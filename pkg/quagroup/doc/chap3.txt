  
  [1X3 QuaGroup[0X
  
  In this chapter we describe the functionality provided by [5XQuaGroup[0m.
  
  
  [1X3.1 Global constants[0X
  
  [1X3.1-1 QuantumField[0m
  
  [2X> QuantumField_______________________________________________[0Xglobal variable
  
  This is the field Q(q) of rational functions in q, over Q.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> QuantumField;[0X
    [4XQuantumField[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.1-2 _q[0m
  
  [2X> _q_________________________________________________________[0Xglobal variable
  
  This is an indeterminate; [3XQuantumField[0m is the field of rational functions in
  this  indeterminate. The identifier [3X_q[0m is fixed once the package [5XQuaGroup[0m is
  loaded.  The  symbol [3X_q[0m is chosen (instead of [3Xq[0m) in order to avoid potential
  name clashes. We note that [3X_q[0m is printed as [3Xq[0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> _q;[0X
    [4Xq[0X
    [4Xgap> _q in QuantumField;[0X
    [4Xtrue[0X
  [4X------------------------------------------------------------------[0X
  
  
  [1X3.2 Gaussian integers[0X
  
  [1X3.2-1 GaussNumber[0m
  
  [2X> GaussNumber( [0X[3Xn, par[0X[2X ) ___________________________________________[0Xoperation
  
  This function computes for the integer [3Xn[0m the Gaussian integer [n]_v=[3Xpar[0m (cf.
  Section [14X2.1[0m).
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> GaussNumber( 4, _q );[0X
    [4Xq^-3+q^-1+q+q^3[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.2-2 GaussianFactorial[0m
  
  [2X> GaussianFactorial( [0X[3Xn, par[0X[2X ) _____________________________________[0Xoperation
  
  This function computes for the integer [3Xn[0m the Gaussian factorial [n]!_v=[3Xpar[0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> GaussianFactorial( 3, _q );[0X
    [4Xq^-3+2*q^-1+2*q+q^3[0X
    [4Xgap> GaussianFactorial( 3, _q^2 );[0X
    [4Xq^-6+2*q^-2+2*q^2+q^6[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.2-3 GaussianBinomial[0m
  
  [2X> GaussianBinomial( [0X[3Xn, k, par[0X[2X ) ___________________________________[0Xoperation
  
  This  function  computes  for  two  integers [3Xn[0m and [3Xk[0m the Gaussian binomial [3Xn[0m
  choose [3Xk[0m, where the parameter v is replaced by [3Xpar[0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> GaussianBinomial( 5, 2, _q^2 );[0X
    [4Xq^-12+q^-8+2*q^-4+2+2*q^4+q^8+q^12[0X
  [4X------------------------------------------------------------------[0X
  
  
  [1X3.3 Roots and root systems[0X
  
  In  this  section  we describe some functions for dealing with root systems.
  These functions supplement the ones already present in the [5XGAP[0m library.
  
  [1X3.3-1 RootSystem[0m
  
  [2X> RootSystem( [0X[3Xtype, rank[0X[2X ) ________________________________________[0Xoperation
  [2X> RootSystem( [0X[3Xlist[0X[2X ) ______________________________________________[0Xoperation
  
  Here  [3Xtype[0m  is  a capital letter between [3X"A"[0m and [3X"G"[0m, and [3Xrank[0m is a positive
  integer (>= 1 if [3Xtype="A"[0m, >= 2 if [3Xtype="B"[0m, [3X"C"[0m, >= 4 if [3Xtype="D"[0m, 6,7,8 if
  [3Xtype="E"[0m,  4 if [3Xtype="F"[0m, and 2 if [3Xtype="G"[0m). This function returns the root
  system  of  type  [3Xtype[0m  and  rank [3Xrank[0m. In the second form [3Xlist[0m is a list of
  types and ranks, e.g., [3X[ "B", 2, "F", 4, "D", 7 ][0m.
  
  The  root  system  constructed  by  this  function  comes with he attributes
  [3XPositiveRoots[0m,  [3XNegativeRoots[0m,  [3XSimpleSystem[0m, [3XCartanMatrix[0m, [3XBilinearFormMat[0m.
  Here  the  attribute [3XSimpleSystem[0m contains a set of simple roots, written as
  unit  vectors.  [3XPositiveRoots[0m  is  a  list of the positive roots, written as
  linear  combinations  of  the  simple roots, and likewise for [3XNegativeRoots[0m.
  [3XCartanMatrix( R )[0m is the Cartan matrix of the root system [3XR[0m, where the entry
  on  position ( i, j ) is given by < alpha_i, alpha_j^v> where alpha_i is the
  i-th  simple  root. [3XBilinearFormMat( R )[0m is the matrix of the bilinear form,
  where  the  entry on position ( i, j ) is given by ( alpha_i, alpha_j ) (see
  Section [14X2.2[0m).
  
  [3XWeylGroup(  R )[0m returns the Weyl group of the root system [3XR[0m. We refer to the
  [5XGAP[0m reference manual for an overview of the functions for Weyl groups in the
  [5XGAP[0m  library.  We  mention  the  functions  [3XConjugateDominantWeight( W, wt )[0m
  (returns  the  dominant  weight  in  the  [3XW[0m-orbit  of  the  weight  [3Xwt[0m), and
  [3XWeylOrbitIterator(  W,  wt )[0m (returns an iterator for the [3XW[0m-orbit containing
  the  weight  [3Xwt[0m).  We  write  weights  as  integral  linear  combinations of
  fundamental  weights, so in [5XGAP[0m weights are represented by lists of integers
  (of length equal to the rank of the root system).
  
  Also  we  mention  the function [3XPositiveRootsAsWeights( R )[0m that returns the
  positive  roots of [3XR[0m written as weights, i.e., as linear combinations of the
  fundamental weights.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> R:=RootSystem( [ "B", 2, "F", 4, "E", 6 ] );[0X
    [4X<root system of type B2 F4 E6>[0X
    [4Xgap> R:= RootSystem( "A", 2 );[0X
    [4X<root system of type A2>[0X
    [4Xgap> PositiveRoots( R );[0X
    [4X[ [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ][0X
    [4Xgap> BilinearFormMat( R );[0X
    [4X[ [ 2, -1 ], [ -1, 2 ] ][0X
    [4Xgap> W:= WeylGroup( R );[0X
    [4XGroup([ [ [ -1, 1 ], [ 0, 1 ] ], [ [ 1, 0 ], [ 1, -1 ] ] ])[0X
    [4Xgap> ConjugateDominantWeight( W, [-3,2] );[0X
    [4X[ 2, 1 ][0X
    [4Xgap> o:= WeylOrbitIterator( W, [-3,2] );[0X
    [4X<iterator>[0X
    [4X# Using the iterator we can loop over the orbit:[0X
    [4Xgap> NextIterator( o );[0X
    [4X[ 2, 1 ][0X
    [4Xgap> NextIterator( o );[0X
    [4X[ -1, -2 ][0X
    [4Xgap> PositiveRootsAsWeights( R );[0X
    [4X[ [ 2, -1 ], [ -1, 2 ], [ 1, 1 ] ][0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.3-2 BilinearFormMatNF[0m
  
  [2X> BilinearFormMatNF( [0X[3XR[0X[2X ) __________________________________________[0Xattribute
  
  This  is  the  matrix of the "normalized" bilinear form. This means that all
  diagonal  entries  are  even,  and  2  is the minimum value occurring on the
  diagonal. If [3XR[0m is a root system constructed by [2XRootSystem[0m ([14X3.3-1[0m), then this
  is equal to [3XBilinearFormMat( R )[0m.
  
  [1X3.3-3 PositiveRootsNF[0m
  
  [2X> PositiveRootsNF( [0X[3XR[0X[2X ) ____________________________________________[0Xattribute
  
  This  is  the list of positive roots of the root system [3XR[0m, written as linear
  combinations  of the simple roots. This means that the simple roots are unit
  vectors.  If [3XR[0m is a root system constructed by [2XRootSystem[0m ([14X3.3-1[0m), then this
  is equal to [3XPositiveRoots( R )[0m.
  
  One  of  the  reasons  for  writing  the  positive  roots  like  this is the
  following.  Let  [3Xa,  b[0m be two elements of [3XPositiveRootsNF( R )[0m, and let [3XB[0m be
  the  matrix  of  the bilinear form. Then [3Xa*( B*b )[0m is the result of applying
  the bilinear form to [3Xa, b[0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> R:= RootSystem( SimpleLieAlgebra( "B", 2, Rationals ) );;[0X
    [4Xgap> PositiveRootsNF( R );[0X
    [4X[ [ 1, 0 ], [ 0, 1 ], [ 1, 1 ], [ 1, 2 ] ][0X
    [4X# We note that in this case PositiveRoots( R ) will give the positive roots in[0X
    [4X# a different format.[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.3-4 SimpleSystemNF[0m
  
  [2X> SimpleSystemNF( [0X[3XR[0X[2X ) _____________________________________________[0Xattribute
  
  This  is  the list of simple roots of [3XR[0m, written as unit vectors (this means
  that  they  are  elements  of  [3XPositiveRootsNF(  R )[0m). If [3XR[0m is a root system
  constructed by [2XRootSystem[0m ([14X3.3-1[0m), then this is equal to [3XSimpleSystem( R )[0m.
  
  [1X3.3-5 PositiveRootsInConvexOrder[0m
  
  [2X> PositiveRootsInConvexOrder( [0X[3XR[0X[2X ) _________________________________[0Xattribute
  
  This  function  returns  the  positive  roots  of  the root system [3XR[0m, in the
  "convex"  order. Let w_0=s_1cdots s_t be a reduced expression of the longest
  element  in  the  Weyl  group. Then the k-th element of the list returned by
  this function is s_1cdots s_k-1(alpha_k). (Where the reduced expression used
  is  the one returned by [3XLongestWeylWord( R )[0m.) If alpha, beta and alpha+beta
  are  positive  roots,  then alpha+beta occurs between alpha and beta (whence
  the name convex order).
  
  In  the  output all roots are written in "normal form", i.e., as elements of
  [3XPositiveRootsNF( R )[0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> R:= RootSystem( "G", 2 );;[0X
    [4Xgap> PositiveRootsInConvexOrder( R );[0X
    [4X[ [ 1, 0 ], [ 3, 1 ], [ 2, 1 ], [ 3, 2 ], [ 1, 1 ], [ 0, 1 ] ][0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.3-6 SimpleRootsAsWeights[0m
  
  [2X> SimpleRootsAsWeights( [0X[3XR[0X[2X ) _______________________________________[0Xattribute
  
  Returns   the  simple  roots  of  the  root  system  [3XR[0m,  written  as  linear
  combinations of the fundamental weights.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> R:= RootSystem( "A", 2 );;[0X
    [4Xgap> SimpleRootsAsWeights( R );[0X
    [4X[ [ 2, -1 ], [ -1, 2 ] ][0X
  [4X------------------------------------------------------------------[0X
  
  
  [1X3.4 Weyl groups and their elements[0X
  
  Now  we  describe  a  few functions that deal with reduced words in the Weyl
  group of the root system [3XR[0m. These words are represented as lists of positive
  integers  i,  denoting  the i-th simple reflection (which corresponds to the
  i-th element of [3XSimpleSystem( R )[0m). For example [3X[ 3, 2, 1, 3, 1 ][0m represents
  the expression s_3 s_2 s_1 s_3 s_1.
  
  [1X3.4-1 ApplyWeylElement[0m
  
  [2X> ApplyWeylElement( [0X[3XW, wt, wd[0X[2X ) ___________________________________[0Xoperation
  
  Here [3Xwd[0m is a (not necessarily reduced) word in the Weyl group [3XW[0m, and [3Xwt[0m is a
  weight  (written as integral linear combination of the simple weights). This
  function returns the result of applying [3Xwd[0m to [3Xwt[0m. For example, if [3Xwt=[0mmu, and
  [3Xwd = [ 1, 2 ][0m then this function returns s_1s_2(mu) (where s_i is the simple
  reflection corresponding to the i-th simple root).
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> W:= WeylGroup( RootSystem( "G", 2 ) ) ;;[0X
    [4Xgap> ApplyWeylElement( W, [ -3, 7 ], [ 1, 1, 2, 1, 2 ] );[0X
    [4X[ 15, -11 ][0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.4-2 LengthOfWeylWord[0m
  
  [2X> LengthOfWeylWord( [0X[3XW, wd[0X[2X ) _______________________________________[0Xoperation
  
  Here  [3Xwd[0m  is a word in the Weyl group [3XW[0m. This function returns the length of
  that word.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> W:= WeylGroup( RootSystem( "F", 4 ) ) ;[0X
    [4X<matrix group with 4 generators>[0X
    [4Xgap> LengthOfWeylWord( W, [ 1, 3, 2, 4, 2 ] );[0X
    [4X3[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.4-3 LongestWeylWord[0m
  
  [2X> LongestWeylWord( [0X[3XR[0X[2X ) ____________________________________________[0Xattribute
  
  Here  [3XR[0m  is  a root system. [3XLongestWeylWord( R )[0m returns the longest word in
  the Weyl group of [3XR[0m.
  
  If this function is called for a root system [3XR[0m, a reduced expression for the
  longest  element  in  the  Weyl  group  is  calculated (the one which is the
  smallest  in  the  lexicographical  ordering). However, if you would like to
  work  with  a different reduced expression, then it is possible to set it by
  [3XSetLongestWeylWord( R, wd )[0m, where [3Xwd[0m is a reduced expression of the longest
  element in the Weyl group. Note that you will have to do this before calling
  [3XLongestWeylWord[0m,  or  any  function  that may call [3XLongestWeylWord[0m (once the
  attribute  is set, it will not be possible to change it). Note also that you
  must  be sure that the word you give is in fact a reduced expression for the
  longest  element  in  the  Weyl group, as this is not checked (you can check
  this with [2XLengthOfWeylWord[0m ([14X3.4-2[0m)).
  
  We  note  that  virtually  all  algorithms for quantized enveloping algebras
  depend  on  the  choice of reduced expression for the longest element in the
  Weyl group (as the PBW-type basis depends on this).
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> R:= RootSystem( "G", 2 );;[0X
    [4Xgap> LongestWeylWord( R );[0X
    [4X[ 1, 2, 1, 2, 1, 2 ][0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.4-4 ReducedWordIterator[0m
  
  [2X> ReducedWordIterator( [0X[3XW, wd[0X[2X ) ____________________________________[0Xoperation
  
  Here  [3XW[0m  is  a  Weyl  group, and [3Xwd[0m a reduced word. This function returns an
  iterator for the set of reduced words that represent the same element as [3Xwd[0m.
  The elements are output in ascending lexicographical order.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> R:= RootSystem( "F", 4 );;[0X
    [4Xgap> it:= ReducedWordIterator( WeylGroup(R), LongestWeylWord(R) );[0X
    [4X<iterator>[0X
    [4Xgap> NextIterator( it );[0X
    [4X[ 1, 2, 1, 3, 2, 1, 3, 2, 3, 4, 3, 2, 1, 3, 2, 3, 4, 3, 2, 1, 3, 2, 3, 4 ][0X
    [4Xgap> k:= 1;;[0X
    [4Xgap> while not IsDoneIterator( it ) do[0X
    [4X> k:= k+1; w:= NextIterator( it );[0X
    [4X> od;[0X
    [4Xgap> k;[0X
    [4X2144892[0X
  [4X------------------------------------------------------------------[0X
  
  So there are 2144892 reduced expressions for the longest element in the Weyl
  group of type F_4.
  
  [1X3.4-5 ExchangeElement[0m
  
  [2X> ExchangeElement( [0X[3XW, wd, ind[0X[2X ) ___________________________________[0Xoperation
  
  Here  [3XW[0m  is a Weyl group, and [3Xwd[0m is a [13Xreduced[0m word in [3XW[0m, and [3Xind[0m is an index
  between  1  and  the rank of the root system. Let [3Xv[0m denote the word obtained
  from [3Xwd[0m by adding [3Xind[0m at the end. This function [13Xassumes[0m that the length of [3Xv[0m
  is  one  less  than the length of [3Xwd[0m, and returns a reduced expression for [3Xv[0m
  that is obtained from [3Xwd[0m by deleting one entry. Nothing is guaranteed of the
  output if the length of [3Xv[0m is bigger than the length of [3Xwd[0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> R:= RootSystem( "G", 2 );;[0X
    [4Xgap> wd:= LongestWeylWord( R );;[0X
    [4Xgap> ExchangeElement( WeylGroup(R), wd, 1 );[0X
    [4X[ 2, 1, 2, 1, 2 ][0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.4-6 GetBraidRelations[0m
  
  [2X> GetBraidRelations( [0X[3XW, wd1, wd2[0X[2X ) ________________________________[0Xoperation
  
  Here  [3XW[0m is a Weyl group, and [3Xwd1[0m, [3Xwd2[0m are two reduced words representing the
  same  element in [3XW[0m. This function returns a list of braid relations that can
  be  applied  to [3Xwd1[0m to obtain [3Xwd2[0m. Here a braid relation is represented as a
  list, with at the odd positions integers that represent positions in a word,
  and  at  the  even  positions  the indices that are on those positions after
  applying  the relation. For example, let [3Xwd[0m be the word [3X[ 1, 2, 1, 3, 2, 1 ][0m
  and  let  [3Xr = [ 3, 3, 4, 1 ][0m be a relation. Then the result of applying [3Xr[0m to
  [3Xwd[0m  is  [3X[  1, 2, 3, 1, 2, 1][0m (i.e., on the third position we put a 3, and on
  the fourth position a 1).
  
  We note that the function does not check first whether [3Xwd1[0m and [3Xwd2[0m represent
  the  same  element  in  [3XW[0m. If this is not the case, then an error will occur
  during the execution of the function, or it will produce wrong output.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> R:= RootSystem( "A", 3 );;[0X
    [4Xgap> wd1:= LongestWeylWord( R );[0X
    [4X[ 1, 2, 1, 3, 2, 1 ][0X
    [4Xgap> wd2:= [ 1, 3, 2, 1, 3, 2 ];;[0X
    [4Xgap> GetBraidRelations( WeylGroup(R), wd1, wd2 );[0X
    [4X[ [ 3, 3, 4, 1 ], [ 4, 2, 5, 1, 6, 2 ], [ 2, 3, 3, 2, 4, 3 ],[0X
    [4X  [ 4, 1, 5, 3 ] ][0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.4-7 LongWords[0m
  
  [2X> LongWords( [0X[3XR[0X[2X ) __________________________________________________[0Xattribute
  
  For  a  root system [3XR[0m this returns a list of triples (of length equal to the
  rank  of  [3XR[0m).  Let  [3Xt[0m  be  the [3Xk[0m-th triple occurring in this list. The first
  element  of  [3Xt[0m  is  an expression for the longest element of the Weyl group,
  starting  with  [3Xk[0m.  The  second element is a list of braid relations, moving
  this expression to the value of [3XLongestWeylWord( R )[0m. The third element is a
  list of braid relations performing the reverse transformation.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> R:= RootSystem( "A", 3 );;[0X
    [4Xgap> LongWords( R )[3];[0X
    [4X[ [ 3, 1, 2, 1, 3, 2 ],[0X
    [4X  [ [ 3, 3, 4, 1 ], [ 4, 2, 5, 1, 6, 2 ], [ 2, 3, 3, 2, 4, 3 ],[0X
    [4X      [ 4, 1, 5, 3 ], [ 1, 3, 2, 1 ] ],[0X
    [4X  [ [ 4, 3, 5, 1 ], [ 1, 1, 2, 3 ], [ 2, 2, 3, 3, 4, 2 ],[0X
    [4X      [ 4, 1, 5, 2, 6, 1 ], [ 3, 1, 4, 3 ] ] ][0X
  [4X------------------------------------------------------------------[0X
  
  
  [1X3.5 Quantized enveloping algebras[0X
  
  In  [5XQuaGroup[0m  we  deal with two types of quantized enveloping algebra. First
  there   are  the  quantized  enveloping  algebras  defined  over  the  field
  [2XQuantumField[0m  ([14X3.1-1[0m).  We  say  that these algebras are "generic" quantized
  enveloping  algebras,  in  [5XQuaGroup[0m  they  have  the category [3XIsGenericQUEA[0m.
  Secondly,  we  deal  with the quantized enveloping algebras that are defined
  over a different field.
  
  [1X3.5-1 QuantizedUEA[0m
  
  [2X> QuantizedUEA( [0X[3XR[0X[2X ) _______________________________________________[0Xattribute
  [2X> QuantizedUEA( [0X[3XR, F, v[0X[2X ) _________________________________________[0Xoperation
  [2X> QuantizedUEA( [0X[3XL[0X[2X ) _______________________________________________[0Xattribute
  [2X> QuantizedUEA( [0X[3XL, F, v[0X[2X ) _________________________________________[0Xoperation
  
  In  the  first  two  forms  [3XR[0m  is  a  root system. With only [3XR[0m as input, the
  corresponding  generic  quantized  enveloping  algebra is constructed. It is
  stored as an attribute of [3XR[0m (so that constructing it twice for the same root
  system  yields  the  same  object).  Also  the  root system is stored in the
  quantized enveloping algebra as the attribute [3XRootSystem[0m.
  
  The  attribute  [3XGeneratorsOfAlgebra[0m  contains  the  generators of a PBW-type
  basis  (see  Section  [14X2.4[0m),  that  are  constructed  relative to the reduced
  expression  for  the  longest element in the Weyl group that is contained in
  [3XLongestWeylWord(  R  )[0m. We refer to [2XObjByExtRep[0m ([14X3.5-2[0m) for a description of
  the construction of elements of a quantized enveloping algebra.
  
  The  call [3XQuantizedUEA( R, F, v )[0m returns the quantized universal enveloping
  algebra  with  quantum  parameter  [3Xv[0m, which must lie in the field [3XF[0m. In this
  case the elements of [3XGeneratorsOfAlgebra[0m are the images of the generators of
  the corresponding generic quantized enveloping algebra. This means that if [3Xv[0m
  is a root of unity, then the generators will not generate the whole algebra,
  but  rather  a  finite dimensional subalgebra (as for instance E_i^k=0 for k
  large  enough). It is possible to construct elements that do not lie in this
  finite dimensional subalgebra using [2XObjByExtRep[0m ([14X3.5-2[0m).
  
  In  the last two cases [3XL[0m must be a semisimple Lie algebra. The two calls are
  short for [3XQuantizedUEA( RootSystem( L ) )[0m and [3XQuantizedUEA( RootSystem( L ),
  F, v )[0m respectively.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4X# We construct the generic quantized enveloping algebra corresponding[0X
    [4X# to the root system of type A2+G2:[0X
    [4Xgap> R:= RootSystem( [ "A", 2, "G", 2 ] );;[0X
    [4Xgap> U:= QuantizedUEA( R );[0X
    [4XQuantumUEA( <root system of type A2 G2>, Qpar = q )[0X
    [4Xgap> RootSystem( U );[0X
    [4X<root system of type A2 G2>[0X
    [4Xgap> g:= GeneratorsOfAlgebra( U );[0X
    [4X[ F1, F2, F3, F4, F5, F6, F7, F8, F9, K1, K1+(q^-1-q)*[ K1 ; 1 ], K2,[0X
    [4X  K2+(q^-1-q)*[ K2 ; 1 ], K3, K3+(q^-1-q)*[ K3 ; 1 ], K4,[0X
    [4X  K4+(q^-3-q^3)*[ K4 ; 1 ], E1, E2, E3, E4, E5, E6, E7, E8, E9 ][0X
    [4X# These elements generate a PBW-type basis of U; the nine elements Fi,[0X
    [4X# and the nine elements Ei correspond to the roots listed in convex order:[0X
    [4Xgap> PositiveRootsInConvexOrder( R );[0X
    [4X[ [ 1, 0, 0, 0 ], [ 1, 1, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 1, 0 ],[0X
    [4X  [ 0, 0, 3, 1 ], [ 0, 0, 2, 1 ], [ 0, 0, 3, 2 ], [ 0, 0, 1, 1 ],[0X
    [4X  [ 0, 0, 0, 1 ] ][0X
    [4X# So, for example, F5 is an element of weight -[ 0, 0, 3, 1 ].[0X
    [4X# We can also multiply elements; the result is written on the PBW-basis:[0X
    [4Xgap> g[17]*g[4];[0X
    [4X(q^-6-1)*F4*[ K4 ; 1 ]+(q^-3)*F4*K4[0X
    [4X# Now we construct a non-generic quantized enveloping algebra:[0X
    [4Xgap> R:= RootSystem( "A", 2 );;[0X
    [4Xgap> U:= QuantizedUEA( R, CF(3), E(3) );;[0X
    [4Xgap> g:= GeneratorsOfAlgebra( U );[0X
    [4X[ F1, F2, F3, K1, K1+(-E(3)+E(3)^2)*[ K1 ; 1 ], K2,[0X
    [4X  K2+(-E(3)+E(3)^2)*[ K2 ; 1 ], E1, E2, E3 ][0X
  [4X------------------------------------------------------------------[0X
  
  As  can  be  seen  in the example, every element of U is written as a linear
  combination  of  monomials in the PBW-generators; the generators of U^- come
  first, then the generators of U^0, and finally the generators of U^+.
  
  [1X3.5-2 ObjByExtRep[0m
  
  [2X> ObjByExtRep( [0X[3Xfam, list[0X[2X ) ________________________________________[0Xoperation
  
  Here  [3Xfam[0m  is  the  elements  family  of  a  quantized enveloping algebra [3XU[0m.
  Secondly,  [3Xlist[0m  is  a  list describing an element of [3XU[0m. We explain how this
  description  works.  First we describe an indexing system for the generators
  of  [3XU[0m. Let [3XR[0m be the root system of [3XU[0m. Let [3Xt[0m be the number of positive roots,
  and  [3Xrank[0m  the  rank of the root system. Then the generators of [3XU[0m are [3XFk[0m, [3XKi[0m
  (and  its  inverse),  [3XEk[0m,  for [3Xk=1...t[0m, [3Xi=1..rank[0m. (See Section [14X2.4[0m; for the
  construction  of the [3XFk[0m, [3XEk[0m, the value of [3XLongestWeylWord( R )[0m is used.) Now
  the index of [3XFk[0m is [3Xk[0m, and the index of [3XEk[0m is [3Xt+rank+k[0m. Furthermore, elements
  of  the  algebra generated by the [3XKi[0m, and its inverse, are written as linear
  combinations of products of "binomials", as in Section [14X2.5[0m. The element
  
  
       K_i^{d}\begin{bmatrix} K_{i} \\ s \end{bmatrix}
  
  
  (where  d=0,1), is indexed as [3X[ t+i, d ][0m (what happens to the [3Xs[0m is described
  later). So an index is either an integer, or a list of two integers.
  
  A  monomial  is  a list of indices, each followed by an exponent. First come
  the  indices  of the [3XFk[0m, ([3X1..t[0m), then come the lists of the form [3X[ t+i, d ][0m,
  and finally the indices of the [3XEk[0m. Each index is followed by an exponent. An
  index of the form [3X[ t+i, d ][0m is followed by the [3Xs[0m in the above formula.
  
  The  second  argument  of  [3XObjByExtRep[0m  is  a  list of monomials followed by
  coefficients. This function returns the element of [3XU[0m described by this list.
  
  Finally we remark that the element
  
  
       K_i^{d}\begin{bmatrix} K_{i} \\ s \end{bmatrix}
  
  
  is printed as [3XKi[ Ki ; s ][0m if [3Xd=1[0m, and as [3X[ Ki ; s ][0m if [3Xd=0[0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> U:= QuantizedUEA( RootSystem("A",2) );;[0X
    [4Xgap> fam:= ElementsFamily( FamilyObj( U ) );;[0X
    [4Xgap> list:= [ [ 2, 3, [ 4, 0 ], 8, 6, 11 ], _q^2,    # monomial and coefficient[0X
    [4X> [ 1, 7, 3, 5, [ 5, 1 ], 3, 8, 9 ], _q^-1 + _q^2 ]; # monomial and coefficient[0X
    [4X[ [ 2, 3, [ 4, 0 ], 8, 6, 11 ], q^2, [ 1, 7, 3, 5, [ 5, 1 ], 3, 8, 9 ],[0X
    [4X  q^-1+q^2 ][0X
    [4Xgap> ObjByExtRep( fam, list );[0X
    [4X(q^2)*F2^(3)*[ K1 ; 8 ]*E1^(11)+(q^-1+q^2)*F1^(7)*F3^(5)*K2[ K2 ; 3 ]*E3^(9)[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.5-3 ExtRepOfObj[0m
  
  [2X> ExtRepOfObj( [0X[3Xelm[0X[2X ) ______________________________________________[0Xoperation
  
  For the element [3Xelm[0m of a quantized enveloping algebra, this function returns
  the list that defines [3Xelm[0m (see [2XObjByExtRep[0m ([14X3.5-2[0m)).
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> U:= QuantizedUEA( RootSystem("A",2) );;[0X
    [4Xgap> g:= GeneratorsOfAlgebra(U);[0X
    [4X[ F1, F2, F3, K1, K1+(q^-1-q)*[ K1 ; 1 ], K2, K2+(q^-1-q)*[ K2 ; 1 ], E1,[0X
    [4X  E2, E3 ][0X
    [4Xgap> ExtRepOfObj( g[5] );[0X
    [4X[ [ [ 4, 1 ], 0 ], 1, [ [ 4, 0 ], 1 ], q^-1-q ][0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.5-4 QuantumParameter[0m
  
  [2X> QuantumParameter( [0X[3XU[0X[2X ) ___________________________________________[0Xattribute
  
  Returns the quantum parameter used in the definition of [3XU[0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> R:= RootSystem("A",2);;[0X
    [4Xgap> U0:= QuantizedUEA( R, CF(3), E(3) );;[0X
    [4Xgap> QuantumParameter( U0 );[0X
    [4XE(3)[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.5-5 CanonicalMapping[0m
  
  [2X> CanonicalMapping( [0X[3XU[0X[2X ) ___________________________________________[0Xattribute
  
  Here  [3XU[0m  is  a quantized enveloping algebra. Let [3XU0[0m denote the corresponding
  "generic" quantized enveloping algebra. This function returns the mapping [3XU0
  -->  U[0m  obtained  by mapping [3Xq[0m (which is the quantum parameter of [3XU0[0m) to the
  quantum parameter of [3XU[0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> R:= RootSystem("A", 3 );;[0X
    [4Xgap> U:= QuantizedUEA( R, CF(5), E(5) );;[0X
    [4Xgap> f:= CanonicalMapping( U );[0X
    [4XMappingByFunction( QuantumUEA( <root system of type A[0X
    [4X3>, Qpar = q ), QuantumUEA( <root system of type A3>, Qpar =[0X
    [4XE(5) ), function( u ) ... end )[0X
    [4Xgap> U0:= Source( f );[0X
    [4XQuantumUEA( <root system of type A3>, Qpar = q )[0X
    [4Xgap> g:= GeneratorsOfAlgebra( U0 );;[0X
    [4Xgap> u:= g[18]*g[9]*g[6];[0X
    [4X(q^2)*F6*K2*E6+(q)*K2*[ K3 ; 1 ][0X
    [4Xgap> Image( f, u );[0X
    [4X(E(5)^2)*F6*K2*E6+(E(5))*K2*[ K3 ; 1 ][0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.5-6 WriteQEAToFile[0m
  
  [2X> WriteQEAToFile( [0X[3XU, file[0X[2X ) _______________________________________[0Xoperation
  
  Here  [3XU[0m  is  a quantized enveloping algebra, and file is a string containing
  the  name  of  a  file.  This function writes some data to [3Xfile[0m, that allows
  [2XReadQEAFromFile[0m ([14X3.5-7[0m) to recover it.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> U:= QuantizedUEA( RootSystem("A",3) );;[0X
    [4Xgap> WriteQEAToFile( U, "/home/wdg/A3" );[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.5-7 ReadQEAFromFile[0m
  
  [2X> ReadQEAFromFile( [0X[3Xfile[0X[2X ) _________________________________________[0Xoperation
  
  Here  [3Xfile[0m  is  a string containing the name of a file, to which a quantized
  enveloping algebra has been written by [2XWriteQEAToFile[0m ([14X3.5-6[0m). This function
  recovers the quantized enveloping algebra.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> U:= QuantizedUEA( RootSystem("A",3) );;[0X
    [4Xgap> WriteQEAToFile( U, "/home/wdg/A3" );[0X
    [4Xgap> U0:= ReadQEAFromFile( "/home/wdg/A3" );[0X
    [4XQuantumUEA( <root system of type A3>, Qpar = q )[0X
  [4X------------------------------------------------------------------[0X
  
  
  [1X3.6 Homomorphisms and automorphisms[0X
  
  Here    we    describe    functions    for    creating   homomorphisms   and
  (anti)-automorphisms of a quantized enveloping algebra.
  
  [1X3.6-1 QEAHomomorphism[0m
  
  [2X> QEAHomomorphism( [0X[3XU, A, list[0X[2X ) ___________________________________[0Xoperation
  
  Here  [3XU[0m  is  a  generic  quantized  enveloping  algebra  (i.e., with quantum
  parameter  [3X_q[0m),  [3XA[0m  is  an algebra with one over [3XQuantumField[0m, and [3Xlist[0m is a
  list  of  [3X4*rank[0m elements of [3XA[0m (where [3Xrank[0m is the rank of the root system of
  [3XU[0m).  On  the first rank positions there are the images of the F_alpha (where
  the  alpha  are  simple  roots,  listed  in the order in which they occur in
  [3XSimpleSystem(  R  )[0m). On the positions [3Xrank+1...2*rank[0m are the images of the
  K_alpha.   On   the  positions  [3X2*rank+1...3*rank[0m  are  the  images  of  the
  K_alpha^-1,  and finally on the positions [3X3*rank+1...4*rank[0m occur the images
  of the E_alpha.
  
  This  function returns the homomorphism [3XU -> A[0m, defined by this data. In the
  example  below  we  construct  a  homomorphism from one quantized enveloping
  algebra into another. Both are constructed relative to the same root system,
  but  with  different reduced expressions for the longest element of the Weyl
  group.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> R:= RootSystem( "G", 2 );;[0X
    [4Xgap> SetLongestWeylWord( R, [1,2,1,2,1,2] );[0X
    [4Xgap> UR:= QuantizedUEA( R );;[0X
    [4Xgap> S:= RootSystem( "G", 2 );;[0X
    [4Xgap> SetLongestWeylWord( S, [2,1,2,1,2,1] );[0X
    [4Xgap> US:= QuantizedUEA( S );;[0X
    [4Xgap> gS:= GeneratorsOfAlgebra( US );[0X
    [4X[ F1, F2, F3, F4, F5, F6, K1, K1+(q^-1-q)*[ K1 ; 1 ], K2,[0X
    [4X  K2+(q^-3-q^3)*[ K2 ; 1 ], E1, E2, E3, E4, E5, E6 ][0X
    [4Xgap> SimpleSystem( R );[0X
    [4X[ [ 1, 0 ], [ 0, 1 ] ][0X
    [4Xgap> PositiveRootsInConvexOrder( S );[0X
    [4X[ [ 0, 1 ], [ 1, 1 ], [ 3, 2 ], [ 2, 1 ], [ 3, 1 ], [ 1, 0 ] ][0X
    [4X# We see that the simple roots of R occur on positions 6 and 1[0X
    [4X# in the list PositiveRootsInConvexOrder( S ); This means that we[0X
    [4X# get the following list of images of the homomorphism:[0X
    [4Xgap> imgs:= [ gS[6], gS[1],      # the images of the F_{\alpha}[0X
    [4X> gS[7], gS[9],                  # the images of the K_{\alpha}[0X
    [4X> gS[8], gS[10],                 # the images of the K_{\alpha}^{-1}[0X
    [4X> gS[16], gS[11] ];              # the images of the E_{\alpha}[0X
    [4X[ F6, F1, K1, K2, K1+(q^-1-q)*[ K1 ; 1 ], K2+(q^-3-q^3)*[ K2 ; 1 ], E6, E1[0X
    [4X ][0X
    [4Xgap> h:= QEAHomomorphism( UR, US, imgs );[0X
    [4X<homomorphism: QuantumUEA( <root system of type G[0X
    [4X2>, Qpar = q ) -> QuantumUEA( <root system of type G2>, Qpar = q )>[0X
    [4Xgap> Image( h, GeneratorsOfAlgebra( UR )[3] );[0X
    [4X(1-q^4-q^6+q^10)*F1*F6^(2)+(-q^2+q^6)*F2*F6+(q^4)*F4[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.6-2 QEAAutomorphism[0m
  
  [2X> QEAAutomorphism( [0X[3XU, list[0X[2X ) ______________________________________[0Xoperation
  [2X> QEAAutomorphism( [0X[3XU, f[0X[2X ) _________________________________________[0Xoperation
  
  In  the  first  form [3XU[0m is a generic quantized enveloping algebra (i.e., with
  quantum  parameter  [3X_q[0m),  and  [3Xlist[0m is a list of [3X4*rank[0m elements of [3XU[0m (where
  [3Xrank[0m  is  the  rank  of  the  corresponding  root system). On the first [3Xrank[0m
  positions  there  are  the images of the F_alpha (where the alpha are simple
  roots, listed in the order in which they occur in [3XSimpleSystem( R )[0m). On the
  positions  [3Xrank+1...2*rank[0m  are  the images of the K_alpha. On the positions
  [3X2*rank+1...3*rank[0m  are  the  images  of  the  K_alpha^-1, and finally on the
  positions [3X3*rank+1...4*rank[0m occur the images of the E_alpha.
  
  In the second form [3XU[0m is a non-generic quantized enveloping algebra, and [3Xf[0m is
  an  automorphism  of the corresponding generic quantized enveloping algebra.
  The  corresponding automorphism of [3XU[0m is constructed. In this case [3Xf[0m must not
  be  the  bar-automorphism  of the corresponding generic quantized enveloping
  algebra  (cf. [2XBarAutomorphism[0m ([14X3.6-6[0m)), as this automorphism doesn't work in
  the non-generic case.
  
  The image of an element [3Xx[0m under an automorphism [3Xf[0m is computed by [3XImage( f, x
  )[0m.  Note  that  there  is no function for calculating pre-images (in general
  this  seems  to  be  a  very  hard  task).  If  you  want  the inverse of an
  automorphism, you have to construct it explicitly (e.g., by [3XQEAAutomorphism(
  U, list )[0m, where [3Xlist[0m is a list of pre-images).
  
  Below we construct the automorphism omega (cf. Section [14X2.2[0m) of the quantized
  enveloping  of  type  A_3,  when  the  quantum parameter is [3X_q[0m, and when the
  quantum parameter is a fifth root of unity.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4X# First we construct the quantized enveloping algebra:[0X
    [4Xgap> R:= RootSystem( "A", 3 );;[0X
    [4Xgap> U0:= QuantizedUEA( R );[0X
    [4XQuantumUEA( <root system of type A3>, Qpar = q )[0X
    [4Xgap> g:= GeneratorsOfAlgebra( U0 );[0X
    [4X[ F1, F2, F3, F4, F5, F6, K1, K1+(q^-1-q)*[ K1 ; 1 ], K2,[0X
    [4X  K2+(q^-1-q)*[ K2 ; 1 ], K3, K3+(q^-1-q)*[ K3 ; 1 ], E1, E2, E3, E4, E5, E6 ][0X
    [4X# Now, for instance, we map F_{\alpha} to E_{\alpha}, where \alpha[0X
    [4X# is a simple root. In order to find where those F_{\alpha}, E_{\alpha}[0X
    [4X# are in the list of generators, we look at the list of positive roots[0X
    [4X# in convex order:[0X
    [4Xgap> PositiveRootsInConvexOrder( R );[0X
    [4X[ [ 1, 0, 0 ], [ 1, 1, 0 ], [ 0, 1, 0 ], [ 1, 1, 1 ], [ 0, 1, 1 ],[0X
    [4X  [ 0, 0, 1 ] ][0X
    [4X# So the simple roots occur on positions 1, 3, 6. This means that we[0X
    [4X# have the following list of images:[0X
    [4Xgap> imgs:= [ g[13], g[15], g[18], g[8], g[10], g[12], g[7], g[9], g[11],[0X
    [4X> g[1], g[3], g[6] ];[0X
    [4X[ E1, E3, E6, K1+(q^-1-q)*[ K1 ; 1 ], K2+(q^-1-q)*[ K2 ; 1 ],[0X
    [4X  K3+(q^-1-q)*[ K3 ; 1 ], K1, K2, K3, F1, F3, F6 ][0X
    [4Xgap> f:= QEAAutomorphism( U0, imgs );[0X
    [4X<automorphism of QuantumUEA( <root system of type A3>, Qpar = q )>[0X
    [4Xgap> Image( f, g[2] );[0X
    [4X(-q)*E2[0X
    [4X# f induces an automorphism of any non-generic quantized enveloping[0X
    [4X# algebra with the same root system R:[0X
    [4Xgap> U1:= QuantizedUEA( R, CF(5), E(5) );[0X
    [4XQuantumUEA( <root system of type A3>, Qpar = E(5) )[0X
    [4Xgap> h:= QEAAutomorphism( U1, f );[0X
    [4X<automorphism of QuantumUEA( <root system of type A3>, Qpar = E(5) )>[0X
    [4Xgap> Image( h, GeneratorsOfAlgebra(U1)[7] );[0X
    [4X(-E(5)+E(5)^4)*[ K1 ; 1 ]+K1[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.6-3 QEAAntiAutomorphism[0m
  
  [2X> QEAAntiAutomorphism( [0X[3XU, list[0X[2X ) __________________________________[0Xoperation
  [2X> QEAAntiAutomorphism( [0X[3XU, f[0X[2X ) _____________________________________[0Xoperation
  
  These   are  functions  for  constructing  anti-automorphisms  of  quantized
  enveloping algebras. The same comments apply as for [2XQEAAutomorphism[0m ([14X3.6-2[0m).
  
  [1X3.6-4 AutomorphismOmega[0m
  
  [2X> AutomorphismOmega( [0X[3XU[0X[2X ) __________________________________________[0Xattribute
  
  This is the automorphism omega (cf. Section [14X2.2[0m).
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> R:= RootSystem( "A", 3 );;[0X
    [4Xgap> U:= QuantizedUEA( R, CF(5), E(5) );[0X
    [4XQuantumUEA( <root system of type A3>, Qpar = E(5) )[0X
    [4Xgap> f:= AutomorphismOmega( U );[0X
    [4X<automorphism of QuantumUEA( <root system of type A3>, Qpar = E(5) )>[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.6-5 AntiAutomorphismTau[0m
  
  [2X> AntiAutomorphismTau( [0X[3X[0X[2X ) _________________________________________[0Xattribute
  
  This is the anti-automorphism tau (cf. Section [14X2.2[0m).
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> R:= RootSystem( "A", 3 );;[0X
    [4Xgap> U:= QuantizedUEA( R, CF(5), E(5) );[0X
    [4XQuantumUEA( <root system of type A3>, Qpar = E(5) )[0X
    [4Xgap> t:= AntiAutomorphismTau( U );[0X
    [4X<anti-automorphism of QuantumUEA( <root system of type A3>, Qpar = E(5) )>[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.6-6 BarAutomorphism[0m
  
  [2X> BarAutomorphism( [0X[3XU[0X[2X ) ____________________________________________[0Xattribute
  
  This  is  the  automorphism  bar~  defined  in  Section [14X2.2[0m Here [3XU[0m must be a
  generic quantized enveloping algebra.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> U:= QuantizedUEA( RootSystem(["A",2,"B",2]) );;[0X
    [4Xgap> bar:= BarAutomorphism( U );[0X
    [4X<automorphism of QuantumUEA( <root system of type A2 B2>, Qpar = q )>[0X
    [4Xgap> Image( bar, GeneratorsOfAlgebra( U )[5] );[0X
    [4X(-q^-2+q^2)*F4*F7+F5[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.6-7 AutomorphismTalpha[0m
  
  [2X> AutomorphismTalpha( [0X[3XU, ind[0X[2X ) ____________________________________[0Xoperation
  
  This  is  the  automorphism  T_alpha  (cf.  Section [14X2.4[0m), where alpha is the
  [3Xind[0m-th simple root.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> U:= QuantizedUEA( RootSystem( "B", 3 ) );;[0X
    [4Xgap> f:=AutomorphismTalpha( U, 1 );[0X
    [4X<automorphism of QuantumUEA( <root system of type B3>, Qpar = q )>[0X
    [4Xgap> a:= GeneratorsOfAlgebra( U )[3];[0X
    [4XF3[0X
    [4Xgap>  Image( f, a );[0X
    [4XF2[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.6-8 DiagramAutomorphism[0m
  
  [2X> DiagramAutomorphism( [0X[3XU, perm[0X[2X ) __________________________________[0Xoperation
  
  This  is  the  automorphism  of  [3XU[0m  induced by a diagram automorphism of the
  underlying  root  system.  The  diagram  automorphism  is represented by the
  permutation  [3Xperm[0m, which is the permutation of the simple roots performed by
  the diagram automorphism.
  
  In  the  example  below  we  construct  the diagram automorphism of the root
  system of type A_3, which is represented by the permutation [3X(1,3)[0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> R:= RootSystem( "A", 3 );;[0X
    [4Xgap> U:= QuantizedUEA( R );;[0X
    [4Xgap> f:= DiagramAutomorphism( U, (1,3) );[0X
    [4X<automorphism of QuantumUEA( <root system of type A3>, Qpar = q )>[0X
    [4Xgap> g:= GeneratorsOfAlgebra( U );[0X
    [4X[ F1, F2, F3, F4, F5, F6, K1, K1+(q^-1-q)*[ K1 ; 1 ], K2,[0X
    [4X  K2+(q^-1-q)*[ K2 ; 1 ], K3, K3+(q^-1-q)*[ K3 ; 1 ], E1, E2, E3, E4, E5, E6[0X
    [4X ][0X
    [4Xgap> Image( f, g[1] );[0X
    [4XF6[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.6-9 \*[0m
  
  [2X> \*( [0X[3Xf, h[0X[2X ) ______________________________________________________[0Xoperation
  
  We  can  compose  automorphisms  and  anti-automorphisms  using  the infix [3X*[0m
  operator.  The result of composing two automorphisms is an automorphism. The
  result   of  composing  an  automorphism  and  an  anti-automorphism  is  an
  anti-automorphism.  The  result  of  composing  two anti-automorphisms is an
  automorphism.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> U:= QuantizedUEA( RootSystem( "B", 3 ) );;[0X
    [4Xgap> f:=AutomorphismTalpha( U, 1 );[0X
    [4X<automorphism of QuantumUEA( <root system of type B3>, Qpar = q )>[0X
    [4Xgap> h:= AutomorphismOmega( U );[0X
    [4X<automorphism of QuantumUEA( <root system of type B3>, Qpar = q )>[0X
    [4Xgap> f*h;[0X
    [4X<automorphism of QuantumUEA( <root system of type B3>, Qpar = q )>[0X
    [4Xgap> t:= AntiAutomorphismTau( U );;[0X
    [4Xgap> T:= AutomorphismTalpha( U, 2 );;[0X
    [4Xgap> Tinv:= t*T*t;[0X
    [4X<automorphism of QuantumUEA( <root system of type B3>, Qpar = q )>[0X
    [4X# (The last call may take a little while.)[0X
    [4Xgap> x:= Image( T, GeneratorsOfAlgebra( U )[1] );[0X
    [4X(1-q^4)*F1*F3+(-q^2)*F2[0X
    [4Xgap> Image( Tinv, x );[0X
    [4XF1[0X
  [4X------------------------------------------------------------------[0X
  
  According  to [Jan96], 8.14(10), tau circ T_alpha circ tau is the inverse of
  T_alpha.
  
  
  [1X3.7 Hopf algebra structure[0X
  
  Here  we describe functions for dealing with the Hopf algebra structure of a
  quantized  enveloping algebra. This structure enables us to construct tensor
  products,  and  dual modules of modules over a quantized enveloping algebra.
  We  refer  to the next section (Section [14X3.8[0m) for some functions for creating
  modules.
  
  [1X3.7-1 TensorPower[0m
  
  [2X> TensorPower( [0X[3XU, d[0X[2X ) _____________________________________________[0Xoperation
  
  Here  [3XU[0m  is  a  quantized universal enveloping algebra, and [3Xd[0m a non-negative
  integer.  This  function  returns  the  associative  algebra with underlying
  vector  space  the  [3Xd[0m-fold  tensor  product of [3XU[0m with itself. The product is
  defined component wise.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> U:= QuantizedUEA( RootSystem( [ "B", 2 ] ) );;[0X
    [4Xgap> T:= TensorPower( U, 3 );[0X
    [4X<algebra over QuantumField, with 36 generators>[0X
    [4Xgap> g:= GeneratorsOfAlgebra( T );;[0X
    [4Xgap> x:= g[1];[0X
    [4X1*(1<x>1<x>F1)[0X
    [4Xgap> y:= g[30];[0X
    [4X1*(E2<x>1<x>1)[0X
    [4Xgap> x*y;[0X
    [4X1*(E2<x>1<x>F1)[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.7-2 UseTwistedHopfStructure[0m
  
  [2X> UseTwistedHopfStructure( [0X[3XU, f, finv[0X[2X ) ___________________________[0Xoperation
  
  Here  [3XU[0m  is  a  quantized  enveloping  algebra,  and  [3Xf[0m,  [3Xfinv[0m  two  (anti-)
  automorphisms  of  [3XU[0m,  where  [3Xfinv[0m  is  the inverse of [3Xf[0m. After calling this
  function  the Hopf structure on [3XU[0m is used that is obtained from the "normal"
  Hopf structure (see Section [14X2.3[0m) by twisting it with [3Xf[0m.
  
  A  call to this function sets the attribute [3XHopfStructureTwist[0m, which is the
  list [3X[ f, finv ][0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> U:= QuantizedUEA( RootSystem("A",2), CF(5), E(5) );;[0X
    [4Xgap> t:= AntiAutomorphismTau( U );;[0X
    [4Xgap> UseTwistedHopfStructure( U, t, t );[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.7-3 ComultiplicationMap[0m
  
  [2X> ComultiplicationMap( [0X[3XU, d[0X[2X ) _____________________________________[0Xoperation
  
  This is a homomorphism from the quantized enveloping algebra [3XU[0m to the [3Xd[0m-fold
  tensor  power  of [3XU[0m with itself. It is obtained by a repeated application of
  the comultiplication of [3XU[0m. So for [3Xd=2[0m we get the comultiplication of [3XU[0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> U:= QuantizedUEA( RootSystem("A",2), CF(5), E(5) );;[0X
    [4Xgap> D:= ComultiplicationMap( U, 3 );[0X
    [4X<Comultiplication of QuantumUEA( <root system of type A2>, Qpar =[0X
    [4XE(5) ), degree 3>[0X
    [4Xgap> Image( D, GeneratorsOfAlgebra(U)[4] );[0X
    [4X1*(K1<x>K1<x>K1)[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.7-4 AntipodeMap[0m
  
  [2X> AntipodeMap( [0X[3XU[0X[2X ) ________________________________________________[0Xattribute
  
  This  is  the  antipode  map of the quantized enveloping algebra [3XU[0m, which is
  constructed as an anti-automorphism of [3XU[0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> U:= QuantizedUEA( RootSystem("A",2), CF(5), E(5) );;[0X
    [4Xgap> a:= AntipodeMap( U );[0X
    [4X<anti-automorphism of QuantumUEA( <root system of type A2>, Qpar = E(5) )>[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.7-5 CounitMap[0m
  
  [2X> CounitMap( [0X[3XU[0X[2X ) __________________________________________________[0Xattribute
  
  This  is  the  counit  map  of  the quantized enveloping algebra [3XU[0m, which is
  constructed as a function from [3XU[0m to the ground field.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> U:= QuantizedUEA( RootSystem("A",2), CF(5), E(5) );;[0X
    [4Xgap> co:= CounitMap( U );[0X
    [4Xfunction( u ) ... end[0X
    [4Xgap> x:= GeneratorsOfAlgebra( U )[4];[0X
    [4XK1[0X
    [4Xgap> co( x );[0X
    [4X1[0X
  [4X------------------------------------------------------------------[0X
  
  
  [1X3.8 Modules[0X
  
  Here we describe some functions for constructing left modules over quantized
  enveloping algebras. We refer to the [5XGAP[0m reference manual for an overview of
  basic  functions  for  algebra  modules,  which  are  also applicable to the
  modules  constructed  by the functions described in this section. We mention
  [3XMatrixOfAction[0m,  [3XDirectSumOfAlgebraModules[0m.  The action of an element of the
  algebra on an element of the module is calculated by the infix operator [3X^[0m.
  
  [1X3.8-1 HighestWeightModule[0m
  
  [2X> HighestWeightModule( [0X[3XU, wt[0X[2X ) ____________________________________[0Xoperation
  
  Here [3XU[0m is a quantized universal enveloping algebra, and [3Xwt[0m a dominant weight
  (i.e.,  a list of length equal to the rank of the root system, consisting of
  non-negative   integers).   This   function   returns  a  finite-dimensional
  highest-weight module of highest weight [3Xwt[0m over [3XU[0m. If [3XU[0m is generic then this
  is  the unique irreducible highest-weight module over [3XU[0m. Otherwise it is the
  Weyl  module,  cf.  Section  [14X2.5[0m.  In  this  last  case  the  module  is not
  necessarily irreducible.
  
  Let  [3XV[0m  denote the module returned by this function. The first basis element
  of  the  attribute  [3XBasis(  V )[0m is a highest-weight vector; it is written as
  [3X1*v0[0m.  Other  basis  elements  are  written as, for example, [3XF2*F9*v0[0m, which
  means  that  this vector is the result of letting the PBW-monomial [3XF2*F9[0m act
  on the highest-weight vector.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> U:= QuantizedUEA( RootSystem( [ "A", 2, "G", 2 ] ) );;[0X
    [4Xgap> V:= HighestWeightModule( U, [ 0, 1, 0, 2 ] );[0X
    [4X<231-dimensional left-module over QuantumUEA( <root system of type A2 G[0X
    [4X2>, Qpar = q )>[0X
    [4Xgap> Basis( V )[1];[0X
    [4X1*v0[0X
    [4Xgap> Basis(V)[23]+(_q^2+_q^-2)*Basis(V)[137];[0X
    [4XF3*F5*v0+(q^-2+q^2)*F8^(6)*v0[0X
    [4X# We compute the action of an element on a vector:[0X
    [4Xgap> gg:= GeneratorsOfAlgebra( U );;[0X
    [4Xgap> x:= gg[21]*gg[5];[0X
    [4XF5*E4+(-q^-1)*F6*K3[0X
    [4Xgap> x^Basis(V)[1];[0X
    [4X(-q^-1)*F6*v0[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.8-2 IrreducibleQuotient[0m
  
  [2X> IrreducibleQuotient( [0X[3XV[0X[2X ) ________________________________________[0Xattribute
  
  Here  [3XV[0m  is  a highest-weight module over a non-generic quantized enveloping
  algebra.  This  function  returns the quotient of [3XV[0m by the maximal submodule
  not containing the highest weight vector. This is not necessarily equal to [3XV[0m
  if the quantum parameter is a root of 1.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> R:= RootSystem( "A", 2 );;[0X
    [4Xgap> U:= QuantizedUEA( R, CF(3), E(3) );;[0X
    [4Xgap> V:= HighestWeightModule( U, [1,1] );[0X
    [4X<8-dimensional left-module over QuantumUEA( <root system of type A2>, Qpar =[0X
    [4XE(3) )>[0X
    [4Xgap> IrreducibleQuotient( V );[0X
    [4X<7-dimensional left-module over QuantumUEA( <root system of type A2>, Qpar =[0X
    [4XE(3) )>[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.8-3 HWModuleByTensorProduct[0m
  
  [2X> HWModuleByTensorProduct( [0X[3XU, wt[0X[2X ) ________________________________[0Xoperation
  
  Here  [3XU[0m  must  be  a [13Xgeneric[0m quantized enveloping algebra, and [3Xwt[0m a dominant
  weight.  This  function  returns  the irreducible highest-weight module with
  highest  weight [3Xwt[0m. The algorithm uses tensor products (whence the name). On
  some   inputs   this   algorithm   is   faster   than   the   one   use  for
  [2XHighestWeightModule:for  a quantized env. alg.[0m ([14X???HighestWeightModule:for a
  quantized env. alg.???[0m), on some inputs it is slower. I do not know any good
  heuristics.
  
  The basis supplied with the module returned is the canonical basis.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> U:= QuantizedUEA( RootSystem("G",2) );;[0X
    [4Xgap> V:= HWModuleByTensorProduct( U, [2,1] );[0X
    [4X<189-dimensional left-module over QuantumUEA( <root system of type G[0X
    [4X2>, Qpar = q )>[0X
    [4X# (This is a case where this algorithm is a lot faster.)[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.8-4 DIYModule[0m
  
  [2X> DIYModule( [0X[3XU, V, acts[0X[2X ) _________________________________________[0Xoperation
  
  Here  [3XU[0m  is  a generic quantized enveloping algebra, and [3XV[0m is a vector space
  over  the field [3XQuantumField[0m. [3XU[0m acts on [3XV[0m and the action is described by the
  data  in  the  list [3Xacts[0m. [3Xacts[0m is a list of lists, of length [3X4*l[0m, where [3Xl[0m is
  the  rank  of  the root system. [3Xacts[0m describes the actions of the generators
  [F_1,...,F_l,K_1,...,K_l,K_1^-1,...,K_l^-1,  E_1,...,E_l ]. (Here F_k is the
  generator F_alpha_k, where alpha_k is the k-th simple root, and likewise for
  E_k.)  The  action of each generator is described by a list of length [3Xdim V[0m,
  giving  the  images  of the basis elements of [3XV[0m. If an image is zero then it
  may  be  omitted:  in that case there is a "hole" in the list. This function
  returns the [3XU[0m-module defined by the input.
  
  Let  [3XR[0m  be  a  root  system  of  type A_1, and [3XU[0m the corresponding quantized
  enveloping  algebra  (generated  by  F, K, K^-1, E). In the example below we
  construct  the  2-dimensional  U-module  with  basis  vectors  v_1,v_2,  and
  [3XU[0m-action  given  by  Fv_1  = v_2, Fv_2=0, Kv_1 = qv_1, Kv_2=q^-1v_2, Ev_1=0,
  Ev_2=v_1.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> U:= QuantizedUEA( RootSystem("A",1) );[0X
    [4XQuantumUEA( <root system of type A1>, Qpar = q )[0X
    [4Xgap> V:= QuantumField^2;[0X
    [4X( QuantumField^2 )[0X
    [4Xgap> v:= BasisVectors( Basis(V) );[0X
    [4X[ [ 1, 0 ], [ 0, 1 ] ][0X
    [4Xgap> acts:= [ [ v[2], 0*v[1] ], [ _q*v[1], _q^-1*v[2] ],[0X
    [4X> [ _q^-1*v[1], _q*v[2] ], [ 0*v[1], v[1] ] ];;[0X
    [4Xgap> M:= DIYModule( U, V, acts );[0X
    [4X<2-dimensional left-module over QuantumUEA( <root system of type A[0X
    [4X1>, Qpar = q )>[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.8-5 TensorProductOfAlgebraModules[0m
  
  [2X> TensorProductOfAlgebraModules( [0X[3XV, W[0X[2X ) ___________________________[0Xoperation
  [2X> TensorProductOfAlgebraModules( [0X[3XV, W[0X[2X ) ___________________________[0Xoperation
  
  Here  [3XV[0m  and [3XW[0m are two modules over the same quantized enveloping algebra [3XU[0m.
  This  function constructs the tensor product of [3XV[0m and [3XW[0m (as a [3XU[0m-module). For
  this  the  comultiplication  map  of  [3XU[0m  is  used  (see  [2XComultiplicationMap[0m
  ([14X3.7-3[0m)).
  
  In  the  second  form list is a list of [3XU[0m-modules. In that case the iterated
  tensor product is constructed.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> U:= QuantizedUEA( RootSystem( [ "A", 2 ] ) );;[0X
    [4Xgap> V1:= HighestWeightModule( U, [ 1, 0 ] );;[0X
    [4Xgap> V2:= HighestWeightModule( U, [ 0, 1 ] );;[0X
    [4Xgap> TensorProductOfAlgebraModules( V1, V2 );[0X
    [4X<9-dimensional left-module over QuantumUEA( <root system of type A2>, Qpar = q )>[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.8-6 HWModuleByGenerator[0m
  
  [2X> HWModuleByGenerator( [0X[3XV, v, hw[0X[2X ) _________________________________[0Xoperation
  
  Here  [3XV[0m  is  a  module over a generic quantized enveloping algebra [3XU[0m, [3Xv[0m is a
  highest-weight  vector  (i.e.,  all E_alpha[3Xv=0[0m), of weight [3Xhw[0m, which must be
  dominant. This function returns a highest-weight module over [3XU[0m isomorphic to
  the submodule of [3XV[0m generated by [3Xv[0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> U:= QuantizedUEA( RootSystem("B",2) );;[0X
    [4Xgap> W1:= HighestWeightModule( U, [1,0] );;[0X
    [4Xgap> W2:= HighestWeightModule( U, [0,1] );;[0X
    [4Xgap> T:= TensorProductOfAlgebraModules( W1, W2 );[0X
    [4X<20-dimensional left-module over QuantumUEA( <root system of type B[0X
    [4X2>, Qpar = q )>[0X
    [4Xgap> HWModuleByGenerator( T, Basis(T)[1], [1,1] );[0X
    [4X<16-dimensional left-module over QuantumUEA( <root system of type B[0X
    [4X2>, Qpar = q )>[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.8-7 InducedQEAModule[0m
  
  [2X> InducedQEAModule( [0X[3XU, V[0X[2X ) ________________________________________[0Xoperation
  
  Here  [3XU[0m  is  a non-generic quantized enveloping algebra, and [3XV[0m a module over
  the  corresponding  generic  quantized  enveloping  algebra.  This  function
  returns  the  [3XU[0m-module  obtained  from  [3XV[0m by setting [3X_q[0m equal to the quantum
  parameter of [3XU[0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> R:= RootSystem("B",2);;[0X
    [4Xgap> U:= QuantizedUEA( R );;[0X
    [4Xgap> U0:= QuantizedUEA( R, CF(3), E(3) );;[0X
    [4Xgap> V:= HighestWeightModule( U, [1,1] );;[0X
    [4Xgap> W:= InducedQEAModule( U0, V );[0X
    [4X<16-dimensional left-module over QuantumUEA( <root system of type B[0X
    [4X2>, Qpar = E(3) )>[0X
    [4X# This module is isomorphic to the one obtained by[0X
    [4X# HighestWeightModule( U0, [1,1] );[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.8-8 GenericModule[0m
  
  [2X> GenericModule( [0X[3XW[0X[2X ) ______________________________________________[0Xattribute
  
  For  an  induced module (see [2XInducedQEAModule[0m ([14X3.8-7[0m)) this function returns
  the corresponding module over the generic quantized enveloping algebra.
  
  [1X3.8-9 CanonicalMapping[0m
  
  [2X> CanonicalMapping( [0X[3XW[0X[2X ) ___________________________________________[0Xattribute
  
  Here  [3XW[0m  is  an  induced  module.  Let [3XV[0m be the corresponding generic module
  ([2XGenericModule[0m ([14X3.8-8[0m)). This function returns the map [3XV --> W[0m, that sets [3X_q[0m
  equal to the quantum parameter of the acting algebra of [3XW[0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> R:= RootSystem("B",2);;[0X
    [4Xgap> U:= QuantizedUEA( R );;[0X
    [4Xgap> U0:= QuantizedUEA( R, CF(3), E(3) );;[0X
    [4Xgap> V:= HighestWeightModule( U, [1,1] );;[0X
    [4Xgap> W:= InducedQEAModule( U0, V );;[0X
    [4Xgap> f:= CanonicalMapping( W );[0X
    [4XMappingByFunction( <[0X
    [4X16-dimensional left-module over QuantumUEA( <root system of type B[0X
    [4X2>, Qpar = q )>, <[0X
    [4X16-dimensional left-module over QuantumUEA( <root system of type B[0X
    [4X2>, Qpar = E(3) )>, function( v ) ... end )[0X
    [4Xgap> Image( f, _q^2*Basis(V)[3] );[0X
    [4X(E(3)^2)*e.3[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.8-10 U2Module[0m
  
  [2X> U2Module( [0X[3XU, hw[0X[2X ) _______________________________________________[0Xoperation
  
  Here  [3XU[0m  must  be  a quantized enveloping algebra of type A_2. This function
  returns the highest-weight module over [3XU[0m of highest-weight [3Xhw[0m (which must be
  dominant).    This    function    is    generally    a   lot   faster   than
  [2XHighestWeightModule:for  a quantized env. alg.[0m ([14X???HighestWeightModule:for a
  quantized env. alg.???[0m).
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> U:= QuantizedUEA( RootSystem("A",2) );;[0X
    [4Xgap> A2Module( U, [4,7] );[0X
    [4X<260-dimensional left-module over QuantumUEA( <root system of type A[0X
    [4X2>, Qpar = q )>[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.8-11 MinusculeModule[0m
  
  [2X> MinusculeModule( [0X[3XU, hw[0X[2X ) ________________________________________[0Xoperation
  
  Here  [3XU[0m  must  be a generic quantized enveloping algebra, and [3Xhw[0m a minuscule
  dominant  weight.  This function returns the highest-weight module over [3XU[0m of
  highest-weight   [3Xhw[0m.   This  function  is  generally  somewhat  faster  than
  [2XHighestWeightModule:for  a quantized env. alg.[0m ([14X???HighestWeightModule:for a
  quantized env. alg.???[0m).
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> U:= QuantizedUEA( RootSystem("A",5) );;[0X
    [4Xgap> MinusculeModule( U, [0,0,1,0,0] );[0X
    [4X<20-dimensional left-module over QuantumUEA( <root system of type A[0X
    [4X5>, Qpar = q )>[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.8-12 DualAlgebraModule[0m
  
  [2X> DualAlgebraModule( [0X[3XV[0X[2X ) __________________________________________[0Xattribute
  
  Here  [3XV[0m  is  a  finite-dimensional  left  module over a quantized enveloping
  algebra  [3XU[0m.  This function returns the dual space of [3XV[0m as an algebra module.
  For this the antipode map of [3XU[0m is used (see [2XAntipodeMap[0m ([14X3.7-4[0m)).
  
  Let  [3XM[0m  denote the module returned by this function. Then [3XM[0m has as basis the
  dual  basis  with respect to [3XBasis( V )[0m. An element of this basis is printed
  as  [3XF@v[0m,  where  [3Xv[0m  is  an element of [3XBasis( V )[0m. This is the function which
  takes  the value [3X1[0m on [3Xv[0m and [3X0[0m on all other basis elements. A general element
  of [3XM[0m is a linear combination of these basis elements.
  
  The  elements of [3XM[0m can be viewed as functions which take arguments. However,
  internally  the  elements  of [3XM[0m are represented as wrapped up functions. The
  function  corresponding to an element [3Xm[0m of [3XM[0m is obtained by [3XExtRepOfObj( m )[0m
  (the  result  of  which is printed in the same way as [3Xm[0m, but is not equal to
  it).
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> U:= QuantizedUEA( RootSystem("A",2) );;[0X
    [4Xgap> V:= HighestWeightModule( U, [1,1] );;[0X
    [4Xgap> M:= DualAlgebraModule( V );[0X
    [4X<8-dimensional left-module over QuantumUEA( <root system of type A[0X
    [4X2>, Qpar = q )>[0X
    [4Xgap> u:= GeneratorsOfAlgebra( U )[2];[0X
    [4XF2[0X
    [4Xgap> vv:= BasisVectors( Basis( M ) );[0X
    [4X[ (1)*F@1*v0, (1)*F@F1*v0, (1)*F@F3*v0, (1)*F@F1*F3*v0, (1)*F@F2*v0,[0X
    [4X  (1)*F@F1*F2*v0, (1)*F@F2*F3*v0, (1)*F@F2^(2)*v0 ][0X
    [4Xgap> u^vv[3];[0X
    [4X<zero function>[0X
    [4X# (The zero of the dual space is printed as <zero function>).[0X
    [4Xgap> u^vv[4];[0X
    [4X(q^3-q^5)*F@1*v0[0X
    [4X# We get the function corresponding to a vector in M by using ExtRepOfObj:[0X
    [4Xgap> f:= ExtRepOfObj( vv[1] );[0X
    [4X(1)*F@1*v0[0X
    [4X# We can calculate images of this function:[0X
    [4Xgap> List( Basis(V), v -> Image( f, v ) );[0X
    [4X[ 1, 0, 0, 0, 0, 0, 0, 0 ][0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.8-13 TrivialAlgebraModule[0m
  
  [2X> TrivialAlgebraModule( [0X[3XU[0X[2X ) _______________________________________[0Xattribute
  
  Returns the trivial module over the quantized enveloping algebra [3XU[0m. For this
  the counit map of [3XU[0m is used.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> U:= QuantizedUEA( RootSystem("A",2) );;[0X
    [4Xgap> V:= TrivialAlgebraModule( U );[0X
    [4X<left-module over QuantumUEA( <root system of type A2>, Qpar = q )>[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.8-14 WeightsAndVectors[0m
  
  [2X> WeightsAndVectors( [0X[3XV[0X[2X ) __________________________________________[0Xoperation
  
  Here   [3XV[0m   is   a   left   module   over  a  quantized  enveloping  algebra.
  [3XWeightsAndVectors(  V )[0m is a list of two lists; the first of these is a list
  of  the  weights  of  [3XV[0m,  the second a list of corresponding weight vectors.
  These are again grouped in lists: if the multiplicity of a weight is [3Xm[0m, then
  there  are  [3Xm[0m  weight  vectors,  forming a basis of the corresponding weight
  space.
  
  Modules   constructed  by  [2XHighestWeightModule:for  a  quantized  env.  alg.[0m
  ([14X???HighestWeightModule:for   a  quantized  env.  alg.???[0m)  come  with  this
  attribute  set. There is a method installed for computing [3XWeightsAndVectors(
  V  )[0m,  for  modules [3XV[0m over a generic quantized enveloping algebra, such that
  all basis vectors (i.e., all elements of [3XBasis( V )[0m) are weight vectors.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> U:= QuantizedUEA( RootSystem( "A", 2 ) );;[0X
    [4Xgap> V:= HighestWeightModule( U, [ 1, 1 ] );;[0X
    [4Xgap> WeightsAndVectors( V );[0X
    [4X[ [ [ 1, 1 ], [ -1, 2 ], [ 2, -1 ], [ 0, 0 ], [ -2, 1 ], [ 1, -2 ],[0X
    [4X      [ -1, -1 ] ],[0X
    [4X  [ [ 1*v0 ], [ F1*v0 ], [ F3*v0 ], [ F1*F3*v0, F2*v0 ], [ F1*F2*v0 ],[0X
    [4X      [ F2*F3*v0 ], [ F2^(2)*v0 ] ] ][0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.8-15 HighestWeightsAndVectors[0m
  
  [2X> HighestWeightsAndVectors( [0X[3XV[0X[2X ) ___________________________________[0Xattribute
  
  Is analogous to [2XWeightsAndVectors[0m ([14X3.8-14[0m); now only the highest weights are
  listed along with the corresponding highest-weight vectors.
  
  There is a method installed for this using [2XWeightsAndVectors[0m ([14X3.8-14[0m); which
  means that it works if and only if [3XWeightsAndVectors( V )[0m works.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> U:= QuantizedUEA( RootSystem( [ "A", 2 ] ) );;[0X
    [4Xgap> V:= HighestWeightModule( U, [ 1, 1 ] );;[0X
    [4Xgap> HighestWeightsAndVectors( V );[0X
    [4X[ [ [ 1, 1 ] ], [ [ 1*v0 ] ] ][0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.8-16 RMatrix[0m
  
  [2X> RMatrix( [0X[3XV[0X[2X ) ____________________________________________________[0Xattribute
  
  Here  [3XV[0m is a module over the a quantized enveloping algebra [3XU[0m. This function
  returns  the matrix of a linear map theta : Votimes V -> Votimes V that is a
  solution to the quantum Yang-Baxter equation. We have that thetacirc P is an
  isomorphism  of  [3XU[0m-modules, where P :Votimes V-> Votimes V is the linear map
  such  that  P(votimes  w)=wotimes  v.  For more details we refer to [Jan96],
  Chapter 7.
  
  This function works for modules for which [2XWeightsAndVectors[0m ([14X3.8-14[0m) works.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> U:= QuantizedUEA( RootSystem("A",1) );;[0X
    [4Xgap> V:= HighestWeightModule( U, [1] );;[0X
    [4Xgap> RMatrix( V );[0X
    [4X[ [ 1, 0, 0, 0 ], [ 0, q, 1-q^2, 0 ], [ 0, 0, q, 0 ], [ 0, 0, 0, 1 ] ][0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.8-17 IsomorphismOfTensorModules[0m
  
  [2X> IsomorphismOfTensorModules( [0X[3XV, W[0X[2X ) ______________________________[0Xoperation
  
  Here [3XV[0m, [3XW[0m are two modules over the same quantized enveloping algebra [3XU[0m. This
  function  returns  a  linear  map  theta  : Votimes W-> Wotimes V that is an
  isomorphism of U-modules.
  
  This  function  is  only  guaranteed  to  work correctly if the Hopf algebra
  structure is non-twisted (see [2XUseTwistedHopfStructure[0m ([14X3.7-2[0m)).
  
  This function works for modules for which [2XWeightsAndVectors[0m ([14X3.8-14[0m) works.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> U:= QuantizedUEA( RootSystem("B",2) );;[0X
    [4Xgap> V:= HighestWeightModule( U, [1,0] );;[0X
    [4Xgap> W:= HighestWeightModule( U, [0,1] );;[0X
    [4Xgap> h:= IsomorphismOfTensorModules( V, W );;[0X
    [4Xgap> VW:= Source( h );[0X
    [4X<20-dimensional left-module over QuantumUEA( <root system of type B[0X
    [4X2>, Qpar = q )>[0X
    [4Xgap> Image( h, Basis(VW)[13] );[0X
    [4Xq*(1*v0<x>F3*v0)+1-q^2*(F4*v0<x>F2*v0)+q^-1-q^3*(F3*v0<x>1*v0)[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.8-18 WriteModuleToFile[0m
  
  [2X> WriteModuleToFile( [0X[3XV, file[0X[2X ) ____________________________________[0Xoperation
  
  Here [3XV[0m is a module over a quantized enveloping algebra, and [3Xfile[0m is a string
  containing  the name of a file. This function writes some data to [3Xfile[0m, that
  allows [2XReadModuleFromFile[0m ([14X3.8-19[0m) to recover it.
  
  We  remark  that  this  function  currently  is only implemented for generic
  quantized enveloping algebras.
  
  [1X3.8-19 ReadModuleFromFile[0m
  
  [2X> ReadModuleFromFile( [0X[3Xfile[0X[2X ) ______________________________________[0Xoperation
  
  Here  [3Xfile[0m is a string containing the name of a file, to which a module over
  a  quantized  enveloping  algebra  has  been  written  by  [2XWriteModuleToFile[0m
  ([14X3.8-18[0m). This function recovers the module. More precisely: a new module is
  constructed  that  is  isomorphic to the old one. In the process the algebra
  acting  on  the  module is constructed anew (from data written to the file).
  This algebra can be accessed by [3XLeftActingAlgebra( V )[0m.
  
  We  remark  that  this  function  currently  is only implemented for generic
  quantized enveloping algebras.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> U:= QuantizedUEA( RootSystem("A",3) );;[0X
    [4Xgap> V:= HighestWeightModule( U, [1,1,1] );;[0X
    [4Xgap> WriteModuleToFile( V, "/home/wdg/A3mod" );[0X
    [4Xgap> W:= ReadModuleFromFile( "/home/wdg/A3mod" );[0X
    [4X<64-dimensional left-module over QuantumUEA( <root system of type A[0X
    [4X3>, Qpar = q )>[0X
  [4X------------------------------------------------------------------[0X
  
  
  [1X3.9 The path model[0X
  
  In  this  section  we describe functions for dealing with the path model. We
  work only with LS-paths, which are represented by two lists, one of weights,
  and one of rationals (see Section [14X2.7[0m).
  
  [1X3.9-1 DominantLSPath[0m
  
  [2X> DominantLSPath( [0X[3XR, wt[0X[2X ) _________________________________________[0Xoperation
  
  Here  [3XR[0m  is a root system, and [3Xwt[0m a dominant weight in the weight lattice of
  [3XR[0m. This function returns the LS-path that is the line from the origin to [3Xwt[0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> R:= RootSystem( "G", 2 );;[0X
    [4Xgap> DominantLSPath( R, [1,3] );[0X
    [4X<LS path of shape [ 1, 3 ] ending in [ 1, 3 ] >[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.9-2 Falpha[0m
  
  [2X> Falpha( [0X[3Xpath, ind[0X[2X ) _____________________________________________[0Xoperation
  
  Is the result of applying the path operator f_alpha_[3Xind[0m} to the LS-path [3Xpath[0m
  (where alpha_[3Xind[0m is the [3Xind[0m-th simple root).
  
  The result is [3Xfail[0m if f_alpha_[3Xind[0m}[3X(path)=0[0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> R:= RootSystem( "G", 2 );;[0X
    [4Xgap> p:=DominantLSPath( R, [1,3] );;[0X
    [4Xgap> p1:=Falpha( p, 1 );[0X
    [4X<LS path of shape [ 1, 3 ] ending in [ -1, 4 ] >[0X
    [4Xgap> Falpha( p1, 1 );[0X
    [4Xfail[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.9-3 Ealpha[0m
  
  [2X> Ealpha( [0X[3Xpath, ind[0X[2X ) _____________________________________________[0Xoperation
  
  Is the result of applying the path operator e_alpha_[3Xind[0m} to the LS-path [3Xpath[0m
  (where alpha_[3Xind[0m is the [3Xind[0m-th simple root).
  
  The result is [3Xfail[0m if e_alpha_[3Xind[0m}[3X(path)=0[0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> R:= RootSystem( "G", 2 );;[0X
    [4Xgap> p:=DominantLSPath( R, [1,3] );;[0X
    [4Xgap> Ealpha( p, 2 );[0X
    [4Xfail[0X
    [4Xgap> p1:=Falpha( p, 1 );;[0X
    [4Xgap> Ealpha( p1, 1 );[0X
    [4X<LS path of shape [ 1, 3 ] ending in [ 1, 3 ] >[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.9-4 LSSequence[0m
  
  [2X> LSSequence( [0X[3Xpath[0X[2X ) ______________________________________________[0Xattribute
  
  returns  the two sequences (of weights and rational numbers) that define the
  LS-path path.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> R:= RootSystem( "G", 2 );;[0X
    [4Xgap> p:=DominantLSPath( R, [1,3] );;[0X
    [4Xgap> p1:= Falpha( Falpha( p, 1 ), 2 );;[0X
    [4Xgap> LSSequence( p1 );[0X
    [4X[ [ [ 11, -4 ], [ -1, 4 ] ], [ 0, 1/4, 1 ] ][0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.9-5 WeylWord[0m
  
  [2X> WeylWord( [0X[3Xpath[0X[2X ) ________________________________________________[0Xattribute
  
  Here  [3Xpath[0m  is  an  LS-path  in  the  orbit  (under the root operators) of a
  dominant  LS-path  ending in the dominant weight lambda. This means that the
  first  direction  of  path  is  of the form w(lambda) for some w in the Weyl
  group.  This  function returns a list [i_1,..., i_m ] such that w=s_i_1cdots
  s_i_m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> R:= RootSystem( "G", 2 );;[0X
    [4Xgap> p:=DominantLSPath( R, [1,3] );;[0X
    [4Xgap> p1:= Falpha( Falpha( Falpha( p, 1 ), 2 ), 1 );;[0X
    [4Xgap> WeylWord( p1 );[0X
    [4X[ 1, 2, 1 ][0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.9-6 EndWeight[0m
  
  [2X> EndWeight( [0X[3Xpath[0X[2X ) _______________________________________________[0Xattribute
  
  Here  [3Xpath[0m  is  an  LS-path;  this  function  returns the weight that is the
  endpoint of path
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> R:= RootSystem( "G", 2 );;[0X
    [4Xgap> p:=DominantLSPath( R, [1,3] );;[0X
    [4Xgap> p1:= Falpha( Falpha( Falpha( p, 1 ), 2 ), 1 );;[0X
    [4Xgap> EndWeight( p1 );[0X
    [4X[ 0, 3 ][0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.9-7 CrystalGraph[0m
  
  [2X> CrystalGraph( [0X[3XR, wt[0X[2X ) ____________________________________________[0Xfunction
  
  This  function  returns  a  record  describing  the  crystal  graph  of  the
  highest-weight  module with highest weight [3Xwt[0m, over the quantized enveloping
  algebra  corresponding  to [3XR[0m. It is computed using the path model. Therefore
  the points in the graph are LS-paths.
  
  Denote  the  output  by [3Xr[0m; then [3Xr.points[0m is the list of points of the graph.
  Furthermore,  [3Xr.edges[0m  is  a  list  of edges of the graph; this is a list of
  elements of the form [3X[ [ i, j ], u ][0m. This means that there is an arrow from
  point  [3Xi[0m  (i.e., the point on position [3Xi[0m in [3Xr.points[0m) to point [3Xj[0m, with label
  [3Xu[0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> R:= RootSystem( "A", 2 );;[0X
    [4Xgap> CrystalGraph( R, [1,1] );[0X
    [4Xrec([0X
    [4X  points := [ <LS path of shape [ 1, 1 ] ending in [ 1, 1 ] >, <LS path of sha\[0X
    [4Xpe [ 1, 1 ] ending in [ -1, 2 ] >, <LS path of shape [ 1, 1 ] ending in[0X
    [4X        [ 2, -1 ] >, <LS path of shape [ 1, 1 ] ending in [ 0, 0 ] >,[0X
    [4X      <LS path of shape [ 1, 1 ] ending in [ 0, 0 ] >,[0X
    [4X      <LS path of shape [ 1, 1 ] ending in [ 1, -2 ] >,[0X
    [4X      <LS path of shape [ 1, 1 ] ending in [ -2, 1 ] >,[0X
    [4X      <LS path of shape [ 1, 1 ] ending in [ -1, -1 ] > ],[0X
    [4X  edges := [ [ [ 1, 2 ], 1 ], [ [ 1, 3 ], 2 ], [ [ 2, 4 ], 2 ],[0X
    [4X      [ [ 3, 5 ], 1 ], [ [ 4, 6 ], 2 ], [ [ 5, 7 ], 1 ], [ [ 6, 8 ], 1 ],[0X
    [4X      [ [ 7, 8 ], 2 ] ] )[0X
  [4X------------------------------------------------------------------[0X
  
  
  [1X3.10 Canonical bases[0X
  
  Here we describe functions for computing the canonical basis of the negative
  part of a quantized enveloping algebra, and of a module.
  
  [1X3.10-1 Falpha[0m
  
  [2X> Falpha( [0X[3Xx, ind[0X[2X ) ________________________________________________[0Xoperation
  
  Here  [3Xx[0m  is  a  PBW-monomial  in U^- (i.e., a monomial in the F_alpha, where
  alpha  runs  over  the  positive roots). This function returns the result of
  applying  the  [3Xind[0m-th  Kashiwara  operator  widetildeF_alpha_[3Xind[0m}  to x (cf.
  Section [14X2.6[0m).
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> U:= QuantizedUEA( RootSystem( "F", 4 ) );;[0X
    [4Xgap> x:= One( U );[0X
    [4X1[0X
    [4Xgap> Falpha( Falpha( x, 3 ), 2 );[0X
    [4XF3*F9[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.10-2 Ealpha[0m
  
  [2X> Ealpha( [0X[3Xx, ind[0X[2X ) ________________________________________________[0Xoperation
  
  Here  [3Xx[0m  is  a  PBW-monomial  in U^- (i.e., a monomial in the F_alpha, where
  alpha  runs  over  the  positive roots). This function returns the result of
  applying  the  [3Xind[0m-th  Kashiwara  operator  widetildeE_alpha_[3Xind[0m}  to x (cf.
  Section [14X2.6[0m). The result is [3Xfail[0m if widetildeE_alpha_[3Xind[0m}[3X(x)=0[0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> U:= QuantizedUEA( RootSystem( "F", 4 ) );;[0X
    [4Xgap> Ealpha( One( U ), 2 );[0X
    [4Xfail[0X
    [4Xgap> g:= GeneratorsOfAlgebra( U );;[0X
    [4Xgap> x:= g[1]*g[4]*g[7]*g[17];[0X
    [4XF1*F4*F7*F17[0X
    [4Xgap> Ealpha( x, 3 );[0X
    [4XF1*F2*F7*F17[0X
    [4X[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.10-3 CanonicalBasis[0m
  
  [2X> CanonicalBasis( [0X[3XU[0X[2X ) _____________________________________________[0Xattribute
  
  Is the canonical basis of the quantized universal enveloping algebra [3XU[0m. When
  this  is  constructed  nothing  is  computed. By using [2XPBWElements[0m ([14X3.10-4[0m),
  [2XMonomialElements[0m  ([14X3.10-5[0m),  [2XStrings[0m  ([14X3.10-6[0m) information about elements of
  the canonical basis can be obtained.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> U:= QuantizedUEA( RootSystem( "F", 4 ) );;[0X
    [4Xgap> B:= CanonicalBasis( U );[0X
    [4X<canonical basis of QuantumUEA( <root system of type F4>, Qpar = q ) >[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.10-4 PBWElements[0m
  
  [2X> PBWElements( [0X[3XB, rt[0X[2X ) ____________________________________________[0Xoperation
  
  Here  [3XB[0m  is  the  canonical  basis  of  a  quantized  uea,  and [3Xrt[0m a list of
  non-negative  integers representing an element of the root lattice (e.g., if
  the  simple  roots  are  alpha,  beta  and [3Xrt = [ 3, 2 ][0m, then [3Xrt[0m represents
  3alpha+2beta).
  
  It  is  possible  to  add  the option [3Xlowrank[0m, as follows [3XPBWElements( B, rt
  :lowrank  )[0m.  In that case a somewhat different method will be used, that is
  significantly faster if the underlying root system has rank 2,3. It is about
  equally fast for ranks 4,5; and slower for ranks greater than 5.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> U:= QuantizedUEA( RootSystem( "F", 4 ) );;[0X
    [4Xgap> B:= CanonicalBasis( U );;[0X
    [4Xgap> PBWElements( B, [1,2,1,0] );[0X
    [4X[ F1*F3^(2)*F9, F1*F3*F7+(q^4)*F1*F3^(2)*F9, (q^4)*F1*F3^(2)*F9+F2*F3*F9,[0X
    [4X  (q^2)*F1*F3*F7+(q^2+q^6)*F1*F3^(2)*F9+(q^2)*F2*F3*F9+F2*F7,[0X
    [4X  (q^4)*F1*F3*F7+(q^8)*F1*F3^(2)*F9+(q^4)*F2*F3*F9+(q^2)*F2*F7+F3*F4 ][0X
    [4Xgap> U:= QuantizedUEA( RootSystem("G",2) );;[0X
    [4Xgap> B:= CanonicalBasis( U );;[0X
    [4Xgap> PBWElements( B, [2,3] : lowrank );[0X
    [4X[ F1^(2)*F6^(3), F1*F5*F6^(2)+(q^8+q^10)*F1^(2)*F6^(3),[0X
    [4X  (q^2)*F1*F5*F6^(2)+(q^6+q^12)*F1^(2)*F6^(3)+F3*F6^(2),[0X
    [4X  (q^8)*F1*F5*F6^(2)+(q^18)*F1^(2)*F6^(3)+(q^6)*F3*F6^(2)+F5^(2)*F6 ][0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.10-5 MonomialElements[0m
  
  [2X> MonomialElements( [0X[3XB, rt[0X[2X ) _______________________________________[0Xoperation
  
  This  does  the  same  as [2XPBWElements[0m ([14X3.10-4[0m), except that the elements are
  written as linear combinations of monomials in the generators F_alpha, where
  alpha runs through the simple roots.
  
  We  remark  that  this information is also computed "behind the scenes" when
  calling  [3XPBWElements(  B,  rt  )[0m.  However, it is not computed if the option
  [3Xlowrank[0m is present in the call to [3XPBWElements[0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> U:= QuantizedUEA( RootSystem( "F", 4 ) );;[0X
    [4Xgap> B:= CanonicalBasis( U );;[0X
    [4Xgap> MonomialElements( B, [1,2,1,0] );[0X
    [4X[ F1*F3^(2)*F9, F1*F3*F9*F3+(-1)*F1*F3^(2)*F9, F3^(2)*F1*F9, F3*F1*F9*F3,[0X
    [4X  F3*F9*F3*F1+(-1)*F3^(2)*F1*F9 ][0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.10-6 Strings[0m
  
  [2X> Strings( [0X[3XB, rt[0X[2X ) ________________________________________________[0Xoperation
  
  Here [3XB[0m, [3Xrt[0m are the same as in [2XPBWElements[0m ([14X3.10-4[0m). This returns the list of
  strings  corresponding  to the elements of [3XB[0m of weight [3Xrt[0m (cf. Section [14X2.6[0m).
  For  example,  if on the k-th position of the list returned by this function
  we  have  [3X[ 1, 2, 2, 3 ][0m, then the principal monomial of the k-th element of
  [3XPBWElements(  B, rt )[0m is widetildeF_1^2widetildeF_2^3(1) (where widetildeF_i
  is the i-th Kashiwara operator).
  
  We  remark  that  this information is also computed "behind the scenes" when
  calling  [3XPBWElements(  B,  rt  )[0m.  However, it is not computed if the option
  [3Xlowrank[0m is present in the call to [3XPBWElements[0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> U:= QuantizedUEA( RootSystem( "F", 4 ) );;[0X
    [4Xgap> B:= CanonicalBasis( U );;[0X
    [4Xgap> Strings( B, [1,2,1,0] );[0X
    [4X[ [ 1, 1, 2, 2, 3, 1 ], [ 1, 1, 2, 1, 3, 1, 2, 1 ], [ 2, 2, 1, 1, 3, 1 ],[0X
    [4X  [ 2, 1, 1, 1, 3, 1, 2, 1 ], [ 2, 1, 3, 1, 2, 1, 1, 1 ] ][0X
    [4Xgap> Falpha( Falpha( Falpha( Falpha( One(U), 3 ), 1 ), 2 ), 2 );[0X
    [4XF2*F3*F9[0X
    [4Xgap> PBWElements( B, [1,2,1,0] )[3];[0X
    [4X(q^4)*F1*F3^(2)*F9+F2*F3*F9[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.10-7 PrincipalMonomial[0m
  
  [2X> PrincipalMonomial( [0X[3Xu[0X[2X ) __________________________________________[0Xoperation
  
  Here  [3Xu[0m  is  an element of the output of [2XPBWElements[0m ([14X3.10-4[0m). This function
  returns the unique monomial of [3Xu[0m that has coefficient 1.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> U:= QuantizedUEA( RootSystem("G",2) );;[0X
    [4Xgap> B:= CanonicalBasis( U );;[0X
    [4Xgap> p:= PBWElements( B, [4,4] : lowrank )[4];[0X
    [4X(q^9)*F1^(2)*F3*F6^(3)+F1^(2)*F5^(2)*F6^(2)+(q^9+q^11+q^13)*F1^(3)*F5*F6^([0X
    [4X3)+(q^20+q^22+2*q^24+q^26+q^28)*F1^(4)*F6^(4)[0X
    [4Xgap> PrincipalMonomial( p );[0X
    [4XF1^(2)*F5^(2)*F6^(2)[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.10-8 StringMonomial[0m
  
  [2X> StringMonomial( [0X[3Xu[0X[2X ) _____________________________________________[0Xoperation
  
  Here [3Xu[0m is a monomial in the negative part of a quantized enveloping algebra,
  e.g.,  as  output  by [2XPrincipalMonomial[0m ([14X3.10-7[0m). This function computes the
  corresponding "string" (see Section [14X2.6[0m). The strings are output in the same
  way as in [14X3.10-6[0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> U:= QuantizedUEA( RootSystem("G",2) );;[0X
    [4Xgap> B:= CanonicalBasis( U );;[0X
    [4Xgap> p:= PBWElements( B, [1,2] : lowrank )[2];;[0X
    [4Xgap> m:=PrincipalMonomial( p );[0X
    [4XF5*F6[0X
    [4Xgap> StringMonomial( m );[0X
    [4X[ 2, 2, 1, 1 ][0X
    [4Xgap> Falpha( Falpha( Falpha( One(U), 1 ), 2 ), 2 );[0X
    [4XF5*F6[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.10-9 Falpha[0m
  
  [2X> Falpha( [0X[3XV, v, ind[0X[2X ) _____________________________________________[0Xoperation
  
  Here  [3XV[0m is a module over a quantized enveloping algebra, [3Xv[0m an element of it,
  and  [3Xind[0m  an  index  between 1 and the rank of the root system. The function
  returns  the result of applying the [3Xind[0m-th Kashiwara operator widetildeF_[3Xind[0m
  to  [3Xv[0m. Here the Kashiwara operators are different from the ones described in
  Section  [14X2.6[0m.  We  refer to [Jan96], 9.2 for the definition of the operators
  used here.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> U:= QuantizedUEA( RootSystem("B",2) );;[0X
    [4Xgap> V:= HighestWeightModule( U, [1,1] );;[0X
    [4Xgap> Falpha( V, Basis(V)[1], 1 );[0X
    [4XF1*v0[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.10-10 Ealpha[0m
  
  [2X> Ealpha( [0X[3XV, v, ind[0X[2X ) _____________________________________________[0Xoperation
  
  Here  [3XV[0m is a module over a quantized enveloping algebra, [3Xv[0m an element of it,
  and  [3Xind[0m  an  index  between 1 and the rank of the root system. The function
  returns  the result of applying the [3Xind[0m-th Kashiwara operator widetildeE_[3Xind[0m
  to  [3Xv[0m. Here the Kashiwara operators are different from the ones described in
  Section  [14X2.6[0m.  We  refer to [Jan96], 9.2 for the definition of the operators
  used here.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> U:= QuantizedUEA( RootSystem("B",2) );;[0X
    [4Xgap> V:= HighestWeightModule( U, [1,1] );;[0X
    [4Xgap> v:= Falpha( V, Basis(V)[2], 2 );[0X
    [4X(q^2)*F1*F4*v0+F2*v0[0X
    [4Xgap> Ealpha( V, v, 2 );[0X
    [4XF1*v0[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.10-11 CrystalBasis[0m
  
  [2X> CrystalBasis( [0X[3XV[0X[2X ) _______________________________________________[0Xattribute
  
  Here  [3XV[0m  is  a  finite-dimensional  left  module over a quantized enveloping
  algebra.  This  function  returns  the canonical, or crystal basis of V (see
  Section [14X2.6[0m).
  
  This  function  only  works for modules for which [2XWeightsAndVectors[0m ([14X3.8-14[0m)
  works.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> U:= QuantizedUEA( RootSystem( "B", 2 ) );;[0X
    [4X gap> V:= HighestWeightModule( U, [1,1] );[0X
    [4X <16-dimensional left-module over QuantumUEA( <root system of type B2>, Qpar[0X
    [4X= q )>[0X
    [4X gap>  CrystalBasis( V );[0X
    [4X Basis( <16-dimensional left-module over QuantumUEA( <root system of type B[0X
    [4X 2>, Qpar = q )>, [ 1*v0, F1*v0, F4*v0, F1*F4*v0, (q^2)*F1*F4*v0+F2*v0, F2*F4*v0,[0X
    [4X(q)*F2*F4*v0+F3*v0, (-q^-4)*F1*F2*v0, (-q^-1)*F1*F3*v0+(-q^-3)*F2^(2)*v0,[0X
    [4X(-q^-2)*F2^(2)*v0, F3*F4*v0, (-q^-4)*F2*F3*v0+(-q^-2)*F2^(2)*F4*v0,[0X
    [4X(-q^-2)*F2*F3*v0, (q^-4)*F2^(3)*v0, (-q^-1)*F3^(2)*v0, (q^-5)*F2^(2)*F3*v0 ] )[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.10-12 CrystalVectors[0m
  
  [2X> CrystalVectors( [0X[3XV[0X[2X ) _____________________________________________[0Xattribute
  
  Here  [3XV[0m  is  a  finite-dimensional  left  module over a quantized enveloping
  algebra.  Let  [3XC[0m  be  the  crystal  basis of [3XV[0m (i.e., output by [2XCrystalBasis[0m
  ([14X3.10-11[0m)).  This function returns a list of cosets of the basis elements of
  [3XC[0m modulo qL, where L is the Z[q]-lattice spanned by [3XC[0m.
  
  The coset of a vector [3Xv[0m is printed as [3X<v>[0m.
  
  The crystal vectors are used to construct the point set of the crystal graph
  of [3XV[0m ([2XCrystalGraph:for a module[0m ([14X???CrystalGraph:for a module???[0m)).
  
  This  function  only  works for modules for which [2XWeightsAndVectors[0m ([14X3.8-14[0m)
  works.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> U:= QuantizedUEA( RootSystem( "B", 2 ) );;[0X
    [4Xgap> V:= HighestWeightModule( U, [1,1] );[0X
    [4X<16-dimensional left-module over QuantumUEA( <root system of type B[0X
    [4X2>, Qpar = q )>[0X
    [4Xgap> CrystalVectors( V );[0X
    [4X[ <1*v0>, <F1*v0>, <F4*v0>, <F2*v0>, <F1*F4*v0>, <F3*v0>,[0X
    [4X  <(-q^-4)*F1*F2*v0>, <F2*F4*v0>, <F1*F3*v0>, <F3*F4*v0>,[0X
    [4X  <(-q^-1)*F1*F3*v0+(-q^-3)*F2^(2)*v0>, <(-q^-4)*F2*F3*v0+(-q^-2)*F2^(2)*F[0X
    [4X    4*v0>, <F2^(2)*F4*v0>, <(q^-4)*F2^(3)*v0>, <(-q^-1)*F3^(2)*v0>,[0X
    [4X  <(q^-5)*F2^(2)*F3*v0> ][0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.10-13 Falpha[0m
  
  [2X> Falpha( [0X[3Xv, ind[0X[2X ) ________________________________________________[0Xoperation
  
  Here [3Xv[0m is a crystal vector, i.e., an element of [3XCrystalVectors( V )[0m, where [3XV[0m
  is  a left module over a quantized enveloping algebra. This function returns
  the  result  of applying the [3Xind[0m-th Kashiwara operator widetildeF_alpha_[3Xind[0m}
  to v. The result is [3Xfail[0m if widetildeF_alpha_[3Xind[0m}[3X(v)=0[0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> U:= QuantizedUEA( RootSystem( "B", 2 ) );;[0X
    [4Xgap> V:= HighestWeightModule( U, [1,1] );;[0X
    [4Xgap> c:=CrystalVectors( V );;[0X
    [4Xgap> Falpha( c[2], 2 );[0X
    [4X<F2*v0>[0X
    [4Xgap> Falpha( c[3], 2 );[0X
    [4Xfail[0X
    [4Xgap> Falpha( Falpha( Falpha( c[1], 1 ), 2 ), 1 );[0X
    [4Xfail[0X
    [4Xgap> p:= DominantLSPath( RootSystem( "B", 2 ), [1,1] );[0X
    [4X<LS path of shape [ 1, 1 ] ending in [ 1, 1 ] >[0X
    [4Xgap> Falpha( Falpha( Falpha( p, 1 ), 2 ), 1 );[0X
    [4Xfail[0X
  [4X------------------------------------------------------------------[0X
  
  The  last  part  of  this  example  is  an illustration of the fact that the
  crystal  graph of a highest-weight module can be obtained by the path method
  (see Section [14X2.7[0m).
  
  [1X3.10-14 Ealpha[0m
  
  [2X> Ealpha( [0X[3Xv, ind[0X[2X ) ________________________________________________[0Xoperation
  
  Here [3Xv[0m is a crystal vector, i.e., an element of [3XCrystalVectors( V )[0m, where [3XV[0m
  is  a left module over a quantized enveloping algebra. This function returns
  the  result  of applying the [3Xind[0m-th Kashiwara operator widetildeE_alpha_[3Xind[0m}
  to v. The result is [3Xfail[0m if widetildeE_alpha_[3Xind[0m}[3X(v)=0[0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> U:= QuantizedUEA( RootSystem( "B", 2 ) );;[0X
    [4Xgap> V:= HighestWeightModule( U, [1,1] );;[0X
    [4Xgap> c:=CrystalVectors( V );;[0X
    [4Xgap> Ealpha( c[3], 1 );[0X
    [4Xfail[0X
    [4Xgap> Ealpha( c[3], 2 );[0X
    [4X<1*v0>[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.10-15 CrystalGraph[0m
  
  [2X> CrystalGraph( [0X[3XV[0X[2X ) ________________________________________________[0Xfunction
  
  Returns  the crystal graph of the module [3XV[0m. The points of this graph are the
  cosets output by [2XCrystalVectors[0m ([14X3.10-12[0m). The edges work in the same way as
  in  [2XCrystalGraph:for root system and weight[0m ([14X???CrystalGraph:for root system
  and weight???[0m).
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> U:= QuantizedUEA( RootSystem("A",2) );;[0X
    [4Xgap> V1:= HighestWeightModule( U, [1,0] );;[0X
    [4Xgap> V2:= HighestWeightModule( U, [0,1] );;[0X
    [4Xgap> W:= TensorProductOfAlgebraModules( V1, V2 );;[0X
    [4Xgap> CrystalGraph( W );[0X
    [4Xrec([0X
    [4X  points := [ <1*(1*v0<x>1*v0)>, <1*(F1*v0<x>1*v0)>, <1*(1*v0<x>F3*v0)>,[0X
    [4X      <1*(1*v0<x>F2*v0)+q^-1*(F2*v0<x>1*v0)>,[0X
    [4X      <-q^-1*(1*v0<x>F2*v0)+q^-1*(F1*v0<x>F3*v0)>, <1*(F2*v0<x>F3*v0)>,[0X
    [4X      <-q^-1*(F1*v0<x>F2*v0)>, <-q^-1*(F2*v0<x>F2*v0)>,[0X
    [4X      <-q^-3*(1*v0<x>F2*v0)+-q^-1*(F1*v0<x>F3*v0)+1*(F2*v0<x>1*v0)> ],[0X
    [4X  edges := [ [ [ 1, 2 ], 1 ], [ [ 1, 3 ], 2 ], [ [ 2, 4 ], 2 ],[0X
    [4X      [ [ 3, 5 ], 1 ], [ [ 4, 6 ], 2 ], [ [ 5, 7 ], 1 ], [ [ 6, 8 ], 1 ],[0X
    [4X      [ [ 7, 8 ], 2 ] ] )[0X
  [4X------------------------------------------------------------------[0X
  
  
  [1X3.11 Universal enveloping algebras[0X
  
  Here  we describe functions for connecting a quantized enveloping algebra to
  the corresponding universal enveloping algebra.
  
  [1X3.11-1 UEA[0m
  
  [2X> UEA( [0X[3XL[0X[2X ) ________________________________________________________[0Xattribute
  
  This  function  returns the universal enveloping algebra [3Xu[0m of the semisimple
  Lie  algebra  [3XL[0m. The generators of [3Xu[0m are the generators of a Kostant lattice
  in the universal enveloping algebra (these generators are obtained from [3XL[0m by
  [3XLatticeGeneratorsInUEA( L )[0m, see the [5XGAP[0m reference manual).
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> L:= SimpleLieAlgebra( "B", 2, Rationals );[0X
    [4X<Lie algebra of dimension 10 over Rationals>[0X
    [4Xgap> u:= UEA( L );[0X
    [4X<algebra over Rationals, with 10 generators>[0X
    [4Xgap> g:= GeneratorsOfAlgebra( u );[0X
    [4X[ y1, y2, y3, y4, x1, x2, x3, x4, ( h9/1 ), ( h10/1 ) ][0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.11-2 UnderlyingLieAlgebra[0m
  
  [2X> UnderlyingLieAlgebra( [0X[3Xu[0X[2X ) _______________________________________[0Xattribute
  
  For  a  universal  enveloping  algebra  [3Xu[0m  constructed by [2XUEA[0m ([14X3.11-1[0m), this
  returns the corresponding semisimple Lie algebra
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> L:= SimpleLieAlgebra( "B", 2, Rationals );;[0X
    [4Xgap> u:= UEA( L );;[0X
    [4Xgap> UnderlyingLieAlgebra( u );[0X
    [4X<Lie algebra of dimension 10 over Rationals>[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.11-3 HighestWeightModule[0m
  
  [2X> HighestWeightModule( [0X[3Xu, hw[0X[2X ) ____________________________________[0Xoperation
  
  For  a  universal  enveloping  algebra  [3Xu[0m  constructed by [2XUEA[0m ([14X3.11-1[0m), this
  returns the irreducible highest weight module over [3Xu[0m with highest weight [3Xhw[0m,
  which must be dominant. This module is the same as the corresponding highest
  weight  module  over  the  semisimple  Lie  algebra,  but  in  this case the
  enveloping algebra [3Xu[0m acts.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> L:= SimpleLieAlgebra( "B", 2, Rationals );;[0X
    [4Xgap> u:= UEA( L );;[0X
    [4Xgap> HighestWeightModule( u, [2,3] );[0X
    [4X<140-dimensional left-module over <algebra over Rationals, with[0X
    [4X10 generators>>[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.11-4 QUEAToUEAMap[0m
  
  [2X> QUEAToUEAMap( [0X[3XL[0X[2X ) _______________________________________________[0Xattribute
  
  Here  [3XL[0m  is  a  semisimple  Lie  algebra.  Set  [3Xu  :=  UEA(  L  )[0m,  and [3XU :=
  QuantizedUEA(  L  )[0m  (so  [3Xu,  U[0m  are  the  universal enveloping algebra, and
  "generic"   quantized   enveloping   algebra   of   [3XL[0m   respectively).  Then
  [3XQUEAToUEAMap(  L  )[0m returns the algebra homomorphism from [3XU[0m to [3Xu[0m obtained by
  mapping  [3Xq[0m  to  [3X1[0m,  a  generator  [3XFi[0m,  corresponding to a simple root to the
  generator  [3Xyi[0m  (corresponding  to the same simple root), and likewise for [3XEi[0m
  and [3Xxi[0m. This means that [3XKi[0m is mapped to one, and [3X[ Ki : s ][0m to [3Xhi[0m choose [3Xs[0m.
  
  The canonical basis of [3XU[0m is mapped to the canonical basis of [3Xu[0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> L:= SimpleLieAlgebra( "B", 2, Rationals );;[0X
    [4Xgap> f:= QUEAToUEAMap( L );[0X
    [4X<mapping: QuantumUEA( <root system of rank[0X
    [4X2>, Qpar = q ) -> Algebra( Rationals, [ y1, y2, y3, y4, x1, x2, x3, x4,[0X
    [4X  ( h9/1 ), ( h10/1 ) ] ) >[0X
    [4Xgap> U:= Source( f );[0X
    [4XQuantumUEA( <root system of rank 2>, Qpar = q )[0X
    [4Xgap> u:= Range( f );[0X
    [4X<algebra over Rationals, with 10 generators>[0X
    [4Xgap> B:= CanonicalBasis( U );;[0X
    [4Xgap> p:= PBWElements( B, [1,2] );[0X
    [4X[ F1*F4^(2), (q+q^3)*F1*F4^(2)+F2*F4, (q^4)*F1*F4^(2)+(q)*F2*F4+F3 ][0X
    [4Xgap> pu:= List( p, x -> Image( f, x ) );[0X
    [4X[ y1*y2^(2), 2*y1*y2^(2)+y2*y3-2*y4, y1*y2^(2)+y2*y3-1*y4 ][0X
    [4Xgap> V:= HighestWeightModule( u, [2,1] );[0X
    [4X<40-dimensional left-module over <algebra over Rationals, with[0X
    [4X10 generators>>[0X
    [4Xgap> List( pu, x -> x^Basis(V)[1] );[0X
    [4X[ 0*v0, y2*y3*v0+-2*y4*v0, y2*y3*v0+-1*y4*v0 ][0X
    [4X# Which gives us a piece of the canonical basis of V.[0X
  [4X------------------------------------------------------------------[0X
  
