<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (quagroup) - Chapter 3: QuaGroup</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
</head>
<body>


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">Top of Book</a>&nbsp;  &nbsp;<a href="chap2.html">Previous Chapter</a>&nbsp;  &nbsp;<a href="chapBib.html">Next Chapter</a>&nbsp;  </div>

<p><a id="X80C9BD6584865157" name="X80C9BD6584865157"></a></p>
<div class="ChapSects"><a href="chap3.html#X80C9BD6584865157">3 <span class="Heading">QuaGroup</span></a>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap3.html#X7C202C54806653DE">3.1 <span class="Heading">Global constants</span></a>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8748A60A7AB09B0C">3.1-1 QuantumField</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X87FCF1537A81E11D">3.1-2 _q</a></span>
</div>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap3.html#X83804A6F84BB2387">3.2 <span class="Heading">Gaussian integers</span></a>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7985B6A67A30FDA1">3.2-1 GaussNumber</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7EF34AC07BDFEF20">3.2-2 GaussianFactorial</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7F1A5A457926F3CF">3.2-3 GaussianBinomial</a></span>
</div>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap3.html#X87064F787DEA9E21">3.3 <span class="Heading">Roots and root systems</span></a>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X80D15C027BB8029B">3.3-1 RootSystem</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X79E8AE3A8739D11A">3.3-2 BilinearFormMatNF</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X853E620A79D796E7">3.3-3 PositiveRootsNF</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7D2E78B678C73E69">3.3-4 SimpleSystemNF</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7A5DFEAB7EC0D945">3.3-5 PositiveRootsInConvexOrder</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7A5BD2D77ED1BEDD">3.3-6 SimpleRootsAsWeights</a></span>
</div>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap3.html#X798CE6777FC473DD">3.4 <span class="Heading">Weyl groups and their elements</span></a>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7D738A0E85CD5C14">3.4-1 ApplyWeylElement</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X792A49A8808D1C64">3.4-2 LengthOfWeylWord</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X83851E7D7ED84A48">3.4-3 LongestWeylWord</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X81FC70FA84F1B6E9">3.4-4 ReducedWordIterator</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8264626678D9F39A">3.4-5 ExchangeElement</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X84138DD47BBEA4E0">3.4-6 GetBraidRelations</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X800BB9837DCF1DBD">3.4-7 LongWords</a></span>
</div>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap3.html#X81394E207F6AA6CF">3.5 <span class="Heading">Quantized enveloping algebras </span></a>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7C263EA87C6E4F8A">3.5-1 QuantizedUEA</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7E3D93D47AFDE8D4">3.5-2 ObjByExtRep</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8542B32A8206118C">3.5-3 ExtRepOfObj</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7879B74F7C77E930">3.5-4 QuantumParameter</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X82B42CD279854DFC">3.5-5 CanonicalMapping</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X87C302567A9B2AD3">3.5-6 WriteQEAToFile</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X874B8E4A83180063">3.5-7 ReadQEAFromFile</a></span>
</div>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap3.html#X847A0459844B7A59">3.6 <span class="Heading"> Homomorphisms and automorphisms </span></a>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8185FE54820AA950">3.6-1 QEAHomomorphism</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X81214E9B8532B06F">3.6-2 QEAAutomorphism</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X79D886AB7B248F75">3.6-3 QEAAntiAutomorphism</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X851AE6987871E0E8">3.6-4 AutomorphismOmega</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7E288BFE7FDF8BEA">3.6-5 AntiAutomorphismTau</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8576A5987AD999F0">3.6-6 BarAutomorphism</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8277D87D7D81AE75">3.6-7 AutomorphismTalpha</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7DC17C2D8540FCED">3.6-8 DiagramAutomorphism</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8123456781234567">3.6-9 \*</a></span>
</div>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap3.html#X832B6D897BDBC8A3">3.7 <span class="Heading">Hopf algebra structure</span></a>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8245FA64874E085D">3.7-1 TensorPower</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X783144818681D2E6">3.7-2 UseTwistedHopfStructure</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X811565FF83FA4847">3.7-3 ComultiplicationMap</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7985B7EF7E31C4DF">3.7-4 AntipodeMap</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8361876D8770FC06">3.7-5 CounitMap</a></span>
</div>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap3.html#X8183A6857B0C3633">3.8 <span class="Heading">Modules</span></a>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7ED0FA2980330CE1">3.8-1 HighestWeightModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7B00688F82AACDD0">3.8-2 IrreducibleQuotient</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7B080C0078370E99">3.8-3 HWModuleByTensorProduct</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7C03DC018016B93B">3.8-4 DIYModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X854FA09F7E07D2D0">3.8-5 TensorProductOfAlgebraModules</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7F0AED7A85D603A2">3.8-6 HWModuleByGenerator</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8565D4CD82EB2503">3.8-7 InducedQEAModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8680D0D67BACAE16">3.8-8 GenericModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X82B42CD279854DFC">3.8-9 CanonicalMapping</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7DCD17BF7B76E7CA">3.8-10 U2Module</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7E1B059780BB2E09">3.8-11 MinusculeModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X79C8F1317C2E8C60">3.8-12 DualAlgebraModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X87EBE47D86292754">3.8-13 TrivialAlgebraModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7929063E7C428331">3.8-14 WeightsAndVectors</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7EEEBA347A816827">3.8-15 HighestWeightsAndVectors</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X799E7D5981B9F14A">3.8-16 RMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X78E533D2813BDA9E">3.8-17 IsomorphismOfTensorModules</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X87FF182B86367CC4">3.8-18 WriteModuleToFile</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7DD49D8282C516B9">3.8-19 ReadModuleFromFile</a></span>
</div>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap3.html#X83BBB99685FB9FB7">3.9 <span class="Heading">The path model</span></a>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8025E1918067B03C">3.9-1 DominantLSPath</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X82EDAFAB7E81BD1F">3.9-2 Falpha</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X855C478587112804">3.9-3 Ealpha</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X820413E57DEDB0D1">3.9-4 LSSequence</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8573A4077DB4659F">3.9-5 WeylWord</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7D06353282BE96C6">3.9-6 EndWeight</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8637218B80BDC906">3.9-7 CrystalGraph</a></span>
</div>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap3.html#X827A177C8416C576">3.10 <span class="Heading"> Canonical bases </span></a>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8215C71E8361EE62">3.10-1 Falpha</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X814B1C7B7AF17B79">3.10-2 Ealpha</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7C8EBFF5805F8C51">3.10-3 CanonicalBasis</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8233212A79D722FB">3.10-4 PBWElements</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X81631585816C4CCD">3.10-5 MonomialElements</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X782174177D696504">3.10-6 Strings</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X842A5CC07C3E5848">3.10-7 PrincipalMonomial</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7C04F75683D0A512">3.10-8 StringMonomial</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7E67BE5D856C77DC">3.10-9 Falpha</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X855EFC817CFCE2C7">3.10-10 Ealpha</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X85A9229678572948">3.10-11 CrystalBasis</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X82CE52AB7E798902">3.10-12 CrystalVectors</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X80A534637D8F3210">3.10-13 Falpha</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7B9C76BF841FA70B">3.10-14 Ealpha</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7D7607BB81ADF579">3.10-15 CrystalGraph</a></span>
</div>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap3.html#X7875070C85DD4E8E">3.11 <span class="Heading"> Universal enveloping algebras </span></a>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7E7B25307E6478CD">3.11-1 UEA</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7CA021E28527763E">3.11-2 UnderlyingLieAlgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8707EE2C8145701F">3.11-3 HighestWeightModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7AD80E5C7E015859">3.11-4 QUEAToUEAMap</a></span>
</div>
</div>

<h3>3 <span class="Heading">QuaGroup</span></h3>

<p>In this chapter we describe the functionality provided by <strong class="pkg">QuaGroup</strong>.</p>

<p><a id="X7C202C54806653DE" name="X7C202C54806653DE"></a></p>

<h4>3.1 <span class="Heading">Global constants</span></h4>

<p><a id="X8748A60A7AB09B0C" name="X8748A60A7AB09B0C"></a></p>

<h5>3.1-1 QuantumField</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; QuantumField</code></td><td class="tdright">( global variable )</td></tr></table></div>
<p>This is the field Q(q) of rational functions in q, over Q.</p>


<table class="example">
<tr><td><pre>
gap&gt; QuantumField;
QuantumField
</pre></td></tr></table>

<p><a id="X87FCF1537A81E11D" name="X87FCF1537A81E11D"></a></p>

<h5>3.1-2 _q</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; _q</code></td><td class="tdright">( global variable )</td></tr></table></div>
<p>This is an indeterminate; <var class="Arg">QuantumField</var> is the field of rational functions in this indeterminate. The identifier <var class="Arg">_q</var> is fixed once the package <strong class="pkg">QuaGroup</strong> is loaded. The symbol <var class="Arg">_q</var> is chosen (instead of <var class="Arg">q</var>) in order to avoid potential name clashes. We note that <var class="Arg">_q</var> is printed as <var class="Arg">q</var>.</p>


<table class="example">
<tr><td><pre>
gap&gt; _q;
q
gap&gt; _q in QuantumField;
true
</pre></td></tr></table>

<p><a id="X83804A6F84BB2387" name="X83804A6F84BB2387"></a></p>

<h4>3.2 <span class="Heading">Gaussian integers</span></h4>

<p><a id="X7985B6A67A30FDA1" name="X7985B6A67A30FDA1"></a></p>

<h5>3.2-1 GaussNumber</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; GaussNumber</code>( <var class="Arg">n, par</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>This function computes for the integer <var class="Arg">n</var> the Gaussian integer [n]_v=<var class="Arg">par</var> (cf. Section <a href="chap2.html#X7AAC838B7CEB5E54"><b>2.1</b></a>).</p>


<table class="example">
<tr><td><pre>
gap&gt; GaussNumber( 4, _q );
q^-3+q^-1+q+q^3
</pre></td></tr></table>

<p><a id="X7EF34AC07BDFEF20" name="X7EF34AC07BDFEF20"></a></p>

<h5>3.2-2 GaussianFactorial</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; GaussianFactorial</code>( <var class="Arg">n, par</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>This function computes for the integer <var class="Arg">n</var> the Gaussian factorial [n]!_v=<var class="Arg">par</var>.</p>


<table class="example">
<tr><td><pre>
gap&gt; GaussianFactorial( 3, _q );
q^-3+2*q^-1+2*q+q^3
gap&gt; GaussianFactorial( 3, _q^2 );
q^-6+2*q^-2+2*q^2+q^6
</pre></td></tr></table>

<p><a id="X7F1A5A457926F3CF" name="X7F1A5A457926F3CF"></a></p>

<h5>3.2-3 GaussianBinomial</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; GaussianBinomial</code>( <var class="Arg">n, k, par</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>This function computes for two integers <var class="Arg">n</var> and <var class="Arg">k</var> the Gaussian binomial <var class="Arg">n</var> choose <var class="Arg">k</var>, where the parameter v is replaced by <var class="Arg">par</var>.</p>


<table class="example">
<tr><td><pre>
gap&gt; GaussianBinomial( 5, 2, _q^2 );
q^-12+q^-8+2*q^-4+2+2*q^4+q^8+q^12
</pre></td></tr></table>

<p><a id="X87064F787DEA9E21" name="X87064F787DEA9E21"></a></p>

<h4>3.3 <span class="Heading">Roots and root systems</span></h4>

<p>In this section we describe some functions for dealing with root systems. These functions supplement the ones already present in the <strong class="pkg">GAP</strong> library.</p>

<p><a id="X80D15C027BB8029B" name="X80D15C027BB8029B"></a></p>

<h5>3.3-1 RootSystem</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; RootSystem</code>( <var class="Arg">type, rank</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; RootSystem</code>( <var class="Arg">list</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Here <var class="Arg">type</var> is a capital letter between <var class="Arg">"A"</var> and <var class="Arg">"G"</var>, and <var class="Arg">rank</var> is a positive integer (&gt;= 1 if <var class="Arg">type="A"</var>, &gt;= 2 if <var class="Arg">type="B"</var>, <var class="Arg">"C"</var>, &gt;= 4 if <var class="Arg">type="D"</var>, 6,7,8 if <var class="Arg">type="E"</var>, 4 if <var class="Arg">type="F"</var>, and 2 if <var class="Arg">type="G"</var>). This function returns the root system of type <var class="Arg">type</var> and rank <var class="Arg">rank</var>. In the second form <var class="Arg">list</var> is a list of types and ranks, e.g., <var class="Arg">[ "B", 2, "F", 4, "D", 7 ]</var>.</p>

<p>The root system constructed by this function comes with he attributes <var class="Arg">PositiveRoots</var>, <var class="Arg">NegativeRoots</var>, <var class="Arg">SimpleSystem</var>, <var class="Arg">CartanMatrix</var>, <var class="Arg">BilinearFormMat</var>. Here the attribute <var class="Arg">SimpleSystem</var> contains a set of simple roots, written as unit vectors. <var class="Arg">PositiveRoots</var> is a list of the positive roots, written as linear combinations of the simple roots, and likewise for <var class="Arg">NegativeRoots</var>. <var class="Arg">CartanMatrix( R )</var> is the Cartan matrix of the root system <var class="Arg">R</var>, where the entry on position ( i, j ) is given by &lt; alpha_i, alpha_j^v&gt; where alpha_i is the i-th simple root. <var class="Arg">BilinearFormMat( R )</var> is the matrix of the bilinear form, where the entry on position ( i, j ) is given by ( alpha_i, alpha_j ) (see Section <a href="chap2.html#X81394E207F6AA6CF"><b>2.2</b></a>).</p>

<p><var class="Arg">WeylGroup( R )</var> returns the Weyl group of the root system <var class="Arg">R</var>. We refer to the <strong class="pkg">GAP</strong> reference manual for an overview of the functions for Weyl groups in the <strong class="pkg">GAP</strong> library. We mention the functions <var class="Arg">ConjugateDominantWeight( W, wt )</var> (returns the dominant weight in the <var class="Arg">W</var>-orbit of the weight <var class="Arg">wt</var>), and <var class="Arg">WeylOrbitIterator( W, wt )</var> (returns an iterator for the <var class="Arg">W</var>-orbit containing the weight <var class="Arg">wt</var>). We write weights as integral linear combinations of fundamental weights, so in <strong class="pkg">GAP</strong> weights are represented by lists of integers (of length equal to the rank of the root system).</p>

<p>Also we mention the function <var class="Arg">PositiveRootsAsWeights( R )</var> that returns the positive roots of <var class="Arg">R</var> written as weights, i.e., as linear combinations of the fundamental weights.</p>


<table class="example">
<tr><td><pre>
gap&gt; R:=RootSystem( [ "B", 2, "F", 4, "E", 6 ] );
&lt;root system of type B2 F4 E6&gt;
gap&gt; R:= RootSystem( "A", 2 );
&lt;root system of type A2&gt;
gap&gt; PositiveRoots( R );
[ [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ]
gap&gt; BilinearFormMat( R );
[ [ 2, -1 ], [ -1, 2 ] ]
gap&gt; W:= WeylGroup( R );
Group([ [ [ -1, 1 ], [ 0, 1 ] ], [ [ 1, 0 ], [ 1, -1 ] ] ])
gap&gt; ConjugateDominantWeight( W, [-3,2] );
[ 2, 1 ]
gap&gt; o:= WeylOrbitIterator( W, [-3,2] );
&lt;iterator&gt;
# Using the iterator we can loop over the orbit:
gap&gt; NextIterator( o );
[ 2, 1 ]
gap&gt; NextIterator( o );
[ -1, -2 ]
gap&gt; PositiveRootsAsWeights( R );
[ [ 2, -1 ], [ -1, 2 ], [ 1, 1 ] ]
</pre></td></tr></table>

<p><a id="X79E8AE3A8739D11A" name="X79E8AE3A8739D11A"></a></p>

<h5>3.3-2 BilinearFormMatNF</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; BilinearFormMatNF</code>( <var class="Arg">R</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>This is the matrix of the "normalized" bilinear form. This means that all diagonal entries are even, and 2 is the minimum value occurring on the diagonal. If <var class="Arg">R</var> is a root system constructed by <code class="func">RootSystem</code> (<a href="chap3.html#X80D15C027BB8029B"><b>3.3-1</b></a>), then this is equal to <var class="Arg">BilinearFormMat( R )</var>.</p>

<p><a id="X853E620A79D796E7" name="X853E620A79D796E7"></a></p>

<h5>3.3-3 PositiveRootsNF</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; PositiveRootsNF</code>( <var class="Arg">R</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>This is the list of positive roots of the root system <var class="Arg">R</var>, written as linear combinations of the simple roots. This means that the simple roots are unit vectors. If <var class="Arg">R</var> is a root system constructed by <code class="func">RootSystem</code> (<a href="chap3.html#X80D15C027BB8029B"><b>3.3-1</b></a>), then this is equal to <var class="Arg">PositiveRoots( R )</var>.</p>

<p>One of the reasons for writing the positive roots like this is the following. Let <var class="Arg">a, b</var> be two elements of <var class="Arg">PositiveRootsNF( R )</var>, and let <var class="Arg">B</var> be the matrix of the bilinear form. Then <var class="Arg">a*( B*b )</var> is the result of applying the bilinear form to <var class="Arg">a, b</var>.</p>


<table class="example">
<tr><td><pre>
gap&gt; R:= RootSystem( SimpleLieAlgebra( "B", 2, Rationals ) );;
gap&gt; PositiveRootsNF( R );
[ [ 1, 0 ], [ 0, 1 ], [ 1, 1 ], [ 1, 2 ] ]
# We note that in this case PositiveRoots( R ) will give the positive roots in
# a different format.
</pre></td></tr></table>

<p><a id="X7D2E78B678C73E69" name="X7D2E78B678C73E69"></a></p>

<h5>3.3-4 SimpleSystemNF</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; SimpleSystemNF</code>( <var class="Arg">R</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>This is the list of simple roots of <var class="Arg">R</var>, written as unit vectors (this means that they are elements of <var class="Arg">PositiveRootsNF( R )</var>). If <var class="Arg">R</var> is a root system constructed by <code class="func">RootSystem</code> (<a href="chap3.html#X80D15C027BB8029B"><b>3.3-1</b></a>), then this is equal to <var class="Arg">SimpleSystem( R )</var>.</p>

<p><a id="X7A5DFEAB7EC0D945" name="X7A5DFEAB7EC0D945"></a></p>

<h5>3.3-5 PositiveRootsInConvexOrder</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; PositiveRootsInConvexOrder</code>( <var class="Arg">R</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>This function returns the positive roots of the root system <var class="Arg">R</var>, in the "convex" order. Let w_0=s_1cdots s_t be a reduced expression of the longest element in the Weyl group. Then the k-th element of the list returned by this function is s_1cdots s_k-1(alpha_k). (Where the reduced expression used is the one returned by <var class="Arg">LongestWeylWord( R )</var>.) If alpha, beta and alpha+beta are positive roots, then alpha+beta occurs between alpha and beta (whence the name convex order).</p>

<p>In the output all roots are written in "normal form", i.e., as elements of <var class="Arg">PositiveRootsNF( R )</var>.</p>


<table class="example">
<tr><td><pre>
gap&gt; R:= RootSystem( "G", 2 );;
gap&gt; PositiveRootsInConvexOrder( R );
[ [ 1, 0 ], [ 3, 1 ], [ 2, 1 ], [ 3, 2 ], [ 1, 1 ], [ 0, 1 ] ]
</pre></td></tr></table>

<p><a id="X7A5BD2D77ED1BEDD" name="X7A5BD2D77ED1BEDD"></a></p>

<h5>3.3-6 SimpleRootsAsWeights</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; SimpleRootsAsWeights</code>( <var class="Arg">R</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns the simple roots of the root system <var class="Arg">R</var>, written as linear combinations of the fundamental weights.</p>


<table class="example">
<tr><td><pre>
gap&gt; R:= RootSystem( "A", 2 );;
gap&gt; SimpleRootsAsWeights( R );
[ [ 2, -1 ], [ -1, 2 ] ]
</pre></td></tr></table>

<p><a id="X798CE6777FC473DD" name="X798CE6777FC473DD"></a></p>

<h4>3.4 <span class="Heading">Weyl groups and their elements</span></h4>

<p>Now we describe a few functions that deal with reduced words in the Weyl group of the root system <var class="Arg">R</var>. These words are represented as lists of positive integers i, denoting the i-th simple reflection (which corresponds to the i-th element of <var class="Arg">SimpleSystem( R )</var>). For example <var class="Arg">[ 3, 2, 1, 3, 1 ]</var> represents the expression s_3 s_2 s_1 s_3 s_1.</p>

<p><a id="X7D738A0E85CD5C14" name="X7D738A0E85CD5C14"></a></p>

<h5>3.4-1 ApplyWeylElement</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ApplyWeylElement</code>( <var class="Arg">W, wt, wd</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Here <var class="Arg">wd</var> is a (not necessarily reduced) word in the Weyl group <var class="Arg">W</var>, and <var class="Arg">wt</var> is a weight (written as integral linear combination of the simple weights). This function returns the result of applying <var class="Arg">wd</var> to <var class="Arg">wt</var>. For example, if <var class="Arg">wt=</var>mu, and <var class="Arg">wd = [ 1, 2 ]</var> then this function returns s_1s_2(mu) (where s_i is the simple reflection corresponding to the i-th simple root).</p>


<table class="example">
<tr><td><pre>
gap&gt; W:= WeylGroup( RootSystem( "G", 2 ) ) ;;
gap&gt; ApplyWeylElement( W, [ -3, 7 ], [ 1, 1, 2, 1, 2 ] );
[ 15, -11 ]
</pre></td></tr></table>

<p><a id="X792A49A8808D1C64" name="X792A49A8808D1C64"></a></p>

<h5>3.4-2 LengthOfWeylWord</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; LengthOfWeylWord</code>( <var class="Arg">W, wd</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Here <var class="Arg">wd</var> is a word in the Weyl group <var class="Arg">W</var>. This function returns the length of that word.</p>


<table class="example">
<tr><td><pre>
gap&gt; W:= WeylGroup( RootSystem( "F", 4 ) ) ;
&lt;matrix group with 4 generators&gt;
gap&gt; LengthOfWeylWord( W, [ 1, 3, 2, 4, 2 ] );
3
</pre></td></tr></table>

<p><a id="X83851E7D7ED84A48" name="X83851E7D7ED84A48"></a></p>

<h5>3.4-3 LongestWeylWord</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; LongestWeylWord</code>( <var class="Arg">R</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Here <var class="Arg">R</var> is a root system. <var class="Arg">LongestWeylWord( R )</var> returns the longest word in the Weyl group of <var class="Arg">R</var>.</p>

<p>If this function is called for a root system <var class="Arg">R</var>, a reduced expression for the longest element in the Weyl group is calculated (the one which is the smallest in the lexicographical ordering). However, if you would like to work with a different reduced expression, then it is possible to set it by <var class="Arg">SetLongestWeylWord( R, wd )</var>, where <var class="Arg">wd</var> is a reduced expression of the longest element in the Weyl group. Note that you will have to do this before calling <var class="Arg">LongestWeylWord</var>, or any function that may call <var class="Arg">LongestWeylWord</var> (once the attribute is set, it will not be possible to change it). Note also that you must be sure that the word you give is in fact a reduced expression for the longest element in the Weyl group, as this is not checked (you can check this with <code class="func">LengthOfWeylWord</code> (<a href="chap3.html#X792A49A8808D1C64"><b>3.4-2</b></a>)).</p>

<p>We note that virtually all algorithms for quantized enveloping algebras depend on the choice of reduced expression for the longest element in the Weyl group (as the PBW-type basis depends on this).</p>


<table class="example">
<tr><td><pre>
gap&gt; R:= RootSystem( "G", 2 );;
gap&gt; LongestWeylWord( R );
[ 1, 2, 1, 2, 1, 2 ]
</pre></td></tr></table>

<p><a id="X81FC70FA84F1B6E9" name="X81FC70FA84F1B6E9"></a></p>

<h5>3.4-4 ReducedWordIterator</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ReducedWordIterator</code>( <var class="Arg">W, wd</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Here <var class="Arg">W</var> is a Weyl group, and <var class="Arg">wd</var> a reduced word. This function returns an iterator for the set of reduced words that represent the same element as <var class="Arg">wd</var>. The elements are output in ascending lexicographical order.</p>


<table class="example">
<tr><td><pre>
gap&gt; R:= RootSystem( "F", 4 );;
gap&gt; it:= ReducedWordIterator( WeylGroup(R), LongestWeylWord(R) );
&lt;iterator&gt;
gap&gt; NextIterator( it );
[ 1, 2, 1, 3, 2, 1, 3, 2, 3, 4, 3, 2, 1, 3, 2, 3, 4, 3, 2, 1, 3, 2, 3, 4 ]
gap&gt; k:= 1;;
gap&gt; while not IsDoneIterator( it ) do
&gt; k:= k+1; w:= NextIterator( it );
&gt; od;
gap&gt; k;
2144892
</pre></td></tr></table>

<p>So there are 2144892 reduced expressions for the longest element in the Weyl group of type F_4.</p>

<p><a id="X8264626678D9F39A" name="X8264626678D9F39A"></a></p>

<h5>3.4-5 ExchangeElement</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ExchangeElement</code>( <var class="Arg">W, wd, ind</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Here <var class="Arg">W</var> is a Weyl group, and <var class="Arg">wd</var> is a <em>reduced</em> word in <var class="Arg">W</var>, and <var class="Arg">ind</var> is an index between 1 and the rank of the root system. Let <var class="Arg">v</var> denote the word obtained from <var class="Arg">wd</var> by adding <var class="Arg">ind</var> at the end. This function <em>assumes</em> that the length of <var class="Arg">v</var> is one less than the length of <var class="Arg">wd</var>, and returns a reduced expression for <var class="Arg">v</var> that is obtained from <var class="Arg">wd</var> by deleting one entry. Nothing is guaranteed of the output if the length of <var class="Arg">v</var> is bigger than the length of <var class="Arg">wd</var>.</p>


<table class="example">
<tr><td><pre>
gap&gt; R:= RootSystem( "G", 2 );;
gap&gt; wd:= LongestWeylWord( R );;
gap&gt; ExchangeElement( WeylGroup(R), wd, 1 );
[ 2, 1, 2, 1, 2 ]
</pre></td></tr></table>

<p><a id="X84138DD47BBEA4E0" name="X84138DD47BBEA4E0"></a></p>

<h5>3.4-6 GetBraidRelations</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; GetBraidRelations</code>( <var class="Arg">W, wd1, wd2</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Here <var class="Arg">W</var> is a Weyl group, and <var class="Arg">wd1</var>, <var class="Arg">wd2</var> are two reduced words representing the same element in <var class="Arg">W</var>. This function returns a list of braid relations that can be applied to <var class="Arg">wd1</var> to obtain <var class="Arg">wd2</var>. Here a braid relation is represented as a list, with at the odd positions integers that represent positions in a word, and at the even positions the indices that are on those positions after applying the relation. For example, let <var class="Arg">wd</var> be the word <var class="Arg">[ 1, 2, 1, 3, 2, 1 ]</var> and let <var class="Arg">r = [ 3, 3, 4, 1 ]</var> be a relation. Then the result of applying <var class="Arg">r</var> to <var class="Arg">wd</var> is <var class="Arg">[ 1, 2, 3, 1, 2, 1]</var> (i.e., on the third position we put a 3, and on the fourth position a 1).</p>

<p>We note that the function does not check first whether <var class="Arg">wd1</var> and <var class="Arg">wd2</var> represent the same element in <var class="Arg">W</var>. If this is not the case, then an error will occur during the execution of the function, or it will produce wrong output.</p>


<table class="example">
<tr><td><pre>
gap&gt; R:= RootSystem( "A", 3 );;
gap&gt; wd1:= LongestWeylWord( R );
[ 1, 2, 1, 3, 2, 1 ]
gap&gt; wd2:= [ 1, 3, 2, 1, 3, 2 ];;
gap&gt; GetBraidRelations( WeylGroup(R), wd1, wd2 );
[ [ 3, 3, 4, 1 ], [ 4, 2, 5, 1, 6, 2 ], [ 2, 3, 3, 2, 4, 3 ],
  [ 4, 1, 5, 3 ] ]
</pre></td></tr></table>

<p><a id="X800BB9837DCF1DBD" name="X800BB9837DCF1DBD"></a></p>

<h5>3.4-7 LongWords</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; LongWords</code>( <var class="Arg">R</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>For a root system <var class="Arg">R</var> this returns a list of triples (of length equal to the rank of <var class="Arg">R</var>). Let <var class="Arg">t</var> be the <var class="Arg">k</var>-th triple occurring in this list. The first element of <var class="Arg">t</var> is an expression for the longest element of the Weyl group, starting with <var class="Arg">k</var>. The second element is a list of braid relations, moving this expression to the value of <var class="Arg">LongestWeylWord( R )</var>. The third element is a list of braid relations performing the reverse transformation.</p>


<table class="example">
<tr><td><pre>
gap&gt; R:= RootSystem( "A", 3 );;
gap&gt; LongWords( R )[3];
[ [ 3, 1, 2, 1, 3, 2 ],
  [ [ 3, 3, 4, 1 ], [ 4, 2, 5, 1, 6, 2 ], [ 2, 3, 3, 2, 4, 3 ],
      [ 4, 1, 5, 3 ], [ 1, 3, 2, 1 ] ],
  [ [ 4, 3, 5, 1 ], [ 1, 1, 2, 3 ], [ 2, 2, 3, 3, 4, 2 ],
      [ 4, 1, 5, 2, 6, 1 ], [ 3, 1, 4, 3 ] ] ]
</pre></td></tr></table>

<p><a id="X81394E207F6AA6CF" name="X81394E207F6AA6CF"></a></p>

<h4>3.5 <span class="Heading">Quantized enveloping algebras </span></h4>

<p>In <strong class="pkg">QuaGroup</strong> we deal with two types of quantized enveloping algebra. First there are the quantized enveloping algebras defined over the field <code class="func">QuantumField</code> (<a href="chap3.html#X8748A60A7AB09B0C"><b>3.1-1</b></a>). We say that these algebras are "generic" quantized enveloping algebras, in <strong class="pkg">QuaGroup</strong> they have the category <var class="Arg">IsGenericQUEA</var>. Secondly, we deal with the quantized enveloping algebras that are defined over a different field.</p>

<p><a id="X7C263EA87C6E4F8A" name="X7C263EA87C6E4F8A"></a></p>

<h5>3.5-1 QuantizedUEA</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; QuantizedUEA</code>( <var class="Arg">R</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; QuantizedUEA</code>( <var class="Arg">R, F, v</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; QuantizedUEA</code>( <var class="Arg">L</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; QuantizedUEA</code>( <var class="Arg">L, F, v</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>In the first two forms <var class="Arg">R</var> is a root system. With only <var class="Arg">R</var> as input, the corresponding generic quantized enveloping algebra is constructed. It is stored as an attribute of <var class="Arg">R</var> (so that constructing it twice for the same root system yields the same object). Also the root system is stored in the quantized enveloping algebra as the attribute <var class="Arg">RootSystem</var>.</p>

<p>The attribute <var class="Arg">GeneratorsOfAlgebra</var> contains the generators of a PBW-type basis (see Section <a href="chap2.html#X83E7F39F7D16793B"><b>2.4</b></a>), that are constructed relative to the reduced expression for the longest element in the Weyl group that is contained in <var class="Arg">LongestWeylWord( R )</var>. We refer to <code class="func">ObjByExtRep</code> (<a href="chap3.html#X7E3D93D47AFDE8D4"><b>3.5-2</b></a>) for a description of the construction of elements of a quantized enveloping algebra.</p>

<p>The call <var class="Arg">QuantizedUEA( R, F, v )</var> returns the quantized universal enveloping algebra with quantum parameter <var class="Arg">v</var>, which must lie in the field <var class="Arg">F</var>. In this case the elements of <var class="Arg">GeneratorsOfAlgebra</var> are the images of the generators of the corresponding generic quantized enveloping algebra. This means that if <var class="Arg">v</var> is a root of unity, then the generators will not generate the whole algebra, but rather a finite dimensional subalgebra (as for instance E_i^k=0 for k large enough). It is possible to construct elements that do not lie in this finite dimensional subalgebra using <code class="func">ObjByExtRep</code> (<a href="chap3.html#X7E3D93D47AFDE8D4"><b>3.5-2</b></a>).</p>

<p>In the last two cases <var class="Arg">L</var> must be a semisimple Lie algebra. The two calls are short for <var class="Arg">QuantizedUEA( RootSystem( L ) )</var> and <var class="Arg">QuantizedUEA( RootSystem( L ), F, v )</var> respectively.</p>


<table class="example">
<tr><td><pre>
# We construct the generic quantized enveloping algebra corresponding
# to the root system of type A2+G2:
gap&gt; R:= RootSystem( [ "A", 2, "G", 2 ] );;
gap&gt; U:= QuantizedUEA( R );
QuantumUEA( &lt;root system of type A2 G2&gt;, Qpar = q )
gap&gt; RootSystem( U );
&lt;root system of type A2 G2&gt;
gap&gt; g:= GeneratorsOfAlgebra( U );
[ F1, F2, F3, F4, F5, F6, F7, F8, F9, K1, K1+(q^-1-q)*[ K1 ; 1 ], K2,
  K2+(q^-1-q)*[ K2 ; 1 ], K3, K3+(q^-1-q)*[ K3 ; 1 ], K4,
  K4+(q^-3-q^3)*[ K4 ; 1 ], E1, E2, E3, E4, E5, E6, E7, E8, E9 ]
# These elements generate a PBW-type basis of U; the nine elements Fi,
# and the nine elements Ei correspond to the roots listed in convex order:
gap&gt; PositiveRootsInConvexOrder( R );
[ [ 1, 0, 0, 0 ], [ 1, 1, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 1, 0 ],
  [ 0, 0, 3, 1 ], [ 0, 0, 2, 1 ], [ 0, 0, 3, 2 ], [ 0, 0, 1, 1 ],
  [ 0, 0, 0, 1 ] ]
# So, for example, F5 is an element of weight -[ 0, 0, 3, 1 ].
# We can also multiply elements; the result is written on the PBW-basis:
gap&gt; g[17]*g[4];
(q^-6-1)*F4*[ K4 ; 1 ]+(q^-3)*F4*K4
# Now we construct a non-generic quantized enveloping algebra:
gap&gt; R:= RootSystem( "A", 2 );;
gap&gt; U:= QuantizedUEA( R, CF(3), E(3) );;
gap&gt; g:= GeneratorsOfAlgebra( U );
[ F1, F2, F3, K1, K1+(-E(3)+E(3)^2)*[ K1 ; 1 ], K2,
  K2+(-E(3)+E(3)^2)*[ K2 ; 1 ], E1, E2, E3 ]
</pre></td></tr></table>

<p>As can be seen in the example, every element of U is written as a linear combination of monomials in the PBW-generators; the generators of U^- come first, then the generators of U^0, and finally the generators of U^+.</p>

<p><a id="X7E3D93D47AFDE8D4" name="X7E3D93D47AFDE8D4"></a></p>

<h5>3.5-2 ObjByExtRep</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ObjByExtRep</code>( <var class="Arg">fam, list</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Here <var class="Arg">fam</var> is the elements family of a quantized enveloping algebra <var class="Arg">U</var>. Secondly, <var class="Arg">list</var> is a list describing an element of <var class="Arg">U</var>. We explain how this description works. First we describe an indexing system for the generators of <var class="Arg">U</var>. Let <var class="Arg">R</var> be the root system of <var class="Arg">U</var>. Let <var class="Arg">t</var> be the number of positive roots, and <var class="Arg">rank</var> the rank of the root system. Then the generators of <var class="Arg">U</var> are <var class="Arg">Fk</var>, <var class="Arg">Ki</var> (and its inverse), <var class="Arg">Ek</var>, for <var class="Arg">k=1...t</var>, <var class="Arg">i=1..rank</var>. (See Section <a href="chap2.html#X83E7F39F7D16793B"><b>2.4</b></a>; for the construction of the <var class="Arg">Fk</var>, <var class="Arg">Ek</var>, the value of <var class="Arg">LongestWeylWord( R )</var> is used.) Now the index of <var class="Arg">Fk</var> is <var class="Arg">k</var>, and the index of <var class="Arg">Ek</var> is <var class="Arg">t+rank+k</var>. Furthermore, elements of the algebra generated by the <var class="Arg">Ki</var>, and its inverse, are written as linear combinations of products of "binomials", as in Section <a href="chap2.html#X803D39F580E4E4EE"><b>2.5</b></a>. The element</p>

<p class="pcenter"> K_i^{d}\begin{bmatrix} K_{i} \\ s \end{bmatrix} </p>

<p>(where d=0,1), is indexed as <var class="Arg">[ t+i, d ]</var> (what happens to the <var class="Arg">s</var> is described later). So an index is either an integer, or a list of two integers.</p>

<p>A monomial is a list of indices, each followed by an exponent. First come the indices of the <var class="Arg">Fk</var>, (<var class="Arg">1..t</var>), then come the lists of the form <var class="Arg">[ t+i, d ]</var>, and finally the indices of the <var class="Arg">Ek</var>. Each index is followed by an exponent. An index of the form <var class="Arg">[ t+i, d ]</var> is followed by the <var class="Arg">s</var> in the above formula.</p>

<p>The second argument of <var class="Arg">ObjByExtRep</var> is a list of monomials followed by coefficients. This function returns the element of <var class="Arg">U</var> described by this list.</p>

<p>Finally we remark that the element</p>

<p class="pcenter"> K_i^{d}\begin{bmatrix} K_{i} \\ s \end{bmatrix} </p>

<p>is printed as <var class="Arg">Ki[ Ki ; s ]</var> if <var class="Arg">d=1</var>, and as <var class="Arg">[ Ki ; s ]</var> if <var class="Arg">d=0</var>.</p>


<table class="example">
<tr><td><pre>
gap&gt; U:= QuantizedUEA( RootSystem("A",2) );;
gap&gt; fam:= ElementsFamily( FamilyObj( U ) );;
gap&gt; list:= [ [ 2, 3, [ 4, 0 ], 8, 6, 11 ], _q^2,    # monomial and coefficient
&gt; [ 1, 7, 3, 5, [ 5, 1 ], 3, 8, 9 ], _q^-1 + _q^2 ]; # monomial and coefficient
[ [ 2, 3, [ 4, 0 ], 8, 6, 11 ], q^2, [ 1, 7, 3, 5, [ 5, 1 ], 3, 8, 9 ],
  q^-1+q^2 ]
gap&gt; ObjByExtRep( fam, list );
(q^2)*F2^(3)*[ K1 ; 8 ]*E1^(11)+(q^-1+q^2)*F1^(7)*F3^(5)*K2[ K2 ; 3 ]*E3^(9)
</pre></td></tr></table>

<p><a id="X8542B32A8206118C" name="X8542B32A8206118C"></a></p>

<h5>3.5-3 ExtRepOfObj</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ExtRepOfObj</code>( <var class="Arg">elm</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>For the element <var class="Arg">elm</var> of a quantized enveloping algebra, this function returns the list that defines <var class="Arg">elm</var> (see <code class="func">ObjByExtRep</code> (<a href="chap3.html#X7E3D93D47AFDE8D4"><b>3.5-2</b></a>)).</p>


<table class="example">
<tr><td><pre>
gap&gt; U:= QuantizedUEA( RootSystem("A",2) );;
gap&gt; g:= GeneratorsOfAlgebra(U);
[ F1, F2, F3, K1, K1+(q^-1-q)*[ K1 ; 1 ], K2, K2+(q^-1-q)*[ K2 ; 1 ], E1,
  E2, E3 ]
gap&gt; ExtRepOfObj( g[5] );
[ [ [ 4, 1 ], 0 ], 1, [ [ 4, 0 ], 1 ], q^-1-q ]
</pre></td></tr></table>

<p><a id="X7879B74F7C77E930" name="X7879B74F7C77E930"></a></p>

<h5>3.5-4 QuantumParameter</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; QuantumParameter</code>( <var class="Arg">U</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns the quantum parameter used in the definition of <var class="Arg">U</var>.</p>


<table class="example">
<tr><td><pre>
gap&gt; R:= RootSystem("A",2);;
gap&gt; U0:= QuantizedUEA( R, CF(3), E(3) );;
gap&gt; QuantumParameter( U0 );
E(3)
</pre></td></tr></table>

<p><a id="X82B42CD279854DFC" name="X82B42CD279854DFC"></a></p>

<h5>3.5-5 CanonicalMapping</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; CanonicalMapping</code>( <var class="Arg">U</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Here <var class="Arg">U</var> is a quantized enveloping algebra. Let <var class="Arg">U0</var> denote the corresponding "generic" quantized enveloping algebra. This function returns the mapping <var class="Arg">U0 --&gt; U</var> obtained by mapping <var class="Arg">q</var> (which is the quantum parameter of <var class="Arg">U0</var>) to the quantum parameter of <var class="Arg">U</var>.</p>


<table class="example">
<tr><td><pre>
gap&gt; R:= RootSystem("A", 3 );;
gap&gt; U:= QuantizedUEA( R, CF(5), E(5) );;
gap&gt; f:= CanonicalMapping( U );
MappingByFunction( QuantumUEA( &lt;root system of type A
3&gt;, Qpar = q ), QuantumUEA( &lt;root system of type A3&gt;, Qpar =
E(5) ), function( u ) ... end )
gap&gt; U0:= Source( f );
QuantumUEA( &lt;root system of type A3&gt;, Qpar = q )
gap&gt; g:= GeneratorsOfAlgebra( U0 );;
gap&gt; u:= g[18]*g[9]*g[6];
(q^2)*F6*K2*E6+(q)*K2*[ K3 ; 1 ]
gap&gt; Image( f, u );
(E(5)^2)*F6*K2*E6+(E(5))*K2*[ K3 ; 1 ]
</pre></td></tr></table>

<p><a id="X87C302567A9B2AD3" name="X87C302567A9B2AD3"></a></p>

<h5>3.5-6 WriteQEAToFile</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; WriteQEAToFile</code>( <var class="Arg">U, file</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Here <var class="Arg">U</var> is a quantized enveloping algebra, and file is a string containing the name of a file. This function writes some data to <var class="Arg">file</var>, that allows <code class="func">ReadQEAFromFile</code> (<a href="chap3.html#X874B8E4A83180063"><b>3.5-7</b></a>) to recover it.</p>


<table class="example">
<tr><td><pre>
gap&gt; U:= QuantizedUEA( RootSystem("A",3) );;
gap&gt; WriteQEAToFile( U, "/home/wdg/A3" );
</pre></td></tr></table>

<p><a id="X874B8E4A83180063" name="X874B8E4A83180063"></a></p>

<h5>3.5-7 ReadQEAFromFile</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ReadQEAFromFile</code>( <var class="Arg">file</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Here <var class="Arg">file</var> is a string containing the name of a file, to which a quantized enveloping algebra has been written by <code class="func">WriteQEAToFile</code> (<a href="chap3.html#X87C302567A9B2AD3"><b>3.5-6</b></a>). This function recovers the quantized enveloping algebra.</p>


<table class="example">
<tr><td><pre>
gap&gt; U:= QuantizedUEA( RootSystem("A",3) );;
gap&gt; WriteQEAToFile( U, "/home/wdg/A3" );
gap&gt; U0:= ReadQEAFromFile( "/home/wdg/A3" );
QuantumUEA( &lt;root system of type A3&gt;, Qpar = q )
</pre></td></tr></table>

<p><a id="X847A0459844B7A59" name="X847A0459844B7A59"></a></p>

<h4>3.6 <span class="Heading"> Homomorphisms and automorphisms </span></h4>

<p>Here we describe functions for creating homomorphisms and (anti)-automorphisms of a quantized enveloping algebra.</p>

<p><a id="X8185FE54820AA950" name="X8185FE54820AA950"></a></p>

<h5>3.6-1 QEAHomomorphism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; QEAHomomorphism</code>( <var class="Arg">U, A, list</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Here <var class="Arg">U</var> is a generic quantized enveloping algebra (i.e., with quantum parameter <var class="Arg">_q</var>), <var class="Arg">A</var> is an algebra with one over <var class="Arg">QuantumField</var>, and <var class="Arg">list</var> is a list of <var class="Arg">4*rank</var> elements of <var class="Arg">A</var> (where <var class="Arg">rank</var> is the rank of the root system of <var class="Arg">U</var>). On the first rank positions there are the images of the F_alpha (where the alpha are simple roots, listed in the order in which they occur in <var class="Arg">SimpleSystem( R )</var>). On the positions <var class="Arg">rank+1...2*rank</var> are the images of the K_alpha. On the positions <var class="Arg">2*rank+1...3*rank</var> are the images of the K_alpha^-1, and finally on the positions <var class="Arg">3*rank+1...4*rank</var> occur the images of the E_alpha.</p>

<p>This function returns the homomorphism <var class="Arg">U -&gt; A</var>, defined by this data. In the example below we construct a homomorphism from one quantized enveloping algebra into another. Both are constructed relative to the same root system, but with different reduced expressions for the longest element of the Weyl group.</p>


<table class="example">
<tr><td><pre>
gap&gt; R:= RootSystem( "G", 2 );;
gap&gt; SetLongestWeylWord( R, [1,2,1,2,1,2] );
gap&gt; UR:= QuantizedUEA( R );;
gap&gt; S:= RootSystem( "G", 2 );;
gap&gt; SetLongestWeylWord( S, [2,1,2,1,2,1] );
gap&gt; US:= QuantizedUEA( S );;
gap&gt; gS:= GeneratorsOfAlgebra( US );
[ F1, F2, F3, F4, F5, F6, K1, K1+(q^-1-q)*[ K1 ; 1 ], K2,
  K2+(q^-3-q^3)*[ K2 ; 1 ], E1, E2, E3, E4, E5, E6 ]
gap&gt; SimpleSystem( R );
[ [ 1, 0 ], [ 0, 1 ] ]
gap&gt; PositiveRootsInConvexOrder( S );
[ [ 0, 1 ], [ 1, 1 ], [ 3, 2 ], [ 2, 1 ], [ 3, 1 ], [ 1, 0 ] ]
# We see that the simple roots of R occur on positions 6 and 1
# in the list PositiveRootsInConvexOrder( S ); This means that we
# get the following list of images of the homomorphism:
gap&gt; imgs:= [ gS[6], gS[1],      # the images of the F_{\alpha}
&gt; gS[7], gS[9],                  # the images of the K_{\alpha}
&gt; gS[8], gS[10],                 # the images of the K_{\alpha}^{-1}
&gt; gS[16], gS[11] ];              # the images of the E_{\alpha}
[ F6, F1, K1, K2, K1+(q^-1-q)*[ K1 ; 1 ], K2+(q^-3-q^3)*[ K2 ; 1 ], E6, E1
 ]
gap&gt; h:= QEAHomomorphism( UR, US, imgs );
&lt;homomorphism: QuantumUEA( &lt;root system of type G
2&gt;, Qpar = q ) -&gt; QuantumUEA( &lt;root system of type G2&gt;, Qpar = q )&gt;
gap&gt; Image( h, GeneratorsOfAlgebra( UR )[3] );
(1-q^4-q^6+q^10)*F1*F6^(2)+(-q^2+q^6)*F2*F6+(q^4)*F4
</pre></td></tr></table>

<p><a id="X81214E9B8532B06F" name="X81214E9B8532B06F"></a></p>

<h5>3.6-2 QEAAutomorphism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; QEAAutomorphism</code>( <var class="Arg">U, list</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; QEAAutomorphism</code>( <var class="Arg">U, f</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>In the first form <var class="Arg">U</var> is a generic quantized enveloping algebra (i.e., with quantum parameter <var class="Arg">_q</var>), and <var class="Arg">list</var> is a list of <var class="Arg">4*rank</var> elements of <var class="Arg">U</var> (where <var class="Arg">rank</var> is the rank of the corresponding root system). On the first <var class="Arg">rank</var> positions there are the images of the F_alpha (where the alpha are simple roots, listed in the order in which they occur in <var class="Arg">SimpleSystem( R )</var>). On the positions <var class="Arg">rank+1...2*rank</var> are the images of the K_alpha. On the positions <var class="Arg">2*rank+1...3*rank</var> are the images of the K_alpha^-1, and finally on the positions <var class="Arg">3*rank+1...4*rank</var> occur the images of the E_alpha.</p>

<p>In the second form <var class="Arg">U</var> is a non-generic quantized enveloping algebra, and <var class="Arg">f</var> is an automorphism of the corresponding generic quantized enveloping algebra. The corresponding automorphism of <var class="Arg">U</var> is constructed. In this case <var class="Arg">f</var> must not be the bar-automorphism of the corresponding generic quantized enveloping algebra (cf. <code class="func">BarAutomorphism</code> (<a href="chap3.html#X8576A5987AD999F0"><b>3.6-6</b></a>)), as this automorphism doesn't work in the non-generic case.</p>

<p>The image of an element <var class="Arg">x</var> under an automorphism <var class="Arg">f</var> is computed by <var class="Arg">Image( f, x )</var>. Note that there is no function for calculating pre-images (in general this seems to be a very hard task). If you want the inverse of an automorphism, you have to construct it explicitly (e.g., by <var class="Arg">QEAAutomorphism( U, list )</var>, where <var class="Arg">list</var> is a list of pre-images).</p>

<p>Below we construct the automorphism omega (cf. Section <a href="chap2.html#X81394E207F6AA6CF"><b>2.2</b></a>) of the quantized enveloping of type A_3, when the quantum parameter is <var class="Arg">_q</var>, and when the quantum parameter is a fifth root of unity.</p>


<table class="example">
<tr><td><pre>
# First we construct the quantized enveloping algebra:
gap&gt; R:= RootSystem( "A", 3 );;
gap&gt; U0:= QuantizedUEA( R );
QuantumUEA( &lt;root system of type A3&gt;, Qpar = q )
gap&gt; g:= GeneratorsOfAlgebra( U0 );
[ F1, F2, F3, F4, F5, F6, K1, K1+(q^-1-q)*[ K1 ; 1 ], K2,
  K2+(q^-1-q)*[ K2 ; 1 ], K3, K3+(q^-1-q)*[ K3 ; 1 ], E1, E2, E3, E4, E5, E6 ]
# Now, for instance, we map F_{\alpha} to E_{\alpha}, where \alpha
# is a simple root. In order to find where those F_{\alpha}, E_{\alpha}
# are in the list of generators, we look at the list of positive roots
# in convex order:
gap&gt; PositiveRootsInConvexOrder( R );
[ [ 1, 0, 0 ], [ 1, 1, 0 ], [ 0, 1, 0 ], [ 1, 1, 1 ], [ 0, 1, 1 ],
  [ 0, 0, 1 ] ]
# So the simple roots occur on positions 1, 3, 6. This means that we
# have the following list of images:
gap&gt; imgs:= [ g[13], g[15], g[18], g[8], g[10], g[12], g[7], g[9], g[11],
&gt; g[1], g[3], g[6] ];
[ E1, E3, E6, K1+(q^-1-q)*[ K1 ; 1 ], K2+(q^-1-q)*[ K2 ; 1 ],
  K3+(q^-1-q)*[ K3 ; 1 ], K1, K2, K3, F1, F3, F6 ]
gap&gt; f:= QEAAutomorphism( U0, imgs );
&lt;automorphism of QuantumUEA( &lt;root system of type A3&gt;, Qpar = q )&gt;
gap&gt; Image( f, g[2] );
(-q)*E2
# f induces an automorphism of any non-generic quantized enveloping
# algebra with the same root system R:
gap&gt; U1:= QuantizedUEA( R, CF(5), E(5) );
QuantumUEA( &lt;root system of type A3&gt;, Qpar = E(5) )
gap&gt; h:= QEAAutomorphism( U1, f );
&lt;automorphism of QuantumUEA( &lt;root system of type A3&gt;, Qpar = E(5) )&gt;
gap&gt; Image( h, GeneratorsOfAlgebra(U1)[7] );
(-E(5)+E(5)^4)*[ K1 ; 1 ]+K1
</pre></td></tr></table>

<p><a id="X79D886AB7B248F75" name="X79D886AB7B248F75"></a></p>

<h5>3.6-3 QEAAntiAutomorphism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; QEAAntiAutomorphism</code>( <var class="Arg">U, list</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; QEAAntiAutomorphism</code>( <var class="Arg">U, f</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>These are functions for constructing anti-automorphisms of quantized enveloping algebras. The same comments apply as for <code class="func">QEAAutomorphism</code> (<a href="chap3.html#X81214E9B8532B06F"><b>3.6-2</b></a>).</p>

<p><a id="X851AE6987871E0E8" name="X851AE6987871E0E8"></a></p>

<h5>3.6-4 AutomorphismOmega</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; AutomorphismOmega</code>( <var class="Arg">U</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>This is the automorphism omega (cf. Section <a href="chap2.html#X81394E207F6AA6CF"><b>2.2</b></a>).</p>


<table class="example">
<tr><td><pre>
gap&gt; R:= RootSystem( "A", 3 );;
gap&gt; U:= QuantizedUEA( R, CF(5), E(5) );
QuantumUEA( &lt;root system of type A3&gt;, Qpar = E(5) )
gap&gt; f:= AutomorphismOmega( U );
&lt;automorphism of QuantumUEA( &lt;root system of type A3&gt;, Qpar = E(5) )&gt;
</pre></td></tr></table>

<p><a id="X7E288BFE7FDF8BEA" name="X7E288BFE7FDF8BEA"></a></p>

<h5>3.6-5 AntiAutomorphismTau</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; AntiAutomorphismTau</code>( <var class="Arg"></var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>This is the anti-automorphism tau (cf. Section <a href="chap2.html#X81394E207F6AA6CF"><b>2.2</b></a>).</p>


<table class="example">
<tr><td><pre>
gap&gt; R:= RootSystem( "A", 3 );;
gap&gt; U:= QuantizedUEA( R, CF(5), E(5) );
QuantumUEA( &lt;root system of type A3&gt;, Qpar = E(5) )
gap&gt; t:= AntiAutomorphismTau( U );
&lt;anti-automorphism of QuantumUEA( &lt;root system of type A3&gt;, Qpar = E(5) )&gt;
</pre></td></tr></table>

<p><a id="X8576A5987AD999F0" name="X8576A5987AD999F0"></a></p>

<h5>3.6-6 BarAutomorphism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; BarAutomorphism</code>( <var class="Arg">U</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>This is the automorphism bar~ defined in Section <a href="chap2.html#X81394E207F6AA6CF"><b>2.2</b></a> Here <var class="Arg">U</var> must be a generic quantized enveloping algebra.</p>


<table class="example">
<tr><td><pre>
gap&gt; U:= QuantizedUEA( RootSystem(["A",2,"B",2]) );;
gap&gt; bar:= BarAutomorphism( U );
&lt;automorphism of QuantumUEA( &lt;root system of type A2 B2&gt;, Qpar = q )&gt;
gap&gt; Image( bar, GeneratorsOfAlgebra( U )[5] );
(-q^-2+q^2)*F4*F7+F5
</pre></td></tr></table>

<p><a id="X8277D87D7D81AE75" name="X8277D87D7D81AE75"></a></p>

<h5>3.6-7 AutomorphismTalpha</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; AutomorphismTalpha</code>( <var class="Arg">U, ind</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>This is the automorphism T_alpha (cf. Section <a href="chap2.html#X83E7F39F7D16793B"><b>2.4</b></a>), where alpha is the <var class="Arg">ind</var>-th simple root.</p>


<table class="example">
<tr><td><pre>
gap&gt; U:= QuantizedUEA( RootSystem( "B", 3 ) );;
gap&gt; f:=AutomorphismTalpha( U, 1 );
&lt;automorphism of QuantumUEA( &lt;root system of type B3&gt;, Qpar = q )&gt;
gap&gt; a:= GeneratorsOfAlgebra( U )[3];
F3
gap&gt;  Image( f, a );
F2
</pre></td></tr></table>

<p><a id="X7DC17C2D8540FCED" name="X7DC17C2D8540FCED"></a></p>

<h5>3.6-8 DiagramAutomorphism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; DiagramAutomorphism</code>( <var class="Arg">U, perm</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>This is the automorphism of <var class="Arg">U</var> induced by a diagram automorphism of the underlying root system. The diagram automorphism is represented by the permutation <var class="Arg">perm</var>, which is the permutation of the simple roots performed by the diagram automorphism.</p>

<p>In the example below we construct the diagram automorphism of the root system of type A_3, which is represented by the permutation <var class="Arg">(1,3)</var>.</p>


<table class="example">
<tr><td><pre>
gap&gt; R:= RootSystem( "A", 3 );;
gap&gt; U:= QuantizedUEA( R );;
gap&gt; f:= DiagramAutomorphism( U, (1,3) );
&lt;automorphism of QuantumUEA( &lt;root system of type A3&gt;, Qpar = q )&gt;
gap&gt; g:= GeneratorsOfAlgebra( U );
[ F1, F2, F3, F4, F5, F6, K1, K1+(q^-1-q)*[ K1 ; 1 ], K2,
  K2+(q^-1-q)*[ K2 ; 1 ], K3, K3+(q^-1-q)*[ K3 ; 1 ], E1, E2, E3, E4, E5, E6
 ]
gap&gt; Image( f, g[1] );
F6
</pre></td></tr></table>

<p><a id="X8123456781234567" name="X8123456781234567"></a></p>

<h5>3.6-9 \*</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; \*</code>( <var class="Arg">f, h</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>We can compose automorphisms and anti-automorphisms using the infix <var class="Arg">*</var> operator. The result of composing two automorphisms is an automorphism. The result of composing an automorphism and an anti-automorphism is an anti-automorphism. The result of composing two anti-automorphisms is an automorphism.</p>


<table class="example">
<tr><td><pre>
gap&gt; U:= QuantizedUEA( RootSystem( "B", 3 ) );;
gap&gt; f:=AutomorphismTalpha( U, 1 );
&lt;automorphism of QuantumUEA( &lt;root system of type B3&gt;, Qpar = q )&gt;
gap&gt; h:= AutomorphismOmega( U );
&lt;automorphism of QuantumUEA( &lt;root system of type B3&gt;, Qpar = q )&gt;
gap&gt; f*h;
&lt;automorphism of QuantumUEA( &lt;root system of type B3&gt;, Qpar = q )&gt;
gap&gt; t:= AntiAutomorphismTau( U );;
gap&gt; T:= AutomorphismTalpha( U, 2 );;
gap&gt; Tinv:= t*T*t;
&lt;automorphism of QuantumUEA( &lt;root system of type B3&gt;, Qpar = q )&gt;
# (The last call may take a little while.)
gap&gt; x:= Image( T, GeneratorsOfAlgebra( U )[1] );
(1-q^4)*F1*F3+(-q^2)*F2
gap&gt; Image( Tinv, x );
F1
</pre></td></tr></table>

<p>According to <a href="chapBib.html#biBJ96">[Jan96]</a>, 8.14(10), tau circ T_alpha circ tau is the inverse of T_alpha.</p>

<p><a id="X832B6D897BDBC8A3" name="X832B6D897BDBC8A3"></a></p>

<h4>3.7 <span class="Heading">Hopf algebra structure</span></h4>

<p>Here we describe functions for dealing with the Hopf algebra structure of a quantized enveloping algebra. This structure enables us to construct tensor products, and dual modules of modules over a quantized enveloping algebra. We refer to the next section (Section <a href="chap3.html#X8183A6857B0C3633"><b>3.8</b></a>) for some functions for creating modules.</p>

<p><a id="X8245FA64874E085D" name="X8245FA64874E085D"></a></p>

<h5>3.7-1 TensorPower</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; TensorPower</code>( <var class="Arg">U, d</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Here <var class="Arg">U</var> is a quantized universal enveloping algebra, and <var class="Arg">d</var> a non-negative integer. This function returns the associative algebra with underlying vector space the <var class="Arg">d</var>-fold tensor product of <var class="Arg">U</var> with itself. The product is defined component wise.</p>


<table class="example">
<tr><td><pre>
gap&gt; U:= QuantizedUEA( RootSystem( [ "B", 2 ] ) );;
gap&gt; T:= TensorPower( U, 3 );
&lt;algebra over QuantumField, with 36 generators&gt;
gap&gt; g:= GeneratorsOfAlgebra( T );;
gap&gt; x:= g[1];
1*(1&lt;x&gt;1&lt;x&gt;F1)
gap&gt; y:= g[30];
1*(E2&lt;x&gt;1&lt;x&gt;1)
gap&gt; x*y;
1*(E2&lt;x&gt;1&lt;x&gt;F1)
</pre></td></tr></table>

<p><a id="X783144818681D2E6" name="X783144818681D2E6"></a></p>

<h5>3.7-2 UseTwistedHopfStructure</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; UseTwistedHopfStructure</code>( <var class="Arg">U, f, finv</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Here <var class="Arg">U</var> is a quantized enveloping algebra, and <var class="Arg">f</var>, <var class="Arg">finv</var> two (anti-) automorphisms of <var class="Arg">U</var>, where <var class="Arg">finv</var> is the inverse of <var class="Arg">f</var>. After calling this function the Hopf structure on <var class="Arg">U</var> is used that is obtained from the "normal" Hopf structure (see Section <a href="chap2.html#X84DCFABC7DE54325"><b>2.3</b></a>) by twisting it with <var class="Arg">f</var>.</p>

<p>A call to this function sets the attribute <var class="Arg">HopfStructureTwist</var>, which is the list <var class="Arg">[ f, finv ]</var>.</p>


<table class="example">
<tr><td><pre>
gap&gt; U:= QuantizedUEA( RootSystem("A",2), CF(5), E(5) );;
gap&gt; t:= AntiAutomorphismTau( U );;
gap&gt; UseTwistedHopfStructure( U, t, t );
</pre></td></tr></table>

<p><a id="X811565FF83FA4847" name="X811565FF83FA4847"></a></p>

<h5>3.7-3 ComultiplicationMap</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ComultiplicationMap</code>( <var class="Arg">U, d</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>This is a homomorphism from the quantized enveloping algebra <var class="Arg">U</var> to the <var class="Arg">d</var>-fold tensor power of <var class="Arg">U</var> with itself. It is obtained by a repeated application of the comultiplication of <var class="Arg">U</var>. So for <var class="Arg">d=2</var> we get the comultiplication of <var class="Arg">U</var>.</p>


<table class="example">
<tr><td><pre>
gap&gt; U:= QuantizedUEA( RootSystem("A",2), CF(5), E(5) );;
gap&gt; D:= ComultiplicationMap( U, 3 );
&lt;Comultiplication of QuantumUEA( &lt;root system of type A2&gt;, Qpar =
E(5) ), degree 3&gt;
gap&gt; Image( D, GeneratorsOfAlgebra(U)[4] );
1*(K1&lt;x&gt;K1&lt;x&gt;K1)
</pre></td></tr></table>

<p><a id="X7985B7EF7E31C4DF" name="X7985B7EF7E31C4DF"></a></p>

<h5>3.7-4 AntipodeMap</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; AntipodeMap</code>( <var class="Arg">U</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>This is the antipode map of the quantized enveloping algebra <var class="Arg">U</var>, which is constructed as an anti-automorphism of <var class="Arg">U</var>.</p>


<table class="example">
<tr><td><pre>
gap&gt; U:= QuantizedUEA( RootSystem("A",2), CF(5), E(5) );;
gap&gt; a:= AntipodeMap( U );
&lt;anti-automorphism of QuantumUEA( &lt;root system of type A2&gt;, Qpar = E(5) )&gt;
</pre></td></tr></table>

<p><a id="X8361876D8770FC06" name="X8361876D8770FC06"></a></p>

<h5>3.7-5 CounitMap</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; CounitMap</code>( <var class="Arg">U</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>This is the counit map of the quantized enveloping algebra <var class="Arg">U</var>, which is constructed as a function from <var class="Arg">U</var> to the ground field.</p>


<table class="example">
<tr><td><pre>
gap&gt; U:= QuantizedUEA( RootSystem("A",2), CF(5), E(5) );;
gap&gt; co:= CounitMap( U );
function( u ) ... end
gap&gt; x:= GeneratorsOfAlgebra( U )[4];
K1
gap&gt; co( x );
1
</pre></td></tr></table>

<p><a id="X8183A6857B0C3633" name="X8183A6857B0C3633"></a></p>

<h4>3.8 <span class="Heading">Modules</span></h4>

<p>Here we describe some functions for constructing left modules over quantized enveloping algebras. We refer to the <strong class="pkg">GAP</strong> reference manual for an overview of basic functions for algebra modules, which are also applicable to the modules constructed by the functions described in this section. We mention <var class="Arg">MatrixOfAction</var>, <var class="Arg">DirectSumOfAlgebraModules</var>. The action of an element of the algebra on an element of the module is calculated by the infix operator <var class="Arg">^</var>.</p>

<p><a id="X7ED0FA2980330CE1" name="X7ED0FA2980330CE1"></a></p>

<h5>3.8-1 HighestWeightModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; HighestWeightModule</code>( <var class="Arg">U, wt</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Here <var class="Arg">U</var> is a quantized universal enveloping algebra, and <var class="Arg">wt</var> a dominant weight (i.e., a list of length equal to the rank of the root system, consisting of non-negative integers). This function returns a finite-dimensional highest-weight module of highest weight <var class="Arg">wt</var> over <var class="Arg">U</var>. If <var class="Arg">U</var> is generic then this is the unique irreducible highest-weight module over <var class="Arg">U</var>. Otherwise it is the Weyl module, cf. Section <a href="chap2.html#X803D39F580E4E4EE"><b>2.5</b></a>. In this last case the module is not necessarily irreducible.</p>

<p>Let <var class="Arg">V</var> denote the module returned by this function. The first basis element of the attribute <var class="Arg">Basis( V )</var> is a highest-weight vector; it is written as <var class="Arg">1*v0</var>. Other basis elements are written as, for example, <var class="Arg">F2*F9*v0</var>, which means that this vector is the result of letting the PBW-monomial <var class="Arg">F2*F9</var> act on the highest-weight vector.</p>


<table class="example">
<tr><td><pre>
gap&gt; U:= QuantizedUEA( RootSystem( [ "A", 2, "G", 2 ] ) );;
gap&gt; V:= HighestWeightModule( U, [ 0, 1, 0, 2 ] );
&lt;231-dimensional left-module over QuantumUEA( &lt;root system of type A2 G
2&gt;, Qpar = q )&gt;
gap&gt; Basis( V )[1];
1*v0
gap&gt; Basis(V)[23]+(_q^2+_q^-2)*Basis(V)[137];
F3*F5*v0+(q^-2+q^2)*F8^(6)*v0
# We compute the action of an element on a vector:
gap&gt; gg:= GeneratorsOfAlgebra( U );;
gap&gt; x:= gg[21]*gg[5];
F5*E4+(-q^-1)*F6*K3
gap&gt; x^Basis(V)[1];
(-q^-1)*F6*v0
</pre></td></tr></table>

<p><a id="X7B00688F82AACDD0" name="X7B00688F82AACDD0"></a></p>

<h5>3.8-2 IrreducibleQuotient</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IrreducibleQuotient</code>( <var class="Arg">V</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Here <var class="Arg">V</var> is a highest-weight module over a non-generic quantized enveloping algebra. This function returns the quotient of <var class="Arg">V</var> by the maximal submodule not containing the highest weight vector. This is not necessarily equal to <var class="Arg">V</var> if the quantum parameter is a root of 1.</p>


<table class="example">
<tr><td><pre>
gap&gt; R:= RootSystem( "A", 2 );;
gap&gt; U:= QuantizedUEA( R, CF(3), E(3) );;
gap&gt; V:= HighestWeightModule( U, [1,1] );
&lt;8-dimensional left-module over QuantumUEA( &lt;root system of type A2&gt;, Qpar =
E(3) )&gt;
gap&gt; IrreducibleQuotient( V );
&lt;7-dimensional left-module over QuantumUEA( &lt;root system of type A2&gt;, Qpar =
E(3) )&gt;
</pre></td></tr></table>

<p><a id="X7B080C0078370E99" name="X7B080C0078370E99"></a></p>

<h5>3.8-3 HWModuleByTensorProduct</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; HWModuleByTensorProduct</code>( <var class="Arg">U, wt</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Here <var class="Arg">U</var> must be a <em>generic</em> quantized enveloping algebra, and <var class="Arg">wt</var> a dominant weight. This function returns the irreducible highest-weight module with highest weight <var class="Arg">wt</var>. The algorithm uses tensor products (whence the name). On some inputs this algorithm is faster than the one use for <code class="func">HighestWeightModule:for a quantized env. alg.</code> (<b>???</b>), on some inputs it is slower. I do not know any good heuristics.</p>

<p>The basis supplied with the module returned is the canonical basis.</p>


<table class="example">
<tr><td><pre>
gap&gt; U:= QuantizedUEA( RootSystem("G",2) );;
gap&gt; V:= HWModuleByTensorProduct( U, [2,1] );
&lt;189-dimensional left-module over QuantumUEA( &lt;root system of type G
2&gt;, Qpar = q )&gt;
# (This is a case where this algorithm is a lot faster.)
</pre></td></tr></table>

<p><a id="X7C03DC018016B93B" name="X7C03DC018016B93B"></a></p>

<h5>3.8-4 DIYModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; DIYModule</code>( <var class="Arg">U, V, acts</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Here <var class="Arg">U</var> is a generic quantized enveloping algebra, and <var class="Arg">V</var> is a vector space over the field <var class="Arg">QuantumField</var>. <var class="Arg">U</var> acts on <var class="Arg">V</var> and the action is described by the data in the list <var class="Arg">acts</var>. <var class="Arg">acts</var> is a list of lists, of length <var class="Arg">4*l</var>, where <var class="Arg">l</var> is the rank of the root system. <var class="Arg">acts</var> describes the actions of the generators [F_1,...,F_l,K_1,...,K_l,K_1^-1,...,K_l^-1, E_1,...,E_l ]. (Here F_k is the generator F_alpha_k, where alpha_k is the k-th simple root, and likewise for E_k.) The action of each generator is described by a list of length <var class="Arg">dim V</var>, giving the images of the basis elements of <var class="Arg">V</var>. If an image is zero then it may be omitted: in that case there is a "hole" in the list. This function returns the <var class="Arg">U</var>-module defined by the input.</p>

<p>Let <var class="Arg">R</var> be a root system of type A_1, and <var class="Arg">U</var> the corresponding quantized enveloping algebra (generated by F, K, K^-1, E). In the example below we construct the 2-dimensional U-module with basis vectors v_1,v_2, and <var class="Arg">U</var>-action given by Fv_1 = v_2, Fv_2=0, Kv_1 = qv_1, Kv_2=q^-1v_2, Ev_1=0, Ev_2=v_1.</p>


<table class="example">
<tr><td><pre>
gap&gt; U:= QuantizedUEA( RootSystem("A",1) );
QuantumUEA( &lt;root system of type A1&gt;, Qpar = q )
gap&gt; V:= QuantumField^2;
( QuantumField^2 )
gap&gt; v:= BasisVectors( Basis(V) );
[ [ 1, 0 ], [ 0, 1 ] ]
gap&gt; acts:= [ [ v[2], 0*v[1] ], [ _q*v[1], _q^-1*v[2] ],
&gt; [ _q^-1*v[1], _q*v[2] ], [ 0*v[1], v[1] ] ];;
gap&gt; M:= DIYModule( U, V, acts );
&lt;2-dimensional left-module over QuantumUEA( &lt;root system of type A
1&gt;, Qpar = q )&gt;
</pre></td></tr></table>

<p><a id="X854FA09F7E07D2D0" name="X854FA09F7E07D2D0"></a></p>

<h5>3.8-5 TensorProductOfAlgebraModules</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; TensorProductOfAlgebraModules</code>( <var class="Arg">V, W</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; TensorProductOfAlgebraModules</code>( <var class="Arg">V, W</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Here <var class="Arg">V</var> and <var class="Arg">W</var> are two modules over the same quantized enveloping algebra <var class="Arg">U</var>. This function constructs the tensor product of <var class="Arg">V</var> and <var class="Arg">W</var> (as a <var class="Arg">U</var>-module). For this the comultiplication map of <var class="Arg">U</var> is used (see <code class="func">ComultiplicationMap</code> (<a href="chap3.html#X811565FF83FA4847"><b>3.7-3</b></a>)).</p>

<p>In the second form list is a list of <var class="Arg">U</var>-modules. In that case the iterated tensor product is constructed.</p>


<table class="example">
<tr><td><pre>
gap&gt; U:= QuantizedUEA( RootSystem( [ "A", 2 ] ) );;
gap&gt; V1:= HighestWeightModule( U, [ 1, 0 ] );;
gap&gt; V2:= HighestWeightModule( U, [ 0, 1 ] );;
gap&gt; TensorProductOfAlgebraModules( V1, V2 );
&lt;9-dimensional left-module over QuantumUEA( &lt;root system of type A2&gt;, Qpar = q )&gt;
</pre></td></tr></table>

<p><a id="X7F0AED7A85D603A2" name="X7F0AED7A85D603A2"></a></p>

<h5>3.8-6 HWModuleByGenerator</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; HWModuleByGenerator</code>( <var class="Arg">V, v, hw</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Here <var class="Arg">V</var> is a module over a generic quantized enveloping algebra <var class="Arg">U</var>, <var class="Arg">v</var> is a highest-weight vector (i.e., all E_alpha<var class="Arg">v=0</var>), of weight <var class="Arg">hw</var>, which must be dominant. This function returns a highest-weight module over <var class="Arg">U</var> isomorphic to the submodule of <var class="Arg">V</var> generated by <var class="Arg">v</var>.</p>


<table class="example">
<tr><td><pre>
gap&gt; U:= QuantizedUEA( RootSystem("B",2) );;
gap&gt; W1:= HighestWeightModule( U, [1,0] );;
gap&gt; W2:= HighestWeightModule( U, [0,1] );;
gap&gt; T:= TensorProductOfAlgebraModules( W1, W2 );
&lt;20-dimensional left-module over QuantumUEA( &lt;root system of type B
2&gt;, Qpar = q )&gt;
gap&gt; HWModuleByGenerator( T, Basis(T)[1], [1,1] );
&lt;16-dimensional left-module over QuantumUEA( &lt;root system of type B
2&gt;, Qpar = q )&gt;
</pre></td></tr></table>

<p><a id="X8565D4CD82EB2503" name="X8565D4CD82EB2503"></a></p>

<h5>3.8-7 InducedQEAModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; InducedQEAModule</code>( <var class="Arg">U, V</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Here <var class="Arg">U</var> is a non-generic quantized enveloping algebra, and <var class="Arg">V</var> a module over the corresponding generic quantized enveloping algebra. This function returns the <var class="Arg">U</var>-module obtained from <var class="Arg">V</var> by setting <var class="Arg">_q</var> equal to the quantum parameter of <var class="Arg">U</var>.</p>


<table class="example">
<tr><td><pre>
gap&gt; R:= RootSystem("B",2);;
gap&gt; U:= QuantizedUEA( R );;
gap&gt; U0:= QuantizedUEA( R, CF(3), E(3) );;
gap&gt; V:= HighestWeightModule( U, [1,1] );;
gap&gt; W:= InducedQEAModule( U0, V );
&lt;16-dimensional left-module over QuantumUEA( &lt;root system of type B
2&gt;, Qpar = E(3) )&gt;
# This module is isomorphic to the one obtained by
# HighestWeightModule( U0, [1,1] );
</pre></td></tr></table>

<p><a id="X8680D0D67BACAE16" name="X8680D0D67BACAE16"></a></p>

<h5>3.8-8 GenericModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; GenericModule</code>( <var class="Arg">W</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>For an induced module (see <code class="func">InducedQEAModule</code> (<a href="chap3.html#X8565D4CD82EB2503"><b>3.8-7</b></a>)) this function returns the corresponding module over the generic quantized enveloping algebra.</p>

<p><a id="X82B42CD279854DFC" name="X82B42CD279854DFC"></a></p>

<h5>3.8-9 CanonicalMapping</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; CanonicalMapping</code>( <var class="Arg">W</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Here <var class="Arg">W</var> is an induced module. Let <var class="Arg">V</var> be the corresponding generic module (<code class="func">GenericModule</code> (<a href="chap3.html#X8680D0D67BACAE16"><b>3.8-8</b></a>)). This function returns the map <var class="Arg">V --&gt; W</var>, that sets <var class="Arg">_q</var> equal to the quantum parameter of the acting algebra of <var class="Arg">W</var>.</p>


<table class="example">
<tr><td><pre>
gap&gt; R:= RootSystem("B",2);;
gap&gt; U:= QuantizedUEA( R );;
gap&gt; U0:= QuantizedUEA( R, CF(3), E(3) );;
gap&gt; V:= HighestWeightModule( U, [1,1] );;
gap&gt; W:= InducedQEAModule( U0, V );;
gap&gt; f:= CanonicalMapping( W );
MappingByFunction( &lt;
16-dimensional left-module over QuantumUEA( &lt;root system of type B
2&gt;, Qpar = q )&gt;, &lt;
16-dimensional left-module over QuantumUEA( &lt;root system of type B
2&gt;, Qpar = E(3) )&gt;, function( v ) ... end )
gap&gt; Image( f, _q^2*Basis(V)[3] );
(E(3)^2)*e.3
</pre></td></tr></table>

<p><a id="X7DCD17BF7B76E7CA" name="X7DCD17BF7B76E7CA"></a></p>

<h5>3.8-10 U2Module</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; U2Module</code>( <var class="Arg">U, hw</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Here <var class="Arg">U</var> must be a quantized enveloping algebra of type A_2. This function returns the highest-weight module over <var class="Arg">U</var> of highest-weight <var class="Arg">hw</var> (which must be dominant). This function is generally a lot faster than <code class="func">HighestWeightModule:for a quantized env. alg.</code> (<b>???</b>).</p>


<table class="example">
<tr><td><pre>
gap&gt; U:= QuantizedUEA( RootSystem("A",2) );;
gap&gt; A2Module( U, [4,7] );
&lt;260-dimensional left-module over QuantumUEA( &lt;root system of type A
2&gt;, Qpar = q )&gt;
</pre></td></tr></table>

<p><a id="X7E1B059780BB2E09" name="X7E1B059780BB2E09"></a></p>

<h5>3.8-11 MinusculeModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; MinusculeModule</code>( <var class="Arg">U, hw</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Here <var class="Arg">U</var> must be a generic quantized enveloping algebra, and <var class="Arg">hw</var> a minuscule dominant weight. This function returns the highest-weight module over <var class="Arg">U</var> of highest-weight <var class="Arg">hw</var>. This function is generally somewhat faster than <code class="func">HighestWeightModule:for a quantized env. alg.</code> (<b>???</b>).</p>


<table class="example">
<tr><td><pre>
gap&gt; U:= QuantizedUEA( RootSystem("A",5) );;
gap&gt; MinusculeModule( U, [0,0,1,0,0] );
&lt;20-dimensional left-module over QuantumUEA( &lt;root system of type A
5&gt;, Qpar = q )&gt;
</pre></td></tr></table>

<p><a id="X79C8F1317C2E8C60" name="X79C8F1317C2E8C60"></a></p>

<h5>3.8-12 DualAlgebraModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; DualAlgebraModule</code>( <var class="Arg">V</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Here <var class="Arg">V</var> is a finite-dimensional left module over a quantized enveloping algebra <var class="Arg">U</var>. This function returns the dual space of <var class="Arg">V</var> as an algebra module. For this the antipode map of <var class="Arg">U</var> is used (see <code class="func">AntipodeMap</code> (<a href="chap3.html#X7985B7EF7E31C4DF"><b>3.7-4</b></a>)).</p>

<p>Let <var class="Arg">M</var> denote the module returned by this function. Then <var class="Arg">M</var> has as basis the dual basis with respect to <var class="Arg">Basis( V )</var>. An element of this basis is printed as <var class="Arg">F@v</var>, where <var class="Arg">v</var> is an element of <var class="Arg">Basis( V )</var>. This is the function which takes the value <var class="Arg">1</var> on <var class="Arg">v</var> and <var class="Arg">0</var> on all other basis elements. A general element of <var class="Arg">M</var> is a linear combination of these basis elements.</p>

<p>The elements of <var class="Arg">M</var> can be viewed as functions which take arguments. However, internally the elements of <var class="Arg">M</var> are represented as wrapped up functions. The function corresponding to an element <var class="Arg">m</var> of <var class="Arg">M</var> is obtained by <var class="Arg">ExtRepOfObj( m )</var> (the result of which is printed in the same way as <var class="Arg">m</var>, but is not equal to it).</p>


<table class="example">
<tr><td><pre>
gap&gt; U:= QuantizedUEA( RootSystem("A",2) );;
gap&gt; V:= HighestWeightModule( U, [1,1] );;
gap&gt; M:= DualAlgebraModule( V );
&lt;8-dimensional left-module over QuantumUEA( &lt;root system of type A
2&gt;, Qpar = q )&gt;
gap&gt; u:= GeneratorsOfAlgebra( U )[2];
F2
gap&gt; vv:= BasisVectors( Basis( M ) );
[ (1)*F@1*v0, (1)*F@F1*v0, (1)*F@F3*v0, (1)*F@F1*F3*v0, (1)*F@F2*v0,
  (1)*F@F1*F2*v0, (1)*F@F2*F3*v0, (1)*F@F2^(2)*v0 ]
gap&gt; u^vv[3];
&lt;zero function&gt;
# (The zero of the dual space is printed as &lt;zero function&gt;).
gap&gt; u^vv[4];
(q^3-q^5)*F@1*v0
# We get the function corresponding to a vector in M by using ExtRepOfObj:
gap&gt; f:= ExtRepOfObj( vv[1] );
(1)*F@1*v0
# We can calculate images of this function:
gap&gt; List( Basis(V), v -&gt; Image( f, v ) );
[ 1, 0, 0, 0, 0, 0, 0, 0 ]
</pre></td></tr></table>

<p><a id="X87EBE47D86292754" name="X87EBE47D86292754"></a></p>

<h5>3.8-13 TrivialAlgebraModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; TrivialAlgebraModule</code>( <var class="Arg">U</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns the trivial module over the quantized enveloping algebra <var class="Arg">U</var>. For this the counit map of <var class="Arg">U</var> is used.</p>


<table class="example">
<tr><td><pre>
gap&gt; U:= QuantizedUEA( RootSystem("A",2) );;
gap&gt; V:= TrivialAlgebraModule( U );
&lt;left-module over QuantumUEA( &lt;root system of type A2&gt;, Qpar = q )&gt;
</pre></td></tr></table>

<p><a id="X7929063E7C428331" name="X7929063E7C428331"></a></p>

<h5>3.8-14 WeightsAndVectors</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; WeightsAndVectors</code>( <var class="Arg">V</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Here <var class="Arg">V</var> is a left module over a quantized enveloping algebra. <var class="Arg">WeightsAndVectors( V )</var> is a list of two lists; the first of these is a list of the weights of <var class="Arg">V</var>, the second a list of corresponding weight vectors. These are again grouped in lists: if the multiplicity of a weight is <var class="Arg">m</var>, then there are <var class="Arg">m</var> weight vectors, forming a basis of the corresponding weight space.</p>

<p>Modules constructed by <code class="func">HighestWeightModule:for a quantized env. alg.</code> (<b>???</b>) come with this attribute set. There is a method installed for computing <var class="Arg">WeightsAndVectors( V )</var>, for modules <var class="Arg">V</var> over a generic quantized enveloping algebra, such that all basis vectors (i.e., all elements of <var class="Arg">Basis( V )</var>) are weight vectors.</p>


<table class="example">
<tr><td><pre>
gap&gt; U:= QuantizedUEA( RootSystem( "A", 2 ) );;
gap&gt; V:= HighestWeightModule( U, [ 1, 1 ] );;
gap&gt; WeightsAndVectors( V );
[ [ [ 1, 1 ], [ -1, 2 ], [ 2, -1 ], [ 0, 0 ], [ -2, 1 ], [ 1, -2 ],
      [ -1, -1 ] ],
  [ [ 1*v0 ], [ F1*v0 ], [ F3*v0 ], [ F1*F3*v0, F2*v0 ], [ F1*F2*v0 ],
      [ F2*F3*v0 ], [ F2^(2)*v0 ] ] ]
</pre></td></tr></table>

<p><a id="X7EEEBA347A816827" name="X7EEEBA347A816827"></a></p>

<h5>3.8-15 HighestWeightsAndVectors</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; HighestWeightsAndVectors</code>( <var class="Arg">V</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Is analogous to <code class="func">WeightsAndVectors</code> (<a href="chap3.html#X7929063E7C428331"><b>3.8-14</b></a>); now only the highest weights are listed along with the corresponding highest-weight vectors.</p>

<p>There is a method installed for this using <code class="func">WeightsAndVectors</code> (<a href="chap3.html#X7929063E7C428331"><b>3.8-14</b></a>); which means that it works if and only if <var class="Arg">WeightsAndVectors( V )</var> works.</p>


<table class="example">
<tr><td><pre>
gap&gt; U:= QuantizedUEA( RootSystem( [ "A", 2 ] ) );;
gap&gt; V:= HighestWeightModule( U, [ 1, 1 ] );;
gap&gt; HighestWeightsAndVectors( V );
[ [ [ 1, 1 ] ], [ [ 1*v0 ] ] ]
</pre></td></tr></table>

<p><a id="X799E7D5981B9F14A" name="X799E7D5981B9F14A"></a></p>

<h5>3.8-16 RMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; RMatrix</code>( <var class="Arg">V</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Here <var class="Arg">V</var> is a module over the a quantized enveloping algebra <var class="Arg">U</var>. This function returns the matrix of a linear map theta : Votimes V -&gt; Votimes V that is a solution to the quantum Yang-Baxter equation. We have that thetacirc P is an isomorphism of <var class="Arg">U</var>-modules, where P :Votimes V-&gt; Votimes V is the linear map such that P(votimes w)=wotimes v. For more details we refer to <a href="chapBib.html#biBJ96">[Jan96]</a>, Chapter 7.</p>

<p>This function works for modules for which <code class="func">WeightsAndVectors</code> (<a href="chap3.html#X7929063E7C428331"><b>3.8-14</b></a>) works.</p>


<table class="example">
<tr><td><pre>
gap&gt; U:= QuantizedUEA( RootSystem("A",1) );;
gap&gt; V:= HighestWeightModule( U, [1] );;
gap&gt; RMatrix( V );
[ [ 1, 0, 0, 0 ], [ 0, q, 1-q^2, 0 ], [ 0, 0, q, 0 ], [ 0, 0, 0, 1 ] ]
</pre></td></tr></table>

<p><a id="X78E533D2813BDA9E" name="X78E533D2813BDA9E"></a></p>

<h5>3.8-17 IsomorphismOfTensorModules</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsomorphismOfTensorModules</code>( <var class="Arg">V, W</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Here <var class="Arg">V</var>, <var class="Arg">W</var> are two modules over the same quantized enveloping algebra <var class="Arg">U</var>. This function returns a linear map theta : Votimes W-&gt; Wotimes V that is an isomorphism of U-modules.</p>

<p>This function is only guaranteed to work correctly if the Hopf algebra structure is non-twisted (see <code class="func">UseTwistedHopfStructure</code> (<a href="chap3.html#X783144818681D2E6"><b>3.7-2</b></a>)).</p>

<p>This function works for modules for which <code class="func">WeightsAndVectors</code> (<a href="chap3.html#X7929063E7C428331"><b>3.8-14</b></a>) works.</p>


<table class="example">
<tr><td><pre>
gap&gt; U:= QuantizedUEA( RootSystem("B",2) );;
gap&gt; V:= HighestWeightModule( U, [1,0] );;
gap&gt; W:= HighestWeightModule( U, [0,1] );;
gap&gt; h:= IsomorphismOfTensorModules( V, W );;
gap&gt; VW:= Source( h );
&lt;20-dimensional left-module over QuantumUEA( &lt;root system of type B
2&gt;, Qpar = q )&gt;
gap&gt; Image( h, Basis(VW)[13] );
q*(1*v0&lt;x&gt;F3*v0)+1-q^2*(F4*v0&lt;x&gt;F2*v0)+q^-1-q^3*(F3*v0&lt;x&gt;1*v0)
</pre></td></tr></table>

<p><a id="X87FF182B86367CC4" name="X87FF182B86367CC4"></a></p>

<h5>3.8-18 WriteModuleToFile</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; WriteModuleToFile</code>( <var class="Arg">V, file</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Here <var class="Arg">V</var> is a module over a quantized enveloping algebra, and <var class="Arg">file</var> is a string containing the name of a file. This function writes some data to <var class="Arg">file</var>, that allows <code class="func">ReadModuleFromFile</code> (<a href="chap3.html#X7DD49D8282C516B9"><b>3.8-19</b></a>) to recover it.</p>

<p>We remark that this function currently is only implemented for generic quantized enveloping algebras.</p>

<p><a id="X7DD49D8282C516B9" name="X7DD49D8282C516B9"></a></p>

<h5>3.8-19 ReadModuleFromFile</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ReadModuleFromFile</code>( <var class="Arg">file</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Here <var class="Arg">file</var> is a string containing the name of a file, to which a module over a quantized enveloping algebra has been written by <code class="func">WriteModuleToFile</code> (<a href="chap3.html#X87FF182B86367CC4"><b>3.8-18</b></a>). This function recovers the module. More precisely: a new module is constructed that is isomorphic to the old one. In the process the algebra acting on the module is constructed anew (from data written to the file). This algebra can be accessed by <var class="Arg">LeftActingAlgebra( V )</var>.</p>

<p>We remark that this function currently is only implemented for generic quantized enveloping algebras.</p>


<table class="example">
<tr><td><pre>
gap&gt; U:= QuantizedUEA( RootSystem("A",3) );;
gap&gt; V:= HighestWeightModule( U, [1,1,1] );;
gap&gt; WriteModuleToFile( V, "/home/wdg/A3mod" );
gap&gt; W:= ReadModuleFromFile( "/home/wdg/A3mod" );
&lt;64-dimensional left-module over QuantumUEA( &lt;root system of type A
3&gt;, Qpar = q )&gt;
</pre></td></tr></table>

<p><a id="X83BBB99685FB9FB7" name="X83BBB99685FB9FB7"></a></p>

<h4>3.9 <span class="Heading">The path model</span></h4>

<p>In this section we describe functions for dealing with the path model. We work only with LS-paths, which are represented by two lists, one of weights, and one of rationals (see Section <a href="chap2.html#X83BBB99685FB9FB7"><b>2.7</b></a>).</p>

<p><a id="X8025E1918067B03C" name="X8025E1918067B03C"></a></p>

<h5>3.9-1 DominantLSPath</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; DominantLSPath</code>( <var class="Arg">R, wt</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Here <var class="Arg">R</var> is a root system, and <var class="Arg">wt</var> a dominant weight in the weight lattice of <var class="Arg">R</var>. This function returns the LS-path that is the line from the origin to <var class="Arg">wt</var>.</p>


<table class="example">
<tr><td><pre>
gap&gt; R:= RootSystem( "G", 2 );;
gap&gt; DominantLSPath( R, [1,3] );
&lt;LS path of shape [ 1, 3 ] ending in [ 1, 3 ] &gt;
</pre></td></tr></table>

<p><a id="X82EDAFAB7E81BD1F" name="X82EDAFAB7E81BD1F"></a></p>

<h5>3.9-2 Falpha</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; Falpha</code>( <var class="Arg">path, ind</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Is the result of applying the path operator f_alpha_<var class="Arg">ind</var>} to the LS-path <var class="Arg">path</var> (where alpha_<var class="Arg">ind</var> is the <var class="Arg">ind</var>-th simple root).</p>

<p>The result is <var class="Arg">fail</var> if f_alpha_<var class="Arg">ind</var>}<var class="Arg">(path)=0</var>.</p>


<table class="example">
<tr><td><pre>
gap&gt; R:= RootSystem( "G", 2 );;
gap&gt; p:=DominantLSPath( R, [1,3] );;
gap&gt; p1:=Falpha( p, 1 );
&lt;LS path of shape [ 1, 3 ] ending in [ -1, 4 ] &gt;
gap&gt; Falpha( p1, 1 );
fail
</pre></td></tr></table>

<p><a id="X855C478587112804" name="X855C478587112804"></a></p>

<h5>3.9-3 Ealpha</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; Ealpha</code>( <var class="Arg">path, ind</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Is the result of applying the path operator e_alpha_<var class="Arg">ind</var>} to the LS-path <var class="Arg">path</var> (where alpha_<var class="Arg">ind</var> is the <var class="Arg">ind</var>-th simple root).</p>

<p>The result is <var class="Arg">fail</var> if e_alpha_<var class="Arg">ind</var>}<var class="Arg">(path)=0</var>.</p>


<table class="example">
<tr><td><pre>
gap&gt; R:= RootSystem( "G", 2 );;
gap&gt; p:=DominantLSPath( R, [1,3] );;
gap&gt; Ealpha( p, 2 );
fail
gap&gt; p1:=Falpha( p, 1 );;
gap&gt; Ealpha( p1, 1 );
&lt;LS path of shape [ 1, 3 ] ending in [ 1, 3 ] &gt;
</pre></td></tr></table>

<p><a id="X820413E57DEDB0D1" name="X820413E57DEDB0D1"></a></p>

<h5>3.9-4 LSSequence</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; LSSequence</code>( <var class="Arg">path</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>returns the two sequences (of weights and rational numbers) that define the LS-path path.</p>


<table class="example">
<tr><td><pre>
gap&gt; R:= RootSystem( "G", 2 );;
gap&gt; p:=DominantLSPath( R, [1,3] );;
gap&gt; p1:= Falpha( Falpha( p, 1 ), 2 );;
gap&gt; LSSequence( p1 );
[ [ [ 11, -4 ], [ -1, 4 ] ], [ 0, 1/4, 1 ] ]
</pre></td></tr></table>

<p><a id="X8573A4077DB4659F" name="X8573A4077DB4659F"></a></p>

<h5>3.9-5 WeylWord</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; WeylWord</code>( <var class="Arg">path</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Here <var class="Arg">path</var> is an LS-path in the orbit (under the root operators) of a dominant LS-path ending in the dominant weight lambda. This means that the first direction of path is of the form w(lambda) for some w in the Weyl group. This function returns a list [i_1,..., i_m ] such that w=s_i_1cdots s_i_m.</p>


<table class="example">
<tr><td><pre>
gap&gt; R:= RootSystem( "G", 2 );;
gap&gt; p:=DominantLSPath( R, [1,3] );;
gap&gt; p1:= Falpha( Falpha( Falpha( p, 1 ), 2 ), 1 );;
gap&gt; WeylWord( p1 );
[ 1, 2, 1 ]
</pre></td></tr></table>

<p><a id="X7D06353282BE96C6" name="X7D06353282BE96C6"></a></p>

<h5>3.9-6 EndWeight</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; EndWeight</code>( <var class="Arg">path</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Here <var class="Arg">path</var> is an LS-path; this function returns the weight that is the endpoint of path</p>


<table class="example">
<tr><td><pre>
gap&gt; R:= RootSystem( "G", 2 );;
gap&gt; p:=DominantLSPath( R, [1,3] );;
gap&gt; p1:= Falpha( Falpha( Falpha( p, 1 ), 2 ), 1 );;
gap&gt; EndWeight( p1 );
[ 0, 3 ]
</pre></td></tr></table>

<p><a id="X8637218B80BDC906" name="X8637218B80BDC906"></a></p>

<h5>3.9-7 CrystalGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; CrystalGraph</code>( <var class="Arg">R, wt</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>This function returns a record describing the crystal graph of the highest-weight module with highest weight <var class="Arg">wt</var>, over the quantized enveloping algebra corresponding to <var class="Arg">R</var>. It is computed using the path model. Therefore the points in the graph are LS-paths.</p>

<p>Denote the output by <var class="Arg">r</var>; then <var class="Arg">r.points</var> is the list of points of the graph. Furthermore, <var class="Arg">r.edges</var> is a list of edges of the graph; this is a list of elements of the form <var class="Arg">[ [ i, j ], u ]</var>. This means that there is an arrow from point <var class="Arg">i</var> (i.e., the point on position <var class="Arg">i</var> in <var class="Arg">r.points</var>) to point <var class="Arg">j</var>, with label <var class="Arg">u</var>.</p>


<table class="example">
<tr><td><pre>
gap&gt; R:= RootSystem( "A", 2 );;
gap&gt; CrystalGraph( R, [1,1] );
rec(
  points := [ &lt;LS path of shape [ 1, 1 ] ending in [ 1, 1 ] &gt;, &lt;LS path of sha\
pe [ 1, 1 ] ending in [ -1, 2 ] &gt;, &lt;LS path of shape [ 1, 1 ] ending in
        [ 2, -1 ] &gt;, &lt;LS path of shape [ 1, 1 ] ending in [ 0, 0 ] &gt;,
      &lt;LS path of shape [ 1, 1 ] ending in [ 0, 0 ] &gt;,
      &lt;LS path of shape [ 1, 1 ] ending in [ 1, -2 ] &gt;,
      &lt;LS path of shape [ 1, 1 ] ending in [ -2, 1 ] &gt;,
      &lt;LS path of shape [ 1, 1 ] ending in [ -1, -1 ] &gt; ],
  edges := [ [ [ 1, 2 ], 1 ], [ [ 1, 3 ], 2 ], [ [ 2, 4 ], 2 ],
      [ [ 3, 5 ], 1 ], [ [ 4, 6 ], 2 ], [ [ 5, 7 ], 1 ], [ [ 6, 8 ], 1 ],
      [ [ 7, 8 ], 2 ] ] )
</pre></td></tr></table>

<p><a id="X827A177C8416C576" name="X827A177C8416C576"></a></p>

<h4>3.10 <span class="Heading"> Canonical bases </span></h4>

<p>Here we describe functions for computing the canonical basis of the negative part of a quantized enveloping algebra, and of a module.</p>

<p><a id="X8215C71E8361EE62" name="X8215C71E8361EE62"></a></p>

<h5>3.10-1 Falpha</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; Falpha</code>( <var class="Arg">x, ind</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Here <var class="Arg">x</var> is a PBW-monomial in U^- (i.e., a monomial in the F_alpha, where alpha runs over the positive roots). This function returns the result of applying the <var class="Arg">ind</var>-th Kashiwara operator widetildeF_alpha_<var class="Arg">ind</var>} to x (cf. Section <a href="chap2.html#X78BE3EB980F0A295"><b>2.6</b></a>).</p>


<table class="example">
<tr><td><pre>
gap&gt; U:= QuantizedUEA( RootSystem( "F", 4 ) );;
gap&gt; x:= One( U );
1
gap&gt; Falpha( Falpha( x, 3 ), 2 );
F3*F9
</pre></td></tr></table>

<p><a id="X814B1C7B7AF17B79" name="X814B1C7B7AF17B79"></a></p>

<h5>3.10-2 Ealpha</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; Ealpha</code>( <var class="Arg">x, ind</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Here <var class="Arg">x</var> is a PBW-monomial in U^- (i.e., a monomial in the F_alpha, where alpha runs over the positive roots). This function returns the result of applying the <var class="Arg">ind</var>-th Kashiwara operator widetildeE_alpha_<var class="Arg">ind</var>} to x (cf. Section <a href="chap2.html#X78BE3EB980F0A295"><b>2.6</b></a>). The result is <var class="Arg">fail</var> if widetildeE_alpha_<var class="Arg">ind</var>}<var class="Arg">(x)=0</var>.</p>


<table class="example">
<tr><td><pre>
gap&gt; U:= QuantizedUEA( RootSystem( "F", 4 ) );;
gap&gt; Ealpha( One( U ), 2 );
fail
gap&gt; g:= GeneratorsOfAlgebra( U );;
gap&gt; x:= g[1]*g[4]*g[7]*g[17];
F1*F4*F7*F17
gap&gt; Ealpha( x, 3 );
F1*F2*F7*F17

</pre></td></tr></table>

<p><a id="X7C8EBFF5805F8C51" name="X7C8EBFF5805F8C51"></a></p>

<h5>3.10-3 CanonicalBasis</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; CanonicalBasis</code>( <var class="Arg">U</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Is the canonical basis of the quantized universal enveloping algebra <var class="Arg">U</var>. When this is constructed nothing is computed. By using <code class="func">PBWElements</code> (<a href="chap3.html#X8233212A79D722FB"><b>3.10-4</b></a>), <code class="func">MonomialElements</code> (<a href="chap3.html#X81631585816C4CCD"><b>3.10-5</b></a>), <code class="func">Strings</code> (<a href="chap3.html#X782174177D696504"><b>3.10-6</b></a>) information about elements of the canonical basis can be obtained.</p>


<table class="example">
<tr><td><pre>
gap&gt; U:= QuantizedUEA( RootSystem( "F", 4 ) );;
gap&gt; B:= CanonicalBasis( U );
&lt;canonical basis of QuantumUEA( &lt;root system of type F4&gt;, Qpar = q ) &gt;
</pre></td></tr></table>

<p><a id="X8233212A79D722FB" name="X8233212A79D722FB"></a></p>

<h5>3.10-4 PBWElements</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; PBWElements</code>( <var class="Arg">B, rt</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Here <var class="Arg">B</var> is the canonical basis of a quantized uea, and <var class="Arg">rt</var> a list of non-negative integers representing an element of the root lattice (e.g., if the simple roots are alpha, beta and <var class="Arg">rt = [ 3, 2 ]</var>, then <var class="Arg">rt</var> represents 3alpha+2beta).</p>

<p>It is possible to add the option <var class="Arg">lowrank</var>, as follows <var class="Arg">PBWElements( B, rt :lowrank )</var>. In that case a somewhat different method will be used, that is significantly faster if the underlying root system has rank 2,3. It is about equally fast for ranks 4,5; and slower for ranks greater than 5.</p>


<table class="example">
<tr><td><pre>
gap&gt; U:= QuantizedUEA( RootSystem( "F", 4 ) );;
gap&gt; B:= CanonicalBasis( U );;
gap&gt; PBWElements( B, [1,2,1,0] );
[ F1*F3^(2)*F9, F1*F3*F7+(q^4)*F1*F3^(2)*F9, (q^4)*F1*F3^(2)*F9+F2*F3*F9,
  (q^2)*F1*F3*F7+(q^2+q^6)*F1*F3^(2)*F9+(q^2)*F2*F3*F9+F2*F7,
  (q^4)*F1*F3*F7+(q^8)*F1*F3^(2)*F9+(q^4)*F2*F3*F9+(q^2)*F2*F7+F3*F4 ]
gap&gt; U:= QuantizedUEA( RootSystem("G",2) );;
gap&gt; B:= CanonicalBasis( U );;
gap&gt; PBWElements( B, [2,3] : lowrank );
[ F1^(2)*F6^(3), F1*F5*F6^(2)+(q^8+q^10)*F1^(2)*F6^(3),
  (q^2)*F1*F5*F6^(2)+(q^6+q^12)*F1^(2)*F6^(3)+F3*F6^(2),
  (q^8)*F1*F5*F6^(2)+(q^18)*F1^(2)*F6^(3)+(q^6)*F3*F6^(2)+F5^(2)*F6 ]
</pre></td></tr></table>

<p><a id="X81631585816C4CCD" name="X81631585816C4CCD"></a></p>

<h5>3.10-5 MonomialElements</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; MonomialElements</code>( <var class="Arg">B, rt</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>This does the same as <code class="func">PBWElements</code> (<a href="chap3.html#X8233212A79D722FB"><b>3.10-4</b></a>), except that the elements are written as linear combinations of monomials in the generators F_alpha, where alpha runs through the simple roots.</p>

<p>We remark that this information is also computed "behind the scenes" when calling <var class="Arg">PBWElements( B, rt )</var>. However, it is not computed if the option <var class="Arg">lowrank</var> is present in the call to <var class="Arg">PBWElements</var>.</p>


<table class="example">
<tr><td><pre>
gap&gt; U:= QuantizedUEA( RootSystem( "F", 4 ) );;
gap&gt; B:= CanonicalBasis( U );;
gap&gt; MonomialElements( B, [1,2,1,0] );
[ F1*F3^(2)*F9, F1*F3*F9*F3+(-1)*F1*F3^(2)*F9, F3^(2)*F1*F9, F3*F1*F9*F3,
  F3*F9*F3*F1+(-1)*F3^(2)*F1*F9 ]
</pre></td></tr></table>

<p><a id="X782174177D696504" name="X782174177D696504"></a></p>

<h5>3.10-6 Strings</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; Strings</code>( <var class="Arg">B, rt</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Here <var class="Arg">B</var>, <var class="Arg">rt</var> are the same as in <code class="func">PBWElements</code> (<a href="chap3.html#X8233212A79D722FB"><b>3.10-4</b></a>). This returns the list of strings corresponding to the elements of <var class="Arg">B</var> of weight <var class="Arg">rt</var> (cf. Section <a href="chap2.html#X78BE3EB980F0A295"><b>2.6</b></a>). For example, if on the k-th position of the list returned by this function we have <var class="Arg">[ 1, 2, 2, 3 ]</var>, then the principal monomial of the k-th element of <var class="Arg">PBWElements( B, rt )</var> is widetildeF_1^2widetildeF_2^3(1) (where widetildeF_i is the i-th Kashiwara operator).</p>

<p>We remark that this information is also computed "behind the scenes" when calling <var class="Arg">PBWElements( B, rt )</var>. However, it is not computed if the option <var class="Arg">lowrank</var> is present in the call to <var class="Arg">PBWElements</var>.</p>


<table class="example">
<tr><td><pre>
gap&gt; U:= QuantizedUEA( RootSystem( "F", 4 ) );;
gap&gt; B:= CanonicalBasis( U );;
gap&gt; Strings( B, [1,2,1,0] );
[ [ 1, 1, 2, 2, 3, 1 ], [ 1, 1, 2, 1, 3, 1, 2, 1 ], [ 2, 2, 1, 1, 3, 1 ],
  [ 2, 1, 1, 1, 3, 1, 2, 1 ], [ 2, 1, 3, 1, 2, 1, 1, 1 ] ]
gap&gt; Falpha( Falpha( Falpha( Falpha( One(U), 3 ), 1 ), 2 ), 2 );
F2*F3*F9
gap&gt; PBWElements( B, [1,2,1,0] )[3];
(q^4)*F1*F3^(2)*F9+F2*F3*F9
</pre></td></tr></table>

<p><a id="X842A5CC07C3E5848" name="X842A5CC07C3E5848"></a></p>

<h5>3.10-7 PrincipalMonomial</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; PrincipalMonomial</code>( <var class="Arg">u</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Here <var class="Arg">u</var> is an element of the output of <code class="func">PBWElements</code> (<a href="chap3.html#X8233212A79D722FB"><b>3.10-4</b></a>). This function returns the unique monomial of <var class="Arg">u</var> that has coefficient 1.</p>


<table class="example">
<tr><td><pre>
gap&gt; U:= QuantizedUEA( RootSystem("G",2) );;
gap&gt; B:= CanonicalBasis( U );;
gap&gt; p:= PBWElements( B, [4,4] : lowrank )[4];
(q^9)*F1^(2)*F3*F6^(3)+F1^(2)*F5^(2)*F6^(2)+(q^9+q^11+q^13)*F1^(3)*F5*F6^(
3)+(q^20+q^22+2*q^24+q^26+q^28)*F1^(4)*F6^(4)
gap&gt; PrincipalMonomial( p );
F1^(2)*F5^(2)*F6^(2)
</pre></td></tr></table>

<p><a id="X7C04F75683D0A512" name="X7C04F75683D0A512"></a></p>

<h5>3.10-8 StringMonomial</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; StringMonomial</code>( <var class="Arg">u</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Here <var class="Arg">u</var> is a monomial in the negative part of a quantized enveloping algebra, e.g., as output by <code class="func">PrincipalMonomial</code> (<a href="chap3.html#X842A5CC07C3E5848"><b>3.10-7</b></a>). This function computes the corresponding "string" (see Section <a href="chap2.html#X78BE3EB980F0A295"><b>2.6</b></a>). The strings are output in the same way as in <a href="chap3.html#X782174177D696504"><b>3.10-6</b></a>.</p>


<table class="example">
<tr><td><pre>
gap&gt; U:= QuantizedUEA( RootSystem("G",2) );;
gap&gt; B:= CanonicalBasis( U );;
gap&gt; p:= PBWElements( B, [1,2] : lowrank )[2];;
gap&gt; m:=PrincipalMonomial( p );
F5*F6
gap&gt; StringMonomial( m );
[ 2, 2, 1, 1 ]
gap&gt; Falpha( Falpha( Falpha( One(U), 1 ), 2 ), 2 );
F5*F6
</pre></td></tr></table>

<p><a id="X7E67BE5D856C77DC" name="X7E67BE5D856C77DC"></a></p>

<h5>3.10-9 Falpha</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; Falpha</code>( <var class="Arg">V, v, ind</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Here <var class="Arg">V</var> is a module over a quantized enveloping algebra, <var class="Arg">v</var> an element of it, and <var class="Arg">ind</var> an index between 1 and the rank of the root system. The function returns the result of applying the <var class="Arg">ind</var>-th Kashiwara operator widetildeF_<var class="Arg">ind</var> to <var class="Arg">v</var>. Here the Kashiwara operators are different from the ones described in Section <a href="chap2.html#X78BE3EB980F0A295"><b>2.6</b></a>. We refer to <a href="chapBib.html#biBJ96">[Jan96]</a>, 9.2 for the definition of the operators used here.</p>


<table class="example">
<tr><td><pre>
gap&gt; U:= QuantizedUEA( RootSystem("B",2) );;
gap&gt; V:= HighestWeightModule( U, [1,1] );;
gap&gt; Falpha( V, Basis(V)[1], 1 );
F1*v0
</pre></td></tr></table>

<p><a id="X855EFC817CFCE2C7" name="X855EFC817CFCE2C7"></a></p>

<h5>3.10-10 Ealpha</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; Ealpha</code>( <var class="Arg">V, v, ind</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Here <var class="Arg">V</var> is a module over a quantized enveloping algebra, <var class="Arg">v</var> an element of it, and <var class="Arg">ind</var> an index between 1 and the rank of the root system. The function returns the result of applying the <var class="Arg">ind</var>-th Kashiwara operator widetildeE_<var class="Arg">ind</var> to <var class="Arg">v</var>. Here the Kashiwara operators are different from the ones described in Section <a href="chap2.html#X78BE3EB980F0A295"><b>2.6</b></a>. We refer to <a href="chapBib.html#biBJ96">[Jan96]</a>, 9.2 for the definition of the operators used here.</p>


<table class="example">
<tr><td><pre>
gap&gt; U:= QuantizedUEA( RootSystem("B",2) );;
gap&gt; V:= HighestWeightModule( U, [1,1] );;
gap&gt; v:= Falpha( V, Basis(V)[2], 2 );
(q^2)*F1*F4*v0+F2*v0
gap&gt; Ealpha( V, v, 2 );
F1*v0
</pre></td></tr></table>

<p><a id="X85A9229678572948" name="X85A9229678572948"></a></p>

<h5>3.10-11 CrystalBasis</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; CrystalBasis</code>( <var class="Arg">V</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Here <var class="Arg">V</var> is a finite-dimensional left module over a quantized enveloping algebra. This function returns the canonical, or crystal basis of V (see Section <a href="chap2.html#X78BE3EB980F0A295"><b>2.6</b></a>).</p>

<p>This function only works for modules for which <code class="func">WeightsAndVectors</code> (<a href="chap3.html#X7929063E7C428331"><b>3.8-14</b></a>) works.</p>


<table class="example">
<tr><td><pre>
gap&gt; U:= QuantizedUEA( RootSystem( "B", 2 ) );;
 gap&gt; V:= HighestWeightModule( U, [1,1] );
 &lt;16-dimensional left-module over QuantumUEA( &lt;root system of type B2&gt;, Qpar
= q )&gt;
 gap&gt;  CrystalBasis( V );
 Basis( &lt;16-dimensional left-module over QuantumUEA( &lt;root system of type B
 2&gt;, Qpar = q )&gt;, [ 1*v0, F1*v0, F4*v0, F1*F4*v0, (q^2)*F1*F4*v0+F2*v0, F2*F4*v0,
(q)*F2*F4*v0+F3*v0, (-q^-4)*F1*F2*v0, (-q^-1)*F1*F3*v0+(-q^-3)*F2^(2)*v0,
(-q^-2)*F2^(2)*v0, F3*F4*v0, (-q^-4)*F2*F3*v0+(-q^-2)*F2^(2)*F4*v0,
(-q^-2)*F2*F3*v0, (q^-4)*F2^(3)*v0, (-q^-1)*F3^(2)*v0, (q^-5)*F2^(2)*F3*v0 ] )
</pre></td></tr></table>

<p><a id="X82CE52AB7E798902" name="X82CE52AB7E798902"></a></p>

<h5>3.10-12 CrystalVectors</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; CrystalVectors</code>( <var class="Arg">V</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Here <var class="Arg">V</var> is a finite-dimensional left module over a quantized enveloping algebra. Let <var class="Arg">C</var> be the crystal basis of <var class="Arg">V</var> (i.e., output by <code class="func">CrystalBasis</code> (<a href="chap3.html#X85A9229678572948"><b>3.10-11</b></a>)). This function returns a list of cosets of the basis elements of <var class="Arg">C</var> modulo qL, where L is the Z[q]-lattice spanned by <var class="Arg">C</var>.</p>

<p>The coset of a vector <var class="Arg">v</var> is printed as <var class="Arg">&lt;v&gt;</var>.</p>

<p>The crystal vectors are used to construct the point set of the crystal graph of <var class="Arg">V</var> (<code class="func">CrystalGraph:for a module</code> (<b>???</b>)).</p>

<p>This function only works for modules for which <code class="func">WeightsAndVectors</code> (<a href="chap3.html#X7929063E7C428331"><b>3.8-14</b></a>) works.</p>


<table class="example">
<tr><td><pre>
gap&gt; U:= QuantizedUEA( RootSystem( "B", 2 ) );;
gap&gt; V:= HighestWeightModule( U, [1,1] );
&lt;16-dimensional left-module over QuantumUEA( &lt;root system of type B
2&gt;, Qpar = q )&gt;
gap&gt; CrystalVectors( V );
[ &lt;1*v0&gt;, &lt;F1*v0&gt;, &lt;F4*v0&gt;, &lt;F2*v0&gt;, &lt;F1*F4*v0&gt;, &lt;F3*v0&gt;,
  &lt;(-q^-4)*F1*F2*v0&gt;, &lt;F2*F4*v0&gt;, &lt;F1*F3*v0&gt;, &lt;F3*F4*v0&gt;,
  &lt;(-q^-1)*F1*F3*v0+(-q^-3)*F2^(2)*v0&gt;, &lt;(-q^-4)*F2*F3*v0+(-q^-2)*F2^(2)*F
    4*v0&gt;, &lt;F2^(2)*F4*v0&gt;, &lt;(q^-4)*F2^(3)*v0&gt;, &lt;(-q^-1)*F3^(2)*v0&gt;,
  &lt;(q^-5)*F2^(2)*F3*v0&gt; ]
</pre></td></tr></table>

<p><a id="X80A534637D8F3210" name="X80A534637D8F3210"></a></p>

<h5>3.10-13 Falpha</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; Falpha</code>( <var class="Arg">v, ind</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Here <var class="Arg">v</var> is a crystal vector, i.e., an element of <var class="Arg">CrystalVectors( V )</var>, where <var class="Arg">V</var> is a left module over a quantized enveloping algebra. This function returns the result of applying the <var class="Arg">ind</var>-th Kashiwara operator widetildeF_alpha_<var class="Arg">ind</var>} to v. The result is <var class="Arg">fail</var> if widetildeF_alpha_<var class="Arg">ind</var>}<var class="Arg">(v)=0</var>.</p>


<table class="example">
<tr><td><pre>
gap&gt; U:= QuantizedUEA( RootSystem( "B", 2 ) );;
gap&gt; V:= HighestWeightModule( U, [1,1] );;
gap&gt; c:=CrystalVectors( V );;
gap&gt; Falpha( c[2], 2 );
&lt;F2*v0&gt;
gap&gt; Falpha( c[3], 2 );
fail
gap&gt; Falpha( Falpha( Falpha( c[1], 1 ), 2 ), 1 );
fail
gap&gt; p:= DominantLSPath( RootSystem( "B", 2 ), [1,1] );
&lt;LS path of shape [ 1, 1 ] ending in [ 1, 1 ] &gt;
gap&gt; Falpha( Falpha( Falpha( p, 1 ), 2 ), 1 );
fail
</pre></td></tr></table>

<p>The last part of this example is an illustration of the fact that the crystal graph of a highest-weight module can be obtained by the path method (see Section <a href="chap2.html#X83BBB99685FB9FB7"><b>2.7</b></a>).</p>

<p><a id="X7B9C76BF841FA70B" name="X7B9C76BF841FA70B"></a></p>

<h5>3.10-14 Ealpha</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; Ealpha</code>( <var class="Arg">v, ind</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Here <var class="Arg">v</var> is a crystal vector, i.e., an element of <var class="Arg">CrystalVectors( V )</var>, where <var class="Arg">V</var> is a left module over a quantized enveloping algebra. This function returns the result of applying the <var class="Arg">ind</var>-th Kashiwara operator widetildeE_alpha_<var class="Arg">ind</var>} to v. The result is <var class="Arg">fail</var> if widetildeE_alpha_<var class="Arg">ind</var>}<var class="Arg">(v)=0</var>.</p>


<table class="example">
<tr><td><pre>
gap&gt; U:= QuantizedUEA( RootSystem( "B", 2 ) );;
gap&gt; V:= HighestWeightModule( U, [1,1] );;
gap&gt; c:=CrystalVectors( V );;
gap&gt; Ealpha( c[3], 1 );
fail
gap&gt; Ealpha( c[3], 2 );
&lt;1*v0&gt;
</pre></td></tr></table>

<p><a id="X7D7607BB81ADF579" name="X7D7607BB81ADF579"></a></p>

<h5>3.10-15 CrystalGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; CrystalGraph</code>( <var class="Arg">V</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns the crystal graph of the module <var class="Arg">V</var>. The points of this graph are the cosets output by <code class="func">CrystalVectors</code> (<a href="chap3.html#X82CE52AB7E798902"><b>3.10-12</b></a>). The edges work in the same way as in <code class="func">CrystalGraph:for root system and weight</code> (<b>???</b>).</p>


<table class="example">
<tr><td><pre>
gap&gt; U:= QuantizedUEA( RootSystem("A",2) );;
gap&gt; V1:= HighestWeightModule( U, [1,0] );;
gap&gt; V2:= HighestWeightModule( U, [0,1] );;
gap&gt; W:= TensorProductOfAlgebraModules( V1, V2 );;
gap&gt; CrystalGraph( W );
rec(
  points := [ &lt;1*(1*v0&lt;x&gt;1*v0)&gt;, &lt;1*(F1*v0&lt;x&gt;1*v0)&gt;, &lt;1*(1*v0&lt;x&gt;F3*v0)&gt;,
      &lt;1*(1*v0&lt;x&gt;F2*v0)+q^-1*(F2*v0&lt;x&gt;1*v0)&gt;,
      &lt;-q^-1*(1*v0&lt;x&gt;F2*v0)+q^-1*(F1*v0&lt;x&gt;F3*v0)&gt;, &lt;1*(F2*v0&lt;x&gt;F3*v0)&gt;,
      &lt;-q^-1*(F1*v0&lt;x&gt;F2*v0)&gt;, &lt;-q^-1*(F2*v0&lt;x&gt;F2*v0)&gt;,
      &lt;-q^-3*(1*v0&lt;x&gt;F2*v0)+-q^-1*(F1*v0&lt;x&gt;F3*v0)+1*(F2*v0&lt;x&gt;1*v0)&gt; ],
  edges := [ [ [ 1, 2 ], 1 ], [ [ 1, 3 ], 2 ], [ [ 2, 4 ], 2 ],
      [ [ 3, 5 ], 1 ], [ [ 4, 6 ], 2 ], [ [ 5, 7 ], 1 ], [ [ 6, 8 ], 1 ],
      [ [ 7, 8 ], 2 ] ] )
</pre></td></tr></table>

<p><a id="X7875070C85DD4E8E" name="X7875070C85DD4E8E"></a></p>

<h4>3.11 <span class="Heading"> Universal enveloping algebras </span></h4>

<p>Here we describe functions for connecting a quantized enveloping algebra to the corresponding universal enveloping algebra.</p>

<p><a id="X7E7B25307E6478CD" name="X7E7B25307E6478CD"></a></p>

<h5>3.11-1 UEA</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; UEA</code>( <var class="Arg">L</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>This function returns the universal enveloping algebra <var class="Arg">u</var> of the semisimple Lie algebra <var class="Arg">L</var>. The generators of <var class="Arg">u</var> are the generators of a Kostant lattice in the universal enveloping algebra (these generators are obtained from <var class="Arg">L</var> by <var class="Arg">LatticeGeneratorsInUEA( L )</var>, see the <strong class="pkg">GAP</strong> reference manual).</p>


<table class="example">
<tr><td><pre>
gap&gt; L:= SimpleLieAlgebra( "B", 2, Rationals );
&lt;Lie algebra of dimension 10 over Rationals&gt;
gap&gt; u:= UEA( L );
&lt;algebra over Rationals, with 10 generators&gt;
gap&gt; g:= GeneratorsOfAlgebra( u );
[ y1, y2, y3, y4, x1, x2, x3, x4, ( h9/1 ), ( h10/1 ) ]
</pre></td></tr></table>

<p><a id="X7CA021E28527763E" name="X7CA021E28527763E"></a></p>

<h5>3.11-2 UnderlyingLieAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; UnderlyingLieAlgebra</code>( <var class="Arg">u</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>For a universal enveloping algebra <var class="Arg">u</var> constructed by <code class="func">UEA</code> (<a href="chap3.html#X7E7B25307E6478CD"><b>3.11-1</b></a>), this returns the corresponding semisimple Lie algebra</p>


<table class="example">
<tr><td><pre>
gap&gt; L:= SimpleLieAlgebra( "B", 2, Rationals );;
gap&gt; u:= UEA( L );;
gap&gt; UnderlyingLieAlgebra( u );
&lt;Lie algebra of dimension 10 over Rationals&gt;
</pre></td></tr></table>

<p><a id="X8707EE2C8145701F" name="X8707EE2C8145701F"></a></p>

<h5>3.11-3 HighestWeightModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; HighestWeightModule</code>( <var class="Arg">u, hw</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>For a universal enveloping algebra <var class="Arg">u</var> constructed by <code class="func">UEA</code> (<a href="chap3.html#X7E7B25307E6478CD"><b>3.11-1</b></a>), this returns the irreducible highest weight module over <var class="Arg">u</var> with highest weight <var class="Arg">hw</var>, which must be dominant. This module is the same as the corresponding highest weight module over the semisimple Lie algebra, but in this case the enveloping algebra <var class="Arg">u</var> acts.</p>


<table class="example">
<tr><td><pre>
gap&gt; L:= SimpleLieAlgebra( "B", 2, Rationals );;
gap&gt; u:= UEA( L );;
gap&gt; HighestWeightModule( u, [2,3] );
&lt;140-dimensional left-module over &lt;algebra over Rationals, with
10 generators&gt;&gt;
</pre></td></tr></table>

<p><a id="X7AD80E5C7E015859" name="X7AD80E5C7E015859"></a></p>

<h5>3.11-4 QUEAToUEAMap</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; QUEAToUEAMap</code>( <var class="Arg">L</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Here <var class="Arg">L</var> is a semisimple Lie algebra. Set <var class="Arg">u := UEA( L )</var>, and <var class="Arg">U := QuantizedUEA( L )</var> (so <var class="Arg">u, U</var> are the universal enveloping algebra, and "generic" quantized enveloping algebra of <var class="Arg">L</var> respectively). Then <var class="Arg">QUEAToUEAMap( L )</var> returns the algebra homomorphism from <var class="Arg">U</var> to <var class="Arg">u</var> obtained by mapping <var class="Arg">q</var> to <var class="Arg">1</var>, a generator <var class="Arg">Fi</var>, corresponding to a simple root to the generator <var class="Arg">yi</var> (corresponding to the same simple root), and likewise for <var class="Arg">Ei</var> and <var class="Arg">xi</var>. This means that <var class="Arg">Ki</var> is mapped to one, and <var class="Arg">[ Ki : s ]</var> to <var class="Arg">hi</var> choose <var class="Arg">s</var>.</p>

<p>The canonical basis of <var class="Arg">U</var> is mapped to the canonical basis of <var class="Arg">u</var>.</p>


<table class="example">
<tr><td><pre>
gap&gt; L:= SimpleLieAlgebra( "B", 2, Rationals );;
gap&gt; f:= QUEAToUEAMap( L );
&lt;mapping: QuantumUEA( &lt;root system of rank
2&gt;, Qpar = q ) -&gt; Algebra( Rationals, [ y1, y2, y3, y4, x1, x2, x3, x4,
  ( h9/1 ), ( h10/1 ) ] ) &gt;
gap&gt; U:= Source( f );
QuantumUEA( &lt;root system of rank 2&gt;, Qpar = q )
gap&gt; u:= Range( f );
&lt;algebra over Rationals, with 10 generators&gt;
gap&gt; B:= CanonicalBasis( U );;
gap&gt; p:= PBWElements( B, [1,2] );
[ F1*F4^(2), (q+q^3)*F1*F4^(2)+F2*F4, (q^4)*F1*F4^(2)+(q)*F2*F4+F3 ]
gap&gt; pu:= List( p, x -&gt; Image( f, x ) );
[ y1*y2^(2), 2*y1*y2^(2)+y2*y3-2*y4, y1*y2^(2)+y2*y3-1*y4 ]
gap&gt; V:= HighestWeightModule( u, [2,1] );
&lt;40-dimensional left-module over &lt;algebra over Rationals, with
10 generators&gt;&gt;
gap&gt; List( pu, x -&gt; x^Basis(V)[1] );
[ 0*v0, y2*y3*v0+-2*y4*v0, y2*y3*v0+-1*y4*v0 ]
# Which gives us a piece of the canonical basis of V.
</pre></td></tr></table>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">Top of Book</a>&nbsp;  &nbsp;<a href="chap2.html">Previous Chapter</a>&nbsp;  &nbsp;<a href="chapBib.html">Next Chapter</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
