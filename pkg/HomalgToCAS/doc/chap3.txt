  
  [1X3 Watch and Influence the Communication[0X
  
  
  [1X3.1 Functions[0X
  
  [1X3.1-1 homalgIOMode[0m
  
  [2X> homalgIOMode( [0X[3Xstr[, str2[, str3]][0X[2X ) ______________________________[0Xfunction
  
  This  function  sets  different  modes  which  influence  how  much  of  the
  communication   becomes   visible.   Handling   the   string   [3Xstr[0m   is  [13Xnot[0m
  case-sensitive.  [10XhomalgIOMode[0m invokes the global function [10XhomalgMode[0m defined
  in  the  [5Xhomalg[0m  package  with  an  "appropriate" argument (see code below).
  Alternatively,  if  a  second  or more strings are given, then [10XhomalgMode[0m is
  invoked  with  the  remaining  strings  [3Xstr2[0m,  [3Xstr3[0m,  ...  at  the  end.  In
  particular,  you  can  use  [10XhomalgIOMode[0m(  [3Xstr[0m,  "" ) to reset the effect of
  invoking [10XhomalgMode[0m.
  
        [3Xstr[0m | [3Xstr[0m (long form) | mode description                                                  
      -------------------------------------------------------------------------------------------
            |                 |                                                                   
        ""  |       ""        | the default mode, i.e. the communication protocol won't be visible
            |                 | ([10XhomalgIOMode[0m( ) is a short form for [10XhomalgIOMode[0m( "" ))          
            |                 |                                                                   
        "a" |      "all"      | combine the modes "debug" and "file"                              
            |                 |                                                                   
        "b" |     "basic"     | the same as "picto" + [10XhomalgMode[0m( "basic" )                       
            |                 |                                                                   
        "d" |     "debug"     | view the complete communication protocol                          
            |                 |                                                                   
        "f" |     "file"      | dump the communication protocol into a file with the name         
            |                 | [10XConcatenation[0m( "commands_file_of_", CAS, "_with_PID_", PID )      
            |                 |                                                                   
        "p" |     "picto"     | view the abbreviated communication protocol                       
            |                 | using the preassigned pictograms                                  
            |                 |                                                                   
      -------------------------------------------------------------------------------------------
  
  All  modes  other than the "default"-mode only set their specific values and
  leave  the  other  values  untouched,  which  allows  combining them to some
  extent.  This  also  means  that in order to get from one mode to a new mode
  (without  the  aim to combine them) one needs to reset to the "default"-mode
  first.
  [13XCaution[0m:
  
  --    In  case you choose one of the modes "file" or "all" you might want to
        set  the  global variable [10XHOMALG_IO.DoNotDeleteTemporaryFiles[0m := [10Xtrue[0m;
        this  is  only  important if during the computations some matrices get
        converted  via  files  (using  [10XConvertHomalgMatrixViaFile[0m), as reading
        these files will be part of the protocol!
  
  --    It   makes   sense   for  the  dumped  communication  protocol  to  be
        (re)executed  with  the  respective  external system, only in case the
        latter is deterministic (i.e. same-input-same-output).
  
  [4X-----------------------------  Code  -----------------------------[0X
    [4XInstallGlobalFunction( homalgIOMode,[0X
    [4X  function( arg )[0X
    [4X    local nargs, mode, s;[0X
    [4X    [0X
    [4X    nargs := Length( arg );[0X
    [4X    [0X
    [4X    if nargs = 0 or ( IsString( arg[1] ) and arg[1] = "" ) then[0X
    [4X        mode := "default";[0X
    [4X    elif IsString( arg[1] ) then	## now we know, the string is not empty[0X
    [4X        s := arg[1];[0X
    [4X        if LowercaseString( s{[1]} ) = "a" then[0X
    [4X            mode := "all";[0X
    [4X        elif LowercaseString( s{[1]} ) = "b" then[0X
    [4X            mode := "basic";[0X
    [4X        elif LowercaseString( s{[1]} ) = "d" then[0X
    [4X            mode := "debug";[0X
    [4X        elif LowercaseString( s{[1]} ) = "f" then[0X
    [4X            mode := "file";[0X
    [4X        elif LowercaseString( s{[1]} ) = "p" then[0X
    [4X            mode := "picto";[0X
    [4X        else[0X
    [4X            mode := "";[0X
    [4X        fi;[0X
    [4X    else[0X
    [4X        Error( "the first argument must be a string\n" );[0X
    [4X    fi;[0X
    [4X    [0X
    [4X    if mode = "default" then[0X
    [4X        ## reset to the default values[0X
    [4X        HOMALG_IO.color_display := false;[0X
    [4X        HOMALG_IO.show_banners := true;[0X
    [4X        HOMALG_IO.save_CAS_commands_to_file := false;[0X
    [4X        HOMALG_IO.DoNotDeleteTemporaryFiles := false;[0X
    [4X        HOMALG_IO.SaveHomalgMaximumBackStream := false;[0X
    [4X        HOMALG_IO.InformAboutCASystemsWithoutActiveRings := true;[0X
    [4X        SetInfoLevel( InfoHomalgToCAS, 1 );[0X
    [4X        homalgMode( );[0X
    [4X    elif mode = "all" then[0X
    [4X        homalgIOMode( "debug" );[0X
    [4X        homalgIOMode( "file" );[0X
    [4X    elif mode = "basic" then[0X
    [4X        HOMALG_IO.color_display := true;[0X
    [4X        HOMALG_IO.show_banners := true;[0X
    [4X        SetInfoLevel( InfoHomalgToCAS, 4 );[0X
    [4X        homalgMode( "basic" );	## use homalgIOMode( "basic", "" ) to reset[0X
    [4X    elif mode = "debug" then[0X
    [4X        HOMALG_IO.color_display := true;[0X
    [4X        HOMALG_IO.show_banners := true;[0X
    [4X        SetInfoLevel( InfoHomalgToCAS, 8 );[0X
    [4X        homalgMode( "debug" );	## use homalgIOMode( "debug", "" ) to reset[0X
    [4X    elif mode = "file" then[0X
    [4X        HOMALG_IO.save_CAS_commands_to_file := true;[0X
    [4X    elif mode = "picto" then[0X
    [4X        HOMALG_IO.color_display := true;[0X
    [4X        HOMALG_IO.show_banners := true;[0X
    [4X        SetInfoLevel( InfoHomalgToCAS, 4 );[0X
    [4X        homalgMode( "logic" );	## use homalgIOMode( "picto", "" ) to reset[0X
    [4X    fi;[0X
    [4X    [0X
    [4X    if nargs > 1 and IsString( arg[2] ) then[0X
    [4X        CallFuncList( homalgMode, arg{[ 2 .. nargs ]} );[0X
    [4X    fi;[0X
    [4X    [0X
    [4Xend );[0X
  [4X------------------------------------------------------------------[0X
  
  This is the part of the global function [10XhomalgSendBlocking[0m that controls the
  visibility of the communication.
  
  [4X-----------------------------  Code  -----------------------------[0X
    [4Xio_info_level := InfoLevel( InfoHomalgToCAS );[0X
    [4X[0X
    [4Xif not IsBound( pictogram ) then[0X
    [4X    pictogram := HOMALG_IO.Pictograms.unknown;[0X
    [4X    picto := pictogram;[0X
    [4Xelif io_info_level >= 3 then[0X
    [4X    picto := pictogram;[0X
    [4X    ## add colors to the pictograms[0X
    [4X    if pictogram = HOMALG_IO.Pictograms.ReducedEchelonForm and[0X
    [4X       IsBound( HOMALG_MATRICES.color_BOE ) then[0X
    [4X        pictogram := Concatenation( HOMALG_MATRICES.color_BOE, pictogram, "\033[0m" );[0X
    [4X    elif pictogram = HOMALG_IO.Pictograms.BasisOfModule and[0X
    [4X      IsBound( HOMALG_MATRICES.color_BOB ) then[0X
    [4X        pictogram := Concatenation( HOMALG_MATRICES.color_BOB, pictogram, "\033[0m" );[0X
    [4X    elif pictogram = HOMALG_IO.Pictograms.DecideZero and[0X
    [4X      IsBound( HOMALG_MATRICES.color_BOD ) then[0X
    [4X        pictogram := Concatenation( HOMALG_MATRICES.color_BOD, pictogram, "\033[0m" );[0X
    [4X    elif pictogram = HOMALG_IO.Pictograms.SyzygiesGenerators and[0X
    [4X      IsBound( HOMALG_MATRICES.color_BOH ) then[0X
    [4X        pictogram := Concatenation( HOMALG_MATRICES.color_BOH, pictogram, "\033[0m" );[0X
    [4X    elif pictogram = HOMALG_IO.Pictograms.BasisCoeff and[0X
    [4X      IsBound( HOMALG_MATRICES.color_BOC ) then[0X
    [4X        pictogram := Concatenation( HOMALG_MATRICES.color_BOC, pictogram, "\033[0m" );[0X
    [4X    elif pictogram = HOMALG_IO.Pictograms.DecideZeroEffectively and[0X
    [4X      IsBound( HOMALG_MATRICES.color_BOP ) then[0X
    [4X        pictogram := Concatenation( HOMALG_MATRICES.color_BOP, pictogram, "\033[0m" );[0X
    [4X    elif need_output or need_display then[0X
    [4X        pictogram := Concatenation( HOMALG_IO.Pictograms.color_need_output,[0X
    [4X                             pictogram, "\033[0m" );[0X
    [4X    else[0X
    [4X        pictogram := Concatenation( HOMALG_IO.Pictograms.color_need_command,[0X
    [4X                             pictogram, "\033[0m" );[0X
    [4X    fi;[0X
    [4Xelse[0X
    [4X    picto := pictogram;[0X
    [4Xfi;[0X
    [4X[0X
    [4Xif io_info_level >= 3 then[0X
    [4X    if ( io_info_level >= 7 and not need_display ) or io_info_level >= 8 then[0X
    [4X        ## print the pictogram, the prompt of the external system,[0X
    [4X        ## and the sent command[0X
    [4X        Info( InfoHomalgToCAS, 7, pictogram, " ", stream.prompt,[0X
    [4X              L{[ 1 .. Length( L ) - 1 ]} );[0X
    [4X    elif io_info_level >= 4 then[0X
    [4X        ## print the pictogram and the prompt of the external system[0X
    [4X        Info( InfoHomalgToCAS, 4, pictogram, " ", stream.prompt, "..." );[0X
    [4X    else[0X
    [4X        ## print the pictogram only[0X
    [4X        Info( InfoHomalgToCAS, 3, pictogram );[0X
    [4X    fi;[0X
    [4Xfi;[0X
  [4X------------------------------------------------------------------[0X
  
  
  [1X3.2 The Pictograms[0X
  
  [1X3.2-1 HOMALG_IO.Pictograms[0m
  
  [2X> HOMALG_IO.Pictograms_______________________________________[0Xglobal variable
  
  The record of pictograms is a component of the record [10XHOMALG_IO[0m.
  
  [4X-----------------------------  Code  -----------------------------[0X
    [4XPictograms := rec([0X
    [4X  [0X
    [4X  ##[0X
    [4X  ## colors:[0X
    [4X  ##[0X
    [4X  [0X
    [4X  ## pictogram color of a "need_command" or assignment operation:[0X
    [4X  color_need_command                      := "\033[1;33;44m",[0X
    [4X  [0X
    [4X  ## pictogram color of a "need_output" or "need_display" operation:[0X
    [4X  color_need_output                       := "\033[1;34;43m",[0X
    [4X  [0X
    [4X  ##[0X
    [4X  ## good morning computer algebra system:[0X
    [4X  ##[0X
    [4X  [0X
    [4X  ## initialize:[0X
    [4X  initialize                              := "ini",[0X
    [4X  [0X
    [4X  ## define macros:[0X
    [4X  define                                  := "def",[0X
    [4X  [0X
    [4X  ## get time:[0X
    [4X  time                                    := ":ms",[0X
    [4X  [0X
    [4X  ## memory usage:[0X
    [4X  memory                                  := "mem",[0X
    [4X  [0X
    [4X  ## unknown:[0X
    [4X  unknown                                 := "???",[0X
    [4X  [0X
    [4X  ##[0X
    [4X  ## external garbage collection:[0X
    [4X  ##[0X
    [4X  [0X
    [4X  ## delete a variable:[0X
    [4X  delete                                  := "xxx",[0X
    [4X  [0X
    [4X  ## delete serveral variables:[0X
    [4X  multiple_delete                         := "XXX",[0X
    [4X  [0X
    [4X  ## trigger the garbage collector:[0X
    [4X  garbage_collector                       := "grb",[0X
    [4X  [0X
    [4X  ##[0X
    [4X  ## create lists:[0X
    [4X  ##[0X
    [4X  [0X
    [4X  ## define a list:[0X
    [4X  CreateList                              := "lst",[0X
    [4X  [0X
    [4X  ##[0X
    [4X  ## create rings:[0X
    [4X  ##[0X
    [4X  [0X
    [4X  ## define a ring:[0X
    [4X  CreateHomalgRing                        := "R:=",[0X
    [4X  [0X
    [4X  ## get the names of the "variables" defining the ring:[0X
    [4X  variables                               := "var",[0X
    [4X  [0X
    [4X  ## define zero:[0X
    [4X  Zero                                    := "0:=",[0X
    [4X  [0X
    [4X  ## define one:[0X
    [4X  One                                     := "1:=",[0X
    [4X  [0X
    [4X  ## define minus one:[0X
    [4X  MinusOne                                := "-:=",[0X
    [4X  [0X
    [4X  ##[0X
    [4X  ## mandatory ring operations:[0X
    [4X  ##[0X
    [4X  [0X
    [4X  ## get the name of an element:[0X
    [4X  ## (important if the CAS pretty-prints ring elements,[0X
    [4X  ##  we need names that can be used as input!)[0X
    [4X  ## (install a method instead of a homalgTable entry)[0X
    [4X  homalgSetName                           := "\"a\"",[0X
    [4X  [0X
    [4X  ## a = 0 ?[0X
    [4X  IsZero                                  := "a=0",[0X
    [4X  [0X
    [4X  ## a = 1 ?[0X
    [4X  IsOne                                   := "a=1",[0X
    [4X  [0X
    [4X  ## substract two ring elements[0X
    [4X  ## (needed by SimplerEquivalentMatrix in case[0X
    [4X  ##  CopyRow/ColumnToIdentityMatrix are not defined):[0X
    [4X  Minus                                   := "a-b",[0X
    [4X  [0X
    [4X  ## divide the element a by the unit u[0X
    [4X  ## (needed by SimplerEquivalentMatrix in case[0X
    [4X  ##  DivideEntryByUnit is not defined):[0X
    [4X  DivideByUnit                            := "a/u",[0X
    [4X  [0X
    [4X  ## important ring operations:[0X
    [4X  ## (important for performance since existing[0X
    [4X  ##  fallback methods cause a lot of traffic):[0X
    [4X  [0X
    [4X  ## is u a unit?[0X
    [4X  ## (mainly needed by the fallback methods for matrices, see below):[0X
    [4X  IsUnit                                  := "?/u",[0X
    [4X  [0X
    [4X  ##[0X
    [4X  ## optional ring operations:[0X
    [4X  ##[0X
    [4X  [0X
    [4X  ## add two ring elements:[0X
    [4X  Sum                                     := "a+b",[0X
    [4X  [0X
    [4X  ## multiply two ring elements:[0X
    [4X  Product                                 := "a*b",[0X
    [4X  [0X
    [4X  ## the (greatest) common divisor:[0X
    [4X  Gcd                                     := "gcd",[0X
    [4X  [0X
    [4X  ## cancel the (greatest) common divisor:[0X
    [4X  CancelGcd                               := "ccd",[0X
    [4X  [0X
    [4X  ## random polynomial:[0X
    [4X  RandomPol                               := "rpl",[0X
    [4X  [0X
    [4X  ## degree of a multivariate polynomial[0X
    [4X  DegreeOfRingElement                     := "deg",[0X
    [4X  [0X
    [4X  ## is irreducible:[0X
    [4X  IsIrreducible                           := "irr",[0X
    [4X  [0X
    [4X  ##[0X
    [4X  ## create matrices:[0X
    [4X  ##[0X
    [4X  [0X
    [4X  ## define a matrix:[0X
    [4X  HomalgMatrix                            := "A:=",[0X
    [4X  [0X
    [4X  ## copy a matrix:[0X
    [4X  CopyMatrix                              := "A>A",[0X
    [4X  [0X
    [4X  ## load a matrix from file:[0X
    [4X  LoadHomalgMatrixFromFile                := "A<<",[0X
    [4X  [0X
    [4X  ## save a matrix to file:[0X
    [4X  SaveHomalgMatrixToFile                  := "A>>",[0X
    [4X  [0X
    [4X  ## get a matrix entry as a string:[0X
    [4X  MatElm                  := "<ij",[0X
    [4X  [0X
    [4X  ## set a matrix entry from a string:[0X
    [4X  SetMatElm                  := ">ij",[0X
    [4X  [0X
    [4X  ## add to a matrix entry from a string:[0X
    [4X  AddToMatElm                := "+ij",[0X
    [4X  [0X
    [4X  ## get a list of the matrix entries as a string:[0X
    [4X  GetListOfHomalgMatrixAsString           := "\"A\"",[0X
    [4X  [0X
    [4X  ## get a listlist of the matrix entries as a string:[0X
    [4X  GetListListOfHomalgMatrixAsString       := "\"A\"",[0X
    [4X  [0X
    [4X  ## get a "sparse" list of the matrix entries as a string:[0X
    [4X  GetSparseListOfHomalgMatrixAsString     := ".A.",[0X
    [4X  [0X
    [4X  ## assign a "sparse" list of matrix entries to a variable:[0X
    [4X  sparse                                  := "spr",[0X
    [4X  [0X
    [4X  ##[0X
    [4X  ## mandatory matrix operations:[0X
    [4X  ##[0X
    [4X  [0X
    [4X  ## test if a matrix is the zero matrix:[0X
    [4X  ## CAUTION: the external system must be able to check[0X
    [4X  ##          if the matrix is zero modulo possible ring relations[0X
    [4X  ##          only known to the external system![0X
    [4X  IsZeroMatrix                            := "A=0",[0X
    [4X  [0X
    [4X  ## number of rows:[0X
    [4X  NrRows                                  := "#==",[0X
    [4X  [0X
    [4X  ## number of columns:[0X
    [4X  NrColumns                               := "#||",[0X
    [4X  [0X
    [4X  ## determinant of a matrix over a (commutative) ring:[0X
    [4X  Determinant                             := "det",[0X
    [4X  [0X
    [4X  ## create a zero matrix:[0X
    [4X  ZeroMatrix                              := "(0)",[0X
    [4X  [0X
    [4X  ## create a initial zero matrix:[0X
    [4X  InitialMatrix                           := "[0]",[0X
    [4X  [0X
    [4X  ## create an identity matrix:[0X
    [4X  IdentityMatrix                          := "(1)",[0X
    [4X  [0X
    [4X  ## create an initial identity matrix:[0X
    [4X  InitialIdentityMatrix                   := "[1]",[0X
    [4X  [0X
    [4X  ## "transpose" a matrix (with "the" involution of the ring):[0X
    [4X  Involution                              := "A^*",[0X
    [4X  [0X
    [4X  ## get certain rows of a matrix:[0X
    [4X  CertainRows                             := "===",[0X
    [4X  [0X
    [4X  ## get certain columns of a matrix:[0X
    [4X  CertainColumns                          := "|||",[0X
    [4X  [0X
    [4X  ## stack to matrices vertically:[0X
    [4X  UnionOfRows                             := "A_B",[0X
    [4X  [0X
    [4X  ## glue to matrices horizontally:[0X
    [4X  UnionOfColumns                          := "A|B",[0X
    [4X  [0X
    [4X  ## create a block diagonal matrix:[0X
    [4X  DiagMat                                 := "A\\B",[0X
    [4X  [0X
    [4X  ## the Kronecker (tensor) product of two matrices:[0X
    [4X  KroneckerMat                            := "AoB",[0X
    [4X  [0X
    [4X  ## multiply a matrix with a ring element:[0X
    [4X  MulMat                                  := "a*A",[0X
    [4X  [0X
    [4X  ## add two matrices:[0X
    [4X  AddMat                                  := "A+B",[0X
    [4X  [0X
    [4X  ## substract two matrices:[0X
    [4X  SubMat                                  := "A-B",[0X
    [4X  [0X
    [4X  ## multiply two matrices:[0X
    [4X  Compose                                 := "A*B",[0X
    [4X  [0X
    [4X  ## pullback a matrix by a ring map:[0X
    [4X  Pullback                                := "pbk",[0X
    [4X  [0X
    [4X  ##[0X
    [4X  ## important matrix operations:[0X
    [4X  ## (important for performance since existing[0X
    [4X  ##  fallback methods cause a lot of traffic):[0X
    [4X  ##[0X
    [4X  [0X
    [4X  ## test if two matrices are equal:[0X
    [4X  ## CAUTION: the external system must be able to check[0X
    [4X  ##          equality of the two matrices modulo possible ring relations[0X
    [4X  ##          only known to the external system![0X
    [4X  AreEqualMatrices                        := "A=B",[0X
    [4X  [0X
    [4X  ## test if a matrix is the identity matrix:[0X
    [4X  IsIdentityMatrix                        := "A=1",[0X
    [4X  [0X
    [4X  ## test if a matrix is diagonal (needed by the display method):[0X
    [4X  IsDiagonalMatrix                        := "A=\\",[0X
    [4X  [0X
    [4X  ## get the positions of the zero rows:[0X
    [4X  ZeroRows                                := "0==",[0X
    [4X  [0X
    [4X  ## get the positions of the zero columns:[0X
    [4X  ZeroColumns                             := "0||",[0X
    [4X  [0X
    [4X  ## get "column-independent" unit positions[0X
    [4X  ## (needed by ReducedBasisOfModule):[0X
    [4X  GetColumnIndependentUnitPositions       := "ciu",[0X
    [4X  [0X
    [4X  ## get "row-independent" unit positions[0X
    [4X  ## (needed by ReducedBasisOfModule):[0X
    [4X  GetRowIndependentUnitPositions          := "riu",[0X
    [4X  [0X
    [4X  ## get the position of the "first" unit in the matrix[0X
    [4X  ## (needed by SimplerEquivalentMatrix):[0X
    [4X  GetUnitPosition                         := "gup",[0X
    [4X  [0X
    [4X  ## position of the first non-zero entry per row[0X
    [4X  PositionOfFirstNonZeroEntryPerRow       := "fnr",[0X
    [4X  [0X
    [4X  ## position of the first non-zero entry per column[0X
    [4X  PositionOfFirstNonZeroEntryPerColumn    := "fnc",[0X
    [4X  [0X
    [4X  ## indicator matrix of non-zero entries[0X
    [4X  IndicatorMatrixOfNonZeroEntries         := "<>0",[0X
    [4X  [0X
    [4X  ## transposed matrix:[0X
    [4X  TransposedMatrix                        := "^tr",[0X
    [4X  [0X
    [4X  ## divide an entry of a matrix by a unit[0X
    [4X  ## (needed by SimplerEquivalentMatrix in case[0X
    [4X  ##  DivideRow/ColumnByUnit are not defined):[0X
    [4X  DivideEntryByUnit                       := "ij/",[0X
    [4X  [0X
    [4X  ## divide a row by a unit[0X
    [4X  ## (needed by SimplerEquivalentMatrix):[0X
    [4X  DivideRowByUnit                         := "-/u",[0X
    [4X  [0X
    [4X  ## divide a column by a unit[0X
    [4X  ## (needed by SimplerEquivalentMatrix):[0X
    [4X  DivideColumnByUnit                      := "|/u",[0X
    [4X  [0X
    [4X  ## divide a row by a unit[0X
    [4X  ## (needed by SimplerEquivalentMatrix):[0X
    [4X  CopyRowToIdentityMatrix                 := "->-",[0X
    [4X  [0X
    [4X  ## divide a column by a unit[0X
    [4X  ## (needed by SimplerEquivalentMatrix):[0X
    [4X  CopyColumnToIdentityMatrix              := "|>|",[0X
    [4X  [0X
    [4X  ## set a column (except a certain row) to zero[0X
    [4X  ## (needed by SimplerEquivalentMatrix):[0X
    [4X  SetColumnToZero                         := "|=0",[0X
    [4X  [0X
    [4X  ## get the positions of the rows with a single one[0X
    [4X  ## (needed by SimplerEquivalentMatrix):[0X
    [4X  GetCleanRowsPositions                   := "crp",[0X
    [4X  [0X
    [4X  ## convert a single row matrix into a matrix[0X
    [4X  ## with specified number of rows/columns[0X
    [4X  ## (needed by the display methods for homomorphisms):[0X
    [4X  ConvertRowToMatrix                      := "-%A",[0X
    [4X  [0X
    [4X  ## convert a single column matrix into a matrix[0X
    [4X  ## with specified number of rows/columns[0X
    [4X  ## (needed by the display methods for homomorphisms):[0X
    [4X  ConvertColumnToMatrix                   := "|%A",[0X
    [4X  [0X
    [4X  ## convert a matrix into a single row matrix:[0X
    [4X  ConvertMatrixToRow                      := "A%-",[0X
    [4X  [0X
    [4X  ## convert a matrix into a single column matrix:[0X
    [4X  ConvertMatrixToColumn                   := "A%|",[0X
    [4X  [0X
    [4X  ##[0X
    [4X  ## basic matrix operations:[0X
    [4X  ##[0X
    [4X  [0X
    [4X  ## compute a (r)educed (e)chelon (f)orm:[0X
    [4X  ReducedEchelonForm                      := "ref",[0X
    [4X  [0X
    [4X  ## compute a "(bas)is" of a given set of module elements:[0X
    [4X  BasisOfModule                           := "bas",[0X
    [4X  [0X
    [4X  ## compute a reduced "(Bas)is" of a given set of module elements:[0X
    [4X  ReducedBasisOfModule                    := "Bas",[0X
    [4X  [0X
    [4X  ## (d)e(c)ide the ideal/submodule membership problem,[0X
    [4X  ## i.e. if an element is (0) modulo the ideal/submodule:[0X
    [4X  DecideZero                              := "dc0",[0X
    [4X  [0X
    [4X  ## compute a generating set of (syz)ygies:[0X
    [4X  SyzygiesGenerators                      := "syz",[0X
    [4X  [0X
    [4X  ## compute a generating set of reduced (Syz)ygies:[0X
    [4X  ReducedSyzygiesGenerators               := "Syz",[0X
    [4X  [0X
    [4X  ## compute a (R)educed (E)chelon (F)orm[0X
    [4X  ## together with the matrix of coefficients:[0X
    [4X  ReducedEchelonFormC                     := "REF",[0X
    [4X  [0X
    [4X  ## compute a "(BAS)is" of a given set of module elements[0X
    [4X  ## together with the matrix of coefficients:[0X
    [4X  BasisCoeff                              := "BAS",[0X
    [4X  [0X
    [4X  ## (D)e(C)ide the ideal/submodule membership problem,[0X
    [4X  ## i.e. write an element effectively as (0) modulo the ideal/submodule:[0X
    [4X  DecideZeroEffectively                   := "DC0",[0X
    [4X  [0X
    [4X  ##[0X
    [4X  ## optional matrix operations:[0X
    [4X  ##[0X
    [4X  [0X
    [4X  ## Hilbert-Poincare series of a module:[0X
    [4X  HilbertPoincareSeries                   := "hps",[0X
    [4X  [0X
    [4X  ## Hilbert polynomial of a module:[0X
    [4X  HilbertPolynomial                       := "hil",[0X
    [4X  [0X
    [4X  ## affine dimension of a module:[0X
    [4X  AffineDimension                         := "dim",[0X
    [4X  [0X
    [4X  ## affine degree of a module:[0X
    [4X  AffineDegree                            := "adg",[0X
    [4X  [0X
    [4X  ## the constant term of the hilbert polynomial:[0X
    [4X  ConstantTermOfHilbertPolynomial         := "P_0",[0X
    [4X  [0X
    [4X  ## primary decomposition:[0X
    [4X  PrimaryDecomposition                    := "YxZ",[0X
    [4X  [0X
    [4X  ## eliminate variables:[0X
    [4X  Eliminate                               := "eli",[0X
    [4X  [0X
    [4X  LeadingModule                           := "led",[0X
    [4X  [0X
    [4X  ## matrix of symbols:[0X
    [4X  MatrixOfSymbols                         := "smb",[0X
    [4X  [0X
    [4X  ## leading module:[0X
    [4X  ## coefficients:[0X
    [4X  Coefficients                            := "cfs",[0X
    [4X  [0X
    [4X  ##[0X
    [4X  ## optional module operations:[0X
    [4X  ##[0X
    [4X  [0X
    [4X  ## compute a better equivalent matrix[0X
    [4X  ## (field -> row+col Gauss, PIR -> Smith, Dedekind domain -> Krull, etc ...):[0X
    [4X  BestBasis                               := "(\\)",[0X
    [4X  [0X
    [4X  ## compute elementary divisors:[0X
    [4X  ElementaryDivisors                      := "div",[0X
    [4X  [0X
    [4X  ##[0X
    [4X  ## for the eye:[0X
    [4X  ##[0X
    [4X  [0X
    [4X  ## display objects:[0X
    [4X  Display                                 := "dsp",[0X
    [4X  [0X
    [4X  ## the LaTeX code of the mathematical entity:[0X
    [4X  homalgLaTeX                             := "TeX",[0X
    [4X  [0X
    [4X)[0X
  [4X------------------------------------------------------------------[0X
  
