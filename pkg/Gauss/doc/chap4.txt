  
  [1X4 Gaussian Algorithms[0X
  
  
  [1X4.1 A list of the available algorithms[0X
  
  As  decribed earlier, the main functions of [5XGauss[0m are [2XEchelonMat[0m ([14X4.2-1[0m) and
  [2XEchelonMatTransformation[0m       ([14X4.2-2[0m),      [2XReduceMat[0m      ([14X4.2-3[0m)      and
  [2XReduceMatTransformation[0m  ([14X4.2-4[0m),  [2XKernelMat[0m  ([14X4.2-5[0m) and, additionally [2XRank[0m
  ([14X4.2-6[0m). These are all documented in the next section, but of course rely on
  specific  algorithms depending on the base ring of the matrix. These are not
  fully  documented but it should be very easy to find out how they work based
  on the documentation of the main functions.
  
        EchelonMat                                                                        
                                   Field:            [10XEchelonMatDestructive[0m                
                                   Ring:             [10XHermiteMatDestructive[0m                
        EchelonMatTransformation                                                          
                                   Field:            [10XEchelonMatTransformationDestructive[0m  
                                   Ring:             [10XHermiteMatTransformationDestructive[0m  
        ReduceMat                                                                         
                                   Field:            [10XReduceMatWithEchelonMat[0m              
                                   Ring:             [10XReduceMatWithHermiteMat[0m              
        ReduceMatTransformation                                                           
                                   Field:            [10XReduceMatWithEchelonMatTransformation[0m
                                   Ring:             [10XReduceMatWithHermiteMatTransformation[0m
        KernelMat                                                                         
                                   Field:            [10XKernelEchelonMatDestructive[0m          
                                   Ring:             [10XKernelHermiteMatDestructive[0m          
        Rank                                                                              
                                   Field (dense):    [10XRank[0m ([5XGAP[0m method)                    
                                   Field (sparse):   [10XRankDestructive[0m                      
                                   GF(2) (sparse):   [10XRankOfIndicesListList[0m                
                                   Ring:             n.a.                                 
  
  
  [1X4.2 Methods and Functions for [5XGauss[1Xian algorithms[0X
  
  [1X4.2-1 EchelonMat[0m
  
  [2X> EchelonMat( [0X[3Xmat[0X[2X ) __________________________________________________[0Xmethod
  [6XReturns:[0X  a  record  that  contains information about an echelonized form of
            the matrix [3Xmat[0m.
  
            The components of this record are
  
            `vectors'
  
            the  reduced  row echelon / hermite form of the matrix [3Xmat[0m without
            zero rows.
  
            `heads'
  
            list  that contains at position <i>, if nonzero, the number of the
            row for that the pivot element is in column <i>.
  
  computes  the  reduced row echelon form RREF of a dense or sparse matrix [3Xmat[0m
  over a field, or the hermite form of a sparse matrix [3Xmat[0m over â„¤ / < p^n >.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> M := [[0,0,0,1,0],[0,1,1,1,1],[1,1,1,1,0]] * One( GF(2) );;[0X
    [4Xgap> Display(M);[0X
    [4X . . . 1 .[0X
    [4X . 1 1 1 1[0X
    [4X 1 1 1 1 .[0X
    [4Xgap> EchelonMat(M);[0X
    [4Xrec( heads := [ 1, 2, 0, 3, 0 ],[0X
    [4X  vectors := [ <a GF2 vector of length 5>, <a GF2 vector of length 5>,[0X
    [4X      <a GF2 vector of length 5> ] )[0X
    [4Xgap> Display( last.vectors );[0X
    [4X 1 . . . 1[0X
    [4X . 1 1 . 1[0X
    [4X . . . 1 .[0X
    [4Xgap> SM := SparseMatrix( M );[0X
    [4X<a 3 x 5 sparse matrix over GF(2)>[0X
    [4Xgap> EchelonMat( SM );[0X
    [4Xrec( heads := [ 1, 2, 0, 3, 0 ], vectors := <a 3 x 5 sparse matrix over GF([0X
    [4X    2)> )[0X
    [4Xgap> Display(last.vectors);[0X
    [4X 1 . . . 1[0X
    [4X . 1 1 . 1[0X
    [4X . . . 1 .[0X
    [4Xgap> SM := SparseMatrix( [[7,4,5],[0,0,6],[0,4,4]] * One( Integers mod 8 ) );[0X
    [4X<a 3 x 3 sparse matrix over (Integers mod 8)>[0X
    [4Xgap> Display( SM );[0X
    [4X 7 4 5[0X
    [4X . . 6[0X
    [4X . 4 4[0X
    [4Xgap> EchelonMat( SM );[0X
    [4Xrec( heads := [ 1, 2, 3 ],[0X
    [4X  vectors := <a 3 x 3 sparse matrix over (Integers mod 8)> )[0X
    [4Xgap> Display( last.vectors );[0X
    [4X 1 . 1[0X
    [4X . 4 .[0X
    [4X . . 2      [0X
  [4X------------------------------------------------------------------[0X
  
  [1X4.2-2 EchelonMatTransformation[0m
  
  [2X> EchelonMatTransformation( [0X[3Xmat[0X[2X ) ____________________________________[0Xmethod
  [6XReturns:[0X  a  record  that  contains information about an echelonized form of
            the matrix [3Xmat[0m.
  
            The components of this record are
  
            `vectors'
  
            the  reduced  row echelon / hermite form of the matrix [3Xmat[0m without
            zero rows.
  
            `heads'
  
            list  that contains at position <i>, if nonzero, the number of the
            row for that the pivot element is in column <i>.
  
            `coeffs'
  
            the transformation matrix needed to obtain the RREF from [3Xmat[0m.
  
            `relations'
  
            the  kernel of the matrix [3Xmat[0m if RingOfDefinition([3Xmat[0m) is a field.
            Otherwise  these  are only the obvious row relations of [3Xmat[0m, there
            might be more kernel vectors - --> [2XKernelMat[0m ([14X4.2-5[0m).
  
  computes  the  reduced row echelon form RREF of a dense or sparse matrix [3Xmat[0m
  over  a  field, or the hermite form of a sparse matrix [3Xmat[0m over â„¤ / < p^n >.
  In  either  case, the transformation matrix T is calculated as the row union
  of `coeffs' and `relations'.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> M := [[1,0,1],[1,1,0],[1,0,1],[1,1,0],[1,1,1]] * One( GF(2) );;[0X
    [4Xgap> EchelonMatTransformation( M );[0X
    [4Xrec( heads := [ 1, 2, 3 ],[0X
    [4X  vectors := [ <a GF2 vector of length 3>, <a GF2 vector of length 3>,[0X
    [4X      <a GF2 vector of length 3> ],[0X
    [4X  coeffs := [ <a GF2 vector of length 5>, <a GF2 vector of length 5>,[0X
    [4X      <a GF2 vector of length 5> ],[0X
    [4X  relations := [ <a GF2 vector of length 5>, <a GF2 vector of length 5> ] )[0X
    [4Xgap> Display(last.vectors);[0X
    [4X 1 . .[0X
    [4X . 1 .[0X
    [4X . . 1[0X
    [4Xgap> Display(last.coeffs);[0X
    [4X 1 1 . . 1[0X
    [4X 1 . . . 1[0X
    [4X . 1 . . 1[0X
    [4Xgap> Display(last.relations);[0X
    [4X 1 . 1 . .[0X
    [4X . 1 . 1 .[0X
    [4Xgap> Display( Concatenation( last.coeffs, last.relations ) * M );[0X
    [4X 1 . .[0X
    [4X . 1 .[0X
    [4X . . 1[0X
    [4X . . .[0X
    [4X . . .[0X
    [4Xgap> SM := SparseMatrix( M );[0X
    [4X<a 5 x 3 sparse matrix over GF(2)>[0X
    [4Xgap> EchelonMatTransformation( SM );[0X
    [4Xrec( heads := [ 1, 2, 3 ], vectors := <a 3 x 3 sparse matrix over GF(2)>,[0X
    [4X  coeffs := <a 3 x 5 sparse matrix over GF(2)>,[0X
    [4X  relations := <a 2 x 5 sparse matrix over GF(2)> )[0X
    [4Xgap> Display(last.vectors);[0X
    [4X 1 . .[0X
    [4X . 1 .[0X
    [4X . . 1[0X
    [4Xgap> Display(last.coeffs);[0X
    [4X 1 1 . . 1[0X
    [4X 1 . . . 1[0X
    [4X . 1 . . 1[0X
    [4Xgap> Display(last.relations);[0X
    [4X 1 . 1 . .[0X
    [4X . 1 . 1 .[0X
    [4Xgap> Display( UnionOfRows( last.coeffs, last.relations ) * SM );[0X
    [4X 1 . .[0X
    [4X . 1 .[0X
    [4X . . 1[0X
    [4X . . .[0X
    [4X . . .[0X
  [4X------------------------------------------------------------------[0X
  
  [1X4.2-3 ReduceMat[0m
  
  [2X> ReduceMat( [0X[3XA, B[0X[2X ) __________________________________________________[0Xmethod
  [6XReturns:[0X  a  record  with  a  single  component  `reduced_matrix' := M. M is
            created  by  reducing [3XA[0m with [3XB[0m, where [3XB[0m must be in Echelon/Hermite
            form. M will have the same dimensions as [3XA[0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> M := [[0,0,0,1,0],[0,1,1,1,1],[1,1,1,1,0]] * One( GF(2) );;[0X
    [4Xgap> Display(M);[0X
    [4X . . . 1 .[0X
    [4X . 1 1 1 1[0X
    [4X 1 1 1 1 .[0X
    [4Xgap> N := [[1,1,0,0,0],[0,0,1,0,1]] * One( GF(2) );;[0X
    [4Xgap> Display(N);[0X
    [4X 1 1 . . .[0X
    [4X . . 1 . 1[0X
    [4Xgap> ReduceMat(M,N);[0X
    [4Xrec([0X
    [4X  reduced_matrix := [ <a GF2 vector of length 5>, <a GF2 vector of length 5>,[0X
    [4X      <a GF2 vector of length 5> ] )[0X
    [4Xgap> Display(last.reduced_matrix);[0X
    [4X . . . 1 .[0X
    [4X . 1 . 1 .[0X
    [4X . . . 1 1[0X
    [4Xgap> SM := SparseMatrix(M); SN := SparseMatrix(N);[0X
    [4X<a 3 x 5 sparse matrix over GF(2)>[0X
    [4X<a 2 x 5 sparse matrix over GF(2)>[0X
    [4Xgap> ReduceMat(SM,SN);[0X
    [4Xrec( reduced_matrix := <a 3 x 5 sparse matrix over GF(2)> )[0X
    [4Xgap> Display(last.reduced_matrix);[0X
    [4X . . . 1 .[0X
    [4X . 1 . 1 .[0X
    [4X . . . 1 1[0X
  [4X------------------------------------------------------------------[0X
  
  [1X4.2-4 ReduceMatTransformation[0m
  
  [2X> ReduceMatTransformation( [0X[3XA, B[0X[2X ) ____________________________________[0Xmethod
  [6XReturns:[0X  a  record  with a component `reduced_matrix' := M. M is created by
            reducing [3XA[0m with [3XB[0m, where [3XB[0m must be in Echelon/Hermite form. M will
            have  the  same  dimensions  as  [3XA[0m. In addition to the (identical)
            output  as  ReduceMat  this  record  also  includes  the component
            `transformation', which stores the row operations that were needed
            to  reduce  [3XA[0m  with  [3XB[0m.  This differs from "normal" transformation
            matrices  because  only  rows of [3XB[0m had to be moved. Therefore, the
            transformation matrix solves M = A + T * B.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> M := [[0,0,0,1,0],[0,1,1,1,1],[1,1,1,1,0]] * One( GF(2) );;[0X
    [4Xgap> Display(M);[0X
    [4X . . . 1 .[0X
    [4X . 1 1 1 1[0X
    [4X 1 1 1 1 .[0X
    [4Xgap> N := [[1,1,0,0,0],[0,0,1,0,1]] * One( GF(2) );;[0X
    [4Xgap> Display(N);[0X
    [4X 1 1 . . .[0X
    [4X . . 1 . 1[0X
    [4Xgap> ReduceMatTransformation(M,N);[0X
    [4Xrec([0X
    [4X  reduced_matrix := [ <a GF2 vector of length 5>, <a GF2 vector of length 5>,[0X
    [4X      <a GF2 vector of length 5> ],[0X
    [4X  transformation := [ <a GF2 vector of length 2>, <a GF2 vector of length 2>,[0X
    [4X      <a GF2 vector of length 2> ] )[0X
    [4Xgap> Display(last.reduced_matrix);[0X
    [4X . . . 1 .[0X
    [4X . 1 . 1 .[0X
    [4X . . . 1 1[0X
    [4Xgap> Display(last.transformation);[0X
    [4X . .[0X
    [4X . 1[0X
    [4X 1 1[0X
    [4Xgap> Display( M + last.transformation * N );[0X
    [4X . . . 1 .[0X
    [4X . 1 . 1 .[0X
    [4X . . . 1 1 [0X
    [4Xgap> SM := SparseMatrix(M); SN := SparseMatrix(N);[0X
    [4X<a 3 x 5 sparse matrix over GF(2)>[0X
    [4X<a 2 x 5 sparse matrix over GF(2)>[0X
    [4Xgap> ReduceMatTransformation(SM,SN);[0X
    [4Xrec( reduced_matrix := <a 3 x 5 sparse matrix over GF(2)>,[0X
    [4X  transformation := <a 3 x 2 sparse matrix over GF(2)> )[0X
    [4Xgap> Display(last.reduced_matrix);[0X
    [4X . . . 1 .[0X
    [4X . 1 . 1 .[0X
    [4X . . . 1 1[0X
    [4Xgap> Display(last.transformation);[0X
    [4X . .[0X
    [4X . 1[0X
    [4X 1 1[0X
    [4Xgap> Display( SM + last.transformation * SN );[0X
    [4X . . . 1 .[0X
    [4X . 1 . 1 .[0X
    [4X . . . 1 1[0X
  [4X------------------------------------------------------------------[0X
  
  [1X4.2-5 KernelMat[0m
  
  [2X> KernelMat( [0X[3XM[0X[2X ) ___________________________________________________[0Xfunction
  [6XReturns:[0X  a record with a single component `relations'.
  
  If   [3XM[0m   is   a   matrix   over   a   field  this  is  the  same  output  as
  [2XEchelonMatTransformation[0m  ([14X4.2-2[0m) provides in the `relations' component, but
  with  less  memory  and CPU usage. If the base ring of [3XM[0m is a non-field, the
  Kernel might have additional generators, which are added to the output.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> M := [[2,1],[0,2]];[0X
    [4X[ [ 2, 1 ], [ 0, 2 ] ][0X
    [4Xgap> SM := SparseMatrix( M * One( GF(3) ) );[0X
    [4X<a 2 x 2 sparse matrix over GF(3)>[0X
    [4Xgap> KernelMat(SM);[0X
    [4Xrec( relations := <a 0 x 2 sparse matrix over GF(3)> )[0X
    [4Xgap> SN := SparseMatrix( M * One( Integers mod 4 ) );[0X
    [4X<a 2 x 2 sparse matrix over (Integers mod 4)>[0X
    [4Xgap> KernelMat(SN);[0X
    [4Xrec( relations := <a 1 x 2 sparse matrix over (Integers mod 4)> )[0X
    [4Xgap> Display(last.relations);[0X
    [4X 2 1[0X
  [4X------------------------------------------------------------------[0X
  
  [1X4.2-6 Rank[0m
  
  [2X> Rank( [0X[3Xsm[, boundary][0X[2X ) _____________________________________________[0Xmethod
  [6XReturns:[0X  the rank of the sparse matrix [3Xsm[0m. Only works for fields.
  
  Computes  the  rank of a sparse matrix. If the optional argument [3Xboundary[0m is
  provided,  some  algorithms  take  into  account  the  fact that Rank([3Xsm[0m) <=
  [3Xboundary[0m, thus possibly terminating earlier.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> M := SparseDiagMat( ListWithIdenticalEntries( 10,[0X
    [4X>         SparseMatrix( [[1,1],[1,1]] * One( GF(5) ) ) ) );[0X
    [4X<a 20 x 20 sparse matrix over GF(5)>[0X
    [4Xgap> Display(M);[0X
    [4X 1 1 . . . . . . . . . . . . . . . . . .[0X
    [4X 1 1 . . . . . . . . . . . . . . . . . .[0X
    [4X . . 1 1 . . . . . . . . . . . . . . . .[0X
    [4X . . 1 1 . . . . . . . . . . . . . . . .[0X
    [4X . . . . 1 1 . . . . . . . . . . . . . .[0X
    [4X . . . . 1 1 . . . . . . . . . . . . . .[0X
    [4X . . . . . . 1 1 . . . . . . . . . . . .[0X
    [4X . . . . . . 1 1 . . . . . . . . . . . .[0X
    [4X . . . . . . . . 1 1 . . . . . . . . . .[0X
    [4X . . . . . . . . 1 1 . . . . . . . . . .[0X
    [4X . . . . . . . . . . 1 1 . . . . . . . .[0X
    [4X . . . . . . . . . . 1 1 . . . . . . . .[0X
    [4X . . . . . . . . . . . . 1 1 . . . . . .[0X
    [4X . . . . . . . . . . . . 1 1 . . . . . .[0X
    [4X . . . . . . . . . . . . . . 1 1 . . . .[0X
    [4X . . . . . . . . . . . . . . 1 1 . . . .[0X
    [4X . . . . . . . . . . . . . . . . 1 1 . .[0X
    [4X . . . . . . . . . . . . . . . . 1 1 . .[0X
    [4X . . . . . . . . . . . . . . . . . . 1 1[0X
    [4X . . . . . . . . . . . . . . . . . . 1 1[0X
    [4Xgap> Rank(M);[0X
    [4X10[0X
  [4X------------------------------------------------------------------[0X
  
