% generated by GAPDoc2LaTeX from XML source (Frank Luebeck)
\documentclass[a4paper,11pt]{report}
\usepackage{a4wide}
\sloppy
\pagestyle{myheadings}
\usepackage{amssymb}
\usepackage[utf8]{inputenc}
\usepackage{makeidx}
\makeindex
\usepackage{color}
\definecolor{DarkOlive}{rgb}{0.1047,0.2412,0.0064}
\definecolor{FireBrick}{rgb}{0.5812,0.0074,0.0083}
\definecolor{RoyalBlue}{rgb}{0.0236,0.0894,0.6179}
\definecolor{RoyalGreen}{rgb}{0.0236,0.6179,0.0894}
\definecolor{RoyalRed}{rgb}{0.6179,0.0236,0.0894}
\definecolor{LightBlue}{rgb}{0.8544,0.9511,1.0000}
\definecolor{Black}{rgb}{0.0,0.0,0.0}
\definecolor{FuncColor}{rgb}{1.0,0.0,0.0}
%% strange name because of pdflatex bug:
\definecolor{Chapter }{rgb}{0.0,0.0,1.0}

\usepackage{fancyvrb}

\usepackage{pslatex}

\usepackage[pdftex=true,
        a4paper=true,bookmarks=false,pdftitle={Written with GAPDoc},
        pdfcreator={LaTeX with hyperref package / GAPDoc},
        colorlinks=true,backref=page,breaklinks=true,linkcolor=RoyalBlue,
        citecolor=RoyalGreen,filecolor=RoyalRed,
        urlcolor=RoyalRed,pagecolor=RoyalBlue]{hyperref}

% write page numbers to a .pnr log file for online help
\newwrite\pagenrlog
\immediate\openout\pagenrlog =\jobname.pnr
\immediate\write\pagenrlog{PAGENRS := [}
\newcommand{\logpage}[1]{\protect\write\pagenrlog{#1, \thepage,}}
%% were never documented, give conflicts with some additional packages


\newcommand{\GAP}{\textsf{GAP}}

%% nicer description environments, allows long labels
\usepackage{enumitem}
\setdescription{style=nextline}

\begin{document}

\logpage{[ 0, 0, 0 ]}
\begin{titlepage}
\begin{center}{\Huge \textbf{\textsf{LocalizeRingForHomalg}\mbox{}}}\\[1cm]
\hypersetup{pdftitle=\textsf{LocalizeRingForHomalg}}
\markright{\scriptsize \mbox{}\hfill \textsf{LocalizeRingForHomalg} \hfill\mbox{}}
{\Large \textbf{Localize Commutative \textsf{homalg} Rings at Maximal Ideals\mbox{}}}\\[1cm]
{Version 2012.05.27\mbox{}}\\[1cm]
{September 2011\mbox{}}\\[1cm]
\mbox{}\\[2cm]
{\large \textbf{Mohamed Barakat\\
    \mbox{}}}\\
{\large \textbf{Markus Lange-Hegermann\\
    \mbox{}}}\\
\hypersetup{pdfauthor=Mohamed Barakat\\
    ; Markus Lange-Hegermann\\
    }
\mbox{}\\[2cm]
\begin{minipage}{12cm}\noindent
 This manual is best viewed as an \textsc{HTML} document. The latest version is available \textsc{online} at: \\
\\
 \href{http://homalg.math.rwth-aachen.de/~markus/LocalizeRingForHomalg/chap0.html} {\texttt{http://homalg.math.rwth-aachen.de/\texttt{\symbol{126}}markus/LocalizeRingForHomalg/chap0.html}} \\
\\
 An \textsc{offline} version should be included in the documentation subfolder of the package. \end{minipage}

\end{center}\vfill

\mbox{}\\
{\mbox{}\\
\small \noindent \textbf{Mohamed Barakat\\
    } --- Email: \href{mailto://barakat@mathematik.uni-kl.de} {\texttt{barakat@mathematik.uni-kl.de}}\\
 --- Homepage: \href{http://www.mathematik.uni-kl.de/~barakat/} {\texttt{http://www.mathematik.uni-kl.de/\texttt{\symbol{126}}barakat/}}\\
 --- Address: \begin{minipage}[t]{8cm}\noindent
 Department of Mathematics, \\
 University of Kaiserslautern, \\
 67653 Kaiserslautern, \\
 Germany \end{minipage}
}\\
{\mbox{}\\
\small \noindent \textbf{Markus Lange-Hegermann\\
    } --- Email: \href{mailto://markus.lange.hegermann@rwth-aachen.de} {\texttt{markus.lange.hegermann@rwth-aachen.de}}\\
 --- Homepage: \href{http://wwwb.math.rwth-aachen.de/~markus} {\texttt{http://wwwb.math.rwth-aachen.de/\texttt{\symbol{126}}markus}}\\
 --- Address: \begin{minipage}[t]{8cm}\noindent
 Lehrstuhl B f{\"u}r Mathematik, RWTH Aachen, Templergraben 64, 52056 Aachen,
Germany \end{minipage}
}\\
\end{titlepage}

\newpage\setcounter{page}{2}
{\small 
\section*{Copyright}
\logpage{[ 0, 0, 1 ]}
 {\copyright} 2009-2011 by Mohamed Barakat and Markus Lange-Hegermann 

 This package may be distributed under the terms and conditions of the GNU
Public License Version 2. \mbox{}}\\[1cm]
{\small 
\section*{Acknowledgements}
\logpage{[ 0, 0, 2 ]}
 We would like to thank the Aachen forest for being such a nice place for
jogging. \mbox{}}\\[1cm]
\newpage

\def\contentsname{Contents\logpage{[ 0, 0, 3 ]}}

\tableofcontents
\newpage

 \index{\textsf{LocalizeRingForHomalg}}   
\chapter{\textcolor{Chapter }{Introduction}}\label{intro}
\logpage{[ 1, 0, 0 ]}
\hyperdef{L}{X7DFB63A97E67C0A1}{}
{
  
\section{\textcolor{Chapter }{What is the Role of the \textsf{LocalizeRingForHomalg} Package in the \textsf{homalg} Project?}}\label{role}
\logpage{[ 1, 1, 0 ]}
\hyperdef{L}{X7AC2A9FA80501972}{}
{
  The \textsf{homalg} project \cite{homalg-project} aims at providing a general and abstract framework for homological
computations. The package \textsf{LocalizeRingForHomalg} enables the \textsf{homalg} project to construct localizations from commutative rings in \textsf{homalg} at their maximal ideals. }

 
\section{\textcolor{Chapter }{Functionality}}\label{Functionality}
\logpage{[ 1, 2, 0 ]}
\hyperdef{L}{X87F1120883F5B4D0}{}
{
  The package \textsf{LocalizeRingForHomalg} on the one hand builds on the package \textsf{MatricesForHomalg} and on the other hands adds functionality to \textsf{MatricesForHomalg}. It uses the computability (i.e. capability to solve linear systems) of a
commutative ring $R$ declared in \textsf{MatricesForHomalg} to construct the localization $R_m$ of $R$ at a maximal ideal $m$ (given by a finite set of generators). This localized ring $R_m$ is again computable and can thus be used by \textsf{MatricesForHomalg}. 

Furthermore, via the package \textsf{RingsForHomalg}, an interface to \textsf{Singular} is used to compute in localized polynomial rings with the help of Mora's
algorithm. }

 
\section{\textcolor{Chapter }{The Math Behind This Package}}\label{math}
\logpage{[ 1, 3, 0 ]}
\hyperdef{L}{X7845DA5685210CC3}{}
{
  The math behind this package is a simple trick in allowing global computation
to be done instead of local computations. This works on any commutative
computable ring (in the sense of \textsf{homalg} \cite{homalg-package}) without need of implementing new low level algorithms. Details can be found
in the paper \cite{BL}. This ring can be constructed by \texttt{LocalizeAt} (\ref{LocalizeAt:for a commutative ring and a maximal ideal}) and \texttt{LocalizeAtZero} (\ref{LocalizeAtZero:for a free polynomial ring}). 

Furthermore we use the package \textsf{RingsForHomalg} to communicate with \textsf{Singular} and use the implementation of Mora's algorithm there. This is restricted to
polynomial rings and needs the package \textsf{RingsForHomalg}. This ring can be constructed by \texttt{LocalizePolynomialRingAtZeroWithMora} (\ref{LocalizePolynomialRingAtZeroWithMora:constructor for homalg localized rings using Mora's algorithm}). }

 
\section{\textcolor{Chapter }{Which Ring to Use?}}\label{ring comparison}
\logpage{[ 1, 4, 0 ]}
\hyperdef{L}{X795ABF907CEB327F}{}
{
  Since there are two kinds of rings included in this package, we want to offer
a short comparison of these. 

As usually one important part of such a comparison is the computation time. In
our experience the general localization is much faster than Mora's algorithm
for large examples. 

The main advantage of using local bases with Mora's algorithm is the
possibility of computing Hilbert polynomials and other combinatorical
invariants. This is not possible with our localization algorithm. But it is
possible to do a large computation without Mora's algorithm, which perhaps
would not terminate in acceptable time, and afterwards compute a local
standard basis of the - in comparison to intermediate computations usually
much smaller - result to get the combinatorical information and invariants. 

Furthermore we remark, that our localization algorithm works on any maximal
ideal in any computable commutative ring, whereas Mora's algorithm only works
for polynomial rings at the maximal ideal generated by the indeterminates. Of
course by affine transformation Mora's algorithm will work on any maximal
ideal in a polynomial ring where the residue class field is isomorphic to the
ground field. }

 }

   
\chapter{\textcolor{Chapter }{Installation of the \textsf{LocalizeRingForHomalg} Package}}\label{install}
\logpage{[ 2, 0, 0 ]}
\hyperdef{L}{X7E6144A47929DD91}{}
{
  To install this package just extract the package's archive file to the \textsf{GAP} \texttt{pkg} directory. \textsf{LocalizeRingForHomalg} also needs the package \textsf{homalg}.

 By default the \textsf{LocalizeRingForHomalg} package is not automatically loaded by \textsf{GAP} when it is installed. You must load the package with \\
\\
 \texttt{LoadPackage("LocalizeRingForHomalg");} \\
\\
 before its functions become available.

 Please, send me us e-mail if you have any questions, remarks, suggestions,
etc. concerning this package. Also, we would be pleased to hear about
applications of this package. \\
\\
\\
 Mohamed Barakat and Markus Lange-Hegermann  }

   
\chapter{\textcolor{Chapter }{Quick Start}}\label{QuickStart}
\logpage{[ 3, 0, 0 ]}
\hyperdef{L}{X7EB860EC84DFC71E}{}
{
   
\section{\textcolor{Chapter }{Localization of {\ensuremath{\mathbb Z}}}}\label{QuickstartZ}
\logpage{[ 3, 1, 0 ]}
\hyperdef{L}{X799572BF810091BC}{}
{
  The following example is taken from Section 2 of \cite{BREACA}. \\
\\
 The computation takes place over the local ring $R={\ensuremath{\mathbb Z}}_{\langle 2\rangle}$ (i.e. {\ensuremath{\mathbb Z}} localized at the maximal ideal generated by $2$). 

 Here we compute the (infinite) long exact homology sequence of the covariant
functor $Hom(Hom(-,R/2^7R),R/2^4R)$ (and its left derived functors) applied to the short exact sequence\\
\\
 $0 \longrightarrow M\_=R/2^2R \stackrel{\alpha_1}{\longrightarrow} M=R/2^5R
\stackrel{\alpha_2}{\longrightarrow} \_M=R/2^3R \longrightarrow 0$ . 

We want to lead your attention to the commands \texttt{LocalizeAt} and \texttt{HomalgLocalMatrix}. The first one creates a localized ring from a global one and generators of a
maximal ideal and the second one creates a local matrix from a global matrix.
The other commands used here are well known from \textsf{homalg}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
    
  gap> LoadPackage( "LocalizeRingForHomalg" );;
  gap> ZZ := HomalgRingOfIntegers(  );
  Z
  gap> R := LocalizeAt( ZZ , [ 2 ] );
  Z_< 2 >
  gap> Display( R );
  <A local ring>
  gap> LoadPackage( "Modules" );
  true
  gap> M := LeftPresentation( HomalgMatrix( [ 2^5 ], R ) );
  <A cyclic left module presented by 1 relation for a cyclic generator>
  gap> _M := LeftPresentation( HomalgMatrix( [ 2^3 ], R ) );
  <A cyclic left module presented by 1 relation for a cyclic generator>
  gap> alpha2 := HomalgMap( HomalgMatrix( [ 1 ], R ), M, _M );
  <A "homomorphism" of left modules>
  gap> M_ := Kernel( alpha2 );
  <A cyclic left module presented by yet unknown relations for a cyclic generato\
  r>
  gap> alpha1 := KernelEmb( alpha2 );
  <A monomorphism of left modules>
  gap> Display( M_ );
  Z_< 2 >/< -4/1 >
  gap> Display( alpha1 );
  [ [  24 ] ]
  / 1
  
  the map is currently represented by the above 1 x 1 matrix
  gap> ByASmallerPresentation( M_ );
  <A cyclic left module presented by 1 relation for a cyclic generator>
  gap> Display( M_ );
  Z_< 2 >/< 4/1 >
\end{Verbatim}
 }

 }

   
\chapter{\textcolor{Chapter }{Localize Rings}}\label{LocalizeRing}
\logpage{[ 4, 0, 0 ]}
\hyperdef{L}{X86CBDDB082295E5F}{}
{
  The package \textsf{LocalizeRingForHomalg} defines the classes of local(ized) rings, local ring elements and local
matrices. These three objects can be used as data structures defined in \textsf{MatricesForHomalg} on which the \textsf{homalg} project can rely to do homological computations over localized rings. 

A \textsf{homalg} local ring element contains two \textsf{homalg} ring elements, a numerator ($\to$ \texttt{Numerator} (\ref{Numerator:for homalg local ring elements})) and a denominator ($\to$ \texttt{Denominator} (\ref{Denominator:for homalg local ring elements})). A \textsf{homalg} local matrix contains a global \textsf{homalg} matrix as a numerator ($\to$ \texttt{Numerator} (\ref{Numerator:for homalg local matrices})) and a ring element as a denominator ($\to$ \texttt{Denominator} (\ref{Denominator:for homalg local matrices})). New constructors for ring elements and matrices are \texttt{HomalgLocalRingElement} (\ref{HomalgLocalRingElement:constructor for local ring elements using numerator and denominator}) and \texttt{HomalgLocalMatrix} (\ref{HomalgLocalMatrix:constructor for local matrices using numerator and denominator}) in addition to the standard contructors introduced in other packages of the \textsf{homalg} project. 

The local rings most prominently can be used with methods known from general \textsf{homalg} rings. The methods for doing the computations are presented in the appendix (\ref{FileOverview}), since they are not for external use. The new attributes and operations are
documented here. 

Since the objects inplemented here are representations from objects elsewhere
in the \textsf{homalg} project (i.e. \textsf{MatricesForHomalg}), we want to stress that there are many other operations in \textsf{homalg}, which can be used in connection with the ones presented here. A few of them
can be found in the examples and the appendix of this documentation. 
\section{\textcolor{Chapter }{Category and Representations}}\label{Rings:Category}
\logpage{[ 4, 1, 0 ]}
\hyperdef{L}{X826B3EF37FB188A8}{}
{
  

\subsection{\textcolor{Chapter }{IsHomalgLocalRingRep}}
\logpage{[ 4, 1, 1 ]}\nobreak
\hyperdef{L}{X7AEE9D7F85CD25DD}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsHomalgLocalRingRep({\slshape R})\index{IsHomalgLocalRingRep@\texttt{IsHomalgLocalRingRep}}
\label{IsHomalgLocalRingRep}
}\hfill{\scriptsize (Representation)}}\\
\textbf{\indent Returns:\ }
true or false



 The representation of \textsf{homalg} local rings. 

 (It is a subrepresentation of the \textsf{GAP} representation \\
 \texttt{IsHomalgRingOrFinitelyPresentedModuleRep}.) 
\begin{Verbatim}[fontsize=\small,frame=single,label=Code]
  DeclareRepresentation( "IsHomalgLocalRingRep",
          IsHomalgRing
          and IsHomalgRingOrFinitelyPresentedModuleRep,
          [ "ring" ] );
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{IsHomalgLocalRingElementRep}}
\logpage{[ 4, 1, 2 ]}\nobreak
\hyperdef{L}{X7E2AD9FF82990735}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsHomalgLocalRingElementRep({\slshape r})\index{IsHomalgLocalRingElementRep@\texttt{IsHomalgLocalRingElementRep}}
\label{IsHomalgLocalRingElementRep}
}\hfill{\scriptsize (Representation)}}\\
\textbf{\indent Returns:\ }
true or false



 The representation of elements of \textsf{homalg} local rings. 

 (It is a representation of the \textsf{GAP} category \texttt{IsHomalgRingElement}.) 
\begin{Verbatim}[fontsize=\small,frame=single,label=Code]
  DeclareRepresentation( "IsHomalgLocalRingElementRep",
          IsHomalgRingElement,
          [ "pointer" ] );
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{IsHomalgLocalMatrixRep}}
\logpage{[ 4, 1, 3 ]}\nobreak
\hyperdef{L}{X80AB357F7883ACF3}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsHomalgLocalMatrixRep({\slshape A})\index{IsHomalgLocalMatrixRep@\texttt{IsHomalgLocalMatrixRep}}
\label{IsHomalgLocalMatrixRep}
}\hfill{\scriptsize (Representation)}}\\
\textbf{\indent Returns:\ }
true or false



 The representation of \textsf{homalg} matrices with entries in a \textsf{homalg} local ring. 

 (It is a representation of the \textsf{GAP} category \texttt{IsHomalgMatrix}.) 
\begin{Verbatim}[fontsize=\small,frame=single,label=Code]
  DeclareRepresentation( "IsHomalgLocalMatrixRep",
          IsHomalgMatrix,
          [ ] );
\end{Verbatim}
 }

 }

 
\section{\textcolor{Chapter }{Rings: Attributes}}\label{Rings:Attributes}
\logpage{[ 4, 2, 0 ]}
\hyperdef{L}{X867290E7847A5101}{}
{
  

\subsection{\textcolor{Chapter }{GeneratorsOfMaximalLeftIdeal}}
\logpage{[ 4, 2, 1 ]}\nobreak
\hyperdef{L}{X7EAE00247B717A0F}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{GeneratorsOfMaximalLeftIdeal({\slshape R})\index{GeneratorsOfMaximalLeftIdeal@\texttt{GeneratorsOfMaximalLeftIdeal}}
\label{GeneratorsOfMaximalLeftIdeal}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
a \textsf{homalg} matrix



 Returns the generators of the maximal ideal, at which R was created. The
generators are given as a column over the associated global ring. }

 

\subsection{\textcolor{Chapter }{GeneratorsOfMaximalRightIdeal}}
\logpage{[ 4, 2, 2 ]}\nobreak
\hyperdef{L}{X85BA4850780569D7}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{GeneratorsOfMaximalRightIdeal({\slshape R})\index{GeneratorsOfMaximalRightIdeal@\texttt{GeneratorsOfMaximalRightIdeal}}
\label{GeneratorsOfMaximalRightIdeal}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
a \textsf{homalg} matrix



 Returns the generators of the maximal ideal, at which R was created. The
generators are given as a row over the associated global ring. }

 }

 
\section{\textcolor{Chapter }{Operations and Functions}}\label{LocalizeRing:Operations}
\logpage{[ 4, 3, 0 ]}
\hyperdef{L}{X81CFB50085A4E12F}{}
{
  

\subsection{\textcolor{Chapter }{AssociatedGlobalRing (for homalg local rings)}}
\logpage{[ 4, 3, 1 ]}\nobreak
\hyperdef{L}{X7D8C5E8B8533EE2D}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{AssociatedGlobalRing({\slshape R})\index{AssociatedGlobalRing@\texttt{AssociatedGlobalRing}!for homalg local rings}
\label{AssociatedGlobalRing:for homalg local rings}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
a (global) \textsf{homalg} ring



 The global \textsf{homalg} ring, from which the local ring \mbox{\texttt{\slshape R}} was created. }

 

\subsection{\textcolor{Chapter }{AssociatedGlobalRing (for homalg local ring elements)}}
\logpage{[ 4, 3, 2 ]}\nobreak
\hyperdef{L}{X8612432F81364A90}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{AssociatedGlobalRing({\slshape r})\index{AssociatedGlobalRing@\texttt{AssociatedGlobalRing}!for homalg local ring elements}
\label{AssociatedGlobalRing:for homalg local ring elements}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
a (global) \textsf{homalg} ring



 The global \textsf{homalg} ring, from which the local ring element \mbox{\texttt{\slshape r}} was created. }

 

\subsection{\textcolor{Chapter }{AssociatedGlobalRing (for homalg local matrices)}}
\logpage{[ 4, 3, 3 ]}\nobreak
\hyperdef{L}{X78AE3B5187FC5B24}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{AssociatedGlobalRing({\slshape mat})\index{AssociatedGlobalRing@\texttt{AssociatedGlobalRing}!for homalg local matrices}
\label{AssociatedGlobalRing:for homalg local matrices}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
a (global) \textsf{homalg} ring



 The global \textsf{homalg} ring, from which the local matrix \mbox{\texttt{\slshape mat}} was created. }

 

\subsection{\textcolor{Chapter }{Numerator (for homalg local ring elements)}}
\logpage{[ 4, 3, 4 ]}\nobreak
\hyperdef{L}{X86B86F85831145D0}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Numerator({\slshape r})\index{Numerator@\texttt{Numerator}!for homalg local ring elements}
\label{Numerator:for homalg local ring elements}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
a (global) \textsf{homalg} ring element



 The numerator from a local ring element \mbox{\texttt{\slshape r}}, which is a \textsf{homalg} ring element from the computation ring. }

 

\subsection{\textcolor{Chapter }{Numerator (for homalg local matrices)}}
\logpage{[ 4, 3, 5 ]}\nobreak
\hyperdef{L}{X8613D7A27D3D770D}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Numerator({\slshape mat})\index{Numerator@\texttt{Numerator}!for homalg local matrices}
\label{Numerator:for homalg local matrices}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
a (global) \textsf{homalg} matrix



 The numerator from a local matrix \mbox{\texttt{\slshape mat}}, which is a \textsf{homalg} matrix from the computation ring. }

 

\subsection{\textcolor{Chapter }{Denominator (for homalg local ring elements)}}
\logpage{[ 4, 3, 6 ]}\nobreak
\hyperdef{L}{X83E87130831148A4}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Denominator({\slshape r})\index{Denominator@\texttt{Denominator}!for homalg local ring elements}
\label{Denominator:for homalg local ring elements}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
a (global) \textsf{homalg} ring element



 The denominator from a local ring element \mbox{\texttt{\slshape r}}, which is a \textsf{homalg} ring element from the computation ring. }

 

\subsection{\textcolor{Chapter }{Denominator (for homalg local matrices)}}
\logpage{[ 4, 3, 7 ]}\nobreak
\hyperdef{L}{X863DB91A7DEDEA22}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Denominator({\slshape mat})\index{Denominator@\texttt{Denominator}!for homalg local matrices}
\label{Denominator:for homalg local matrices}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
a (global) \textsf{homalg} ring element



 The denominator from a local matrix \mbox{\texttt{\slshape mat}}, which is a \textsf{homalg} matrix from the computation ring. }

 

\subsection{\textcolor{Chapter }{Name (for homalg local ring elements)}}
\logpage{[ 4, 3, 8 ]}\nobreak
\hyperdef{L}{X7FA0CC577E97B6E8}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Name({\slshape r})\index{Name@\texttt{Name}!for homalg local ring elements}
\label{Name:for homalg local ring elements}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
a string



 The name of the local ring element \mbox{\texttt{\slshape r}}. }

 

\subsection{\textcolor{Chapter }{SetMatElm (for homalg local matrices)}}
\logpage{[ 4, 3, 9 ]}\nobreak
\hyperdef{L}{X80F936B786454DD0}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{SetMatElm({\slshape mat, i, j, r, R})\index{SetMatElm@\texttt{SetMatElm}!for homalg local matrices}
\label{SetMatElm:for homalg local matrices}
}\hfill{\scriptsize (operation)}}\\


 Changes the entry (\mbox{\texttt{\slshape i,j}}) of the local matrix \mbox{\texttt{\slshape mat}} to the value \mbox{\texttt{\slshape r}}. Here \mbox{\texttt{\slshape R}} is the (local) \textsf{homalg} ring involved in these computations. }

 

\subsection{\textcolor{Chapter }{AddToMatElm (for homalg local matrices)}}
\logpage{[ 4, 3, 10 ]}\nobreak
\hyperdef{L}{X87689354873E0B14}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{AddToMatElm({\slshape mat, i, j, r, R})\index{AddToMatElm@\texttt{AddToMatElm}!for homalg local matrices}
\label{AddToMatElm:for homalg local matrices}
}\hfill{\scriptsize (operation)}}\\


 Changes the entry (\mbox{\texttt{\slshape i,j}}) of the local matrix \mbox{\texttt{\slshape mat}} by adding the value \mbox{\texttt{\slshape r}} to it. Here \mbox{\texttt{\slshape R}} is the (local) \textsf{homalg} ring involved in these computations. }

 

\subsection{\textcolor{Chapter }{MatElmAsString (for homalg local matrices)}}
\logpage{[ 4, 3, 11 ]}\nobreak
\hyperdef{L}{X8789D7998407AD36}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{MatElmAsString({\slshape mat, i, j, R})\index{MatElmAsString@\texttt{MatElmAsString}!for homalg local matrices}
\label{MatElmAsString:for homalg local matrices}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
a string



 Returns the entry (\mbox{\texttt{\slshape i,j}}) of the local matrix \mbox{\texttt{\slshape mat}} as a string. Here \mbox{\texttt{\slshape R}} is the (local) \textsf{homalg} ring involved in these computations. }

 

\subsection{\textcolor{Chapter }{MatElm (for homalg local matrices)}}
\logpage{[ 4, 3, 12 ]}\nobreak
\hyperdef{L}{X7EFD740F87ADB6E0}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{MatElm({\slshape mat, i, j, R})\index{MatElm@\texttt{MatElm}!for homalg local matrices}
\label{MatElm:for homalg local matrices}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
a local ring element



 Returns the entry (\mbox{\texttt{\slshape i,j}}) of the local matrix \mbox{\texttt{\slshape mat}}. Here \mbox{\texttt{\slshape R}} is the (local) \textsf{homalg} ring involved in these computations. }

 

\subsection{\textcolor{Chapter }{Cancel (for pairs of ring elements)}}
\logpage{[ 4, 3, 13 ]}\nobreak
\hyperdef{L}{X7F0196827D195F88}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Cancel({\slshape a, b})\index{Cancel@\texttt{Cancel}!for pairs of ring elements}
\label{Cancel:for pairs of ring elements}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
two ring elements



 For $\mbox{\texttt{\slshape a}}=a'*c$ and $\mbox{\texttt{\slshape b}}=b'*c$ return $a'$ and $b'$. The exact form of $c$ depends on whether a procedure for gcd computation is included in the ring
package. }

 

\subsection{\textcolor{Chapter }{LocalizeAt (for a commutative ring and a maximal ideal)}}
\logpage{[ 4, 3, 14 ]}\nobreak
\hyperdef{L}{X7E4E70FE82978F9C}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LocalizeAt({\slshape R, l})\index{LocalizeAt@\texttt{LocalizeAt}!for a commutative ring and a maximal ideal}
\label{LocalizeAt:for a commutative ring and a maximal ideal}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
a local ring



 If \mbox{\texttt{\slshape l}} is a list of elements of the global ring \mbox{\texttt{\slshape R}} generating a maximal ideal, the method creates the corresponding localization
of \mbox{\texttt{\slshape R}} at the complement of the maximal ideal. }

 

\subsection{\textcolor{Chapter }{LocalizeAtZero (for a free polynomial ring)}}
\logpage{[ 4, 3, 15 ]}\nobreak
\hyperdef{L}{X7D910AA785CEED34}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LocalizeAtZero({\slshape R})\index{LocalizeAtZero@\texttt{LocalizeAtZero}!for a free polynomial ring}
\label{LocalizeAtZero:for a free polynomial ring}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
a local ring



 This method creates the corresponding localization of \mbox{\texttt{\slshape R}} at the complement of the maximal ideal generated by the indeterminates ("at
zero"). }

 

\subsection{\textcolor{Chapter }{LocalizePolynomialRingAtZeroWithMora (constructor for homalg localized rings using Mora's algorithm)}}
\logpage{[ 4, 3, 16 ]}\nobreak
\hyperdef{L}{X7F790F3B852C1A5C}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LocalizePolynomialRingAtZeroWithMora({\slshape R})\index{LocalizePolynomialRingAtZeroWithMora@\texttt{Localize}\-\texttt{Polynomial}\-\texttt{Ring}\-\texttt{At}\-\texttt{Zero}\-\texttt{With}\-\texttt{Mora}!constructor for homalg localized rings using Mora's algorithm}
\label{LocalizePolynomialRingAtZeroWithMora:constructor for homalg localized rings using Mora's algorithm}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
a local ring



 This method localizes the ring \mbox{\texttt{\slshape R}} at zero and this localized ring is returned. The ring table uses Mora's
algorithm as implemented \textsf{Singular} for low level computations. }

 

\subsection{\textcolor{Chapter }{HomalgLocalRingElement (constructor for local ring elements using numerator and denominator)}}
\logpage{[ 4, 3, 17 ]}\nobreak
\hyperdef{L}{X8741B0AE787624CB}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{HomalgLocalRingElement({\slshape numer, denom, R})\index{HomalgLocalRingElement@\texttt{HomalgLocalRingElement}!constructor for local ring elements using numerator and denominator}
\label{HomalgLocalRingElement:constructor for local ring elements using numerator and denominator}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{HomalgLocalRingElement({\slshape numer, R})\index{HomalgLocalRingElement@\texttt{HomalgLocalRingElement}!constructor for local ring elements using a given numerator and one as denominator}
\label{HomalgLocalRingElement:constructor for local ring elements using a given numerator and one as denominator}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
a local ring element



 Creates the local ring element $\mbox{\texttt{\slshape numer}}/\mbox{\texttt{\slshape denom}}$ or in the second case $\mbox{\texttt{\slshape numer}}/1$ for the local ring \mbox{\texttt{\slshape R}}. Both \mbox{\texttt{\slshape numer}} and \mbox{\texttt{\slshape denom}} may either be a string describing a valid global ring element or from the
global ring or computation ring. }

 

\subsection{\textcolor{Chapter }{HomalgLocalMatrix (constructor for local matrices using numerator and denominator)}}
\logpage{[ 4, 3, 18 ]}\nobreak
\hyperdef{L}{X808317A88773E967}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{HomalgLocalMatrix({\slshape numer, denom, R})\index{HomalgLocalMatrix@\texttt{HomalgLocalMatrix}!constructor for local matrices using numerator and denominator}
\label{HomalgLocalMatrix:constructor for local matrices using numerator and denominator}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{HomalgLocalMatrix({\slshape numer, R})\index{HomalgLocalMatrix@\texttt{HomalgLocalMatrix}!constructor for local matrices using a given numerator and one as denominator}
\label{HomalgLocalMatrix:constructor for local matrices using a given numerator and one as denominator}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
a local matrix



 Creates the local matrix $\mbox{\texttt{\slshape numer}}/\mbox{\texttt{\slshape denom}}$ or in the second case $\mbox{\texttt{\slshape numer}}/1$ for the local ring \mbox{\texttt{\slshape R}}. Both \mbox{\texttt{\slshape numer}} and \mbox{\texttt{\slshape denom}} may either be from the global ring or the computation ring. }

 }

 }

   
\chapter{\textcolor{Chapter }{Examples}}\label{examples}
\logpage{[ 5, 0, 0 ]}
\hyperdef{L}{X7A489A5D79DA9E5C}{}
{
  
\section{\textcolor{Chapter }{An Easy Polynomial Example}}\label{EasyPoly}
\logpage{[ 5, 1, 0 ]}
\hyperdef{L}{X8426A658837B4911}{}
{
  The ground ring used in this example is $F_3[x,y]$. We want to see, how the different rings in this package can be used to
localize at different points and how the results differ. 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> LoadPackage("RingsForHomalg");;
  gap> F3xy := HomalgRingOfIntegersInSingular(3) * "x,y";;
  gap> x1 := HomalgRingElement( "x+2", F3xy );;
  gap> y0 := HomalgRingElement( "y", F3xy );;
  gap> LoadPackage("LocalizeRingForHomalg");;
  gap> R00 := LocalizeAtZero( F3xy );;
  gap> R10 := LocalizeAt( F3xy, [ x1, y0 ] );;
  gap> RMora := LocalizePolynomialRingAtZeroWithMora( F3xy );;
  gap> M := HomalgMatrix( "[\
  >        y^3+2*y^2+x+x^2+2*x*y+y^4+x*y^2, \
  >        x*y^3+2*x^2*y+y^3+y^2+x+2*y+x^2, \
  >        x^2*y^2+2*x^3+x^2*y+y^3+2*x^2+2*x*y+y^2+2*y\
  >      ]", 1, 3, F3xy );;
  gap> LoadPackage( "Modules" );;
  gap> I := RightPresentation( M );;
  gap> M00 := HomalgLocalMatrix( M, R00 );;
  gap> M10 := HomalgLocalMatrix( M, R10 );;
  gap> MMora := HomalgLocalMatrix( M, RMora );;
  gap> I00 := RightPresentation( M00 );;
  gap> I10 := RightPresentation( M10 );;
  gap> IMora := RightPresentation( MMora );;
\end{Verbatim}
 This ring is able to compute a standard basis of the module. 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> Display( IMora );
  GF(3)[x,y]_< x, y >/< (x+x^2-x*y-y^2+x*y^2+y^3+y^4)/1, (x-y+x^2+y^2-x^2*y+y^3+\
  x*y^3)/1, (-y-x^2-x*y+y^2-x^3+x^2*y+y^3+x^2*y^2)/1 >
  gap> ByASmallerPresentation( IMora );
  <A cyclic torsion right module on a cyclic generator satisfying 2 relations>
  gap> Display( IMora );
  GF(3)[x,y]_< x, y >/< x/1, y/1 >
\end{Verbatim}
 This ring recognizes, that the module is not zero, but is not able to find
better generators. 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> Display( I00 );
  GF(3)[x,y]_< x, y >/< (y^4+x*y^2+y^3+x^2-x*y-y^2+x)/1, (x*y^3-x^2*y+y^3+x^2+y^\
  2+x-y)/1, (x^2*y^2-x^3+x^2*y+y^3-x^2-x*y+y^2-y)/1 >
  gap> ByASmallerPresentation( I00 );
  <A cyclic right module on a cyclic generator satisfying 3 relations>
  gap> Display( I00 );
  GF(3)[x,y]_< x, y >/< (y^4+x*y^2+y^3+x^2-x*y-y^2+x)/1, (x*y^3-x^2*y+y^3+x^2+y^\
  2+x-y)/1, (x^2*y^2-x^3+x^2*y+y^3-x^2-x*y+y^2-y)/1 >
\end{Verbatim}
 We are able to change the ring, to compute a nicer basis. 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> I00ToMora := RMora * I00;
  <A cyclic right module on a cyclic generator satisfying 3 relations>
  gap> Display( I00ToMora );
  GF(3)[x,y]_< x, y >/< (x+x^2-x*y-y^2+x*y^2+y^3+y^4)/1, (x-y+x^2+y^2-x^2*y+y^3+\
  x*y^3)/1, (-y-x^2-x*y+y^2-x^3+x^2*y+y^3+x^2*y^2)/1 >
  gap> ByASmallerPresentation( I00ToMora );
  <A cyclic torsion right module on a cyclic generator satisfying 2 relations>
  gap> Display( I00ToMora );
  GF(3)[x,y]_< x, y >/< x/1, y/1 >
\end{Verbatim}
 We are able to find out, that this module is actually zero. 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> Display( I10 );
  GF(3)[x,y]_< x-1, y >/< (y^4+x*y^2+y^3+x^2-x*y-y^2+x)/1, (x*y^3-x^2*y+y^3+x^2+\
  y^2+x-y)/1, (x^2*y^2-x^3+x^2*y+y^3-x^2-x*y+y^2-y)/1 >
  gap> ByASmallerPresentation( I10 );
  <A zero right module>
  gap> Display( I10 );
  0
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Hom(Hom(-,Z128),Z16)}}\label{HomHomZ128}
\logpage{[ 5, 2, 0 ]}
\hyperdef{L}{X7820475F7C884EA5}{}
{
  The following example is taken from Section 2 of \cite{BREACA}. \\
\\
 The computation takes place over the local ring $R={\ensuremath{\mathbb Z}}_{\langle 2\rangle}$ (i.e. {\ensuremath{\mathbb Z}} localized at the maximal ideal generated by $2$). 

 Here we compute the (infinite) long exact homology sequence of the covariant
functor $Hom(Hom(-,R/2^7R),R/2^4R)$ (and its left derived functors) applied to the short exact sequence\\
\\
 $0 \longrightarrow M\_=R/2^2R \stackrel{\alpha_1}{\longrightarrow} M=R/2^5R
\stackrel{\alpha_2}{\longrightarrow} \_M=R/2^3R \longrightarrow 0$ . 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> LoadPackage( "LocalizeRingForHomalg" );;
  gap> GlobalR := HomalgRingOfIntegersInExternalGAP(  );
  Z
  gap> Display( GlobalR );
  <An external ring residing in the CAS GAP>
  gap> LoadPackage( "RingsForHomalg" );;
  gap> R := LocalizeAt( GlobalR , [ 2 ] );
  Z_< 2 >
  gap> Display( R );
  <A local ring>
  gap> M := LeftPresentation( HomalgMatrix( [ 2^5 ], R ) );
  <A cyclic left module presented by an unknown number of relations for a cyclic\
   generator>
  gap> _M := LeftPresentation( HomalgMatrix( [ 2^3 ], R ) );
  <A cyclic left module presented by an unknown number of relations for a cyclic\
   generator>
  gap> alpha2 := HomalgMap( HomalgMatrix( [ 1 ], R ), M, _M );
  <A "homomorphism" of left modules>
  gap> M_ := Kernel( alpha2 );
  <A cyclic left module presented by yet unknown relations for a cyclic generato\
  r>
  gap> alpha1 := KernelEmb( alpha2 );
  <A monomorphism of left modules>
  gap> seq := HomalgComplex( alpha2 );
  <A "complex" containing a single morphism of left modules at degrees
  [ 0 .. 1 ]>
  gap> Add( seq, alpha1 );
  gap> IsShortExactSequence( seq );
  true
  gap> K := LeftPresentation( HomalgMatrix( [ 2^7 ], R ) );
  <A cyclic left module presented by an unknown number of relations for a cyclic\
   generator>
  gap> L := RightPresentation( HomalgMatrix( [ 2^4 ], R ) );
  <A cyclic right module on a cyclic generator satisfying an unknown number of r\
  elations>
  gap> triangle := LHomHom( 4, seq, K, L, "t" );
  <An exact triangle containing 3 morphisms of left complexes at degrees
  [ 1, 2, 3, 1 ]>
  gap> lehs := LongSequence( triangle );
  <A sequence containing 14 morphisms of left modules at degrees [ 0 .. 14 ]>
  gap> ByASmallerPresentation( lehs );
  <A non-zero sequence containing 14 morphisms of left modules at degrees
  [ 0 .. 14 ]>
  gap> IsExactSequence( lehs );
  true
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{ResidueClass}}\label{ResidueClass}
\logpage{[ 5, 3, 0 ]}
\hyperdef{L}{X7CC8EA507E7AABA4}{}
{
  We want to show, how localization can work together with residue class rings. 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> LoadPackage( "RingsForHomalg" );;
  gap> Qxy := HomalgFieldOfRationalsInDefaultCAS( ) * "x,y";
  Q[x,y]
  gap> wmat := HomalgMatrix(
  >           "[ y^3-y^2 , x^3-x^2 , y^3+y^2 , x^3+x^2 ]",
  >           2, 2, Qxy );
  <A 2 x 2 matrix over an external ring>
  gap> ec := HomalgRingElement( "-x^3-x^2+2*y^2", Qxy );
  -x^3-x^2+2*y^2
\end{Verbatim}
 Compute globally: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> LoadPackage( "Modules" );;
  gap> W := LeftPresentation( wmat );
  <A left module presented by 2 relations for 2 generators>
  gap> Res := Resolution( 2 , W );
  <A right acyclic complex containing 2 morphisms of left modules at degrees
  [ 0 .. 2 ]>
  gap> Display( Res );
  -------------------------
  at homology degree: 2
  0
  -------------------------
  (an empty 0 x 2 matrix)
  
  the map is currently represented by the above 0 x 2 matrix
  ------------v------------
  at homology degree: 1
  Q[x,y]^(1 x 2)
  -------------------------
  y^2,      x^2,
  x*y^2-y^3,0
  
  the map is currently represented by the above 2 x 2 matrix
  ------------v------------
  at homology degree: 0
  Q[x,y]^(1 x 2)
  -------------------------
\end{Verbatim}
 Try a localization of a residue class ring: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> R1 := Qxy / ec;
  Q[x,y]/( x^3+x^2-2*y^2 )
  gap> Display( R1 );
  <A residue class ring>
  gap> wmat1 := R1 * wmat;
  <A 2 x 2 matrix over a residue class ring>
  gap> LoadPackage( "LocalizeRingForHomalg" );;
  gap> R10 := LocalizeAt( R1 ,
  >          [ HomalgRingElement( "x", R1 ),
  >            HomalgRingElement( "y", R1 ) ]
  >        );
  Q[x,y]/( x^3+x^2-2*y^2 )_< |[ x ]|, |[ y ]| >
  gap> Display( R10 );
  <A local ring>
  gap> wmat10 := HomalgLocalMatrix( wmat, R10 );
  <A 2 x 2 matrix over a local ring>
  gap> W10 := LeftPresentation( wmat10 );
  <A left module presented by 2 relations for 2 generators>
  gap> Res10 := Resolution( 2 , W10 );
  <A right acyclic complex containing 2 morphisms of left modules at degrees
  [ 0 .. 2 ]>
  gap> Display( Res10 );
  -------------------------
  at homology degree: 2
  0
  -------------------------
  (an empty 0 x 2 matrix)
  
  the map is currently represented by the above 0 x 2 matrix
  ------------v------------
  at homology degree: 1
  Q[x,y]/( x^3+x^2-2*y^2 )_< |[ x ]|, |[ y ]| >^(1 x 2)
  -------------------------
  0,  x*y^2-y^3,
  y^2,y^4-2*y^3+2*y^2
  
  modulo [ x^3+x^2-2*y^2 ]
  / |[ 1 ]|
  
  the map is currently represented by the above 2 x 2 matrix
  ------------v------------
  at homology degree: 0
  Q[x,y]/( x^3+x^2-2*y^2 )_< |[ x ]|, |[ y ]| >^(1 x 2)
  -------------------------
\end{Verbatim}
 Try a residue class ring of a localization: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> R0 := LocalizeAtZero( Qxy );
  Q[x,y]_< x, y >
  gap> Display( R0 );
  <A local ring>
  gap> wmat0 := R0 * wmat;
  <A 2 x 2 matrix over a local ring>
  gap> R01 := R0 / ( ec / R0 );
  Q[x,y]_< x, y >/( (x^3+x^2-2*y^2)/1 )
  gap> Display( R01 );
  <A residue class ring>
  gap> wmat01 := R01 * wmat0;
  <A 2 x 2 matrix over a residue class ring>
  gap> W01 := LeftPresentation( wmat01 );
  <A left module presented by 2 relations for 2 generators>
  gap> Res01 := Resolution( 2 , W01 );
  <A right acyclic complex containing 2 morphisms of left modules at degrees
  [ 0 .. 2 ]>
  gap> Display( Res01 );
  -------------------------
  at homology degree: 2
  0
  -------------------------
  (an empty 0 x 2 matrix)
  
  the map is currently represented by the above 0 x 2 matrix
  ------------v------------
  at homology degree: 1
  Q[x,y]_< x, y >/( (x^3+x^2-2*y^2)/1 )^(1 x 2)
  -------------------------
  y^2,    x^2,
  y^3+y^2,2*y^2
  / 1
  
  modulo [ (x^3+x^2-2*y^2)/1 ]
  
  the map is currently represented by the above 2 x 2 matrix
  ------------v------------
  at homology degree: 0
  Q[x,y]_< x, y >/( (x^3+x^2-2*y^2)/1 )^(1 x 2)
  -------------------------
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Testing the Intersection Formula}}\label{Intersection}
\logpage{[ 5, 4, 0 ]}
\hyperdef{L}{X7958E7417BB312F0}{}
{
  We want to check Serre's intersection formula $i(I_1, I_2; 0)=\sum_i(-1)^i length(Tor^{R_0}_i(R_0/I_1,R_0/I_2))$ on an easy affine example. 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
   
  gap> LoadPackage( "RingsForHomalg" );;
  gap> R := HomalgFieldOfRationalsInSingular() * "w,x,y,z";;
  gap> LoadPackage( "LocalizeRingForHomalg" );;
  gap> R0 := LocalizePolynomialRingAtZeroWithMora( R );;
  gap> M1 := HomalgMatrix( "[\
  >        (w-x^2)*y, \
  >        (w-x^2)*z, \
  >        (x-w^2)*y, \
  >        (x-w^2)*z  \
  >      ]", 4, 1, R );;
  gap> M2 := HomalgMatrix( "[\
  >        (w-x^2)-y, \
  >        (x-w^2)-z  \
  >      ]", 2, 1, R );;
  gap> LoadPackage( "Modules" );;
  gap> RmodI1 := LeftPresentation( M1 );;
  gap> RmodI2 := LeftPresentation( M2 );;
  gap> T:=Tor( RmodI1, RmodI2 );
  <A graded homology object consisting of 4 left modules at degrees [ 0 .. 3 ]>
  gap> List( ObjectsOfComplex( T ), AffineDegree );
  [ 12, 4, 0, 0 ]
\end{Verbatim}
 We read, that the intersection multiplicity is 12-4=8 globally. 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> M10 := R0 * M1;
  <A 4 x 1 matrix over a local (Mora) ring>
  gap> M20 := R0 * M2;
  <A 2 x 1 matrix over a local (Mora) ring>
  gap> R0modI10 := LeftPresentation( M10 );;
  gap> R0modI20 := LeftPresentation( M20 );;
  gap> T0 := Tor( R0modI10, R0modI20 );
  <A graded homology object consisting of 4 left modules at degrees [ 0 .. 3 ]>
  gap> List( ObjectsOfComplex( T0 ), AffineDegree );
  [ 3, 1, 0, 0 ]
\end{Verbatim}
 The intersection multiplicity at zero is 3-1=2. }

  }

 

\appendix


\chapter{\textcolor{Chapter }{Overview of the \textsf{LocalizeRingForHomalg} Package Source Code}}\label{FileOverview}
\logpage{[ "A", 0, 0 ]}
\hyperdef{L}{X7C7697867CBF79C9}{}
{
  This appendix is included in the documentation to shine some light on the
mathematical backgrounds of this Package. Neither is it needed to work with
this package nor should the methods presented here be called directly. The
functions documented here are entries of the so called ring table and not to
be called directly. There are higher level methods in declared and installed
in \textsf{MatricesForHomalg}, which call this functions ($\to$ \texttt{?MatricesForHomalg:The Basic Matrix Operations}). 

We only present the simpler procedures, where no transformation matrices are
computed, since the computation of transformation matrices carries no further
mathematical ideas. 
\section{\textcolor{Chapter }{The generic Methods}}\label{HomalgTable:Generic}
\logpage{[ "A", 1, 0 ]}
\hyperdef{L}{X87807E467C364A00}{}
{
  There are some methods in localized rings, where homalg is able to fall back
on procedures of the corresponding global ring. Furthermore these methods work
quite good together with Mora's algorithm as implemented in Singular, since we
can treat it like a global ring. We will present some methods as an example,
to show the idea: 

\subsection{\textcolor{Chapter }{BasisOfRowModule (for local rings)}}
\logpage{[ "A", 1, 1 ]}\nobreak
\hyperdef{L}{X7B04DAB47BAB9165}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{BasisOfRowModule({\slshape M})\index{BasisOfRowModule@\texttt{BasisOfRowModule}!for local rings}
\label{BasisOfRowModule:for local rings}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
a "basis" of the module generated by M



 This procedure computes a basis by using the Funcod of the underlying
computation ring. If the computation ring is given by Mora's Algorithm, we
will indeed compute a local basis. If we just use the global ring for
computations, this will be a global basis and is just computed for some
simplifications and not for the use of reducing by it. Of course we can just
forget about the denominator of \mbox{\texttt{\slshape M}}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=Code]
  BasisOfRowModule :=
    function( M )
  
      Info(
        InfoLocalizeRingForHomalg,
        2,
        "Start BasisOfRowModule with ",
        NrRows( M ), "x", NrColumns( M )
      );
  
      return HomalgLocalMatrix( BasisOfRowModule( Numerator( M ) ), HomalgRing( M ) );
      
  end,
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{DecideZeroRows (for local rings with Mora's algorithm)}}
\logpage{[ "A", 1, 2 ]}\nobreak
\hyperdef{L}{X8196F11E7FD3201C}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{DecideZeroRows({\slshape A, B})\index{DecideZeroRows@\texttt{DecideZeroRows}!for local rings with Mora's algorithm}
\label{DecideZeroRows:for local rings with Mora's algorithm}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
a "reduced" form of \mbox{\texttt{\slshape A}} with respect to \mbox{\texttt{\slshape B}}



 This procedure just calls the DecideZeroRows of the computation ring for the
numerator of \mbox{\texttt{\slshape A}}. 

If we use Mora's algorithm this procedure will just call it. The result is
divided by the denominator of \mbox{\texttt{\slshape A}} afterwards. Again we do not need to care about the denominator of B. 

If we use the reduction implemented in this package, this Funcod is
overwritten and will not be called. 
\begin{Verbatim}[fontsize=\small,frame=single,label=Code]
  DecideZeroRows :=
    function( A, B )
      local R, ComputationRing, hook, result;
      
      Info(
        InfoLocalizeRingForHomalg,
        2,
        "Start DecideZeroRows with ",
        NrRows( A ), "x", NrColumns( A ),
        " and ",
        NrRows( B ), "x", NrColumns( B )
      );
      
      R := HomalgRing( A );
      ComputationRing := AssociatedComputationRing( R );
      
      result := DecideZeroRows( Numerator( A ) , Numerator( B ) );
      result := HomalgLocalMatrix( result, Denominator( A ) , R );
      Info( InfoLocalizeRingForHomalgShowUnits, 1, "DecideZeroRows: produces denominator: ", Name( Denominator( result ) ) );
      return result;
  
    end,
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{SyzygiesGeneratorsOfRows (for local rings)}}
\logpage{[ "A", 1, 3 ]}\nobreak
\hyperdef{L}{X7B1B3662863726EE}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{SyzygiesGeneratorsOfRows({\slshape M})\index{SyzygiesGeneratorsOfRows@\texttt{SyzygiesGeneratorsOfRows}!for local rings}
\label{SyzygiesGeneratorsOfRows:for local rings}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
a "basis" of the syzygies of the arguments (for details consult the homalg
help)



 It is easy to see, that a global syzygy is also a local syzygy and vice versa
when clearing the local Syzygy of its denominators. So this procedure just
calls the syzygy Funcod of the underlying computation ring. 
\begin{Verbatim}[fontsize=\small,frame=single,label=Code]
  SyzygiesGeneratorsOfRows :=
    function( M )
      
      Info(
        InfoLocalizeRingForHomalg,
        2,
        "Start SyzygiesGeneratorsOfRows with ",
        NrRows( M ), "x", NrColumns( M )
      );
  
      return HomalgLocalMatrix(\
               SyzygiesGeneratorsOfRows( Numerator( M ) ), HomalgRing( M )\
             );
      
    end,
\end{Verbatim}
 }

 }

 
\section{\textcolor{Chapter }{The Local Decide Zero trick}}\label{HomalgTable:DecideZero}
\logpage{[ "A", 2, 0 ]}
\hyperdef{L}{X85822F1B7E006A87}{}
{
  

\subsection{\textcolor{Chapter }{DecideZeroRows (for local rings)}}
\logpage{[ "A", 2, 1 ]}\nobreak
\hyperdef{L}{X790256E88417752F}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{DecideZeroRows({\slshape B, A})\index{DecideZeroRows@\texttt{DecideZeroRows}!for local rings}
\label{DecideZeroRows:for local rings}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
a "reduced" form of \mbox{\texttt{\slshape B}} with respect to \mbox{\texttt{\slshape A}}



 This procedure is the mathematical core procedure of this package. We use a
trick to decide locally, whether \mbox{\texttt{\slshape B}} can be reduced to zero by \mbox{\texttt{\slshape A}} with a global computation. First a heuristic is used by just checking, whether
the element lies inside the global module, generated by the generators of the
local module. This of course implies this for the local module having the
advantage of a short computation time and leaving a normal form free of
denominators. If this check fails, we use our trick to check for each row of \mbox{\texttt{\slshape B}} independently, whether it lies in the module generated by \mbox{\texttt{\slshape B}}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=Code]
  DecideZeroRows :=
    function( B, A )
      local R, T, m, gens, n, GlobalR, one, N, b, numB, denB, i, B1, A1, B2, A2, B3;
      
      Info( 
         InfoLocalizeRingForHomalg,
         2,
         "Start DecideZeroRows with ",
         NrRows( B ), "x", NrColumns( B ),
         " and ",
         NrRows( A ), "x", NrColumns( A ) 
      );
      
      R := HomalgRing( B );
      GlobalR := AssociatedComputationRing( R );
      T := HomalgVoidMatrix( R );
      gens := GeneratorsOfMaximalLeftIdeal( R );
      n := NrRows( gens );
      one := One( GlobalR );
      
      m := NrRows( A );
      A1 := Numerator( A );
      
      N := HomalgZeroMatrix( 0, NrColumns( B ), R );
      b := Eval( B );
      numB := b[1];
      denB := b[2];
      
      for i in [ 1 .. NrRows( B ) ] do
      
          #use global reduction as heuristic
          B1 := CertainRows( numB, [ i ] );
          B2 := HomalgLocalMatrix( DecideZeroRows( B1, A1 ), R );
          
          #if it is nonzero, check whether local reduction makes it zero
          if not IsZero( B2 ) then
            A2 := UnionOfRows( A1, gens * B1 );
            A2 := BasisOfRows( A2 );
            B3 := HomalgLocalMatrix( DecideZeroRows( B1, A2 ), R );
            if IsZero( B3 ) then
              B2 := B3;
            fi;
          fi;
          
          N := UnionOfRows( N, B2 );
          
      od;
      
      N := HomalgRingElement( one, denB, R ) * N;
      
      Info( InfoLocalizeRingForHomalgShowUnits, 1, "DecideZeroRows: produces denominator: ", Name( Denominator( N ) ) );
      
      return N;
      
    end,
\end{Verbatim}
 }

 }

 
\section{\textcolor{Chapter }{Tools}}\label{LocalizeRing:Tools}
\logpage{[ "A", 3, 0 ]}
\hyperdef{L}{X8508AEF8845565A1}{}
{
  The package \textsf{LocalizeRingForHomalg} also implements tool functions. These are referred to from \textsf{MatricesForHomalg} automatically. We list the implemented methods here are and refer to the \textsf{MatricesForHomalg} documentation ($\to$ \texttt{?MatricesForHomalg: The Matrix Tool Operations} and \texttt{?MatricesForHomalg:RingElement}) for details. All tools functions from \textsf{MatricesForHomalg} not listed here are also supported by fallback tools. 
\begin{itemize}
\item IsZero
\item IsOne
\item Minus
\item DivideByUnit
\item IsUnit
\item Sum
\item Product
\item ShallowCopy
\item ZeroMatrix
\item IdentityMatrix
\item AreEqualMatrices
\item Involution
\item CertainRows
\item CertainColumns
\item UnionOfRows
\item UnionOfColumns
\item DiagMat
\item KroneckerMat
\item MulMat
\item AddMat
\item SubMat
\item Compose
\item NrRows
\item NrColumns
\item IsZeroMatrix
\item IsDiagonalMatrix
\item ZeroRows
\item ZeroColumns
\end{itemize}
 }

 }

\def\bibname{References\logpage{[ "Bib", 0, 0 ]}
\hyperdef{L}{X7A6F98FD85F02BFE}{}
}

\bibliographystyle{alpha}
\bibliography{LocalizeRingForHomalgBib.xml}

\def\indexname{Index\logpage{[ "Ind", 0, 0 ]}
\hyperdef{L}{X83A0356F839C696F}{}
}


\printindex

\newpage
\immediate\write\pagenrlog{["End"], \arabic{page}];}
\immediate\closeout\pagenrlog
\end{document}
