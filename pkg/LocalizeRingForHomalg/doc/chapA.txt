  
  [1XA Overview of the [5XLocalizeRingForHomalg[1X Package Source Code[0X
  
  This  appendix  is  included in the documentation to shine some light on the
  mathematical  backgrounds of this Package. Neither is it needed to work with
  this  package  nor should the methods presented here be called directly. The
  functions documented here are entries of the so called ring table and not to
  be called directly. There are higher level methods in declared and installed
  in  [5XMatricesForHomalg[0m, which call this functions (--> [10X?MatricesForHomalg:The
  Basic Matrix Operations[0m).
  
  We only present the simpler procedures, where no transformation matrices are
  computed,  since  the  computation  of  transformation  matrices  carries no
  further mathematical ideas.
  
  
  [1XA.1 The generic Methods[0X
  
  There are some methods in localized rings, where homalg is able to fall back
  on  procedures  of  the corresponding global ring. Furthermore these methods
  work  quite  good together with Mora's algorithm as implemented in Singular,
  since we can treat it like a global ring. We will present some methods as an
  example, to show the idea:
  
  [1XA.1-1 BasisOfRowModule[0m
  
  [2X> BasisOfRowModule( [0X[3XM[0X[2X ) ____________________________________________[0Xfunction
  [6XReturns:[0X  a "basis" of the module generated by M
  
  This  procedure  computes  a  basis  by  using  the Funcod of the underlying
  computation  ring.  If the computation ring is given by Mora's Algorithm, we
  will  indeed  compute  a  local  basis.  If  we just use the global ring for
  computations,  this  will  be  a  global basis and is just computed for some
  simplifications and not for the use of reducing by it. Of course we can just
  forget about the denominator of [3XM[0m.
  
  [4X-----------------------------  Code  -----------------------------[0X
    [4XBasisOfRowModule :=[0X
    [4X  function( M )[0X
    [4X[0X
    [4X    Info([0X
    [4X      InfoLocalizeRingForHomalg,[0X
    [4X      2,[0X
    [4X      "Start BasisOfRowModule with ",[0X
    [4X      NrRows( M ), "x", NrColumns( M )[0X
    [4X    );[0X
    [4X[0X
    [4X    return HomalgLocalMatrix( BasisOfRowModule( Numerator( M ) ), HomalgRing( M ) );[0X
    [4X    [0X
    [4Xend,[0X
  [4X------------------------------------------------------------------[0X
  
  [1XA.1-2 DecideZeroRows[0m
  
  [2X> DecideZeroRows( [0X[3XA, B[0X[2X ) ___________________________________________[0Xfunction
  [6XReturns:[0X  a "reduced" form of [3XA[0m with respect to [3XB[0m
  
  This procedure just calls the DecideZeroRows of the computation ring for the
  numerator of [3XA[0m.
  
  If  we  use Mora's algorithm this procedure will just call it. The result is
  divided  by  the  denominator  of [3XA[0m afterwards. Again we do not need to care
  about the denominator of B.
  
  If  we  use  the  reduction  implemented  in  this  package,  this Funcod is
  overwritten and will not be called.
  
  [4X-----------------------------  Code  -----------------------------[0X
    [4XDecideZeroRows :=[0X
    [4X  function( A, B )[0X
    [4X    local R, ComputationRing, hook, result;[0X
    [4X    [0X
    [4X    Info([0X
    [4X      InfoLocalizeRingForHomalg,[0X
    [4X      2,[0X
    [4X      "Start DecideZeroRows with ",[0X
    [4X      NrRows( A ), "x", NrColumns( A ),[0X
    [4X      " and ",[0X
    [4X      NrRows( B ), "x", NrColumns( B )[0X
    [4X    );[0X
    [4X    [0X
    [4X    R := HomalgRing( A );[0X
    [4X    ComputationRing := AssociatedComputationRing( R );[0X
    [4X    [0X
    [4X    result := DecideZeroRows( Numerator( A ) , Numerator( B ) );[0X
    [4X    result := HomalgLocalMatrix( result, Denominator( A ) , R );[0X
    [4X    Info( InfoLocalizeRingForHomalgShowUnits, 1, "DecideZeroRows: produces denominator: ", Name( Denominator( result ) ) );[0X
    [4X    return result;[0X
    [4X[0X
    [4X  end,[0X
  [4X------------------------------------------------------------------[0X
  
  [1XA.1-3 SyzygiesGeneratorsOfRows[0m
  
  [2X> SyzygiesGeneratorsOfRows( [0X[3XM[0X[2X ) ____________________________________[0Xfunction
  [6XReturns:[0X  a  "basis"  of  the syzygies of the arguments (for details consult
            the homalg help)
  
  It  is  easy  to  see,  that a global syzygy is also a local syzygy and vice
  versa  when clearing the local Syzygy of its denominators. So this procedure
  just calls the syzygy Funcod of the underlying computation ring.
  
  [4X-----------------------------  Code  -----------------------------[0X
    [4XSyzygiesGeneratorsOfRows :=[0X
    [4X  function( M )[0X
    [4X    [0X
    [4X    Info([0X
    [4X      InfoLocalizeRingForHomalg,[0X
    [4X      2,[0X
    [4X      "Start SyzygiesGeneratorsOfRows with ",[0X
    [4X      NrRows( M ), "x", NrColumns( M )[0X
    [4X    );[0X
    [4X[0X
    [4X    return HomalgLocalMatrix(\[0X
    [4X             SyzygiesGeneratorsOfRows( Numerator( M ) ), HomalgRing( M )\[0X
    [4X           );[0X
    [4X    [0X
    [4X  end,[0X
  [4X------------------------------------------------------------------[0X
  
  
  [1XA.2 The Local Decide Zero trick[0X
  
  [1XA.2-1 DecideZeroRows[0m
  
  [2X> DecideZeroRows( [0X[3XB, A[0X[2X ) ___________________________________________[0Xfunction
  [6XReturns:[0X  a "reduced" form of [3XB[0m with respect to [3XA[0m
  
  This  procedure is the mathematical core procedure of this package. We use a
  trick to decide locally, whether [3XB[0m can be reduced to zero by [3XA[0m with a global
  computation. First a heuristic is used by just checking, whether the element
  lies  inside  the  global  module,  generated by the generators of the local
  module.  This  of  course  implies  this  for  the  local  module having the
  advantage  of  a  short  computation  time and leaving a normal form free of
  denominators. If this check fails, we use our trick to check for each row of
  [3XB[0m independently, whether it lies in the module generated by [3XB[0m.
  
  [4X-----------------------------  Code  -----------------------------[0X
    [4XDecideZeroRows :=[0X
    [4X  function( B, A )[0X
    [4X    local R, T, m, gens, n, GlobalR, one, N, b, numB, denB, i, B1, A1, B2, A2, B3;[0X
    [4X    [0X
    [4X    Info( [0X
    [4X       InfoLocalizeRingForHomalg,[0X
    [4X       2,[0X
    [4X       "Start DecideZeroRows with ",[0X
    [4X       NrRows( B ), "x", NrColumns( B ),[0X
    [4X       " and ",[0X
    [4X       NrRows( A ), "x", NrColumns( A ) [0X
    [4X    );[0X
    [4X    [0X
    [4X    R := HomalgRing( B );[0X
    [4X    GlobalR := AssociatedComputationRing( R );[0X
    [4X    T := HomalgVoidMatrix( R );[0X
    [4X    gens := GeneratorsOfMaximalLeftIdeal( R );[0X
    [4X    n := NrRows( gens );[0X
    [4X    one := One( GlobalR );[0X
    [4X    [0X
    [4X    m := NrRows( A );[0X
    [4X    A1 := Numerator( A );[0X
    [4X    [0X
    [4X    N := HomalgZeroMatrix( 0, NrColumns( B ), R );[0X
    [4X    b := Eval( B );[0X
    [4X    numB := b[1];[0X
    [4X    denB := b[2];[0X
    [4X    [0X
    [4X    for i in [ 1 .. NrRows( B ) ] do[0X
    [4X    [0X
    [4X        #use global reduction as heuristic[0X
    [4X        B1 := CertainRows( numB, [ i ] );[0X
    [4X        B2 := HomalgLocalMatrix( DecideZeroRows( B1, A1 ), R );[0X
    [4X        [0X
    [4X        #if it is nonzero, check whether local reduction makes it zero[0X
    [4X        if not IsZero( B2 ) then[0X
    [4X          A2 := UnionOfRows( A1, gens * B1 );[0X
    [4X          A2 := BasisOfRows( A2 );[0X
    [4X          B3 := HomalgLocalMatrix( DecideZeroRows( B1, A2 ), R );[0X
    [4X          if IsZero( B3 ) then[0X
    [4X            B2 := B3;[0X
    [4X          fi;[0X
    [4X        fi;[0X
    [4X        [0X
    [4X        N := UnionOfRows( N, B2 );[0X
    [4X        [0X
    [4X    od;[0X
    [4X    [0X
    [4X    N := HomalgRingElement( one, denB, R ) * N;[0X
    [4X    [0X
    [4X    Info( InfoLocalizeRingForHomalgShowUnits, 1, "DecideZeroRows: produces denominator: ", Name( Denominator( N ) ) );[0X
    [4X    [0X
    [4X    return N;[0X
    [4X    [0X
    [4X  end,[0X
  [4X------------------------------------------------------------------[0X
  
  
  [1XA.3 Tools[0X
  
  The  package [5XLocalizeRingForHomalg[0m also implements tool functions. These are
  referred  to  from  [5XMatricesForHomalg[0m automatically. We list the implemented
  methods  here  are  and  refer  to  the [5XMatricesForHomalg[0m documentation (-->
  [10X?MatricesForHomalg:       The      Matrix      Tool      Operations[0m      and
  [10X?MatricesForHomalg:RingElement[0m)   for  details.  All  tools  functions  from
  [5XMatricesForHomalg[0m not listed here are also supported by fallback tools.
  
  --    IsZero
  
  --    IsOne
  
  --    Minus
  
  --    DivideByUnit
  
  --    IsUnit
  
  --    Sum
  
  --    Product
  
  --    ShallowCopy
  
  --    ZeroMatrix
  
  --    IdentityMatrix
  
  --    AreEqualMatrices
  
  --    Involution
  
  --    CertainRows
  
  --    CertainColumns
  
  --    UnionOfRows
  
  --    UnionOfColumns
  
  --    DiagMat
  
  --    KroneckerMat
  
  --    MulMat
  
  --    AddMat
  
  --    SubMat
  
  --    Compose
  
  --    NrRows
  
  --    NrColumns
  
  --    IsZeroMatrix
  
  --    IsDiagonalMatrix
  
  --    ZeroRows
  
  --    ZeroColumns
  
