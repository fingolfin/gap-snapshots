<?xml version="1.0" encoding="UTF-8"?>

<!-- This is an automatically generated file. -->
<Chapter Label="Chapter_Morphisms">
<Heading>Morphisms</Heading>

<P/>
Any GAP object satisfying <C>IsCapCategoryMorphism</C> can be added to a category
and then becomes a morphism in this category.
Any morphism can belong to one or no category.
After a GAP object is added to the category, it knows which things can be
computed in its category and to which category it belongs.
It knows categorical properties and attributes, and the functions for existential quantifiers
can be applied to the morphism.
<Section Label="Chapter_Morphisms_Section_Attributes_for_the_Type_of_Morphisms">
<Heading>Attributes for the Type of Morphisms</Heading>

<ManSection>
  <Attr Arg="alpha" Name="CapCategory" Label="for IsCapCategoryMorphism"/>
 <Returns>a category
</Returns>
 <Description>
The argument is a morphism <Math>\alpha</Math>.
The output is the category <Math>\mathbf{C}</Math>
to which <Math>\alpha</Math> was added.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="alpha" Name="Source" Label="for IsCapCategoryMorphism"/>
 <Returns>an object
</Returns>
 <Description>
The argument is a morphism <Math>\alpha: a \rightarrow b</Math>.
The output is its source <Math>a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="alpha" Name="Range" Label="for IsCapCategoryMorphism"/>
 <Returns>an object
</Returns>
 <Description>
The argument is a morphism <Math>\alpha: a \rightarrow b</Math>.
The output is its range <Math>b</Math>.
 </Description>
</ManSection>


</Section>



<Section Label="Chapter_Morphisms_Section_Categorical_Properties_of_Morphisms">
<Heading>Categorical Properties of Morphisms</Heading>

<ManSection>
  <Oper Arg="C, F" Name="AddIsMonomorphism" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operations adds the given function <Math>F</Math>
to the category for the basic operation <C>IsMonomorphism</C>.
<Math>F: \alpha \mapsto \mathtt{IsMonomorphism}(\alpha)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddIsEpimorphism" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operations adds the given function <Math>F</Math>
to the category for the basic operation <C>IsEpimorphism</C>.
<Math>F: \alpha \mapsto \mathtt{IsEpimorphism}(\alpha)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddIsIsomorphism" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operations adds the given function <Math>F</Math>
to the category for the basic operation <C>IsIsomorphism</C>.
<Math>F: \alpha \mapsto \mathtt{IsIsomorphism}(\alpha)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddIsSplitMonomorphism" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operations adds the given function <Math>F</Math>
to the category for the basic operation <C>IsSplitMonomorphism</C>.
<Math>F: \alpha \mapsto \mathtt{IsSplitMonomorphism}(\alpha)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddIsSplitEpimorphism" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operations adds the given function <Math>F</Math>
to the category for the basic operation <C>IsSplitEpimorphism</C>.
<Math>F: \alpha \mapsto \mathtt{IsSplitEpimorphism}(\alpha)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddIsOne" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operations adds the given function <Math>F</Math>
to the category for the basic operation <C>IsOne</C>.
<Math>F: \alpha \mapsto \mathtt{IsOne}(\alpha)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddIsIdempotent" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operations adds the given function <Math>F</Math>
to the category for the basic operation <C>IsIdempotent</C>.
<Math>F: \alpha \mapsto \mathtt{IsIdempotent}(\alpha)</Math>.
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Morphisms_Section_Random_Morphisms">
<Heading>Random Morphisms</Heading>

CAP provides two principal methods to generate random morphisms with or without fixed source and range:
<List>
<Item>
<E>By integers</E>: The integer is simply a parameter that can be used to create a random morphism.
</Item>
<Item>
<E>By lists</E>: The list is used when creating a random morphism would need more than one parameter. Lists offer more
flexibility at the expense of the genericity of the methods. This happens because lists that are valid as input in
some category may be not valid for other categories. Hence, these operations are not thought to be used in
generic categorical algorithms.
</Item>
</List>
<ManSection>
  <Oper Arg="a, n" Name="RandomMorphismWithFixedSourceByInteger" Label="for IsCapCategoryObject, IsInt"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a,b)</Math> or <C>fail</C>
</Returns>
 <Description>
The arguments are an object <Math>a</Math> in a category <Math>C</Math> and an integer <Math>n</Math>.
The output is a random morphism <Math>\alpha: a \rightarrow b</Math> for some object
<Math>b</Math> in <Math>C</Math> or <C>fail</C>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddRandomMorphismWithFixedSourceByInteger" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operation adds the given function <Math>F</Math>
to the category for the basic operation <C>RandomMorphismWithFixedSourceByInteger</C>.
The function <Math>F</Math> maps <Math>(a,n)</Math> to <C>fail</C> or to a random morphism in
<Math>C</Math> whose source is <Math>a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, L" Name="RandomMorphismWithFixedSourceByList" Label="for IsCapCategoryObject, IsList"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a,b)</Math> or <C>fail</C>
</Returns>
 <Description>
The arguments are an object <Math>a</Math> in a category <Math>C</Math> and a list <Math>L</Math>.
The output is a random morphism <Math>\alpha: a \rightarrow b</Math> for some object
<Math>b</Math> in <Math>C</Math> or <C>fail</C>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddRandomMorphismWithFixedSourceByList" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operation adds the given function <Math>F</Math>
to the category for the basic operation <C>RandomMorphismWithFixedSourceByList</C>.
The function <Math>F</Math> maps <Math>(a,L)</Math> to <C>fail</C> or to a random morphism in
<Math>C</Math> whose source is <Math>a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="b, n" Name="RandomMorphismWithFixedRangeByInteger" Label="for IsCapCategoryObject, IsInt"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a,b)</Math> or <C>fail</C>
</Returns>
 <Description>
The arguments are an object <Math>b</Math> in a category <Math>C</Math> and an integer <Math>n</Math>.
The output is a random morphism <Math>\alpha: a \rightarrow b</Math> for some object
<Math>a</Math> in <Math>C</Math> or <C>fail</C>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddRandomMorphismWithFixedRangeByInteger" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operation adds the given function <Math>F</Math>
to the category for the basic operation <C>RandomMorphismWithFixedRangeByInteger</C>.
The function <Math>F</Math> maps <Math>(b,n)</Math> to <C>fail</C> or to a random morphism in
<Math>C</Math> whose range is <Math>b</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="b, L" Name="RandomMorphismWithFixedRangeByList" Label="for IsCapCategoryObject, IsList"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a,b)</Math> or <C>fail</C>
</Returns>
 <Description>
The arguments are an object <Math>b</Math> in a category <Math>C</Math> and a list <Math>L</Math>.
The output is a random morphism <Math>\alpha: a \rightarrow b</Math> for some object
<Math>a</Math> in <Math>C</Math> or <C>fail</C>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddRandomMorphismWithFixedRangeByList" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operation adds the given function <Math>F</Math>
to the category for the basic operation <C>RandomMorphismWithFixedRangeByList</C>.
The function <Math>F</Math> maps <Math>(b,L)</Math> to <C>fail</C> or to a random morphism in
<Math>C</Math> whose range is <Math>b</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b, n" Name="RandomMorphismWithFixedSourceAndRangeByInteger" Label="for IsCapCategoryObject, IsCapCategoryObject, IsInt"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a,b)</Math> or <C>fail</C>
</Returns>
 <Description>
The arguments are two objects <Math>a</Math> and <Math>b</Math> in a category <Math>C</Math> and an integer <Math>n</Math>.
The output is a random morphism <Math>\alpha: a \rightarrow b</Math> in <Math>C</Math> or <C>fail</C>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddRandomMorphismWithFixedSourceAndRangeByInteger" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operations adds the given function <Math>F</Math>
to the category for the basic operation <C>RandomMorphismWithFixedSourceAndRangeByInteger</C>.
The function <Math>F</Math> maps <Math>(a,b,n)</Math> to <C>fail</C> or to a random morphism in <Math>C</Math>
from <Math>a</Math> to <Math>b</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b, L" Name="RandomMorphismWithFixedSourceAndRangeByList" Label="for IsCapCategoryObject, IsCapCategoryObject, IsList"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a,b)</Math> or <C>fail</C>
</Returns>
 <Description>
This operation is not a CAP basic operation
The arguments are two objects <Math>a</Math> and <Math>b</Math> in a category <Math>C</Math> and a list <Math>L</Math>.
The output is a random morphism <Math>\alpha: a \rightarrow b</Math> in <Math>C</Math> or <C>fail</C>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddRandomMorphismWithFixedSourceAndRangeByList" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operations adds the given function <Math>F</Math>
to the category for the basic operation <C>RandomMorphismWithFixedSourceAndRangeByList</C>.
The function <Math>F</Math> maps <Math>(a,b,L)</Math> to <C>fail</C> or to a random morphism in <Math>C</Math>
from <Math>a</Math> to <Math>b</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, n" Name="RandomMorphismByInteger" Label="for IsCapCategory, IsInt"/>
 <Returns>a morphism or <C>fail</C>
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and an integer <Math>n</Math>.
The output is a random morphism in <Math>C</Math> or <C>fail</C>.
If the methods <C>RandomObjectByInteger</C> and
<C>RandomMorphismWithFixedSourceByInteger</C>(<C>RandomMorphismWithFixedRangeByInteger</C>)
are added to the category <Math>C</Math>, then <C>RandomMorphismByInteger</C> can be
derived to return a random morphism of complexity <Math>n</Math> with random
source(range) of complexity <Math>n</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddRandomMorphismByInteger" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operation adds the given function <Math>F</Math>
to the category for the basic operation <C>RandomMorphismByInteger</C>.
The function <Math>F</Math> maps <Math>(C,n)</Math> to <C>fail</C> or to a random morphism in <Math>C</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, L" Name="RandomMorphismByList" Label="for IsCapCategory, IsList"/>
 <Returns>a morphism or <C>fail</C>
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a list <Math>L</Math>.
The output is a random morphism in <Math>C</Math> or <C>fail</C>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddRandomMorphismByList" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operation adds the given function <Math>F</Math>
to the category for the basic operation <C>RandomMorphismByList</C>.
The function <Math>F</Math> maps <Math>(C,L)</Math> to <C>fail</C> or to a random morphism in <Math>C</Math>.
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group10">
  <Oper Arg="a, n" Name="RandomMorphismWithFixedSource" Label="for IsCapCategoryObject, IsInt"/>
  <Oper Arg="a, L" Name="RandomMorphismWithFixedSource" Label="for IsCapCategoryObject, IsList"/>
  <Oper Arg="b, n" Name="RandomMorphismWithFixedRange" Label="for IsCapCategoryObject, IsInt"/>
  <Oper Arg="b, L" Name="RandomMorphismWithFixedRange" Label="for IsCapCategoryObject, IsList"/>
  <Oper Arg="a, b, n" Name="RandomMorphismWithFixedSourceAndRange" Label="for IsCapCategoryObject, IsCapCategoryObject, IsInt"/>
  <Oper Arg="a, b, L" Name="RandomMorphismWithFixedSourceAndRange" Label="for IsCapCategoryObject, IsCapCategoryObject, IsList"/>
  <Oper Arg="C, n" Name="RandomMorphism" Label="for IsCapCategory, IsInt"/>
  <Oper Arg="C, L" Name="RandomMorphism" Label="for IsCapCategory, IsList"/>
 <Description>
These are convenient methods and they, depending on the input, delegate to one of the above methods.
<P/>
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Morphisms_Section_Non-Categorical_Properties_of_Morphisms">
<Heading>Non-Categorical Properties of Morphisms</Heading>

Non-categorical properties are not stable under equivalences of categories.
<ManSection>
  <Prop Arg="alpha" Name="IsIdenticalToIdentityMorphism" Label="for IsCapCategoryMorphism"/>
 <Returns>a boolean
</Returns>
 <Description>
The argument is a morphism <Math>\alpha: a \rightarrow b</Math>.
The output is <C>true</C> if <Math>\alpha = \mathrm{id}_a</Math>,
otherwise the output is <C>false</C>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddIsIdenticalToIdentityMorphism" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operations adds the given function <Math>F</Math>
to the category for the basic operation <C>IsIdenticalToIdentityMorphism</C>.
<Math>F: \alpha \mapsto \mathtt{IsIdenticalToIdentityMorphism}(\alpha)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Prop Arg="alpha" Name="IsIdenticalToZeroMorphism" Label="for IsCapCategoryMorphism"/>
 <Returns>a boolean
</Returns>
 <Description>
The argument is a morphism <Math>\alpha: a \rightarrow b</Math>.
The output is <C>true</C> if <Math>\alpha = 0</Math>,
otherwise the output is <C>false</C>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddIsIdenticalToZeroMorphism" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operations adds the given function <Math>F</Math>
to the category for the basic operation <C>IsIdenticalToZeroMorphism</C>.
<Math>F: \alpha \mapsto \mathtt{IsIdenticalToZeroMorphism }(\alpha)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddIsEndomorphism" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operations adds the given function <Math>F</Math>
to the category for the basic operation <C>IsEndomorphism</C>.
<Math>F: \alpha \mapsto \mathtt{IsEndomorphism}(\alpha)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddIsAutomorphism" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operations adds the given function <Math>F</Math>
to the category for the basic operation <C>IsAutomorphism</C>.
<Math>F: \alpha \mapsto \mathtt{IsAutomorphism}(\alpha)</Math>.
 </Description>
</ManSection>


</Section>


<Section Label="Section_Adding_Morphisms_to_a_Category">
<Heading>Adding Morphisms to a Category</Heading>

<ManSection>
  <Oper Arg="category, morphism" Name="Add" Label="for IsCapCategory, IsCapCategoryMorphism"/>
 <Description>
Adds <A>morphism</A> as a morphism to <A>category</A>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="category, morphism" Name="AddMorphism" Label="for IsCapCategory, IsAttributeStoringRep"/>
 <Description>
Adds <A>morphism</A> as a morphism to <A>category</A>.
If <A>morphism</A> already lies in the filter <C>IsCapCategoryMorphism</C>,
the operation <Ref Oper="Add" Label="for IsCapCategory, IsCapCategoryMorphism" />
can be used instead.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="category, filter" Name="AddMorphismRepresentation" Label="for IsCapCategory, IsObject"/>
 <Description>
The argument <A>filter</A> is used to create a morphism type for the
category <A>category</A>, which is then used in <C>ObjectifyMorphismForCAPWithAttributes</C>
to objectify morphisms for this category.
 </Description>
</ManSection>


<ManSection>
  <Func Arg="morphism, category, [attribute1, value1, ...]" Name="ObjectifyMorphismForCAPWithAttributes" />
 <Description>
Objectifies the morphism <A>morphism</A> with the type created
for morphisms in the category <A>category</A>. The type
is created by passing a representation to <C>AddMorphismRepresentation</C>.
Morphisms which are objectified using this method do not have to be passed
to the <C>AddMorphism</C> function.
<P/>
Please note that the <C>Source</C> and <C>Range</C> attribute need to be passed to
this function. The values belonging to these attrbutes will not be objectified.
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Morphisms_Section_Equality_and_Congruence_for_Morphisms">
<Heading>Equality and Congruence for Morphisms</Heading>

<ManSection>
  <Oper Arg="alpha, beta" Name="IsCongruentForMorphisms" Label="for IsCapCategoryMorphism, IsCapCategoryMorphism"/>
 <Returns>a boolean
</Returns>
 <Description>
The arguments are two morphisms <Math>\alpha, \beta: a \rightarrow b</Math>.
The output is <C>true</C> if <Math>\alpha \sim_{a,b} \beta</Math>,
otherwise the output is <C>false</C>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddIsCongruentForMorphisms" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operations adds the given function <Math>F</Math>
to the category for the basic operation <C>IsCongruentForMorphisms</C>.
<Math>F: (\alpha, \beta) \mapsto \mathtt{IsCongruentForMorphisms}(\alpha, \beta)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="alpha, beta" Name="IsEqualForMorphisms" Label="for IsCapCategoryMorphism, IsCapCategoryMorphism"/>
 <Returns>a boolean
</Returns>
 <Description>
The arguments are two morphisms <Math>\alpha, \beta: a \rightarrow b</Math>.
The output is <C>true</C> if <Math>\alpha = \beta</Math>,
otherwise the output is <C>false</C>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddIsEqualForMorphisms" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operations adds the given function <Math>F</Math>
to the category for the basic operation <C>IsEqualForMorphisms</C>.
<Math>F: (\alpha, \beta) \mapsto \mathtt{IsEqualForMorphisms}(\alpha, \beta)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="alpha, beta" Name="IsEqualForMorphismsOnMor" Label="for IsCapCategoryMorphism, IsCapCategoryMorphism"/>
 <Returns>a boolean
</Returns>
 <Description>
The arguments are two morphisms <Math>\alpha: a \rightarrow b, \beta: c \rightarrow d</Math>.
The output is <C>true</C> if <Math>\alpha = \beta</Math>,
otherwise the output is <C>false</C>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddIsEqualForMorphismsOnMor" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operations adds the given function <Math>F</Math>
to the category for the basic operation <C>IsEqualForMorphismsOnMor</C>.
<Math>F: (\alpha, \beta) \mapsto \mathtt{IsEqualForMorphismsOnMor}(\alpha, \beta)</Math>.
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Morphisms_Section_Basic_Operations_for_Morphisms_in_Ab-Categories">
<Heading>Basic Operations for Morphisms in Ab-Categories</Heading>

<ManSection>
  <Prop Arg="alpha" Name="IsZeroForMorphisms" Label="for IsCapCategoryMorphism"/>
 <Returns>a boolean
</Returns>
 <Description>
The argument is a morphism <Math>\alpha: a \rightarrow b</Math>.
The output is <C>true</C> if <Math>\alpha \sim_{a,b} 0</Math>,
otherwise the output is <C>false</C>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddIsZeroForMorphisms" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operations adds the given function <Math>F</Math>
to the category for the basic operation <C>IsZeroForMorphisms</C>.
<Math>F: \alpha \mapsto \mathtt{IsZeroForMorphisms}(\alpha)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="alpha, beta" Name="AdditionForMorphisms" Label="for IsCapCategoryMorphism, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a,b)</Math>
</Returns>
 <Description>
The arguments are two morphisms <Math>\alpha, \beta: a \rightarrow b</Math>.
The output is the addition <Math>\alpha + \beta</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddAdditionForMorphisms" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operations adds the given function <Math>F</Math>
to the category for the basic operation <C>AdditionForMorphisms</C>.
<Math>F: (\alpha, \beta) \mapsto \alpha + \beta</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="alpha, beta" Name="SubtractionForMorphisms" Label="for IsCapCategoryMorphism, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a,b)</Math>
</Returns>
 <Description>
The arguments are two morphisms <Math>\alpha, \beta: a \rightarrow b</Math>.
The output is the addition <Math>\alpha - \beta</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddSubtractionForMorphisms" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operations adds the given function <Math>F</Math>
to the category for the basic operation <C>SubtractionForMorphisms</C>.
<Math>F: (\alpha, \beta) \mapsto \alpha - \beta</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="alpha" Name="AdditiveInverseForMorphisms" Label="for IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a,b)</Math>
</Returns>
 <Description>
The argument is a morphism <Math>\alpha: a \rightarrow b</Math>.
The output is its additive inverse <Math>-\alpha</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddAdditiveInverseForMorphisms" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operations adds the given function <Math>F</Math>
to the category for the basic operation <C>AdditiveInverseForMorphisms</C>.
<Math>F: \alpha \mapsto -\alpha</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="r, alpha" Name="MultiplyWithElementOfCommutativeRingForMorphisms" Label="for IsRingElement, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a,b)</Math>
</Returns>
 <Description>
The arguments are an element <Math>r</Math> of a commutative ring
and a morphism <Math>\alpha: a \rightarrow b</Math>.
The output is the multiplication with the ring element <Math>r \cdot \alpha</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddMultiplyWithElementOfCommutativeRingForMorphisms" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operations adds the given function <Math>F</Math>
to the category for the basic operation <C>MultiplyWithElementOfCommutativeRingForMorphisms</C>.
<Math>F: (r, \alpha) \mapsto r \cdot \alpha</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b" Name="ZeroMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a,b)</Math>
</Returns>
 <Description>
The arguments are two objects <Math>a</Math> and <Math>b</Math>.
The output is the zero morphism <Math>0: a \rightarrow b</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddZeroMorphism" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operations adds the given function <Math>F</Math>
to the category for the basic operation <C>ZeroMorphism</C>.
<Math>F: (a,b) \mapsto (0: a \rightarrow b)</Math>.
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Morphisms_Section_Subobject_and_Factorobject_Operations">
<Heading>Subobject and Factorobject Operations</Heading>

Subobjects of an object <Math>c</Math> are monomorphisms
with range <Math>c</Math> and a special function for comparision.
Similarly, factorobjects of an object <Math>c</Math> are epimorphisms
with source <Math>c</Math> and a special function for comparision.
<ManSection>
  <Oper Arg="alpha, beta" Name="IsEqualAsSubobjects" Label="for IsCapCategoryMorphism, IsCapCategoryMorphism"/>
 <Returns>a boolean
</Returns>
 <Description>
The arguments are two subobjects <Math>\alpha: a \rightarrow c</Math>, <Math>\beta: b \rightarrow c</Math>.
The output is <C>true</C> if there exists an isomorphism <Math>\iota: a \rightarrow b</Math>
such that <Math>\beta \circ \iota \sim_{a,c} \alpha</Math>,
otherwise the output is <C>false</C>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddIsEqualAsSubobjects" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operations adds the given function <Math>F</Math>
to the category for the basic operation <C>IsEqualAsSubobjects</C>.
<Math>F: (\alpha, \beta) \mapsto \mathtt{IsEqualAsSubobjects}(\alpha,\beta)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="alpha, beta" Name="IsEqualAsFactorobjects" Label="for IsCapCategoryMorphism, IsCapCategoryMorphism"/>
 <Returns>a boolean
</Returns>
 <Description>
The arguments are two factorobjects <Math>\alpha: c \rightarrow a</Math>, <Math>\beta: c \rightarrow b</Math>.
The output is <C>true</C> if there exists an isomorphism <Math>\iota: b \rightarrow a</Math>
such that <Math>\iota \circ \beta \sim_{c,a} \alpha</Math>,
otherwise the output is <C>false</C>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddIsEqualAsFactorobjects" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operations adds the given function <Math>F</Math>
to the category for the basic operation <C>IsEqualAsFactorobjects</C>.
<Math>F: (\alpha, \beta) \mapsto \mathtt{IsEqualAsFactorobjects}(\alpha,\beta)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="alpha, beta" Name="IsDominating" Label="for IsCapCategoryMorphism, IsCapCategoryMorphism"/>
 <Returns>a boolean
</Returns>
 <Description>
<Alt Only="LaTeX"><![CDATA[
\begin{center}
\begin{tikzpicture}
\def\w{2};
\def\h{1};
\node (a) at (0,\h) {$a$};
\node (b) at (0,-\h) {$b$};
\node (c) at (\w,0) {$c$};
\draw[right hook-latex] (a) to node[pos=0.45, above] {$\alpha$} (c);
\draw[right hook-latex] (b) to node[pos=0.45, below] {$\beta$} (c);
\draw[-latex, dashed] (a) to node[pos=0.45, left] {$\exists \iota$} (b);
\end{tikzpicture}
\end{center}
]]></Alt>
In short: Returns <C>true</C> iff <Math>\alpha</Math> is smaller than <Math>\beta</Math>.
Full description: The arguments are two subobjects <Math>\alpha: a \rightarrow c</Math>, <Math>\beta: b \rightarrow c</Math>.
The output is <C>true</C> if there exists a morphism <Math>\iota: a \rightarrow b</Math>
such that <Math>\beta \circ \iota \sim_{a,c} \alpha</Math>,
otherwise the output is <C>false</C>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddIsDominating" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operations adds the given function <Math>F</Math>
to the category for the basic operation <C>IsDominating</C>.
<Math>F: (\alpha, \beta) \mapsto \mathtt{IsDominating}(\alpha,\beta)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="alpha, beta" Name="IsCodominating" Label="for IsCapCategoryMorphism, IsCapCategoryMorphism"/>
 <Returns>a boolean
</Returns>
 <Description>
<Alt Only="LaTeX"><![CDATA[
\begin{center}
\begin{tikzpicture}
\def\w{2};
\def\h{1};
\node (c) at (0,0) {$c$};
\node (a) at (\w,\h) {$a$};
\node (b) at (\w,-\h) {$b$};
\draw[-twohead] (c) to node[pos=0.45, above] {$\alpha$} (a);
\draw[-twohead] (c) to node[pos=0.45, below] {$\beta$} (b);
\draw[-latex, dashed] (b) to node[pos=0.45, right] {$\exists \iota$} (a);
\end{tikzpicture}
\end{center}
]]></Alt>
In short: Returns <C>true</C> iff <Math>\alpha</Math> is smaller than <Math>\beta</Math>.
Full description:
The arguments are two factorobjects <Math>\alpha: c \rightarrow a</Math>, <Math>\beta: c \rightarrow b</Math>.
The output is <C>true</C> if there exists a morphism <Math>\iota: b \rightarrow a</Math>
such that <Math>\iota \circ \beta \sim_{c,a} \alpha</Math>,
otherwise the output is <C>false</C>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddIsCodominating" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operations adds the given function <Math>F</Math>
to the category for the basic operation <C>IsCodominating</C>.
<Math>F: (\alpha, \beta) \mapsto \mathtt{IsCodominating}(\alpha,\beta)</Math>.
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Morphisms_Section_Identity_Morphism_and_Composition_of_Morphisms">
<Heading>Identity Morphism and Composition of Morphisms</Heading>

<ManSection>
  <Attr Arg="a" Name="IdentityMorphism" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a,a)</Math>
</Returns>
 <Description>
The argument is an object <Math>a</Math>.
The output is its identity morphism <Math>\mathrm{id}_a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddIdentityMorphism" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operations adds the given function <Math>F</Math>
to the category for the basic operation <C>IdentityMorphism</C>.
<Math>F: a \mapsto \mathrm{id}_a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="alpha, beta" Name="PreCompose" Label="for IsCapCategoryMorphism, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a, c )</Math>
</Returns>
 <Description>
The arguments are two morphisms <Math>\alpha: a \rightarrow b</Math>, <Math>\beta: b \rightarrow c</Math>.
The output is the composition <Math>\beta \circ \alpha: a \rightarrow c</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="L" Name="PreCompose" Label="for IsList"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a_1, a_{n+1})</Math>
</Returns>
 <Description>
This is a convenience method.
The argument is a list of morphisms
<Math>L = ( \alpha_1: a_1 \rightarrow a_2, \alpha_2: a_2 \rightarrow a_3, \dots, \alpha_n: a_n \rightarrow a_{n+1} )</Math>.
The output is the composition
<Math>\alpha_{n} \circ ( \alpha_{n-1} \circ ( \dots ( \alpha_2 \circ \alpha_1 ) ) )</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddPreCompose" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operations adds the given function <Math>F</Math>
to the category for the basic operation <C>PreCompose</C>.
<Math>F: (\alpha, \beta) \mapsto \beta \circ \alpha</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="beta, alpha" Name="PostCompose" Label="for IsCapCategoryMorphism, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a, c )</Math>
</Returns>
 <Description>
The arguments are two morphisms <Math>\beta: b \rightarrow c</Math>, <Math>\alpha: a \rightarrow b</Math>.
The output is the composition <Math>\beta \circ \alpha: a \rightarrow c</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="L" Name="PostCompose" Label="for IsList"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a_1, a_{n+1})</Math>
</Returns>
 <Description>
This is a convenience method.
The argument is a list of morphisms
<Math>L = ( \alpha_n: a_n \rightarrow a_{n+1}, \alpha_{n-1}: a_{n-1} \rightarrow a_n, \dots, \alpha_1: a_1 \rightarrow a_2 )</Math>.
The output is the composition
<Math>((\alpha_{n} \circ \alpha_{n-1}) \circ \dots \alpha_2) \circ \alpha_1</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddPostCompose" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operations adds the given function <Math>F</Math>
to the category for the basic operation <C>PostCompose</C>.
<Math>F: (\alpha, \beta) \mapsto \alpha \circ \beta</Math>.
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Morphisms_Section_Well-Definedness_of_Morphisms">
<Heading>Well-Definedness of Morphisms</Heading>

<ManSection>
  <Oper Arg="alpha" Name="IsWellDefinedForMorphisms" Label="for IsCapCategoryMorphism"/>
 <Returns>a boolean
</Returns>
 <Description>
The argument is a morphism <Math>\alpha</Math>.
The output is <C>true</C> if <Math>\alpha</Math> is well-defined,
otherwise the output is <C>false</C>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddIsWellDefinedForMorphisms" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operations adds the given function <Math>F</Math>
to the category for the basic operation <C>IsWellDefinedForMorphisms</C>.
<Math>F: \alpha \mapsto \mathtt{IsWellDefinedForMorphisms}( \alpha )</Math>.
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Morphisms_Section_LiftColift">
<Heading>Lift/Colift</Heading>

<List>
<Item>
For any pair of morphisms <Math>\alpha: a \rightarrow c</Math>, <Math>\beta: b \rightarrow c</Math>,
we call each morphism <Math>\alpha / \beta: a \rightarrow b</Math> such that
<Math>\beta \circ (\alpha / \beta) \sim_{a,c} \alpha</Math> a <Emph>lift of <Math>\alpha</Math> along <Math>\beta</Math></Emph>.
<Alt Only="LaTeX"><![CDATA[
\begin{center}
\begin{tikzpicture}
\def\w{2};
\def\h{1};
\node (a) at (0,\h) {$a$};
\node (b) at (0,-\h) {$b$};
\node (c) at (\w,0) {$c$};
\draw[-latex] (a) to node[pos=0.45, above] {$\alpha$} (c);
\draw[-latex] (b) to node[pos=0.45, below] {$\beta$} (c);
\draw[-latex, dashed] (a) to node[pos=0.45, left] {$\alpha/\beta$} (b);
\end{tikzpicture}
\end{center}
]]></Alt>
</Item>
<Item>
For any pair of morphisms <Math>\alpha: a \rightarrow c</Math>, <Math>\beta: a \rightarrow b</Math>,
we call each morphism <Math>\alpha \backslash \beta: c \rightarrow b</Math> such that
<Math>(\alpha \backslash \beta) \circ \alpha \sim_{a,b} \beta</Math> a <Emph> colift of <Math>\beta</Math> along <Math>\alpha</Math></Emph>.
<Alt Only="LaTeX"><![CDATA[
\begin{center}
\begin{tikzpicture}
\def\w{2};
\def\h{1};
\node (a) at (0,0) {$a$};
\node (c) at (\w,\h) {$c$};
\node (b) at (\w,-\h) {$b$};
\draw[-latex] (a) to node[pos=0.45, above] {$\alpha$} (c);
\draw[-latex] (a) to node[pos=0.45, below] {$\beta$} (b);
\draw[-latex, dashed] (c) to node[pos=0.45, right] {$\alpha \backslash \beta$} (b);
\end{tikzpicture}
\end{center}
]]></Alt>
</Item>
</List>
Note that such lifts (or colifts) do not have to be unique. So in general,
we do not expect that algorithms computing lifts (or colifts) do this in a functorial way.
Thus the operations <Math>\mathtt{Lift}</Math> and <Math>\mathtt{Colift}</Math> are not regarded as
categorical operations, but only as set-theoretic operations.
<ManSection>
  <Oper Arg="iota, tau" Name="LiftAlongMonomorphism" Label="for IsCapCategoryMorphism, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(t,k)</Math>
</Returns>
 <Description>
The arguments are a monomorphism <Math>\iota: k \hookrightarrow a</Math>
and a morphism <Math>\tau: t \rightarrow a</Math>
such that there is a morphism <Math>u: t \rightarrow k</Math> with
<Math>\iota \circ u \sim_{t,a} \tau</Math>.
The output is such a <Math>u</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddLiftAlongMonomorphism" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operations adds the given function <Math>F</Math>
to the category for the basic operation <C>LiftAlongMonomorphism</C>.
The function <Math>F</Math> maps a pair <Math>(\iota, \tau)</Math> to a lift <Math>u</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="epsilon, tau" Name="ColiftAlongEpimorphism" Label="for IsCapCategoryMorphism, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(c,t)</Math>
</Returns>
 <Description>
The arguments are an epimorphism <Math>\epsilon: a \rightarrow c</Math>
and a morphism <Math>\tau: a \rightarrow t</Math>
such that there is a morphism <Math>u: c \rightarrow t</Math> with
<Math>u \circ \epsilon \sim_{a,t} \tau</Math>.
The output is such a <Math>u</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddColiftAlongEpimorphism" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operations adds the given function <Math>F</Math>
to the category for the basic operation <C>ColiftAlongEpimorphism</C>.
The function <Math>F</Math> maps a pair <Math>(\epsilon, \tau)</Math> to a lift <Math>u</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="iota, tau" Name="IsLiftableAlongMonomorphism" Label="for IsCapCategoryMorphism, IsCapCategoryMorphism"/>
 <Returns>a boolean
</Returns>
 <Description>
The arguments are a monomorphism <Math>\iota: k \hookrightarrow a</Math>
and a morphism <Math>\tau: t \rightarrow a</Math>.
The output is <C>true</C> if there exists
a morphism <Math>u: t \rightarrow k</Math> with
<Math>\iota \circ u \sim_{t,a} \tau</Math>.
Otherwise, the output is <C>false</C>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddIsLiftableAlongMonomorphism" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operations adds the given function <Math>F</Math>
to the category for the basic operation <C>IsLiftableAlongMonomorphism</C>.
<Math>F: (\iota, \tau) \mapsto \texttt{IsLiftableAlongMonomorphism}( \iota, \tau )</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="epsilon, tau" Name="IsColiftableAlongEpimorphism" Label="for IsCapCategoryMorphism, IsCapCategoryMorphism"/>
 <Returns>a boolean
</Returns>
 <Description>
The arguments are an epimorphism <Math>\epsilon: a \rightarrow c</Math>
and a morphism <Math>\tau: a \rightarrow t</Math>.
The output is <C>true</C> if there exists
a morphism <Math>u: c \rightarrow t</Math> with
<Math>u \circ \epsilon \sim_{a,t} \tau</Math>.
Otherwise, the output is <C>false</C>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddIsColiftableAlongEpimorphism" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operations adds the given function <Math>F</Math>
to the category for the basic operation <C>IsColiftableAlongEpimorphism</C>.
<Math>F: (\epsilon, \tau) \mapsto \texttt{IsColiftableAlongEpimorphism}( \epsilon, \tau )</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="alpha, beta" Name="Lift" Label="for IsCapCategoryMorphism, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a,b) + \{ \mathtt{fail} \}</Math>
</Returns>
 <Description>
The arguments are two morphisms <Math>\alpha: a \rightarrow c</Math>, <Math>\beta: b \rightarrow c</Math>.
The output is a lift <Math>\alpha / \beta: a \rightarrow b</Math> of <Math>\alpha</Math> along <Math>\beta</Math>
if such a lift exists or <Math>\mathtt{fail}</Math> if it doesn't.
Recall that a lift <Math>\alpha / \beta: a \rightarrow b</Math> of <Math>\alpha</Math> along <Math>\beta</Math> is
a morphism such that <Math>\beta \circ (\alpha / \beta) \sim_{a,c} \alpha</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddLift" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operations adds the given function <Math>F</Math>
to the category for the basic operation <C>Lift</C>.
The function <Math>F</Math> maps a pair <Math>(\alpha, \beta)</Math> to a lift <Math>\alpha / \beta</Math> if it
exists, and to <C>fail</C> otherwise.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="alpha, beta" Name="Colift" Label="for IsCapCategoryMorphism, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(c,b) + \{ \mathtt{fail} \}</Math>
</Returns>
 <Description>
The arguments are two morphisms <Math>\alpha: a \rightarrow c</Math>, <Math>\beta: a \rightarrow b</Math>.
The output is a colift <Math>\alpha \backslash \beta: c \rightarrow b</Math> of <Math>\beta</Math> along <Math>\alpha</Math>
if such a colift exists or <Math>\mathtt{fail}</Math> if it doesn't.
Recall that a colift <Math>\alpha \backslash \beta: c \rightarrow b</Math> of <Math>\beta</Math> along <Math>\alpha</Math> is
a morphism such that <Math>(\alpha \backslash \beta) \circ \alpha \sim_{a,b} \beta</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddColift" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operations adds the given function <Math>F</Math>
to the category for the basic operation <C>Colift</C>.
The function <Math>F</Math> maps a pair <Math>(\alpha, \beta)</Math> to a colift <Math>\alpha \backslash \beta</Math> if it
exists, and to <C>fail</C> otherwise.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="alpha, beta" Name="IsLiftable" Label="for IsCapCategoryMorphism, IsCapCategoryMorphism"/>
 <Returns>a boolean
</Returns>
 <Description>
The arguments are two morphisms <Math>\alpha: a \rightarrow c</Math>, <Math>\beta: b \rightarrow c</Math>.
The output is <C>true</C> if there exists
a lift <Math>\alpha / \beta: a \rightarrow b</Math> of <Math>\alpha</Math> along <Math>\beta</Math>, i.e.,
a morphism such that <Math>\beta \circ (\alpha / \beta) \sim_{a,c} \alpha</Math>.
Otherwise, the output is <C>false</C>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddIsLiftable" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operations adds the given function <Math>F</Math>
to the category for the basic operation <C>IsLiftable</C>.
<Math>F: ( \alpha, \beta ) \mapsto \mathtt{IsLiftable}( \alpha, \beta )</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="alpha, beta" Name="IsColiftable" Label="for IsCapCategoryMorphism, IsCapCategoryMorphism"/>
 <Returns>a boolean
</Returns>
 <Description>
The arguments are two morphisms <Math>\alpha: a \rightarrow c</Math>, <Math>\beta: a \rightarrow b</Math>.
The output is <C>true</C> if there exists
a colift <Math>\alpha \backslash \beta: c \rightarrow b</Math> of <Math>\beta</Math> along <Math>\alpha</Math>., i.e.,
a morphism such that <Math>(\alpha \backslash \beta) \circ \alpha \sim_{a,b} \beta</Math>.
Otherwise, the output is <C>false</C>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddIsColiftable" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operations adds the given function <Math>F</Math>
to the category for the basic operation <C>IsColiftable</C>.
<Math>F: ( \alpha, \beta ) \mapsto \mathtt{IsColiftable}( \alpha, \beta )</Math>.
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Morphisms_Section_Inverses">
<Heading>Inverses</Heading>

Let <Math>\alpha: a \rightarrow b</Math> be a morphism. An inverse of <Math>\alpha</Math>
is a morphism <Math>\alpha^{-1}: b \rightarrow a</Math> such that
<Math>\alpha \circ \alpha^{-1} \sim_{b,b} \mathrm{id}_b</Math>
and <Math>\alpha^{-1} \circ \alpha \sim_{a,a} \mathrm{id}_a</Math>.
<Alt Only="LaTeX"><![CDATA[
\begin{center}
\begin{tikzpicture}
\def\w{2};
\def\h{1};
\node (a) at (0,0) {$a$};
\node (b) at (\w,0) {$b$};
\draw[-latex] (a) to node[pos=0.45, above] {$\alpha$} (b);
\draw[-latex] (b) to [out = -135, in = -45] node[pos=0.45, below] {$\alpha^{-1}$} (a);
\draw [-latex] (a.135) arc (45:45+280:4mm) node[pos=0.5,left] {$\mathrm{id}_a$} (a);
\draw [-latex] (b.45) arc (-240:-240-280:4mm) node[pos=0.5,right] {$\mathrm{id}_b$} (b);
\end{tikzpicture}
\end{center}
]]></Alt>
<ManSection>
  <Oper Arg="C, F" Name="AddInverse" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operations adds the given function <Math>F</Math>
to the category for the basic operation <C>Inverse</C>.
<Math>F: \alpha \mapsto \alpha^{-1}</Math>.
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Morphisms_Section_Tool_functions_for_caches">
<Heading>Tool functions for caches</Heading>

<ManSection>
  <Oper Arg="phi, psi" Name="IsEqualForCacheForMorphisms" Label="for IsCapCategoryMorphism, IsCapCategoryMorphism"/>
 <Returns>true or false
</Returns>
 <Description>
Compares two objects in the cache
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="c,F" Name="AddIsEqualForCacheForMorphisms" Label="for IsCapCategory, IsFunction"/>
 <Returns>northing
</Returns>
 <Description>
By default, CAP uses caches to store the values of Categorical operations.
To get a value out of the cache, one needs to compare the input of a basic operation
with its previous input. To compare morphisms in the category, IsEqualForCacheForMorphism is
used. By default this is an alias for IsEqualForMorphismsOnMor, where fail is substituted by false.
If you add a function, this function
used instead. A function <Math>F: a,b \mapsto bool</Math> is expected here. The output has to be
true or false. Fail is not allowed in this context.
 </Description>
</ManSection>


</Section>



<Section Label="Chapter_Morphisms_Section_Homomorphism_structures">
<Heading>Homomorphism structures</Heading>

Homomorphism structures are way to "oversee" the homomorphisms between two given objects.
Let <Math>C</Math>, <Math>D</Math> be categories.
A <Math>D</Math>-homomorphism structure for <Math>C</Math> consists of the following data:
<List>
<Item>
a functor <Math>H: C^{\mathrm{op}} \times C \rightarrow D</Math> (when <Math>C</Math> and <Math>D</Math> are Ab-categories, <Math>H</Math> is assumed to be bilinear).
</Item>
<Item>
an object <Math>1 \in D</Math>, called the distinguished object,
</Item>
<Item>
a bijection <Math>\nu: \mathrm{Hom}_{C}(a,b) \simeq \mathrm{Hom}_{D}(1, H(a,b))</Math> natural in <Math>a,b \in C</Math>.
</Item>
</List>
<ManSection>
  <Oper Arg="a,b" Name="HomomorphismStructureOnObjects" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>an object in <Math>D</Math>
</Returns>
 <Description>
The arguments are two objects <Math>a, b</Math> in <Math>C</Math>.
The output is the value of the homomorphism structure on objects <Math>H(a,b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddHomomorphismStructureOnObjects" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operations adds the given function <Math>F</Math>
to the category for the basic operation <C>HomomorphismStructureOnObjects</C>.
<Math>F: (a,b) \mapsto H(a,b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="alpha, beta" Name="HomomorphismStructureOnMorphisms" Label="for IsCapCategoryMorphism, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}_{D}(H(a',b), H(a,b'))</Math>
</Returns>
 <Description>
The arguments are two morphisms <Math>\alpha: a \rightarrow a', \beta: b \rightarrow b'</Math> in <Math>C</Math>.
The output is the value of the homomorphism structure on morphisms <Math>H(\alpha, \beta )</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s, alpha, beta, r" Name="HomomorphismStructureOnMorphismsWithGivenObjects" Label="for IsCapCategoryObject, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}_{D}(H(a',b), H(a,b'))</Math>
</Returns>
 <Description>
The arguments are an object <Math>s = H(a',b)</Math> in <Math>D</Math>,
two morphisms <Math>\alpha: a \rightarrow a', \beta: b \rightarrow b'</Math> in <Math>C</Math>,
and an object <Math>r = H(a,b')</Math> in <Math>D</Math>.
The output is the value of the homomorphism structure on morphisms <Math>H(\alpha, \beta )</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddHomomorphismStructureOnMorphismsWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operations adds the given function <Math>F</Math>
to the category for the basic operation <C>HomomorphismStructureOnMorphismsWithGivenObjects</C>.
<Math>F: ( s, \alpha: a \rightarrow a', \beta: b \rightarrow b', r ) \mapsto H( \alpha, \beta )</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="C" Name="DistinguishedObjectOfHomomorphismStructure" Label="for IsCapCategory"/>
 <Returns>an object in <Math>D</Math>
</Returns>
 <Description>
The argument is a category <Math>C</Math>.
The output is the distinguished object <Math>1</Math> in <Math>D</Math> of the homomorphism structure.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddDistinguishedObjectOfHomomorphismStructure" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operations adds the given function <Math>F</Math>
to the category for the basic operation <C>DistinguishedObjectOfHomomorphismStructure</C>.
<Math>F: ( ) \mapsto 1</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="alpha" Name="InterpretMorphismAsMorphismFromDinstinguishedObjectToHomomorphismStructure" Label="for IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}_{D}(1, H(a,a'))</Math>
</Returns>
 <Description>
The argument is a morphism <Math>\alpha: a \rightarrow a'</Math> in <Math>C</Math>.
The output is the corresponding morphism
<Math>\nu( \alpha ): 1 \rightarrow H(a,a')</Math> in <Math>D</Math> of the homomorphism structure.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddInterpretMorphismAsMorphismFromDinstinguishedObjectToHomomorphismStructure" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operations adds the given function <Math>F</Math>
to the category for the basic operation <C>InterpretMorphismAsMorphismFromDinstinguishedObjectToHomomorphismStructure</C>.
<Math>F: (\alpha: a \rightarrow a') \mapsto (\nu(\alpha):1 \rightarrow H(a,a'))</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,a',iota" Name="InterpretMorphismFromDinstinguishedObjectToHomomorphismStructureAsMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}_{C}(a,a')</Math>
</Returns>
 <Description>
The arguments are
objects <Math>a,a'</Math> in <Math>C</Math>
and a morphism <Math>\iota: 1 \rightarrow H(a,a')</Math> in <Math>D</Math>.
The output is the corresponding morphism
<Math>\nu^{-1}(\iota): a \rightarrow a'</Math> in <Math>C</Math> of the homomorphism structure.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddInterpretMorphismFromDinstinguishedObjectToHomomorphismStructureAsMorphism" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
This operations adds the given function <Math>F</Math>
to the category for the basic operation <C>InterpretMorphismFromDinstinguishedObjectToHomomorphismStructureAsMorphism</C>.
<Math>F: (a,a',\iota: 1 \rightarrow H(a,a')) \mapsto (\nu^{-1}(\iota): a \rightarrow a')</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="alpha, beta, gamma" Name="SolveLinearSystemInAbCategory" Label="for IsList, IsList, IsList"/>
 <Returns>a list of morphisms <Math>[X_1, \dots, X_n]</Math>
</Returns>
 <Description>
The arguments are three lists <Math>\alpha</Math>, <Math>\beta</Math>, and <Math>\gamma</Math>.
The first list <Math>\alpha</Math> (the left coefficients) is a list of list of morphisms <Math>\alpha_{ij}: A_i \rightarrow B_j</Math>,
where <Math>i = 1 \dots m</Math> and <Math>j = 1 \dots n</Math> for integers <Math>m,n \geq 1</Math>.
The second list <Math>\beta</Math> (the right coefficients) is a list of list of morphisms <Math>\beta_{ij}: C_j \rightarrow D_i</Math>,
where <Math>i = 1 \dots m</Math> and <Math>j = 1 \dots n</Math>.
The third list <Math>\gamma</Math> (the right side) is a list of morphisms <Math>\gamma_i: A_i \rightarrow D_i</Math>,
where <Math>i = 1, \dots, m</Math>.
The output is either
a list of morphisms <Math>X_j: B_j \rightarrow C_j</Math> for <Math>j=1\dots n</Math> solving the linear system
defined by <Math>\alpha</Math>, <Math>\beta</Math>, <Math>\gamma</Math>, i.e.,
<Math>\sum_{j = 1}^n \alpha_{ij}\cdot X_j \cdot \beta_{ij} = \gamma_i</Math>
for all <Math>i = 1 \dots m</Math>,
or <Math>\texttt{fail}</Math> if no such solution exists.
 </Description>
</ManSection>


</Section>


</Chapter>

