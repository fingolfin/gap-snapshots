% generated by GAPDoc2LaTeX from XML source (Frank Luebeck)
\documentclass[a4paper,11pt]{report}

\usepackage{a4wide}
\sloppy
\pagestyle{myheadings}
\usepackage{amssymb}
\usepackage[latin1]{inputenc}
\usepackage{makeidx}
\makeindex
\usepackage{color}
\definecolor{FireBrick}{rgb}{0.5812,0.0074,0.0083}
\definecolor{RoyalBlue}{rgb}{0.0236,0.0894,0.6179}
\definecolor{RoyalGreen}{rgb}{0.0236,0.6179,0.0894}
\definecolor{RoyalRed}{rgb}{0.6179,0.0236,0.0894}
\definecolor{LightBlue}{rgb}{0.8544,0.9511,1.0000}
\definecolor{Black}{rgb}{0.0,0.0,0.0}

\definecolor{linkColor}{rgb}{0.0,0.0,0.554}
\definecolor{citeColor}{rgb}{0.0,0.0,0.554}
\definecolor{fileColor}{rgb}{0.0,0.0,0.554}
\definecolor{urlColor}{rgb}{0.0,0.0,0.554}
\definecolor{promptColor}{rgb}{0.0,0.0,0.589}
\definecolor{brkpromptColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapinputColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapoutputColor}{rgb}{0.0,0.0,0.0}

%%  for a long time these were red and blue by default,
%%  now black, but keep variables to overwrite
\definecolor{FuncColor}{rgb}{0.0,0.0,0.0}
%% strange name because of pdflatex bug:
\definecolor{Chapter }{rgb}{0.0,0.0,0.0}
\definecolor{DarkOlive}{rgb}{0.1047,0.2412,0.0064}


\usepackage{fancyvrb}

\usepackage{mathptmx,helvet}
\usepackage[T1]{fontenc}
\usepackage{textcomp}


\usepackage[
            pdftex=true,
            bookmarks=true,        
            a4paper=true,
            pdftitle={Written with GAPDoc},
            pdfcreator={LaTeX with hyperref package / GAPDoc},
            colorlinks=true,
            backref=page,
            breaklinks=true,
            linkcolor=linkColor,
            citecolor=citeColor,
            filecolor=fileColor,
            urlcolor=urlColor,
            pdfpagemode={UseNone}, 
           ]{hyperref}

\newcommand{\maintitlesize}{\fontsize{50}{55}\selectfont}

% write page numbers to a .pnr log file for online help
\newwrite\pagenrlog
\immediate\openout\pagenrlog =\jobname.pnr
\immediate\write\pagenrlog{PAGENRS := [}
\newcommand{\logpage}[1]{\protect\write\pagenrlog{#1, \thepage,}}
%% were never documented, give conflicts with some additional packages

\newcommand{\GAP}{\textsf{GAP}}

%% nicer description environments, allows long labels
\usepackage{enumitem}
\setdescription{style=nextline}

%% depth of toc
\setcounter{tocdepth}{1}





%% command for ColorPrompt style examples
\newcommand{\gapprompt}[1]{\color{promptColor}{\bfseries #1}}
\newcommand{\gapbrkprompt}[1]{\color{brkpromptColor}{\bfseries #1}}
\newcommand{\gapinput}[1]{\color{gapinputColor}{#1}}


\begin{document}

\logpage{[ 0, 0, 0 ]}
\begin{titlepage}
\mbox{}\vfill

\begin{center}{\maintitlesize \textbf{GAP 4 Package \textsf{cvec}\mbox{}}}\\
\vfill

\hypersetup{pdftitle=GAP 4 Package \textsf{cvec}}
\markright{\scriptsize \mbox{}\hfill GAP 4 Package \textsf{cvec} \hfill\mbox{}}
{\Huge \textbf{Compact vectors over finite fields\mbox{}}}\\
\vfill

{\Huge  Version 2.2 \mbox{}}\\[1cm]
{May 2012\mbox{}}\\[1cm]
\mbox{}\\[2cm]
{\Large \textbf{Max Neunh{\"o}ffer    \mbox{}}}\\
\hypersetup{pdfauthor=Max Neunh{\"o}ffer    }
\end{center}\vfill

\mbox{}\\
{\mbox{}\\
\small \noindent \textbf{Max Neunh{\"o}ffer    }  Email: \href{mailto://neunhoef@mcs.st-and.ac.uk} {\texttt{neunhoef@mcs.st-and.ac.uk}}\\
  Homepage: \href{http://www-groups.mcs.st-and.ac.uk/~neunhoef} {\texttt{http://www-groups.mcs.st-and.ac.uk/\texttt{\symbol{126}}neunhoef}}\\
  Address: \begin{minipage}[t]{8cm}\noindent
 School of Mathematics and Statistics Mathematical Institute North Haugh St
Andrews, Fife KY16 9SS Scotland, UK \end{minipage}
}\\
\end{titlepage}

\newpage\setcounter{page}{2}
{\small 
\section*{Copyright}
\logpage{[ 0, 0, 1 ]}
 {\copyright} by Max Neunh{\"o}ffer

 This package may be distributed under the terms and conditions of the GNU
Public License Version 2. \mbox{}}\\[1cm]
\newpage

\def\contentsname{Contents\logpage{[ 0, 0, 2 ]}}

\tableofcontents
\newpage

  
\chapter{\textcolor{Chapter }{Introduction}}\label{intro}
\logpage{[ 1, 0, 0 ]}
\hyperdef{L}{X7DFB63A97E67C0A1}{}
{
  
\section{\textcolor{Chapter }{Philosophy}}\label{philosophy}
\logpage{[ 1, 1, 0 ]}
\hyperdef{L}{X873C99678745ABAF}{}
{
  This package implements a complete infrastructure for vectors over finite
fields. The basic idea is, that one can store an element of a finite field
using only a few bits rather than a full machine word. Therefore one can pack
more than one finite field element in a machine word. This approach not only
saves memory but also allows fast arithmetic.

 Contrary to other implementations this package uses long word instructions for
arithmetic and other operations rather than table lookups, because modern
microprocessor designs seem to support faster memory access in this way and
memory access is the main limiting factor for computations over finite fields.
This approach also allows for bigger finite fields with more than 256
elements. For a more detailed descriptions of this design see Chapter \ref{datastrucs}.

 The main purpose of this implementation is to use it in \textsf{MeatAxe}-like applications, that is, working with matrices consisting of compressed
vectors over finite fields, doing linear algebra calculations like nullspaces,
spinning of vectors, multiplying and inverting matrices and the like. Another
purpose could be matrix group calculations. Usually in such computations, the
base field does not change too often and not many different lengths of vectors
occur. This implementation is optimized with these applications in mind and
might not be very efficient for other purposes like using compressed vectors
as coefficient lists of polynomials.

 Another important point is that compressed vectors in this package do not even
try to behave exactly like \textsf{GAP} lists. To the contrary, they disallow many operations that are possible for \textsf{GAP} lists for example changing their length or assigning arbitrary \textsf{GAP} objects to positions in the vector. The reason for this is that the chosen
data structure does not allow to assign anything but elements of the one base
field to positions in the vector and the option to change the representation ``on the fly'' is not desirable in most applications. On the other hand one can be relatively
sure not to ``lose compression'' along the way. 

 }

 
\section{\textcolor{Chapter }{Overview over this manual}}\label{overview}
\logpage{[ 1, 2, 0 ]}
\hyperdef{L}{X786BACDB82918A65}{}
{
  Chapter \ref{install} describes the installation of this package. Chapter \ref{datastrucs} describes the basic design and all the data structures used in this package,
including the external representation of matrices on storage. These
descriptions might be very valuable to understand the behaviour of the
implementation and various performance issues. Those and other performance
issues are covered in Chapter \ref{performance}, where you mainly find hints on how to tune your own programs that use this
package. Chapters \ref{vectors} to \ref{matrices} describe the available functionality for vectors and matrices respectively.
Chapter \ref{gaplib} describes, how the functionality in this package is or is not usable in
connection with the \textsf{GAP} library. Finally, Chapter \ref{examples} shows instructive examples for the usage of this package. }

  }

   
\chapter{\textcolor{Chapter }{Installation of the \textsf{cvec}-Package}}\label{install}
\logpage{[ 2, 0, 0 ]}
\hyperdef{L}{X81202E6D86800514}{}
{
  \index{\textsf{cvec}} To get the newest version of this \textsf{GAP} 4 package download one of the archive files 
\begin{itemize}
\item  \texttt{cvec-x.x.tar.gz} 
\item  \texttt{cvec-x.x.tar.bz2} 
\item  \texttt{cvec-x.x.zip} 
\end{itemize}
 and unpack it using 
\begin{verbatim}  
  gunzip cvec-x.x.tar.gz; tar xvf cvec-x.x.tar
\end{verbatim}
 or 
\begin{verbatim}  
  bzip2 -d cvec-x.x.tar.bz2; tar xvf cvec-x.x.tar
\end{verbatim}
 or 
\begin{verbatim}  
  unzip -x cvec-x.x.zip
\end{verbatim}
 respectively. 

 Do this in a directory called ``\texttt{pkg}'', preferably (but not necessarily) in the ``\texttt{pkg}'' subdirectory of your \textsf{GAP} 4 installation. It creates a subdirectory called ``\texttt{cvec}''.

 The package will not work without the following compilation step.

 To compile the C part of the package do (in the \texttt{pkg} directory) 
\begin{verbatim}  
      cd cvec
      ./configure
      make
\end{verbatim}
 If you installed the package in another ``\texttt{pkg}'' directory than the standard ``\texttt{pkg}'' directory in your \textsf{GAP} 4 installation, then you have to do two things. Firstly during compilation you
have to use the option \texttt{--with-gaproot=PATH} of the \texttt{configure} script where ``PATH'' is a path to the main \textsf{GAP} root directory (if not given the default ``\texttt{../..}'' is assumed). 

 Secondly you have to specify the path to the directory containing your ``\texttt{pkg}'' directory to \textsf{GAP}'s list of directories. This can be done by starting \textsf{GAP} with the ``\texttt{-l}'' command line option followed by the name of the directory and a semicolon.
Then your directory is prepended to the list of directories searched.
Otherwise the package is not found by \textsf{GAP}. Of course, you can add this option to your \textsf{GAP} startup script. 

 If you installed \textsf{GAP} on several architectures, you must execute the configure/make step for each of
the architectures. You can either do this immediately after configuring and
compiling \textsf{GAP} itself on this architecture, or alternatively (when using version 4.5 of \textsf{GAP} or newer) set the environment variable \texttt{CONFIGNAME} to the name of the configuration you used when compiling \textsf{GAP} before running \texttt{./configure}. Note however that your compiler choice and flags (environment variables \texttt{CC} and \texttt{CFLAGS}) need to be chosen to match the setup of the original \textsf{GAP} compilation. For example you have to specify 32-bit or 64-bit mode correctly!

  }

   
\chapter{\textcolor{Chapter }{The Data Structures}}\label{datastrucs}
\logpage{[ 3, 0, 0 ]}
\hyperdef{L}{X81F8AEBD87002F6F}{}
{
  This chapter describes all the data structures used in this package. We start
with a section on finite fields and what is already there in the \textsf{GAP} kernel and library. Then we describe compressed vectors and compressed
matrices. 
\section{\textcolor{Chapter }{Finite field elements}}\label{finfields}
\logpage{[ 3, 1, 0 ]}
\hyperdef{L}{X7B9DCCCC83400B47}{}
{
  Throughout the package, elements in the field $GF(p)$ of $p$ elements are represented by numbers $0,1,\ldots,p-1$ and arithmetic is just the standard arithmetic in the integers modulo $p$.

 Bigger finite fields are done by calculating in the polynomial ring $GF(p)[x]$ in one indeterminate $x$ modulo a certain irreducible polynomial. By convention, we use the so-called ``Conway polynomials'' (see \href{http://www.math.rwth-aachen.de:8001/~Frank.Luebeck/data/ConwayPol/index.html} {\texttt{http://www.math.rwth-aachen.de:8001/\texttt{\symbol{126}}Frank.Luebeck/data/ConwayPol/index.html}}) for this purpose, because they provide a standard way of embedding finite
fields into their extension fields. Because Conway polynomials are monic, we
can store coset representatives by storing polynomials of degree less than $d$, where $d$ is the degree of the finite field over its prime field.

 As of this writing, \textsf{GAP} has two implementation of finite field elements built into its kernel and
library, the first of which stores finite field elements by storing the
discrete logarithm with respect to a primitive root of the field. Although
this is nice and efficient for small finite fields, it becomes unhandy for
larger finite fields, because one needs a lookup table of length $p^d$ for doing efficient addition. This implementation thus is limited to fields
with less than or equal to $65536$ elements. The other implementation using polynomial arithmetic modulo the
Conway polynomial is used for fields with more than $65536$ elements. For prime fields of characteristic $p$ with more than that elements, there is an implementation using integers modulo $p$. }

 
\section{\textcolor{Chapter }{Compressed Vectors in Memory}}\label{cvecs}
\logpage{[ 3, 2, 0 ]}
\hyperdef{L}{X7ED5B368830755AF}{}
{
  
\subsection{\textcolor{Chapter }{Packing of prime field elements}}\logpage{[ 3, 2, 1 ]}
\hyperdef{L}{X87968B277C5DF090}{}
{
  For this section, we assume that the base field is $GF(p^d)$, the finite field with $p^d$ elements, where $p$ is a prime and $d$ is a positive integer. This is realized as a field extension of degree $d$ over the prime field $GF(p)$ using the Conway polynomial $c \in GF(p)[x]$. We always represent field elements of $GF(p^d)$ by polynomials $a = \sum_{{i=0}}^{{d-1}} a_i x^i$ where the coefficients $a_i$ are in $GF(p)$. Because $c$ is monic, this gives a one-to-one correspondance between polynomials and
finite field elements.

 The memory layout for compressed vectors is determined by two important
constants, depending only on $p$ and the word length of the machine. The word length is 4 bytes on 32bit
machines (for example on the i386 architecture) and 8 bytes on 64bit machines
(for example on the AMD64 architecture). More concretely, a ``\texttt{Word}'' is an \texttt{unsigned long int} in C and the length of a \texttt{Word} is \texttt{sizeof(unsigned long int)}.

 Those constants are \texttt{bitsperel} (bits per prime field element) and \texttt{elsperword} (prime field elements per \texttt{Word}). \texttt{bitsperel} is $1$ for $p=2$ and otherwise the smallest integer, such that $2^bitsperel > 2\cdot p-1$. This means, that we can store the numbers from $0$ to $2\cdot p - 1$ in \texttt{bitsperel} bits. \texttt{elsperword} is $32/bitsperel$ rounded down to the next integer and multiplied by $2$ if the length of a \texttt{Word} is $8$ bytes. Note that we thus store as many prime field elements as possible into
one \texttt{Word}, however, on 64bit machines we store only twice as much as would fit into
32bit, even if we could pack one more into a \texttt{Word}. This has technical reasons to make conversion between different
architectures more efficient.

 These definitions imply that we can put \texttt{elsperword} prime field elements into one \texttt{Word}. We do this by using the \texttt{bitsperel} least significant bits in the \texttt{Word} for the first prime field element, using the next \texttt{bitsperel} bits for the next prime field element and so on. Here is an example that shows
how the $6$ finite field elements $0,1,2,3,4,5$ of $GF(11)$ are stored in that order in one 32bit \texttt{Word}. \texttt{bitsperel} is here $4$, because $2^4 < 2\cdot 11 - 1 = 21 < 2^5$. Therefore \texttt{elsperword} is $5$ on a 32bit machine. 
\begin{Verbatim}[commandchars=!@A,fontsize=\small,frame=single,label=Example]
   most significant xx|.....|.....|.....|.....|.....|..... least significant
                    00|00101|00100|00011|00010|00001|00000 
                      |    5|    4|    3|    2|    1|    0
\end{Verbatim}
 Here is another example that shows how the $20$ finite field elements $0,1,2,0,0,0,1,1,1,2,2,2,0,1,2,2,1,0,2,2$ of $GF(3)$ are stored in that order in one 64bit \texttt{Word}. \texttt{bitsperel} is here $3$, because $2^2 < 2\cdot 3 - 1 = 5 < 2^3$. Therefore \texttt{elsperword} is $20$ on a 32bit machine. Remember, that we only put twice as many elements in one
64bit \texttt{Word} than we could in one 32bit \texttt{Word}! 
\begin{Verbatim}[commandchars=@|A,fontsize=\small,frame=single,label=Example]
   xxxx..!..!..!..!..!..!..!..!..!..!..!..!..!..!..!..!..!..!..!..!
   0000010010000001010010001000010010010001001001000000000010001000
         2  2  0  1  2  2  1  0  2  2  2  1  1  1  0  0  0  2  1  0
\end{Verbatim}
 (The exclamation marks mark the right hand side of the prime field elements.)

 Note that different architectures store their \texttt{Word}s in a different byte order in memory (``endianess''). We do \emph{not} specify how the data is distributed into bytes here! All access is via \texttt{Word}s and their arithmetic (shifting, addition, multiplication, etc.). See Section \ref{extrep} for a discussion of this with respect to our external representation.

 }

 
\subsection{\textcolor{Chapter }{Extension Fields}}\logpage{[ 3, 2, 2 ]}
\hyperdef{L}{X7C195F41802266B7}{}
{
  Now that we have seen how prime field elements are packed into \texttt{Word}s, we proceed to the description how compressed vectors are stored over
arbitrary extension fields:

 Assume a compressed vector has length $l$ with $l \geq 0$. If $d=1$ (prime field), it just uses $elsperword/l$ \texttt{Word}s (division rounded up to the next integer), where the first \texttt{Word} stores the leftmost \texttt{elsperword} field elements in the first \texttt{Word} as described above and so on. This means, that the very first field element is
stored in the least significant bits of the first \texttt{Word}. 

 In the extension field case $GF(p^d)$, a vector of length $l$ uses $(elsperword/l)*d$ \texttt{Word}s (division rounded up to the next integer), where the first $d$ \texttt{Word}s store the leftmost \texttt{elsperword} field elements. The very first word stores all the constant coefficients of
the polynomials representing the first \texttt{elsperword} field elements in their order from left to right, the second \texttt{Word} stores the coefficients of $x^1$ and so on until the $d$'th \texttt{Word}, which stores the coefficients of $x^{{d-1}}$. Unused entries behind the end of the actual vector data within the last \texttt{Word} has to be zero!.

 The following example shows, how the $9$ field elements $x^2+x+1$, $x^2+2x+2$, $x^2+3x+3$, $x^2+4x+4$, $2x^2+x$, $2x^2+3x+1$, $2x^2+4x+2$, $3x^2+1$, and $4x^2+x+3$ of $GF(5^3)$ occurring in a vector of length $9$ in that order are stored on a 32bit machine: 
\begin{Verbatim}[commandchars=!@A,fontsize=\small,frame=single,label=Example]
   ^^^ lower memory addresses ^^^
              ....|....|....|....|....|....|....|....  (least significant bit)
   1st Word:  0001|0010|0001|0000|0100|0011|0010|0001| (first
   2nd Word:  0000|0100|0011|0001|0100|0011|0010|0001|     8 field
   3rd Word:  0011|0010|0010|0010|0001|0001|0001|0001|        elements)
   ---------------------------------------------------
   4th Word:  0000|0000|0000|0000|0000|0000|0000|0011| (second
   5th Word:  0000|0000|0000|0000|0000|0000|0000|0001|     8 field
   6th Word:  0000|0000|0000|0000|0000|0000|0000|0100|        elements)
   VVV higher memory addresses VVV
\end{Verbatim}
 A ``\texttt{cvec}'' (one of our compressed vectors) is a \textsf{GAP} ``Data object'' (that is with \texttt{TNUM} equal to \texttt{T{\textunderscore}DATOBJ}). The first machine word in its bag is a pointer to its type, from the second
machine word on the \texttt{Word}s containing the above data are stored. The bag is exactly long enough to hold
the type pointer and the data \texttt{Word}s.

 }

 
\subsection{\textcolor{Chapter }{How is information about the base field stored?}}\logpage{[ 3, 2, 3 ]}
\hyperdef{L}{X819040FD7BCBABB2}{}
{
  But how does the system know, over which field the vector is and how long it
is? The type of a \textsf{GAP} object consists of $3$ pieces: A family, a bit list (for the filters), and one \textsf{GAP} object for ``defining data''. The additional information about the vector is stored in the third piece,
the defining data, and is called a ``\texttt{cvecclass}''.

 A \texttt{cvecclass} is a positional object with $5$ components: \begin{center}
\begin{tabular}{cll}Position&
Name&
Content\\
\hline
1&
\texttt{IDX\_fieldinfo} &
a \texttt{fieldinfo} object, see below\\
2&
\texttt{IDX\_len} &
the length of the vector as immediate \textsf{GAP} integer\\
3&
\texttt{IDX\_wordlen} &
the number of \texttt{Word}s used as immediate \textsf{GAP} integer\\
4&
\texttt{IDX\_type} &
a \textsf{GAP} type used to create new vectors\\
5&
\texttt{IDX\_GF} &
a \textsf{GAP} object for the base field\\
6&
\texttt{IDX\_lens} &
a list holding lengths of vectors in \texttt{cvecclasses} for the same field\\
7&
\texttt{IDX\_classes} &
a list holding \texttt{cvecclass}es for the same field with lengths as in entry number 6\\
\end{tabular}\\[2mm]
\textbf{Table: }Components of a \texttt{cvecclass}\end{center}

 In position 5 we have just the \textsf{GAP} finite field object \texttt{GF(p,d)}. The names appear as symbols in the code.

 The field is described by the \textsf{GAP} object in position 1, a so-called \texttt{fieldinfo} object, which is described in the following table: \begin{center}
\begin{tabular}{cll}\emph{Position}&
Name&
\emph{Content}\\
\hline
1&
\texttt{IDX\_p} &
$p$ as an immediate \textsf{GAP} integer\\
2&
\texttt{IDX\_d} &
$d$ as an immediate \textsf{GAP} integer\\
3&
\texttt{IDX\_q} &
$q=p^d$ as a \textsf{GAP} integer\\
4&
\texttt{IDX\_conway} &
a \textsf{GAP} string containing the coefficients of the Conway Polynomial as unsigned int []\\
5&
\texttt{IDX\_bitsperel} &
number of bits per element of the prime field (\texttt{bitsperel})\\
6&
\texttt{IDX\_elsperword} &
prime field elements per \texttt{Word} (\texttt{elsperword})\\
7&
\texttt{IDX\_wordinfo} &
a \textsf{GAP} string containing C data for internal use\\
8&
\texttt{IDX\_bestgrease} &
the best grease level (see Section \ref{Greasing})\\
9&
\texttt{IDX\_greasetabl} &
the length of a grease table using best grease\\
10&
\texttt{IDX\_filts} &
a filter list for the creation of new vectors over this field\\
11&
\texttt{IDX\_tab1} &
a table for $GF(q)$ to \texttt{[0..q-1]} conversion if $q \leq 65536$\\
12&
\texttt{IDX\_tab2} &
a table for \texttt{[0..q-1]} to $GF(q)$ conversion if $q \leq 65536$\\
13&
\texttt{IDX\_size} &
0 for $q \leq 65536$, otherwise 1 if $q$ is a \textsf{GAP} immediate integer and 2 if not\\
14&
\texttt{IDX\_scafam} &
the scalars family\\
\end{tabular}\\[2mm]
\textbf{Table: }Components of a \texttt{fieldinfo}\end{center}

 Note that \textsf{GAP} has a family for all finite field elements of a given characteristic $p$, vectors over a finite field are then in the collections family of that
family and matrices are in the collections family of the collections family of
the scalars family. We use the same families in the same way for compressed
vectors and matrices. }

 
\subsection{\textcolor{Chapter }{Limits that follow from the Data Format}}\logpage{[ 3, 2, 4 ]}
\hyperdef{L}{X7DF0FE978626CE59}{}
{
  The following limits come from the above mentioned data format or other
internal restrictions (an ``immediate integer'' in \textsf{GAP} can take values between $2^{{-28}}$ and $(2^{{28}})-1$ inclusively on 32bit machines and between $2^{{-60}}$ and $(2^{{60}})-1$ on 64bit machines): 
\begin{itemize}
\item  The prime $p$ must be an immediate integer. 
\item  The degree $d$ must be smaller than $1024$ (this limit is arbitrarily chosen at the moment and could be increased
easily).
\item  The Conway polynomial must be known to \textsf{GAP}. 
\item  The length of a vector must be an immediate integer. 
\end{itemize}
 }

 }

 
\section{\textcolor{Chapter }{Compressed Matrices}}\label{cmats}
\logpage{[ 3, 3, 0 ]}
\hyperdef{L}{X78694256795D3A28}{}
{
  The implementation of \texttt{cmats} (compressed matrices) is done mainly on the \textsf{GAP} level without using too many C parts. Only the time critical parts for some
operations for matrices are done in the kernel.

 A \texttt{cmat} object is a positional object with at least the following components: \begin{center}
\begin{tabular}{ll}Component name&
Content\\
\hline
\texttt{len}&
the number of rows, can be $0$\\
\texttt{vecclass}&
a \texttt{cvecclass} object describing the class of rows\\
\texttt{scaclass}&
a \texttt{cscaclass} object holding a reference to \texttt{GF(p,d)}\\
\texttt{rows}&
a list containing the rows of the matrix, which are \texttt{cvec}s\\
\texttt{greasehint}&
the recommended greasing level\\
\end{tabular}\\[2mm]
\textbf{Table: }Components of a \texttt{cmat} object\end{center}

 The \texttt{cvecclass} in the component \texttt{vecclass} determines the number of columns of the matrix by the length of the rows.

 The length of the list in component \texttt{rows} is \texttt{len+1}, because the first position is equal to the integer $0$ such that the type of the list \texttt{rows} can always be computed efficiently. The rows are then stored in positions 2 to \texttt{len+1}.

 The component \texttt{greasehint} contains the greasing level for the next matrix multiplication, in which this
matrix occurs as the factor on the right hand side (if greasing is worth the
effort, see Section \ref{grease}).

 A \texttt{cmat} can be ``pre-greased'', which just means, that a certain number of linear combinations of its rows
is already precomputed (see Section \ref{grease}). In that case, the object is in the additional filter \texttt{HasGreaseTab} and the following components are bound additionally: \begin{center}
\begin{tabular}{ll}Component name&
Content\\
\hline
\texttt{greaselev}&
the grease level\\
\texttt{greasetab}&
the grease table, a list of lists of \texttt{cvecs}\\
\texttt{greaseblo}&
the number of greasing blocks\\
\texttt{spreadtab}&
a lookup table for indexing the right linear combination\\
\end{tabular}\\[2mm]
\textbf{Table: }Additional components of a \texttt{cmat} object when pre-greased \end{center}

 }

 
\section{\textcolor{Chapter }{External Representation of Matrices on Storage}}\label{extrep}
\logpage{[ 3, 4, 0 ]}
\hyperdef{L}{X783395FC81A451F3}{}
{
  
\subsection{\textcolor{Chapter }{Byte ordering and word length}}\logpage{[ 3, 4, 1 ]}
\hyperdef{L}{X7B82906C7FFF36F5}{}
{
  This section describes the external representation of matrices. A special data
format is needed here, because of differences between computer architectures
with respect to word length (32bit/64bit) and endianess. The term ``endianess'' refers to the fact, that different architectures store their long words in a
different way in memory, namely they order the bytes that together make up a
long word in different orders.

 The external representation is the same as the internal format of a 32bit
machine with little endianess, which means, that the lower significant bytes
of a \texttt{Word} are stored in lower addresses. The reasons for this decision are firstly that
64bit machines can do the bit shifting to convert between internal and
externel representation easier using their wide registers, and secondly, that
the nowadays most popular architectures i386 and AMD64 use both little
endianess, such that conversion is only necessary on a minority of machines.

 }

 
\subsection{\textcolor{Chapter }{The header of a \texttt{cmat} file}}\logpage{[ 3, 4, 2 ]}
\hyperdef{L}{X8598B059867CA116}{}
{
  The header of a \texttt{cmat} file consists of 5 words of 64bit each, that are stored in little endian byte
order: \begin{center}
\begin{tabular}{l}the magic value ``\texttt{GAPCMat1}'' as ASCII letters (8 bytes) in this order\\
the value of $p$ to describe the base field\\
the value of $d$ to describe the base field\\
the number of rows of the matrix\\
the number of columns of the matrix\\
\end{tabular}\\[2mm]
\textbf{Table: }Header of a \texttt{cmat} file\end{center}

 After these $40$ bytes follow the data words as described above using little endian 32bit \texttt{Word}s as in the internal representation on 32bit machines.

 Note that the decision to put not more than twice as many prime field elements
into a 64bit \texttt{Word} than would fit into a 32bit \texttt{Word} makes the conversion between internal and external representation much easier
to implement. }

 }

  }

    
\chapter{\textcolor{Chapter }{Vectors}}\label{vectors}
\logpage{[ 4, 0, 0 ]}
\hyperdef{L}{X7D12102B824C97B4}{}
{
  See Section \ref{cvecs} for a documentation of the data format of \texttt{cvec}s and its restrictions.

 
\section{\textcolor{Chapter }{Creation}}\logpage{[ 4, 1, 0 ]}
\hyperdef{L}{X788B78DE82579F3D}{}
{
  Note that many functions described later in this chapter implicitly create new \texttt{cvec}s, such that it is usually only in the beginning of a calculation necessary to
create \texttt{cvec}s explicitly. 

\subsection{\textcolor{Chapter }{CVec}}
\logpage{[ 4, 1, 1 ]}\nobreak
\hyperdef{L}{X83BF7BBC84478E77}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CVec({\mdseries\slshape arg})\index{CVec@\texttt{CVec}}
\label{CVec}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
a new mutable \texttt{cvec}



 Creates a new \texttt{cvec}. See the method descriptions for details. }

 

\subsection{\textcolor{Chapter }{CVec (cvecclass)}}
\logpage{[ 4, 1, 2 ]}\nobreak
\hyperdef{L}{X83E8D01B82498337}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CVec({\mdseries\slshape cvecclass})\index{CVec@\texttt{CVec}!cvecclass}
\label{CVec:cvecclass}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
a new mutable \texttt{cvec}



 \mbox{\texttt{\mdseries\slshape cvecclass}} must be a \texttt{cvecclass}. Creates a new \texttt{cvec} containing only zeroes. For an explanation of the term \texttt{cvecclass} see Section \ref{cvecs} and \texttt{CVecClass} (\ref{CVecClass}). }

 

\subsection{\textcolor{Chapter }{CVec (coefflcvecclass)}}
\logpage{[ 4, 1, 3 ]}\nobreak
\hyperdef{L}{X826347BB7B81A06D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CVec({\mdseries\slshape coeffs, cvecclass})\index{CVec@\texttt{CVec}!coefflcvecclass}
\label{CVec:coefflcvecclass}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
a new mutable \texttt{cvec}



 This method takes a coefficient list and a \texttt{cvecclass} as arguments. Assume the vector will be over $GF(p,d)$ with $q=p^d$. For the coefficient list \mbox{\texttt{\mdseries\slshape coeffs}} there exist several possibilities, partially depending on the base field size.
The easiest way is to use \textsf{GAP} finite field elements, which will be put into the new vector in the same
order. If $d=1$, one can always use \textsf{GAP} immediate integers between $0$ and $p-1$, the vector will then contain the corresponding cosets in $GF(p)=Z/pZ$. If $q$ is small enough to be a \textsf{GAP} immediate integer, then one can use \textsf{GAP} immediate integers that are equal to the $p$-adic expansion using the coefficients of the representing polynomial as
coefficients. That is, if an element in $GF(p,d)$ is represented by the polynomial $\sum_{{i=0}}^{{d-1}} a_i x^i$ with $a_i \in \{0,\ldots,p-1\}$, then one has to put $\sum_{{i=0}}^{{d-1}} a_i p^i$ as integer into the coefficient list \mbox{\texttt{\mdseries\slshape coeffs}}. If $q$ is larger, then \mbox{\texttt{\mdseries\slshape coeffs}} must be a list of lists of length $d$ and contains for each field element of $GF(p,d)$ in the vector a list of its $d$ coefficients of the representing polynomial. For an explanation of the term \texttt{cvecclass} see Section \ref{cvecs} and \texttt{CVecClass} (\ref{CVecClass}). Of course, the length of the list \mbox{\texttt{\mdseries\slshape coeffs}} must match the length of the vector given in the \texttt{cvecclass}. }

 

\subsection{\textcolor{Chapter }{CVec (coefflpd)}}
\logpage{[ 4, 1, 4 ]}\nobreak
\hyperdef{L}{X83E046D17AB12FF0}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CVec({\mdseries\slshape coeffs, p, d})\index{CVec@\texttt{CVec}!coefflpd}
\label{CVec:coefflpd}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
a new mutable \texttt{cvec}



 This method takes a coefficient list and two positive integers \mbox{\texttt{\mdseries\slshape p}} and \mbox{\texttt{\mdseries\slshape d}} as arguments. A new \texttt{cvec} over $GF(p,d)$ will be created. Let $q := p^d$.

 For a description of the possible values of the coefficient list \mbox{\texttt{\mdseries\slshape coeffs}} see the description of the method \texttt{CVec} (\ref{CVec:coefflcvecclass}). }

 

\subsection{\textcolor{Chapter }{CVec (compvec)}}
\logpage{[ 4, 1, 5 ]}\nobreak
\hyperdef{L}{X86642DDE797387E7}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CVec({\mdseries\slshape v})\index{CVec@\texttt{CVec}!compvec}
\label{CVec:compvec}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
a new \texttt{cvec}



 \mbox{\texttt{\mdseries\slshape v}} must be a \textsf{GAP} compressed vector either over $GF(2)$ or $GF(p,d)$ with $p^d \leq 256$. Creates a new \texttt{cvec} containing the same numbers as \mbox{\texttt{\mdseries\slshape v}} over the field which the \texttt{Field} operation returns for \mbox{\texttt{\mdseries\slshape v}}. }

 

\subsection{\textcolor{Chapter }{CVec (coefflff)}}
\logpage{[ 4, 1, 6 ]}\nobreak
\hyperdef{L}{X7CC92B9E8286B025}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CVec({\mdseries\slshape coeffs, f})\index{CVec@\texttt{CVec}!coefflff}
\label{CVec:coefflff}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
a new mutable \texttt{cvec}



 This method takes a coefficient list and a finite field \mbox{\texttt{\mdseries\slshape f}} as arguments. A new \texttt{cvec} over \mbox{\texttt{\mdseries\slshape f}} will be created. Let $q := $\texttt{Size(}\mbox{\texttt{\mdseries\slshape f}}\texttt{)}.

 For a description of the possible values of the coefficient list \mbox{\texttt{\mdseries\slshape coeffs}} see the description of the method \texttt{CVec} (\ref{CVec:coefflcvecclass}). }

 After having encountered the concept of a \texttt{cvecclass} already a few times it is time to learn how to create one. The following
operation is used first to create new \texttt{cvecclass}es and second to ask a \texttt{cvec} for its class. In addition, it is used for \texttt{csca}s. 

\subsection{\textcolor{Chapter }{CVecClass}}
\logpage{[ 4, 1, 7 ]}\nobreak
\hyperdef{L}{X7B9566C1867C5EA6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CVecClass({\mdseries\slshape arg})\index{CVecClass@\texttt{CVecClass}}
\label{CVecClass}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
a \texttt{cvecclass}



 Creates new \texttt{cvecclass}es and asks \texttt{cvec}s for their class. See the following method descriptions for details. For an
explanation of the term \texttt{cvecclass} see Section \ref{cvecs}. }

 

\subsection{\textcolor{Chapter }{CVecClass}}
\logpage{[ 4, 1, 8 ]}\nobreak
\hyperdef{L}{X7B9566C1867C5EA6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CVecClass({\mdseries\slshape p, d, l})\index{CVecClass@\texttt{CVecClass}}
\label{CVecClass}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
a \texttt{cvecclass}



 All three arguments must be integers. The arguments \mbox{\texttt{\mdseries\slshape p}} and \mbox{\texttt{\mdseries\slshape d}} must be positive and describe the base field $GF(p,d)$. The third argument must be non-negative and the method returns the \texttt{cvecclass} of vectors over $GF(p,d)$ of length \mbox{\texttt{\mdseries\slshape l}}. 

 For an explanation of the term \texttt{cvecclass} and its data structure see Section \ref{cvecs}. }

 

\subsection{\textcolor{Chapter }{CVecClass}}
\logpage{[ 4, 1, 9 ]}\nobreak
\hyperdef{L}{X7B9566C1867C5EA6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CVecClass({\mdseries\slshape v})\index{CVecClass@\texttt{CVecClass}}
\label{CVecClass}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
a \texttt{cvecclass}



 The argument \mbox{\texttt{\mdseries\slshape v}} must be a \texttt{cvec}. The method returns the corresponding \texttt{cvecclass}. For an explanation of the term \texttt{cvecclass} and its data structure see Section \ref{cvecs}. }

 

\subsection{\textcolor{Chapter }{CVecClass}}
\logpage{[ 4, 1, 10 ]}\nobreak
\hyperdef{L}{X7B9566C1867C5EA6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CVecClass({\mdseries\slshape v, l})\index{CVecClass@\texttt{CVecClass}}
\label{CVecClass}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
a \texttt{cvecclass}



 The argument \mbox{\texttt{\mdseries\slshape v}} must be a \texttt{cvec}. The method returns the corresponding \texttt{cvecclass} for vectors over the same field as \mbox{\texttt{\mdseries\slshape v}} but with length \mbox{\texttt{\mdseries\slshape l}}. This is much faster than producing the same object by giving $p$ and $d$. For an explanation of the term \texttt{cvecclass} and its data structure see Section \ref{cvecs}. }

 

\subsection{\textcolor{Chapter }{CVecClass}}
\logpage{[ 4, 1, 11 ]}\nobreak
\hyperdef{L}{X7B9566C1867C5EA6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CVecClass({\mdseries\slshape c, l})\index{CVecClass@\texttt{CVecClass}}
\label{CVecClass}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
a \texttt{cvecclass}



 The argument \mbox{\texttt{\mdseries\slshape c}} must be a \texttt{cvecclass}. The method returns the corresponding \texttt{cvecclass} for vectors over the same field as those in \mbox{\texttt{\mdseries\slshape c}} but with length \mbox{\texttt{\mdseries\slshape l}}. This is much faster than producing the same object by giving $p$ and $d$. For an explanation of the term \texttt{cvecclass} and its data structure see Section \ref{cvecs}. }

 

\subsection{\textcolor{Chapter }{CVecClass}}
\logpage{[ 4, 1, 12 ]}\nobreak
\hyperdef{L}{X7B9566C1867C5EA6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CVecClass({\mdseries\slshape f, l})\index{CVecClass@\texttt{CVecClass}}
\label{CVecClass}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
a \texttt{cvecclass}



 The argument \mbox{\texttt{\mdseries\slshape f}} must be a \texttt{finite field}. The method returns the corresponding \texttt{cvecclass} for vectors over the field \mbox{\texttt{\mdseries\slshape f}} with length \mbox{\texttt{\mdseries\slshape l}}. For an explanation of the term \texttt{cvecclass} and its data structure see Section \ref{cvecs}. }

 

\subsection{\textcolor{Chapter }{ZeroSameMutability (cvec)}}
\logpage{[ 4, 1, 13 ]}\nobreak
\hyperdef{L}{X876613FC7A9A276C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ZeroSameMutability({\mdseries\slshape v})\index{ZeroSameMutability@\texttt{ZeroSameMutability}!cvec}
\label{ZeroSameMutability:cvec}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the zero \texttt{cvec} in the same \texttt{cvecclass} as \mbox{\texttt{\mdseries\slshape v}} 



 \mbox{\texttt{\mdseries\slshape v}} must be a \texttt{cvec}. }

 

\subsection{\textcolor{Chapter }{ShallowCopy (cvec)}}
\logpage{[ 4, 1, 14 ]}\nobreak
\hyperdef{L}{X7BA2BD517C058720}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ShallowCopy({\mdseries\slshape v})\index{ShallowCopy@\texttt{ShallowCopy}!cvec}
\label{ShallowCopy:cvec}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
a mutable copy of \mbox{\texttt{\mdseries\slshape v}} 



 \mbox{\texttt{\mdseries\slshape v}} must be a \texttt{cvec}. }

 

\subsection{\textcolor{Chapter }{Randomize (cvec)}}
\logpage{[ 4, 1, 15 ]}\nobreak
\hyperdef{L}{X84EBC4427913251F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Randomize({\mdseries\slshape v})\index{Randomize@\texttt{Randomize}!cvec}
\label{Randomize:cvec}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Randomize({\mdseries\slshape v, rs})\index{Randomize@\texttt{Randomize}!cvecrandomsource}
\label{Randomize:cvecrandomsource}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the vector \mbox{\texttt{\mdseries\slshape v}}



 \mbox{\texttt{\mdseries\slshape v}} must be a \texttt{cvec} and \mbox{\texttt{\mdseries\slshape rs}} must be a random source object if given. This method changes the vector \mbox{\texttt{\mdseries\slshape v}} in place by (pseudo) random values in the field over which the vector lives.
If a random source is given, the pseudo random numbers used are taken from
this source, otherwise the global random source in the \textsf{GAP} library is taken. }

 }

 
\section{\textcolor{Chapter }{Arithmetic}}\logpage{[ 4, 2, 0 ]}
\hyperdef{L}{X79862FF37B75BF48}{}
{
  Of course, the standard arithmetic infix operations $+$, $-$ and $*$ (for vectors and scalars) work as expected by using the methods below. We
start this section with a subsection on the usage of scalars in arithmetic
operations involving vectors. 
\subsection{\textcolor{Chapter }{Handling of scalars in arithmetic operations}}\label{scahandl}
\logpage{[ 4, 2, 1 ]}
\hyperdef{L}{X788A3D6482290F7D}{}
{
  In all places (like in \texttt{\texttt{\symbol{92}}*}) where vectors and scalars occur, the following conventions apply to scalars:

 \textsf{GAP} finite field elements can be used as scalars.

 Integers between $0$ and $p-1$ (inclusively) can always be used as scalars representing prime field elements
via the isomorphism $GF(p)=Z/pZ$, also for extension fields. Larger integers than $p-1$, as long as they are \textsf{GAP} immediate integers, are interpreted as the $p$-adic expansion of the coefficient list of the polynomial representing the
scalar. Note that this usage of immediate integers differs from the standard
list arithmetic in \textsf{GAP} because multiplication with the integer $n$ not necessarily means the same than $n$ times addition! Larger integers than immediate integers are not supported. }

 

\subsection{\textcolor{Chapter }{\texttt{\symbol{92}}+ (cveccvec)}}
\logpage{[ 4, 2, 2 ]}\nobreak
\hyperdef{L}{X7C2F565480B1A4A1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{\texttt{\symbol{92}}+({\mdseries\slshape v, w})\index{+@\texttt{\texttt{\symbol{92}}+}!cveccvec}
\label{+:cveccvec}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the sum $\mbox{\texttt{\mdseries\slshape v}}+\mbox{\texttt{\mdseries\slshape w}}$ as a new \texttt{cvec}



 For two \texttt{cvec}s \mbox{\texttt{\mdseries\slshape v}} and \mbox{\texttt{\mdseries\slshape w}}. Works as expected. }

 

\subsection{\textcolor{Chapter }{\texttt{\symbol{92}}- (cveccvec)}}
\logpage{[ 4, 2, 3 ]}\nobreak
\hyperdef{L}{X7CFEB1507E279EF2}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{\texttt{\symbol{92}}-({\mdseries\slshape v, w})\index{-@\texttt{\texttt{\symbol{92}}-}!cveccvec}
\label{-:cveccvec}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the difference $\mbox{\texttt{\mdseries\slshape v}}-\mbox{\texttt{\mdseries\slshape w}}$ as a new \texttt{cvec}



 For two \texttt{cvec}s \mbox{\texttt{\mdseries\slshape v}} and \mbox{\texttt{\mdseries\slshape w}}. Works as expected. }

 

\subsection{\textcolor{Chapter }{AdditiveInverseSameMutability (cvec)}}
\logpage{[ 4, 2, 4 ]}\nobreak
\hyperdef{L}{X7DD3036C847E12DC}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{AdditiveInverseSameMutability({\mdseries\slshape v})\index{AdditiveInverseSameMutability@\texttt{AdditiveInverseSameMutability}!cvec}
\label{AdditiveInverseSameMutability:cvec}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{\texttt{\symbol{92}}-({\mdseries\slshape v})\index{-@\texttt{\texttt{\symbol{92}}-}!cvec}
\label{-:cvec}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the additive inverse of \mbox{\texttt{\mdseries\slshape v}} as a new \texttt{cvec}



 For a \texttt{cvec} \mbox{\texttt{\mdseries\slshape v}}. Works as expected. }

 

\subsection{\textcolor{Chapter }{AdditiveInverseMutable (cvec)}}
\logpage{[ 4, 2, 5 ]}\nobreak
\hyperdef{L}{X7A34F9AA8330EBB9}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{AdditiveInverseMutable({\mdseries\slshape v})\index{AdditiveInverseMutable@\texttt{AdditiveInverseMutable}!cvec}
\label{AdditiveInverseMutable:cvec}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the additive inverse of \mbox{\texttt{\mdseries\slshape v}} as a new mutable \texttt{cvec} 



 For a \texttt{cvec} \mbox{\texttt{\mdseries\slshape v}}. Works as expected. }

 

\subsection{\textcolor{Chapter }{\texttt{\symbol{92}}* (cvecsca)}}
\logpage{[ 4, 2, 6 ]}\nobreak
\hyperdef{L}{X8191F74E797B4A3D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{\texttt{\symbol{92}}*({\mdseries\slshape v, s})\index{*@\texttt{\texttt{\symbol{92}}*}!cvecsca}
\label{*:cvecsca}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{\texttt{\symbol{92}}*({\mdseries\slshape s, v})\index{*@\texttt{\texttt{\symbol{92}}*}!scacvec}
\label{*:scacvec}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the scalar multiple \mbox{\texttt{\mdseries\slshape s}}$\cdot$\mbox{\texttt{\mdseries\slshape v}}



 For a \texttt{cvec} \mbox{\texttt{\mdseries\slshape v}} and a scalar \mbox{\texttt{\mdseries\slshape s}}. For the format of the scalar see \ref{scahandl}. Works as expected. }

 

\subsection{\textcolor{Chapter }{AddRowVector (cveccvecsca)}}
\logpage{[ 4, 2, 7 ]}\nobreak
\hyperdef{L}{X820D829E87A82A80}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{AddRowVector({\mdseries\slshape v, w, s})\index{AddRowVector@\texttt{AddRowVector}!cveccvecsca}
\label{AddRowVector:cveccvecsca}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{AddRowVector({\mdseries\slshape v, w, s, fr, to})\index{AddRowVector@\texttt{AddRowVector}!cveccvecscapospos}
\label{AddRowVector:cveccvecscapospos}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
nothing



 \mbox{\texttt{\mdseries\slshape v}} and \mbox{\texttt{\mdseries\slshape w}} must be \texttt{cvec}s over the same field with equal length, \mbox{\texttt{\mdseries\slshape s}} a scalar (see Subsection \ref{scahandl}) and \mbox{\texttt{\mdseries\slshape v}} must be mutable. Adds \mbox{\texttt{\mdseries\slshape s}}$\cdot$\mbox{\texttt{\mdseries\slshape w}} to \mbox{\texttt{\mdseries\slshape v}} modifying \mbox{\texttt{\mdseries\slshape v}}. If \mbox{\texttt{\mdseries\slshape fr}} and \mbox{\texttt{\mdseries\slshape to}} are given, they give a hint, that \mbox{\texttt{\mdseries\slshape w}} is zero outside positions \mbox{\texttt{\mdseries\slshape fr}} to \mbox{\texttt{\mdseries\slshape to}} (inclusively). The method can, if it chooses so, save time by not computing
outside that range. In fact, the implemented method restricts the operation to
the \texttt{Word}s involved.

 If either \mbox{\texttt{\mdseries\slshape fr}} or \mbox{\texttt{\mdseries\slshape to}} is $0$ it defaults to $1$ and \texttt{Length(v)} respectively. }

 

\subsection{\textcolor{Chapter }{MultRowVector (cvecsca)}}
\logpage{[ 4, 2, 8 ]}\nobreak
\hyperdef{L}{X87D8F28D78BC14DD}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MultRowVector({\mdseries\slshape v, s})\index{MultRowVector@\texttt{MultRowVector}!cvecsca}
\label{MultRowVector:cvecsca}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MultRowVector({\mdseries\slshape v, s, fr, to})\index{MultRowVector@\texttt{MultRowVector}!cvecscapospos}
\label{MultRowVector:cvecscapospos}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
nothing



 \mbox{\texttt{\mdseries\slshape v}} must be a mutable \texttt{cvec} and \mbox{\texttt{\mdseries\slshape s}} a scalar (see Subsection \ref{scahandl}). Multiplys \mbox{\texttt{\mdseries\slshape v}} by \mbox{\texttt{\mdseries\slshape s}} modifying \mbox{\texttt{\mdseries\slshape v}}. If \mbox{\texttt{\mdseries\slshape fr}} and \mbox{\texttt{\mdseries\slshape to}} are given, they give a hint, that \mbox{\texttt{\mdseries\slshape v}} is zero outside positions \mbox{\texttt{\mdseries\slshape fr}} to \mbox{\texttt{\mdseries\slshape to}} (inclusively). The method can, if it chooses so, save time by not computing
outside that range. In fact, the implemented method restricts the operation to
the \texttt{Word}s involved.

 If either \mbox{\texttt{\mdseries\slshape fr}} or \mbox{\texttt{\mdseries\slshape to}} is $0$ it defaults to $1$ and \texttt{Length(v)} respectively. }

 

\subsection{\textcolor{Chapter }{ScalarProduct (cveccvec)}}
\logpage{[ 4, 2, 9 ]}\nobreak
\hyperdef{L}{X7F4B8B747E88C59B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ScalarProduct({\mdseries\slshape v, w})\index{ScalarProduct@\texttt{ScalarProduct}!cveccvec}
\label{ScalarProduct:cveccvec}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the scalar product



 Both \mbox{\texttt{\mdseries\slshape v}} and \mbox{\texttt{\mdseries\slshape w}} must be \texttt{cvec}s over the same field with equal length. The function returns the scalar
product of the two vectors. Note that there is a very efficient method for
prime fields with $p < 65536$. In the other cases the method taken is not extremely fast. }

 

\subsection{\textcolor{Chapter }{ZeroMutable (cvec)}}
\logpage{[ 4, 2, 10 ]}\nobreak
\hyperdef{L}{X86115BE97842EC3B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ZeroMutable({\mdseries\slshape v})\index{ZeroMutable@\texttt{ZeroMutable}!cvec}
\label{ZeroMutable:cvec}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
a mutable copy of the zero \texttt{cvec} in the same \texttt{cvecclass} as \mbox{\texttt{\mdseries\slshape v}} 



 \mbox{\texttt{\mdseries\slshape v}} must be a \texttt{cvec}. }

 

\subsection{\textcolor{Chapter }{ZeroVector (cvec)}}
\logpage{[ 4, 2, 11 ]}\nobreak
\hyperdef{L}{X7FB1A37D7F8603B9}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ZeroVector({\mdseries\slshape l, v})\index{ZeroVector@\texttt{ZeroVector}!cvec}
\label{ZeroVector:cvec}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
a mutable copy of the zero \texttt{cvec} over the same field than \mbox{\texttt{\mdseries\slshape v}} but with length \mbox{\texttt{\mdseries\slshape l}}



 \mbox{\texttt{\mdseries\slshape v}} must be a \texttt{cvec} and \mbox{\texttt{\mdseries\slshape l}} a \textsf{GAP} integer. }

 }

 
\section{\textcolor{Chapter }{Element access and slicing}}\logpage{[ 4, 3, 0 ]}
\hyperdef{L}{X7C68FFEC84A86786}{}
{
  \texttt{cvec}s behave to some extend like lists with respect to element access and slicing.
However, they allow only actions that can be implemented efficiently and that
do not change their length. In addition there is a highly optimised function
to copy contiguous sections of \texttt{cvec}s into another \texttt{cvec}. 

\subsection{\textcolor{Chapter }{ELM{\textunderscore}LIST}}
\logpage{[ 4, 3, 1 ]}\nobreak
\hyperdef{L}{X805C33C281B29B00}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ELM{\textunderscore}LIST({\mdseries\slshape v, pos})\index{ELMLIST@\texttt{ELM{\textunderscore}LIST}}
\label{ELMLIST}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
a finite field element



 This is a method for (reading) element access of vectors. \mbox{\texttt{\mdseries\slshape v}} must be a \mbox{\texttt{\mdseries\slshape cvec}} and \mbox{\texttt{\mdseries\slshape pos}} must be a positive integer not greater than the length of \mbox{\texttt{\mdseries\slshape v}}. The finite field element at position \mbox{\texttt{\mdseries\slshape pos}} in \mbox{\texttt{\mdseries\slshape v}} is returned.

 Note that the list access syntax ``\mbox{\texttt{\mdseries\slshape v}}[\mbox{\texttt{\mdseries\slshape pos}}]'' triggers a call to the \texttt{ELM{\textunderscore}LIST} (\ref{ELMLIST}) operation. }

 

\subsection{\textcolor{Chapter }{ASS{\textunderscore}LIST}}
\logpage{[ 4, 3, 2 ]}\nobreak
\hyperdef{L}{X829C3BD17C7A6F4F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ASS{\textunderscore}LIST({\mdseries\slshape v, pos, s})\index{ASSLIST@\texttt{ASS{\textunderscore}LIST}}
\label{ASSLIST}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
nothing



 This is a method for (writing) element access of vectors. \mbox{\texttt{\mdseries\slshape v}} must be a \mbox{\texttt{\mdseries\slshape cvec}} and \mbox{\texttt{\mdseries\slshape pos}} must be a positive integer not greater than the length of \mbox{\texttt{\mdseries\slshape v}}. \mbox{\texttt{\mdseries\slshape s}} must be a finite field element or an integer. The finite field element at
position \mbox{\texttt{\mdseries\slshape pos}} in \mbox{\texttt{\mdseries\slshape v}} is set to \mbox{\texttt{\mdseries\slshape s}}.

 The scalar \mbox{\texttt{\mdseries\slshape s}} is treated exactly as described in Subsection \ref{scahandl}.

 Note that the list access syntax ``\mbox{\texttt{\mdseries\slshape v}}\texttt{[}\mbox{\texttt{\mdseries\slshape pos}}\texttt{] := }\mbox{\texttt{\mdseries\slshape s}}'' triggers a call to the \texttt{ASS{\textunderscore}LIST} (\ref{ASSLIST}) operation. }

 

\subsection{\textcolor{Chapter }{ELMS{\textunderscore}LIST}}
\logpage{[ 4, 3, 3 ]}\nobreak
\hyperdef{L}{X7E3A8E51853DEC58}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ELMS{\textunderscore}LIST({\mdseries\slshape v, l})\index{ELMSLIST@\texttt{ELMS{\textunderscore}LIST}}
\label{ELMSLIST}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
a \texttt{cvec}



 This is a method for (reading) slice access of vectors. \mbox{\texttt{\mdseries\slshape v}} must be a \mbox{\texttt{\mdseries\slshape cvec}} and \mbox{\texttt{\mdseries\slshape l}} must be a range object or a list of positive integers not greater than the
length of \mbox{\texttt{\mdseries\slshape v}}. In both cases the list of numbers must be contiguous list of valid positions
in the vector. A new \texttt{cvec} over the same field as \mbox{\texttt{\mdseries\slshape v}} and with the same length as \mbox{\texttt{\mdseries\slshape l}} is created and returned. The finite field element at i positions \mbox{\texttt{\mdseries\slshape l}} in \mbox{\texttt{\mdseries\slshape v}} are copied into the new vector.

 Note that the list slice access syntax ``\mbox{\texttt{\mdseries\slshape v}}\texttt{\symbol{123}}\mbox{\texttt{\mdseries\slshape l}}\texttt{\symbol{125}}'' triggers a call to the \texttt{ELMS{\textunderscore}LIST} (\ref{ELMSLIST}) operation. }

 Note that there intentionally is no write slice access to \texttt{cvec}s, because in most cases this would lead to code that unnecessarily copies
data around in an expensive way. Please use the following function instead: 

\subsection{\textcolor{Chapter }{CVEC{\textunderscore}Slice}}
\logpage{[ 4, 3, 4 ]}\nobreak
\hyperdef{L}{X78878E5E839265A6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CVEC{\textunderscore}Slice({\mdseries\slshape src, dst, srcpos, len, dstpos})\index{CVECSlice@\texttt{CVEC{\textunderscore}Slice}}
\label{CVECSlice}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
nothing



 \mbox{\texttt{\mdseries\slshape src}} and \mbox{\texttt{\mdseries\slshape dst}} must be \texttt{cvec}s over the same field. The field elements from positions \mbox{\texttt{\mdseries\slshape srcpos}} to $\mbox{\texttt{\mdseries\slshape srcpos}}+\mbox{\texttt{\mdseries\slshape len}}-1$ in \mbox{\texttt{\mdseries\slshape src}} are copied to positions from \mbox{\texttt{\mdseries\slshape dstpos}} in \mbox{\texttt{\mdseries\slshape dst}}. Of course all positions must be within the vectors. 

 Note that this functions is quite efficient, however, the ranges are checked.
If you want to avoid this, use \texttt{CVEC{\textunderscore}SLICE} instead (with same calling convention), but do not complain later if crashes
occur in case of illegal positions used. }

 

\subsection{\textcolor{Chapter }{CopySubVector}}
\logpage{[ 4, 3, 5 ]}\nobreak
\hyperdef{L}{X80EC354D78D7B5A6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CopySubVector({\mdseries\slshape src, dst, srcposs, dstposs})\index{CopySubVector@\texttt{CopySubVector}}
\label{CopySubVector}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
nothing



 Implements the operation \texttt{CopySubVector} (CopySubVector???) for \texttt{cvec}s \mbox{\texttt{\mdseries\slshape src}} and \mbox{\texttt{\mdseries\slshape dst}}, that is, \mbox{\texttt{\mdseries\slshape srcposs}} and \mbox{\texttt{\mdseries\slshape dstposs}} must be ranges or plain lists of integers of equal length such that all
numbers contained lie between $1$ and the length of \mbox{\texttt{\mdseries\slshape src}} and \mbox{\texttt{\mdseries\slshape dst}} respectively. The result is undefined if \mbox{\texttt{\mdseries\slshape src}} and \mbox{\texttt{\mdseries\slshape dst}} are the same objects. The method is particularly efficient if both \mbox{\texttt{\mdseries\slshape srcposs}} and \mbox{\texttt{\mdseries\slshape dstposs}} are ranges with increment $1$. }

 

\subsection{\textcolor{Chapter }{CVEC{\textunderscore}Concatenation}}
\logpage{[ 4, 3, 6 ]}\nobreak
\hyperdef{L}{X84347D8B7DFA790C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CVEC{\textunderscore}Concatenation({\mdseries\slshape arg})\index{CVECConcatenation@\texttt{CVEC{\textunderscore}Concatenation}}
\label{CVECConcatenation}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
a new \texttt{cvec} by concatenating all arguments



 This function provides concatenation of \texttt{cvec}s over the same base field. The result is a new \texttt{cvec}. A variable number of \texttt{cvec}s over the same field can be given. }

 }

 
\section{\textcolor{Chapter }{Comparison of Vectors and other information}}\logpage{[ 4, 4, 0 ]}
\hyperdef{L}{X81F3C9697E5636B6}{}
{
  

\subsection{\textcolor{Chapter }{=}}
\logpage{[ 4, 4, 1 ]}\nobreak
\hyperdef{L}{X806A4814806A4814}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{=({\mdseries\slshape v, w})\index{=@\texttt{=}}
\label{=}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
\texttt{true} or \texttt{false}



 Returns \texttt{true} if the \texttt{cvec}s \mbox{\texttt{\mdseries\slshape v}} and \mbox{\texttt{\mdseries\slshape w}} are equal. The vectors must be over the same field and must have equal length. }

 

\subsection{\textcolor{Chapter }{LT}}
\logpage{[ 4, 4, 2 ]}\nobreak
\hyperdef{L}{X7FBCE84886AB9848}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LT({\mdseries\slshape v, w})\index{LT@\texttt{LT}}
\label{LT}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
\texttt{true} or \texttt{false}



 Returns \texttt{true} if the \texttt{cvec} \mbox{\texttt{\mdseries\slshape v}} is smaller than \mbox{\texttt{\mdseries\slshape w}}. The vectors must be over the same field and must have equal length. The
order implemented is very efficient but is \emph{not} compatible with lexicographic ordering of lists of finite field elements! This
method should therefore only be used for binary search purposes. Note that the
operation \texttt{LT} is the same as \texttt{\texttt{\symbol{92}}{\textless}}. }

 

\subsection{\textcolor{Chapter }{IsZero}}
\logpage{[ 4, 4, 3 ]}\nobreak
\hyperdef{L}{X82BDA47282F9BBA7}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsZero({\mdseries\slshape v})\index{IsZero@\texttt{IsZero}}
\label{IsZero}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
\texttt{true} or \texttt{false}



 Returns \texttt{true} if the \texttt{cvec} \mbox{\texttt{\mdseries\slshape v}} is equal to zero, meaning that all entries are equal to zero. }

 

\subsection{\textcolor{Chapter }{PositionNonZero}}
\logpage{[ 4, 4, 4 ]}\nobreak
\hyperdef{L}{X7F42E5AD87EC9D5A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PositionNonZero({\mdseries\slshape v})\index{PositionNonZero@\texttt{PositionNonZero}}
\label{PositionNonZero}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
a positive integer



 Returns the index of the first entry in the \texttt{cvec} \mbox{\texttt{\mdseries\slshape v}} that is not equal to zero. If the vector is equal to zero, then its \texttt{Length} plus one is returned. }

 

\subsection{\textcolor{Chapter }{PositionLastNonZero}}
\logpage{[ 4, 4, 5 ]}\nobreak
\hyperdef{L}{X8370979D7F451279}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PositionLastNonZero({\mdseries\slshape v})\index{PositionLastNonZero@\texttt{PositionLastNonZero}}
\label{PositionLastNonZero}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
a non-negative integer



 Returns the index of the last entry in the \texttt{cvec} \mbox{\texttt{\mdseries\slshape v}} that is not equal to zero. If the vector is equal to zero, then $0$ is returned. }

 

\subsection{\textcolor{Chapter }{Length}}
\logpage{[ 4, 4, 6 ]}\nobreak
\hyperdef{L}{X780769238600AFD1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Length({\mdseries\slshape v})\index{Length@\texttt{Length}}
\label{Length}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
a non-negative integer



 Returns the length of the \texttt{cvec} \mbox{\texttt{\mdseries\slshape v}}. }

 }

 
\section{\textcolor{Chapter }{Changing representation, Unpacking}}\logpage{[ 4, 5, 0 ]}
\hyperdef{L}{X80A1A9C386FD0E1B}{}
{
  

\subsection{\textcolor{Chapter }{Unpack (cvec)}}
\logpage{[ 4, 5, 1 ]}\nobreak
\hyperdef{L}{X7BD632E57E1EB300}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Unpack({\mdseries\slshape v})\index{Unpack@\texttt{Unpack}!cvec}
\label{Unpack:cvec}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
a list of finite field elements



 This operation unpacks a \texttt{cvec} \mbox{\texttt{\mdseries\slshape v}}. A new plain list containing the corresponding numbers as \textsf{GAP} finite field elements. Note that the vector \mbox{\texttt{\mdseries\slshape v}} remains unchanged. }

 

\subsection{\textcolor{Chapter }{IntegerRep (cvec)}}
\logpage{[ 4, 5, 2 ]}\nobreak
\hyperdef{L}{X850FB74483F87453}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IntegerRep({\mdseries\slshape v})\index{IntegerRep@\texttt{IntegerRep}!cvec}
\label{IntegerRep:cvec}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
a list of integers or of lists of integers



 This operation unpacks a \texttt{cvec} \mbox{\texttt{\mdseries\slshape v}} into its integer representation. A new plain list containing the corresponding
numbers of the vector is returned. The integer representation of a finite
field element is either one integer (containing the p-adic expansion of the
polynomial representative of the residue class modulo the Conway polynomial,
if the field has less or equal to $65536$ elements. For larger finite fields each field element is represented as a list
of $d$ integers between $0$ and $p-1$, where $d$ is the degree of the finite field over its prime field. Note that the vector \mbox{\texttt{\mdseries\slshape v}} remains unchanged. }

 

\subsection{\textcolor{Chapter }{NumberFFVector (cvec)}}
\logpage{[ 4, 5, 3 ]}\nobreak
\hyperdef{L}{X7FDFEF7A7E850151}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NumberFFVector({\mdseries\slshape v, sz})\index{NumberFFVector@\texttt{NumberFFVector}!cvec}
\label{NumberFFVector:cvec}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
an integer



 This implements the library operation \texttt{NumberFFVector} (\textbf{Reference: NumberFFVector}). Note that only the case that \mbox{\texttt{\mdseries\slshape sz}} is the number of elements in the base field of \mbox{\texttt{\mdseries\slshape v}} is implemented. There is an inverse operation called \texttt{CVecNumber} (\ref{CVecNumber}). }

 

\subsection{\textcolor{Chapter }{CVecNumber}}
\logpage{[ 4, 5, 4 ]}\nobreak
\hyperdef{L}{X7A97E6E883E4BDCB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CVecNumber({\mdseries\slshape nr, cl})\index{CVecNumber@\texttt{CVecNumber}}
\label{CVecNumber}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CVecNumber({\mdseries\slshape nr, p, d, l})\index{CVecNumber@\texttt{CVecNumber}}
\label{CVecNumber}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
a \texttt{cvec}



 This is the inverse operation to \texttt{NumberFFVector} (\textbf{Reference: NumberFFVector}). Of course, the base field of the vector and its length has to be specified,
either by giving a \texttt{cvecclass} \mbox{\texttt{\mdseries\slshape cl}} or the parameters \mbox{\texttt{\mdseries\slshape p}}, \mbox{\texttt{\mdseries\slshape d}}, and \mbox{\texttt{\mdseries\slshape l}}. For both cases corresponding methods are available. }

 }

 
\section{\textcolor{Chapter }{Access to the base field}}\logpage{[ 4, 6, 0 ]}
\hyperdef{L}{X853A85AE878B0CBF}{}
{
  

\subsection{\textcolor{Chapter }{BaseDomain (cvec)}}
\logpage{[ 4, 6, 1 ]}\nobreak
\hyperdef{L}{X854192428704857E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{BaseDomain({\mdseries\slshape v})\index{BaseDomain@\texttt{BaseDomain}!cvec}
\label{BaseDomain:cvec}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the base field of \mbox{\texttt{\mdseries\slshape v}} 



 For a \texttt{cvec} \mbox{\texttt{\mdseries\slshape v}} this returns the \textsf{GAP} object \texttt{GF(p,d)}. }

 

\subsection{\textcolor{Chapter }{BaseField (cvec)}}
\logpage{[ 4, 6, 2 ]}\nobreak
\hyperdef{L}{X842335E47DC49702}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{BaseField({\mdseries\slshape v})\index{BaseField@\texttt{BaseField}!cvec}
\label{BaseField:cvec}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the base field of \mbox{\texttt{\mdseries\slshape v}} 



 For a \texttt{cvec} \mbox{\texttt{\mdseries\slshape v}} this returns the \textsf{GAP} object \texttt{GF(p,d)}. }

 

\subsection{\textcolor{Chapter }{Characteristic (cvec)}}
\logpage{[ 4, 6, 3 ]}\nobreak
\hyperdef{L}{X81B99EEC7C134213}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Characteristic({\mdseries\slshape v})\index{Characteristic@\texttt{Characteristic}!cvec}
\label{Characteristic:cvec}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the characteristic of the base field of \mbox{\texttt{\mdseries\slshape v}} 



 Returns the characteristic of the base field of \mbox{\texttt{\mdseries\slshape v}} (see \texttt{BaseField} (\ref{BaseField:cvec})). }

 

\subsection{\textcolor{Chapter }{DegreeFFE (cvec)}}
\logpage{[ 4, 6, 4 ]}\nobreak
\hyperdef{L}{X81E3BBBB80096DC2}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DegreeFFE({\mdseries\slshape v})\index{DegreeFFE@\texttt{DegreeFFE}!cvec}
\label{DegreeFFE:cvec}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the degree of the base field of \mbox{\texttt{\mdseries\slshape v}} over its prime field 



 Returns the degree of the base field of \mbox{\texttt{\mdseries\slshape v}} over its prime field (see \texttt{BaseField} (\ref{BaseField:cvec})). }

 }

 
\section{\textcolor{Chapter }{Hashing techniques for \texttt{cvec}s}}\logpage{[ 4, 7, 0 ]}
\hyperdef{L}{X7CB5FB4C7BBB87E9}{}
{
  

\subsection{\textcolor{Chapter }{CVEC{\textunderscore}HashFunctionForCVecs}}
\logpage{[ 4, 7, 1 ]}\nobreak
\hyperdef{L}{X7F0228A18327F87D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CVEC{\textunderscore}HashFunctionForCVecs({\mdseries\slshape v, data})\index{CVECHashFunctionForCVecs@\texttt{CVE}\-\texttt{C{\textunderscore}}\-\texttt{Hash}\-\texttt{Function}\-\texttt{For}\-\texttt{C}\-\texttt{Vecs}}
\label{CVECHashFunctionForCVecs}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
an integer hash value



 This is a hash function usable for the \texttt{ChooseHashFunction} (\textbf{orb: ChooseHashFunction}) framework. It takes as arguments a \texttt{cvec} \mbox{\texttt{\mdseries\slshape v}} and a list \mbox{\texttt{\mdseries\slshape data}} of length $2$. The first entry of \mbox{\texttt{\mdseries\slshape data}} is the length of the hash table used and the second entry is the number of
bytes looked at in the \texttt{cvec}. }

 

\subsection{\textcolor{Chapter }{ChooseHashFunction}}
\logpage{[ 4, 7, 2 ]}\nobreak
\hyperdef{L}{X7ACED4FB7C971A5A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ChooseHashFunction({\mdseries\slshape v, hashlen})\index{ChooseHashFunction@\texttt{ChooseHashFunction}}
\label{ChooseHashFunction}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
a record describing a hash function



 Chooses a hash function to store \texttt{cvec}s like \mbox{\texttt{\mdseries\slshape v}} in a hash table of length \mbox{\texttt{\mdseries\slshape hashlen}}. The return value is a record with components \texttt{func} and \texttt{data} bound to \texttt{CVEC{\textunderscore}HashFunctionForCVecs} (\ref{CVECHashFunctionForCVecs}) and a list of length $2$ to be given as a second argument to \texttt{CVEC{\textunderscore}HashFunctionForCVecs} (\ref{CVECHashFunctionForCVecs}). This allows to use \texttt{cvec}s in the \texttt{ChooseHashFunction} (\textbf{orb: ChooseHashFunction}) framework. }

 }

  }

   
\chapter{\textcolor{Chapter }{Matrices}}\label{matrices}
\logpage{[ 5, 0, 0 ]}
\hyperdef{L}{X812CCAB278643A59}{}
{
  A compressed matrix (a \texttt{cmat}) behaves very much like a list of \texttt{cvec}s. However, it insists on having only \texttt{cvec}s of the same length and over the same base field as its elements, and it
insists on being a list without holes. Apart from these restrictions, you can
use all the standard list operations with \texttt{cmat}s (see Section \ref{matlists}. 

 In the rest of this chapter, we document all methods for matrices for the sake
of completeness. If they behave exactly as is to be expected by the already
defined operation no further explanation is given. 
\section{\textcolor{Chapter }{Creation}}\label{matcreation}
\logpage{[ 5, 1, 0 ]}
\hyperdef{L}{X788B78DE82579F3D}{}
{
  The basic operation to create new \texttt{cmat}s is \texttt{CMat}, for which a variety of methods is available: 

\subsection{\textcolor{Chapter }{CMat}}
\logpage{[ 5, 1, 1 ]}\nobreak
\hyperdef{L}{X7CC3BB7982789EB1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CMat({\mdseries\slshape l, cl, dochecks})\index{CMat@\texttt{CMat}}
\label{CMat}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CMat({\mdseries\slshape l, cl})\index{CMat@\texttt{CMat}}
\label{CMat}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 a new \texttt{cmat} 



 A new \texttt{cmat} is created with rows being in the \texttt{cvecclass} \mbox{\texttt{\mdseries\slshape cl}}. All elements of the list \mbox{\texttt{\mdseries\slshape l}} must be \texttt{cvec}s in that class. The boolean flag \mbox{\texttt{\mdseries\slshape dochecks}} indicates, whether this should be checked or not. If the flag is omitted,
checks are performed. Note that \mbox{\texttt{\mdseries\slshape l}} may be the empty list. }

 

\subsection{\textcolor{Chapter }{CMat}}
\logpage{[ 5, 1, 2 ]}\nobreak
\hyperdef{L}{X7CC3BB7982789EB1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CMat({\mdseries\slshape l, dochecks})\index{CMat@\texttt{CMat}}
\label{CMat}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CMat({\mdseries\slshape l})\index{CMat@\texttt{CMat}}
\label{CMat}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 a new \texttt{cmat} 



 A new \texttt{cmat} is created with rows being in the \texttt{cvecclass} of the vectors in \mbox{\texttt{\mdseries\slshape l}}. All elements of the list \mbox{\texttt{\mdseries\slshape l}} must be \texttt{cvec}s in the same class. The boolean flag \mbox{\texttt{\mdseries\slshape dochecks}} indicates, whether this should be checked or not. If the flag is omitted,
checks are performed. Note that \mbox{\texttt{\mdseries\slshape l}} may not be the empty list. }

 

\subsection{\textcolor{Chapter }{CMat}}
\logpage{[ 5, 1, 3 ]}\nobreak
\hyperdef{L}{X7CC3BB7982789EB1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CMat({\mdseries\slshape l, v})\index{CMat@\texttt{CMat}}
\label{CMat}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 a new \texttt{cmat} 



 A new \texttt{cmat} is created with rows being in the \texttt{cvecclass} of the \texttt{cvec} \mbox{\texttt{\mdseries\slshape v}}. All elements of the list \mbox{\texttt{\mdseries\slshape l}} must be \texttt{cvec}s in the that same class. This is checked. Note that \mbox{\texttt{\mdseries\slshape l}} may be the empty list. }

 

\subsection{\textcolor{Chapter }{CMat}}
\logpage{[ 5, 1, 4 ]}\nobreak
\hyperdef{L}{X7CC3BB7982789EB1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CMat({\mdseries\slshape m})\index{CMat@\texttt{CMat}}
\label{CMat}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 a new \texttt{cmat} 



 Creates a new \texttt{cmat} which is equal to \mbox{\texttt{\mdseries\slshape m}}, which must be a compressed matrix in the filter \texttt{IsGF2MatrixRep} or the filter \texttt{Is8BitMatrixRep}. }

 There are some methods to create \texttt{cmat}s of special form: 

\subsection{\textcolor{Chapter }{CVEC{\textunderscore}ZeroMat}}
\logpage{[ 5, 1, 5 ]}\nobreak
\hyperdef{L}{X85DE9EF67ADE6A6B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CVEC{\textunderscore}ZeroMat({\mdseries\slshape rows, cl})\index{CVECZeroMat@\texttt{CVEC{\textunderscore}ZeroMat}}
\label{CVECZeroMat}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CVEC{\textunderscore}ZeroMat({\mdseries\slshape rows, cols, p, d})\index{CVECZeroMat@\texttt{CVEC{\textunderscore}ZeroMat}}
\label{CVECZeroMat}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 a new \texttt{cmat} 



 Creates a zero matrix with \mbox{\texttt{\mdseries\slshape rows}} rows and \mbox{\texttt{\mdseries\slshape cols}} columns over the field \texttt{GF(\mbox{\texttt{\mdseries\slshape p}},\mbox{\texttt{\mdseries\slshape d}})}. If a \texttt{cvecclass} \mbox{\texttt{\mdseries\slshape cl}} is given, the number of columns and the field follow from that. }

 

\subsection{\textcolor{Chapter }{CVEC{\textunderscore}IdentityMat}}
\logpage{[ 5, 1, 6 ]}\nobreak
\hyperdef{L}{X7C188AFF84F2E3ED}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CVEC{\textunderscore}IdentityMat({\mdseries\slshape rows, cl})\index{CVECIdentityMat@\texttt{CVEC{\textunderscore}IdentityMat}}
\label{CVECIdentityMat}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CVEC{\textunderscore}IdentityMat({\mdseries\slshape rows, cols, p, d})\index{CVECIdentityMat@\texttt{CVEC{\textunderscore}IdentityMat}}
\label{CVECIdentityMat}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 a new \texttt{cmat} 



 Creates an identity matrix with \mbox{\texttt{\mdseries\slshape rows}} rows and \mbox{\texttt{\mdseries\slshape cols}} columns over the field \texttt{GF(\mbox{\texttt{\mdseries\slshape p}},\mbox{\texttt{\mdseries\slshape d}})}. If a \texttt{cvecclass} \mbox{\texttt{\mdseries\slshape cl}} is given, the number of columns and the field follow from that. }

 

\subsection{\textcolor{Chapter }{CVEC{\textunderscore}RandomMat}}
\logpage{[ 5, 1, 7 ]}\nobreak
\hyperdef{L}{X879CE439863CC8D1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CVEC{\textunderscore}RandomMat({\mdseries\slshape rows, cl})\index{CVECRandomMat@\texttt{CVEC{\textunderscore}RandomMat}}
\label{CVECRandomMat}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CVEC{\textunderscore}RandomMat({\mdseries\slshape rows, cols, p, d})\index{CVECRandomMat@\texttt{CVEC{\textunderscore}RandomMat}}
\label{CVECRandomMat}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 a new \texttt{cmat} 



 Creates a random matrix with \mbox{\texttt{\mdseries\slshape rows}} rows and \mbox{\texttt{\mdseries\slshape cols}} columns over the field \texttt{GF(\mbox{\texttt{\mdseries\slshape p}},\mbox{\texttt{\mdseries\slshape d}})}. If a \texttt{cvecclass} \mbox{\texttt{\mdseries\slshape cl}} is given, the number of columns and the field follow from that. Note that this
is not particularly efficient. }

 

\subsection{\textcolor{Chapter }{MutableCopyMat}}
\logpage{[ 5, 1, 8 ]}\nobreak
\hyperdef{L}{X78BD0AD885D4C2FF}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MutableCopyMat({\mdseries\slshape m})\index{MutableCopyMat@\texttt{MutableCopyMat}}
\label{MutableCopyMat}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 a mutable copy of \mbox{\texttt{\mdseries\slshape m}} 



 Creates a mutable copy of the \texttt{cmat} \mbox{\texttt{\mdseries\slshape m}}. }

 

\subsection{\textcolor{Chapter }{Matrix}}
\logpage{[ 5, 1, 9 ]}\nobreak
\hyperdef{L}{X879384D479EB1D82}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Matrix({\mdseries\slshape vectorlist, vector})\index{Matrix@\texttt{Matrix}}
\label{Matrix}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MatrixNC({\mdseries\slshape vectorlist, vector})\index{MatrixNC@\texttt{MatrixNC}}
\label{MatrixNC}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 a new mutable \texttt{cmat} 



 Returns a new \texttt{cmat} containing the vectors in \mbox{\texttt{\mdseries\slshape vectorlist}} as rows. The elements in \mbox{\texttt{\mdseries\slshape vectorlist}} must be vectors of the same length as the sample vector \mbox{\texttt{\mdseries\slshape vector}} and must live over the same base field. The sample vector is always necessary
to be able to use the method selection. The \mbox{\texttt{\mdseries\slshape vectorlist}} may be empty. The NC method does not check the inputs. }

 }

 
\section{\textcolor{Chapter }{Matrices as lists}}\label{matlists}
\logpage{[ 5, 2, 0 ]}
\hyperdef{L}{X7C9F7D327BAECA5E}{}
{
  In this section, arguments named \mbox{\texttt{\mdseries\slshape m}} and \mbox{\texttt{\mdseries\slshape n}} are \texttt{cmat}s and \mbox{\texttt{\mdseries\slshape v}} and \mbox{\texttt{\mdseries\slshape w}} are \texttt{cvec}s that fit into the corresponding matrices. \mbox{\texttt{\mdseries\slshape pos}} is an integer between $1$ and \texttt{Length(m)} if it applies to the matrix \mbox{\texttt{\mdseries\slshape m}}. 

\subsection{\textcolor{Chapter }{Add}}
\logpage{[ 5, 2, 1 ]}\nobreak
\hyperdef{L}{X795EC9D67E34DAB0}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Add({\mdseries\slshape m, v[, pos]})\index{Add@\texttt{Add}}
\label{Add}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 nothing 



 Behaves exactly as expected. Note that one can only add \texttt{cvec}s of the right length and over the right field. }

 

\subsection{\textcolor{Chapter }{Remove}}
\logpage{[ 5, 2, 2 ]}\nobreak
\hyperdef{L}{X7E98B11B79BA9167}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Remove({\mdseries\slshape m[, pos]})\index{Remove@\texttt{Remove}}
\label{Remove}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 a \texttt{cvec} 



 Behaves exactly as expected. No holes can be made. }

 

\subsection{\textcolor{Chapter }{ELM{\textunderscore}LIST}}
\logpage{[ 5, 2, 3 ]}\nobreak
\hyperdef{L}{X805C33C281B29B00}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ELM{\textunderscore}LIST({\mdseries\slshape m, pos})\index{ELMLIST@\texttt{ELM{\textunderscore}LIST}}
\label{ELMLIST}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 a \texttt{cvec} 



 Behaves exactly as expected. Note that this method is triggered when one uses
the (reading) syntax ``\texttt{m[pos]}''. }

 

\subsection{\textcolor{Chapter }{ASS{\textunderscore}LIST}}
\logpage{[ 5, 2, 4 ]}\nobreak
\hyperdef{L}{X829C3BD17C7A6F4F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ASS{\textunderscore}LIST({\mdseries\slshape m, pos, v})\index{ASSLIST@\texttt{ASS{\textunderscore}LIST}}
\label{ASSLIST}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 nothing 



 Behaves exactly as expected. Note that one can only assign to positions such
that the resulting matrix has no holes. This method is triggered when one uses
the (assignment) syntax ``\texttt{m[pos] := }''. }

 

\subsection{\textcolor{Chapter }{ELMS{\textunderscore}LIST}}
\logpage{[ 5, 2, 5 ]}\nobreak
\hyperdef{L}{X7E3A8E51853DEC58}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ELMS{\textunderscore}LIST({\mdseries\slshape m, poss})\index{ELMSLIST@\texttt{ELMS{\textunderscore}LIST}}
\label{ELMSLIST}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 a sub \texttt{cmat}



 Behaves exactly as expected: A new matrix containing a subset of the rows is
returned. Note that the row vectors are the same \textsf{GAP} objects as the corresponding rows of \mbox{\texttt{\mdseries\slshape m}}. This operation is triggered by the expression \mbox{\texttt{\mdseries\slshape m}}\texttt{\texttt{\symbol{123}}\mbox{\texttt{\mdseries\slshape poss}}\texttt{\symbol{125}}}. }

 

\subsection{\textcolor{Chapter }{ASSS{\textunderscore}LIST}}
\logpage{[ 5, 2, 6 ]}\nobreak
\hyperdef{L}{X82C3E70078F51817}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ASSS{\textunderscore}LIST({\mdseries\slshape m, poss, vals})\index{ASSSLIST@\texttt{ASSS{\textunderscore}LIST}}
\label{ASSSLIST}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 nothing 



 Behaves exactly as expected. Of course all values in \mbox{\texttt{\mdseries\slshape vals}} must be \texttt{cvec}s over the correct field and the \texttt{cmat} \mbox{\texttt{\mdseries\slshape m}} must be a dense list afterwards. This operation is triggered by the statement \mbox{\texttt{\mdseries\slshape m}}\texttt{\texttt{\symbol{123}}\mbox{\texttt{\mdseries\slshape poss}}\texttt{\symbol{125}} := \mbox{\texttt{\mdseries\slshape vals}}}. }

 

\subsection{\textcolor{Chapter }{Length}}
\logpage{[ 5, 2, 7 ]}\nobreak
\hyperdef{L}{X780769238600AFD1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Length({\mdseries\slshape m})\index{Length@\texttt{Length}}
\label{Length}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 the number of rows of the \texttt{cmat} \mbox{\texttt{\mdseries\slshape m}}



 Behaves exactly as expected. }

 

\subsection{\textcolor{Chapter }{ShallowCopy}}
\logpage{[ 5, 2, 8 ]}\nobreak
\hyperdef{L}{X846BC7107C352031}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ShallowCopy({\mdseries\slshape m})\index{ShallowCopy@\texttt{ShallowCopy}}
\label{ShallowCopy}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 a new matrix containing the same rows than the \texttt{cmat} \mbox{\texttt{\mdseries\slshape m}} 



 Behaves exactly as expected. Note that the rows of the result are the very
same \textsf{GAP} objects than the rows of the \texttt{cmat} \mbox{\texttt{\mdseries\slshape m}}. }

 

\subsection{\textcolor{Chapter }{Collected}}
\logpage{[ 5, 2, 9 ]}\nobreak
\hyperdef{L}{X7ECE9056792F28BA}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Collected({\mdseries\slshape m})\index{Collected@\texttt{Collected}}
\label{Collected}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 the same as the collected list of the rows of \mbox{\texttt{\mdseries\slshape m}}



 Behaves exactly as expected. Just uses the standard \texttt{Collected} (\textbf{Reference: Collected}) on the list of rows. }

 

\subsection{\textcolor{Chapter }{DuplicateFreeList}}
\logpage{[ 5, 2, 10 ]}\nobreak
\hyperdef{L}{X8727F2928467C2F9}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DuplicateFreeList({\mdseries\slshape m})\index{DuplicateFreeList@\texttt{DuplicateFreeList}}
\label{DuplicateFreeList}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 a new mutable \texttt{cmat} containing the rows of \mbox{\texttt{\mdseries\slshape m}} with duplicates removed



 Behaves exactly as expected. Just uses the standard \texttt{DuplicateFreeList} (\textbf{Reference: DuplicateFreeList}) on the list of rows. }

 

\subsection{\textcolor{Chapter }{Append}}
\logpage{[ 5, 2, 11 ]}\nobreak
\hyperdef{L}{X79E31DB27C82D6E1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Append({\mdseries\slshape m, n})\index{Append@\texttt{Append}}
\label{Append}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 nothing 



 Behaves exactly as expected. Of course, the \texttt{cmat}s \mbox{\texttt{\mdseries\slshape m}} and \mbox{\texttt{\mdseries\slshape n}} must be over the same field and have the same number of columns. Note that the
rows of \mbox{\texttt{\mdseries\slshape n}} themselves (and no copies) will be put into the matrix \mbox{\texttt{\mdseries\slshape m}}. }

 

\subsection{\textcolor{Chapter }{Filtered}}
\logpage{[ 5, 2, 12 ]}\nobreak
\hyperdef{L}{X7C86D7F7795125F0}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Filtered({\mdseries\slshape m, f})\index{Filtered@\texttt{Filtered}}
\label{Filtered}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 a new \texttt{cmat} containing some of the rows of \mbox{\texttt{\mdseries\slshape m}}



 Behaves exactly as expected. The function \mbox{\texttt{\mdseries\slshape f}} will be called for each row of \mbox{\texttt{\mdseries\slshape m}}. }

 

\subsection{\textcolor{Chapter }{Unbind}}
\logpage{[ 5, 2, 13 ]}\nobreak
\hyperdef{L}{X82AACD43853C24D1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Unbind({\mdseries\slshape m, f})\index{Unbind@\texttt{Unbind}}
\label{Unbind}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 nothing 



 Behaves exactly as expected. Of course, only the last bound row may be
unbound. }

 }

 
\section{\textcolor{Chapter }{Arithmetic}}\label{arithmetic}
\logpage{[ 5, 3, 0 ]}
\hyperdef{L}{X79862FF37B75BF48}{}
{
  Of course, the standard arithmetic infix operations $+$, $-$ and $*$ (for vectors and scalars) work as expected by using the methods below. The
comments on the usage of scalars in arithmetic operations involving vectors
from Subsection \ref{scahandl} apply analogously. 

\subsection{\textcolor{Chapter }{\texttt{\symbol{92}}+ (cmatcmat)}}
\logpage{[ 5, 3, 1 ]}\nobreak
\hyperdef{L}{X819B1A8A7DE1EE88}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{\texttt{\symbol{92}}+({\mdseries\slshape m, n})\index{+@\texttt{\texttt{\symbol{92}}+}!cmatcmat}
\label{+:cmatcmat}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the sum $\mbox{\texttt{\mdseries\slshape m}}+\mbox{\texttt{\mdseries\slshape n}}$ as a new \texttt{cmat}



 For two \texttt{cmat}s \mbox{\texttt{\mdseries\slshape m}} and \mbox{\texttt{\mdseries\slshape n}}. Works as expected. }

 

\subsection{\textcolor{Chapter }{\texttt{\symbol{92}}- (cmatcmat)}}
\logpage{[ 5, 3, 2 ]}\nobreak
\hyperdef{L}{X814AFD8E8377D4DB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{\texttt{\symbol{92}}-({\mdseries\slshape m, n})\index{-@\texttt{\texttt{\symbol{92}}-}!cmatcmat}
\label{-:cmatcmat}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the difference $\mbox{\texttt{\mdseries\slshape m}}-\mbox{\texttt{\mdseries\slshape n}}$ as a new \texttt{cmat}



 For two \texttt{cmat}s \mbox{\texttt{\mdseries\slshape m}} and \mbox{\texttt{\mdseries\slshape n}}. Works as expected. }

 

\subsection{\textcolor{Chapter }{AdditiveInverseSameMutability (cmat)}}
\logpage{[ 5, 3, 3 ]}\nobreak
\hyperdef{L}{X82AFC3A987140922}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{AdditiveInverseSameMutability({\mdseries\slshape m})\index{AdditiveInverseSameMutability@\texttt{AdditiveInverseSameMutability}!cmat}
\label{AdditiveInverseSameMutability:cmat}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{\texttt{\symbol{92}}-({\mdseries\slshape m})\index{-@\texttt{\texttt{\symbol{92}}-}!cmat}
\label{-:cmat}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the additive inverse of \mbox{\texttt{\mdseries\slshape m}} as a new \texttt{cmat}



 For a \texttt{cmat} \mbox{\texttt{\mdseries\slshape m}}. Works as expected. }

 

\subsection{\textcolor{Chapter }{AdditiveInverseMutable (cmat)}}
\logpage{[ 5, 3, 4 ]}\nobreak
\hyperdef{L}{X8548396F7D4CAC21}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{AdditiveInverseMutable({\mdseries\slshape m})\index{AdditiveInverseMutable@\texttt{AdditiveInverseMutable}!cmat}
\label{AdditiveInverseMutable:cmat}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the additive inverse of \mbox{\texttt{\mdseries\slshape m}} as a new mutable \texttt{cmat} 



 For a \texttt{cmat} \mbox{\texttt{\mdseries\slshape m}}. Works as expected. }

 

\subsection{\textcolor{Chapter }{\texttt{\symbol{92}}* (cmatsca)}}
\logpage{[ 5, 3, 5 ]}\nobreak
\hyperdef{L}{X848404F57FBFFE7A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{\texttt{\symbol{92}}*({\mdseries\slshape m, s})\index{*@\texttt{\texttt{\symbol{92}}*}!cmatsca}
\label{*:cmatsca}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{\texttt{\symbol{92}}*({\mdseries\slshape s, m})\index{*@\texttt{\texttt{\symbol{92}}*}!scacmat}
\label{*:scacmat}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the scalar multiple \mbox{\texttt{\mdseries\slshape s}}$\cdot$\mbox{\texttt{\mdseries\slshape m}}



 For a \texttt{cmat} \mbox{\texttt{\mdseries\slshape m}} and a scalar \mbox{\texttt{\mdseries\slshape s}}. For the format of the scalar see \ref{scahandl}. Works as expected. }

 

\subsection{\textcolor{Chapter }{\texttt{\symbol{92}}* (cveccmat)}}
\logpage{[ 5, 3, 6 ]}\nobreak
\hyperdef{L}{X7DAFB0227C5529C6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{\texttt{\symbol{92}}*({\mdseries\slshape v, m})\index{*@\texttt{\texttt{\symbol{92}}*}!cveccmat}
\label{*:cveccmat}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the product \mbox{\texttt{\mdseries\slshape v}}$\cdot$\mbox{\texttt{\mdseries\slshape m}}



 For a \texttt{cmat} \mbox{\texttt{\mdseries\slshape m}} and a \texttt{cvec} \mbox{\texttt{\mdseries\slshape s}} with the same length as the number of rows of \mbox{\texttt{\mdseries\slshape m}}. Works as expected. Note that there is a very fast method for the case that \mbox{\texttt{\mdseries\slshape m}} is pre-greased (see \ref{greasemat}). }

 

\subsection{\textcolor{Chapter }{\texttt{\symbol{92}}\texttt{\symbol{94}} (cveccmat)}}
\logpage{[ 5, 3, 7 ]}\nobreak
\hyperdef{L}{X8255927C7923A294}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{\texttt{\symbol{92}}\texttt{\symbol{94}}({\mdseries\slshape v, m})\index{^@\texttt{\texttt{\symbol{92}}\texttt{\symbol{94}}}!cveccmat}
\label{^:cveccmat}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the product \mbox{\texttt{\mdseries\slshape v}}$\cdot$\mbox{\texttt{\mdseries\slshape m}}



 For a \texttt{cmat} \mbox{\texttt{\mdseries\slshape m}} and a \texttt{cvec} \mbox{\texttt{\mdseries\slshape s}} with the same length as the number of rows of \mbox{\texttt{\mdseries\slshape m}}. Works as expected. Note that there is a very fast method for the case that \mbox{\texttt{\mdseries\slshape m}} is pre-greased (see \ref{greasemat}). }

 

\subsection{\textcolor{Chapter }{\texttt{\symbol{92}}* (cmatcmat)}}
\logpage{[ 5, 3, 8 ]}\nobreak
\hyperdef{L}{X7F673C397A919D81}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{\texttt{\symbol{92}}*({\mdseries\slshape m, n})\index{*@\texttt{\texttt{\symbol{92}}*}!cmatcmat}
\label{*:cmatcmat}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the product \mbox{\texttt{\mdseries\slshape m}}$\cdot$\mbox{\texttt{\mdseries\slshape n}}



 Of course, the \texttt{cmat} \mbox{\texttt{\mdseries\slshape m}} must have as many columns as the \texttt{cmat} \mbox{\texttt{\mdseries\slshape n}} has rows. Works as expected. Note that there is a very fast method for the
case that \mbox{\texttt{\mdseries\slshape n}} is pre-greased (see \ref{greasemat}). }

 

\subsection{\textcolor{Chapter }{ZeroSameMutability (cmat)}}
\logpage{[ 5, 3, 9 ]}\nobreak
\hyperdef{L}{X781AD339797C0625}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ZeroSameMutability({\mdseries\slshape m})\index{ZeroSameMutability@\texttt{ZeroSameMutability}!cmat}
\label{ZeroSameMutability:cmat}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the zero \texttt{cmat} over the same field and with the same dimensions as \mbox{\texttt{\mdseries\slshape m}} 



 \mbox{\texttt{\mdseries\slshape m}} must be a \texttt{cmat}. }

 

\subsection{\textcolor{Chapter }{ZeroMutable (cmat)}}
\logpage{[ 5, 3, 10 ]}\nobreak
\hyperdef{L}{X796D9B2C83C0667B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ZeroMutable({\mdseries\slshape m})\index{ZeroMutable@\texttt{ZeroMutable}!cmat}
\label{ZeroMutable:cmat}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
a mutable copy of the zero \texttt{cmat} over the same field and with the same dimensions as \mbox{\texttt{\mdseries\slshape m}} 



 \mbox{\texttt{\mdseries\slshape m}} must be a \texttt{cmat}. }

 

\subsection{\textcolor{Chapter }{OneSameMutability (cmat)}}
\logpage{[ 5, 3, 11 ]}\nobreak
\hyperdef{L}{X7ED3BC7D8198EE2E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{OneSameMutability({\mdseries\slshape m})\index{OneSameMutability@\texttt{OneSameMutability}!cmat}
\label{OneSameMutability:cmat}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the identity \texttt{cmat} over the same field and with the same dimensions as \mbox{\texttt{\mdseries\slshape m}} 



 \mbox{\texttt{\mdseries\slshape m}} must be a square \texttt{cmat}. }

 

\subsection{\textcolor{Chapter }{OneMutable (cmat)}}
\logpage{[ 5, 3, 12 ]}\nobreak
\hyperdef{L}{X7FBD3ABF80EB659C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{OneMutable({\mdseries\slshape m})\index{OneMutable@\texttt{OneMutable}!cmat}
\label{OneMutable:cmat}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
a mutable copy of the identity \texttt{cmat} over the same field and with the same dimensions as \mbox{\texttt{\mdseries\slshape m}} 



 \mbox{\texttt{\mdseries\slshape m}} must be a square \texttt{cmat}. }

 

\subsection{\textcolor{Chapter }{InverseMutable}}
\logpage{[ 5, 3, 13 ]}\nobreak
\hyperdef{L}{X78F9A4028122E39B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{InverseMutable({\mdseries\slshape m})\index{InverseMutable@\texttt{InverseMutable}}
\label{InverseMutable}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 the multiplicative inverse of \mbox{\texttt{\mdseries\slshape m}}



 If the \texttt{cmat} is not square or not invertible then \texttt{fail} is returned. Behaves exactly as expected. }

 

\subsection{\textcolor{Chapter }{InverseSameMutability}}
\logpage{[ 5, 3, 14 ]}\nobreak
\hyperdef{L}{X8593B0F886BBD8A7}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{InverseSameMutability({\mdseries\slshape m})\index{InverseSameMutability@\texttt{InverseSameMutability}}
\label{InverseSameMutability}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 the multiplicative inverse of \mbox{\texttt{\mdseries\slshape m}}



 If the \texttt{cmat} is not square or not invertible then \texttt{fail} is returned. Behaves exactly as expected. }

 

\subsection{\textcolor{Chapter }{TransposedMat}}
\logpage{[ 5, 3, 15 ]}\nobreak
\hyperdef{L}{X87F304F3826A7063}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{TransposedMat({\mdseries\slshape m})\index{TransposedMat@\texttt{TransposedMat}}
\label{TransposedMat}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 the transpose of \mbox{\texttt{\mdseries\slshape m}}



 Behaves exactly as expected. }

 

\subsection{\textcolor{Chapter }{KroneckerProduct}}
\logpage{[ 5, 3, 16 ]}\nobreak
\hyperdef{L}{X8634C79E7DB22934}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{KroneckerProduct({\mdseries\slshape m, n})\index{KroneckerProduct@\texttt{KroneckerProduct}}
\label{KroneckerProduct}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 the Kronecker product of \mbox{\texttt{\mdseries\slshape m}} and \mbox{\texttt{\mdseries\slshape n}} 



 Behaves exactly as expected. }

 }

 
\section{\textcolor{Chapter }{Comparison of matrices and other information}}\label{comparemat}
\logpage{[ 5, 4, 0 ]}
\hyperdef{L}{X845009E07A011131}{}
{
  

\subsection{\textcolor{Chapter }{=}}
\logpage{[ 5, 4, 1 ]}\nobreak
\hyperdef{L}{X806A4814806A4814}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{=({\mdseries\slshape m, n})\index{=@\texttt{=}}
\label{=}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
\texttt{true} or \texttt{false}



 Returns \texttt{true} if the \texttt{cmat}s \mbox{\texttt{\mdseries\slshape m}} and \mbox{\texttt{\mdseries\slshape n}} are equal. The matrices must be over the same field and must have equal
dimensions. }

 

\subsection{\textcolor{Chapter }{LT}}
\logpage{[ 5, 4, 2 ]}\nobreak
\hyperdef{L}{X7FBCE84886AB9848}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LT({\mdseries\slshape m, n})\index{LT@\texttt{LT}}
\label{LT}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
\texttt{true} or \texttt{false}



 Returns \texttt{true} if the \texttt{cmat} \mbox{\texttt{\mdseries\slshape m}} is smaller than \mbox{\texttt{\mdseries\slshape n}}. The matrices must be over the same field and must have equal dimensions. The
method implements the lexicographic order and uses \texttt{LT} for the ordering of vectors. Note that the operation \texttt{LT} is the same as \texttt{\texttt{\symbol{92}}{\textless}}. }

 

\subsection{\textcolor{Chapter }{IsZero}}
\logpage{[ 5, 4, 3 ]}\nobreak
\hyperdef{L}{X82BDA47282F9BBA7}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsZero({\mdseries\slshape m})\index{IsZero@\texttt{IsZero}}
\label{IsZero}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
\texttt{true} or \texttt{false}



 Returns \texttt{true} if the \texttt{cmat} \mbox{\texttt{\mdseries\slshape m}} is equal to zero, meaning that all entries are equal to zero. }

 

\subsection{\textcolor{Chapter }{IsOne}}
\logpage{[ 5, 4, 4 ]}\nobreak
\hyperdef{L}{X814D78347858EC13}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsOne({\mdseries\slshape m})\index{IsOne@\texttt{IsOne}}
\label{IsOne}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
\texttt{true} or \texttt{false}



 Returns \texttt{true} iff the \texttt{cmat} \mbox{\texttt{\mdseries\slshape m}} is equal to the identity matrix. }

 

\subsection{\textcolor{Chapter }{IsDiagonalMat}}
\logpage{[ 5, 4, 5 ]}\nobreak
\hyperdef{L}{X7FF01BF686AD0623}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsDiagonalMat({\mdseries\slshape m})\index{IsDiagonalMat@\texttt{IsDiagonalMat}}
\label{IsDiagonalMat}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
\texttt{true} or \texttt{false}



 Returns \texttt{true} iff the \texttt{cmat} \mbox{\texttt{\mdseries\slshape m}} is a diagonal matrix. }

 

\subsection{\textcolor{Chapter }{IsUpperTriangularMat}}
\logpage{[ 5, 4, 6 ]}\nobreak
\hyperdef{L}{X7ECFBD9F8664982B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsUpperTriangularMat({\mdseries\slshape m})\index{IsUpperTriangularMat@\texttt{IsUpperTriangularMat}}
\label{IsUpperTriangularMat}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
\texttt{true} or \texttt{false}



 Returns \texttt{true} iff the \texttt{cmat} \mbox{\texttt{\mdseries\slshape m}} is an upper triangular matrix. }

 

\subsection{\textcolor{Chapter }{IsLowerTriangularMat}}
\logpage{[ 5, 4, 7 ]}\nobreak
\hyperdef{L}{X81671CFD7CFE4819}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsLowerTriangularMat({\mdseries\slshape m})\index{IsLowerTriangularMat@\texttt{IsLowerTriangularMat}}
\label{IsLowerTriangularMat}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
\texttt{true} or \texttt{false}



 Returns \texttt{true} iff the \texttt{cmat} \mbox{\texttt{\mdseries\slshape m}} is a lower triangular matrix. }

 

\subsection{\textcolor{Chapter }{CVEC{\textunderscore}HashFunctionForCMats}}
\logpage{[ 5, 4, 8 ]}\nobreak
\hyperdef{L}{X875B076C8559CAF0}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CVEC{\textunderscore}HashFunctionForCMats({\mdseries\slshape m, data})\index{CVECHashFunctionForCMats@\texttt{CVE}\-\texttt{C{\textunderscore}}\-\texttt{Hash}\-\texttt{Function}\-\texttt{For}\-\texttt{C}\-\texttt{Mats}}
\label{CVECHashFunctionForCMats}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
an integer hash value



 This is a hash function usable for the \texttt{ChooseHashFunction} (\textbf{orb: ChooseHashFunction}) framework. It takes as arguments a \texttt{cmat} \mbox{\texttt{\mdseries\slshape m}} and a list \mbox{\texttt{\mdseries\slshape data}} of length $2$. The first entry of \mbox{\texttt{\mdseries\slshape data}} is the length of the hash table used and the second entry is the number of
bytes looked at in the \texttt{cvec}s in the matrices. }

 

\subsection{\textcolor{Chapter }{ChooseHashFunction}}
\logpage{[ 5, 4, 9 ]}\nobreak
\hyperdef{L}{X7ACED4FB7C971A5A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ChooseHashFunction({\mdseries\slshape m, l})\index{ChooseHashFunction@\texttt{ChooseHashFunction}}
\label{ChooseHashFunction}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 a record with entries \texttt{func} and \texttt{data}.



 Chooses a hash function to be used for \texttt{cmat}s like \mbox{\texttt{\mdseries\slshape m}} (that is, over the same field with the same number of columns) and for hash
tables of length \mbox{\texttt{\mdseries\slshape l}}. The hash function itself is stored in the \texttt{func} component of the resulting record. The hash function has to be called with two
arguments: the first must be a matrix like \mbox{\texttt{\mdseries\slshape m}} and the second must be the value of the \texttt{data} component of the resulting record. }

 }

 
\section{\textcolor{Chapter }{Slicing and submatrices}}\label{slicingmat}
\logpage{[ 5, 5, 0 ]}
\hyperdef{L}{X7B54DF167CFC6C0F}{}
{
  As described in Section \ref{matlists} you can use the slicing operator \texttt{\texttt{\symbol{92}}\texttt{\symbol{123}}\texttt{\symbol{92}}\texttt{\symbol{125}}} for read and write access of a subset of the rows of a \texttt{cmat}. However, the double slicing operator is not supported. The reason for this
is twofold: First there is a technical issue that the double slicing operator
cannot easily be overloaded in the \textsf{GAP} system. The second is, that very often the double slicing operator is used to
copy a part of one matrix to another part of another matrix using double
slicing on both sides of an assignment. This is quite inefficient because it
creates an intermediate object, namely the submatrix which is extracted. 

 Therefore we have chosen to support submatrix access through two operations \texttt{ExtractSubMatrix} (\ref{ExtractSubMatrix}) and \texttt{CopySubMatrix} (\ref{CopySubMatrix}) described below. 

\subsection{\textcolor{Chapter }{ExtractSubMatrix}}
\logpage{[ 5, 5, 1 ]}\nobreak
\hyperdef{L}{X838B45F7790E9FDF}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ExtractSubMatrix({\mdseries\slshape m, rows, cols})\index{ExtractSubMatrix@\texttt{ExtractSubMatrix}}
\label{ExtractSubMatrix}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
 a submatrix of \mbox{\texttt{\mdseries\slshape m}} 



 This operation extracts the submatrix of the matrix \mbox{\texttt{\mdseries\slshape m}} consisting of the rows described by the integer list (or range) \mbox{\texttt{\mdseries\slshape rows}} and of the columns described by the integer list (or range) \mbox{\texttt{\mdseries\slshape cols}}. This is thus equivalent to the usage \mbox{\texttt{\mdseries\slshape m}}\texttt{\texttt{\symbol{123}}}\mbox{\texttt{\mdseries\slshape rows}}\texttt{\texttt{\symbol{125}}\texttt{\symbol{123}}}\mbox{\texttt{\mdseries\slshape cols}}\texttt{\texttt{\symbol{125}}}. Note that the latter does not work for \texttt{cmat}s, whereas a quite efficient method for \texttt{ExtractSubMatrix} is available for \texttt{cmat}s. }

 

\subsection{\textcolor{Chapter }{CopySubMatrix}}
\logpage{[ 5, 5, 2 ]}\nobreak
\hyperdef{L}{X7ED9E5D4809E3B50}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CopySubMatrix({\mdseries\slshape src, dst, srows, drows, scols, dcols})\index{CopySubMatrix@\texttt{CopySubMatrix}}
\label{CopySubMatrix}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
 nothing 



 This operation extracts the submatrix of the matrix \mbox{\texttt{\mdseries\slshape src}} consisting of the rows described by the integer list (or range) \mbox{\texttt{\mdseries\slshape srows}} and of the columns described by the integer list (or range) \mbox{\texttt{\mdseries\slshape scols}} and copies it into the submatrix of \mbox{\texttt{\mdseries\slshape dst}} described by the integer lists (or ranges) \mbox{\texttt{\mdseries\slshape drows}} and \mbox{\texttt{\mdseries\slshape dcols}}. No intermediate object is created. This is thus equivalent to the usage \mbox{\texttt{\mdseries\slshape dst}}\texttt{\texttt{\symbol{123}}}\mbox{\texttt{\mdseries\slshape drows}}\texttt{\texttt{\symbol{125}}\texttt{\symbol{123}}}\mbox{\texttt{\mdseries\slshape dcols}}\texttt{\texttt{\symbol{125}} := }\mbox{\texttt{\mdseries\slshape src}}\texttt{\texttt{\symbol{123}}}\mbox{\texttt{\mdseries\slshape srows}}\texttt{\texttt{\symbol{125}}\texttt{\symbol{123}}}\mbox{\texttt{\mdseries\slshape scols}}\texttt{\texttt{\symbol{125}}}. Note that the latter does not work for \texttt{cmat}s, whereas a quite efficient method for \texttt{CopySubMatrix} is available for \texttt{cmat}s. }

 }

 
\section{\textcolor{Chapter }{Information about matrices}}\label{matinfo}
\logpage{[ 5, 6, 0 ]}
\hyperdef{L}{X805F24017D4348E2}{}
{
  

\subsection{\textcolor{Chapter }{BaseField (cmat)}}
\logpage{[ 5, 6, 1 ]}\nobreak
\hyperdef{L}{X7B5FF52186205C5E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{BaseField({\mdseries\slshape m})\index{BaseField@\texttt{BaseField}!cmat}
\label{BaseField:cmat}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the base field of \mbox{\texttt{\mdseries\slshape m}} 



 For a \texttt{cmat} \mbox{\texttt{\mdseries\slshape m}} this returns the \textsf{GAP} object \texttt{GF(p,d)} corresponding to the base field of \mbox{\texttt{\mdseries\slshape m}}. Note that this is a relatively fast lookup. }

 

\subsection{\textcolor{Chapter }{Characteristic (cmat)}}
\logpage{[ 5, 6, 2 ]}\nobreak
\hyperdef{L}{X7EC55E298313BCB1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Characteristic({\mdseries\slshape m})\index{Characteristic@\texttt{Characteristic}!cmat}
\label{Characteristic:cmat}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the characteristic of the base field of \mbox{\texttt{\mdseries\slshape m}} 



 Returns the characteristic of the base field of \mbox{\texttt{\mdseries\slshape m}} (see \texttt{BaseField} (\ref{BaseField:cmat})). }

 

\subsection{\textcolor{Chapter }{DegreeFFE (cmat)}}
\logpage{[ 5, 6, 3 ]}\nobreak
\hyperdef{L}{X7E9F7B7E7BEDA69E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DegreeFFE({\mdseries\slshape m})\index{DegreeFFE@\texttt{DegreeFFE}!cmat}
\label{DegreeFFE:cmat}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the degree of the base field of \mbox{\texttt{\mdseries\slshape m}} over its prime field 



 Returns the degree of the base field of \mbox{\texttt{\mdseries\slshape m}} over its prime field (see \texttt{BaseField} (\ref{BaseField:cmat})). }

 

\subsection{\textcolor{Chapter }{DefaultField (cmat)}}
\logpage{[ 5, 6, 4 ]}\nobreak
\hyperdef{L}{X7C6624AF7CEAA74D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DefaultField({\mdseries\slshape m})\index{DefaultField@\texttt{DefaultField}!cmat}
\label{DefaultField:cmat}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the base field of \mbox{\texttt{\mdseries\slshape m}}



 For a \texttt{cmat} \mbox{\texttt{\mdseries\slshape m}} this returns the \textsf{GAP} object \texttt{GF(p,d)} corresponding to the base field of \mbox{\texttt{\mdseries\slshape m}}. Note that this is a relatively fast lookup. }

 }

 
\section{\textcolor{Chapter }{Input and output}}\label{matio}
\logpage{[ 5, 7, 0 ]}
\hyperdef{L}{X78DA04477DDD0ACE}{}
{
  

\subsection{\textcolor{Chapter }{CVEC{\textunderscore}WriteMat}}
\logpage{[ 5, 7, 1 ]}\nobreak
\hyperdef{L}{X7DF1D51F7924429A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CVEC{\textunderscore}WriteMat({\mdseries\slshape f, m})\index{CVECWriteMat@\texttt{CVEC{\textunderscore}WriteMat}}
\label{CVECWriteMat}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
\texttt{true} or \texttt{fail}



 \mbox{\texttt{\mdseries\slshape f}} must be a file object from the \textsf{IO} package (see \texttt{IsFile} (\textbf{IO: IsFile})) and \mbox{\texttt{\mdseries\slshape m}} must be a \texttt{cmat}. The matrix \mbox{\texttt{\mdseries\slshape m}} is written to the file \mbox{\texttt{\mdseries\slshape f}}. Note that the format (see Section \ref{extrep}) is platform independent, such that matrices can be exchanged between
different architectures. The result is \texttt{true} or \texttt{fail} depending on whether everything worked or an error occurred respectively. }

 

\subsection{\textcolor{Chapter }{CVEC{\textunderscore}WriteMatToFile}}
\logpage{[ 5, 7, 2 ]}\nobreak
\hyperdef{L}{X794D936C7E99F805}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CVEC{\textunderscore}WriteMatToFile({\mdseries\slshape fn, m})\index{CVECWriteMatToFile@\texttt{CVEC{\textunderscore}WriteMatToFile}}
\label{CVECWriteMatToFile}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
\texttt{true} or \texttt{fail}



 \mbox{\texttt{\mdseries\slshape fn}} must be a string object containing a file name and \mbox{\texttt{\mdseries\slshape m}} must be a \texttt{cmat}. The matrix \mbox{\texttt{\mdseries\slshape m}} is written to the file with name \mbox{\texttt{\mdseries\slshape fn}} on the local storage. Note that the format (see Section \ref{extrep}) is platform independent, such that matrices can be exchanged between
different architectures. The result is \texttt{true} or \texttt{fail} depending on whether everything worked or an error occurred respectively. }

 

\subsection{\textcolor{Chapter }{CVEC{\textunderscore}WriteMatsToFile}}
\logpage{[ 5, 7, 3 ]}\nobreak
\hyperdef{L}{X78F898D17D9E522C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CVEC{\textunderscore}WriteMatsToFile({\mdseries\slshape fnpref, l})\index{CVECWriteMatsToFile@\texttt{CVE}\-\texttt{C{\textunderscore}}\-\texttt{Write}\-\texttt{Mats}\-\texttt{To}\-\texttt{File}}
\label{CVECWriteMatsToFile}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
\texttt{true} or \texttt{fail}



 \mbox{\texttt{\mdseries\slshape fnpref}} must be a string object containing a file name prefix and \mbox{\texttt{\mdseries\slshape m}} must be a list of \texttt{cmat}s. The matrices in \mbox{\texttt{\mdseries\slshape l}} are written to the files with names determined by using the string \mbox{\texttt{\mdseries\slshape fnpref}} and appending the natural numbers from $1$ to the length of \mbox{\texttt{\mdseries\slshape l}} on the local storage. Note that the format (see Section \ref{extrep}) is platform independent, such that matrices can be exchanged between
different architectures. The result is \texttt{true} or \texttt{fail} depending on whether everything worked or an error occurred respectively. }

 

\subsection{\textcolor{Chapter }{CVEC{\textunderscore}ReadMat}}
\logpage{[ 5, 7, 4 ]}\nobreak
\hyperdef{L}{X79E47CB5831D48CC}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CVEC{\textunderscore}ReadMat({\mdseries\slshape f})\index{CVECReadMat@\texttt{CVEC{\textunderscore}ReadMat}}
\label{CVECReadMat}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
a \texttt{cmat} or \texttt{fail} 



 \mbox{\texttt{\mdseries\slshape f}} must be a file object from the \textsf{IO} package (see \texttt{IsFile} (\textbf{IO: IsFile})). A matrix is read from the file \mbox{\texttt{\mdseries\slshape f}}. Note that the format (see Section \ref{extrep}) is platform independent, such that matrices can be exchanged between
different architectures. The result is \texttt{fail} if an error occurred. }

 

\subsection{\textcolor{Chapter }{CVEC{\textunderscore}ReadMatFromFile}}
\logpage{[ 5, 7, 5 ]}\nobreak
\hyperdef{L}{X824FA01878D60EE1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CVEC{\textunderscore}ReadMatFromFile({\mdseries\slshape fn})\index{CVECReadMatFromFile@\texttt{CVE}\-\texttt{C{\textunderscore}}\-\texttt{Read}\-\texttt{Mat}\-\texttt{From}\-\texttt{File}}
\label{CVECReadMatFromFile}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 a \texttt{cmat} or \texttt{fail}



 \mbox{\texttt{\mdseries\slshape fn}} must be a string object containing a file name. A matrix is read from the file
with name \mbox{\texttt{\mdseries\slshape fn}} on the local storage. Note that the format (see Section \ref{extrep}) is platform independent, such that matrices can be exchanged between
different architectures. The result is \texttt{fail} if an error occurred. }

 

\subsection{\textcolor{Chapter }{CVEC{\textunderscore}ReadMatsFromFile}}
\logpage{[ 5, 7, 6 ]}\nobreak
\hyperdef{L}{X79397B1D78E0746A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CVEC{\textunderscore}ReadMatsFromFile({\mdseries\slshape fnpref})\index{CVECReadMatsFromFile@\texttt{CVE}\-\texttt{C{\textunderscore}}\-\texttt{Read}\-\texttt{Mats}\-\texttt{From}\-\texttt{File}}
\label{CVECReadMatsFromFile}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
a list of \texttt{cmat}s or \texttt{fail}



 \mbox{\texttt{\mdseries\slshape fnpref}} must be a string object containing a file name prefix. A list of matrices is
read from the files with names determined by using the string \mbox{\texttt{\mdseries\slshape fnpref}} and appending the natural numbers from $1$ on from the local storage. The number of matrices read is determined by the
highest number such that the corresponding filename exists in the filesystem.
Note that the format (see Section \ref{extrep}) is platform independent, such that matrices can be exchanged between
different architectures. The result is \texttt{fail} if an error occurred. }

 }

 
\section{\textcolor{Chapter }{Grease}}\label{greasemat}
\logpage{[ 5, 8, 0 ]}
\hyperdef{L}{X7DA0D38A7D5DBDFF}{}
{
  The basic idea behind the ``grease'' technique is that over a finite field there are only finitely many linear
combinations of a fixed list of vectors. Thus, many operations including
matrix multiplication can be speeded up by precomputing all possible linear
combinations and then just looking up the right one. For the case of matrix
multiplication this can for example gain a factor of about $4$ over the field with $2$ elements using ``grease level$8$'', which means that for blocks of $8$ rows all linear combinations are precomputed. 

 The \textsf{cvec} uses grease whenever appropriate automatically for example for matrix
multiplication. However, occasionally the user has to take a conscious
decision, which matrices to grease, because this of course uses more memory. 

 A \texttt{cmat} can be ``pre-greased'' with level $l$, which means that it is chopped into chunks of $l$ rows and for each such chunk all possible linear combinations are precomputed
and stored. This increases the memory used to store the matrix by a factor of $q^l$ if the base field of the matrix has $q$ elements. However, operations like vector matrix multiplication and matrix
matrix multiplication (here the right hand side matrix must be greased!) are
speeded up. As a rule of thumb the factor one can hope for is about $l \cdot (q-1)/q$. Note that for big matrices matrix multiplication does greasing on the fly
anyway and therefore one cannot hope for such a big factor by pre-greasing. 

\subsection{\textcolor{Chapter }{GreaseMat}}
\logpage{[ 5, 8, 1 ]}\nobreak
\hyperdef{L}{X7DF5A56F8747DD45}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GreaseMat({\mdseries\slshape m, l})\index{GreaseMat@\texttt{GreaseMat}}
\label{GreaseMat}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GreaseMat({\mdseries\slshape m})\index{GreaseMat@\texttt{GreaseMat}}
\label{GreaseMat}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
nothing



 \mbox{\texttt{\mdseries\slshape m}} must be a \texttt{cmat}. It is pregreased with level \mbox{\texttt{\mdseries\slshape l}}. Without the argument \mbox{\texttt{\mdseries\slshape l}} a grease level depending of the field size is chosen automatically. Note that
the matrix will need much more memory when pregreased. }

 

\subsection{\textcolor{Chapter }{UnGreaseMat}}
\logpage{[ 5, 8, 2 ]}\nobreak
\hyperdef{L}{X7E8A9C7E7E014FC7}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{UnGreaseMat({\mdseries\slshape m})\index{UnGreaseMat@\texttt{UnGreaseMat}}
\label{UnGreaseMat}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
nothing



 \mbox{\texttt{\mdseries\slshape m}} must be a \texttt{cmat}. The pregreased information is deleted. This can save a lot of memory. }

 }

 
\section{\textcolor{Chapter }{Everything else}}\label{sonst}
\logpage{[ 5, 9, 0 ]}
\hyperdef{L}{X7A0D26B180BEDE37}{}
{
  

\subsection{\textcolor{Chapter }{Randomize (cmat)}}
\logpage{[ 5, 9, 1 ]}\nobreak
\hyperdef{L}{X7B97048782F7EE43}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Randomize({\mdseries\slshape m})\index{Randomize@\texttt{Randomize}!cmat}
\label{Randomize:cmat}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Randomize({\mdseries\slshape m, rs})\index{Randomize@\texttt{Randomize}!cmatrandomsource}
\label{Randomize:cmatrandomsource}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the matrix \mbox{\texttt{\mdseries\slshape m}}



 \mbox{\texttt{\mdseries\slshape m}} must be a \texttt{cmat} and \mbox{\texttt{\mdseries\slshape rs}} must be a random source object if given. This method changes the matrix \mbox{\texttt{\mdseries\slshape m}} in place by (pseudo) random values in the field over which the matrix lives.
If a random source is given, the pseudo random numbers used are taken from
this source, otherwise the global random source in the \textsf{GAP} library is taken. }

 

\subsection{\textcolor{Chapter }{OverviewMat (cmat)}}
\logpage{[ 5, 9, 2 ]}\nobreak
\hyperdef{L}{X8114198F7D6486CB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{OverviewMat({\mdseries\slshape m})\index{OverviewMat@\texttt{OverviewMat}!cmat}
\label{OverviewMat:cmat}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 nothing 



 An ASCII art overview over the \texttt{cmat} \mbox{\texttt{\mdseries\slshape m}} is printed. Stars indicate nonzero blocks in the matrix and dots zero blocks. }

 

\subsection{\textcolor{Chapter }{Unpack (cmat)}}
\logpage{[ 5, 9, 3 ]}\nobreak
\hyperdef{L}{X84AAF220841589D9}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Unpack({\mdseries\slshape m})\index{Unpack@\texttt{Unpack}!cmat}
\label{Unpack:cmat}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
a list of lists of finite field elements



 This operation unpacks a \texttt{cmat} \mbox{\texttt{\mdseries\slshape m}}. A new plain list of plain lists containing the corresponding numbers as \textsf{GAP} finite field elements. Note that the matrix \mbox{\texttt{\mdseries\slshape m}} remains unchanged. }

 }

  }

   
\chapter{\textcolor{Chapter }{Linear Algebra routines}}\label{linalg}
\logpage{[ 6, 0, 0 ]}
\hyperdef{L}{X8571243581CAD780}{}
{
  
\section{\textcolor{Chapter }{Semi echelonised bases and cleaning}}\label{semiechelon}
\logpage{[ 6, 1, 0 ]}
\hyperdef{L}{X79C4BA5B821BBE58}{}
{
  A semi echelonised basis is a record with the following components: \texttt{vectors} is a list of vectors of equal length, optionally (and optimally) they can be
wrapped to a matrix. \texttt{pivots} is a list of integers. The number $i$ in position $j$ indicates that the $j$th vector in \texttt{vectors} has a one in column number $i$ and all vectors with a number bigger than $j$ in \texttt{vectors} have a zero in column number $i$. 

 Note that for technical reasons another component \texttt{helper} is bound containing a \texttt{cvec} of length $1$ over the same field. 

 Note further that the output of the \textsf{GAP} library operation \texttt{SemiEchelonMat} (\textbf{Reference: SemiEchelonMat}) is not compatible to this setup, because it contains a component \texttt{heads} that contains at position $i$, if nonzero, the number of the row for that the pivot element is in column $i$. 

\subsection{\textcolor{Chapter }{EmptySemiEchelonBasis}}
\logpage{[ 6, 1, 1 ]}\nobreak
\hyperdef{L}{X87855EEA8779C855}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{EmptySemiEchelonBasis({\mdseries\slshape v})\index{EmptySemiEchelonBasis@\texttt{EmptySemiEchelonBasis}}
\label{EmptySemiEchelonBasis}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 a new mutable empty semi echelonised basis 



 The argument \mbox{\texttt{\mdseries\slshape v}} must be a sample vector. Also a \texttt{cvecclass} can be given instead. }

 

\subsection{\textcolor{Chapter }{MakeSemiEchelonBasis}}
\logpage{[ 6, 1, 2 ]}\nobreak
\hyperdef{L}{X7893E4AB7C5D9E31}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MakeSemiEchelonBasis({\mdseries\slshape b})\index{MakeSemiEchelonBasis@\texttt{MakeSemiEchelonBasis}}
\label{MakeSemiEchelonBasis}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 a semi echelonised basis 



 Turns the output \mbox{\texttt{\mdseries\slshape b}} of \texttt{SemiEchelonMat} (\textbf{Reference: SemiEchelonMat}) into a valid semi echelonised basis in the sense of the \textsf{cvec} package. This means that the component \texttt{pivots} is calculated from the component \texttt{heads}. Use this function only if necessary. Directly use \texttt{SemiEchelonRows} (\ref{SemiEchelonRows}) instead. }

 

\subsection{\textcolor{Chapter }{Vectors}}
\logpage{[ 6, 1, 3 ]}\nobreak
\hyperdef{L}{X7D12102B824C97B4}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Vectors({\mdseries\slshape b})\index{Vectors@\texttt{Vectors}}
\label{Vectors}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
 a matrix 



 The argument \mbox{\texttt{\mdseries\slshape b}} must be a semi echelonised basis. This operation returns a (mutable) matrix
whose rows are the basis vectors. }

 

\subsection{\textcolor{Chapter }{Length (for a semi echelonised basis)}}
\logpage{[ 6, 1, 4 ]}\nobreak
\hyperdef{L}{X8464F2B87BCA3D34}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Length({\mdseries\slshape b})\index{Length@\texttt{Length}!for a semi echelonised basis}
\label{Length:for a semi echelonised basis}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
 an integer 



 The argument \mbox{\texttt{\mdseries\slshape b}} must be a semi echelonised basis. This operation returns the number of vectors
in the basis. }

 

\subsection{\textcolor{Chapter }{CleanRow}}
\logpage{[ 6, 1, 5 ]}\nobreak
\hyperdef{L}{X7F4EA39D7D18D9B7}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CleanRow({\mdseries\slshape b, v, extend, dec})\index{CleanRow@\texttt{CleanRow}}
\label{CleanRow}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 \texttt{true} or \texttt{false} 



 This is the basic operation for cleaning with a semi echelonised basis \mbox{\texttt{\mdseries\slshape b}}. The vector \mbox{\texttt{\mdseries\slshape v}} is cleaned with the vectors in the semi echelonised basis. The function
returns \texttt{true} if \mbox{\texttt{\mdseries\slshape v}} lies in the span of \mbox{\texttt{\mdseries\slshape b}} and false otherwise. 

 The boolean value \mbox{\texttt{\mdseries\slshape extend}} indicates, whether the basis should be extended in the latter case by the
newly cleaned vector. 

 The argument \mbox{\texttt{\mdseries\slshape dec}} is either \texttt{fail} in which case it is not used or a vector over the same field as \mbox{\texttt{\mdseries\slshape v}} that is at least as long as the number $n$ of vectors in \mbox{\texttt{\mdseries\slshape b}} (plus one if \mbox{\texttt{\mdseries\slshape extend}} is \texttt{true}). In this case, the first $n$ components of \mbox{\texttt{\mdseries\slshape dec}} are changed such that $\sum_{{i=1}}^{n} \mbox{\texttt{\mdseries\slshape dec}}_i \mbox{\texttt{\mdseries\slshape b}}_i$. If \mbox{\texttt{\mdseries\slshape extend}} is \texttt{true} and \mbox{\texttt{\mdseries\slshape v}} is not contained in the span of the vectors in \mbox{\texttt{\mdseries\slshape b}} and \mbox{\texttt{\mdseries\slshape dec}} is a vector, then the first $n+1$ components of \mbox{\texttt{\mdseries\slshape dec}} are changed such that $\mbox{\texttt{\mdseries\slshape v}} = \sum_{{i=1}}^{n+1} \mbox{\texttt{\mdseries\slshape dec}}_i \mbox{\texttt{\mdseries\slshape b}}_i$. }

 

\subsection{\textcolor{Chapter }{SemiEchelonRows}}
\logpage{[ 6, 1, 6 ]}\nobreak
\hyperdef{L}{X80E1EAE17F8D03DF}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SemiEchelonRows({\mdseries\slshape m})\index{SemiEchelonRows@\texttt{SemiEchelonRows}}
\label{SemiEchelonRows}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 a semi echelonised basis 



 The argument \mbox{\texttt{\mdseries\slshape m}} must be a \texttt{cmat}. This method calculates a semi echelonised basis for the row space of \mbox{\texttt{\mdseries\slshape m}}. 

 There are a number of similar operations the names of which are derived from \texttt{SemiEchelonRows} by appending single letters: The letters ``P'', ``T'' and ``X'' are modifiers and there are operations for most of the $8$ combinations of those letters being present or not respectively. Always give
the present letters in alphabetical order. 

 The ``X'' indicates, that the input matrix may be destroyed, that is, the rows of \mbox{\texttt{\mdseries\slshape m}} will be changed and the very same objects be used in the semi echelonised
result basis. 

 The ``T'' indicates, that the transformation is calculated, that is, the resulting
record \texttt{r} will have a compontent \texttt{coeffs}, such that \texttt{r.coeffs * \mbox{\texttt{\mdseries\slshape m}}} is equal to \texttt{r.vectors} component of the semi echelonised result. Further, with given letter ``T'' there will be a component \texttt{relations} which is a basis for the (left) nullspace of \mbox{\texttt{\mdseries\slshape m}}. 

 The ``P'' indicates, that a component \texttt{r.p} is calculated such that \texttt{r.p * r.vectors} is the original matrix \mbox{\texttt{\mdseries\slshape m}}. 

 Currently the variants with ``P'' and ``T'' both present are not implement because they will probably not be very useful. }

 

\subsection{\textcolor{Chapter }{SemiEchelonRowsX}}
\logpage{[ 6, 1, 7 ]}\nobreak
\hyperdef{L}{X7DD036268036DB7D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SemiEchelonRowsX({\mdseries\slshape m})\index{SemiEchelonRowsX@\texttt{SemiEchelonRowsX}}
\label{SemiEchelonRowsX}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 a semi echelonised basis 



 Same as \texttt{SemiEchelonRows} (\ref{SemiEchelonRows}) but destructive in \mbox{\texttt{\mdseries\slshape m}}. }

 

\subsection{\textcolor{Chapter }{SemiEchelonRowsT}}
\logpage{[ 6, 1, 8 ]}\nobreak
\hyperdef{L}{X7D4B52E47A44F641}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SemiEchelonRowsT({\mdseries\slshape m})\index{SemiEchelonRowsT@\texttt{SemiEchelonRowsT}}
\label{SemiEchelonRowsT}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 a semi echelonised basis 



 Same as \texttt{SemiEchelonRows} (\ref{SemiEchelonRows}) but in addition stores the transformation, see \texttt{SemiEchelonRows} (\ref{SemiEchelonRows}). }

 

\subsection{\textcolor{Chapter }{SemiEchelonRowsTX}}
\logpage{[ 6, 1, 9 ]}\nobreak
\hyperdef{L}{X82160419798B73D4}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SemiEchelonRowsTX({\mdseries\slshape m})\index{SemiEchelonRowsTX@\texttt{SemiEchelonRowsTX}}
\label{SemiEchelonRowsTX}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 a semi echelonised basis 



 Same as \texttt{SemiEchelonRowsT} (\ref{SemiEchelonRowsT}) but destructive in \mbox{\texttt{\mdseries\slshape m}}. }

 

\subsection{\textcolor{Chapter }{SemiEchelonRowsP}}
\logpage{[ 6, 1, 10 ]}\nobreak
\hyperdef{L}{X7D3D8EA58707E289}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SemiEchelonRowsP({\mdseries\slshape m})\index{SemiEchelonRowsP@\texttt{SemiEchelonRowsP}}
\label{SemiEchelonRowsP}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 a semi echelonised basis 



 Same as \texttt{SemiEchelonRows} (\ref{SemiEchelonRows}) but in addition stores the inverse transformation, see \texttt{SemiEchelonRows} (\ref{SemiEchelonRows}). }

 

\subsection{\textcolor{Chapter }{SemiEchelonRowsPX}}
\logpage{[ 6, 1, 11 ]}\nobreak
\hyperdef{L}{X8450C84984C8671C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SemiEchelonRowsPX({\mdseries\slshape m})\index{SemiEchelonRowsPX@\texttt{SemiEchelonRowsPX}}
\label{SemiEchelonRowsPX}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 a semi echelonised basis 



 Same as \texttt{SemiEchelonRowsP} (\ref{SemiEchelonRowsP}) but destructive in \mbox{\texttt{\mdseries\slshape m}}. }

 

\subsection{\textcolor{Chapter }{MutableNullspaceMat}}
\logpage{[ 6, 1, 12 ]}\nobreak
\hyperdef{L}{X7E5C2C297CAAE3FB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MutableNullspaceMat({\mdseries\slshape m})\index{MutableNullspaceMat@\texttt{MutableNullspaceMat}}
\label{MutableNullspaceMat}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 a \texttt{cmat} 



 Returns a \texttt{cmat} the rows of which are a basis of the (left) nullspace of the \texttt{cmat} \mbox{\texttt{\mdseries\slshape m}}. Internally, \texttt{SemiEchelonRowsT} (\ref{SemiEchelonRowsT}) is used and the component \texttt{relations} of the result is returned. The result is mutable, which is the reason for the
introduction of a new operation besides \texttt{NullspaceMat} (\textbf{Reference: NullspaceMat}). }

 

\subsection{\textcolor{Chapter }{MutableNullspaceMatX}}
\logpage{[ 6, 1, 13 ]}\nobreak
\hyperdef{L}{X7A9596C98725862E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MutableNullspaceMatX({\mdseries\slshape m})\index{MutableNullspaceMatX@\texttt{MutableNullspaceMatX}}
\label{MutableNullspaceMatX}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 a \texttt{cmat} 



 Same as \texttt{MutableNullspaceMat} (\ref{MutableNullspaceMat}) but destructive in \mbox{\texttt{\mdseries\slshape m}}. }

 

\subsection{\textcolor{Chapter }{NullspaceMat}}
\logpage{[ 6, 1, 14 ]}\nobreak
\hyperdef{L}{X7DA0D5887DB12DC4}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NullspaceMat({\mdseries\slshape m})\index{NullspaceMat@\texttt{NullspaceMat}}
\label{NullspaceMat}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 an immutable \texttt{cmat} 



 Behaves exactly as expected. \mbox{\texttt{\mdseries\slshape m}} must be a \texttt{cmat}. }

 

\subsection{\textcolor{Chapter }{NullspaceMatDestructive}}
\logpage{[ 6, 1, 15 ]}\nobreak
\hyperdef{L}{X87684B0F7AB7B7DB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NullspaceMatDestructive({\mdseries\slshape m})\index{NullspaceMatDestructive@\texttt{NullspaceMatDestructive}}
\label{NullspaceMatDestructive}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 an immutable \texttt{cmat} 



 Behaves exactly as expected. \mbox{\texttt{\mdseries\slshape m}} must be a \texttt{cmat}. }

 }

 
\section{\textcolor{Chapter }{Characteristic and minimal polynomial}}\label{polynomials}
\logpage{[ 6, 2, 0 ]}
\hyperdef{L}{X825613828322BD22}{}
{
  

\subsection{\textcolor{Chapter }{CharacteristicPolynomialOfMatrix}}
\logpage{[ 6, 2, 1 ]}\nobreak
\hyperdef{L}{X7BB7DCBF78177638}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CharacteristicPolynomialOfMatrix({\mdseries\slshape m})\index{CharacteristicPolynomialOfMatrix@\texttt{CharacteristicPolynomialOfMatrix}}
\label{CharacteristicPolynomialOfMatrix}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CharacteristicPolynomialOfMatrix({\mdseries\slshape m, indetnr})\index{CharacteristicPolynomialOfMatrix@\texttt{CharacteristicPolynomialOfMatrix}}
\label{CharacteristicPolynomialOfMatrix}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 a record 



 Calculates the characteristic polynomial of the \texttt{cmat} \mbox{\texttt{\mdseries\slshape m}} over its base field. Because during the calculations the polynomial
automatically comes as a product of some not necessarily irreducible factors,
the result is returned in a record with two components. The \texttt{poly} component contains the full characteristic polynomial. The \texttt{factors} component contains a list of not necessarily irreducibly factors the product
of which is the characteristic polynomial. If an indeterminate number is given
as second argument, the polynomials are written in that indeterminate,
otherwise in the first indeterminate over the base field. }

 

\subsection{\textcolor{Chapter }{FactorsOfCharacteristicPolynomial}}
\logpage{[ 6, 2, 2 ]}\nobreak
\hyperdef{L}{X7FE2A9D281A74FDD}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FactorsOfCharacteristicPolynomial({\mdseries\slshape m})\index{FactorsOfCharacteristicPolynomial@\texttt{FactorsOfCharacteristicPolynomial}}
\label{FactorsOfCharacteristicPolynomial}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FactorsOfCharacteristicPolynomial({\mdseries\slshape m, indetnr})\index{FactorsOfCharacteristicPolynomial@\texttt{FactorsOfCharacteristicPolynomial}}
\label{FactorsOfCharacteristicPolynomial}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 a list 



 Calculates the characteristic polynomial of the \texttt{cmat} \mbox{\texttt{\mdseries\slshape m}} over its base field. The result is a list of irreducible factors of the
characteristic polynomial of \mbox{\texttt{\mdseries\slshape m}}, the product of which is the characteristic polynomial. Because during the
calculations the polynomial automatically comes as a product of some not
necessarily irreducible factors, this is more efficient than just calculating
the characteristic polynomial and then factoring it. If an indeterminate
number is given as second argument, the polynomials are written in that
indeterminate, otherwise in the first indeterminate over the base field. }

 

\subsection{\textcolor{Chapter }{MinimalPolynomialOfMatrix}}
\logpage{[ 6, 2, 3 ]}\nobreak
\hyperdef{L}{X7A110EA07A2EC59C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MinimalPolynomialOfMatrix({\mdseries\slshape m})\index{MinimalPolynomialOfMatrix@\texttt{MinimalPolynomialOfMatrix}}
\label{MinimalPolynomialOfMatrix}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MinimalPolynomialOfMatrix({\mdseries\slshape m, indetnr})\index{MinimalPolynomialOfMatrix@\texttt{MinimalPolynomialOfMatrix}}
\label{MinimalPolynomialOfMatrix}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 a polynomial over the base field of \mbox{\texttt{\mdseries\slshape m}} 



 Calculates the minimal polynomial of the \texttt{cmat} \mbox{\texttt{\mdseries\slshape m}} over its base field. The polynomial is returned. If an indeterminate number is
given as second argument, the polynomials are written in that indeterminate,
otherwise in the first indeterminate over the base field. }

 

\subsection{\textcolor{Chapter }{CharAndMinimalPolynomialOfMatrix}}
\logpage{[ 6, 2, 4 ]}\nobreak
\hyperdef{L}{X862C6AA0794E41C4}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CharAndMinimalPolynomialOfMatrix({\mdseries\slshape m})\index{CharAndMinimalPolynomialOfMatrix@\texttt{CharAndMinimalPolynomialOfMatrix}}
\label{CharAndMinimalPolynomialOfMatrix}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CharAndMinimalPolynomialOfMatrix({\mdseries\slshape m, indetnr})\index{CharAndMinimalPolynomialOfMatrix@\texttt{CharAndMinimalPolynomialOfMatrix}}
\label{CharAndMinimalPolynomialOfMatrix}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 a record 



 Calculates the characteristic and minimal polynomial of the \texttt{cmat} \mbox{\texttt{\mdseries\slshape m}} over its base field. Because during the calculation of the minimal polynomial
the characteristic polynomial is calculated anyway, the result is returned in
a record with five components: The \texttt{charpoly} component contains the full characteristic polynomial. The \texttt{irreds} component contains the set of irreducible factors of the characteristic
polynomial as a list. The \texttt{mult} component contains a corresponding list of multiplicities, that is in position $i$ is the multiplicity of the irreducible factor number $i$ in the characteristic polynomial. The component \texttt{minpoly} contains the minimal polynomial and the component \texttt{multmin} the corresponding multiplicities of the irreducible factors of the
characteristic polynomial in the minimal polynomial. If an indeterminate
number is given as second argument, the polynomials are written in that
indeterminate, otherwise in the first indeterminate over the base field. }

 

\subsection{\textcolor{Chapter }{MinimalPolynomialOfMatrixMC}}
\logpage{[ 6, 2, 5 ]}\nobreak
\hyperdef{L}{X839407B37A85AAC8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MinimalPolynomialOfMatrixMC({\mdseries\slshape m, prob[, indetnr]})\index{MinimalPolynomialOfMatrixMC@\texttt{MinimalPolynomialOfMatrixMC}}
\label{MinimalPolynomialOfMatrixMC}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
 a record 



 This method calculates the characteristic and minimal polynomials of the row
list matrix \mbox{\texttt{\mdseries\slshape m}} over its base domain. It uses the Monte Carlo algorithm by Neunhoeffer and
Praeger. The second argument \mbox{\texttt{\mdseries\slshape prob}} is an upper bound for the error probability, it can be $0$ in which case a deterministic verification is done. The optional argument \mbox{\texttt{\mdseries\slshape indetnr}} is the number of the indeterminate over the base domain to be used to express
polynomials. 

 The result is a record with the following components bound: The component \texttt{charpoly} is the characteristic polynomial which is guaranteed to be correct. The
component \texttt{minpoly} is always a divisor of the minimal polynomial and usually is equal to it. See
below for details. The component \texttt{irreds} is a sorted list of the irreducible factors of the characteristic polynomial.
The component \texttt{mult} is a corresponding list of the same length containing the multiplicities of
these irreducible factors in the characteristic polynomial. The component \texttt{minmult} is a corresponding list of the same length containing the multiplicities of
these irreducible factors in the polynomial given in \texttt{minpoly}. The component \texttt{proof} is set to \texttt{true} if the result is proved to be correct, which can happen even if \mbox{\texttt{\mdseries\slshape prob}} was non-zero (for example in the case of a cyclic matrix). The component \texttt{iscyclic} is set to \texttt{true} if and only if the minimal polynomial is equal to the characteristic
polynomial. The component \texttt{prob} is set to the probability given in \mbox{\texttt{\mdseries\slshape prob}}, if that was zero then it is set to $1/10000$ but \texttt{proof} will be \texttt{true}. The components \texttt{A}, \texttt{B} and \texttt{S} describe a base change for \mbox{\texttt{\mdseries\slshape m}} to a sparse form which is obtained as a byproduct. \texttt{S} is a semi echelonised basis which was obtained by a spin-up computation with \mbox{\texttt{\mdseries\slshape m}} and if $Y$ is the sparse basis then $Y = A \cdot S$ and $B=A^{-1}$. 

The given result for the minimal polynomial could be a proper divisor of the
real minimal polynomial if \mbox{\texttt{\mdseries\slshape prob}} was non-zero, however, the probability for this outcome is guaranteed to be
less than or equal to \mbox{\texttt{\mdseries\slshape prob}}. Note that it is always guaranteed that all irreducible factors of the
minimal polynomial are actually present, it can only happen that the
multiplicities are too small. }

 }

  }

   
\chapter{\textcolor{Chapter }{Performance}}\label{performance}
\logpage{[ 7, 0, 0 ]}
\hyperdef{L}{X854F8C5579845066}{}
{
  Here comes text.

  }

   
\chapter{\textcolor{Chapter }{Cooperation with the \textsf{GAP} library}}\label{gaplib}
\logpage{[ 8, 0, 0 ]}
\hyperdef{L}{X7F24BDC0877F7681}{}
{
  Here comes text.

  }

   
\chapter{\textcolor{Chapter }{Examples}}\label{examples}
\logpage{[ 9, 0, 0 ]}
\hyperdef{L}{X7A489A5D79DA9E5C}{}
{
  Here comes text.

  }

  \def\bibname{References\logpage{[ "Bib", 0, 0 ]}
\hyperdef{L}{X7A6F98FD85F02BFE}{}
}

\bibliographystyle{alpha}
\bibliography{cvec}

\addcontentsline{toc}{chapter}{References}

\def\indexname{Index\logpage{[ "Ind", 0, 0 ]}
\hyperdef{L}{X83A0356F839C696F}{}
}

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Index}


\printindex

\newpage
\immediate\write\pagenrlog{["End"], \arabic{page}];}
\immediate\closeout\pagenrlog
\end{document}
