#############################################################################
##
#W  transform.xml
#Y  Copyright (C) 2011-12                                James D. Mitchell
##
##  Licensing information can be found in the README file of this package.
##
#############################################################################
##

<#GAPDoc Label="AsPermOfKerImg">
  <ManSection>
    <Func Name="AsPermOfKerImg" Arg="f"/>
    <Returns>A permutation.</Returns>
    <Description>
      This function returns a permutation <C>p</C> such that 
<Log>OnTuples(CanonicalTransSameKernel(f), p)=ImageListOfTransformation(f);</Log>
      See also <Ref Func="CanonicalTransSameKernel"/> and 
      <Ref Attr="ImageListOfTransformation" BookName="ref"/>. 
        
    <Example>
gap> f:=Transformation( [ 2, 1, 6, 1, 7, 6, 2, 8, 4, 7 ] );;
gap> CanonicalTransSameKernel(f); ImageListOfTransformation(f);
[ 1, 2, 3, 2, 4, 3, 1, 5, 6, 4 ]
[ 2, 1, 6, 1, 7, 6, 2, 8, 4, 7 ]
gap> AsPermOfKerImg(f);
(1,2)(3,6,4,7)(5,8)</Example>
    </Description>
  </ManSection>
 <#/GAPDoc>

<#GAPDoc Label="AsPermutation">
  <ManSection>
    <Oper Name="AsPermutation" Arg="f  [, set]"/>
    <Returns>A permutation.</Returns>
    <Description>
      If the transformation or partial permutation <A>f</A> is a permutation of
      the set of positive integers <A>set</A>, then <C>AsPermutation</C>
      returns this permutation;  see <Ref Func="Permutation"
        BookName="ref"/>.<P/>

      If the optional argument <A>set</A> is not specified, then the image set
      of <A>f</A> is used by default for transformations and the range of
      <A>f</A> is used by default for partial permutations; see 
      <Ref Attr="ImageSetOfTransformation" BookName="ref"/> and 
      <Ref Func="RangeSetOfPartialPerm"/>.

<Example>
gap> f:=Transformation( [ 5, 8, 3, 5, 8, 6, 2, 2, 7, 8 ] );;
gap> AsPermutation(f);
fail
gap> f:=Transformation( [ 8, 2, 10, 2, 4, 4, 7, 6, 9, 10 ] );;
gap> AsPermutation(f);
fail
gap> f:=Transformation( [ 1, 3, 6, 6, 2, 10, 2, 3, 10, 5 ] );;
gap> AsPermutation(f);
(2,3,6,10,5)
gap> f:=Transformation( [ 5, 2, 8, 4, 1, 8, 10, 3, 5, 7 ] );;
gap> AsPermutation(f);       
(1,5)(3,8)(7,10)
gap> AsPermutation(f, [1,5]);
(1,5)
gap> AsPermutation(f, [3,8,7,10]);
(3,8)(7,10)
gap> f:=PartialPerm([ 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 16, 17, 18, 19 ],
> [ 3, 12, 14, 4, 11, 18, 17, 2, 9, 5, 15, 8, 20, 10, 19 ]);;
gap> AsPermutation(f);
fail
gap> AsPermutation(f, [4,5,11]);
(5,11)
gap> f:=RandomPartialPerm(20);;
gap> AsPermutation(f^-1*f);
()</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="AsTransformation">
  <ManSection>
    <Oper Name="AsTransformation" Arg="f [, n]"/>
    <Returns>A transformation.</Returns>
    <Description>
      If <A>f</A> is a partial permutation and <C>m</C> is the largest point in
      the union of the domain and range of <A>f</A>, then
      <C>AsTransformation</C> returns the transformation <C>g</C> such that
      <C>i^g=i^f</C> for all <C>i</C> in the domain of <A>f</A> and
      <C>i^g=m+1</C> for all <C>i</C> in <M>\{1,\ldots, m+1\}</M> that is not
      in the domain of <A>f</A>. <P/>

      If the optional second argument <A>n</A> is a positive integer greater
      than the largest point in the union of the domain and range of <A>f</A>,
      then the transformation obtained is defined by replacing <C>m</C> in the
      definition of <C>g</C> in previous paragraph by <C>n</C>. <P/>

      It is also possible to use <C>AsTransformation</C> to convert
      permutations and binary relations into transformations; see 
      <Ref Func="AsTransformation" BookName="ref"/>.

      <Example>
gap> f:=PartialPerm([ 1, 2, 3, 4, 5, 8, 10 ], [ 3, 1, 4, 2, 5, 6, 7 ]);;
gap> AsTransformation(f);
Transformation( [ 3, 1, 4, 2, 5, 11, 11, 6, 11, 7, 11 ] )
gap> AsTransformation(f, 12);
Transformation( [ 3, 1, 4, 2, 5, 12, 12, 6, 12, 7, 12, 12 ] )
gap> AsTransformation(f, 14);
Transformation( [ 3, 1, 4, 2, 5, 14, 14, 6, 14, 7, 14, 14, 14, 14 ] )</Example>
    </Description> 
  </ManSection> 
<#/GAPDoc>

<#GAPDoc Label="CanonicalTransSameKernel">
  <ManSection>
    <Func Name="CanonicalTransSameKernel" Arg="obj"/>
    <Returns>A list of positive integers.</Returns>
    <Description>
      The argument <A>obj</A> should be a transformation or the list of images
      of a transformation. If <A>obj</A> is a transformation, then we define
      <C>f:=<A>obj</A></C> and if <A>obj</A> is the image list of
      a transformation we define <C>f:=Transformation(<A>obj</A>)</C>.
      <C>CanonicalTransSameKernel</C> returns the image list of a
      transformation <C>g</C> such that the kernel of <C>g</C> equals the
      kernel of <C>f</C> and <C>j^g=i</C> for all <C>j</C> in
      <C>KernelOfTransformation(g)[i]</C>. For a given transformation <C>f</C>,
      there is a unique transformation <C>g</C> with this property. <P/>

      See also <Ref Attr="ImageListOfTransformation" BookName="ref"/> and
      <Ref Attr="KernelOfTransformation" BookName="ref"/>. 

      <Example>
gap> f:=Transformation( [ 10, 3, 7, 10, 1, 5, 9, 2, 6, 10 ] );;
gap> CanonicalTransSameKernel(f);
[ 1, 2, 3, 1, 4, 5, 6, 7, 8, 1 ]
gap> f:=[ 10, 6, 7, 9, 9, 9, 4, 1, 4, 1 ];;
gap> CanonicalTransSameKernel(f);
[ 1, 2, 3, 4, 4, 4, 5, 6, 5, 6 ]</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="ConstantTransformation">
  <ManSection>
    <Func Name="ConstantTransformation" Arg="m, n"/>
    <Returns>A constant transformation of degree <A>m</A> with value <A>n</A>. 
    </Returns>
    <Description>
    <Example>
gap> ConstantTransformation(5, 1);
Transformation( [ 1, 1, 1, 1, 1 ] )
gap> ConstantTransformation(6, 4);
Transformation( [ 4, 4, 4, 4, 4, 4 ] )</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="EvaluateWord">
  <ManSection> 
    <Oper Name="EvaluateWord" Arg="gens, w"/>
    <Returns>A transformation.</Returns>
    <Description> 
      The argument <A>gens</A> should be a list of transformations and the
      argument <A>w</A> should be a list of positive integers less than or
      equal to the length of <A>gens</A>.  This operation evaluates the word
      <A>w</A> in the generators <A>gens</A>. More precisely,
      <C>EvaluateWord</C> returns the equivalent of: 
      <Log>Product(List(w, i-> gens[i]));</Log> 
      see also <Ref Meth="Factorization"/>.

<Example>
gap> gens:=[ Transformation( [ 2, 4, 4, 6, 8, 8, 6, 6 ] ), 
> Transformation( [ 2, 7, 4, 1, 4, 6, 5, 2 ] ), 
> Transformation( [ 3, 6, 2, 4, 2, 2, 2, 8 ] ), 
> Transformation( [ 4, 3, 6, 4, 2, 1, 2, 6 ] ), 
> Transformation( [ 4, 5, 1, 3, 8, 5, 8, 2 ] ) ];;
gap> S:=Semigroup(gens);;
gap> f:=Transformation( [ 1, 4, 6, 1, 7, 2, 7, 6 ] );;
gap> Factorization(S, f);
[ 4, 2 ]
gap> EvaluateWord(gens, last);
Transformation( [ 1, 4, 6, 1, 7, 2, 7, 6 ] )</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="Factorization">
<ManSection> 
  <Meth Name="Factorization" Arg="S, f"/>
    <Returns>A word in the generators.</Returns>
      <Description> 
        If <A>S</A> is a transformation semigroup and <A>f</A> is a
        transformation belonging to <A>S</A>, then <C>Factorization</C> returns
        a word in the generators of <A>S</A> that is equal to <A>f</A>. Here, a
        word is a list of positive integers where <C>i</C> corresponds to
        <C>GeneratorsOfSemigroups(S)[i]</C>. More specifically,
        <Log>EvaluateWord(GeneratorsOfSemigroup(S), Factorization(S, f))=f;</Log> <P/>

        Note that <C>Factorization</C> does not return a word of minimum
        length. An empty list is evaluated to the identity transformation with
        degree equal to the degree of <A>S</A> regardless of whether this
        transformation is an element of <A>S</A> or not.<P/> 

        See also <Ref Func="EvaluateWord"/> and 
        <Ref Func="GeneratorsOfSemigroup" BookName="ref"/>.
<Example>
gap> gens:=[ Transformation( [ 2, 2, 9, 7, 4, 9, 5, 5, 4, 8 ] ), 
> Transformation( [ 4, 10, 5, 6, 4, 1, 2, 7, 1, 2 ] ) ];;
gap> S:=Semigroup(gens);;
gap> f:=Transformation( [ 1, 10, 2, 10, 1, 2, 7, 10, 2, 7 ] );;
gap> Factorization(S, f);
[ 2, 2, 1, 2 ]
gap> EvaluateWord(gens, last);
Transformation( [ 1, 10, 2, 10, 1, 2, 7, 10, 2, 7 ] )</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="Idempotent">
  <ManSection><Heading>Idempotent</Heading>
    <Func Name="Idempotent" Arg="ker, img"/>
    <Func Name="IdempotentNC" Arg="ker, img"/>
    <Returns>An idempotent transformation.</Returns>
    <Description>
      This function returns an idempotent with <Ref
      Func="CanonicalTransSameKernel"/> equal to <A>ker</A> and image set equal
      to <A>img</A> after first checking that <Ref
      Func="IsInjectiveTransOnList"/> holds with argument <A>ker, img</A>.  <P/>

     <C>IdempotentNC</C> returns an idempotent with 
     <Ref Func="CanonicalTransSameKernel"/>
     equal to <A>ker</A> and image set equal to <A>img</A> without
     checking that <Ref Func="IsInjectiveTransOnList"/> holds.
      <Example>
gap> f:=Transformation( [ 10, 2, 3, 10, 5, 10, 7, 2, 5, 6 ] );;
gap> ker:=CanonicalTransSameKernel(f);
[ 1, 2, 3, 1, 4, 1, 5, 2, 4, 6 ]
gap> img:=ImageSetOfTransformation(f);
[ 2, 3, 5, 6, 7, 10 ]
gap> Idempotent(ker, img);
Transformation( [ 6, 2, 3, 6, 5, 6, 7, 2, 5, 10 ] )</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IndexPeriodOfTransformation">
  <ManSection>
    <Func Name="IndexPeriodOfTransformation" Arg="f"/>
    <Returns>A pair of positive integers.</Returns>
    <Description>
      Returns the least positive integers <C>m, r</C> such that
      <C><A>f</A>^(m+r)=<A>f</A>^m</C>, which are 
      known as the <E>index</E> and <E>period</E> of the transformation
      <A>f</A>. 
      <Example>
gap> f:=Transformation( [ 3, 4, 4, 6, 1, 3, 3, 7, 1 ] );;
gap> IndexPeriodOfTransformation(f);
[ 2, 3 ]
gap> f^2=f^5;
true</Example> 
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="InversesOfTransformation">
  <ManSection><Heading>InversesOfTransformation</Heading>
    <Oper Name="InversesOfTransformation" Arg="S, f"/>
    <Oper Name="InversesOfTransformationNC" Arg="S, f"/>
    <Returns>A list of transformations.</Returns>
    <Description>
      <C>InversesOfTransformation</C> returns a list of the inverses of the 
      transformation <A>f</A> in the transformation semigroup <A>S</A> after
      first checking that <A>f</A> is an element of <A>S</A>. <P/>
     
     A transformation <C>g</C> in <A>S</A> is an <E>inverse</E> of <A>f</A> if 
      <C><A>f</A>*g*<A>f</A>=<A>f</A></C> and <C>g*<A>f</A>*g=g</C>.<P/>
      
      The function <C>InversesOfTransformationNC</C> does not check that 
      <A>f</A> is an element of <A>S</A>.
      <Example>
gap> S:=Semigroup([ Transformation( [ 3, 1, 4, 2, 5, 2, 1, 6, 1 ] ), 
>  Transformation( [ 5, 7, 8, 8, 7, 5, 9, 1, 9 ] ), 
>  Transformation( [ 7, 6, 2, 8, 4, 7, 5, 8, 3 ] ) ]);;
gap> f:=Transformation( [ 3, 1, 4, 2, 5, 2, 1, 6, 1 ] );;
gap> InversesOfTransformationNC(S, f);
[  ]
gap> IsRegularTransformation(S, f);
false
gap> f:=Transformation( [ 1, 9, 7, 5, 5, 1, 9, 5, 1 ] );;
gap> InversesOfTransformation(S, f);
[ Transformation( [ 1, 5, 1, 2, 5, 1, 3, 2, 2 ] ), 
  Transformation( [ 1, 2, 3, 5, 5, 1, 3, 5, 2 ] ), 
  Transformation( [ 1, 5, 1, 1, 5, 1, 3, 1, 2 ] ) ]
gap> IsRegularTransformation(S, f);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsInjectiveTransOnList">
  <ManSection>
    <Oper Name="IsInjectiveTransOnList" Arg="obj, list"/>
    <Returns><K>true</K> or <K>false</K>.
    </Returns>
    <Description>
      The argument <A>obj</A> should be a transformation or the list of images
      of a transformation and <A>list</A> should be a list of positive
      integers.  If <A>obj</A> is a transformation, then we define
      <C>f:=<A>obj</A></C> and if <A>obj</A> is the image list of a
      transformation we define <C>f:=Transformation(<A>obj</A>)</C>.
      <C>IsInjectiveTransOnList</C> returns <K>true</K> if <C>f</C> is injective
      on <A>list</A> and <K>false</K> if it is not. If <A>list</A> is not
      duplicate free, then <K>false</K> is returned. <P/>

      See also <Ref Attr="ImageListOfTransformation" BookName="ref"/> and 
      <Ref Oper="Transformation" BookName="ref"/>.
      <Example>
gap> f:=Transformation( [ 2, 6, 7, 2, 6, 9, 9, 1, 1, 5 ] );;
gap> IsInjectiveTransOnList(f, [1,5]);
true
gap> IsInjectiveTransOnList(f, [5,1]);
true
gap> IsInjectiveTransOnList(f, [5,1,5,1,1,]);
false
gap> IsInjectiveTransOnList([1,2,3,4,5], [5,1,2,3]);   
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>
      

<#GAPDoc Label="IsRegularTransformation">
  <ManSection>
    <Oper Name="IsRegularTransformation" Arg="S, f"/>
    <Returns><K>true</K> or <K>false</K>.
    </Returns>
    <Description>
      This function returns <K>true</K> if <A>f</A> is a regular element of the 
      transformation semigroup <A>S</A> and <K>false</K> if it is not.<P/> 

      A transformation <A>f</A> is <E>regular</E> in a transformation semigroup
      <A>S</A> if it lies inside a regular &D;-class; see <Ref
      Attr="IsRegularDClass" BookName="ref"/> or <Ref
      Attr="IsRegularDClass"/>.  Equivalently <A>f</A> is regular if the orbit
      of the image of <A>f</A> containing a transversal of the kernel of
      <A>f</A>; see <Ref Oper="Transformation" BookName="ref"/> and <Ref
      Attr="ImageSetOfTransformation" BookName="ref"/>.

      <Example>
gap> S:=Monoid(Transformation([2,2,4,4,5,6]),Transformation([5,3,4,4,6,6]));;
gap> f:=Generators(S)[1];;
gap> IsRegularTransformation(S, f);
true
gap> img:=ImageSetOfTransformation(f);
[ 2, 4, 5, 6 ]
gap> o:=Orb(S, img, OnSets);; Enumerate(o);
&lt;closed orbit, 3 points>
gap> ForAny(o, x-> IsInjectiveTransOnList(f, x));
true
gap> IsRegularTransformation(S, Generators(S)[2]);
false
gap> IsRegularTransformation(FullTransformationSemigroup(6), Generators(S)[2]);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="Random">
  <ManSection>
    <Meth Name="Random" Arg="S" Label="for a semigroup"/>
    <Returns>A transformation or a partial permutation.</Returns>
    <Description>
      This function returns a random element of the semigroup of
      transformations or partial permutations <A>S</A>.  If
      the &R;-class structure of <A>S</A> has not been calculated, then a short
      product (at most <C>2*Length(GeneratorsOfSemigroup(<A>S</A>))</C>) of
      generators is returned.  If the &R;-class structure of <A>S</A> is known,
      then a random element of a randomly chosen &R;-class is returned.  
    </Description> 
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="RandomIdempotent">
  <ManSection><Heading>RandomIdempotent</Heading>
    <Oper Name="RandomIdempotent" Arg="img, m"/>
    <Oper Name="RandomIdempotentNC" Arg="img, m"/>
    <Returns>An idempotent transformation.</Returns>
    <Description>
      Returns a random idempotent with image set <A>img</A> of degree <A>m</A>
      after checking that the maximum value in <A>img</A> is at most <A>m</A>. 
      <P/>

      <C>RandomIdempotentNC</C> returns a random idempotent with image set
      <A>img</A> of degree <A>m</A> without checking that the maximum value in
      <A>img</A> is at most <A>m</A>.

      <Log>
gap> RandomIdempotent([ 1, 2, 3 ], 5);
Transformation( [ 1, 2, 3, 1, 3 ] )
gap> RandomIdempotent([ 1, 2, 3 ], 4);
Transformation( [ 1, 2, 3, 3 ] )
gap> RandomIdempotent([ 1, 2, 3 ], 3);            
Transformation( [ 1, 2, 3 ] )
gap> RandomIdempotent([ 1, 2, 4, 5, 6 ], 10);
Transformation( [ 1, 2, 6, 4, 5, 6, 2, 5, 1, 6 ] )</Log>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="RandomTransformation">
  <ManSection><Heading>RandomTransformation</Heading>
    <Oper Name="RandomTransformation" Arg="arg"/>
    <Oper Name="RandomTransformationNC" Arg="arg"/>
    <Returns>A transformation.</Returns>
    <Description>
      If <A>arg</A> is a positive integer, then a random transformation of 
      degree <A>arg</A> is returned; see <Ref Func="RandomTransformation"
      BookName="ref"/>.<P/>

      If <A>arg</A><C>[1]</C> is a list of positive integers and
      <A>arg</A><C>[2]</C> is a positive integer, then
      <C>RandomTransformation</C> returns a random transformation with degree
      <A>arg</A><C>[2]</C> and image contained in <A>arg</A><C>[1]</C>. <P/>

      The no check version <C>RandomTransformationNC</C> does not check that 
      the arguments can define a transformation.  
<Log>
gap> RandomTransformation([1,2,3], 6);             
Transformation( [ 2, 1, 2, 1, 1, 2 ] )
gap> RandomTransformationNC([1,2,3], 6);
Transformation( [ 3, 1, 2, 2, 1, 2 ] )</Log> 
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="SmallestIdempotentPowerT">
<ManSection> 
  <Oper Name="SmallestIdempotentPower" Arg="f" Label="for a transformation"/>
  <Returns>A positive integer.</Returns>
  <Description>
      This function returns the least positive integer <C>n</C> such that the
      transformation <C><A>f</A>^n</C> is an idempotent. See also <Ref
        Oper="SmallestIdempotentPower" Label="for a partial perm"/>.

      <Example>
gap> f:=Transformation( [ 6, 7, 4, 1, 7, 4, 6, 1, 3, 4 ] );;
gap> SmallestIdempotentPower(f);
3
gap> f:=Transformation( [ 6, 6, 6, 2, 7, 1, 5, 3, 10, 6 ] );;
gap> SmallestIdempotentPower(f);
2</Example>
    </Description>  
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="RankOfTransformation">
  <ManSection>
    <Func Name="RankOfTransformation" Arg="f"/>
    <Func Name="Rank" Arg="f" Label="for a transformation"/>
    <Returns>A positive integer.</Returns>
    <Description>
      <C>RankOfTransformation</C> returns the length of the set of image points
      of the transformation <A>f</A>; see <Ref Oper="RankOfTransformation"
        BookName="ref"/>.<P/>
      
      <C>Rank(<A>f</A>)</C> returns the same result as
      <C>RankOfTransformation</C> and is included for the sake of having a
      shorter name. <C>Rank</C> can 
      also be applied to partial permutations; see <Ref
        Func="RankOfPartialPerm"/>
      <Example>
gap> f:=Transformation( [ 8, 5, 8, 2, 2, 8, 4, 7, 3, 1 ] );;
gap> RankOfTransformation(f);
7
gap> Rank(f);
7</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="DegreeOfTransformation"/>
  <ManSection>
    <Func Name="DegreeOfTransformation" Arg="f"/>
    <Func Name="Degree" Arg="f" Label="for a transformation"/>
    <Func Name="Degree" Arg="C" Label="for a transformation coll"/>
    <Returns>A positive integer.</Returns>
    <Description>
      The <E>degree</E> of a transformation <A>f</A> is the length of <Ref
        Attr="ImageListOfTransformation" BookName="ref"/>. <P/>

      The degree of a transformation collection <A>C</A> is the 
      degree of any (and all) transformations in <A>C</A>. <P/>

      See also <Ref Attr="DegreeOfTransformation" BookName="ref"/>.
    </Description>
  </ManSection>
<#/GAPDoc>


#EOF
