<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (hecke) - Chapter 3: Specht functionality</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
</head>
<body>


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">Top of Book</a>&nbsp;  &nbsp;<a href="chap2.html">Previous Chapter</a>&nbsp;  &nbsp;<a href="chapBib.html">Next Chapter</a>&nbsp;  </div>

<p><a id="X7ED1AB5C7E41D277" name="X7ED1AB5C7E41D277"></a></p>
<div class="ChapSects"><a href="chap3.html#X7ED1AB5C7E41D277">3 <span class="Heading">Specht functionality</span></a>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap3.html#X78AA2DBD7D5D3F02">3.1 <span class="Heading">Porting notes</span></a>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8340A4F97986693C">3.1-1 <span class="Heading">Structure of <strong class="pkg">Hecke</strong></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8120A27282B82CC8">3.1-2 <span class="Heading">Renamings</span></a>
</span>
</div>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap3.html#X7A7DF4FC796EF66F">3.2 <span class="Heading">Specht functions</span></a>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7FE26921867C440A">3.2-1 Specht</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8037763587274161">3.2-2 <span class="Heading">Simple information access</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7C92700882971537">3.2-3 <span class="Heading">The functions MakeSpecht, MakePIM and MakeSimple</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X86F599A07A7C1C33">3.2-4 <span class="Heading">Decomposition numbers of the symmetric groups</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X838BEC0382BF87EA">3.2-5 <span class="Heading">Hecke algebras over fields of positive characteristic</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X83009CE685621BD4">3.2-6 <span class="Heading">The Fock space and Hecke algebras over fields of characteristic zero
</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7B57DF517F73F00D">3.2-7 Schur</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X84F0F9E47D5EEBCF">3.2-8 DecompositionMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7F616CCE808FA11E">3.2-9 CrystalDecompositionMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X829A23A97EE4C20E">3.2-10 DecompositionNumber</a></span>
</div>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap3.html#X7C5B169286EFC900">3.3 <span class="Heading">Partitions in <strong class="pkg">Hecke</strong></span></a>
</div>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap3.html#X87A6E8DD85F3F020">3.4 <span class="Heading">Inducing and restricting modules</span></a>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X81D7F7A4812BB04D">3.4-1 RInducedModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X780709B3865BC344">3.4-2 SInducedModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X783BC74E81A7D0E6">3.4-3 RRestrictedModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8041ABFA86D7A3EF">3.4-4 SRestrictedModule</a></span>
</div>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap3.html#X79F430837BA7BAD2">3.5 <span class="Heading">Operations on decomposition matrices</span></a>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7D257389845738DB">3.5-1 InducedDecompositionMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X803A99987E501AC9">3.5-2 IsNewIndecomposable</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X802E811683E611EE">3.5-3 InvertDecompositionMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X87B18FD97B2D8E80">3.5-4 AdjustmentMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X78B0FF2079269138">3.5-5 SaveDecompositionMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X84DD2D517FC1F905">3.5-6 CalculateDecompositionMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7FDC65328102C1B9">3.5-7 MatrixDecompositionMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X86EBEBF680EBC98E">3.5-8 DecompositionMatrixMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7B05627D83E6977E">3.5-9 AddIndecomposable</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X79FA055E8250E6A2">3.5-10 RemoveIndecomposable</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8434DC7C8364CB54">3.5-11 MissingIndecomposables</a></span>
</div>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap3.html#X7A697AAA799BA7D4">3.6 <span class="Heading">Calculating dimensions</span></a>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X828528747E4AC4C9">3.6-1 SimpleDimension</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7B98631580E193BB">3.6-2 SpechtDimension</a></span>
</div>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap3.html#X78F1DC277875BAFD">3.7 <span class="Heading">Combinatorics on Young diagrams</span></a>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X820A908F8337F59C">3.7-1 Schaper</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7FB82B3184287362">3.7-2 IsSimpleModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7A6262B684185E3D">3.7-3 MullineuxMap</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7CC6C04482DD1E9D">3.7-4 MullineuxSymbol</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7826922879DD8D8A">3.7-5 PartitionMullineuxSymbol</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7CE4D6487FD009B1">3.7-6 GoodNodes</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X783B52458335975F">3.7-7 NormalNodes</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X85B290977A17D9EE">3.7-8 GoodNodeSequence</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7B704FE781A311E5">3.7-9 PartitionGoodNodeSequence</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7A9DC101850008A2">3.7-10 GoodNodeLatticePath</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7918D9DE7ACE2294">3.7-11 LittlewoodRichardsonRule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7B9901427D1CF6F4">3.7-12 InverseLittlewoodRichardsonRule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X790D4ACF7930340F">3.7-13 EResidueDiagram</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7DE3773C78BC324C">3.7-14 HookLengthDiagram</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7F2ACCBF788A62E8">3.7-15 RemoveRimHook</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7CEA98C779BDBD1A">3.7-16 AddRimHook</a></span>
</div>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap3.html#X8350934A7F9AB5BE">3.8 <span class="Heading">Operations on partitions</span></a>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X867496487DC35776">3.8-1 ECore</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8236220C87814790">3.8-2 IsECore</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8538AAAF8628A725">3.8-3 EQuotient</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7F357B417D495B6F">3.8-4 CombineEQuotientECore</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7C460635829E7ED0">3.8-5 EWeight</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X86308F6C818B220C">3.8-6 ERegularPartitions</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7BEDA8F286ED5F20">3.8-7 IsERegular</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7D131AF0839089BD">3.8-8 ConjugatePartition</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8796C1D783ED9CB4">3.8-9 BetaSet</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8711CC56792711A7">3.8-10 PartitionBetaSet</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7EC4D0FA81B55391">3.8-11 ETopLadder</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X820388EF7C8333BA">3.8-12 Dominates</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X84DB1DD37AF227CF">3.8-13 LengthLexicographic</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8480188D81ECBD92">3.8-14 Lexicographic</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X78F41DF77D6F8292">3.8-15 ReverseDominance</a></span>
</div>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap3.html#X83890936806E3A34">3.9 <span class="Heading">Miscellaneous functions on modules</span></a>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7A8E810C85A62DD6">3.9-1 Specialized</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8232C0A1846A27FB">3.9-2 ERegulars</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X822E8193835DD1D9">3.9-3 SplitECores</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7E92948B80075E46">3.9-4 Coefficient</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X79FB3FE67D55BCFA">3.9-5 InnerProduct</a></span>
</div>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap3.html#X7D473E167C866CEC">3.10 <span class="Heading">Semi-standard and standard tableaux</span></a>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7F0F9663796E6978">3.10-1 Tableau</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X79ADB1B980D12A14">3.10-2 SemiStandardTableaux</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7E51D6107DBE2A74">3.10-3 StandardTableaux</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7869DA9A8198BD28">3.10-4 ConjugateTableau</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7E5351C27C9253D9">3.10-5 ShapeTableau</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7CABF92D7BF07DD1">3.10-6 TypeTableau</a></span>
</div>
</div>

<h3>3 <span class="Heading">Specht functionality</span></h3>

<p><a id="X78AA2DBD7D5D3F02" name="X78AA2DBD7D5D3F02"></a></p>

<h4>3.1 <span class="Heading">Porting notes</span></h4>

<p>Porting the <strong class="pkg">Specht</strong> 2.4 package to <strong class="pkg">GAP</strong> 4 did not influence the algorithms but required a completely new object oriented design of the underlying data structures. In <strong class="pkg">GAP</strong> 3 records were used to represent algebra objects, modules and decomposition matrices of <strong class="pkg">Specht</strong> 2.4. Further functions were stored inside of such records to provide name safety.</p>

<p>In <strong class="pkg">Hecke</strong> objects represent all the data that was named above. The overloading mechanism the former record-internal functions to be available on the toplevel. The operation selection mechanism of <strong class="pkg">GAP</strong> 4 allows one to concentrate on the computation code instead of dealing with different possible argument inputs.</p>

<p>Since variable argument length operations are not yet supported by <strong class="pkg">GAP</strong> 4, we introduced our own dispatcher facility to enable the former possibility of passing patrition arguments as sequences of integers (see <a href="chap3.html#X7C5B169286EFC900"><b>3.3</b></a>).</p>

<p><a id="X8340A4F97986693C" name="X8340A4F97986693C"></a></p>

<h5>3.1-1 <span class="Heading">Structure of <strong class="pkg">Hecke</strong></span></h5>

<p>The data structure hierarchy in <strong class="pkg">GAP</strong> 4 is defined through filters and their dependencies.</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsAlgebraObj</code></td><td class="tdright">( filter )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsHecke</code></td><td class="tdright">( filter )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsSchur</code></td><td class="tdright">( filter )</td></tr></table></div>
<p><code class="func">IsAlgebraObj</code> is a generic filter for the objects returned by the functions <code class="func">Specht</code> (<a href="chap3.html#X7FE26921867C440A"><b>3.2-1</b></a>) and <code class="func">Schur</code> (<a href="chap3.html#X7B57DF517F73F00D"><b>3.2-7</b></a>). Concretely, <code class="func">Specht</code> (<a href="chap3.html#X7FE26921867C440A"><b>3.2-1</b></a>) returns an <code class="func">IsHecke</code> object (automatically also an <code class="func">IsAlgebraObj</code> object). For design reasons <code class="func">IsSchur</code> is a subfilter of <code class="func">IsHecke</code>. This allows to use the same functions for Schur-algebras as for Hecke-algebras with minor restrictions.</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsAlgebraObjModule</code></td><td class="tdright">( filter )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsHeckeModule</code></td><td class="tdright">( filter )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsHeckeSpecht</code></td><td class="tdright">( filter )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsHeckePIM</code></td><td class="tdright">( filter )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsHeckeSimple</code></td><td class="tdright">( filter )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsFockModule</code></td><td class="tdright">( filter )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsFockSpecht</code></td><td class="tdright">( filter )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsFockPIM</code></td><td class="tdright">( filter )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsFockSimple</code></td><td class="tdright">( filter )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsSchurModule</code></td><td class="tdright">( filter )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsSchurWeyl</code></td><td class="tdright">( filter )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsSchurPIM</code></td><td class="tdright">( filter )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsSchurSimple</code></td><td class="tdright">( filter )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsFockSchurModule</code></td><td class="tdright">( filter )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsFockSchurWeyl</code></td><td class="tdright">( filter )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsFockSchurPIM</code></td><td class="tdright">( filter )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsFockSchurSimple</code></td><td class="tdright">( filter )</td></tr></table></div>
<p>The hierarchy of module objects is more complex. On top we have the filter <code class="func">IsAlgebraObjModule</code>. Its direct descendant <code class="func">IsHeckeModule</code> has <code class="func">IsHeckeSpecht</code>, <code class="func">IsHeckePIM</code>, <code class="func">IsHeckeSimple</code>, <code class="func">IsFockModule</code> and <code class="func">IsSchurModule</code> as subfilters. Again the last two subfilter relations have no mathematical sense but are technically comfortable. The filter <code class="func">IsFockModule</code> is superfilter of <code class="func">IsFockSpecht</code>, <code class="func">IsFockPIM</code>, <code class="func">IsFockSimple</code> and <code class="func">IsFockSchurModule</code>. Analogously, <code class="func">IsSchurModule</code> is superfilter of <code class="func">IsSchurWeyl</code>, <code class="func">IsSchurPIM</code>, <code class="func">IsSchurSimple</code> and <code class="func">IsFockSchurModule</code> which itself is superfilter of <code class="func">IsFockSchurWeyl</code>, <code class="func">IsFockSchurPIM</code>, <code class="func">IsFockSchurSimple</code>. Further, there are subfilter relations between <code class="func">IsFockSpecht</code> and <code class="func">IsHeckeSpecht</code> etc., <code class="func">IsFockSchurWeyl</code> and <code class="func">IsFockSpecht</code> etc., <code class="func">IsFockSchurWeyl</code> and <code class="func">IsSchurWeyl</code> etc., <code class="func">IsSchurWeyl</code> and <code class="func">IsHeckeSpecht</code> etc. filters.</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsDecompositionMatrix</code></td><td class="tdright">( filter )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsCrystalDecompositionMatrix</code></td><td class="tdright">( filter )</td></tr></table></div>
<p>For decomposition matrices we use the filter <code class="func">IsDecompositionMatrix</code> and its subfilter <code class="func">IsCrystalDecompositionMatrix</code>.</p>

<p><a id="X8120A27282B82CC8" name="X8120A27282B82CC8"></a></p>

<h5>3.1-2 <span class="Heading">Renamings</span></h5>

<p>To keep things as backwards compatible as possible, we tried not to change names and function signatures. But for the former <code class="code">H.***</code>- and <code class="code">H.operations.***</code>-style functions it makes more sense to use toplevel functions (especially when the H is not explicitly needed inside of the called operation). Here is an overview of some important changes:</p>

<div class="pcenter"><table class="GAPDocTable">
<tr>
<td class="tdcenter"><strong class="pkg">GAP</strong> 3</td>
<td class="tdcenter"><strong class="pkg">GAP</strong> 4</td>
</tr>
<tr>
<td class="tdcenter"><code class="code">H.S</code></td>
<td class="tdcenter"><code class="func">MakeSpecht</code> (<a href="chap3.html#X7C92700882971537"><b>3.2-3</b></a>)</td>
</tr>
<tr>
<td class="tdcenter"><code class="code">H.P</code></td>
<td class="tdcenter"><code class="func">MakePIM</code> (<a href="chap3.html#X7C92700882971537"><b>3.2-3</b></a>)</td>
</tr>
<tr>
<td class="tdcenter"><code class="code">H.D</code></td>
<td class="tdcenter"><code class="func">MakeSimple</code> (<a href="chap3.html#X7C92700882971537"><b>3.2-3</b></a>)</td>
</tr>
<tr>
<td class="tdcenter"><code class="code">H.Sq</code></td>
<td class="tdcenter"><code class="func">MakeFockSpecht</code> (<a href="chap3.html#X83009CE685621BD4"><b>3.2-6</b></a>)</td>
</tr>
<tr>
<td class="tdcenter"><code class="code">H.Pq</code></td>
<td class="tdcenter"><code class="func">MakeFockPIM</code> (<a href="chap3.html#X83009CE685621BD4"><b>3.2-6</b></a>)</td>
</tr>
<tr>
<td class="tdcenter"><code class="code">S.W</code></td>
<td class="tdcenter"><code class="func">MakeSpecht</code> (<a href="chap3.html#X7C92700882971537"><b>3.2-3</b></a>)</td>
</tr>
<tr>
<td class="tdcenter"><code class="code">S.F</code></td>
<td class="tdcenter"><code class="func">MakeSimple</code> (<a href="chap3.html#X7C92700882971537"><b>3.2-3</b></a>)</td>
</tr>
<tr>
<td class="tdcenter"><code class="code">InducedModule</code></td>
<td class="tdcenter"><code class="func">RInducedModule</code> (<a href="chap3.html#X81D7F7A4812BB04D"><b>3.4-1</b></a>)</td>
</tr>
<tr>
<td class="tdcenter"><code class="code">RestrictedModule</code></td>
<td class="tdcenter"><code class="func">RRestrictedModule</code> (<a href="chap3.html#X783BC74E81A7D0E6"><b>3.4-3</b></a>)</td>
</tr>
<tr>
<td class="tdcenter"><code class="code">H.operations.New</code></td>
<td class="tdcenter"><code class="code">Module</code></td>
</tr>
<tr>
<td class="tdcenter"><code class="code">H.operations.Collect</code></td>
<td class="tdcenter"><code class="code">Collect</code></td>
</tr>
</table><br /><p>&nbsp;</p><br />
</div>

<p><a id="X7A7DF4FC796EF66F" name="X7A7DF4FC796EF66F"></a></p>

<h4>3.2 <span class="Heading">Specht functions</span></h4>

<p><a id="X7FE26921867C440A" name="X7FE26921867C440A"></a></p>

<h5>3.2-1 Specht</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; Specht</code>( <var class="Arg">e</var> )</td><td class="tdright">( method )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; Specht</code>( <var class="Arg">e, p</var> )</td><td class="tdright">( method )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; Specht</code>( <var class="Arg">e, p, val</var> )</td><td class="tdright">( method )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; Specht</code>( <var class="Arg">e, p, val, ring</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>object belonging to the filter <code class="func">IsHecke</code> (<a href="chap3.html#X8340A4F97986693C"><b>3.1-1</b></a>)</p>

<p>Let R be a field of characteristic 0, q a non-zero element of R, and let e be the smallest positive integer such that 1+q+...+q^e-1=0 (we set e=0 if no such integer exists). The object returned by <code class="code">Specht(e)</code> allows calculations in the Grothendieck rings of the Hecke algebras H of type <em>A</em> which are defined over R and have parameter q. Below we also describe how to consider Hecke algebras defined over fields of positive characteristic.</p>

<p><code class="func">Specht</code> returns an object which contains information about the the family of Hecke algebras determined by R and q. This object needs to be passed to the most of the <strong class="pkg">Hecke</strong> functions as an argument.</p>


<table class="example">
<tr><td><pre>
gap&gt; H:=Specht(5);
&lt;Hecke algebra with e = 5&gt;
gap&gt; Display(last);
Specht(e=5, S(), P(), D())
gap&gt; IsZeroCharacteristic(last);
true
</pre></td></tr></table>

<p>There is also a method <code class="func">Schur</code> (<a href="chap3.html#X7B57DF517F73F00D"><b>3.2-7</b></a>) for doing calculations with the q-Schur algebra. See <code class="func">DecompositionMatrix</code> (<a href="chap3.html#X84F0F9E47D5EEBCF"><b>3.2-8</b></a>), and <code class="func">CrystalDecompositionMatrix</code> (<a href="chap3.html#X7F616CCE808FA11E"><b>3.2-9</b></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X8037763587274161" name="X8037763587274161"></a></p>

<h5>3.2-2 <span class="Heading">Simple information access</span></h5>

<p>We allow to read/store some information from/in the algebra object returned by <code class="func">Specht</code> (<a href="chap3.html#X7FE26921867C440A"><b>3.2-1</b></a>) using the following functions.</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; OrderOfQ</code>( <var class="Arg">H</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>e.</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; Characteristic</code>( <var class="Arg">H</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>p.</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; SetOrdering</code>( <var class="Arg">H, Ordering</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Provides writing access to Ordering that is stored in H. The ordering influences the way how decomposition matrices are printed.</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; SpechtDirectory</code></td><td class="tdright">( global variable )</td></tr></table></div>
<p>Setting this global variable the user can tell <strong class="pkg">Hecke</strong> where to find decomposition matrices that are not in the library and also not in the current directory. By default this variable is set to the current directory.</p>

<p><a id="X7C92700882971537" name="X7C92700882971537"></a></p>

<h5>3.2-3 <span class="Heading">The functions MakeSpecht, MakePIM and MakeSimple</span></h5>

<p>The functions MakeSpecht, MakePIM and MakeSimple return objects belonging to the filter <code class="func">IsAlgebraObjModule</code> (<a href="chap3.html#X8340A4F97986693C"><b>3.1-1</b></a>) which correspond to Specht modules (<code class="func">IsHeckeSpecht</code> (<a href="chap3.html#X8340A4F97986693C"><b>3.1-1</b></a>)), projective indecomposable modules (<code class="func">IsHeckePIM</code> (<a href="chap3.html#X8340A4F97986693C"><b>3.1-1</b></a>)) and simple modules (<code class="func">IsHeckeSimple</code> (<a href="chap3.html#X8340A4F97986693C"><b>3.1-1</b></a>)) respectively. <strong class="pkg">Hecke</strong> allows manipulation of arbitrary linear combinations of these "modules", as well as a way of inducing and restricting them, "multiplying" them and converting between these three natural bases of the Grothendieck ring. Multiplication of modules corresponds to taking a tensor productand then inducing (thus giving a module for a larger Hecke algebra). Each of these three functions can be called in four different ways, as we now describe.</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; MakeSpecht</code>( <var class="Arg">H, mu</var> )</td><td class="tdright">( method )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; MakePIM</code>( <var class="Arg">H, mu</var> )</td><td class="tdright">( method )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; MakeSimple</code>( <var class="Arg">H, mu</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>In the first form, mu is a partition (either a list, or a sequence of integers) and the corresponding Specht module, PIM, or simple module (respectively), is returned.</p>


<table class="example">
<tr><td><pre>
gap&gt; H:=Specht(5);; MakePIM(H,4,3,2);; Display(last);
P(4,3,2)
</pre></td></tr></table>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; MakeSpecht</code>( <var class="Arg">x</var> )</td><td class="tdright">( method )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; MakePIM</code>( <var class="Arg">x</var> )</td><td class="tdright">( method )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; MakeSimple</code>( <var class="Arg">x</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Here, x is an H-module. In this form, <code class="func">MakeSpecht</code> rewrites x as a linear combination of Specht modules, if possible. Similarly, <code class="func">MakePIM</code> and <code class="func">MakeSimple</code> rewrite x as a linear combination of PIMs and simple modules respectively. These conversions require knowledge of the relevant decomposition matrix of H; if this is not known then <code class="keyw">fail</code> is returned (over fields of characteristic zero, all of the decomposition matrices are known via the algorithm of <a href="chapBib.html#biBLLT">[LLT96]</a>; various other decomposition matrices are included with <strong class="pkg">Hecke</strong>). For example, <code class="code">MakeSpecht(MakePIM(</code>H, mu<code class="code">))</code> returns sum_nu d_nu,mu S(nu) or <code class="keyw">fail</code> if some of these decomposition multiplicities are not known.</p>


<table class="example">
<tr><td><pre>
gap&gt; Display( MakeSimple( MakePIM(H,4,3,2) ) );
D(5,3,1) + 2D(4,3,2) + D(2^4,1)
gap&gt; Display( MakeSpecht( MakeSimple( MakeSpecht(H,1,1,1,1,1) ) ) );
 - S(5) + S(4,1) - S(3,1^2) + S(2,1^3)
</pre></td></tr></table>

<p>As the last example shows, <strong class="pkg">Hecke</strong> does not always behave as expected. The reason for this is that Specht modules indexed by e-singular partitions can always be written as a linear combination of Specht modules which involve only e-regular partitions. As such, it is not always clear when two elements are equal in the Grothendieck ring. Consequently, to test whether two modules are equal you should first rewrite both modules in the D-basis; this is <em>not</em> done by <strong class="pkg">Hecke</strong> because it would be very inefficient.</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; MakeSpecht</code>( <var class="Arg">d, mu</var> )</td><td class="tdright">( method )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; MakePIM</code>( <var class="Arg">d, mu</var> )</td><td class="tdright">( method )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; MakeSimple</code>( <var class="Arg">d, mu</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>In the third form, d is a decomposition matrix and mu is a partition. This is useful when you are trying to calculate a new decomposition matrix d because it allows you to do calculations using the known entries of d to deduce information about the unknown ones. When used in this way, <code class="func">MakePIM</code> and <code class="func">MakeSimple</code> use d to rewrite P(mu) and D(mu) respectively as a linear combination of Specht modules and <code class="func">MakeSpecht</code> uses d to write S(mu) as a linear combination of simple modules. If the values of the unknown entries in d are needed, <code class="keyw">fail</code> is returned.</p>


<table class="example">
<tr><td><pre>
gap&gt; H:=Specht(3,3);;   # e = 3, p = 3 = characteristic of 'R'
gap&gt;  d:=InducedDecompositionMatrix(DecompositionMatrix(H,14));;
# Inducing....
The following projectives are missing from &lt;d&gt;:
    [ 15 ]  [ 8, 7 ]
gap&gt; Display(MakePIM(d,4,3,3,2,2,1));
S(4,3^2,2^2,1) + S(4,3^2,2,1^3) + S(4,3,2^3,1^2) + S(3^3,2^2,1^2)
gap&gt; Display(MakeSpecht(d,7, 3, 3, 2));
D(11,2,1^2) + D(10,3,1^2) + D(8,5,1^2) + D(8,3^2,1) + D(7,6,1^2) + D(7,3^2,2)
gap&gt; Display(MakeSimple(d,14,1));
fail
</pre></td></tr></table>

<p>The final example returned <code class="keyw">fail</code> because the partitions (14,1) and (15) have the same 3-core (and P(15) is missing from d).</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; MakeSpecht</code>( <var class="Arg">d, x</var> )</td><td class="tdright">( method )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; MakePIM</code>( <var class="Arg">d, x</var> )</td><td class="tdright">( method )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; MakeSimple</code>( <var class="Arg">d, x</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>In the final form, d is a decomposition matrix and x is a module. All three functions rewrite x in their respective basis using d. Again this is only useful when you are trying to calculate a new decomposition matrix because, for any "known" decomposition matrix d, <code class="code">MakeSpecht(</code>x<code class="code">)</code> and <code class="code">MakeSpecht(</code>d, x<code class="code">)</code> are equivalent (and similarly for <code class="func">MakePIM</code> and <code class="func">MakeSimple</code>).</p>


<table class="example">
<tr><td><pre>
gap&gt; Display(MakeSpecht(d, MakeSimple(d,10,5) ));
 - S(13,2) + S(10,5)
</pre></td></tr></table>

<p><a id="X86F599A07A7C1C33" name="X86F599A07A7C1C33"></a></p>

<h5>3.2-4 <span class="Heading">Decomposition numbers of the symmetric groups</span></h5>

<p>The last example looked at Hecke algebras with parameter q=1 and R a field of characteristic 3 (so e=3); that is, the group algebra of the symmetric group over a field of characteristic 3. More generally, the command <code class="code">Specht(</code>p,p<code class="code">)</code> can be used to consider the group algebras of the symmetric groups over fields of characteristic p (i.e. e=p and R a field of characteristic p). For example, the dimensions of the simple modules of S_6 over fields of characteristic 5 can be computed as follows:</p>


<table class="example">
<tr><td><pre>
gap&gt; H:=Specht(5,5);; SimpleDimension(H,6);
6       : 1
5,1     : 5
4,2     : 8
4,1^2   : 10
3^2     : 5
3,2,1   : 8
3,1^3   : 10
2^3     : 5
2^2,1^2 : 1
2,1^4   : 5
true
</pre></td></tr></table>

<p><a id="X838BEC0382BF87EA" name="X838BEC0382BF87EA"></a></p>

<h5>3.2-5 <span class="Heading">Hecke algebras over fields of positive characteristic</span></h5>

<p>To consider Hecke algebras defined over arbitrary fields, <code class="func">Specht</code> (<a href="chap3.html#X7FE26921867C440A"><b>3.2-1</b></a>) must also be supplied with a valuation map val as an argument. The function val is a map from some PID into the natural numbers; at present it is needed only by functions which rely (at least implicitly), upon the q-analogue of Schaper's theorem. In general, val depends upon q and the characteristic of R; full details can be found in <a href="chapBib.html#biBJM2">[JM97]</a>. Over fields of characteristic zero and in the symmetric group case, the function val is automatically defined by <code class="func">Specht</code> (<a href="chap3.html#X7FE26921867C440A"><b>3.2-1</b></a>). When R is a field of characteristic zero, val([i]_q) is 1 if e divides i and 0 otherwise (this is the valuation map associated to the prime ideal in ℂ[v] generated by the e-th cyclotomic polynomial). When q=1 and R is a field of characteristic p, val is the usual p-adic valuation map. As another example, if q=4 and R is a field of characteristic 5 (so e=2), then the valuation map sends the integer x to nu_5([4]_x) where [4]_x is interpreted as an integer and nu_5 is the usual 5-adic valuation. To consider this Hecke algebra one could proceed as follows:</p>


<table class="example">
<tr><td><pre>
gap&gt; val:=function(x) local v;
&gt;       x:=Sum([0..x-1],v-&gt;4^v);  # x-&gt;[x]_q
&gt;       v:=0; while x mod 5=0 do x:=x/5; v:=v+1; od;
&gt;       return v;
&gt;     end;;
gap&gt; H:=Specht(2,5,val,"e2q4");; Display(H);
Specht(e=2, p=5, S(), P(), D(), HeckeRing="e2q4")
</pre></td></tr></table>

<p>Notice the string "e2q4" which was also passed to <code class="func">Specht</code> (<a href="chap3.html#X7FE26921867C440A"><b>3.2-1</b></a>) in this example. Although it is not strictly necessary, it is a good idea when using a "non-standard" valuation map val to specify the value of HeckeRing. This string is used for internal bookkeeping by <strong class="pkg">Hecke</strong>; in particular, it is used to determine filenames when reading and saving decomposition matrices. If a "standard" valuation map is used then HeckeRing is set to the string "e&lt;e&gt;p&lt;p&gt;"; otherwise it defaults to "unknown". The function <code class="func">SaveDecompositionMatrix</code> (<a href="chap3.html#X78B0FF2079269138"><b>3.5-5</b></a>) will not save any decomposition matrix for any Hecke algebra H with HeckeRing="unknown".</p>

<p><a id="X83009CE685621BD4" name="X83009CE685621BD4"></a></p>

<h5>3.2-6 <span class="Heading">The Fock space and Hecke algebras over fields of characteristic zero
</span></h5>

<p>For Hecke algebras H defined over fields of characteristic zero Lascoux, Leclerc and Thibon <a href="chapBib.html#biBLLT">[LLT96]</a> have described an easy, inductive, algorithm for calculating the decomposition matrices of H. Their algorithm really calculates the <em>canonical basis</em>, or (global) <em>crystal basis</em> of the Fock space; results of Grojnowski-Lusztig <a href="chapBib.html#biBGr">[Gro94]</a> show that computing this basis is equivalent to computing the decomposition matrices of H (see also <a href="chapBib.html#biBA">[Ari96]</a>).</p>

<p>The <em>Fock space</em> F is an (integrable) module for the quantum group U_q( sl^_e) of the affine special linear group. F is a free ℂ[v]-module with basis the set of all Specht modules S(mu) for all partitions mu of all integers.</p>

<p>Here v is an indeterminate over the integers (or strictly, ℂ) that is stored in the algebra object produced by <code class="func">Specht</code> (<a href="chap3.html#X7FE26921867C440A"><b>3.2-1</b></a>). The canonical basis elements Pq(mu) for the U_q( sl^_e)-submodule of F generated by the 0-partition are indexed by e-regular partitions mu. Moreover, under <em>specialization</em>, Pq(mu) maps to P(mu). An eloquent description of the algorithm for computing Pq(mu) can be found in <a href="chapBib.html#biBLLT">[LLT96]</a>.</p>

<p>To access the elements of the Fock space <strong class="pkg">Hecke</strong> provides the functions:</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; MakeFockPIM</code>( <var class="Arg">H, mu</var> )</td><td class="tdright">( method )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; MakeFockSpecht</code>( <var class="Arg">H, mu</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Notice that, unlike <code class="func">MakePIM</code> (<a href="chap3.html#X7C92700882971537"><b>3.2-3</b></a>) and <code class="func">MakeSpecht</code> (<a href="chap3.html#X7C92700882971537"><b>3.2-3</b></a>), the only arguments which <code class="func">MakeFockPIM</code> and <code class="func">MakeFockSpecht</code> accept are partitions.</p>

<p>The function <code class="func">MakeFockPIM</code> computes the canonical basis element Pq(mu) of the Fock space corresponding to the e-regular partition mu (there is a canonical basis -- defined using a larger quantum group -- for the whole of the Fock space <a href="chapBib.html#biBLT">[LT96]</a>; conjecturally, this basis can be used to compute the decomposition matrices for the q-Schur algebra over fields of characteristic zero). The second function returns a standard basis element Sq(mu) of F.</p>


<table class="example">
<tr><td><pre>
gap&gt; H:=Specht(4);; MakeFockPIM(H,6,2);; Display(last);
Sq(6,2) + vSq(5,3)
gap&gt; RRestrictedModule(last); Display(last);
Sq(6,1) + (v+v^-1)Sq(5,2) + vSq(4,3)
gap&gt; MakePIM(last);; Display(last);
Pq(6,1) + (v+v^-1)Pq(5,2)
gap&gt; Specialized(last);; Display(last);
P(6,1) + 2P(5,2)
gap&gt; MakeFockSpecht(H,5,3,2);; Display(last);
Sq(5,3,2)
gap&gt; RInducedModule(last,0);; Display(last);
v^-1Sq(5,3^2)
</pre></td></tr></table>

<p>The modules returned by <code class="func">MakeFockPIM</code> and <code class="func">MakeFockSpecht</code> behave very much like elements of the Grothendieck ring of H; however, they should be considered as elements of the Fock space. The key difference is that when induced or restricted "quantum" analogues of induction and restriction are used. These analogues correspond to the action of U_q( sl^_e) on F <a href="chapBib.html#biBLLT">[LLT96]</a>.</p>

<p>In effect, the functions <code class="func">MakeFockPIM</code> and <code class="func">MakeFockSpecht</code> allow computations in the Fock space, using the functions <code class="func">RInducedModule</code> (<a href="chap3.html#X81D7F7A4812BB04D"><b>3.4-1</b></a>) and <code class="func">RRestrictedModule</code> (<a href="chap3.html#X783BC74E81A7D0E6"><b>3.4-3</b></a>). The functions <code class="func">MakeSpecht</code> (<a href="chap3.html#X7C92700882971537"><b>3.2-3</b></a>), <code class="func">MakePIM</code> (<a href="chap3.html#X7C92700882971537"><b>3.2-3</b></a>) and <code class="func">MakeSimple</code> (<a href="chap3.html#X7C92700882971537"><b>3.2-3</b></a>) can also be applied to elements of the Fock space, in which case they have the expected effect. In addition, any element of the Fock space can be specialized to give the corresponding element of the Grothendieck ring of H (it is because of this correspondence that we do not make a distinction between elements of the Fock space and the Grothendieck ring of H).</p>

<p>When working over fields of characteristic zero <strong class="pkg">Hecke</strong> will automatically calculate any canonical basis elements that it needs for computations in the Grothendieck ring of H. If you are not interested in the canonical basis elements you need never work with them directly.</p>

<p><a id="X7B57DF517F73F00D" name="X7B57DF517F73F00D"></a></p>

<h5>3.2-7 Schur</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; Schur</code>( <var class="Arg">e</var> )</td><td class="tdright">( method )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; Schur</code>( <var class="Arg">e, p</var> )</td><td class="tdright">( method )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; Schur</code>( <var class="Arg">e, p, val</var> )</td><td class="tdright">( method )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; Schur</code>( <var class="Arg">e, p, val, ring</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>object belonging to the filter <code class="func">IsSchur</code> (<a href="chap3.html#X8340A4F97986693C"><b>3.1-1</b></a>)</p>

<p>This function behaves almost identically to the function <code class="func">Specht</code> (<a href="chap3.html#X7FE26921867C440A"><b>3.2-1</b></a>), the only difference being that the belonging modules are printed as "W", "P", "F" and that they correspond to the q-Weyl modules, the projective indecomposable modules, and the simple modules of the q-Schur algebra respectively. Note that the <code class="code">Make***</code>-functions (i.e. <code class="func">MakeSpecht</code> (<a href="chap3.html#X7C92700882971537"><b>3.2-3</b></a>) is used to generate q-Weyl modules). Further, note that our labeling of these modules is non-standard, following that used by James in <a href="chapBib.html#biBJ">[Jam90]</a>. The standard labeling can be obtained from ours by replacing all partitions by their conjugates.</p>

<p>Almost all of the functions in <strong class="pkg">Hecke</strong> which accept a Hecke algebra object H will also accept the object S returned by <code class="func">Schur</code> .</p>

<p>In the current version of <strong class="pkg">Hecke</strong> the decomposition matrices of q -Schur algebras are not fully supported. The <code class="func">InducedDecompositionMatrix</code> (<a href="chap3.html#X7D257389845738DB"><b>3.5-1</b></a>) function can be applied to these matrices; however there are no additional routines available for calculating the columns corresponding to e-singular partitions. The decomposition matrices for the q-Schur algebras defined over a field of characteristic 0 for n&lt;= 10 are in the <strong class="pkg">Hecke</strong> libraries.</p>


<table class="example">
<tr><td><pre>
gap&gt; S:=Schur(2);
&lt;Schur algebra with e = 2&gt;
gap&gt; InducedDecompositionMatrix(DecompositionMatrix(S,3));
# The following projectives are missing from &lt;d&gt;:
#  [ 2, 2 ]
&lt;5x5 decomposition matrix&gt;
gap&gt; Display(last);
4    | 1                   # DecompositionMatrix(S,4) returns the
3,1  | 1 1                 # full decomposition matrix. The point
2^2  | . 1 .               # of this example is to emphasize the
2,1^2| 1 1 . 1             # current limitations of Schur.
1^4  | 1 . . 1 1
</pre></td></tr></table>

<p>Note that when S is defined over a field of characteristic zero then the functions <code class="func">MakeFockSpecht</code> (<a href="chap3.html#X83009CE685621BD4"><b>3.2-6</b></a>) and <code class="func">MakeFockPIM</code> (<a href="chap3.html#X83009CE685621BD4"><b>3.2-6</b></a>) will calculate the canonical basis elements (see <code class="func">Specht</code> (<a href="chap3.html#X7FE26921867C440A"><b>3.2-1</b></a>)); currently <code class="code">MakeFockPIM(</code>mu<code class="code">)</code> is implemented only for e-regular partitions.</p>

<p>See also <code class="func">Specht</code> (<a href="chap3.html#X7FE26921867C440A"><b>3.2-1</b></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X84F0F9E47D5EEBCF" name="X84F0F9E47D5EEBCF"></a></p>

<h5>3.2-8 DecompositionMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; DecompositionMatrix</code>( <var class="Arg">H, n[, Ordering]</var> )</td><td class="tdright">( method )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; DecompositionMatrix</code>( <var class="Arg">H, file[, Ordering]</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>the decomposition matrix D of H(S_n) where H is a Hecke algebra object returned by the function <code class="func">Specht</code> (<a href="chap3.html#X7FE26921867C440A"><b>3.2-1</b></a>) (or <code class="func">Schur</code> (<a href="chap3.html#X7B57DF517F73F00D"><b>3.2-7</b></a>) ).</p>

<p><code class="func">DecompositionMatrix</code> first checks whether the required decomposition matrix exists as a library file (checking first in the current directory, next in the directory specified by <code class="func">SpechtDirectory</code> (<a href="chap3.html#X8037763587274161"><b>3.2-2</b></a>), and finally in the <strong class="pkg">Hecke</strong> libraries). If the base field of H has characteristic zero, <code class="func">DecompositionMatrix</code> next looks for <em>crystallized decomposition matrices</em> (see <code class="func">CrystalDecompositionMatrix</code> (<a href="chap3.html#X7F616CCE808FA11E"><b>3.2-9</b></a>)). If the decomposition matrix d is not stored in the library <code class="func">DecompositionMatrix</code> will calculate d when H is a Hecke algebra with a base field of characteristic zero, and will return <code class="code">fail</code> otherwise (in which case the function <code class="func">CalculateDecompositionMatrix</code> (<a href="chap3.html#X84DD2D517FC1F905"><b>3.5-6</b></a>) can be used to force <strong class="pkg">Hecke</strong> to try and calculate this matrix).</p>

<p>For Hecke algebras defined over fields of characteristic zero, <strong class="pkg">Hecke</strong> uses the algorithm of <a href="chapBib.html#biBLLT">[LLT96]</a> to calculate decomposition matrices The decomposition matrices for the q-Schur algebras for n&lt;=10 are contained in the <strong class="pkg">Hecke</strong> library, as are those for the symmetric group over fields of positive characteristic when n&lt;15.</p>

<p>Once a decomposition matrix is known, <strong class="pkg">Hecke</strong> keeps an internal copy of it which is used by the functions <code class="func">MakeSpecht</code> (<a href="chap3.html#X7C92700882971537"><b>3.2-3</b></a>), <code class="func">MakePIM</code> (<a href="chap3.html#X7C92700882971537"><b>3.2-3</b></a>), and <code class="func">MakeSimple</code> (<a href="chap3.html#X7C92700882971537"><b>3.2-3</b></a>); these functions also read decomposition matrix files as needed.</p>

<p>If you set the variable <code class="func">SpechtDirectory</code> (<a href="chap3.html#X8037763587274161"><b>3.2-2</b></a>), then <strong class="pkg">Hecke</strong> will also search for decomposition matrix files in this directory. The files in the current directory override those in <code class="func">SpechtDirectory</code> (<a href="chap3.html#X8037763587274161"><b>3.2-2</b></a>) and those in the <strong class="pkg">Hecke</strong> libraries.</p>

<p>In the second form of the function, when a filename is supplied, <code class="func">DecompositionMatrix</code> will read the decomposition matrix in the file filename, and this matrix will become <strong class="pkg">Hecke</strong>'s internal copy of this matrix.</p>

<p>By default, the rows and columns of the decomposition matrices are ordered <code class="func">DecompositionMatrix</code> with an ordering function such as <code class="func">LengthLexicographic</code> (<a href="chap3.html#X84DB1DD37AF227CF"><b>3.8-13</b></a>) or <code class="func">ReverseDominance</code> (<a href="chap3.html#X78F41DF77D6F8292"><b>3.8-15</b></a>). You do not need to specify the ordering you want every time you call <code class="func">DecompositionMatrix</code>; <strong class="pkg">Hecke</strong> will keep the same ordering until you change it again. This ordering can also be set "by hand" using the operation <code class="func">SetOrdering</code> (<a href="chap3.html#X8037763587274161"><b>3.2-2</b></a>)</p>


<table class="example">
<tr><td><pre>
gap&gt; DecompositionMatrix(Specht(3),6,LengthLexicographic);
&lt;11x7 decomposition matrix&gt;
gap&gt; Display(last);
6      | 1
5,1    | 1 1
4,2    | . . 1
3^2    | . 1 . 1
4,1^2  | . 1 . . 1
3,2,1  | 1 1 . 1 1 1
2^3    | 1 . . . . 1
3,1^3  | . . . . 1 1
2^2,1^2| . . . . . . 1
2,1^4  | . . . 1 . 1 .
1^6    | . . . 1 . . .
</pre></td></tr></table>

<p>Once you have a decomposition matrix it is often nice to be able to print it. The on screen version is often good enough; There are also functions for converting <strong class="pkg">Hecke</strong> decomposition matrices into <strong class="pkg">GAP</strong> matrices and vice versa (see <code class="func">MatrixDecompositionMatrix</code> (<a href="chap3.html#X7FDC65328102C1B9"><b>3.5-7</b></a>) and <code class="func">DecompositionMatrixMatrix</code> (<a href="chap3.html#X86EBEBF680EBC98E"><b>3.5-8</b></a>)).</p>

<p>Using the function <code class="func">InducedDecompositionMatrix</code> (<a href="chap3.html#X7D257389845738DB"><b>3.5-1</b></a>), it is possible to induce a decomposition matrix. See also <code class="func">SaveDecompositionMatrix</code> (<a href="chap3.html#X78B0FF2079269138"><b>3.5-5</b></a>) and <code class="func">IsNewIndecomposable</code> (<a href="chap3.html#X803A99987E501AC9"><b>3.5-2</b></a>), <code class="func">Specht</code> (<a href="chap3.html#X7FE26921867C440A"><b>3.2-1</b></a>), <code class="func">Schur</code> (<a href="chap3.html#X7B57DF517F73F00D"><b>3.2-7</b></a>), and <code class="func">CrystalDecompositionMatrix</code> (<a href="chap3.html#X7F616CCE808FA11E"><b>3.2-9</b></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X7F616CCE808FA11E" name="X7F616CCE808FA11E"></a></p>

<h5>3.2-9 CrystalDecompositionMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; CrystalDecompositionMatrix</code>( <var class="Arg">H, n[, Ordering]</var> )</td><td class="tdright">( method )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; CrystalDecompositionMatrix</code>( <var class="Arg">H, file[, Ordering]</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>the crystal decomposition matrix D of H(S_n) where H is a Hecke algebra object returned by the function <code class="func">Specht</code> (<a href="chap3.html#X7FE26921867C440A"><b>3.2-1</b></a>) (or <code class="func">Schur</code> (<a href="chap3.html#X7B57DF517F73F00D"><b>3.2-7</b></a>) ).</p>

<p>This function is similar to <code class="func">DecompositionMatrix</code> (<a href="chap3.html#X84F0F9E47D5EEBCF"><b>3.2-8</b></a>). The columns of decomposition matrices correspond to projective indecomposables; the columns of crystallized decomposition matrices correspond to the canonical basis elements of the Fock space (see <code class="func">Specht</code> (<a href="chap3.html#X7FE26921867C440A"><b>3.2-1</b></a>)). Consequently, the entries in these matrices are polynomials (in v), and by specializing (i.e. setting v equal to 1; see <code class="func">Specialized</code> (<a href="chap3.html#X7A8E810C85A62DD6"><b>3.9-1</b></a>)), the decomposition matrices of H are obtained (see <code class="func">Specht</code> (<a href="chap3.html#X7FE26921867C440A"><b>3.2-1</b></a>)). Crystallized decomposition matrices are defined only for Hecke algebras over a base field of characteristic zero. Unlike "normal" decomposition matrices, crystallized decomposition matrices cannot be induced.</p>


<table class="example">
<tr><td><pre>
gap&gt; CrystalDecompositionMatrix(Specht(3), 6);
&lt;11x7 decomposition matrix&gt;
gap&gt; Display(last);
6      |   1
5,1    |   v   1
4,2    |   .   .   1
4,1^2  |   .   v   .   1
3^2    |   .   v   .   .   1
3,2,1  |   v v^2   .   v   v   1
3,1^3  |   .   .   . v^2   .   v
2^3    | v^2   .   .   .   .   v
2^2,1^2|   .   .   .   .   .   .   1
2,1^4  |   .   .   .   .   v v^2   .
1^6    |   .   .   .   . v^2   .   .
gap&gt; Specialized(last);   # set v equal to 1.
&lt;11x7 decomposition matrix&gt;
gap&gt; Display(last);
6      | 1
5,1    | 1 1
4,2    | . . 1
4,1^2  | . 1 . 1
3^2    | . 1 . . 1
3,2,1  | 1 1 . 1 1 1
3,1^3  | . . . 1 . 1
2^3    | 1 . . . . 1
2^2,1^2| . . . . . . 1
2,1^4  | . . . . 1 1 .
1^6    | . . . . 1 . .
</pre></td></tr></table>

<p>See also <code class="func">Specht</code> (<a href="chap3.html#X7FE26921867C440A"><b>3.2-1</b></a>), <code class="func">Schur</code> (<a href="chap3.html#X7B57DF517F73F00D"><b>3.2-7</b></a>), <code class="func">DecompositionMatrix</code> (<a href="chap3.html#X84F0F9E47D5EEBCF"><b>3.2-8</b></a>) and <code class="func">Specialized</code> (<a href="chap3.html#X7A8E810C85A62DD6"><b>3.9-1</b></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X829A23A97EE4C20E" name="X829A23A97EE4C20E"></a></p>

<h5>3.2-10 DecompositionNumber</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; DecompositionNumber</code>( <var class="Arg">H, mu, nu</var> )</td><td class="tdright">( method )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; DecompositionNumber</code>( <var class="Arg">d, mu, nu</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>This function attempts to calculate the decomposition multiplicity of D(nu) in S(mu) (equivalently, the multiplicity of S(mu) in P(nu)). If P(nu) is known, we just look up the answer; if not <code class="func">DecompositionNumber</code> tries to calculate the answer using "row and column removal" (see <a href="chapBib.html#biBJ">[Jam90, Theorem 6.18]</a>).</p>


<table class="example">
<tr><td><pre>
gap&gt; H:=Specht(6);; DecompositionNumber(H,[6,4,2],[6,6]);
0
</pre></td></tr></table>

<p>This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X7C5B169286EFC900" name="X7C5B169286EFC900"></a></p>

<h4>3.3 <span class="Heading">Partitions in <strong class="pkg">Hecke</strong></span></h4>

<p>Many of the functions in <strong class="pkg">Hecke</strong> take partitions as arguments. Partitions are usually represented by lists in <strong class="pkg">GAP</strong>. In <strong class="pkg">Hecke</strong>, all the functions which expect a partition will accept their argument either as a list or simply as a sequence of numbers. So, for example:</p>


<table class="example">
<tr><td><pre>
gap&gt; H:=Specht(4);; Print(MakeSpecht(MakePIM(H,6,4)),"\n");
S(6,4) + S(6,3,1) + S(5,3,1,1) + S(3,3,2,1,1) + S(2,2,2,2,2)
gap&gt; Print(MakeSpecht(MakePIM(H,[6,4])),"\n");
S(6,4) + S(6,3,1) + S(5,3,1,1) + S(3,3,2,1,1) + S(2,2,2,2,2)
</pre></td></tr></table>

<p>Some functions require more than one argument, but the convention still applies.</p>


<table class="example">
<tr><td><pre>
gap&gt; ECore(3, [6,4,2]);
[ 6, 4, 2 ]
gap&gt; ECore(3, 6,4,2);
[ 6, 4, 2 ]
gap&gt; GoodNodes(3, 6,4,2);
[ false, false, 3 ]
gap&gt; GoodNodes(3, [6,4,2], 2);
3
</pre></td></tr></table>

<p>Basically, it never hurts to put the extra brackets in, and they can be omitted so long as this is not ambiguous. One function where the brackets are needed is <code class="func">DecompositionNumber</code> (<a href="chap3.html#X829A23A97EE4C20E"><b>3.2-10</b></a>) this is clear because the function takes two partitions as its arguments.</p>

<p><a id="X87A6E8DD85F3F020" name="X87A6E8DD85F3F020"></a></p>

<h4>3.4 <span class="Heading">Inducing and restricting modules</span></h4>

<p><strong class="pkg">Hecke</strong> provides four functions <code class="func">RInducedModule</code> (<a href="chap3.html#X81D7F7A4812BB04D"><b>3.4-1</b></a>), <code class="func">RRestrictedModule</code> (<a href="chap3.html#X783BC74E81A7D0E6"><b>3.4-3</b></a>), <code class="func">SInducedModule</code> (<a href="chap3.html#X780709B3865BC344"><b>3.4-2</b></a>) and <code class="func">SRestrictedModule</code> (<a href="chap3.html#X8041ABFA86D7A3EF"><b>3.4-4</b></a>) for inducing and restricting modules. All functions can be applied to Specht modules, PIMs, and simple modules. These functions all work by first rewriting all modules as a linear combination of Specht modules (or q-Weyl modules), and then inducing and restricting. Whenever possible the induced or restricted module will be written in the original basis.</p>

<p>All of these functions can also be applied to elements of the Fock space (see <code class="func">Specht</code> (<a href="chap3.html#X7FE26921867C440A"><b>3.2-1</b></a>)); in which case they correspond to the action of the generators E_i and F_i of U_q( sl^_e) on F. There is also a function <code class="func">InducedDecompositionMatrix</code> (<a href="chap3.html#X7D257389845738DB"><b>3.5-1</b></a>) for inducing decomposition matrices.</p>

<p><a id="X81D7F7A4812BB04D" name="X81D7F7A4812BB04D"></a></p>

<h5>3.4-1 RInducedModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; RInducedModule</code>( <var class="Arg">x</var> )</td><td class="tdright">( method )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; RInducedModule</code>( <var class="Arg">x, r1[, r2, ...]</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>the induced modules of the Specht modules, principal indecomposable modules, and simple modules (more accurately, their image in the Grothendieck ring).</p>

<p>There is an natural embedding of H(S_n) in H(S_n+1) which in the usual way lets us define an <em>induced</em> H(S_n+1)-module for every H(S_n)-module.</p>

<p>There is also a function <code class="func">SInducedModule</code> (<a href="chap3.html#X780709B3865BC344"><b>3.4-2</b></a>) which provides a much faster way of r-inducing s times (and inducing s times).</p>

<p>Let mu be a partition. Then the induced module <code class="code">RInducedModule(S(</code>mu<code class="code">))</code> is easy to describe: it has the same composition factors as sum S(nu) where nu runs over all partitions whose diagrams can be obtained by adding a single node to the diagram of mu.</p>


<table class="example">
<tr><td><pre>
gap&gt; H:=Specht(2,2);;
gap&gt; Display(RInducedModule(MakeSpecht(H,7,4,3,1)));
S(8,4,3,1) + S(7,5,3,1) + S(7,4^2,1) + S(7,4,3,2) + S(7,4,3,1^2)
gap&gt; Display(RInducedModule(MakePIM(H,5,3,1)));
P(6,3,1) + 2P(5,4,1) + P(5,3,2)
gap&gt; Display(RInducedModule(MakeSimple(H,11,2,1)));
# D(&lt;x&gt;), unable to rewrite &lt;x&gt; as a sum of simples
S(12,2,1) + S(11,3,1) + S(11,2^2) + S(11,2,1^2)
</pre></td></tr></table>

<p>When inducing indecomposable modules and simple modules, <code class="func">RInducedModule</code> first rewrites these modules as a linear combination of Specht modules (using known decomposition matrices), and then induces this linear combination of Specht modules. If possible <strong class="pkg">Hecke</strong> then rewrites the induced module back in the original basis. Note that in the last example above, the decomposition matrix for S_15 is not known by <strong class="pkg">Hecke</strong> this is why <code class="func">RInducedModule</code> was unable to rewrite this module in the D-basis.</p>

<p><em>r-Induction</em></p>

<p>Two Specht modules S(mu) and S(nu) belong to the same block if and only if the corresponding partitions mu and nu have the same e-core <a href="chapBib.html#biBJM2">[JM97]</a> (see <code class="func">ECore</code> (<a href="chap3.html#X867496487DC35776"><b>3.8-1</b></a>)). Because the e-core of a partition is determined by its (multiset of) e -residues, if S(mu) and S(nu) appear in <code class="code">RInducedModule(S(</code>tau<code class="code">))</code>, for some partition tau, then S(mu) and S(nu) belong to the same block if and only if mu and nu can be obtained by adding a node of the same e-residue to the diagram of tau. The second form of <code class="func">RInducedModule</code> allows one to induce "within blocks" by only adding nodes of some fixed e-residue r; this is known as <em>r-induction</em>. Note that 0&lt;= r&lt;e.</p>


<table class="example">
<tr><td><pre>
gap&gt; H:=Specht(4);; Display(RInducedModule(MakeSpecht(H,5,2,1)));
S(6,2,1) + S(5,3,1) + S(5,2^2) + S(5,2,1^2)
gap&gt; Display(RInducedModule(MakeSpecht(H,5,2,1),0));
0S()
gap&gt; Display(RInducedModule(MakeSpecht(H,5,2,1),1));
S(6,2,1) + S(5,3,1) + S(5,2,1^2)
gap&gt; Display(RInducedModule(MakeSpecht(H,5,2,1),2));
0S()
gap&gt; Display(RInducedModule(MakeSpecht(H,5,2,1),3));
S(5,2^2)
</pre></td></tr></table>

<p>The function <code class="func">EResidueDiagram</code> (<a href="chap3.html#X790D4ACF7930340F"><b>3.7-13</b></a>), prints the diagram of mu, labeling each node with its e-residue. A quick check of this diagram confirms the answers above.</p>


<table class="example">
<tr><td><pre>
gap&gt; EResidueDiagram(H,5,2,1);
  0  1  2  3  0
  3  0
  2
true
</pre></td></tr></table>

<p><em>"Quantized" induction</em></p>

<p>When <code class="func">RInducedModule</code> is applied to the canonical basis elements <code class="code">MakeFockPIM(</code>mu<code class="code">)</code> (or more generally elements of the Fock space; see <code class="func">Specht</code> (<a href="chap3.html#X7FE26921867C440A"><b>3.2-1</b></a>)), a "quantum analogue" of induction is applied. More precisely, the function <code class="code">RInducedModule(</code>*,i<code class="code">)</code> corresponds to the action of the generator F_i of the quantum group U_q( sl^_e) on F <a href="chapBib.html#biBLLT">[LLT96]</a>.</p>


<table class="example">
<tr><td><pre>
gap&gt; H:=Specht(3);; x:=RInducedModule(MakeFockPIM(H,4,2),1,2);;
gap&gt; Display(x); Display(MakePIM(x));
Sq(6,2) + vSq(4^2) + v^2Sq(4,2^2)
Pq(6,2)
</pre></td></tr></table>

<p>See also <code class="func">SInducedModule</code> (<a href="chap3.html#X780709B3865BC344"><b>3.4-2</b></a>), <code class="func">RRestrictedModule</code> (<a href="chap3.html#X783BC74E81A7D0E6"><b>3.4-3</b></a>) and <code class="func">SRestrictedModule</code> (<a href="chap3.html#X8041ABFA86D7A3EF"><b>3.4-4</b></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X780709B3865BC344" name="X780709B3865BC344"></a></p>

<h5>3.4-2 SInducedModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; SInducedModule</code>( <var class="Arg">x, s</var> )</td><td class="tdright">( method )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; SInducedModule</code>( <var class="Arg">x, s, r</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>The function <code class="func">SInducedModule</code>, standing for "string induction", provides a more efficient way of r-inducing s times (and a way of inducing s times if the residue r is omitted); r-induction is explained in "<code class="func">RInducedModule</code> (<a href="chap3.html#X81D7F7A4812BB04D"><b>3.4-1</b></a>).</p>


<table class="example">
<tr><td><pre>
gap&gt; SizeScreen([80,20]);;
gap&gt; H:=Specht(4);; Display(SInducedModule(MakePIM(H,5,2,1),3));
P(8,2,1) + 3P(7,3,1) + 2P(7,2^2) + 6P(6,3,2) + 6P(6,3,1^2) + 3P(6,2,1^3) + 2P(\
5,3^2) + P(5,2^2,1^2)
gap&gt; Display(SInducedModule(MakePIM(H,5,2,1),3,1));
P(6,3,1^2)
gap&gt; Display(RInducedModule(MakePIM(H,5,2,1),1,1,1));
6P(6,3,1^2)
</pre></td></tr></table>

<p>Note that the multiplicity of each summand of <code class="code">RInducedModule(</code>x,r,...,r<code class="code">)</code> is divisible by s! and that <code class="func">SInducedModule</code> divides by this constant.</p>

<p>As with <code class="func">RInducedModule</code> (<a href="chap3.html#X81D7F7A4812BB04D"><b>3.4-1</b></a>) this function can also be applied to elements of the Fock space (see <code class="func">Specht</code> (<a href="chap3.html#X7FE26921867C440A"><b>3.2-1</b></a>)), in which case the quantum analogue of induction is used.</p>

<p>See also <code class="func">RInducedModule</code> (<a href="chap3.html#X81D7F7A4812BB04D"><b>3.4-1</b></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X783BC74E81A7D0E6" name="X783BC74E81A7D0E6"></a></p>

<h5>3.4-3 RRestrictedModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; RRestrictedModule</code>( <var class="Arg">x</var> )</td><td class="tdright">( method )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; RRestrictedModule</code>( <var class="Arg">x, r1[, r2, ...]</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>the corresponding module for H(S_n-1) when given a module x for H(S_n)</p>

<p>The restriction of the Specht module S(mu) is the linear combination of Specht modules sum S(nu) where nu runs over the partitions whose diagrams are obtained by deleting a node from the diagram of mu. If only nodes of residue r are deleted then this corresponds to first restricting S(mu) and then taking one of the block components of the restriction; this process is known as <em>r-restriction</em> (cf. r-induction in <code class="func">RInducedModule</code> (<a href="chap3.html#X81D7F7A4812BB04D"><b>3.4-1</b></a>)).</p>

<p>There is also a function <code class="func">SRestrictedModule</code> (<a href="chap3.html#X8041ABFA86D7A3EF"><b>3.4-4</b></a>) which provides a faster way of r-restricting s times (and restricting s times).</p>

<p>When more than one residue if given to <code class="func">RRestrictedModule</code> it returns <code class="code">RRestrictedModule(</code>x,r_1,r_2,...,r_k<code class="code">)</code>= <code class="code">RRestrictedModule( RRestrictedModule(</code>x,r_1<code class="code">)</code>,r_2,...,r_k<code class="code">)</code> (cf. <code class="func">RInducedModule</code> (<a href="chap3.html#X81D7F7A4812BB04D"><b>3.4-1</b></a>)).</p>


<table class="example">
<tr><td><pre>
gap&gt; H:=Specht(6);; Display(RRestrictedModule(MakePIM(H,5,3,2,1),4));
2P(4,3,2,1)
gap&gt; Display(RRestrictedModule(MakeSimple(H,5,3,2),1));
D(5,2^2)
</pre></td></tr></table>

<p><em>"Quantized" restriction</em></p>

<p>As with <code class="func">RInducedModule</code> (<a href="chap3.html#X81D7F7A4812BB04D"><b>3.4-1</b></a>), when <code class="func">RRestrictedModule</code> is applied to the canonical basis elements <code class="code">MakeFockPIM(</code>mu<code class="code">)</code> a quantum analogue of restriction is applied; this time, <code class="code">RRestrictedModule(</code>*,i<code class="code">)</code> corresponds to the action of the generator E_i of U_q( sl^_e) on F<a href="chapBib.html#biBLLT">[LLT96]</a>.</p>

<p>See also <code class="func">RInducedModule</code> (<a href="chap3.html#X81D7F7A4812BB04D"><b>3.4-1</b></a>), <code class="func">SInducedModule</code> (<a href="chap3.html#X780709B3865BC344"><b>3.4-2</b></a>) and <code class="func">SRestrictedModule</code> (<a href="chap3.html#X8041ABFA86D7A3EF"><b>3.4-4</b></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X8041ABFA86D7A3EF" name="X8041ABFA86D7A3EF"></a></p>

<h5>3.4-4 SRestrictedModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; SRestrictedModule</code>( <var class="Arg">x, s</var> )</td><td class="tdright">( method )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; SRestrictedModule</code>( <var class="Arg">x, s, r</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>As with <code class="func">SInducedModule</code> (<a href="chap3.html#X780709B3865BC344"><b>3.4-2</b></a>) this function provides a more efficient way of r-restricting s times, or restricting s times if the residue r is omitted (cf. <code class="func">SInducedModule</code> (<a href="chap3.html#X780709B3865BC344"><b>3.4-2</b></a>)).</p>


<table class="example">
<tr><td><pre>
gap&gt; H:=Specht(6);; Display(SRestrictedModule(MakeSpecht(H,4,3,2),3));
3S(4,2) + 2S(4,1^2) + 3S(3^2) + 6S(3,2,1) + 2S(2^3)
gap&gt; Display(SRestrictedModule(MakePIM(H,5,4,1),2,4));
P(4^2)
</pre></td></tr></table>

<p>See also <code class="func">RInducedModule</code> (<a href="chap3.html#X81D7F7A4812BB04D"><b>3.4-1</b></a>), <code class="func">SInducedModule</code> (<a href="chap3.html#X780709B3865BC344"><b>3.4-2</b></a>) and <code class="func">RRestrictedModule</code> (<a href="chap3.html#X783BC74E81A7D0E6"><b>3.4-3</b></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X79F430837BA7BAD2" name="X79F430837BA7BAD2"></a></p>

<h4>3.5 <span class="Heading">Operations on decomposition matrices</span></h4>

<p><strong class="pkg">Hecke</strong> is a package for computing decomposition matrices; this section describes the functions available for accessing these matrices directly. In addition to decomposition matrices, <strong class="pkg">Hecke</strong> also calculates the "crystallized decomposition matrices" of <a href="chapBib.html#biBLLT">[LLT96]</a> and the "adjustment matrices" introduced by James <a href="chapBib.html#biBJ">[Jam90]</a> (and Geck <a href="chapBib.html#biBG">[Gec92]</a>).</p>

<p>Throughout <strong class="pkg">Hecke</strong> we place an emphasis on calculating the projective indecomposable modulesand hence upon the columns of decomposition matrices. This approach seems more efficient than the traditional approach of calculating decomposition matrices by rows; ideally both approaches should be combined (as is done by <code class="func">IsNewIndecomposable</code> (<a href="chap3.html#X803A99987E501AC9"><b>3.5-2</b></a>)).</p>

<p>In principle, all decomposition matrices for all Hecke algebras defined over a field of characteristic zero are available from within <strong class="pkg">Hecke</strong>. In addition, the decomposition matrices for all q-Schur algebras with n&lt;=10 and all values of e and the p-modular decomposition matrices of the symmetric groups S_n for n&lt;15 are in the <strong class="pkg">Hecke</strong> library files.</p>

<p>If you are using <strong class="pkg">Hecke</strong> regularly to do calculations involving certain values of e it would be advantageous to have <strong class="pkg">Hecke</strong> calculate and save the first 20 odd decomposition matrices that you are interested in. So, for e=4 use the commands:</p>


<table class="example">
<tr><td><pre>
gap&gt; H:=Specht(4);; for n in [8..20] do
&gt;      SaveDecompositionMatrix(DecompositionMatrix(H,n));
&gt;    od;
</pre></td></tr></table>

<p>Alternatively, you could save the crystallized decomposition matrices. Note that for n&lt;2e the decomposition matrices are known (by <strong class="pkg">Hecke</strong>) and easy to compute.</p>

<p><a id="X7D257389845738DB" name="X7D257389845738DB"></a></p>

<h5>3.5-1 InducedDecompositionMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; InducedDecompositionMatrix</code>( <var class="Arg">d</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>If d is the decomposition matrix of H(S_n), then <code class="code">InducedDecompositionMatrix(</code>d<code class="code">)</code> attempts to calculate the decomposition matrix of H(S_n+1). It does this by extracting each projective indecomposable from d and inducing these modules to obtain projective modules for H(S_n+1). <code class="func">InducedDecompositionMatrix</code> then tries to decompose these projectives using the function <code class="func">IsNewIndecomposable</code> (<a href="chap3.html#X803A99987E501AC9"><b>3.5-2</b></a>). In general there will be columns of the decomposition matrix which <code class="func">InducedDecompositionMatrix</code> is unable to decompose and these will have to be calculated "by hand". <code class="func">InducedDecompositionMatrix</code> prints a list of those columns of the decomposition matrix which it is unable to calculate (this list is also printed by the function <code class="func">MissingIndecomposables</code> (<a href="chap3.html#X8434DC7C8364CB54"><b>3.5-11</b></a>)).</p>


<table class="example">
<tr><td><pre>
gap&gt; d:=DecompositionMatrix(Specht(3,3),14);
&lt;135x57 decomposition matrix&gt;
gap&gt; InducedDecompositionMatrix(d);
# Inducing....
The following projectives are missing from &lt;d&gt;:
    [ 15 ]  [ 8, 7 ]
&lt;176x70 decomposition matrix&gt;
</pre></td></tr></table>

<p>Note that the missing indecomposables come in "pairs" which map to each other under the Mullineux map (see <code class="func">MullineuxMap</code> (<a href="chap3.html#X7A6262B684185E3D"><b>3.7-3</b></a>)).</p>

<p>Almost all of the decomposition matrices included in <strong class="pkg">Hecke</strong> were calculated directly by <code class="func">InducedDecompositionMatrix</code>. When n is "small" <code class="func">InducedDecompositionMatrix</code> is usually able to return the full decomposition matrix for H(S_n). Finally, although the <code class="func">InducedDecompositionMatrix</code> can also be applied to the decomposition matrices of the q-Schur algebras (see <code class="func">Schur</code> (<a href="chap3.html#X7B57DF517F73F00D"><b>3.2-7</b></a>)), <code class="func">InducedDecompositionMatrix</code> is much less successful in inducing these decomposition matrices because it contains no special routines for dealing with the indecomposable modules of the q-Schur algebra which are indexed by e-singular partitions. Note also that we use a non-standard labeling of the decomposition matrices of q-Schur algebras; see <code class="func">Schur</code> (<a href="chap3.html#X7B57DF517F73F00D"><b>3.2-7</b></a>).</p>

<p><a id="X803A99987E501AC9" name="X803A99987E501AC9"></a></p>

<h5>3.5-2 IsNewIndecomposable</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsNewIndecomposable</code>( <var class="Arg">d, x[, mu]</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b><code class="keyw">true</code> if it is able to show that x is indecomposable (and this indecomposable is not already listed in d), and <code class="keyw">false</code> otherwise.</p>

<p><code class="func">IsNewIndecomposable</code> is the function which does all of the hard work when the function <code class="func">InducedDecompositionMatrix</code> (<a href="chap3.html#X7D257389845738DB"><b>3.5-1</b></a>) is applied to decomposition matrices. <code class="func">IsNewIndecomposable</code> will also print a brief description of its findings, giving an upper and lower bound on the <em>first</em> decomposition number mu for which it is unable to determine the multiplicity of S(mu) in x.</p>

<p><code class="func">IsNewIndecomposable</code> works by running through all of the partitions nu such that P(nu) could be a summand of x and it uses various results, such as the q-Schaper theorem of <a href="chapBib.html#biBJM2">[JM97]</a> (see <code class="func">Schaper</code> (<a href="chap3.html#X820A908F8337F59C"><b>3.7-1</b></a>)), the Mullineux map (see <code class="func">MullineuxMap</code> (<a href="chap3.html#X7A6262B684185E3D"><b>3.7-3</b></a>)) and inducing simple modules, to determine if P(nu) does indeed split off. In addition, if d is the decomposition matrix for H(S_n) then <code class="func">IsNewIndecomposable</code> will probably use some of the decomposition matrices of H(S_m) for m&lt;= n, if they are known. Consequently it is a good idea to save decomposition matrices as they are calculated (see <code class="func">SaveDecompositionMatrix</code> (<a href="chap3.html#X78B0FF2079269138"><b>3.5-5</b></a>)).</p>

<p>For example, in calculating the 2-modular decomposition matrices of S_r the first projective which <code class="func">InducedDecompositionMatrix</code> (<a href="chap3.html#X7D257389845738DB"><b>3.5-1</b></a>) is unable to calculate is P(10).</p>


<table class="example">
<tr><td><pre>
gap&gt; H:=Specht(2,2);;
gap&gt; d:=InducedDecompositionMatrix(DecompositionMatrix(H,9));;
# Inducing.
# The following projectives are missing from &lt;d&gt;:
#  [ 10 ]
</pre></td></tr></table>

<p>(In fact, given the above commands, <strong class="pkg">Hecke</strong> will return the full decomposition matrix for S_10 because this matrix is in the library; these were the commands that were used to calculate the decomposition matrix in the library.)</p>

<p>By inducing P(9) we can find a projective H-module which contains P(10). We can then use <code class="func">IsNewIndecomposable</code> to try and decompose this induced module into a sum of PIMs.</p>


<table class="example">
<tr><td><pre>
gap&gt; SizeScreen([80,20]);; x:=RInducedModule(MakePIM(H,9),1);; Display(x);
# P(&lt;x&gt;), unable to rewrite &lt;x&gt; as a sum of projectives
S(10) + S(9,1) + S(8,2) + 2S(8,1^2) + S(7,3) + 2S(7,1^3) + 3S(6,3,1) + 3S(6,2^\
2) + 4S(6,2,1^2) + 2S(6,1^4) + 4S(5,3,2) + 5S(5,3,1^2) + 5S(5,2^2,1) + 2S(5,1^\
5) + 2S(4^2,2) + 2S(4^2,1^2) + 2S(4,3^2) + 5S(4,3,1^3) + 2S(4,2^3) + 5S(4,2^2,\
1^2) + 4S(4,2,1^4) + 2S(4,1^6) + 2S(3^3,1) + 2S(3^2,2^2) + 4S(3^2,2,1^2) + 3S(\
3^2,1^4) + 3S(3,2^2,1^3) + 2S(3,1^7) + S(2^3,1^4) + S(2^2,1^6) + S(2,1^8) + S(\
1^10)
gap&gt; IsNewIndecomposable(d,x);
# The multiplicity of S(6,3,1) in P(10) is at least 1 and at most 2.
false
gap&gt; Display(x);
S(10) + S(9,1) + S(8,2) + 2S(8,1^2) + S(7,3) + 2S(7,1^3) + 2S(6,3,1) + 2S(6,2^\
2) + 3S(6,2,1^2) + 2S(6,1^4) + 3S(5,3,2) + 4S(5,3,1^2) + 4S(5,2^2,1) + 2S(5,1^\
5) + 2S(4^2,2) + 2S(4^2,1^2) + 2S(4,3^2) + 4S(4,3,1^3) + 2S(4,2^3) + 4S(4,2^2,\
1^2) + 3S(4,2,1^4) + 2S(4,1^6) + 2S(3^3,1) + 2S(3^2,2^2) + 3S(3^2,2,1^2) + 2S(\
3^2,1^4) + 2S(3,2^2,1^3) + 2S(3,1^7) + S(2^3,1^4) + S(2^2,1^6) + S(2,1^8) + S(\
1^10)
</pre></td></tr></table>

<p>Notice that some of the coefficients of the Specht modules in x have changed; this is because <code class="func">IsNewIndecomposable</code> was able to determine that the multiplicity of S(6,3,1) was at most 2 and so it subtracted one copy of P(6,3,1) from x.</p>

<p>In this case, the multiplicity of S(6,3,1) in P(10) is easy to resolve because general theory says that this multiplicity must be odd. Therefore, x-P(6,3,1) is projective. After subtracting P(6,3,1) from x we again use <code class="func">IsNewIndecomposable</code> to see if x is now indecomposable. We can tell <code class="func">IsNewIndecomposable</code> that all of the multiplicities up to and including S(6,3,1) have already been checked by giving it the addition argument mu=[6,3,1].</p>


<table class="example">
<tr><td><pre>
gap&gt; x:=x-MakePIM(d,6,3,1);; IsNewIndecomposable(d,x,6,3,1);
true
</pre></td></tr></table>

<p>Consequently, x=P(10) and we add it to the decomposition matrix d (and save it).</p>


<table class="example">
<tr><td><pre>
gap&gt; AddIndecomposable(d,x); SaveDecompositionMatrix(d);
</pre></td></tr></table>

<p>A full description of what <code class="func">IsNewIndecomposable</code> does can be found by reading the comments in <code class="file">specht.gi</code>. Any suggestions or improvements on this function would be especially welcome.</p>

<p>See also <code class="func">DecompositionMatrix</code> (<a href="chap3.html#X84F0F9E47D5EEBCF"><b>3.2-8</b></a>) and <code class="func">InducedDecompositionMatrix</code> (<a href="chap3.html#X7D257389845738DB"><b>3.5-1</b></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X802E811683E611EE" name="X802E811683E611EE"></a></p>

<h5>3.5-3 InvertDecompositionMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; InvertDecompositionMatrix</code>( <var class="Arg">d</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>inverse of the (e-regular part of) d, where d is a decomposition matrix, or crystallized decomposition matrix, of a Hecke algebra or q-Schur algebra.</p>

<p>If part of the decomposition matrix d is unknown then <code class="func">InvertDecompositionMatrix</code> will invert as much of d as possible.</p>


<table class="example">
<tr><td><pre>
gap&gt; H:=Specht(4);; d:=CrystalDecompositionMatrix(H,5);;
gap&gt; Display(InvertDecompositionMatrix(d));
5    |   1
4,1  |   .   1
3,2  |  -v   .   1
3,1^2|   .   .   .   1
2^2,1| v^2   .  -v   .   1
2,1^3|   .   .   .   .   .   1
</pre></td></tr></table>

<p>See also <code class="func">DecompositionMatrix</code> (<a href="chap3.html#X84F0F9E47D5EEBCF"><b>3.2-8</b></a>) and <code class="func">CrystalDecompositionMatrix</code> (<a href="chap3.html#X7F616CCE808FA11E"><b>3.2-9</b></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X87B18FD97B2D8E80" name="X87B18FD97B2D8E80"></a></p>

<h5>3.5-4 AdjustmentMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; AdjustmentMatrix</code>( <var class="Arg">dp, d</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>the adjustment matrix a</p>

<p>James <a href="chapBib.html#biBJ">[Jam90]</a> noticed and Geck <a href="chapBib.html#biBG">[Gec92]</a> proved, that the decomposition matrices dp for Hecke algebras defined over fields of positive characteristic admit a factorization dp = d * a where d is a decomposition matrix for a suitable Hecke algebra defined over a field of characteristic zero and a is the so-called <em>adjustment matrix</em>.</p>


<table class="example">
<tr><td><pre>
gap&gt; H:=Specht(2);; Hp:=Specht(2,2);;
gap&gt; d:=DecompositionMatrix(H,13);; dp:=DecompositionMatrix(Hp,13);;
gap&gt; a:=AdjustmentMatrix(dp,d);
&lt;18x18 decomposition matrix&gt;
gap&gt; Display(a);
13     | 1
12,1   | . 1
11,2   | 1 . 1
10,3   | . . . 1
10,2,1 | . . . . 1
9,4    | 1 . 1 . . 1
9,3,1  | 2 . . . . . 1
8,5    | . 1 . . . . . 1
8,4,1  | 1 . . . . . . . 1
8,3,2  | . 2 . . . . . 1 . 1
7,6    | 1 . . . . 1 . . . . 1
7,5,1  | . . . . . . 1 . . . . 1
7,4,2  | 1 . 1 . . 1 . . . . 1 . 1
7,3,2,1| . . . . . . . . . . . . . 1
6,5,2  | . 1 . . . . . 1 . 1 . . . . 1
6,4,3  | 2 . . . 1 . . . . . . . . . . 1
6,4,2,1| . 2 . 1 . . . . . . . . . . . . 1
5,4,3,1| 4 . 2 . . . . . . . . . . . . . . 1
gap&gt; MatrixDecompositionMatrix(dp)=
&gt;           MatrixDecompositionMatrix(d)*MatrixDecompositionMatrix(a);
true
</pre></td></tr></table>

<p>In the last line we have checked our calculation.</p>

<p>See also <code class="func">DecompositionMatrix</code> (<a href="chap3.html#X84F0F9E47D5EEBCF"><b>3.2-8</b></a>) and <code class="func">CrystalDecompositionMatrix</code> (<a href="chap3.html#X7F616CCE808FA11E"><b>3.2-9</b></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X78B0FF2079269138" name="X78B0FF2079269138"></a></p>

<h5>3.5-5 SaveDecompositionMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; SaveDecompositionMatrix</code>( <var class="Arg">d</var> )</td><td class="tdright">( method )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; SaveDecompositionMatrix</code>( <var class="Arg">d, filename</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>The function <code class="func">SaveDecompositionMatrix</code> saves the decomposition matrix d. After a decomposition matrix has been saved, the functions <code class="func">MakeSpecht</code> (<a href="chap3.html#X7C92700882971537"><b>3.2-3</b></a>), <code class="func">MakePIM</code> (<a href="chap3.html#X7C92700882971537"><b>3.2-3</b></a>) and <code class="func">MakeSimple</code> (<a href="chap3.html#X7C92700882971537"><b>3.2-3</b></a>) will automatically access it as needed. So, for example, before saving d in order to retrieve the indecomposable P(mu) from d it is necessary to type <code class="code">MakePIM(</code>d, mu<code class="code">)</code>; once d has been saved, the command <code class="code">MakePIM(</code>mu<code class="code">)</code> suffices.</p>

<p>Since <code class="func">InducedDecompositionMatrix</code> (<a href="chap3.html#X7D257389845738DB"><b>3.5-1</b></a>) consults the decomposition matrices for smaller n, if they are available, it is advantageous to save decomposition matrices as they are calculated. For example, over a field of characteristic 5, the decomposition matrices for the symmetric groups S_n with n&lt;= 20 can be calculated as follows:</p>


<table class="example">
<tr><td><pre>
gap&gt; H:=Specht(5,5);;
gap&gt; d:=DecompositionMatrix(H,9);;
gap&gt; for r in [10..20] do
&gt;      d:=InducedDecompositionMatrix(d);
&gt;      SaveDecompositionMatrix(d);
&gt;    od;
# Inducing...
# Inducing....
# Inducing....
# Inducing.....
# Inducing......
# Inducing.......
# Inducing........
# Inducing..........
# Inducing............
# Inducing..............
# Inducing.................
</pre></td></tr></table>

<p>If your Hecke algebra object H is defined using a non-standard valuation map (see <code class="func">Specht</code> (<a href="chap3.html#X7FE26921867C440A"><b>3.2-1</b></a>)) then it is also necessary to set the string HeckeRing, or to supply the function with a filename before it will save your matrix. <code class="func">SaveDecompositionMatrix</code> will also save adjustment matrices and the various other matrices that appear in <strong class="pkg">Hecke</strong> (they can be read back in using <code class="func">DecompositionMatrix</code> (<a href="chap3.html#X84F0F9E47D5EEBCF"><b>3.2-8</b></a>)). Each matrix has a default filename which you can over ride by supplying a filename. Using non-standard file names will stop <strong class="pkg">Hecke</strong> from automatically accessing these matrices in future. See also <code class="func">DecompositionMatrix</code> (<a href="chap3.html#X84F0F9E47D5EEBCF"><b>3.2-8</b></a>) and <code class="func">CrystalDecompositionMatrix</code> (<a href="chap3.html#X7F616CCE808FA11E"><b>3.2-9</b></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X84DD2D517FC1F905" name="X84DD2D517FC1F905"></a></p>

<h5>3.5-6 CalculateDecompositionMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; CalculateDecompositionMatrix</code>( <var class="Arg">H, n</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><code class="func">CalculateDecompositionMatrix</code> is similar to the function <code class="func">DecompositionMatrix</code> (<a href="chap3.html#X84F0F9E47D5EEBCF"><b>3.2-8</b></a>) in that both functions try to return the decomposition matrix d of H(S_n); the difference is that this function tries to calculate this matrix whereas the latter reads the matrix from the library files (in characteristic zero both functions apply the algorithm of <a href="chapBib.html#biBLLT">[LLT96]</a> to compute d). In effect this function is only needed when working with Hecke algebras defined over fields of positive characteristic (or when you wish to avoid the libraries). For example, if you want to do calculations with the decomposition matrix of the symmetric group S_15 over a field of characteristic two, <code class="func">DecompositionMatrix</code> (<a href="chap3.html#X84F0F9E47D5EEBCF"><b>3.2-8</b></a>) returns fail whereas <code class="func">CalculateDecompositionMatrix</code> returns a part of the decomposition matrix.</p>


<table class="example">
<tr><td><pre>
gap&gt; H:=Specht(2,2);; d:=DecompositionMatrix(H,15);
# This decomposition matrix is not known; use CalculateDecompositionMatrix()
# or InducedDecompositionMatrix() to calculate with this matrix.
fail
gap&gt; d:=CalculateDecompositionMatrix(H,15);;
# Projective indecomposable P(6,4,3,2) not known.
# Projective indecomposable P(6,5,3,1) not known.
# Projective indecomposable P(6,5,4) not known.
# Projective indecomposable P(7,4,3,1) not known.
# Projective indecomposable P(7,5,2,1) not known.
# Projective indecomposable P(7,5,3) not known.
# Projective indecomposable P(7,6,2) not known.
# Projective indecomposable P(8,4,2,1) not known.
# Projective indecomposable P(8,4,3) not known.
# Projective indecomposable P(8,5,2) not known.
# Projective indecomposable P(8,6,1) not known.
# Projective indecomposable P(8,7) not known.
# Projective indecomposable P(9,3,2,1) not known.
# Projective indecomposable P(9,4,2) not known.
# Projective indecomposable P(9,5,1) not known.
# Projective indecomposable P(9,6) not known.
# Projective indecomposable P(10,3,2) not known.
# Projective indecomposable P(10,4,1) not known.
# Projective indecomposable P(10,5) not known.
# Projective indecomposable P(11,3,1) not known.
# Projective indecomposable P(11,4) not known.
# Projective indecomposable P(12,2,1) not known.
# Projective indecomposable P(12,3) not known.
# Projective indecomposable P(13,2) not known.
# Projective indecomposable P(14,1) not known.
# Projective indecomposable P(15) not known.
gap&gt; SizeScreen([80,20]);; MissingIndecomposables(d);
The following projectives are missing from &lt;d&gt;:
    [ 15 ]  [ 14, 1 ]  [ 13, 2 ]  [ 12, 3 ]  [ 12, 2, 1 ]  [ 11, 4 ]
[ 11, 3, 1 ]  [ 10, 5 ]  [ 10, 4, 1 ]  [ 10, 3, 2 ]  [ 9, 6 ]  [ 9, 5, 1 ]
[ 9, 4, 2 ]  [ 9, 3, 2, 1 ]  [ 8, 7 ]  [ 8, 6, 1 ]  [ 8, 5, 2 ]  [ 8, 4, 3 ]
[ 8, 4, 2, 1 ]  [ 7, 6, 2 ]  [ 7, 5, 3 ]  [ 7, 5, 2, 1 ]  [ 7, 4, 3, 1 ]
[ 6, 5, 4 ]  [ 6, 5, 3, 1 ]  [ 6, 4, 3, 2 ]
</pre></td></tr></table>

<p>Actually, you are much better starting with the decomposition matrix of S_14 and then applying <code class="func">InducedDecompositionMatrix</code> (<a href="chap3.html#X7D257389845738DB"><b>3.5-1</b></a>) to this matrix. See also <code class="func">DecompositionMatrix</code> (<a href="chap3.html#X84F0F9E47D5EEBCF"><b>3.2-8</b></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X7FDC65328102C1B9" name="X7FDC65328102C1B9"></a></p>

<h5>3.5-7 MatrixDecompositionMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; MatrixDecompositionMatrix</code>( <var class="Arg">d</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>the <strong class="pkg">GAP</strong> matrix corresponding to the <strong class="pkg">Hecke</strong> decomposition matrix d</p>

<p>The rows and columns of d are sorted by the ordering stored in the internal algebra object of the matrix d.</p>


<table class="example">
<tr><td><pre>
gap&gt; SizeScreen([80,20]);;
gap&gt; MatrixDecompositionMatrix(DecompositionMatrix(Specht(3),5));
[ [ 1, 0, 0, 0, 0 ], [ 0, 1, 0, 0, 0 ], [ 0, 1, 1, 0, 0 ], [ 0, 0, 0, 1, 0 ],
  [ 1, 0, 0, 0, 1 ], [ 0, 0, 0, 0, 1 ], [ 0, 0, 1, 0, 0 ] ]
</pre></td></tr></table>

<p>See also <code class="func">DecompositionMatrix</code> (<a href="chap3.html#X84F0F9E47D5EEBCF"><b>3.2-8</b></a>) and <code class="func">DecompositionMatrixMatrix</code> (<a href="chap3.html#X86EBEBF680EBC98E"><b>3.5-8</b></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X86EBEBF680EBC98E" name="X86EBEBF680EBC98E"></a></p>

<h5>3.5-8 DecompositionMatrixMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; DecompositionMatrixMatrix</code>( <var class="Arg">H, m, n</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>the <strong class="pkg">Hecke</strong> decomposition matrix corresponding to the <strong class="pkg">GAP</strong> matrix m</p>

<p>If p is the number of partitions of n and r the number of e-regular partitions of n, then m must be either rx r, px r or px p. The rows and columns of m are assumed to be indexed by partitions sorted by the ordering stored in the algebra object H (see <code class="func">Specht</code> (<a href="chap3.html#X7FE26921867C440A"><b>3.2-1</b></a>)).</p>


<table class="example">
<tr><td><pre>
gap&gt; H:=Specht(3);;
gap&gt; m:=[ [ 1, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 1, 0, 1, 0 ],
&gt;         [ 0, 0, 0, 1 ], [ 0, 0, 1, 0 ] ];;
gap&gt; Display(DecompositionMatrixMatrix(H,m,4));
4    | 1
3,1  | . 1
2^2  | 1 . 1
2,1^2| . . . 1
1^4  | . . 1 .
</pre></td></tr></table>

<p>See also <code class="func">DecompositionMatrix</code> (<a href="chap3.html#X84F0F9E47D5EEBCF"><b>3.2-8</b></a>) and <code class="func">MatrixDecompositionMatrix</code> (<a href="chap3.html#X7FDC65328102C1B9"><b>3.5-7</b></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X7B05627D83E6977E" name="X7B05627D83E6977E"></a></p>

<h5>3.5-9 AddIndecomposable</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; AddIndecomposable</code>( <var class="Arg">d, x</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><code class="func">AddIndecomposable</code> inserts the indecomposable module x into the decomposition matrix d. If d already contains the indecomposable d then a warning is printed. The function <code class="func">AddIndecomposable</code> also calculates <code class="code">MullineuxMap(</code> x<code class="code">)</code> (see <code class="func">MullineuxMap</code> (<a href="chap3.html#X7A6262B684185E3D"><b>3.7-3</b></a>)) and adds this indecomposable to d (or checks to see that it agrees with the corresponding entry of d if this indecomposable is already in d).</p>

<p>See <code class="func">IsNewIndecomposable</code> (<a href="chap3.html#X803A99987E501AC9"><b>3.5-2</b></a>) for an example. See also <code class="func">DecompositionMatrix</code> (<a href="chap3.html#X84F0F9E47D5EEBCF"><b>3.2-8</b></a>) and <code class="func">CrystalDecompositionMatrix</code> (<a href="chap3.html#X7F616CCE808FA11E"><b>3.2-9</b></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X79FA055E8250E6A2" name="X79FA055E8250E6A2"></a></p>

<h5>3.5-10 RemoveIndecomposable</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; RemoveIndecomposable</code>( <var class="Arg">d, mu</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>The function <code class="func">RemoveIndecomposable</code> removes the column from d which corresponds to P(mu). This is sometimes useful when trying to calculate a new decomposition matrix using <strong class="pkg">Hecke</strong> and want to test a possible candidate for a yet to be identified PIM.</p>

<p>See also <code class="func">DecompositionMatrix</code> (<a href="chap3.html#X84F0F9E47D5EEBCF"><b>3.2-8</b></a>) and <code class="func">CrystalDecompositionMatrix</code> (<a href="chap3.html#X7F616CCE808FA11E"><b>3.2-9</b></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X8434DC7C8364CB54" name="X8434DC7C8364CB54"></a></p>

<h5>3.5-11 MissingIndecomposables</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; MissingIndecomposables</code>( <var class="Arg">d</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>The function <code class="func">MissingIndecomposables</code> prints the list of partitions corresponding to the indecomposable modules which are not listed in d.</p>

<p>See also <code class="func">DecompositionMatrix</code> (<a href="chap3.html#X84F0F9E47D5EEBCF"><b>3.2-8</b></a>) and <code class="func">CrystalDecompositionMatrix</code> (<a href="chap3.html#X7F616CCE808FA11E"><b>3.2-9</b></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X7A697AAA799BA7D4" name="X7A697AAA799BA7D4"></a></p>

<h4>3.6 <span class="Heading">Calculating dimensions</span></h4>

<p><strong class="pkg">Hecke</strong> has two functions for calculating the dimensions of modules of Hecke algebras; <code class="func">SimpleDimension</code> (<a href="chap3.html#X828528747E4AC4C9"><b>3.6-1</b></a>) and <code class="func">SpechtDimension</code> (<a href="chap3.html#X7B98631580E193BB"><b>3.6-2</b></a>). As yet, <strong class="pkg">Hecke</strong> does not know how to calculate the dimensions of modules for q-Schur algebras (these depend up on q).</p>

<p><a id="X828528747E4AC4C9" name="X828528747E4AC4C9"></a></p>

<h5>3.6-1 SimpleDimension</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; SimpleDimension</code>( <var class="Arg">d</var> )</td><td class="tdright">( method )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; SimpleDimension</code>( <var class="Arg">H, n</var> )</td><td class="tdright">( method )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; SimpleDimension</code>( <var class="Arg">H|d, mu</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>In the first two forms, <code class="func">SimpleDimension</code> prints the dimensions of all of the simple modules specified by d or for the Hecke algebra H(S_n) respectively. If a partition mu is supplied, as in the last form, then the dimension of the simple module D(mu) is returned. At present the function is not implemented for the simple modules of the q-Schur algebras.</p>


<table class="example">
<tr><td><pre>
gap&gt; H:=Specht(6);;
gap&gt; SimpleDimension(H,11,3);
272
gap&gt; d:=DecompositionMatrix(H,5);; SimpleDimension(d,3,2);
5
gap&gt; SimpleDimension(d);
5     : 1
4,1   : 4
3,2   : 5
3,1^2 : 6
2^2,1 : 5
2,1^3 : 4
1^5   : 1
true
</pre></td></tr></table>

<p>This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X7B98631580E193BB" name="X7B98631580E193BB"></a></p>

<h5>3.6-2 SpechtDimension</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; SpechtDimension</code>( <var class="Arg">mu</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>the dimension of the Specht module S(mu)</p>

<p>dim S(mu) is equal to the number of standard mu-tableaux; the answer is given by the hook length formula (see <a href="chapBib.html#biBJK">[JK81]</a>).</p>


<table class="example">
<tr><td><pre>
gap&gt; SpechtDimension(6,3,2,1);
5632
</pre></td></tr></table>

<p>See also <code class="func">SimpleDimension</code> (<a href="chap3.html#X828528747E4AC4C9"><b>3.6-1</b></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X78F1DC277875BAFD" name="X78F1DC277875BAFD"></a></p>

<h4>3.7 <span class="Heading">Combinatorics on Young diagrams</span></h4>

<p>These functions range from the representation theoretic q-Schaper theorem and Kleshchev's algorithm for the Mullineux map through to simple combinatorial operations like adding and removing rim hooks from Young diagrams.</p>

<p><a id="X820A908F8337F59C" name="X820A908F8337F59C"></a></p>

<h5>3.7-1 Schaper</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; Schaper</code>( <var class="Arg">H, mu</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>a linear combination of Specht modules which have the same composition factors as the sum of the modules in the "Jantzen filtration " of S(mu); see <a href="chapBib.html#biBJM2">[JM97]</a>. In particular, if nu strictly dominates mu then D(nu) is a composition factor of S(mu) if and only if it is a composition factor of <code class="code">Schaper(</code>mu<code class="code">)</code>.</p>

<p><code class="func">Schaper</code> uses the valuation map attached to H (see <code class="func">Specht</code> (<a href="chap3.html#X7FE26921867C440A"><b>3.2-1</b></a>) and <a href="chapBib.html#biBJM2">[JM97]</a>).</p>

<p>One way in which the q-Schaper theorem can be applied is as follows. Suppose that we have a projective module x, written as a linear combination of Specht modules and suppose that we are trying to decide whether the projective indecomposable P(mu) is a direct summand of x. Then, providing that we know that P(nu) is not a summand of x for all (e-regular) partitions nu which strictly dominate mu (see <code class="func">Dominates</code> (<a href="chap3.html#X820388EF7C8333BA"><b>3.8-12</b></a>)), P(mu) is a summand of x if and only if <code class="code">InnerProduct(Schaper( </code>H,mu<code class="code">)</code>,x<code class="code">)</code> is non-zero (note, in particular, that we don't need to know the indecomposable P(mu) in order to perform this calculation).</p>

<p>The q-Schaper theorem can also be used to check for irreduciblity; in fact, this is the basis for the criterion employed by <code class="func">IsSimpleModule</code> (<a href="chap3.html#X7FB82B3184287362"><b>3.7-2</b></a>).</p>


<table class="example">
<tr><td><pre>
gap&gt; SizeScreen([80,20]);; H:=Specht(2);;
gap&gt; Display(Schaper(H,9,5,3,2,1));
S(17,2,1) - S(15,2,1^3) + S(13,2^3,1) - S(11,3^2,2,1) + S(10,4,3,2,1) - S(9,8,\
3) - S(9,8,1^3) + S(9,6,3,2) + S(9,6,3,1^2) + S(9,6,2^2,1)
gap&gt; Display(Schaper(H,9,6,5,2));
0S()
</pre></td></tr></table>

<p>The last calculation shows that S(9,6,5,2) is irreducible when R is a field of characteristic zero and e=2 (cf. <code class="code">IsSimpleModule(</code>H,9,6,5,2<code class="code">)</code>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X7FB82B3184287362" name="X7FB82B3184287362"></a></p>

<h5>3.7-2 IsSimpleModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsSimpleModule</code>( <var class="Arg">H, mu</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b><code class="keyw">true</code> if S(mu) is simple and <code class="keyw">false</code> otherwise.</p>

<p>mu an e-regular partition.</p>

<p>This calculation uses the valuation function of H; see <code class="func">Specht</code> (<a href="chap3.html#X7FE26921867C440A"><b>3.2-1</b></a>). Note that the criterion used by <code class="func">IsSimpleModule</code> is completely combinatorial; it is derived from the q-Schaper theorem <a href="chapBib.html#biBJM2">[JM97]</a>.</p>


<table class="example">
<tr><td><pre>
gap&gt; H:=Specht(3);;
gap&gt; IsSimpleModule(H,45,31,24);
false
</pre></td></tr></table>

<p>See also <code class="func">Schaper</code> (<a href="chap3.html#X820A908F8337F59C"><b>3.7-1</b></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X7A6262B684185E3D" name="X7A6262B684185E3D"></a></p>

<h5>3.7-3 MullineuxMap</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; MullineuxMap</code>( <var class="Arg">e|H, mu</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>The sign representation D(1^n) of the Hecke algebra is the (one dimensional) representation sending T_w to (-1)^l(w). The Hecke algebra H is not a Hopf algebra so there is no well defined action of H upon the tensor product of two H-modules; however, there is an outer automorphism # of H which corresponds to tensoring with D(1^n). This sends an irreducible module D(mu) to an irreducible D(mu)^#cong D(mu^#) for some e-regular partition mu^#. In the symmetric group case, Mullineux gave a conjectural algorithm for calculating mu^#; consequently the map sending mu to mu^# is known as the <em>Mullineux map</em>.</p>

<p>Deep results of Kleshchev <a href="chapBib.html#biBK">[Kle96]</a> for the symmetric group give another (proven) algorithm for calculating the partition mu^# (Ford and Kleshchev have deduced Mullineux's conjecture from this). Using the canonical basis, it was shown by <a href="chapBib.html#biBLLT">[LLT96]</a> that the natural generalization of Kleshchev's algorithm to H gives the Mullineux map for Hecke algebras over fields of characteristic zero. The general case follows from this, so the Mullineux map is now known for all Hecke algebras.</p>

<p>Kleshchev's map is easy to describe; he proved that if gns is any good node sequence for mu, then the sequence obtained from gns by replacing each residue r by -rmod e is a good node sequence for mu^# (see <code class="func">GoodNodeSequence</code> (<a href="chap3.html#X85B290977A17D9EE"><b>3.7-8</b></a>)).</p>


<table class="example">
<tr><td><pre>
gap&gt; MullineuxMap(Specht(2),12,5,2);
[ 12, 5, 2 ]
gap&gt; MullineuxMap(Specht(4),12,5,2);
[ 4, 4, 4, 2, 2, 1, 1, 1 ]
gap&gt; MullineuxMap(Specht(6),12,5,2);
[ 4, 3, 2, 2, 2, 2, 2, 1, 1 ]
gap&gt; MullineuxMap(Specht(8),12,5,2);
[ 3, 3, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1 ]
gap&gt; MullineuxMap(Specht(10),12,5,2);
[ 3, 3, 3, 3, 2, 1, 1, 1, 1, 1 ]
</pre></td></tr></table>

<p><b>Returns: </b>the image of mu under the Mullineux map</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; MullineuxMap</code>( <var class="Arg">d, mu</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>The Mullineux map can also be calculated using a decomposition matrix. To see this recall that "tensoring" a Specht module S(mu) with the sign representation yields a module isomorphic to the dual of S(lambda), where lambda is the partition conjugate to mu. It follows that d_mu,nu=d_lambda,nu^# for all e-regular partitions nu. Therefore, if mu is the last partition in the lexicographic order such that d_mu,nu&lt;&gt; 0 then we must have nu^#=lambda. The second form of <code class="func">MullineuxMap</code> uses d to calculate mu^# rather than the Kleshchev-<a href="chapBib.html#biBLLT">[LLT96]</a> result.</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; MullineuxMap</code>( <var class="Arg">x</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>returns x^#, the image of x under #.</p>

<p>Note that the above remarks show that P(mu) is mapped to P(mu^#) via the Mullineux map; this observation is useful when calculating decomposition matrices (and is used by the function <code class="func">InducedDecompositionMatrix</code> (<a href="chap3.html#X7D257389845738DB"><b>3.5-1</b></a>)).</p>

<p>See also <code class="func">GoodNodes</code> (<a href="chap3.html#X7CE4D6487FD009B1"><b>3.7-6</b></a>) and <code class="func">GoodNodeSequence</code> (<a href="chap3.html#X85B290977A17D9EE"><b>3.7-8</b></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X7CC6C04482DD1E9D" name="X7CC6C04482DD1E9D"></a></p>

<h5>3.7-4 MullineuxSymbol</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; MullineuxSymbol</code>( <var class="Arg">e|H, mu</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>the Mullineux symbol of the e-regular partition mu.</p>


<table class="example">
<tr><td><pre>
gap&gt; MullineuxSymbol(5,[8,6,5,5]);
[ [ 10, 6, 5, 3 ], [ 4, 4, 3, 2 ] ]
</pre></td></tr></table>

<p>See also <code class="func">PartitionMullineuxSymbol</code> (<a href="chap3.html#X7826922879DD8D8A"><b>3.7-5</b></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X7826922879DD8D8A" name="X7826922879DD8D8A"></a></p>

<h5>3.7-5 PartitionMullineuxSymbol</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; PartitionMullineuxSymbol</code>( <var class="Arg">e|H, ms</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>the e-regular partition corresponding to the given Mullineux symbol ms</p>


<table class="example">
<tr><td><pre>
gap&gt; PartitionMullineuxSymbol(5, MullineuxSymbol(5,[8,6,5,5]) );
[ 8, 6, 5, 5 ]
</pre></td></tr></table>

<p>See also <code class="func">MullineuxSymbol</code> (<a href="chap3.html#X7CC6C04482DD1E9D"><b>3.7-4</b></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X7CE4D6487FD009B1" name="X7CE4D6487FD009B1"></a></p>

<h5>3.7-6 GoodNodes</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; GoodNodes</code>( <var class="Arg">e|H, mu</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>a list of the rows of mu which end in a good node. The good node of residue r (if it exists) is the (r+1)-st element in this list.</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; GoodNodes</code>( <var class="Arg">e|H, mu, r</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>the number of the row which ends with the good node of residue r or <code class="keyw">fail</code> if there is no good node of residue r.</p>

<p>Given a partition and an integer e, Kleshchev [K] defined the notion of <em>good node</em> for each residue r (0&lt;= r&lt;e). When e is prime and mu is e-regular, Kleshchev showed that the good nodes describe the restriction of the socle of D(mu) in the symmetric group case. Brundan <a href="chapBib.html#biBB">[Bru98]</a> has recently generalized this result to the Hecke algebra.</p>

<p>By definition, there is at most one good node for each residue r and this node is a removable node (in the diagram of mu).</p>


<table class="example">
<tr><td><pre>
gap&gt; GoodNodes(5,[5,4,3,2]);
[ fail, fail, 2, fail, 1 ]
gap&gt; GoodNodes(5,[5,4,3,2],0);
fail
gap&gt; GoodNodes(5,[5,4,3,2],4);
1
</pre></td></tr></table>

<p>The good nodes also determine the Kleshchev-Mullineux map (see <code class="func">GoodNodeSequence</code> (<a href="chap3.html#X85B290977A17D9EE"><b>3.7-8</b></a>) and <code class="func">MullineuxMap</code> (<a href="chap3.html#X7A6262B684185E3D"><b>3.7-3</b></a>)). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X783B52458335975F" name="X783B52458335975F"></a></p>

<h5>3.7-7 NormalNodes</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; NormalNodes</code>( <var class="Arg">e|H, mu</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>the numbers of the rows of mu which end in one of Kleshchev's <a href="chapBib.html#biBK">[Kle96]</a> normal nodes.</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; NormalNodes</code>( <var class="Arg">e|H, mu, r</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>the rows corresponding to normal nodes of the specified residue.</p>


<table class="example">
<tr><td><pre>
gap&gt; NormalNodes(5,[6,5,4,4,3,2,1,1,1]);
[ [ 1, 4 ], [  ], [  ], [ 2, 5 ], [  ] ]
gap&gt; NormalNodes(5,[6,5,4,4,3,2,1,1,1],0);
[ 1, 4 ]
</pre></td></tr></table>

<p>See also <code class="func">GoodNodes</code> (<a href="chap3.html#X7CE4D6487FD009B1"><b>3.7-6</b></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X85B290977A17D9EE" name="X85B290977A17D9EE"></a></p>

<h5>3.7-8 GoodNodeSequence</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; GoodNodeSequence</code>( <var class="Arg">e|H, mu</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Given an e-regular partition mu of n, a <em>good node sequence</em> for mu is a sequence gns of n residues such that mu has a good node of residue r, where r is the last residue in gns and the first n-1 residues in gns are a good node sequence for the partition obtained from mu by deleting its (unique) good node with residue r (see <code class="func">GoodNodes</code> (<a href="chap3.html#X7CE4D6487FD009B1"><b>3.7-6</b></a>)). In general, mu will have more than one good node sequence; however, any good node sequence uniquely determines mu (see <code class="func">PartitionGoodNodeSequence</code> (<a href="chap3.html#X7B704FE781A311E5"><b>3.7-9</b></a>)).</p>


<table class="example">
<tr><td><pre>
gap&gt; H:=Specht(4);; GoodNodeSequence(H,4,3,1);
[ 0, 3, 1, 0, 2, 2, 1, 3 ]
gap&gt; GoodNodeSequence(H,4,3,2);
[ 0, 3, 1, 0, 2, 2, 1, 3, 3 ]
gap&gt; GoodNodeSequence(H,4,4,2);
[ 0, 3, 1, 0, 2, 2, 1, 3, 3, 2 ]
gap&gt; GoodNodeSequence(H,5,4,2);
[ 0, 3, 1, 0, 2, 2, 1, 3, 3, 2, 0 ]
</pre></td></tr></table>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; GoodNodeSequences</code>( <var class="Arg">e|H, mu</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>list of all good node sequences for mu</p>


<table class="example">
<tr><td><pre>
gap&gt; H:=Specht(4);; GoodNodeSequences(H,5,2,1);
[ [ 0, 1, 2, 3, 3, 2, 0, 0 ], [ 0, 3, 1, 2, 2, 3, 0, 0 ],
  [ 0, 1, 3, 2, 2, 3, 0, 0 ], [ 0, 1, 2, 3, 3, 0, 2, 0 ],
  [ 0, 1, 2, 3, 0, 3, 2, 0 ], [ 0, 1, 2, 3, 3, 0, 0, 2 ],
  [ 0, 1, 2, 3, 0, 3, 0, 2 ] ]
</pre></td></tr></table>

<p>The good node sequences determine the Mullineux map (see <code class="func">GoodNodes</code> (<a href="chap3.html#X7CE4D6487FD009B1"><b>3.7-6</b></a>) and <code class="func">MullineuxMap</code> (<a href="chap3.html#X7A6262B684185E3D"><b>3.7-3</b></a>)). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X7B704FE781A311E5" name="X7B704FE781A311E5"></a></p>

<h5>3.7-9 PartitionGoodNodeSequence</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; PartitionGoodNodeSequence</code>( <var class="Arg">e|H, gns</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>the unique e-regular partition corresponding to gns (or <code class="keyw">fail</code> if in fact gns is not a good node sequence).</p>


<table class="example">
<tr><td><pre>
gap&gt; H:=Specht(4);;
gap&gt; PartitionGoodNodeSequence(H,0, 3, 1, 0, 2, 2, 1, 3, 3, 2);
[ 4, 4, 2 ]
</pre></td></tr></table>

<p>See also <code class="func">GoodNodes</code> (<a href="chap3.html#X7CE4D6487FD009B1"><b>3.7-6</b></a>), <code class="func">GoodNodeSequence</code> (<a href="chap3.html#X85B290977A17D9EE"><b>3.7-8</b></a>) and <code class="func">MullineuxMap</code> (<a href="chap3.html#X7A6262B684185E3D"><b>3.7-3</b></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X7A9DC101850008A2" name="X7A9DC101850008A2"></a></p>

<h5>3.7-10 GoodNodeLatticePath</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; GoodNodeLatticePath</code>( <var class="Arg">e|H, mu</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>a sequence of partitions which give a path in the e-good partition lattice from the empty partition to mu.</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; GoodNodeLatticePaths</code>( <var class="Arg">e|H, mu</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>the list of all paths in the e-good partition lattice which end in mu.</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; LatticePathGoodNodeSequence</code>( <var class="Arg">e|H, gns</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>the path corresponding to a given good node sequence gns</p>


<table class="example">
<tr><td><pre>
gap&gt; GoodNodeLatticePath(3,3,2,1);
[ [ 1 ], [ 1, 1 ], [ 2, 1 ], [ 2, 1, 1 ], [ 2, 2, 1 ], [ 3, 2, 1 ] ]
gap&gt; GoodNodeLatticePaths(3,3,2,1);
[ [ [ 1 ], [ 1, 1 ], [ 2, 1 ], [ 2, 1, 1 ], [ 2, 2, 1 ], [ 3, 2, 1 ] ],
  [ [ 1 ], [ 1, 1 ], [ 2, 1 ], [ 2, 2 ], [ 2, 2, 1 ], [ 3, 2, 1 ] ] ]
gap&gt; GoodNodeSequence(4,6,3,2);
[ 0, 3, 1, 0, 2, 2, 3, 3, 0, 1, 1 ]
gap&gt; LatticePathGoodNodeSequence(4,last);
[ [ 1 ], [ 1, 1 ], [ 2, 1 ], [ 2, 2 ], [ 3, 2 ], [ 3, 2, 1 ], [ 4, 2, 1 ],
  [ 4, 2, 2 ], [ 5, 2, 2 ], [ 6, 2, 2 ], [ 6, 3, 2 ] ]
</pre></td></tr></table>

<p>See also <code class="func">GoodNodes</code> (<a href="chap3.html#X7CE4D6487FD009B1"><b>3.7-6</b></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X7918D9DE7ACE2294" name="X7918D9DE7ACE2294"></a></p>

<h5>3.7-11 LittlewoodRichardsonRule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; LittlewoodRichardsonRule</code>( <var class="Arg">mu, nu</var> )</td><td class="tdright">( method )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; LittlewoodRichardsonCoefficient</code>( <var class="Arg">mu, nu, tau</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Given partitions mu of n and nu of m the module S(mu)otimes S(nu) is naturally an H(S_nx S_m)- module and, by inducing, we obtain an H(S_n+m)-module. This module has the same composition factors as sum_nu a_mu,nu^lambda S(lambda), where the sum runs over all partitions lambda of n+m and the integers a_mu,nu^lambda are the Littlewood-Richardson coefficients. The integers a_mu,nu^lambda can be calculated using a straightforward combinatorial algorithm known as the Littlewood-Richardson rule (see <a href="chapBib.html#biBJK">[JK81]</a>). The function <code class="func">LittlewoodRichardsonRule</code> returns an (unordered) list of partitions of n+m in which each partition lambda occurs a_mu,nu^lambda times. The Littlewood-Richardson coefficients are independent of e; they can be read more easily from the computation S(mu)otimes S(nu).</p>


<table class="example">
<tr><td><pre>
gap&gt; SizeScreen([80,20]);;
gap&gt; H:=Specht(0);; # the generic Hecke algebra with R=C[q]
gap&gt; LittlewoodRichardsonRule([3,2,1],[4,2]);
[ [ 4, 3, 2, 2, 1 ], [ 4, 3, 3, 1, 1 ], [ 4, 3, 3, 2 ], [ 4, 4, 2, 1, 1 ],
  [ 4, 4, 2, 2 ], [ 4, 4, 3, 1 ], [ 5, 2, 2, 2, 1 ], [ 5, 3, 2, 1, 1 ],
  [ 5, 3, 2, 2 ], [ 5, 4, 2, 1 ], [ 5, 3, 2, 1, 1 ], [ 5, 3, 3, 1 ],
  [ 5, 4, 1, 1, 1 ], [ 5, 4, 2, 1 ], [ 5, 5, 1, 1 ], [ 5, 3, 2, 2 ],
  [ 5, 3, 3, 1 ], [ 5, 4, 2, 1 ], [ 5, 4, 3 ], [ 5, 5, 2 ], [ 6, 2, 2, 1, 1 ],
  [ 6, 3, 1, 1, 1 ], [ 6, 3, 2, 1 ], [ 6, 4, 1, 1 ], [ 6, 2, 2, 2 ],
  [ 6, 3, 2, 1 ], [ 6, 4, 2 ], [ 6, 3, 2, 1 ], [ 6, 3, 3 ], [ 6, 4, 1, 1 ],
  [ 6, 4, 2 ], [ 6, 5, 1 ], [ 7, 2, 2, 1 ], [ 7, 3, 1, 1 ], [ 7, 3, 2 ],
  [ 7, 4, 1 ] ]
gap&gt; Display(MakeSpecht(H,3,2,1)*MakeSpecht(H,4,2));
S(7,4,1) + S(7,3,2) + S(7,3,1^2) + S(7,2^2,1) + S(6,5,1) + 2S(6,4,2) + 2S(6,4,\
1^2) + S(6,3^2) + 3S(6,3,2,1) + S(6,3,1^3) + S(6,2^3) + S(6,2^2,1^2) + S(5^2,2\
) + S(5^2,1^2) + S(5,4,3) + 3S(5,4,2,1) + S(5,4,1^3) + 2S(5,3^2,1) + 2S(5,3,2^\
2) + 2S(5,3,2,1^2) + S(5,2^3,1) + S(4^2,3,1) + S(4^2,2^2) + S(4^2,2,1^2) + S(4\
,3^2,2) + S(4,3^2,1^2) + S(4,3,2^2,1)
gap&gt; LittlewoodRichardsonCoefficient([3,2,1],[4,2],[5,4,2,1]);
3
</pre></td></tr></table>

<p>The function <code class="func">LittlewoodRichardsonCoefficient</code> returns a single Littlewood-Richardson coefficient (although you are really better off asking for all of them, since they will all be calculated anyway).</p>

<p>See also <code class="func">RInducedModule</code> (<a href="chap3.html#X81D7F7A4812BB04D"><b>3.4-1</b></a>) and <code class="func">InverseLittlewoodRichardsonRule</code> (<a href="chap3.html#X7B9901427D1CF6F4"><b>3.7-12</b></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X7B9901427D1CF6F4" name="X7B9901427D1CF6F4"></a></p>

<h5>3.7-12 InverseLittlewoodRichardsonRule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; InverseLittlewoodRichardsonRule</code>( <var class="Arg">tau</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>a list of all pairs of partitions [mu,nu] such that the Littlewood-Richardson coefficient a_mu,nu^tau is non-zero (see <code class="func">LittlewoodRichardsonRule</code> (<a href="chap3.html#X7918D9DE7ACE2294"><b>3.7-11</b></a>)). The list returned is unordered and [mu,nu] will appear a_mu,nu^tau times in it.</p>


<table class="example">
<tr><td><pre>
gap&gt; SizeScreen([80,20]);; InverseLittlewoodRichardsonRule(3,2,1);
[ [ [  ], [ 3, 2, 1 ] ], [ [ 1 ], [ 3, 2 ] ], [ [ 1 ], [ 2, 2, 1 ] ],
  [ [ 1 ], [ 3, 1, 1 ] ], [ [ 1, 1 ], [ 2, 2 ] ], [ [ 1, 1 ], [ 3, 1 ] ],
  [ [ 1, 1 ], [ 2, 1, 1 ] ], [ [ 1, 1, 1 ], [ 2, 1 ] ], [ [ 2 ], [ 2, 2 ] ],
  [ [ 2 ], [ 3, 1 ] ], [ [ 2 ], [ 2, 1, 1 ] ], [ [ 2, 1 ], [ 3 ] ],
  [ [ 2, 1 ], [ 2, 1 ] ], [ [ 2, 1 ], [ 2, 1 ] ], [ [ 2, 1 ], [ 1, 1, 1 ] ],
  [ [ 2, 1, 1 ], [ 2 ] ], [ [ 2, 1, 1 ], [ 1, 1 ] ], [ [ 2, 2 ], [ 2 ] ],
  [ [ 2, 2 ], [ 1, 1 ] ], [ [ 2, 2, 1 ], [ 1 ] ], [ [ 3 ], [ 2, 1 ] ],
  [ [ 3, 1 ], [ 2 ] ], [ [ 3, 1 ], [ 1, 1 ] ], [ [ 3, 1, 1 ], [ 1 ] ],
  [ [ 3, 2 ], [ 1 ] ], [ [ 3, 2, 1 ], [  ] ] ]
</pre></td></tr></table>

<p>See also <code class="func">LittlewoodRichardsonRule</code> (<a href="chap3.html#X7918D9DE7ACE2294"><b>3.7-11</b></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X790D4ACF7930340F" name="X790D4ACF7930340F"></a></p>

<h5>3.7-13 EResidueDiagram</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; EResidueDiagram</code>( <var class="Arg">H|e, mu</var> )</td><td class="tdright">( method )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; EResidueDiagram</code>( <var class="Arg">x</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>The e-residue of the (i,j)-th node in the diagram of a partition mu is (j-i)mod e. <code class="code">EResidueDiagram(</code>e, mu<code class="code">)</code> prints the diagram of the partition mu replacing each node with its e-residue. If x is a module then <code class="code">EResidueDiagram(</code>x<code class="code">)</code> prints the e-residue diagrams of all of the e-regular partitions appearing in x (such diagrams are useful when trying to decide how to restrict and induce modules and also in applying results such as the "Scattering theorem" of <a href="chapBib.html#biBJM1">[JM96]</a>). It is not necessary to supply the integer e in this case because x "knows" the value of e.</p>


<table class="example">
<tr><td><pre>
gap&gt; H:=Specht(2);; EResidueDiagram(MakeSpecht(MakePIM(H,7,5)));
[ 7, 5 ]
   0   1   0   1   0   1   0
   1   0   1   0   1
[ 6, 5, 1 ]
   0   1   0   1   0   1
   1   0   1   0   1
   0
[ 5, 4, 2, 1 ]
   0   1   0   1   0
   1   0   1   0
   0   1
   1
# There are 3 2-regular partitions.
true
</pre></td></tr></table>

<p>This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X7DE3773C78BC324C" name="X7DE3773C78BC324C"></a></p>

<h5>3.7-14 HookLengthDiagram</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; HookLengthDiagram</code>( <var class="Arg">mu</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Prints the diagram of mu, replacing each node with its hook length (see <a href="chapBib.html#biBJK">[JK81]</a>).</p>


<table class="example">
<tr><td><pre>
gap&gt; HookLengthDiagram(11,6,3,2);
  14  13  11   9   8   7   5   4   3   2   1
   8   7   5   3   2   1
   4   3   1
   2   1
true
</pre></td></tr></table>

<p>This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X7F2ACCBF788A62E8" name="X7F2ACCBF788A62E8"></a></p>

<h5>3.7-15 RemoveRimHook</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; RemoveRimHook</code>( <var class="Arg">mu, row, col</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>the partition obtained from mu by removing the (row, col)-th rim hook from (the diagram of) mu.</p>


<table class="example">
<tr><td><pre>
gap&gt; RemoveRimHook([6,5,4],1,2);
[ 4, 3, 1 ]
gap&gt; RemoveRimHook([6,5,4],2,3);
[ 6, 3, 2 ]
gap&gt; HookLengthDiagram(6,5,4);
   8   7   6   5   3   1
   6   5   4   3   1
   4   3   2   1
true
</pre></td></tr></table>

<p>See also <code class="func">AddRimHook</code> (<a href="chap3.html#X7CEA98C779BDBD1A"><b>3.7-16</b></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X7CEA98C779BDBD1A" name="X7CEA98C779BDBD1A"></a></p>

<h5>3.7-16 AddRimHook</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; AddRimHook</code>( <var class="Arg">mu, r, h</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>a list [nu, l] where nu is the partition obtained from mu by adding a rim hook of length h with its "foot" in the r-th row of (the diagram of) mu and l is the leg length of the wrapped on rim hook (see, for example, <a href="chapBib.html#biBJK">[JK81]</a>). If the resulting diagram nu is not the diagram of a partition then <code class="keyw">fail</code> is returned.</p>


<table class="example">
<tr><td><pre>
gap&gt; AddRimHook([6,4,3],1,3);
[ [ 9, 4, 3 ], 0 ]
gap&gt; AddRimHook([6,4,3],2,3);
fail
gap&gt; AddRimHook([6,4,3],3,3);
[ [ 6, 5, 5 ], 1 ]
gap&gt; AddRimHook([6,4,3],4,3);
[ [ 6, 4, 3, 3 ], 0 ]
gap&gt; AddRimHook([6,4,3],5,3);
fail
</pre></td></tr></table>

<p>See also <code class="func">RemoveRimHook</code> (<a href="chap3.html#X7F2ACCBF788A62E8"><b>3.7-15</b></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X8350934A7F9AB5BE" name="X8350934A7F9AB5BE"></a></p>

<h4>3.8 <span class="Heading">Operations on partitions</span></h4>

<p>This section contains functions for manipulating partitions and also several useful orderings on the set of partitions.</p>

<p><a id="X867496487DC35776" name="X867496487DC35776"></a></p>

<h5>3.8-1 ECore</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ECore</code>( <var class="Arg">e|H, mu</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>the e-core of the partition mu.</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; EAbacus</code>( <var class="Arg">e|H, mu</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>The e-core of a partition mu is what remains after as many rim e-hooks as possible have been removed from the diagram of mu (that this is well defined is not obvious; see <a href="chapBib.html#biBJK">[JK81]</a>).</p>


<table class="example">
<tr><td><pre>
gap&gt; H:=Specht(6);; ECore(H,16,8,6,5,3,1);
[ 4, 3, 1, 1 ]
</pre></td></tr></table>

<p>The e-core is calculated here using James'; notation of an <em>abacus</em> there is also an <code class="func">EAbacus</code> function; but it is more "pretty" than useful.</p>

<p>See also <code class="func">IsECore</code> (<a href="chap3.html#X8236220C87814790"><b>3.8-2</b></a>), <code class="func">EQuotient</code> (<a href="chap3.html#X8538AAAF8628A725"><b>3.8-3</b></a>) and <code class="func">EWeight</code> (<a href="chap3.html#X7C460635829E7ED0"><b>3.8-5</b></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X8236220C87814790" name="X8236220C87814790"></a></p>

<h5>3.8-2 IsECore</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsECore</code>( <var class="Arg">e|H, mu</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b><code class="keyw">true</code> if mu is an e-core and <code class="keyw">false</code> otherwise.</p>

<p>See also <code class="func">ECore</code> (<a href="chap3.html#X867496487DC35776"><b>3.8-1</b></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X8538AAAF8628A725" name="X8538AAAF8628A725"></a></p>

<h5>3.8-3 EQuotient</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; EQuotient</code>( <var class="Arg">e|H, mu</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>the e-quotient of mu; this is a sequence of e partitions whose definition can be found in <a href="chapBib.html#biBJK">[JK81]</a>.</p>


<table class="example">
<tr><td><pre>
gap&gt; H:=Specht(8);; EQuotient(H,22,18,16,12,12,1,1);
[ [ 1, 1 ], [  ], [  ], [  ], [  ], [ 2, 2 ], [  ], [ 1 ] ]
</pre></td></tr></table>

<p>See also <code class="func">ECore</code> (<a href="chap3.html#X867496487DC35776"><b>3.8-1</b></a>) and <code class="func">CombineEQuotientECore</code> (<a href="chap3.html#X7F357B417D495B6F"><b>3.8-4</b></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X7F357B417D495B6F" name="X7F357B417D495B6F"></a></p>

<h5>3.8-4 CombineEQuotientECore</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; CombineEQuotientECore</code>( <var class="Arg">e|H, q, C</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>the partition which has e-quotient q and e -core C.</p>

<p>A partition is uniquely determined by its e-quotient and its e -core (see <code class="func">EQuotient</code> (<a href="chap3.html#X8538AAAF8628A725"><b>3.8-3</b></a>) and <code class="func">ECore</code> (<a href="chap3.html#X867496487DC35776"><b>3.8-1</b></a>)).</p>


<table class="example">
<tr><td><pre>
gap&gt; H:=Specht(11);; mu:=[100,98,57,43,12,1];;
gap&gt; Q:=EQuotient(H,mu);
[ [ 9 ], [  ], [  ], [  ], [  ], [  ], [ 3 ], [ 1 ], [ 9 ], [  ], [ 5 ] ]
gap&gt; C:=ECore(H,mu);
[ 7, 2, 2, 1, 1, 1 ]
gap&gt; CombineEQuotientECore(H,Q,C);
[ 100, 98, 57, 43, 12, 1 ]
</pre></td></tr></table>

<p>See also <code class="func">ECore</code> (<a href="chap3.html#X867496487DC35776"><b>3.8-1</b></a>) and <code class="func">EQuotient</code> (<a href="chap3.html#X8538AAAF8628A725"><b>3.8-3</b></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X7C460635829E7ED0" name="X7C460635829E7ED0"></a></p>

<h5>3.8-5 EWeight</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; EWeight</code>( <var class="Arg">e|H, mu</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>The e-weight of a partition is the number of e-hooks which must be removed from the partition to reach the e-core (see <code class="func">ECore</code> (<a href="chap3.html#X867496487DC35776"><b>3.8-1</b></a>)).</p>


<table class="example">
<tr><td><pre>
gap&gt; EWeight(6,[16,8,6,5,3,1]);
5
</pre></td></tr></table>

<p>This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X86308F6C818B220C" name="X86308F6C818B220C"></a></p>

<h5>3.8-6 ERegularPartitions</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ERegularPartitions</code>( <var class="Arg">e|H, n</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>the list of e-regular partitions of n, ordered reverse lexicographically (see <code class="func">Lexicographic</code> (<a href="chap3.html#X8480188D81ECBD92"><b>3.8-14</b></a>)).</p>

<p>A partition mu=(mu_1,mu_2,...) is <em>e-regular</em> if there is no integer i such that mu_i=mu_i+1=cdots=mu_i+e-1&gt;0.</p>


<table class="example">
<tr><td><pre>
gap&gt; H:=Specht(3);; ERegularPartitions(H,6);
[ [ 2, 2, 1, 1 ], [ 3, 2, 1 ], [ 3, 3 ], [ 4, 1, 1 ], [ 4, 2 ], [ 5, 1 ],
  [ 6 ] ]
</pre></td></tr></table>

<p>This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X7BEDA8F286ED5F20" name="X7BEDA8F286ED5F20"></a></p>

<h5>3.8-7 IsERegular</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsERegular</code>( <var class="Arg">e|H, mu</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b><code class="keyw">true</code> if mu is e-regular and <code class="keyw">false</code> otherwise.</p>

<p>This functions requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X7D131AF0839089BD" name="X7D131AF0839089BD"></a></p>

<h5>3.8-8 ConjugatePartition</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ConjugatePartition</code>( <var class="Arg">mu</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>the partition whose diagram is obtained by interchanging the rows and columns in the diagram of mu.</p>


<table class="example">
<tr><td><pre>
gap&gt; ConjugatePartition(6,4,3,2);
[ 4, 4, 3, 2, 1, 1 ]
</pre></td></tr></table>

<p>This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X8796C1D783ED9CB4" name="X8796C1D783ED9CB4"></a></p>

<h5>3.8-9 BetaSet</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; BetaSet</code>( <var class="Arg">mu</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>a <em>set</em> of beta numbers (i.e. first column hook lengths; see <a href="chapBib.html#biBJK">[JK81]</a>) corresponding to the partition mu.</p>


<table class="example">
<tr><td><pre>
gap&gt; BetaSet([5,4,2,2]);
[ 2, 3, 6, 8 ]
</pre></td></tr></table>

<p>See also <code class="func">PartitionBetaSet</code> (<a href="chap3.html#X8711CC56792711A7"><b>3.8-10</b></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X8711CC56792711A7" name="X8711CC56792711A7"></a></p>

<h5>3.8-10 PartitionBetaSet</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; PartitionBetaSet</code>( <var class="Arg">bn</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>the partitions corresponding to the given set of beta numbers bn.Note in particular that bn must be a set of integers.</p>


<table class="example">
<tr><td><pre>
gap&gt; PartitionBetaSet([ 2, 3, 6, 8 ]);
[ 5, 4, 2, 2 ]
</pre></td></tr></table>

<p>This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X7EC4D0FA81B55391" name="X7EC4D0FA81B55391"></a></p>

<h5>3.8-11 ETopLadder</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ETopLadder</code>( <var class="Arg">e|H, mu</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>The ladders in the diagram of a partition are the lines connecting nodes of constant e-residue, having slope e-1 (see <a href="chapBib.html#biBJK">[JK81]</a>). A new partition can be obtained from mu by sliding all nodes up to the highest possible rungs on their ladders.</p>

<p><b>Returns: </b>the partition obtained in this way; it is automatically e-regular (this partition is denoted mu^R in <a href="chapBib.html#biBJK">[JK81]</a>).</p>


<table class="example">
<tr><td><pre>
gap&gt; H:=Specht(4);;
gap&gt; ETopLadder(H,1,1,1,1,1,1,1,1,1,1);
[ 4, 3, 3 ]
gap&gt; ETopLadder(6,1,1,1,1,1,1,1,1,1,1);
[ 2, 2, 2, 2, 2 ]
</pre></td></tr></table>

<p>This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X820388EF7C8333BA" name="X820388EF7C8333BA"></a></p>

<h5>3.8-12 Dominates</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; Dominates</code>( <var class="Arg">mu, nu</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b><code class="keyw">true</code> if either mu=nu or forall i&gt;= 1: sum_j=1^imu_j&gt;=sum_j=1^inu_j and <code class="keyw">false</code> otherwise.</p>

<p>The dominance ordering is an important partial order in the representation theory of Hecke algebra because d_mu,nu=0 unless nu dominates mu.</p>


<table class="example">
<tr><td><pre>
gap&gt; Dominates([5,4],[4,4,1]);
true
</pre></td></tr></table>

<p>This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X84DB1DD37AF227CF" name="X84DB1DD37AF227CF"></a></p>

<h5>3.8-13 LengthLexicographic</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; LengthLexicographic</code>( <var class="Arg">mu, nu</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b><code class="keyw">true</code> if the length of mu is less than the length of nu or if the length of mu equals the length of nu and <code class="code">Lexicographic(</code>mu, nu<code class="code">)</code>.</p>


<table class="example">
<tr><td><pre>
gap&gt; p:=Partitions(6);;Sort(p,LengthLexicographic); p;
[ [ 6 ], [ 5, 1 ], [ 4, 2 ], [ 3, 3 ], [ 4, 1, 1 ], [ 3, 2, 1 ], [ 2, 2, 2 ],
  [ 3, 1, 1, 1 ], [ 2, 2, 1, 1 ], [ 2, 1, 1, 1, 1 ], [ 1, 1, 1, 1, 1, 1 ] ]
</pre></td></tr></table>

<p>This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X8480188D81ECBD92" name="X8480188D81ECBD92"></a></p>

<h5>3.8-14 Lexicographic</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; Lexicographic</code>( <var class="Arg">mu, nu</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b><code class="keyw">true</code> if mu is lexicographically greater than or equal to nu.</p>


<table class="example">
<tr><td><pre>
gap&gt; p:=Partitions(6);;Sort(p,Lexicographic); p;
[ [ 6 ], [ 5, 1 ], [ 4, 2 ], [ 4, 1, 1 ], [ 3, 3 ], [ 3, 2, 1 ],
  [ 3, 1, 1, 1 ], [ 2, 2, 2 ], [ 2, 2, 1, 1 ], [ 2, 1, 1, 1, 1 ],
  [ 1, 1, 1, 1, 1, 1 ] ]
</pre></td></tr></table>

<p>This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X78F41DF77D6F8292" name="X78F41DF77D6F8292"></a></p>

<h5>3.8-15 ReverseDominance</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ReverseDominance</code>( <var class="Arg">mu, nu</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b><code class="keyw">true</code> if forall i&gt;0: sum_j&gt;= imu_j &gt; sum_j&gt;= inu_j.</p>

<p>This is another total order on partitions which extends the dominance ordering (see <code class="func">Dominates</code> (<a href="chap3.html#X820388EF7C8333BA"><b>3.8-12</b></a>)).</p>


<table class="example">
<tr><td><pre>
gap&gt; p:=Partitions(6);;Sort(p,ReverseDominance); p;
[ [ 6 ], [ 5, 1 ], [ 4, 2 ], [ 3, 3 ], [ 4, 1, 1 ], [ 3, 2, 1 ], [ 2, 2, 2 ],
  [ 3, 1, 1, 1 ], [ 2, 2, 1, 1 ], [ 2, 1, 1, 1, 1 ], [ 1, 1, 1, 1, 1, 1 ] ]
</pre></td></tr></table>

<p>This is the ordering used by James in the appendix of his Springer lecture notes book.</p>

<p>This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X83890936806E3A34" name="X83890936806E3A34"></a></p>

<h4>3.9 <span class="Heading">Miscellaneous functions on modules</span></h4>

<p>This section contains some functions for looking at the partitions in a given module for the Hecke algebras. Most of them are used internally by <strong class="pkg">Hecke</strong>.</p>

<p><a id="X7A8E810C85A62DD6" name="X7A8E810C85A62DD6"></a></p>

<h5>3.9-1 Specialized</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; Specialized</code>( <var class="Arg">x[, q]</var> )</td><td class="tdright">( method )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; Specialized</code>( <var class="Arg">d[, q]</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>the corresponding element of the Grothendieck ring or the corresponding decomposition matrix of the Hecke algebra when given an element of the Fock space x (see <code class="func">Specht</code> (<a href="chap3.html#X7FE26921867C440A"><b>3.2-1</b></a>)), or a crystallized decomposition matrix (see <code class="func">CrystalDecompositionMatrix</code> (<a href="chap3.html#X7F616CCE808FA11E"><b>3.2-9</b></a>)), respectively.</p>

<p>By default the indeterminate v is specialized to 1; however v can be specialized to any (integer) q by supplying a second argument.</p>


<table class="example">
<tr><td><pre>
gap&gt; SizeScreen([80,20]);; H:=Specht(2);; x:=MakeFockPIM(H,6,2);; Display(x);
Sq(6,2) + vSq(6,1^2) + vSq(5,3) + v^2Sq(5,1^3) + vSq(4,3,1) + v^2Sq(4,2^2) + (\
v^3+v)Sq(4,2,1^2) + v^2Sq(4,1^4) + v^2Sq(3^2,1^2) + v^3Sq(3,2^2,1) + v^3Sq(3,1\
^5) + v^3Sq(2^3,1^2) + v^4Sq(2^2,1^4)
gap&gt; Display(Specialized(x));
S(6,2) + S(6,1^2) + S(5,3) + S(5,1^3) + S(4,3,1) + S(4,2^2) + 2S(4,2,1^2) + S(\
4,1^4) + S(3^2,1^2) + S(3,2^2,1) + S(3,1^5) + S(2^3,1^2) + S(2^2,1^4)
gap&gt; Display(Specialized(x,2));
S(6,2) + 2S(6,1^2) + 2S(5,3) + 4S(5,1^3) + 2S(4,3,1) + 4S(4,2^2) + 10S(4,2,1^2\
) + 4S(4,1^4) + 4S(3^2,1^2) + 8S(3,2^2,1) + 8S(3,1^5) + 8S(2^3,1^2) + 16S(2^2,\
1^4)
</pre></td></tr></table>

<p>An example of <code class="func">Specialized</code> being applied to a crystallized decomposition matrix can be found in <code class="func">CrystalDecompositionMatrix</code> (<a href="chap3.html#X7F616CCE808FA11E"><b>3.2-9</b></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X8232C0A1846A27FB" name="X8232C0A1846A27FB"></a></p>

<h5>3.9-2 ERegulars</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ERegulars</code>( <var class="Arg">x</var> )</td><td class="tdright">( method )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ERegulars</code>( <var class="Arg">d</var> )</td><td class="tdright">( method )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ListERegulars</code>( <var class="Arg">x</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><code class="code">ERegulars(</code>x<code class="code">)</code> prints a list of the e-regular partitions, together with multiplicities, which occur in the module x. <code class="code">ListERegulars(</code>x<code class="code">)</code> returns an actual list of these partitions rather than printing them.</p>


<table class="example">
<tr><td><pre>
gap&gt; H:=Specht(8);;
gap&gt; x:=MakeSpecht(RInducedModule(MakePIM(H,8,5,3)));; Display(x);
S(9,5,3) + S(8,6,3) + S(8,5,4) + S(8,5,3,1) + S(6,5,3^2) + S(5^2,4,3) + S(5^2,3^2,1)
gap&gt; ERegulars(x);
[ 9, 5, 3 ]  [ 8, 6, 3 ]  [ 8, 5, 4 ]  [ 8, 5, 3, 1 ]
[ 6, 5, 3, 3 ]  [ 5, 5, 4, 3 ]  [ 5, 5, 3, 3, 1 ]
gap&gt; Display(MakePIM(x));
P(9,5,3) + P(8,6,3) + P(8,5,4) + P(8,5,3,1)
</pre></td></tr></table>

<p>This example shows why these functions are useful: given a projective module x, as aboveand the list of e-regular partitions in x we know the possible indecomposable direct summands of x.</p>

<p>Note that it is not necessary to specify what e is when calling this function because x "knows" the value of e.</p>

<p>The function <code class="func">ERegulars</code> can also be applied to a decomposition matrix d; in this case it returns the unitriangular submatrix of d whose rows and columns are indexed by the e-regular partitions.</p>

<p>These function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X822E8193835DD1D9" name="X822E8193835DD1D9"></a></p>

<h5>3.9-3 SplitECores</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; SplitECores</code>( <var class="Arg">x</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>a list [b_1,...,b_k] where the Specht modules in each b_i all belong to the same block (i.e. they have the same e-core).</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; SplitECores</code>( <var class="Arg">x, mu</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>the component of x which is in the same block as mu.</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; SplitECores</code>( <var class="Arg">x, y</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>the component of x which is in the same block as y.</p>


<table class="example">
<tr><td><pre>
gap&gt; H:=Specht(2);;
gap&gt; Display(SplitECores(RInducedModule(MakeSpecht(H,5,3,1))));
[ S(6,3,1) + S(5,3,2) + S(5,3,1,1), S(5,4,1) ]
gap&gt; Display(RInducedModule(MakeSpecht(H,5,3,1),0));
S(5,4,1)
gap&gt; Display(RInducedModule(MakeSpecht(H,5,3,1),1));
S(6,3,1) + S(5,3,2) + S(5,3,1^2)
</pre></td></tr></table>

<p>See also <code class="func">ECore</code> (<a href="chap3.html#X867496487DC35776"><b>3.8-1</b></a>), <code class="func">RInducedModule</code> (<a href="chap3.html#X81D7F7A4812BB04D"><b>3.4-1</b></a>) and <code class="func">RRestrictedModule</code> (<a href="chap3.html#X783BC74E81A7D0E6"><b>3.4-3</b></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X7E92948B80075E46" name="X7E92948B80075E46"></a></p>

<h5>3.9-4 Coefficient</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; Coefficient</code>( <var class="Arg">x, mu</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>the coefficient of S(mu) in x (resp. D(mu), or P(mu)).</p>


<table class="example">
<tr><td><pre>
gap&gt; SizeScreen([80,20]);;
gap&gt; H:=Specht(3);; x:=MakeSpecht(MakePIM(H,7,3));; Display(x);
S(7,3) + S(7,2,1) + S(6,2,1^2) + S(5^2) + S(5,2^2,1) + S(4^2,1^2) + S(4,3^2) +\
 S(4,3,2,1)
gap&gt; Coefficient(x,5,2,2,1);
1
</pre></td></tr></table>

<p>This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X79FB3FE67D55BCFA" name="X79FB3FE67D55BCFA"></a></p>

<h5>3.9-5 InnerProduct</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; InnerProduct</code>( <var class="Arg">x, y</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Here x and y are some modules of the Hecke algebra (i.e. Specht modules, PIMS, or simple modules). <code class="func">InnerProduct</code> computes the standard inner product of these elements. This is sometimes a convenient way to compute decomposition numbers (for example).</p>


<table class="example">
<tr><td><pre>
gap&gt; H:=Specht(2);; InnerProduct(MakeSpecht(H,2,2,2,1), MakePIM(H,4,3));
1
gap&gt; DecompositionNumber(H,[2,2,2,1],[4,3]);
1
</pre></td></tr></table>

<p>This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X7D473E167C866CEC" name="X7D473E167C866CEC"></a></p>

<h4>3.10 <span class="Heading">Semi-standard and standard tableaux</span></h4>

<p>These functions are not really part of <strong class="pkg">Hecke</strong> proper; however they are related and may well be of use to someone. Tableaux are represented by objects, that can be constructed from a list of lists.</p>

<p><a id="X7F0F9663796E6978" name="X7F0F9663796E6978"></a></p>

<h5>3.10-1 Tableau</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; Tableau</code>( <var class="Arg">tab</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>tableau object corresponding to the given list of lists</p>

<p>This is the constructor for tableau objects. The first entry of the given argument list is the list corresponding to the first row of the tableau.</p>

<p><a id="X79ADB1B980D12A14" name="X79ADB1B980D12A14"></a></p>

<h5>3.10-2 SemiStandardTableaux</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; SemiStandardTableaux</code>( <var class="Arg">mu, nu</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>list of the semistandard mu-tableaux of type nu <a href="chapBib.html#biBJK">[JK81]</a></p>

<p>mu a partition, nu a composition.</p>


<table class="example">
<tr><td><pre>
gap&gt; SizeScreen([80,20]);; Display(SemiStandardTableaux([4,3],[1,1,1,2,2]));
[ Tableau( [ [ 1, 2, 3, 4 ], [ 4, 5, 5 ] ] ),
  Tableau( [ [ 1, 2, 3, 5 ], [ 4, 4, 5 ] ] ),
  Tableau( [ [ 1, 2, 4, 4 ], [ 3, 5, 5 ] ] ),
  Tableau( [ [ 1, 2, 4, 5 ], [ 3, 4, 5 ] ] ),
  Tableau( [ [ 1, 3, 4, 4 ], [ 2, 5, 5 ] ] ),
  Tableau( [ [ 1, 3, 4, 5 ], [ 2, 4, 5 ] ] ) ]
</pre></td></tr></table>

<p>See also <code class="func">StandardTableaux</code> (<a href="chap3.html#X7E51D6107DBE2A74"><b>3.10-3</b></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X7E51D6107DBE2A74" name="X7E51D6107DBE2A74"></a></p>

<h5>3.10-3 StandardTableaux</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; StandardTableaux</code>( <var class="Arg">mu</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>list of the standard mu-tableaux</p>

<p>mu a partition</p>


<table class="example">
<tr><td><pre>
gap&gt; SizeScreen([80,20]);; Display(StandardTableaux(4,2));
[ Tableau( [ [ 1, 2, 3, 4 ], [ 5, 6 ] ] ), Tableau( [ [ 1, 2, 3, 5 ], [ 4, 6 ] ] ),
  Tableau( [ [ 1, 2, 3, 6 ], [ 4, 5 ] ] ), Tableau( [ [ 1, 2, 4, 5 ], [ 3, 6 ] ] ),
  Tableau( [ [ 1, 2, 4, 6 ], [ 3, 5 ] ] ), Tableau( [ [ 1, 2, 5, 6 ], [ 3, 4 ] ] ),
  Tableau( [ [ 1, 3, 4, 5 ], [ 2, 6 ] ] ), Tableau( [ [ 1, 3, 4, 6 ], [ 2, 5 ] ] ),
  Tableau( [ [ 1, 3, 5, 6 ], [ 2, 4 ] ] ) ]
</pre></td></tr></table>

<p>See also <code class="func">SemiStandardTableaux</code> (<a href="chap3.html#X79ADB1B980D12A14"><b>3.10-2</b></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X7869DA9A8198BD28" name="X7869DA9A8198BD28"></a></p>

<h5>3.10-4 ConjugateTableau</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ConjugateTableau</code>( <var class="Arg">tab</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>tableau obtained from tab by interchangings its rows and columns</p>


<table class="example">
<tr><td><pre>
gap&gt; Display(ConjugateTableau(Tableau([ [ 1, 3, 5, 6 ], [ 2, 4 ] ])));
Standard Tableau:
1	2
3	4
5
6
</pre></td></tr></table>

<p>This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X7E5351C27C9253D9" name="X7E5351C27C9253D9"></a></p>

<h5>3.10-5 ShapeTableau</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ShapeTableau</code>( <var class="Arg">tab</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>the partition (or composition) obtained from tab</p>


<table class="example">
<tr><td><pre>
gap&gt; ShapeTableau( Tableau([ [ 1, 1, 2, 3 ], [ 4, 5 ] ]) );
[ 4, 2 ]
</pre></td></tr></table>

<p>This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>

<p><a id="X7CABF92D7BF07DD1" name="X7CABF92D7BF07DD1"></a></p>

<h5>3.10-6 TypeTableau</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; TypeTableau</code>( <var class="Arg">tab</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>the type of the (semistandard) tableau tab</p>

<p>The type of a tableau is, the composition sigma= (sigma_1,sigma_2,...) where sigma_i is the number of entries in tab which are equal to i.</p>


<table class="example">
<tr><td><pre>
gap&gt; SizeScreen([80,20]);;
gap&gt; List(SemiStandardTableaux([5,4,2],[4,3,0,1,3]),TypeTableau);
[ [ 4, 3, 0, 1, 3 ], [ 4, 3, 0, 1, 3 ], [ 4, 3, 0, 1, 3 ], [ 4, 3, 0, 1, 3 ],
  [ 4, 3, 0, 1, 3 ] ]
</pre></td></tr></table>

<p>This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="/home/dmitriy/gap4r4/doc/htm/ref/CHAP074.htm#SECT002"><b>Reference: LoadPackage</b></a>)).</p>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">Top of Book</a>&nbsp;  &nbsp;<a href="chap2.html">Previous Chapter</a>&nbsp;  &nbsp;<a href="chapBib.html">Next Chapter</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
