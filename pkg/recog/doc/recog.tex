% generated by GAPDoc2LaTeX from XML source (Frank Luebeck)
\documentclass[a4paper,11pt]{report}

\usepackage{a4wide}
\sloppy
\pagestyle{myheadings}
\usepackage{amssymb}
\usepackage[latin1]{inputenc}
\usepackage{makeidx}
\makeindex
\usepackage{color}
\definecolor{FireBrick}{rgb}{0.5812,0.0074,0.0083}
\definecolor{RoyalBlue}{rgb}{0.0236,0.0894,0.6179}
\definecolor{RoyalGreen}{rgb}{0.0236,0.6179,0.0894}
\definecolor{RoyalRed}{rgb}{0.6179,0.0236,0.0894}
\definecolor{LightBlue}{rgb}{0.8544,0.9511,1.0000}
\definecolor{Black}{rgb}{0.0,0.0,0.0}

\definecolor{linkColor}{rgb}{0.0,0.0,0.554}
\definecolor{citeColor}{rgb}{0.0,0.0,0.554}
\definecolor{fileColor}{rgb}{0.0,0.0,0.554}
\definecolor{urlColor}{rgb}{0.0,0.0,0.554}
\definecolor{promptColor}{rgb}{0.0,0.0,0.589}
\definecolor{brkpromptColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapinputColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapoutputColor}{rgb}{0.0,0.0,0.0}

%%  for a long time these were red and blue by default,
%%  now black, but keep variables to overwrite
\definecolor{FuncColor}{rgb}{0.0,0.0,0.0}
%% strange name because of pdflatex bug:
\definecolor{Chapter }{rgb}{0.0,0.0,0.0}
\definecolor{DarkOlive}{rgb}{0.1047,0.2412,0.0064}


\usepackage{fancyvrb}

\usepackage{mathptmx,helvet}
\usepackage[T1]{fontenc}
\usepackage{textcomp}


\usepackage[
            pdftex=true,
            bookmarks=true,        
            a4paper=true,
            pdftitle={Written with GAPDoc},
            pdfcreator={LaTeX with hyperref package / GAPDoc},
            colorlinks=true,
            backref=page,
            breaklinks=true,
            linkcolor=linkColor,
            citecolor=citeColor,
            filecolor=fileColor,
            urlcolor=urlColor,
            pdfpagemode={UseNone}, 
           ]{hyperref}

\newcommand{\maintitlesize}{\fontsize{50}{55}\selectfont}

% write page numbers to a .pnr log file for online help
\newwrite\pagenrlog
\immediate\openout\pagenrlog =\jobname.pnr
\immediate\write\pagenrlog{PAGENRS := [}
\newcommand{\logpage}[1]{\protect\write\pagenrlog{#1, \thepage,}}
%% were never documented, give conflicts with some additional packages

\newcommand{\GAP}{\textsf{GAP}}

%% nicer description environments, allows long labels
\usepackage{enumitem}
\setdescription{style=nextline}

%% depth of toc
\setcounter{tocdepth}{1}





%% command for ColorPrompt style examples
\newcommand{\gapprompt}[1]{\color{promptColor}{\bfseries #1}}
\newcommand{\gapbrkprompt}[1]{\color{brkpromptColor}{\bfseries #1}}
\newcommand{\gapinput}[1]{\color{gapinputColor}{#1}}


\begin{document}

\logpage{[ 0, 0, 0 ]}
\begin{titlepage}
\mbox{}\vfill

\begin{center}{\maintitlesize \textbf{GAP 4 Package \textsf{recog}\mbox{}}}\\
\vfill

\hypersetup{pdftitle=GAP 4 Package \textsf{recog}}
\markright{\scriptsize \mbox{}\hfill GAP 4 Package \textsf{recog} \hfill\mbox{}}
{\Huge \textbf{Group Recognition Methods\mbox{}}}\\
\vfill

{\Huge  1.2 \mbox{}}\\[1cm]
{May 2012\mbox{}}\\[1cm]
\mbox{}\\[2cm]
{\Large \textbf{Max Neunh{\"o}ffer    \mbox{}}}\\
{\Large \textbf{{\a'A}kos Seress    \mbox{}}}\\
{\Large \textbf{Nurullah Ankaralioglu\mbox{}}}\\
{\Large \textbf{Peter Brooksbank\mbox{}}}\\
{\Large \textbf{Frank Celler\mbox{}}}\\
{\Large \textbf{Stephen Howe\mbox{}}}\\
{\Large \textbf{Maska Law\mbox{}}}\\
{\Large \textbf{Stephen Linton\mbox{}}}\\
{\Large \textbf{Gunter Malle\mbox{}}}\\
{\Large \textbf{Eamonn O'Brien\mbox{}}}\\
{\Large \textbf{Colva Roney-Dougal\mbox{}}}\\
\hypersetup{pdfauthor=Max Neunh{\"o}ffer    ; {\a'A}kos Seress    ; Nurullah Ankaralioglu; Peter Brooksbank; Frank Celler; Stephen Howe; Maska Law; Stephen Linton; Gunter Malle; Eamonn O'Brien; Colva Roney-Dougal}
\end{center}\vfill

\mbox{}\\
{\mbox{}\\
\small \noindent \textbf{Max Neunh{\"o}ffer    }  Email: \href{mailto://neunhoef@mcs.st-and.ac.uk} {\texttt{neunhoef@mcs.st-and.ac.uk}}\\
  Homepage: \href{http://www-groups.mcs.st-and.ac.uk/~neunhoef/} {\texttt{http://www-groups.mcs.st-and.ac.uk/\texttt{\symbol{126}}neunhoef/}}\\
  Address: \begin{minipage}[t]{8cm}\noindent
School of Mathematics and Statistics, Mathematical Institute, North Haugh, St
Andrews, Fife, KY16 9SS, Scotland, UK\end{minipage}
}\\
{\mbox{}\\
\small \noindent \textbf{{\a'A}kos Seress    }  Email: \href{mailto://akos@math.ohio-state.edu} {\texttt{akos@math.ohio-state.edu}}\\
  Homepage: \href{http://www.math.ohio-state.edu/people/display/display.php?ID=302 } {\texttt{http://www.math.ohio-state.edu/people/display/display.php?ID=302 }}\\
  Address: \begin{minipage}[t]{8cm}\noindent
 Department of Mathematics, The Ohio State University, 231 W 18th Avenue,
Columbus, OH 43210 USA \end{minipage}
}\\
\end{titlepage}

\newpage\setcounter{page}{2}
{\small 
\section*{Copyright}
\logpage{[ 0, 0, 1 ]}
 {\copyright} 2005-2009 by Max Neunh{\"o}ffer and {\a'A}kos Seress

 This package may be distributed under the terms and conditions of the GNU
Public License Version 3 or (at your option) any later version. \mbox{}}\\[1cm]
\newpage

\def\contentsname{Contents\logpage{[ 0, 0, 2 ]}}

\tableofcontents
\newpage

  
\chapter{\textcolor{Chapter }{Introduction}}\label{intro}
\logpage{[ 1, 0, 0 ]}
\hyperdef{L}{X7DFB63A97E67C0A1}{}
{
  
\section{\textcolor{Chapter }{Philosophy}}\label{philosophy}
\logpage{[ 1, 1, 0 ]}
\hyperdef{L}{X873C99678745ABAF}{}
{
  This package is about group recognition. To be written further. }

 
\section{\textcolor{Chapter }{Overview over this manual}}\label{overview}
\logpage{[ 1, 2, 0 ]}
\hyperdef{L}{X786BACDB82918A65}{}
{
  Chapter \ref{install} describes the installation of this package. Chapter  (\textbf{recogbase: Recognition info records}) describes the generic, recursive procedure used for group recognition
throughout this package. At the heart of this procedure is the definition of ``FindHomomorphism'' methods, which is also described in that chapter. For the choice of the right
method for finding a homomorphism (or an isomorphism) we use another generic
procedure, the ``method selection'' which is not to be confused with the \textsf{GAP} method selection. Our own method selection is described in detail in Chapter  (\textbf{recogbase: Method Selection}), because it is interesting in its own right and might be useful in other
circumstances.

 \emph{More text on other chapters to be written.}

 Finally, Chapter \ref{examples} shows instructive examples for the usage of this package. }

  }

  
\chapter{\textcolor{Chapter }{Installation of the \textsf{recog}-Package}}\label{install}
\logpage{[ 2, 0, 0 ]}
\hyperdef{L}{X800672E679F7C0D4}{}
{
  \index{\textsf{recog}} To install this package just extract the package's archive file to the GAP \texttt{pkg} directory.

 By default the \textsf{recog} package is not automatically loaded by \textsf{GAP} when it is installed. You must load the package with \texttt{LoadPackage("recog");} before its functions become available.

 Note that the \textsf{recogbase} package is needed by this package.

 Please, send us an e-mail if you have any questions, remarks, suggestions,
etc. concerning this package. Also, we would like to hear about applications
of this package.

 Max Neunh{\"o}ffer and {\a'A}kos Seress

  }

  
\chapter{\textcolor{Chapter }{Methods for recognition}}\label{methods}
\logpage{[ 3, 0, 0 ]}
\hyperdef{L}{X78C5295B86AD0C66}{}
{
  \index{\textsf{recog}} 
\section{\textcolor{Chapter }{Methods for permutation groups}}\label{permmethods}
\logpage{[ 3, 1, 0 ]}
\hyperdef{L}{X829A2F96860513F2}{}
{
  The following table gives an overview over the installed methods and their
rank (higher rank means higher priority, the method is tried earlier, see
Chapter  (\textbf{recogbase: Method Selection})). \begin{center}
\begin{tabular}{|l|l|l|}\hline
300&
\texttt{TrivialPermGroup}&
\ref{TrivialPermGroup}\\
\hline
100&
\texttt{ThrowAwayFixedPoints}&
\ref{ThrowAwayFixedPoints}\\
\hline
97&
\texttt{Pcgs}&
\ref{Pcgs}\\
\hline
95&
\texttt{VeryFewPoints}&
\ref{VeryFewPoints}\\
\hline
90&
\texttt{NonTransitive}&
\ref{NonTransitive}\\
\hline
80&
\texttt{Giant}&
\ref{Giant}\\
\hline
70&
\texttt{Imprimitive}&
\ref{Imprimitive}\\
\hline
60&
\texttt{SnkSetswrSr}&
\ref{SnkSetswrSr}\\
\hline
50&
\texttt{StabChain}&
\ref{StabChain}\\
\hline
\end{tabular}\\[2mm]
\textbf{Table: }Permutation group find homomorphism methods\end{center}

 
\subsection{\textcolor{Chapter }{\texttt{TrivialPermGroup}}}\label{TrivialPermGroup}
\logpage{[ 3, 1, 1 ]}
\hyperdef{L}{X8553B50D83FF8D09}{}
{
  This method is successful if and only if all generators of the permutation
group \mbox{\texttt{\mdseries\slshape G}} are equal to the identity. Otherwise it returns \texttt{false} indicating that it will never succeed. This method is only installed to handle
the trivial case such that we do not have to take this case into account in
the other methods. }

 
\subsection{\textcolor{Chapter }{\texttt{ThrowAwayFixedPoints}}}\label{ThrowAwayFixedPoints}
\logpage{[ 3, 1, 2 ]}
\hyperdef{L}{X7D0F93CC7F6FD5FA}{}
{
  This method defines a homomorphism of a permutation group \mbox{\texttt{\mdseries\slshape G}} to the action on the moved points of \mbox{\texttt{\mdseries\slshape G}} if \mbox{\texttt{\mdseries\slshape G}} does not have too many moved points. In the current setup, the homomorphism is
defined if the number $k$ of moved points is at most $1/3$ of the largest moved point of \mbox{\texttt{\mdseries\slshape G}}, or $k$ is at most half of the number of points on which \mbox{\texttt{\mdseries\slshape G}} is stored internally by \textsf{GAP}. The method returns \texttt{false} if it does not define a homomorphism indicating that it will never succeed. }

 
\subsection{\textcolor{Chapter }{\texttt{Pcgs}}}\label{Pcgs}
\logpage{[ 3, 1, 3 ]}
\hyperdef{L}{X7936FB597D61D4F1}{}
{
  This is the \textsf{GAP} library function to compute a stabiliser chain for a solvable permutation
group. If the method is successful then the calling node becomes a leaf node
in the recursive scheme. If the input group is not solvable then the method
returns \texttt{false}. }

 
\subsection{\textcolor{Chapter }{\texttt{VeryFewPoints}}}\label{VeryFewPoints}
\logpage{[ 3, 1, 4 ]}
\hyperdef{L}{X789EC18884A6169E}{}
{
  If a permutation group acts only on a few points (the current limit is at most
10 points) then a stabiliser chain is computed by the randomized \textsf{GAP} library function for that purpose. If the method is successful then the
calling node becomes a leaf node in the recursive scheme. If the input group
acts on more than 10 points then the method returns \texttt{false}. }

 
\subsection{\textcolor{Chapter }{\texttt{Nontransitive}}}\label{NonTransitive}
\logpage{[ 3, 1, 5 ]}
\hyperdef{L}{X8251084C84624B79}{}
{
  If a permutation group \mbox{\texttt{\mdseries\slshape G}} acts nontransitively then this method computes a homomorphism to the action of \mbox{\texttt{\mdseries\slshape G}} on the orbit of the largest moved point. If \mbox{\texttt{\mdseries\slshape G}} is transitive then the method returns \texttt{false}. }

 
\subsection{\textcolor{Chapter }{\texttt{Giant}}}\label{Giant}
\logpage{[ 3, 1, 6 ]}
\hyperdef{L}{X86008C717EE1C27A}{}
{
  The method tries to determine whether the input group \mbox{\texttt{\mdseries\slshape G}} is a giant (that is, $A_n$ or $S_n$ in its natural action on $n$ points). The output is either a data structure $D$ containing nice generators for \mbox{\texttt{\mdseries\slshape G}} and a procedure to write an SLP for arbitrary elements of \mbox{\texttt{\mdseries\slshape G}} from the nice generators; or \texttt{false} if \mbox{\texttt{\mdseries\slshape G}} is not transitive; or \texttt{fail}, in the case that no evidence was found that \mbox{\texttt{\mdseries\slshape G}} is a giant, or evidence was found, but the construction of $D$ was unsuccessful. If the method constructs $D$ then the calling node becomes a leaf. }

 
\subsection{\textcolor{Chapter }{\texttt{Imprimitive}}}\label{Imprimitive}
\logpage{[ 3, 1, 7 ]}
\hyperdef{L}{X79CD5A5D8743F365}{}
{
  If the input group is not known to be transitive then this method returns \texttt{NotApplicable}. If the input group is known to be transitive and primitive then the method
returns \texttt{false}; otherwise, the method tries to compute a nontrivial block system. If
successful then a homomorphism to the action on the blocks is defined;
otherwise, the method returns \texttt{false}. If the method is successful then it also gives a hint for the children of
the node by determining whether the kernel of the action on the block system
is solvable. If the answer is yes then the default value 20 for the number of
random generators in the kernel construction is increased by the number of
blocks. }

 
\subsection{\textcolor{Chapter }{\texttt{SnkSetswrSr}}}\label{SnkSetswrSr}
\logpage{[ 3, 1, 8 ]}
\hyperdef{L}{X7FE7B1407E9C60B8}{}
{
  This method tries to determine whether the input group \mbox{\texttt{\mdseries\slshape G}} is acting primitively on $N$ points, and is isomorphic to a large subgroup of $H \wr S_r$ where $H$ is $S_n$ acting on $k$-sets and $N = {{n \choose k}}^r$ and $kr > 1$. ``Large'' means that \mbox{\texttt{\mdseries\slshape G}} contains a subgroup isomorphic to $A_n^r$. If \mbox{\texttt{\mdseries\slshape G}} is imprimitive then the output is \texttt{false}. If \mbox{\texttt{\mdseries\slshape G}} is primitive then the output is either a homomorphism into the natural
imprimitive action of \mbox{\texttt{\mdseries\slshape G}} on $nr$ points with $r$ blocks of size $n$, or \texttt{fail}. }

 
\subsection{\textcolor{Chapter }{\texttt{StabChain}}}\label{StabChain}
\logpage{[ 3, 1, 9 ]}
\hyperdef{L}{X784801B47E9838D5}{}
{
  This is the randomized \textsf{GAP} library function for computing a stabiliser chain. The method selection
process ensures that this function is called only with small-base inputs,
where the method works efficiently. }

 }

 
\section{\textcolor{Chapter }{Methods for matrix groups}}\label{matrixmethods}
\logpage{[ 3, 2, 0 ]}
\hyperdef{L}{X829BA50B82FEC109}{}
{
  THIS CHAPTER IS CURRENTLY A BIT OUT OF DATE! 

 The following table gives an overview over the installed methods and their
rank (higher rank means higher priority, the method is tried earlier, see
Chapter  (\textbf{recogbase: Method Selection})). Note that there are not that many methods for matrix groups since the
system can switch to projective groups by dividing out the subgroup of scalar
matrices. The bulk of the recognition methods are then installed es methods
for projective groups. \begin{center}
\begin{tabular}{|l|l|l|}\hline
3100&
\texttt{TrivialMatrixGroup}&
\ref{TrivialMatrixGroup}\\
\hline
1100&
\texttt{DiagonalMatrices}&
\ref{DiagonalMatrices}\\
\hline
1000&
\texttt{ReducibleIso}&
\ref{ReducibleIso}\\
\hline
900&
\texttt{GoProjective}&
\ref{GoProjective}\\
\hline
\end{tabular}\\[2mm]
\textbf{Table: }Matrix group find homomorphism methods\end{center}

 
\subsection{\textcolor{Chapter }{\texttt{TrivialMatrixGroup}}}\label{TrivialMatrixGroup}
\logpage{[ 3, 2, 1 ]}
\hyperdef{L}{X796A682C78FFB9DC}{}
{
  This method is successful if and only if all generators of a matrix group \mbox{\texttt{\mdseries\slshape G}} are equal to the identity. Otherwise, it returns \texttt{false}. }

 
\subsection{\textcolor{Chapter }{\texttt{DiagonalMatrices}}}\label{DiagonalMatrices}
\logpage{[ 3, 2, 2 ]}
\hyperdef{L}{X79C0EC2987BCA334}{}
{
  This method is successful if and only if all generators of a matrix group \mbox{\texttt{\mdseries\slshape G}} are diagonal matrices. Otherwise, it returns \texttt{false}. }

 
\subsection{\textcolor{Chapter }{\texttt{ReducibleIso}}}\label{ReducibleIso}
\logpage{[ 3, 2, 3 ]}
\hyperdef{L}{X8499282F7825D28C}{}
{
  This method determines whether a matrix group \mbox{\texttt{\mdseries\slshape G}} acts irreducibly. If yes, then it returns \texttt{false}. If \mbox{\texttt{\mdseries\slshape G}} acts reducibly then a composition series of the underlying module is computed
and a base change is performed to write \mbox{\texttt{\mdseries\slshape G}} in a block lower triangular form. Also, the method passes a hint to the image
group that it is in block lower triangular form, so the image immediately can
make recursive calls for the actions on the diagonal blocks, and then to the
lower $p$-part. For the image the method \texttt{BlockLowerTriangular} (see \ref{BlockLowerTriangular}) is used. 

 Note that this method is implemented in a way such that it can also be used as
a method for a projective group \mbox{\texttt{\mdseries\slshape G}}. In that case the recognition info record has the \texttt{!.projective} component bound to \texttt{true} and this information is passed down to image and kernel. }

 
\subsection{\textcolor{Chapter }{\texttt{BlockLowerTriangular}}}\label{BlockLowerTriangular}
\logpage{[ 3, 2, 4 ]}
\hyperdef{L}{X85655B8082FCB0AD}{}
{
  This method is only called when a hint was passed down from the method \texttt{ReducibleIso} (see \ref{ReducibleIso}). In that case, it knows that a base change to block lower triangular form
has been performed. The method can then immediately find a homomorphism by
mapping to the diagonal blocks. It sets up this homomorphism and gives hints
to image and kernel. For the image, the method \texttt{BlockDiagonal} (see \ref{BlockDiagonal}) is used and for the kernel, the method \texttt{LowerLeftPGroup} (see \ref{LowerLeftPGroup}) is used. 

 Note that this method is implemented in a way such that it can also be used as
a method for a projective group \mbox{\texttt{\mdseries\slshape G}}. In that case the recognition info record has the \texttt{!.projective} component bound to \texttt{true} and this information is passed down to image and kernel. }

 
\subsection{\textcolor{Chapter }{\texttt{BlockDiagonal}}}\label{BlockDiagonal}
\logpage{[ 3, 2, 5 ]}
\hyperdef{L}{X799EEBE27AF157B6}{}
{
  This method is only called when a hint was passed down from the method \texttt{BlockLowerTriangular} (see \ref{BlockLowerTriangular}). In that case, it knows that the group is in block diagonal form. The method
is used both in the matrix- and the projective case. 

 The method immediately delegates to projective methods handling all the
diagonal blocks projectively. This is done by giving a hint to the factor to
use the method \texttt{BlocksModScalars} (see \ref{BlocksModScalars}) is given. The method for the kernel then has to deal with only scalar
blocks, either projectively or with scalars, which is again done by giving a
hint to either use \texttt{BlockScalar} (see \ref{BlockScalar}) or \texttt{BlockScalarProj} (see \ref{BlockScalarProj}) respectively. 

 Note that this method is implemented in a way such that it can also be used as
a method for a projective group \mbox{\texttt{\mdseries\slshape G}}. In that case the recognition info record has the \texttt{!.projective} component bound to \texttt{true} and this information is passed down to image and kernel. }

 
\subsection{\textcolor{Chapter }{\texttt{GoProjective}}}\label{GoProjective}
\logpage{[ 3, 2, 6 ]}
\hyperdef{L}{X79A0674B7ECAFB62}{}
{
  This method defines a homomorphism from a matrix group \mbox{\texttt{\mdseries\slshape G}} into the projective group \mbox{\texttt{\mdseries\slshape G}} modulo scalar matrices. In fact, since projective groups in \textsf{GAP} are represented as matrix groups, the homomorphism is the identity mapping and
the only difference is that in the image the projective group methods can be
applied. The bulk of the work in matrix recognition is done in the projective
group setting. }

 
\subsection{\textcolor{Chapter }{\texttt{BlockScalar}}}\label{BlockScalar}
\logpage{[ 3, 2, 7 ]}
\hyperdef{L}{X7B9301E97DE36543}{}
{
  This method is only called by a hint. Alongside with the hint it gets a block
decomposition respected by the matrix group \mbox{\texttt{\mdseries\slshape G}} to be recognised and the promise, that all diagonal blocks of all group
elements will only be scalar matrices. This method recursively builds a
balanced tree and does scalar recognition in each leaf. }

 
\subsection{\textcolor{Chapter }{\texttt{LowerLeftPGroup}}}\label{LowerLeftPGroup}
\logpage{[ 3, 2, 8 ]}
\hyperdef{L}{X78A525FD797F429B}{}
{
  This method is only called by a hint from \texttt{BlockLowerTriangular} as the kernel of the homomorphism mapping to the diagonal blocks. The method
uses the fact the this kernel is a $p$-group where $p$ is the characteristic of the underlying field. It exploits this fact and uses
this special structure to find nice generators and a method to express group
elements in terms of these. }

 }

 
\section{\textcolor{Chapter }{Methods for projective groups}}\label{projmethods}
\logpage{[ 3, 3, 0 ]}
\hyperdef{L}{X867550F684F795AE}{}
{
  THIS CHAPTER IS CURRENTLY A BIT OUT OF DATE! 

 The following table gives an overview over the installed methods and their
rank (higher rank means higher priority, the method is tried earlier, see
Chapter  (\textbf{recogbase: Method Selection})). Note that the recognition for matrix group switches to projective
recognition rather soon in the recognition process such that most recognition
methods in fact are installed as methods for projective groups. \begin{center}
\begin{tabular}{|l|l|l|}\hline
3000&
\texttt{TrivialProjectiveGroup}&
\ref{TrivialProjectiveGroup}\\
\hline
1300&
\texttt{ProjDeterminant}&
\ref{ProjDeterminant}\\
\hline
1200&
\texttt{ReducibleIso}&
\ref{ReducibleIsoProj}\\
\hline
1100&
\texttt{NotAbsolutelyIrred}&
\ref{NotAbsolutelyIrred}\\
\hline
1000&
\texttt{Subfield}&
\ref{Subfield}\\
\hline
900&
\texttt{Derived}&
\ref{Derived}\\
\hline
800&
\texttt{LowIndex}&
\ref{LowIndex}\\
\hline
700&
\texttt{C6}&
\ref{C6}\\
\hline
600&
\texttt{Tensor}&
\ref{Tensor}\\
\hline
500&
\texttt{TwoLargeElOrders}&
\ref{TwoLargeElOrders}\\
\hline
100&
\texttt{StabilizerChain}&
\ref{StabilizerChain}\\
\hline
\end{tabular}\\[2mm]
\textbf{Table: }Projective group find homomorphism methods\end{center}

 
\subsection{\textcolor{Chapter }{\texttt{TrivialProjectiveGroup}}}\label{TrivialProjectiveGroup}
\logpage{[ 3, 3, 1 ]}
\hyperdef{L}{X814A92C48174540D}{}
{
  This method is successful if and only if all generators of a projective group \mbox{\texttt{\mdseries\slshape G}} are equal to the identity (that is, in the matrix representation of \mbox{\texttt{\mdseries\slshape G}}, all matrices are scalars). Otherwise, it returns \texttt{false}. }

 
\subsection{\textcolor{Chapter }{\texttt{ProjDeterminant}}}\label{ProjDeterminant}
\logpage{[ 3, 3, 2 ]}
\hyperdef{L}{X7B8A3F4781278CEF}{}
{
  The method defines a homomorphism from a projective group \mbox{\texttt{\mdseries\slshape G}}$ \le PGL(d,q)$ to the cyclic group $GF(q)^*/D$, where $D$ is the set of $d$th powers in $GF(q)^*$. The image of a group element $g \in \mbox{\texttt{\mdseries\slshape G}}$ is the determinant of a matrix representative of $g$, modulo $D$. }

 
\subsection{\textcolor{Chapter }{\texttt{ReducibleIso}}}\label{ReducibleIsoProj}
\logpage{[ 3, 3, 3 ]}
\hyperdef{L}{X8499282F7825D28C}{}
{
  This method is the same as the matrix group method with the same name (see \ref{ReducibleIso}), which is able to take into account the projective mode. }

 
\subsection{\textcolor{Chapter }{\texttt{BlocksModScalars}}}\label{BlocksModScalars}
\logpage{[ 3, 3, 4 ]}
\hyperdef{L}{X803E531C83954EC5}{}
{
  This method is only called when hinted from above. In this method it is
understood that G should \emph{neither} be recognised as a matrix group \emph{nor} as a projective group. Rather, it treats all diagonal blocks modulo scalars
which means that two matrices are considered to be equal, if they differ only
by a scalar factor in \emph{corresponding} diagonal blocks, and this scalar can be different for each diagonal block.
This means that the kernel of the homomorphism mapping to a node which is
recognised using this method will have only scalar matrices in all diagonal
blocks. 

 This method does the balanced tree approach mapping to subsets of the diagonal
blocks and finally using projective recognition to recognise single diagonal
block groups. }

 
\subsection{\textcolor{Chapter }{\texttt{NotAbsolutelyIrred}}}\label{NotAbsolutelyIrred}
\logpage{[ 3, 3, 5 ]}
\hyperdef{L}{X83737D087B53188A}{}
{
  If an irreducible projective group \mbox{\texttt{\mdseries\slshape G}} acts absolutely irreducibly then this method returns \texttt{false}. If \mbox{\texttt{\mdseries\slshape G}} is not absolutely irreducible then a homomorphism into a smaller dimensional
representation over an extension field is defined. A hint is handed down to
the image that no test for absolute irreducibility has to be done any more.
Another hint is handed down to the kernel indicating that the only possible
kernel elements can be elements in the centraliser of \mbox{\texttt{\mdseries\slshape G}} in $PGL(d,q)$ that come from scalar matrices in the extension field. }

 
\subsection{\textcolor{Chapter }{\texttt{Subfield}}}\label{Subfield}
\logpage{[ 3, 3, 6 ]}
\hyperdef{L}{X80EA5C7580235817}{}
{
  When this method runs it knows that the projective group \mbox{\texttt{\mdseries\slshape G}} acts absolutely irreducibly. It then tries to realise this group over a
smaller field. The algorithm used is the one using the ``standard basis approach'' known from isomorphism testing of absolutely irreducible modules. It finds a
base change to write the projective group over the smallest field possible.
Since the group is projective, it may choose to multiply generators with
arbitrary scalars to write them over a smaller field. 

 However, sometimes the correct scalar can not be guessed. Therefore, if the
first approach does not work, the method computes the derived subgroup. If the
group can be written over a smaller field, then taking commutators loses the
scalars preventing a direct base change to work. Therefore, if the derived
subgroup still acts irreducibly, the standard basis approach can find the
right base change that could also do the job for the whole group. If it acts
reducibly, the method \texttt{Derived} (see \ref{Derived}) which is run next already has the computed derived subgroup and can try
different things to find a reduction. }

 
\subsection{\textcolor{Chapter }{\texttt{Derived}}}\label{Derived}
\logpage{[ 3, 3, 7 ]}
\hyperdef{L}{X7B46C2848668373B}{}
{
  This method computes the derived subgroup, if this has not yet been done by
other methods. It then uses the MeatAxe to decide whether the derived subgroup
acts irreducibly or not. If it acts reducibly, then we can apply Clifford
theory to the natural module. The natural module restricted to the derived
subgroup is a direct sum of simple modules. If all the summands are
isomorphic, we immediately get either an action of \mbox{\texttt{\mdseries\slshape G}} on blocks or a tensor decomposition. Otherwise, we get an action of \mbox{\texttt{\mdseries\slshape G}} on the isotypic components. Either way, we find a reduction. 

 If the derived group acts irreducibly, we return \texttt{false} in the current implementation. }

 
\subsection{\textcolor{Chapter }{\texttt{LowIndex}}}\label{LowIndex}
\logpage{[ 3, 3, 8 ]}
\hyperdef{L}{X86BAC96E7BA6E699}{}
{
  This method is designed for the handling of the Aschbacher class C2
(stabiliser of a decomposition of the underlying vector space), but may
succeed on other types of input as well. Given \mbox{\texttt{\mdseries\slshape G}} $ \le PGL(d,q)$, the output is either the permutation action of \mbox{\texttt{\mdseries\slshape G}} on a short orbit of subspaces or \texttt{fail}. In the current setup, ``short orbit'' is defined to have length at most $4d$. }

 
\subsection{\textcolor{Chapter }{\texttt{C6}}}\label{C6}
\logpage{[ 3, 3, 9 ]}
\hyperdef{L}{X8010C98580729238}{}
{
  This method is designed for the handling of the Aschbacher class C6
(normaliser of an extraspecial group). If the input \mbox{\texttt{\mdseries\slshape G}}$\le PGL(d,q)$ does not satisfy $d=r^n$ and $r|q-1$ for some prime $r$ and integer $n$ then the method returns \texttt{false}. Otherwise, it returns either a homomorphism of \mbox{\texttt{\mdseries\slshape G}} into $Sp(2n,r)$, or a homomorphism into the C2 permutation action of \mbox{\texttt{\mdseries\slshape G}} on a decomposition of $GF(q)^d$, or \texttt{fail}. }

 
\subsection{\textcolor{Chapter }{\texttt{Tensor}}}\label{Tensor}
\logpage{[ 3, 3, 10 ]}
\hyperdef{L}{X8750385D847D5C24}{}
{
  This method currently tries to find one tensor factor by powering up
commutators of random elements to elements of prime order. This seems to work
quite well provided that the two tensor factors are not ``linked'' too much such that there exist enough elements that act with different orders
on both tensor factors. 

 This method and its description needs some improvement. }

 
\subsection{\textcolor{Chapter }{\texttt{TwoLargeElOrders}}}\label{TwoLargeElOrders}
\logpage{[ 3, 3, 11 ]}
\hyperdef{L}{X856A17D787B6435D}{}
{
  In the case when the input group \mbox{\texttt{\mdseries\slshape G}}$ \le PGL(d,p^e)$ is suspected to be simple but not alternating, this method takes the two
largest element orders from a sample of pseudorandom elements of \mbox{\texttt{\mdseries\slshape G}}. From these element orders, it tries to determine whether \mbox{\texttt{\mdseries\slshape G}} is of Lie type or sporadic, and the characteristic of \mbox{\texttt{\mdseries\slshape G}} if it is of Lie type. In the case when \mbox{\texttt{\mdseries\slshape G}} is of Lie type of characteristic different from $p$ or \mbox{\texttt{\mdseries\slshape G}} is sporadic, the method also provides a short list of the possible isomorphism
types of \mbox{\texttt{\mdseries\slshape G}}. }

 
\subsection{\textcolor{Chapter }{\texttt{StabilizerChain}}}\label{StabilizerChain}
\logpage{[ 3, 3, 12 ]}
\hyperdef{L}{X79CB567683B3A36F}{}
{
  This method computes a stabiliser chain and a base and strong generating set
using projective actions. This is a last resort method since for bigger
examples no short orbits can be found in the natural action. The strong
generators are the nice generator in this case and expressing group elements
in terms of the nice generators ist just sifting along the stabiliser chain. }

 
\subsection{\textcolor{Chapter }{\texttt{BlockScalarProj}}}\label{BlockScalarProj}
\logpage{[ 3, 3, 13 ]}
\hyperdef{L}{X7BFA205981277BD5}{}
{
  This method is only called by a hint. Alongside with the hint it gets a block
decomposition respected by the matrix group \mbox{\texttt{\mdseries\slshape G}} to be recognised and the promise, that all diagonal blocks of all group
elements will only be scalar matrices. This method simply norms the last
diagonal block in all generators by multiplying with a scalar and then
delegates to \texttt{BlockScalar} (see \ref{BlockScalar}) and matrix group mode to do the recognition. }

 }

 
\section{\textcolor{Chapter }{Methods for black box groups}}\label{bbmethods}
\logpage{[ 3, 4, 0 ]}
\hyperdef{L}{X81DB42647E8FA7B6}{}
{
  }

  }

  
\chapter{\textcolor{Chapter }{Examples}}\label{examples}
\logpage{[ 4, 0, 0 ]}
\hyperdef{L}{X7A489A5D79DA9E5C}{}
{
  Here comes text.

  }

  \def\bibname{References\logpage{[ "Bib", 0, 0 ]}
\hyperdef{L}{X7A6F98FD85F02BFE}{}
}

\bibliographystyle{alpha}
\bibliography{recog}

\addcontentsline{toc}{chapter}{References}

\def\indexname{Index\logpage{[ "Ind", 0, 0 ]}
\hyperdef{L}{X83A0356F839C696F}{}
}

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Index}


\printindex

\newpage
\immediate\write\pagenrlog{["End"], \arabic{page}];}
\immediate\closeout\pagenrlog
\end{document}
