#############################################################################
##
#W  orbits.xml
#Y  Copyright (C) 2011-12                                James D. Mitchell
##
##  Licensing information can be found in the README file of this package.
##
#############################################################################
##

<#GAPDoc Label="GradedImagesOfTransSemigroup">
  <ManSection><Heading>Graded images and kernels</Heading>
  <Attr Name="GradedImagesOfTransSemigroup" Arg="S"/>
  <Attr Name="GradedKernelsOfTransSemigroup" Arg="S"/>
  <Returns>A list of images or kernels.</Returns>
  <Description>
  <C>GradedImagesOfTransSemigroup</C> returns a list where the <C>i</C>th 
  entry is a list of all the images of transformations in the
  transformation semigroup <A>S</A> with size 
  <C>i</C>.  
  <P/>
  
  <C>GradedKernelsOfTransSemigroup</C> returns a list where the <C>i</C>th 
  entry is a list of the values of <Ref Func="CanonicalTransSameKernel"/> for
  all transformations in <A>S</A> with rank <C>i</C>.
  <P/>

  See also <Ref Attr="ImagesOfTransSemigroup"/> and 
  <Ref Attr="KernelsOfTransSemigroup"/>.
  <Example>
gap> S:=Semigroup(Transformation( [ 1, 5, 1, 1, 1 ] ), 
> Transformation( [ 4, 4, 5, 2, 2 ] ));;
gap> GradedImagesOfTransSemigroup(S);
[ [ [ 1 ], [ 4 ], [ 2 ], [ 5 ] ], [ [ 1, 5 ], [ 2, 4 ] ], [ [ 2, 4, 5 ] ], 
  [  ], [  ] ]
gap> GradedKernelsOfTransSemigroup(S);
[ [ [ 1, 1, 1, 1, 1 ] ], [ [ 1, 2, 1, 1, 1 ], [ 1, 1, 1, 2, 2 ] ], 
  [ [ 1, 1, 2, 3, 3 ] ], [  ], [  ] ]</Example> 
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="ImagesOfTransSemigroup">
  <ManSection><Heading>Images and kernels</Heading>
  <Attr Name="ImagesOfTransSemigroup" Arg="S[, n]"/>
  <Attr Name="KernelsOfTransSemigroup" Arg="S[, n]"/>
  <Returns>An orbit.</Returns>
  <Description>
  The argument <A>S</A> should be a transformation semigroup and the optional
  second argument <A>n</A> should be a positive integer not greater than the
  degree of <A>S</A>.  <C>ImagesOfTransSemigroup</C> returns the  <Ref
    Func="Orb" BookName="orb"/> object: 
  <Log>Orb(S, [1..Degree(S)], OnSets);</Log> which contains the image sets of
  all the transformations belonging to <A>S</A>.  <P/>
  
  <C>KernelsOfTransSemigroup</C> returns the <Ref Func="Orb" BookName="orb"/>
  object: <Log>Orb(S, [1,..Degree(S)], OnKernelsAntiAction);</Log> <P/> If the
  optional second argument <A>n</A> (a positive integer) is present, then only
  the images or kernels of size at least <A>n</A> are found.<P/>
 
  Note that the image/kernel <C>[1..Degree(S)]</C> always occurs in both orbits
  even if there is no element of <A>S</A> with image/kernel equal to
  <C>[1..Degree(S)]</C>.<P/>

  See also <Ref Func="GradedImagesOfTransSemigroup"/>,
  <Ref Func="GradedKernelsOfTransSemigroup"/>,
  <Ref Func="OnKernelsAntiAction"/>, and 
  <Ref Func="CanonicalTransSameKernel"/>
  <Example>
gap>  S:=Semigroup( Transformation( [ 6, 4, 4, 4, 6, 1 ] ), 
> Transformation( [ 6, 5, 1, 6, 2, 2 ] ) );;
gap> o:=ImagesOfTransSemigroup(S, 6); Enumerate(o); AsList(o);
&lt;open orbit, 1 points with Schreier tree with grading>
&lt;closed orbit, 1 points with Schreier tree with grading>
[ [ 1 .. 6 ] ]
gap> o:=ImagesOfTransSemigroup(S, 5); Enumerate(o); AsList(o);
&lt;open orbit, 1 points with Schreier tree with grading>
&lt;closed orbit, 1 points with Schreier tree with grading>
[ [ 1 .. 6 ] ]
gap> o:=ImagesOfTransSemigroup(S, 4); Enumerate(o); AsList(o);
&lt;open orbit, 1 points with Schreier tree with grading>
&lt;closed orbit, 2 points with Schreier tree with grading>
[ [ 1 .. 6 ], [ 1, 2, 5, 6 ] ]
gap> o:=ImagesOfTransSemigroup(S, 3); Enumerate(o); AsList(o);
&lt;open orbit, 1 points with Schreier tree with grading>
&lt;closed orbit, 4 points with Schreier tree with grading>
[ [ 1 .. 6 ], [ 1, 4, 6 ], [ 1, 2, 5, 6 ], [ 2, 5, 6 ] ]
gap> o:=ImagesOfTransSemigroup(S, 2); Enumerate(o); AsList(o);
&lt;open orbit, 1 points with Schreier tree with grading>
&lt;closed orbit, 8 points with Schreier tree with grading>
[ [ 1 .. 6 ], [ 1, 4, 6 ], [ 1, 2, 5, 6 ], [ 2, 6 ], [ 2, 5, 6 ], [ 1, 4 ],
  [ 2, 5 ], [ 4, 6 ] ]
gap> o:=ImagesOfTransSemigroup(S, 1); Enumerate(o); AsList(o);
&lt;open orbit, 1 points with Schreier tree with grading>
&lt;closed orbit, 13 points with Schreier tree with grading>
[ [ 1 .. 6 ], [ 1, 4, 6 ], [ 1, 2, 5, 6 ], [ 2, 6 ], [ 2, 5, 6 ], [ 1, 4 ],
  [ 2, 5 ], [ 4, 6 ], [ 6 ], [ 1 ], [ 2 ], [ 4 ], [ 5 ] ]
gap> o:=ImagesOfTransSemigroup(S); Enumerate(o); AsList(o);
&lt;open orbit, 1 points with Schreier tree>
&lt;closed orbit, 13 points with Schreier tree>
[ [ 1 .. 6 ], [ 1, 4, 6 ], [ 1, 2, 5, 6 ], [ 2, 6 ], [ 2, 5, 6 ], [ 1, 4 ],
  [ 2, 5 ], [ 4, 6 ], [ 6 ], [ 1 ], [ 2 ], [ 4 ], [ 5 ] ]</Example>
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="OnKernelsAntiAction">
  <ManSection> 
    <Func Name="OnKernelsAntiAction" Arg="ker, f"/>
    <Returns>
      A list of positive integers. 
    </Returns>
    <Description>
    The argument <A>ker</A> should equal <C>CanonicalTransSameKernel(g);</C>
    for some transformation <C>g</C> with degree equal to the degree of the
    transformation <A>f</A>. 

    <C>OnKernelsAntiAction</C> returns <C>CanonicalTransSameKernel(f*g)</C>.
    See also <Ref Func="CanonicalTransSameKernel"/>.

    <Example>
gap> f:=Transformation( [ 3, 6, 9, 2, 4, 2, 2, 2, 8, 2 ] );;
gap> g:=Transformation( [ 7, 1, 4, 3, 2, 7, 7, 6, 6, 5 ] );;
gap> ker:=CanonicalTransSameKernel(f);
[ 1, 2, 3, 4, 5, 4, 4, 4, 6, 4 ]
gap> OnKernelsAntiAction(ker, g);
[ 1, 2, 1, 3, 4, 1, 1, 1, 1, 5 ]
gap> CanonicalTransSameKernel(g*f);
[ 1, 2, 1, 3, 4, 1, 1, 1, 1, 5 ]</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="OrbSCC">
  <ManSection>
    <Func Name="OrbSCC" Arg="o"/>
    <Returns>The strongly connected components of an orbit.</Returns>
    <Description>
      If <A>o</A> is an orbit created by the <Package>Orb</Package> package
      with the option <C>orbitgraph=true</C>, then <C>OrbSCC</C> returns a set
      of sets of positions in <A>o</A> corresponding to its strongly connected
      components. <P/>

      See also <Ref Func="OrbSCCLookup"/> and <Ref Func="OrbSCCTruthTable"/>.

<Example>
gap> S:=FullTransformationSemigroup(4);;
gap> o:=ImagesOfTransSemigroup(S);;
gap> OrbSCC(o);
[ [ 1 ], [ 2, 3, 4, 5 ], [ 6, 7, 8, 9, 10, 11 ], [ 12, 13, 14, 15 ] ]</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="OrbSCCLookup">
  <ManSection>
    <Func Name="OrbSCCLookup" Arg="o"/>
    <Returns>A lookup table for the strongly connected components of an orbit.
    </Returns>
    <Description>
      If <A>o</A> is an orbit created by the <Package>Orb</Package> package
      with the option <C>orbitgraph=true</C>, then <C>OrbSCCLookup</C> returns
      a lookup table for its strongly connected components. More precisely,
      <C>OrbSCCLookup(o)[i]</C> equals the index of the strongly connected
      component containing <C>o[i]</C>.  <P/>

      See also <Ref Func="OrbSCC"/> and <Ref Func="OrbSCCTruthTable"/>.
      
<Example>
gap> S:=FullTransformationSemigroup(4);;
gap> o:=ImagesOfTransSemigroup(S);;
gap> OrbSCC(o);
[ [ 1 ], [ 2, 3, 4, 5 ], [ 6, 7, 8, 9, 10, 11 ], [ 12, 13, 14, 15 ] ]
gap> OrbSCCLookup(o);
[ 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4 ]
gap> OrbSCCLookup(o)[1]; OrbSCCLookup(o)[4]; OrbSCCLookup(o)[7]; 
1
2
3</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="OrbSCCTruthTable">
  <ManSection>
    <Func Name="OrbSCCTruthTable" Arg="o"/>
    <Returns>Truth tables for strongly connected components of an orbit.
    </Returns>
    <Description>
      If <A>o</A> is an orbit created by the <Package>Orb</Package> package
      with the option <C>orbitgraph=true</C>, then <C>OrbSCCTruthTable</C>
      returns a list of boolean lists such that
      <C>OrbSCCTruthTable(o)[i][j]</C> is <K>true</K> if <C>j</C> belongs to
      <C>OrbSCC(o)[i]</C>.<P/>

      See also <Ref Func="OrbSCC"/> and <Ref Func="OrbSCCLookup"/>.

<Example>
gap> S:=FullTransformationSemigroup(4);;
gap> o:=ImagesOfTransSemigroup(S);;
gap> OrbSCC(o);
[ [ 1 ], [ 2, 3, 4, 5 ], [ 6, 7, 8, 9, 10, 11 ], [ 12, 13, 14, 15 ] ]
gap> OrbSCCTruthTable(o);
[ [ true, false, false, false, false, false, false, false, false, false, 
      false, false, false, false, false ], 
  [ false, true, true, true, true, false, false, false, false, false, false, 
      false, false, false, false ], 
  [ false, false, false, false, false, true, true, true, true, true, true, 
      false, false, false, false ], 
  [ false, false, false, false, false, false, false, false, false, false, 
      false, true, true, true, true ] ]</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="ReverseSchreierTreeOfSCC">
  <ManSection>
    <Func Name="ReverseSchreierTreeOfSCC" Arg="o, i"/>
    <Returns>The reverse Schreier tree corresponding to the <A>i</A>th strongly
    connected component of an orbit. 
    </Returns>
    <Description> 
    If <A>o</A> is an orbit created by the <Package>Orb</Package> package with
    the option <C>orbitgraph=true</C> and action <C>act</C>, and <A>i</A> is a
    positive integer, then <C>ReverseSchreierTreeOfSCC(<A>o</A>, <A>i</A>)</C>
    returns a pair <C>[ gen, pos ]</C> of lists with <C>Length(o)</C> entries
    such that <Log>act(o[j], o!.gens[gen[j]])=o[pos[j]].</Log> The pair <C>[
    gen, pos ]</C> corresponds to a tree with root <C>OrbSCC(o)[i][1]</C> and a
    path from every element of <C>OrbSCC(o)[i]</C> to the root. <P/>

    See also <Ref Func="OrbSCC"/>, <Ref Func="TraceSchreierTreeOfSCCBack"/>, 
    <Ref Func="SchreierTreeOfSCC"/>, and 
    <Ref Func="TraceSchreierTreeOfSCCForward"/>.
<Example>
gap> S:=Semigroup(Transformation( [ 2, 2, 1, 4, 4 ] ), 
> Transformation( [ 3, 3, 3, 4, 5 ] ),
> Transformation( [ 5, 1, 4, 5, 5 ] ) );;
gap> o:=Orb(S, [1..4], OnSets, rec(orbitgraph:=true, schreier:=true));;
gap> OrbSCC(o);
[ [ 1 ], [ 2 ], [ 3, 5, 6, 7, 11 ], [ 4 ], [ 8 ], [ 9 ], [ 10, 12 ] ]
gap> ReverseSchreierTreeOfSCC(o, 3);
[ [ fail, fail, fail, fail, 2, 1, 2, fail, fail, fail, 1, fail ], 
  [ fail, fail, fail, fail, 3, 5, 3, fail, fail, fail, 7, fail ] ]
gap> ReverseSchreierTreeOfSCC(o, 7);
[ [ fail, fail, fail, fail, fail, fail, fail, fail, fail, fail, fail, 3 ], 
  [ fail, fail, fail, fail, fail, fail, fail, fail, fail, fail, fail, 10 ] ]
gap> OnSets(o[11], Generators(S)[1]);
[ 1, 4 ]
gap> Position(o, last);
7</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="SchreierTreeOfSCC">
  <ManSection>
    <Func Name="SchreierTreeOfSCC" Arg="o, i"/>
    <Returns>The Schreier tree corresponding to the <A>i</A>th strongly
    connected component of an orbit. </Returns>

    <Description> 
    If <A>o</A> is an orbit created by the <Package>Orb</Package> package with
    the option <C>orbitgraph=true</C> and action <C>act</C>, and <A>i</A> is a
    positive integer, then <C>SchreierTreeOfSCC(<A>o</A>, <A>i</A>)</C> returns
    a pair <C>[ gen, pos ]</C> of lists with <C>Length(o)</C> entries such that
    <Log>act(o[pos[j]], o!.gens[gen[j]])=o[j].</Log> The pair <C>[ gen, pos
    ]</C> corresponds to a tree with root <C>OrbSCC(o)[i][1]</C> and a path
    from the root to every element of <C>OrbSCC(o)[i]</C>. <P/>

    See also <Ref Func="OrbSCC"/>, <Ref Func="TraceSchreierTreeOfSCCBack"/>, 
    <Ref Func="ReverseSchreierTreeOfSCC"/>, and 
    <Ref Func="TraceSchreierTreeOfSCCForward"/>.
<Example>
gap> S:=Semigroup(Transformation( [ 2, 2, 1, 4, 4 ] ), 
> Transformation( [ 3, 3, 3, 4, 5 ] ),
> Transformation( [ 5, 1, 4, 5, 5 ] ) );;
gap> o:=Orb(S, [1..4], OnSets, rec(orbitgraph:=true, schreier:=true));;
gap> OrbSCC(o);
[ [ 1 ], [ 2 ], [ 3, 5, 6, 7, 11 ], [ 4 ], [ 8 ], [ 9 ], [ 10, 12 ] ]
gap> SchreierTreeOfSCC(o, 3);
[ [ fail, fail, fail, fail, 1, 3, 1, fail, fail, fail, 2, fail ], 
  [ fail, fail, fail, fail, 7, 5, 3, fail, fail, fail, 6, fail ] ]
gap> SchreierTreeOfSCC(o, 7);
[ [ fail, fail, fail, fail, fail, fail, fail, fail, fail, fail, fail, 1 ], 
  [ fail, fail, fail, fail, fail, fail, fail, fail, fail, fail, fail, 10 ] ]
gap> OnSets(o[6], Generators(S)[2]);
[ 3, 5 ]
gap> Position(o, last);
11</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="TraceSchreierTreeOfSCCBack"/>
  <ManSection> 
    <Func Name="TraceSchreierTreeOfSCCBack" Arg="orb, m, nr"/>
    <Returns>A word in the generators.</Returns>
    <Description>
    <A>orb</A>  must  be  an  orbit  object  with  a Schreier tree and orbit
    graph, that is, the options <C>schreier</C> and <C>orbitgraph</C> must have
    been set to <K>true</K> during the creation of the orbit, <A>m</A> must be
    the number of a strongly connected component of <A>orb</A>, and <C>nr</C>
    must be the number of a point in  the  <A>m</A>th strongly connect
    component of <A>orb</A>. This operation traces the result of <Ref
    Func="ReverseSchreierTreeOfSCC"/> and with arguments <A>orb</A> and
    <A>m</A> and returns a word in the generators that maps the point with
    number <A>nr</A> to the first point in the <A>m</A>th strongly connected
    component of <A>orb</A>.  Here, a word is a list of integers, where
    positive integers are numbers of  generators.

    See also <Ref Func="OrbSCC"/>,<Ref Func="EvaluateWord"/>, 
    <Ref Func="ReverseSchreierTreeOfSCC"/>, 
    <Ref Func="SchreierTreeOfSCC"/>, and 
    <Ref Func="TraceSchreierTreeOfSCCForward"/>.
    <Example>
gap> S:=Semigroup(Transformation( [ 1, 3, 4, 1 ] ), 
> Transformation( [ 2, 4, 1, 2 ] ),
> Transformation( [ 3, 1, 1, 3 ] ), 
> Transformation( [ 3, 3, 4, 1 ] ) );;
gap> o:=Orb(S, [1..4], OnSets, rec(orbitgraph:=true, schreier:=true));;
gap> OrbSCC(o);
[ [ 1 ], [ 2 ], [ 3 ], [ 4, 5, 6, 7, 8 ], [ 9, 10, 11, 12 ] ]
gap> ReverseSchreierTreeOfSCC(o, 4);               
[ [ fail, fail, fail, fail, 4, 1, 1, 3, fail, fail, fail, fail ], 
  [ fail, fail, fail, fail, 4, 4, 4, 4, fail, fail, fail, fail ] ]
gap> TraceSchreierTreeOfSCCBack(o, 4, 7);
[ 1 ]
gap> TraceSchreierTreeOfSCCBack(o, 4, 8);
[ 3 ]</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="TraceSchreierTreeOfSCCForward"/>
  <ManSection> 
    <Func Name="TraceSchreierTreeOfSCCForward" Arg="orb, m, nr"/>
    <Returns>A word in the generators.</Returns>
    <Description>
    <A>orb</A>  must  be  an  orbit  object  with  a Schreier tree and orbit
    graph, that is, the options <C>schreier</C> and <C>orbitgraph</C> must have
    been set to <K>true</K> during the creation of the orbit, <A>m</A> must be
    the number of a strongly connected component of <A>orb</A>, and <C>nr</C>
    must be the number of a point in  the  <A>m</A>th strongly connect
    component of <A>orb</A>. This operation traces the result of <Ref
    Func="SchreierTreeOfSCC"/> and with arguments <A>orb</A> and <A>m</A> and
    returns a word in the generators that maps the first point in the
    <A>m</A>th strongly connected component of <A>orb</A> to the point with
    number <A>nr</A>.  Here, a word is a list of integers, where positive
    integers are numbers of  generators.

    See also <Ref Func="OrbSCC"/>, <Ref Func="EvaluateWord"/>, 
    <Ref Func="ReverseSchreierTreeOfSCC"/>, 
    <Ref Func="SchreierTreeOfSCC"/>, and 
    <Ref Func="TraceSchreierTreeOfSCCBack"/>.
    <Example>
gap> S:=Semigroup(Transformation( [ 1, 3, 4, 1 ] ), 
> Transformation( [ 2, 4, 1, 2 ] ),
> Transformation( [ 3, 1, 1, 3 ] ), 
> Transformation( [ 3, 3, 4, 1 ] ) );;
gap> o:=Orb(S, [1..4], OnSets, rec(orbitgraph:=true, schreier:=true));;
gap> OrbSCC(o);
[ [ 1 ], [ 2 ], [ 3 ], [ 4, 5, 6, 7, 8 ], [ 9, 10, 11, 12 ] ]
gap> SchreierTreeOfSCC(o, 4);
[ [ fail, fail, fail, fail, 1, 2, 2, 4, fail, fail, fail, fail ], 
  [ fail, fail, fail, fail, 4, 4, 6, 4, fail, fail, fail, fail ] ]
gap> TraceSchreierTreeOfSCCForward(o, 4, 8);
[ 4 ]
gap> TraceSchreierTreeOfSCCForward(o, 4, 7);
[ 2, 2 ]</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="TransformationActionNC"/>
<ManSection>
  <Oper Name="TransformationActionNC" Arg="obj, list, func"/>
  <Returns>A transformation or collection of transformations.</Returns>
  <Description>
    If <A>obj</A> is a &GAP; object that acts on the list <A>list</A> via the
    function <A>func</A>, then <C>TransformationActionNC</C> returns this
    action as a transformation; see also <Ref Func="Transformation"
      BookName="ref"/>. Mathematically, the argument <A>obj</A> should be an 
    element of a semigroup so that the action of <A>obj</A> on <A>list</A> via
    <A>func</A> is a <B>semigroup action</B>. However, it is not
    technically necessary for <A>obj</A> to be an element of a semigroup in
    &GAP;. <P/>

    If <A>obj</A> is a semigroup, then <C>TransformationActionNC</C> returns
    the list obtained from applying <C>TransformationActionNC</C> to every
    generator of <A>obj</A>.

    <Example>
gap> mat:=OneMutable(GeneratorsOfGroup(GL(3,3))[1]);
[ [ Z(3)^0, 0*Z(3), 0*Z(3) ], [ 0*Z(3), Z(3)^0, 0*Z(3) ],
  [ 0*Z(3), 0*Z(3), Z(3)^0 ] ]
gap> mat[3][3]:=Z(3)*0;
0*Z(3)
gap> F:=BaseDomain(mat);
GF(3)
gap> TransformationActionNC(mat, Elements(F^3), OnRight);
Transformation( [ 1, 1, 1, 4, 4, 4, 7, 7, 7, 10, 10, 10, 13, 13, 13, 16, 16,
  16, 19, 19, 19, 22, 22, 22, 25, 25, 25 ] )</Example>
  </Description>
</ManSection>
<#/GAPDoc>

