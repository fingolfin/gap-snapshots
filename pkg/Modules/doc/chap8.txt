  
  [1X8 Maps[0X
  
  A  [5Xhomalg[0m  map  is a data structures for maps (module homomorphisms) between
  finitely  generated modules. Each map in [5Xhomalg[0m knows its source (--> [2XSource[0m
  ([14Xhomalg:  Source[0m))  and  its  target  (-->  [2XRange[0m ([14Xhomalg: Range[0m)). A map is
  represented  by a [5Xhomalg[0m matrix relative to the current set of generators of
  the source resp. target [5Xhomalg[0m module. As with modules (--> Chapter [14X7[0m), maps
  in  [5Xhomalg[0m  are realized in an intrinsic manner: If the presentations of the
  source or/and target module are altered after the map was constructed, a new
  adapted  representation matrix of the map is automatically computed whenever
  needed.  For  this the internal transition matrices of the modules are used.
  [5Xhomalg[0m  uses  the so-called [13Xassociative[0m convention for maps. This means that
  maps  of  left  modules  are  applied  from the right, whereas maps of right
  modules from the left.
  
  
  [1X8.1 Maps: Categories and Representations[0X
  
  [1X8.1-1 IsHomalgMap[0m
  
  [2X> IsHomalgMap( [0X[3Xphi[0X[2X ) _______________________________________________[0XCategory
  [6XReturns:[0X  [10Xtrue[0m or [10Xfalse[0m
  
  The [5XGAP[0m category of [5Xhomalg[0m maps.
  
  (It   is  a  subcategory  of  the  [5XGAP[0m  categories  [10XIsHomalgModuleOrMap[0m  and
  [10XIsHomalgStaticMorphism[0m.)
  
  [4X-----------------------------  Code  -----------------------------[0X
    [4XDeclareCategory( "IsHomalgMap",[0X
    [4X        IsHomalgModuleOrMap and[0X
    [4X        IsHomalgStaticMorphism );[0X
  [4X------------------------------------------------------------------[0X
  
  [1X8.1-2 IsHomalgSelfMap[0m
  
  [2X> IsHomalgSelfMap( [0X[3Xphi[0X[2X ) ___________________________________________[0XCategory
  [6XReturns:[0X  [10Xtrue[0m or [10Xfalse[0m
  
  The [5XGAP[0m category of [5Xhomalg[0m self-maps.
  
  (It   is   a   subcategory   of   the   [5XGAP[0m   categories   [10XIsHomalgMap[0m   and
  [10XIsHomalgEndomorphism[0m.)
  
  [4X-----------------------------  Code  -----------------------------[0X
    [4XDeclareCategory( "IsHomalgSelfMap",[0X
    [4X        IsHomalgMap and[0X
    [4X        IsHomalgEndomorphism );[0X
  [4X------------------------------------------------------------------[0X
  
  [1X8.1-3 IsMapOfFinitelyGeneratedModulesRep[0m
  
  [2X> IsMapOfFinitelyGeneratedModulesRep( [0X[3Xphi[0X[2X ) __________________[0XRepresentation
  [6XReturns:[0X  [10Xtrue[0m or [10Xfalse[0m
  
  The [5XGAP[0m representation of maps between finitley generated [5Xhomalg[0m modules.
  
  (It  is  a representation of the [5XGAP[0m category [2XIsHomalgChainMorphism[0m ([14Xhomalg:
  IsHomalgChainMorphism[0m),   which   is   a   subrepresentation   of   the  [5XGAP[0m
  representation [10XIsStaticMorphismOfFinitelyGeneratedObjectsRep[0m.)
  
  
  [1X8.2 Maps: Constructors[0X
  
  [1X8.2-1 HomalgMap[0m
  
  [2X> HomalgMap( [0X[3Xmat, M, N[0X[2X ) ___________________________________________[0Xfunction
  [2X> HomalgMap( [0X[3Xmat[, string][0X[2X ) _______________________________________[0Xfunction
  [6XReturns:[0X  a [5Xhomalg[0m map
  
  This constructor returns a map (homomorphism) of finitely presented modules.
  It  is  represented  by the [5Xhomalg[0m matrix [3Xmat[0m relative to the current set of
  generators  of  the  source  [5Xhomalg[0m  module [3XM[0m and target module [3XN[0m (--> [14X7.2[0m).
  Unless  the  source module is free [13Xand[0m given on free generators the returned
  map  will  cautiously  be  indicated  using  parenthesis: "homomorphism". To
  verify  if  the  result is indeed a well defined map use [2XIsMorphism[0m ([14Xhomalg:
  IsMorphism[0m).  If  the  presentations  of the source or/and target module are
  altered  after  the map was constructed, a new adapted representation matrix
  of  the map is automatically computed whenever needed. For this the internal
  transition  matrices  of  the  modules  are  used.  If source and target are
  identical  objects,  and  only  then,  the  map  is  created  as  a  selfmap
  (endomorphism).  [5Xhomalg[0m  uses the so-called [13Xassociative[0m convention for maps.
  This  means  that  maps  of left modules are applied from the right, whereas
  maps of right modules from the left.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> ZZ := HomalgRingOfIntegers( );;[0X
    [4Xgap> M := HomalgMatrix( "[ 2, 3, 4,   5, 6, 7 ]", 2, 3, ZZ );[0X
    [4X<A 2 x 3 matrix over an internal ring>[0X
    [4Xgap> M := LeftPresentation( M );[0X
    [4X<A non-torsion left module presented by 2 relations for 3 generators>[0X
    [4Xgap> N := HomalgMatrix( "[ 2, 3, 4, 5,   6, 7, 8, 9 ]", 2, 4, ZZ );[0X
    [4X<A 2 x 4 matrix over an internal ring>[0X
    [4Xgap> N := LeftPresentation( N );[0X
    [4X<A non-torsion left module presented by 2 relations for 4 generators>[0X
    [4Xgap> mat := HomalgMatrix( "[ \[0X
    [4X> 1, 0, -2, -4, \[0X
    [4X> 0, 1,  4,  7, \[0X
    [4X> 1, 0, -2, -4  \[0X
    [4X> ]", 3, 4, ZZ );;[0X
    [4X<A 3 x 4 matrix over an internal ring>[0X
    [4Xgap> phi := HomalgMap( mat, M, N );[0X
    [4X<A "homomorphism" of left modules>[0X
    [4Xgap> IsMorphism( phi );[0X
    [4Xtrue[0X
    [4Xgap> phi;[0X
    [4X<A homomorphism of left modules>[0X
    [4Xgap> Display( phi );[0X
    [4X[ [   1,   0,  -2,  -4 ],[0X
    [4X  [   0,   1,   4,   7 ],[0X
    [4X  [   1,   0,  -2,  -4 ] ][0X
    [4X[0X
    [4Xthe map is currently represented by the above 3 x 4 matrix[0X
    [4Xgap> ByASmallerPresentation( M );[0X
    [4X<A rank 1 left module presented by 1 relation for 2 generators>[0X
    [4Xgap> Display( last );[0X
    [4XZ/< 3 > + Z^(1 x 1)[0X
    [4Xgap> Display( phi );[0X
    [4X[ [   2,   1,   0,  -1 ],[0X
    [4X  [   1,   0,  -2,  -4 ] ][0X
    [4X[0X
    [4Xthe map is currently represented by the above 2 x 4 matrix[0X
    [4Xgap> ByASmallerPresentation( N );[0X
    [4X<A rank 2 left module presented by 1 relation for 3 generators>[0X
    [4Xgap> Display( N );[0X
    [4XZ/< 4 > + Z^(1 x 2)[0X
    [4Xgap> Display( phi );[0X
    [4X[ [  -8,   0,   0 ],[0X
    [4X  [  -3,  -1,  -2 ] ][0X
    [4X[0X
    [4Xthe map is currently represented by the above 2 x 3 matrix[0X
    [4Xgap> ByASmallerPresentation( phi );[0X
    [4X<A non-zero homomorphism of left modules>[0X
    [4Xgap> Display( phi );[0X
    [4X[ [   0,   0,   0 ],[0X
    [4X  [   1,  -1,  -2 ] ][0X
    [4X[0X
    [4Xthe map is currently represented by the above 2 x 3 matrix[0X
  [4X------------------------------------------------------------------[0X
  
  To construct a map with source being a not yet specified free module
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> N;[0X
    [4X<A rank 2 left module presented by 1 relation for 3 generators>[0X
    [4Xgap> SetPositionOfTheDefaultSetOfGenerators( N, 1 );[0X
    [4Xgap> N;[0X
    [4X<A rank 2 left module presented by 2 relations for 4 generators>[0X
    [4Xgap> psi := HomalgMap( mat, "free", N );[0X
    [4X<A homomorphism of left modules>[0X
    [4Xgap> Source( psi );[0X
    [4X<A free left module of rank 3 on free generators>[0X
  [4X------------------------------------------------------------------[0X
  
  To construct a map between not yet specified free left modules
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> chi := HomalgMap( mat );	## or chi := HomalgMap( mat, "l" );[0X
    [4X<A homomorphism of left modules>[0X
    [4Xgap> Source( chi );[0X
    [4X<A free left module of rank 3 on free generators>[0X
    [4Xgap> Range( chi );[0X
    [4X<A free left module of rank 4 on free generators>[0X
  [4X------------------------------------------------------------------[0X
  
  To construct a map between not yet specified free right modules
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> kappa := HomalgMap( mat, "r" );[0X
    [4X<A homomorphism of right modules>[0X
    [4Xgap> Source( kappa );[0X
    [4X<A free right module of rank 4 on free generators>[0X
    [4Xgap> Range( kappa );[0X
    [4X<A free right module of rank 3 on free generators>[0X
  [4X------------------------------------------------------------------[0X
  
  [1X8.2-2 HomalgZeroMap[0m
  
  [2X> HomalgZeroMap( [0X[3XM, N[0X[2X ) ____________________________________________[0Xfunction
  [6XReturns:[0X  a [5Xhomalg[0m map
  
  The  constructor returns the zero map between the source [5Xhomalg[0m module [3XM[0m and
  the target [5Xhomalg[0m module [3XN[0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> ZZ := HomalgRingOfIntegers( );;[0X
    [4Xgap> M := HomalgMatrix( "[ 2, 3, 4,   5, 6, 7 ]", 2, 3, ZZ );[0X
    [4X<A 2 x 3 matrix over an internal ring>[0X
    [4Xgap> M := LeftPresentation( M );[0X
    [4X<A non-torsion left module presented by 2 relations for 3 generators>[0X
    [4Xgap> N := HomalgMatrix( "[ 2, 3, 4, 5,   6, 7, 8, 9 ]", 2, 4, ZZ );[0X
    [4X<A 2 x 4 matrix over an internal ring>[0X
    [4Xgap> N := LeftPresentation( N );[0X
    [4X<A non-torsion left module presented by 2 relations for 4 generators>[0X
    [4Xgap> HomalgZeroMap( M, N );[0X
    [4X<The zero morphism of left modules>[0X
  [4X------------------------------------------------------------------[0X
  
  [1X8.2-3 HomalgIdentityMap[0m
  
  [2X> HomalgIdentityMap( [0X[3XM, N[0X[2X ) ________________________________________[0Xfunction
  [6XReturns:[0X  a [5Xhomalg[0m map
  
  The constructor returns the identity map of the [5Xhomalg[0m module [3XM[0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> ZZ := HomalgRingOfIntegers( );;[0X
    [4Xgap> M := HomalgMatrix( "[ 2, 3, 4,   5, 6, 7 ]", 2, 3, ZZ );[0X
    [4X<A 2 x 3 matrix over an internal ring>[0X
    [4Xgap> M := LeftPresentation( M );[0X
    [4X<A non-torsion left module presented by 2 relations for 3 generators>[0X
    [4Xgap> HomalgIdentityMap( M );[0X
    [4X<The identity morphism of a non-zero left module>[0X
  [4X------------------------------------------------------------------[0X
  
  
  [1X8.3 Maps: Properties[0X
  
  
  [1X8.4 Maps: Attributes[0X
  
  [1X8.4-1 DegreeOfMorphism[0m
  
  [2X> DegreeOfMorphism( [0X[3Xphi[0X[2X ) _________________________________________[0Xattribute
  [6XReturns:[0X  an integer
  
  The degree of the morphism [3Xphi[0m of graded modules.
  (no method installed)
  
  
  [1X8.5 Maps: Operations and Functions[0X
  
  [1X8.5-1 HomalgRing[0m
  
  [2X> HomalgRing( [0X[3Xphi[0X[2X ) _______________________________________________[0Xoperation
  [6XReturns:[0X  a [5Xhomalg[0m ring
  
  The [5Xhomalg[0m ring of the [5Xhomalg[0m map [3Xphi[0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> ZZ := HomalgRingOfIntegers( );[0X
    [4XZ[0X
    [4Xgap> phi := HomalgIdentityMap( 2 * ZZ );[0X
    [4X<The identity morphism of a non-zero left module>[0X
    [4Xgap> R := HomalgRing( phi );[0X
    [4XZ[0X
    [4Xgap> IsIdenticalObj( R, ZZ );[0X
    [4Xtrue[0X
  [4X------------------------------------------------------------------[0X
  
  [1X8.5-2 PreInverse[0m
  
  [2X> PreInverse( [0X[3Xphi[0X[2X ) _______________________________________________[0Xoperation
  [6XReturns:[0X  a [5Xhomalg[0m map, [10Xfalse[0m, or [10Xfail[0m
  
  Compute  a  pre-inverse  of  the  morphism  [3Xphi[0m  in  case  one exists. For a
  pre-inverse  to  exist  [3Xphi[0m  must  be  an epimorphism. For [13Xcommutative[0m rings
  [5Xhomalg[0m  has an algorithm installed which decides the existence and returns a
  pre-inverse  in  case one exists. If a pre-inverse does not exist then [10Xfalse[0m
  is  returned.  The  algorithm  finds  a  particular  solution  of a two-side
  inhomogeneous  linear  system over R :=[10XHomalgRing[0m( [3Xphi[0m ). For [13Xnon[0mcommutative
  rings  a heuristic method is installed. If it finds a pre-inverse it returns
  it,  otherwise it returns [10Xfail[0m (--> [14X1.1-3[0m). The operation [10XPreInverse[0m is used
  to   install   a   method   for  the  property  [2XIsSplitEpimorphism[0m  ([14Xhomalg:
  IsSplitEpimorphism[0m).
  
  [10XPreInverse[0m checks if it can decide the projectivity of [10XRange[0m( [3Xphi[0m ).
  
