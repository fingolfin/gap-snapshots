Documentation:
* change doc/Makefile to enforce LANG=C
* complete switch to GAPDoc: Verify everything converted fine, then remove old docs

Misc:
* redo stuff in /etc; need a new script for making release tarballs
* Add GPL header to all files
* Update the versions and release dates in PackageInfo.g *AND* CHANGES
* Write a checklist (or maybe a script) for everything that needs to be
  done during a release. E.g. setting version & release date (and where:
  PackageInfo.g, docu, configure, website, ...)

Code:
* Document changes made to AbelianPcpGroup in 2.2->2.6 (it now accepts
  more parameter formats)
* fix things from my bug list
* add some of my new internal code
* add unit tests
* IsomorphismPcpGroupFromFpGroupWithPcPres
  should this be Installed as a global function, considering that 
  it is documented now?
  other new globals (write protected):
    IsPcpElementCollection( ... )*
    IsPcpElementFamily( ... )*
  other new globals (not write protected):
	PcpFamily*
	PcpType*
	PolycyclicPkgName*
	USE_CANONICAL_PCS*
	USE_NORMED_PCS*

* MappedVector is used by lots of code, and also by 3rd party
  packages -> make it official & document it.
  Then again, the GAP core also contains a similar function with equal name. Oops

* add support for cohomology over arbitrary finite modules

* set CanEasilyCompareElements / CanEasilyCompareElementsFamily ?
* CanEasilySortElements / CanEasilySortElementsFamily ?

* Should we use InstallSubsetMaintenance etc.?

* the methods for IsomorphismPcpGroup could be improved, e.g. the
  one starting with a permutation group, or with a pc group

* Maybe add IsFreeAbelian, IsTorsionFree, property to GAP, and just install
  methods for pcp groups in polycyclic. CAREFUL with GAP 4.4 compatibility,
  and also beware of issues where users upgrade from an old polycyclic
  version to newer GAP... ideally, such a change should be made
  *before* GAP 4.5 is introduced.

* The third parameter "snf" in  Pcp( U, "snf" )
  is really an "option", and should be replaced by use of ValueOption()
  Similar for "all" in PrintPcpPresentation()

* Looking at the code in SchurExtension (and elsewhere), perhaps we should
  add a CollectorForPcp operation?

* Get rid of global variables and functions (they pollute the global namespace
  and are a liability, as they can be overwritten by chance).
  CHECK_CENT

* Add code for computing conjugacy classes of elements

* Implement ConjugacySubgroupsBySeries

* implement missing Sylow subgroup code (borrow from the corresponding
  pcgroup code)

* Remove dependency on nq? Only undocumented functions
    NonAbelianTensorSquareFp
    NonAbelianTensorSquarePlusFp
    NonAbelianTensorSquareViaNq
  If we do so, also remove the declaration of and call to
    NqEpimorphismNilpotentQuotient

* The documentation in methods.xml, last section, mentions
   "two libraries of Schur tower p-groups", but then fails to list
   methods for these, nor do I see such libraries in polycyclic. Huh?

* Rename various operations/attributes/properties to better fit into the GAP
  naming conventions; also, in some cases, polycyclic adds new operations
  for things that already have different names in GAP; that should be changed
  as well.
  This includes:
  SchurExtensionEpimorphism => EpimorphismSchurExtension
  SchurCovering => SchurCover (already exists in GAP)
  NonAbelianExteriorSquareEpimorphism => EpimorphismNonabelianExteriorSquare
  NonAbelianExteriorSquare => NonabelianExteriorSquare
  ...

* Add a method for EpimorphismSchurCover

* Turn D!.crossedPairing (set by NonAbelianExteriorSquareEpimorphism)
  into an attribute or so?

* There is lots of dead/unused code in polycyclic, e.g.
   CollectedOneCRNew
   CRRecordWithAction
   -> there is actually a *ton* of code related to that, dealing with "smats"
     "super" and other undocumented CR record entries.
  Decide what to keep of that and what to remove

* in gap/matrix/latbases.gi, there is a function "LatticeBasis"
  perhaps BaseIntMat could / should be used instead?

* in gap/matrix/hnf.gi, there is a function "HNFIntMatRowOps"
  What advantages does it have, exactly, over HermiteNormalFormIntegerMatTransform?
  And likewise for HNFIntMat vs. HermiteNormalFormIntegerMat
  They are used by "NormalFormConsistencyRelations" and "DiagonalFormIntMat" in the same file,
  and the long comments in there sound as if they might be "better" in some special
  cases... would be good to know if that is actually true, by finding such cases
  in real-world examples and documenting them.

* Document (in the manual) the return values of ComplementClasses, ComplementClassesEfaPcps
  and so on. They seem to be some kind of list of records

* Robert Morse suggests the following:

"NonAbelianTensorPlus and NonAbelianExteriorPlus are group products.  It
would be very nice to have the embeddings similar to direct product,
semidirect products, and free products.

For instance just like the other products:

nu := NonAbelianTensorPlus(g);
Embedding(nu,1);
returns a monomorphism from g into nu (first copy)
Embedding(nu,2);
returns a monomorphism from g int nu (second copy)


* Another suggestion by Robert Morse is to install methods that apply the
fast methods for NonAbelianTensorSquare, SchurCover(ing) etc. in polycyclic
to arbitrary polycyclic groups (or at least to pc groups), by temporarily
converting these groups to pcp groups, performing the computation, then
converting back.

* add a method for ConjugacyClasses

* several collector properties should perhaps be plain filters instead:
  IsWeightedCollector, IsPolynomialCollector, UseLibraryCollector

* Move !.collector from pcp group elements to the *family object* of these elements?
  Since the collector is shared by all elements in the same family, this
  seems like the sensible thing to do

* change NameTag resp. !.name -> only store !.name if it differs from "g".
  Which right now it *never* does...
  Indeed, might just as well get rid of NameTag in its current form.
  It is weird that this is an operation on the group elements anyway;
  it would make slightly more sense if it was an operation of the collector.
  

* set IsWholeFamily to true/false for pcp groups, esp. in PcpGroupByCollectorNC
  also add a method for it (this should be quite cheap)

* figure out why EfaSeriesParent is not directly installed as method for EfaSeries...
