<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (simpcomp) - Chapter 6: Functions and operations for SCSimplicialComplex</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap6"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chap13.html">13</a>  <a href="chap14.html">14</a>  <a href="chap15.html">15</a>  <a href="chap16.html">16</a>  <a href="chap17.html">17</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap5.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap7.html">[Next Chapter]</a>&nbsp;  </div>

<p><a id="X836F2B5C816E54B3" name="X836F2B5C816E54B3"></a></p>
<div class="ChapSects"><a href="chap6.html#X836F2B5C816E54B3">6 <span class="Heading">Functions and operations for <code class="code">SCSimplicialComplex</code></span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6.html#X879195657E1B257E">6.1 <span class="Heading">Creating an <code class="code">SCSimplicialComplex</code> object from a facet list</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7B5A874584FF34A7">6.1-1 SCFromFacets</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7B5470FD7E2320DE">6.1-2 SC</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X827D29DD79A82CFA">6.1-3 SCFromDifferenceCycles</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X804A0B1F85B333C2">6.1-4 SCFromGenerators</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6.html#X79072405786FEA0B">6.2 <span class="Heading">Generating some standard triangulations</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X8035AF9A836D38DE">6.2-1 SCBdCrossPolytope</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7E04DD807AF33B78">6.2-2 SCBdCyclicPolytope</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X839F3BD37DBA3F3C">6.2-3 SCBdSimplex</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X856E48967BBFCF0E">6.2-4 SCEmpty</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7A23532F7A8A3988">6.2-5 SCSimplex</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X831315CD80BA3654">6.2-6 SCFVectorBdCrossPolytope</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7C010361858F0214">6.2-7 SCFVectorBdCyclicPolytope</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7C3E0F7687AC966E">6.2-8 SCFVectorBdSimplex</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6.html#X814FE0267D7C54A9">6.3 <span class="Heading">Generating infinite series of transitive triangulations</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7EA6421A8156EBDF">6.3-1 SCSeriesAGL</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X786AD599875BD006">6.3-2 SCSeriesBdHandleBody</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7C0223DF83CC961B">6.3-3 SCSeriesC2n</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7D1CEF9F86D3AE66">6.3-4 SCSeriesCSTSurface</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7C56D2B7858A80C7">6.3-5 SCSeriesD2n</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7CCBF8F487036415">6.3-6 SCSeriesHandleBody</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X78DA125479E1D77F">6.3-7 SCSeriesK</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7B8300428516DAD8">6.3-8 SCSeriesKu</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X813C5B0E7FA7C1A3">6.3-9 SCSeriesL</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7EAC6828812A241A">6.3-10 SCSeriesLe</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7DDC1B127F21CFA4">6.3-11 SCSeriesPrimeTorus</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6.html#X7F4308DB7C3699D1">6.4 <span class="Heading">Generating new complexes from old</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X8255A2F97A7432F9">6.4-1 SCCartesianPower</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X859DA29B83BDE35E">6.4-2 SCCartesianProduct</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X82C9F57780C0B7F8">6.4-3 SCConnectedComponents</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7C63CDF28162C755">6.4-4 SCConnectedProduct</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X81338CE18195607C">6.4-5 SCConnectedSum</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X78B843417D63B408">6.4-6 SCConnectedSumMinus</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X84F3487182AB102A">6.4-7 SCDifferenceCycleCompress</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X8510B6CF85070A28">6.4-8 SCDifferenceCycleExpand</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X8278E1157A318C32">6.4-9 SCStronglyConnectedComponents</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6.html#X87C1C49987E75A9C">6.5 <span class="Heading">Simplicial complexes from transitive permutation groups</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7C1592677A76A3E5">6.5-1 SCsFromGroupExt</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7A04D77085D9BE4E">6.5-2 SCsFromGroupByTransitivity</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6.html#X81CE90127800B91A">6.6 <span class="Heading">Computing properties of simplicial complexes</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7B69B327809F67A0">6.6-1 SCAltshulerSteinberg</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7B88925386E197AC">6.6-2 SCAutomorphismGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7A33B8177A7ACD3A">6.6-3 SCAutomorphismGroupInternal</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X78F6EF808047772C">6.6-4 SCAutomorphismGroupSize</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7EAC3A5D7A3339BB">6.6-5 SCAutomorphismGroupStructure</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7E9D5C257F88E5E0">6.6-6 SCAutomorphismGroupTransitivity</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X836DC73380EA7414">6.6-7 SCBoundary</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X812AE7397B4FC88E">6.6-8 SCDehnSommervilleCheck</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X859C3981831B4B81">6.6-9 SCDehnSommervilleMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X82351AAE793DCB68">6.6-10 SCDim</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X798175C58050DDBD">6.6-11 SCDualGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X788BAE187D584103">6.6-12 SCEulerCharacteristic</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X81F8071385FD9C1D">6.6-13 SCFVector</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7F8B561C823DDDBA">6.6-14 SCFaceLattice</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7AE0029985BD0775">6.6-15 SCFaceLatticeEx</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7F6FE9B27B8D6922">6.6-16 SCFaces</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7B40DFE780A47109">6.6-17 SCFacesEx</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7BDD568184E3419D">6.6-18 SCFacets</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X87DC942881235E25">6.6-19 SCFacetsEx</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X79F60850875BB683">6.6-20 SCFpBettiNumbers</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X875963367A7745FB">6.6-21 SCFundamentalGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7B9F77A885E1BABE">6.6-22 SCGVector</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X863CA73D7F66B295">6.6-23 SCGenerators</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X789F8FC77FC0E701">6.6-24 SCGeneratorsEx</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X84FBF0A685547ECD">6.6-25 SCHVector</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X796EBADE7803C622">6.6-26 SCHasBoundary</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7C2A5B4D7E77E444">6.6-27 SCHasInterior</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X78D66254858CE901">6.6-28 SCHomology</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7B0C12F5780FDD9B">6.6-29 SCIncidences</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7B4CA6FE78A9880F">6.6-30 SCIncidencesEx</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X862926A079F6DFC2">6.6-31 SCInterior</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X8123A6E282CD0174">6.6-32 SCIsCentrallySymmetric</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X81AF20DC814B51A6">6.6-33 SCIsConnected</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X860375D980E9A801">6.6-34 SCIsEmpty</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X83E01C957D2F2458">6.6-35 SCIsEulerianManifold</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X843C3E7F79D8093F">6.6-36 SCIsFlag</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7E66FE0C83A3D371">6.6-37 SCIsHomologySphere</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X87BC29AF878E7FD8">6.6-38 SCIsInKd</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7F4BECCA7E67B1B2">6.6-39 SCIsKNeighborly</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X78C860DC851167F7">6.6-40 SCIsOrientable</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X79DFCA08808665B7">6.6-41 SCIsPseudoManifold</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7AAA757F842EA23A">6.6-42 SCIsPure</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7EA4F4DB78758652">6.6-43 SCIsShellable</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7A2BD5657BBE1CC7">6.6-44 SCIsStronglyConnected</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7B935899849C8E40">6.6-45 SCMinimalNonFaces</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7DE069A0823BD56E">6.6-46 SCMinimalNonFacesEx</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X82A224DF787A97BE">6.6-47 SCNeighborliness</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7AC2427184B44C65">6.6-48 SCNumFaces</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X78DACE3478340DB8">6.6-49 SCOrientation</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X8026B46F8236124D">6.6-50 SCSkel</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X84ACF7D580FE8B76">6.6-51 SCSkelEx</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7E770DE27938B140">6.6-52 SCSpanningTree</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6.html#X8284003382F863A0">6.7 <span class="Heading">Operations on simplicial complexes</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X818757A17DA5CFFC">6.7-1 SCAlexanderDual</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X82D22356858062D6">6.7-2 SCClose</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7A4EBD017F4D9747">6.7-3 SCCollapseGreedy</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7CF53D8D7E0FA702">6.7-4 SCCone</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X800BDDD878DFCBDB">6.7-5 SCDeletedJoin</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7FB3D29178076EB4">6.7-6 SCDifference</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7C8D11C684825ADC">6.7-7 SCFillSphere</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7DCB16857D49EC37">6.7-8 SCHandleAddition</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7B4BE2C783E6D0BF">6.7-9 SCIntersection</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X85659EC77DFF8183">6.7-10 SCIsIsomorphic</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X81D9CC438313F589">6.7-11 SCIsSubcomplex</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X8623B92580E8B4E4">6.7-12 SCIsomorphism</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X86576B7287686E2B">6.7-13 SCIsomorphismEx</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X86AC8D81837CC677">6.7-14 SCJoin</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X8482E1F67C927BB7">6.7-15 SCNeighbors</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7F8FBEF17ACD0D4F">6.7-16 SCNeighborsEx</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7EDA334983025D3D">6.7-17 SCShelling</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7F967A717D4E41C0">6.7-18 SCShellingExt</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X8373598C7FF5D28E">6.7-19 SCShellings</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7987AAE481C31F38">6.7-20 SCSpan</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7AAA4669793C57DC">6.7-21 SCSuspension</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X81DA367A813F7599">6.7-22 SCUnion</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7D5639CB87A0D3F1">6.7-23 SCVertexIdentification</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7E7B17317D1B618D">6.7-24 SCWedge</a></span>
</div></div>
</div>

<h3>6 <span class="Heading">Functions and operations for <code class="code">SCSimplicialComplex</code></span></h3>

<p><a id="X879195657E1B257E" name="X879195657E1B257E"></a></p>

<h4>6.1 <span class="Heading">Creating an <code class="code">SCSimplicialComplex</code> object from a facet list</span></h4>

<p>This section contains functions to generate or to construct new simplicial complexes. Some of them obtain new complexes from existing ones, some generate new complexes from scratch.</p>

<p><a id="X7B5A874584FF34A7" name="X7B5A874584FF34A7"></a></p>

<h5>6.1-1 SCFromFacets</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCFromFacets</code>( <var class="Arg">facets</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, fail otherwise.</p>

<p>Constructs a simplicial complex object from the given facet list. The facet list <var class="Arg">facets</var> has to be a duplicate free list (or set) which consists of duplicate free entries, which are in turn lists or sets. For the vertex labels (i. e. the entries of the list items of <var class="Arg">facets</var>) an ordering via the less-operator has to be defined. Following Section 4.11 of the <strong class="pkg">GAP</strong> manual this is the case for objects of the following families: rationals <code class="code">IsRat</code>, cyclotomics <code class="code">IsCyclotomic</code>, finite field elements <code class="code">IsFFE</code>, permutations <code class="code">IsPerm</code>, booleans <code class="code">IsBool</code>, characters <code class="code">IsChar</code> and lists (strings) <code class="code">IsList</code>.</p>

<p>Internally the vertices are mapped to the standard labeling <span class="SimpleMath">1..n</span>, where <span class="SimpleMath">n</span> is the number of vertices of the complex and the vertex labels of the original complex are stored in the property ''VertexLabels'', see <code class="func">SCLabels</code> (<a href="chap4.html#X826E9B4482AF2671"><span class="RefLink">4.2-3</span></a>) and the <code class="code">SCRelabel..</code> functions like <code class="func">SCRelabel</code> (<a href="chap4.html#X7B6011907B74EDDA"><span class="RefLink">4.2-6</span></a>) or <code class="func">SCRelabelStandard</code> (<a href="chap4.html#X78E22E3B787DDE90"><span class="RefLink">4.2-7</span></a>).</p>


<div class="example"><pre>
 gap&gt; c:=SCFromFacets([[1,2,5], [1,4,5], [1,4,6], [2,3,5], [3,4,6], [3,5,6]]);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="unnamed complex 9"
  Dim=2
 
 /SimplicialComplex]
 gap&gt; c:=SCFromFacets([["a","b","c"], ["a","b",1], ["a","c",1], ["b","c",1]]);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="unnamed complex 10"
  Dim=2
 
 /SimplicialComplex]
 </pre></div>

<p><a id="X7B5470FD7E2320DE" name="X7B5470FD7E2320DE"></a></p>

<h5>6.1-2 SC</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SC</code>( <var class="Arg">facets</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, fail otherwise.</p>

<p>A shorter function to create a simplicial complex from a facet list, just calls <code class="func">SCFromFacets</code> (<a href="chap6.html#X7B5A874584FF34A7"><span class="RefLink">6.1-1</span></a>)(<var class="Arg">facets</var>).</p>


<div class="example"><pre>
 gap&gt; c:=SC(Combinations([1..6],5));
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="unnamed complex 11"
  Dim=4
 
 /SimplicialComplex]
 </pre></div>

<p><a id="X827D29DD79A82CFA" name="X827D29DD79A82CFA"></a></p>

<h5>6.1-3 SCFromDifferenceCycles</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCFromDifferenceCycles</code>( <var class="Arg">diffcycles</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Creates a simplicial complex object from the list of difference cycles provided. If <var class="Arg">diffcycles</var> is of length <span class="SimpleMath">1</span> the computation is equivalent to the one in <code class="func">SCDifferenceCycleExpand</code> (<a href="chap6.html#X8510B6CF85070A28"><span class="RefLink">6.4-8</span></a>). Otherwise the induced modulus (the sum of all entries of a difference cycle) of all cycles has to be equal and the union of all expanded difference cycles is returned.</p>

<p>A <span class="SimpleMath">n</span>-dimensional difference cycle <span class="SimpleMath">D = (d_1 : ... : d_n+1)</span> induces a simplex <span class="SimpleMath">∆ = ( v_1 , ... , v_n+1 )</span> by <span class="SimpleMath">v_1 = d_1</span>, <span class="SimpleMath">v_i = v_i-1 + d_i</span> and a cyclic group action by <span class="SimpleMath">Z_σ</span> where <span class="SimpleMath">σ = ∑ d_i</span> is the modulus of <span class="SimpleMath">D</span>. The function returns the <span class="SimpleMath">Z_σ</span>-orbit of <span class="SimpleMath">∆</span>.</p>

<p>Note that modulo operations in <strong class="pkg">GAP</strong> are often a little bit cumbersome, since all integer ranges usually start from <span class="SimpleMath">1</span>.</p>


<div class="example"><pre>
 gap&gt; c:=SCFromDifferenceCycles([[1,1,6],[2,3,3]]);;
 gap&gt; c.F;
 [ 8, 24, 16 ]
 gap&gt; c.Homology;
 [ [ 0, [  ] ], [ 2, [  ] ], [ 1, [  ] ] ]
 gap&gt; c.Chi;
 0
 gap&gt; c.HasBoundary;
 false
 gap&gt; SCIsPseudoManifold(c);
 true
 gap&gt; SCIsManifold(c);
 true
 </pre></div>

<p><a id="X804A0B1F85B333C2" name="X804A0B1F85B333C2"></a></p>

<h5>6.1-4 SCFromGenerators</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCFromGenerators</code>( <var class="Arg">group</var>, <var class="Arg">generators</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, fail otherwise.</p>

<p>Constructs a simplicial complex object from the set of <var class="Arg">generators</var> on which the group <var class="Arg">group</var> acts, i.e. a complex which has <var class="Arg">group</var> as a subgroup of the automorphism group and a facet list that consists of the <var class="Arg">group</var>-orbits specified by the list of representatives passed in <var class="Arg">generators</var>. Note that <var class="Arg">group</var> is not stored as an attribute of the resulting complex as it might just be a subgroup of the actual automorphism group. Internally calls <code class="code">Orbits</code> and <code class="func">SCFromFacets</code> (<a href="chap6.html#X7B5A874584FF34A7"><span class="RefLink">6.1-1</span></a>).</p>


<div class="example"><pre>
 gap&gt; #group: AGL(1,7) of order 42
 gap&gt; G:=Group([(2,6,5,7,3,4),(1,3,5,7,2,4,6)]);;
 gap&gt; c:=SCFromGenerators(G,[[ 1, 2, 4 ]]);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="complex from generators under group (C7 : C3) : C2"
  Dim=2
 
 /SimplicialComplex]
 gap&gt; SCLib.DetermineTopologicalType(c);
 [SimplicialComplex
 
  Properties known: BoundaryEx, Dim, FacetsEx, HasBoundary, 
                    IsPseudoManifold, Name, SkelExs[], Vertices.
 
  Name="complex from generators under group (C7 : C3) : C2"
  Dim=2
  HasBoundary=false
  IsPseudoManifold=true
 
 /SimplicialComplex]
 </pre></div>

<p><a id="X79072405786FEA0B" name="X79072405786FEA0B"></a></p>

<h4>6.2 <span class="Heading">Generating some standard triangulations</span></h4>

<p><a id="X8035AF9A836D38DE" name="X8035AF9A836D38DE"></a></p>

<h5>6.2-1 SCBdCrossPolytope</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCBdCrossPolytope</code>( <var class="Arg">d</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Generates the boundary of the <span class="SimpleMath">d</span>-dimensional cross polytope <span class="SimpleMath">β^d</span>, a centrally symmetric combinatorial <span class="SimpleMath">d-1</span>-sphere.</p>


<div class="example"><pre>
 gap&gt; SCBdCrossPolytope(3); # the octahedron
 [SimplicialComplex
 
  Properties known: Dim, EulerCharacteristic, FacetsEx, HasBoundary, 
                    Homology, IsConnected, IsStronglyConnected, Name, 
                    NumFaces[], TopologicalType, Vertices.
 
  Name="Bd(\beta^3)"
  Dim=2
  EulerCharacteristic=2
  HasBoundary=false
  Homology=[ [ 0, [ ] ], [ 0, [ ] ], [ 1, [ ] ] ]
  IsConnected=true
  IsStronglyConnected=true
  TopologicalType="S^2"
 
 /SimplicialComplex]
 </pre></div>

<p><a id="X7E04DD807AF33B78" name="X7E04DD807AF33B78"></a></p>

<h5>6.2-2 SCBdCyclicPolytope</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCBdCyclicPolytope</code>( <var class="Arg">d</var>, <var class="Arg">n</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Generates the boundary complex of the <var class="Arg">d</var>-dimensional cyclic polytope (a combinatorial <span class="SimpleMath">d-1</span>-sphere) on <var class="Arg">n</var> vertices, where <span class="SimpleMath">n≥ d+2</span>.</p>


<div class="example"><pre>
 gap&gt; SCBdCyclicPolytope(3,8); 
 [SimplicialComplex
 
  Properties known: Dim, EulerCharacteristic, FacetsEx, HasBoundary, 
                    Homology, IsConnected, IsStronglyConnected, Name, 
                    NumFaces[], TopologicalType, Vertices.
 
  Name="Bd(C_3(8))"
  Dim=2
  EulerCharacteristic=2
  HasBoundary=false
  Homology=[ [ 0, [ ] ], [ 0, [ ] ], [ 1, [ ] ] ]
  IsConnected=true
  IsStronglyConnected=true
  TopologicalType="S^2"
 
 /SimplicialComplex]
 </pre></div>

<p><a id="X839F3BD37DBA3F3C" name="X839F3BD37DBA3F3C"></a></p>

<h5>6.2-3 SCBdSimplex</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCBdSimplex</code>( <var class="Arg">d</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Generates the boundary of the <span class="SimpleMath">d</span>-simplex <span class="SimpleMath">∆^d</span>, a combinatorial <span class="SimpleMath">d-1</span>-sphere.</p>


<div class="example"><pre>
 gap&gt; SCBdSimplex(5);
 [SimplicialComplex
 
  Properties known: AutomorphismGroup, AutomorphismGroupSize, 
                    AutomorphismGroupStructure, 
                    AutomorphismGroupTransitivity, Dim, 
                    EulerCharacteristic, FacetsEx, GeneratorsEx, 
                    HasBoundary, Homology, IsConnected, 
                    IsStronglyConnected, Name, NumFaces[], 
                    TopologicalType, Vertices.
 
  Name="S^4_6"
  Dim=4
  AutomorphismGroupSize=720
  AutomorphismGroupStructure="S6"
  AutomorphismGroupTransitivity=6
  EulerCharacteristic=2
  HasBoundary=false
  Homology=[ [ 0, [ ] ], [ 0, [ ] ], [ 0, [ ] ], [ 0, [ ] ], [ 1, [ ] ] ]
  IsConnected=true
  IsStronglyConnected=true
  TopologicalType="S^4"
 
 /SimplicialComplex]
 </pre></div>

<p><a id="X856E48967BBFCF0E" name="X856E48967BBFCF0E"></a></p>

<h5>6.2-4 SCEmpty</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCEmpty</code>(  )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Generates an empty complex (of dimension <span class="SimpleMath">-1</span>), i. e. a <code class="code">SCSimplicialComplex</code> object with empty facet list.</p>


<div class="example"><pre>
 gap&gt; SCEmpty();
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="empty complex"
  Dim=-1
 
 /SimplicialComplex]
 </pre></div>

<p><a id="X7A23532F7A8A3988" name="X7A23532F7A8A3988"></a></p>

<h5>6.2-5 SCSimplex</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSimplex</code>( <var class="Arg">d</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Generates the <var class="Arg">d</var>-simplex.</p>


<div class="example"><pre>
 gap&gt; SCSimplex(3);
 [SimplicialComplex
 
  Properties known: Dim, EulerCharacteristic, FacetsEx, Name, 
                    NumFaces[], TopologicalType, Vertices.
 
  Name="B^3_4"
  Dim=3
  EulerCharacteristic=1
  TopologicalType="B^3"
 
 /SimplicialComplex]
 </pre></div>

<p><a id="X831315CD80BA3654" name="X831315CD80BA3654"></a></p>

<h5>6.2-6 SCFVectorBdCrossPolytope</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCFVectorBdCrossPolytope</code>( <var class="Arg">d</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: a list of integers of size <code class="code">d + 1</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the <span class="SimpleMath">f</span>-vector of the <span class="SimpleMath">d</span>-dimensional cross polytope without generating the underlying complex.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SCFVectorBdCrossPolytope(50);</span>
[ 100, 4900, 156800, 3684800, 67800320, 1017004800, 12785203200, 
  137440934400, 1282782054400, 10518812846080, 76500457062400, 
  497252970905600, 2907017368371200, 15365663232819200, 73755183517532160, 
  322678927889203200, 1290715711556812800, 4732624275708313600, 
  15941471244491161600, 49418560857922600960, 141195888165493145600, 
  372243705163572838400, 906332499528699084800, 2039248123939572940800, 
  4241636097794311716864, 8156992495758291763200, 14501319992459185356800, 
  23823597130468661657600, 36146147370366245273600, 50604606318512743383040, 
  65296266217435797913600, 77539316133205010022400, 84588344872587283660800, 
  84588344872587283660800, 77337915312079802204160, 64448262760066501836800, 
  48771658304915190579200, 33370081998099867238400, 20535435075753764454400, 
  11294489291664570449920, 5509506971543692902400, 2361217273518725529600, 
  878592473867432755200, 279552150776001331200, 74547240206933688320, 
  16205921784116019200, 2758454771764428800, 344806846470553600, 
  28147497671065600, 1125899906842624 ]
</pre></div>

<p><a id="X7C010361858F0214" name="X7C010361858F0214"></a></p>

<h5>6.2-7 SCFVectorBdCyclicPolytope</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCFVectorBdCyclicPolytope</code>( <var class="Arg">d</var>, <var class="Arg">n</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: a list of integers of size <code class="code">d+1</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the <span class="SimpleMath">f</span>-vector of the <var class="Arg">d</var>-dimensional cyclic polytope on <var class="Arg">n</var> vertices, <span class="SimpleMath">n≥ d+2</span>, without generating the underlying complex.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SCFVectorBdCyclicPolytope(25,198); </span>
[ 198, 19503, 1274196, 62117055, 2410141734, 77526225777, 2126433621312, 
  50768602708824, 1071781612741840, 20256672480820776, 346204947854027808, 
  5395027104058600008, 48354596155522298656, 262068846498922699590, 
  940938105142239825104, 2379003007642628680027, 4396097923113038784642, 
  6062663500381642763609, 6294919173643129209180, 4911378208855785427761, 
  2840750019404460890298, 1183225500922302444568, 335951678686835900832, 
  58265626173398052500, 4661250093871844200 ]
</pre></div>

<p><a id="X7C3E0F7687AC966E" name="X7C3E0F7687AC966E"></a></p>

<h5>6.2-8 SCFVectorBdSimplex</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCFVectorBdSimplex</code>( <var class="Arg">d</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: a list of integers of size <code class="code">d + 1</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the <span class="SimpleMath">f</span>-vector of the <span class="SimpleMath">d</span>-simplex without generating the underlying complex.</p>


<div class="example"><pre>
 gap&gt; SCFVectorBdSimplex(100);
 [ 101, 5050, 166650, 4082925, 79208745, 1267339920, 17199613200, 
   202095455100, 2088319702700, 19212541264840, 158940114100040, 
   1192050855750300, 8160963550905900, 51297485177122800, 297525414027312240, 
   1599199100396803290, 7995995501984016450, 37314645675925410100, 
   163006083742200475700, 668324943343021950370, 2577824781465941808570, 
   9373908296239788394800, 32197337191432316660400, 104641345872155029146300, 
   322295345286237489770604, 942094086221309585483304, 
   2616928017281415515231400, 6916166902815169575968700, 
   17409661513983013070541900, 41783187633559231369300560, 
   95696978128474368620010960, 209337139656037681356273975, 
   437704928371715151926754675, 875409856743430303853509350, 
   1675784582908852295948146470, 3072271735332895875904935195, 
   5397234129638871133346507775, 9090078534128625066688855200, 
   14683973016669317415420458400, 22760158175837441993901710520, 
   33862674359172779551902544920, 48375249084532542217003635600, 
   66375341767149302111702662800, 87494768693060443692698964600, 
   110826707011209895344085355160, 134919469404951176940625649760, 
   157884485473879036845412994400, 177620046158113916451089618700, 
   192119641762857909630770403900, 199804427433372226016001220056, 
   199804427433372226016001220056, 192119641762857909630770403900, 
   177620046158113916451089618700, 157884485473879036845412994400, 
   134919469404951176940625649760, 110826707011209895344085355160, 
   87494768693060443692698964600, 66375341767149302111702662800, 
   48375249084532542217003635600, 33862674359172779551902544920, 
   22760158175837441993901710520, 14683973016669317415420458400, 
   9090078534128625066688855200, 5397234129638871133346507775, 
   3072271735332895875904935195, 1675784582908852295948146470, 
   875409856743430303853509350, 437704928371715151926754675, 
   209337139656037681356273975, 95696978128474368620010960, 
   41783187633559231369300560, 17409661513983013070541900, 
   6916166902815169575968700, 2616928017281415515231400, 
   942094086221309585483304, 322295345286237489770604, 
   104641345872155029146300, 32197337191432316660400, 9373908296239788394800, 
   2577824781465941808570, 668324943343021950370, 163006083742200475700, 
   37314645675925410100, 7995995501984016450, 1599199100396803290, 
   297525414027312240, 51297485177122800, 8160963550905900, 1192050855750300, 
   158940114100040, 19212541264840, 2088319702700, 202095455100, 17199613200, 
   1267339920, 79208745, 4082925, 166650, 5050, 101 ]
 </pre></div>

<p><a id="X814FE0267D7C54A9" name="X814FE0267D7C54A9"></a></p>

<h4>6.3 <span class="Heading">Generating infinite series of transitive triangulations</span></h4>

<p><a id="X7EA6421A8156EBDF" name="X7EA6421A8156EBDF"></a></p>

<h5>6.3-1 SCSeriesAGL</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSeriesAGL</code>( <var class="Arg">p</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: a permutation group and a list of <span class="SimpleMath">5</span>-tuples of integers upon success, <code class="keyw">fail</code> otherwise.</p>

<p>For a given prime <var class="Arg">p</var> the automorphism group (AGL<span class="SimpleMath">(1,p)</span>) and the generators of all members of the series of <span class="SimpleMath">2</span>-transitive combinatorial <span class="SimpleMath">4</span>-pseudomanifolds with <var class="Arg">p</var> vertices from <a href="chapBib.html#biBSpreer10Diss">[Spr10a]</a>, Section 5.2, is computed. The affine linear group AGL<span class="SimpleMath">(1,p)</span> is returned as the first argument. If no member of the series with <var class="Arg">p</var> vertices exists only the group is returned.</p>


<div class="example"><pre>
 gap&gt; gens:=SCSeriesAGL(17);
 [ AGL(1,17), [ [ 1, 2, 4, 8, 16 ] ] ]
 gap&gt; c:=SCFromGenerators(gens[1],gens[2]);;
 gap&gt; SCIsManifold(SCLink(c,1));
 true
 </pre></div>


<div class="example"><pre>
 gap&gt; List([19..23],x-&gt;SCSeriesAGL(x));     
 #I  SCSeriesAGL: argument must be a prime &gt; 13.
 #I  SCSeriesAGL: argument must be a prime &gt; 13.
 #I  SCSeriesAGL: argument must be a prime &gt; 13.
 [ [ AGL(1,19), [ [ 1, 2, 10, 12, 17 ] ] ], fail, fail, fail, 
   [ AGL(1,23), [ [ 1, 2, 7, 9, 19 ], [ 1, 2, 4, 8, 22 ] ] ] ]
 gap&gt; for i in [80000..80100] do if IsPrime(i) then Print(i,"\n"); fi; od;
 80021
 80039
 80051
 80071
 80077
 gap&gt; SCSeriesAGL(80021);                                                 
 AGL(1,80021)
 gap&gt; SCSeriesAGL(80039);                                                 
 [ AGL(1,80039), [ [ 1, 2, 6496, 73546, 78018 ] ] ]
 gap&gt; SCSeriesAGL(80051);                                                 
 [ AGL(1,80051), [ [ 1, 2, 31498, 37522, 48556 ] ] ]
 gap&gt; SCSeriesAGL(80071);                                                 
 AGL(1,80071)
 gap&gt; SCSeriesAGL(80077);                                                 
 [ AGL(1,80077), [ [ 1, 2, 4126, 39302, 40778 ] ] ]
 </pre></div>

<p><a id="X786AD599875BD006" name="X786AD599875BD006"></a></p>

<h5>6.3-2 SCSeriesBdHandleBody</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSeriesBdHandleBody</code>( <var class="Arg">d</var>, <var class="Arg">n</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p><code class="code">SCSeriesBdHandleBody(d,n)</code> generates a transitive <span class="SimpleMath">d</span>-dimensional sphere bundle (<span class="SimpleMath">d ≥ 2</span>) with <span class="SimpleMath">n</span> vertices (<span class="SimpleMath">n ≥ 2d + 3</span>) which coincides with the boundary of <code class="func">SCSeriesHandleBody</code> (<a href="chap6.html#X7CCBF8F487036415"><span class="RefLink">6.3-6</span></a>)<code class="code">(d,n)</code>. The sphere bundle is orientable if <span class="SimpleMath">d</span> is even or if <span class="SimpleMath">d</span> is odd and <span class="SimpleMath">n</span> is even, otherwise it is not orientable. Internally calls <code class="func">SCFromDifferenceCycles</code> (<a href="chap6.html#X827D29DD79A82CFA"><span class="RefLink">6.1-3</span></a>).</p>


<div class="example"><pre>
 gap&gt; c:=SCSeriesBdHandleBody(2,7);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, IsOrientable, Name, TopologicalType, 
                    Vertices.
 
  Name="Sphere bundle S^1 x S^1"
  Dim=2
  IsOrientable=true
  TopologicalType="S^1 x S^1"
 
 /SimplicialComplex]
 gap&gt; SCLib.DetermineTopologicalType(c);
 [SimplicialComplex
 
  Properties known: BoundaryEx, Dim, FacetsEx, HasBoundary, 
                    IsOrientable, IsPseudoManifold, Name, SkelExs[], 
                    TopologicalType, Vertices.
 
  Name="Sphere bundle S^1 x S^1"
  Dim=2
  HasBoundary=false
  IsOrientable=true
  IsPseudoManifold=true
  TopologicalType="S^1 x S^1"
 
 /SimplicialComplex]
 gap&gt; SCIsIsomorphic(c,SCSeriesHandleBody(3,7).Boundary);
 true
 </pre></div>

<p><a id="X7C0223DF83CC961B" name="X7C0223DF83CC961B"></a></p>

<h5>6.3-3 SCSeriesC2n</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSeriesC2n</code>( <var class="Arg">n</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Generates the combinatorial <span class="SimpleMath">3</span>-manifold <span class="SimpleMath">C_2n</span>, <span class="SimpleMath">n ≥ 8</span>, with <span class="SimpleMath">2n</span> vertices from <a href="chapBib.html#biBSpreer10Diss">[Spr10a]</a>, Section 4.5.3 and Section 5.2. The complex is homeomorphic to <span class="SimpleMath">S^2 × S^1</span> for <span class="SimpleMath">n</span> odd and homeomorphic to <span class="SimpleMath">S^2 dtimes S^1</span> in case <span class="SimpleMath">n</span> is an even number. In the latter case <span class="SimpleMath">C_2n</span> is isomorphic to <span class="SimpleMath">D_2n</span> from <code class="func">SCSeriesD2n</code> (<a href="chap6.html#X7C56D2B7858A80C7"><span class="RefLink">6.3-5</span></a>). The complexes are believed to appear as the vertex links of some of the members of the series of <span class="SimpleMath">2</span>-transitive <span class="SimpleMath">4</span>-pseudomanifolds from <code class="func">SCSeriesAGL</code> (<a href="chap6.html#X7EA6421A8156EBDF"><span class="RefLink">6.3-1</span></a>). Internally calls <code class="func">SCFromDifferenceCycles</code> (<a href="chap6.html#X827D29DD79A82CFA"><span class="RefLink">6.1-3</span></a>).</p>


<div class="example"><pre>
 gap&gt; c:=SCSeriesC2n(8);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, TopologicalType, Vertices.
 
  Name="C_16 = { (1:1:3:11),(1:1:11:3),(1:3:1:11),(2:3:2:9),(2:5:2:7) }"
  Dim=3
  TopologicalType="S^2 ~ S^1"
 
 /SimplicialComplex]
 gap&gt; SCGenerators(c);  
 [ [ [ 1, 2, 3, 6 ], 32 ], [ [ 1, 2, 5, 6 ], 16 ], [ [ 1, 3, 6, 8 ], 16 ], 
   [ [ 1, 3, 8, 10 ], 16 ] ]
 </pre></div>


<div class="example"><pre>
 gap&gt; c:=SCSeriesC2n(8);;
 gap&gt; d:=SCSeriesD2n(8); 
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, TopologicalType, Vertices.
 
  Name="D_16 = { (1:1:1:13),(1:2:11:2),(3:4:5:4),(2:3:4:7),(2:7:4:3) }"
  Dim=3
  TopologicalType="S^2 ~ S^1"
 
 /SimplicialComplex]
 gap&gt; SCIsIsomorphic(c,d);
 true
 gap&gt; c:=SCSeriesC2n(11);;
 gap&gt; d:=SCSeriesD2n(11);;
 gap&gt; c.Homology;
 [ [ 0, [  ] ], [ 1, [  ] ], [ 1, [  ] ], [ 1, [  ] ] ]
 gap&gt; d.Homology;
 [ [ 0, [  ] ], [ 1, [  ] ], [ 0, [ 2 ] ], [ 0, [  ] ] ]
 </pre></div>

<p><a id="X7D1CEF9F86D3AE66" name="X7D1CEF9F86D3AE66"></a></p>

<h5>6.3-4 SCSeriesCSTSurface</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSeriesCSTSurface</code>( <var class="Arg">l</var>[, <var class="Arg">j</var>], <var class="Arg">2k</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p><code class="code">SCSeriesCSTSurface(l,j,2k)</code> generates the centrally symmetric transitive (cst) surface <span class="SimpleMath">S_(l,j,2k)</span>, <code class="code">SCSeriesCSTSurface(l,2k)</code> generates the cst surface <span class="SimpleMath">S_(l,2k)</span> from <a href="chapBib.html#biBSpreer10PartBetaK">[Spr10b]</a>, Section 4.4.</p>


<div class="example"><pre>
 gap&gt; SCSeriesCSTSurface(2,4,14);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="cst surface S_{(2,4,14)} = { (2:4:8),(2:8:4) }"
  Dim=2
 
 /SimplicialComplex]
 gap&gt; last.Homology;
 [ [ 1, [  ] ], [ 4, [  ] ], [ 2, [  ] ] ]
 gap&gt; SCSeriesCSTSurface(2,10);  
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="cst surface S_{(2,10)} = { (2:2:6),(3:3:4) }"
  Dim=2
 
 /SimplicialComplex]
 gap&gt; last.Homology;                    
 [ [ 0, [  ] ], [ 1, [ 2 ] ], [ 0, [  ] ] ]
 </pre></div>

<p><a id="X7C56D2B7858A80C7" name="X7C56D2B7858A80C7"></a></p>

<h5>6.3-5 SCSeriesD2n</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSeriesD2n</code>( <var class="Arg">n</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Generates the combinatorial <span class="SimpleMath">3</span>-manifold <span class="SimpleMath">D_2n</span>, <span class="SimpleMath">n ≥ 8</span>, <span class="SimpleMath">n ≠ 9</span>, with <span class="SimpleMath">2n</span> vertices from <a href="chapBib.html#biBSpreer10Diss">[Spr10a]</a>, Section 4.5.3 and Section 5.2. The complex is homeomorphic to <span class="SimpleMath">S^2 dtimes S^1</span>. In the case that <span class="SimpleMath">n</span> is even <span class="SimpleMath">D_2n</span> is isomorphic to <span class="SimpleMath">C_2n</span> from <code class="func">SCSeriesC2n</code> (<a href="chap6.html#X7C0223DF83CC961B"><span class="RefLink">6.3-3</span></a>). The complexes are believed to appear as the vertex links of some of the members of the series of <span class="SimpleMath">2</span>-transitive <span class="SimpleMath">4</span>-pseudomanifolds from <code class="func">SCSeriesAGL</code> (<a href="chap6.html#X7EA6421A8156EBDF"><span class="RefLink">6.3-1</span></a>). Internally calls <code class="func">SCFromDifferenceCycles</code> (<a href="chap6.html#X827D29DD79A82CFA"><span class="RefLink">6.1-3</span></a>).</p>


<div class="example"><pre>
 gap&gt; d:=SCSeriesD2n(15);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, TopologicalType, Vertices.
 
  Name="D_30 = { (1:1:1:27),(1:2:25:2),(3:11:5:11),(2:3:11:14),(2:14:11:3) }"
  Dim=3
  TopologicalType="S^2 ~ S^1"
 
 /SimplicialComplex]
 gap&gt; SCAutomorphismGroup(d);  
 TransitiveGroup(30,14) = t30n14
 gap&gt; StructureDescription(last);
 "D60"
 </pre></div>


<div class="example"><pre>
 gap&gt; c:=SCSeriesC2n(8);;
 gap&gt; d:=SCSeriesD2n(8); 
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, TopologicalType, Vertices.
 
  Name="D_16 = { (1:1:1:13),(1:2:11:2),(3:4:5:4),(2:3:4:7),(2:7:4:3) }"
  Dim=3
  TopologicalType="S^2 ~ S^1"
 
 /SimplicialComplex]
 gap&gt; SCIsIsomorphic(c,d);
 true
 gap&gt; c:=SCSeriesC2n(11);;
 gap&gt; d:=SCSeriesD2n(11);;
 gap&gt; c.Homology;
 [ [ 0, [  ] ], [ 1, [  ] ], [ 1, [  ] ], [ 1, [  ] ] ]
 gap&gt; d.Homology;
 [ [ 0, [  ] ], [ 1, [  ] ], [ 0, [ 2 ] ], [ 0, [  ] ] ]
 </pre></div>

<p><a id="X7CCBF8F487036415" name="X7CCBF8F487036415"></a></p>

<h5>6.3-6 SCSeriesHandleBody</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSeriesHandleBody</code>( <var class="Arg">d</var>, <var class="Arg">n</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p><code class="code">SCSeriesHandleBody(d,n)</code> generates a transitive <span class="SimpleMath">d</span>-dimensional handle body (<span class="SimpleMath">d ≥ 3</span>) with <span class="SimpleMath">n</span> vertices (<span class="SimpleMath">n ≥ 2d + 1</span>). The handle body is orientable if <span class="SimpleMath">d</span> is odd or if <span class="SimpleMath">d</span> and <span class="SimpleMath">n</span> are even, otherwise it is not orientable. The complex equals the difference cycle <span class="SimpleMath">(1 : ... : 1 : n-d)</span> To obtain the boundary complexes of <code class="code">SCSeriesHandleBody(d,n)</code> use the function <code class="func">SCSeriesBdHandleBody</code> (<a href="chap6.html#X786AD599875BD006"><span class="RefLink">6.3-2</span></a>). Internally calls <code class="func">SCFromDifferenceCycles</code> (<a href="chap6.html#X827D29DD79A82CFA"><span class="RefLink">6.1-3</span></a>).</p>


<div class="example"><pre>
 gap&gt; c:=SCSeriesHandleBody(3,7);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, IsOrientable, Name, TopologicalType, 
                    Vertices.
 
  Name="Handle body B^2 x S^1"
  Dim=3
  IsOrientable=true
  TopologicalType="B^2 x S^1"
 
 /SimplicialComplex]
 gap&gt; SCAutomorphismGroup(c);    
 PrimitiveGroup(7,2) = D(2*7)
 gap&gt; bd:=SCBoundary(c);;
 gap&gt; SCAutomorphismGroup(bd);
 PrimitiveGroup(7,4) = AGL(1, 7)
 gap&gt; SCIsIsomorphic(bd,SCSeriesBdHandleBody(2,7));
 true
 </pre></div>

<p><a id="X78DA125479E1D77F" name="X78DA125479E1D77F"></a></p>

<h5>6.3-7 SCSeriesK</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSeriesK</code>( <var class="Arg">i</var>, <var class="Arg">k</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Generates the <var class="Arg">k</var>-th member (<span class="SimpleMath">k ≥ 0</span>) of the series <var class="Arg">K^i</var> (<span class="SimpleMath">1 ≤ i ≤ 114</span>) from <a href="chapBib.html#biBSpreer10Diss">[Spr10a]</a>. The <span class="SimpleMath">114</span> series describe a complete classification of all dense series (i. e. there is a member of the series for every integer, <span class="SimpleMath">f_0 (K^i (k+1) ) = f_0 (K^i (k)) +1</span>) of cyclic <span class="SimpleMath">3</span>-manifolds with a fixed number of difference cycles and at least one member with less than <span class="SimpleMath">20</span> vertices. See <code class="func">SCSeriesL</code> (<a href="chap6.html#X813C5B0E7FA7C1A3"><span class="RefLink">6.3-9</span></a>) for a list of series of order <span class="SimpleMath">2</span>.</p>


<div class="example"><pre>
 gap&gt; cc:=List([1..114],x-&gt;SCSeriesK(x,0));;                                                                                                                                                                                                  
 gap&gt; Set(List(cc,x-&gt;x.F));                                                                                                                                                                                                                        
 [ [ 11, 55, 88, 44 ], [ 13, 65, 104, 52 ], [ 13, 78, 130, 65 ], 
   [ 15, 90, 150, 75 ], [ 15, 105, 180, 90 ], [ 17, 102, 170, 85 ], 
   [ 17, 119, 204, 102 ], [ 17, 136, 238, 119 ], [ 19, 133, 228, 114 ], 
   [ 19, 152, 266, 133 ], [ 19, 171, 304, 152 ] ]
 gap&gt; cc:=List([1..114],x-&gt;SCSeriesK(x,10));;
 gap&gt; gap&gt; cc:=List([1..114],x-&gt;SCSeriesK(x,10));;
 gap&gt; Set(List(cc,x-&gt;x.Homology));
 [ [ [ 0, [  ] ], [ 1, [  ] ], [ 0, [ 2 ] ], [ 0, [  ] ] ], 
   [ [ 0, [  ] ], [ 2, [  ] ], [ 1, [ 2 ] ], [ 0, [  ] ] ], 
   [ [ 0, [  ] ], [ 3, [  ] ], [ 3, [  ] ], [ 1, [  ] ] ] ]
 </pre></div>

<p><a id="X7B8300428516DAD8" name="X7B8300428516DAD8"></a></p>

<h5>6.3-8 SCSeriesKu</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSeriesKu</code>( <var class="Arg">n</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the symmetric orientable sphere bundle Ku<span class="SimpleMath">(n)</span> with <span class="SimpleMath">4n</span> vertices from <a href="chapBib.html#biBSpreer10Diss">[Spr10a]</a>, Section 4.5.2. The series is defined as a generalization of the slicings from <a href="chapBib.html#biBSpreer10Diss">[Spr10a]</a>, Section 3.3.</p>


<div class="example"><pre>
 gap&gt; c:=SCSeriesKu(4);                                    
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="Sl_16 = G{ [1,2,5,9],[1,2,9,10],[1,5,9,16] }"
  Dim=3
 
 /SimplicialComplex]
 gap&gt; SCSlicing(c,[[1,2,3,4,9,10,11,12],[5,6,7,8,13,14,15,16]]);
 [NormalSurface
 
  Properties known: ConnectedComponents, Dim, EulerCharacteristic, FVector, Fac\
 etsEx, Genus, IsConnected, IsOrientable, NSTriangulation, Name, TopologicalTyp\
 e, Vertices.
 
  Name="slicing [ [ 1, 2, 3, 4, 9, 10, 11, 12 ], [ 5, 6, 7, 8, 13, 14, 15, 16 ]\
  ] of Sl_16 = G{ [1,2,5,9],[1,2,9,10],[1,5,9,16] }"
  Dim=2
  FVector=[ 32, 80, 32, 16 ]
  EulerCharacteristic=0
  IsOrientable=true
  TopologicalType="T^2"
 
 /NormalSurface]
 gap&gt; Mminus:=SCSpan(c,[1,2,3,4,9,10,11,12]);;                  
 gap&gt; Mplus:=SCSpan(c,[5,6,7,8,13,14,15,16]);;                  
 gap&gt; SCCollapseGreedy(Mminus).Facets;
 [ [ 9, 10 ], [ 9, 12 ], [ 10, 11 ], [ 11, 12 ] ]
 gap&gt; SCCollapseGreedy(Mplus).Facets; 
 [ [ 13, 14 ], [ 13, 16 ], [ 14, 15 ], [ 15, 16 ] ]
 </pre></div>

<p><a id="X813C5B0E7FA7C1A3" name="X813C5B0E7FA7C1A3"></a></p>

<h5>6.3-9 SCSeriesL</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSeriesL</code>( <var class="Arg">i</var>, <var class="Arg">k</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Generates the <var class="Arg">k</var>-th member (<span class="SimpleMath">k ≥ 0</span>) of the series <var class="Arg">L^i</var>, <span class="SimpleMath">1 ≤ i ≤ 18</span> from <a href="chapBib.html#biBSpreer10Diss">[Spr10a]</a>. The <span class="SimpleMath">18</span> series describe a complete classification of all series of cyclic <span class="SimpleMath">3</span>-manifolds with a fixed number of difference cycles of order <span class="SimpleMath">2</span> (i. e. there is a member of the series for every second integer, <span class="SimpleMath">f_0 (L^i (k+1) ) = f_0 (L^i (k)) +2</span>) and at least one member with less than <span class="SimpleMath">15</span> vertices where each series does not appear as a sub series of one of the series <span class="SimpleMath">K^i</span> from <code class="func">SCSeriesK</code> (<a href="chap6.html#X78DA125479E1D77F"><span class="RefLink">6.3-7</span></a>).</p>


<div class="example"><pre>
 gap&gt; cc:=List([1..18],x-&gt;SCSeriesL(x,0));;
 gap&gt; Set(List(cc,x-&gt;x.F));
 [ [ 10, 45, 70, 35 ], [ 12, 60, 96, 48 ], [ 12, 66, 108, 54 ], 
   [ 14, 77, 126, 63 ], [ 14, 84, 140, 70 ], [ 14, 91, 154, 77 ] ]
 gap&gt; cc:=List([1..18],x-&gt;SCSeriesL(x,10));; 
 gap&gt; Set(List(cc,x-&gt;x.IsManifold));
 [ true ]
 </pre></div>

<p><a id="X7EAC6828812A241A" name="X7EAC6828812A241A"></a></p>

<h5>6.3-10 SCSeriesLe</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSeriesLe</code>( <var class="Arg">k</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Generates the <var class="Arg">k</var>-th member (<span class="SimpleMath">k ≥ 7</span>) of the series <code class="code">Le</code> from <a href="chapBib.html#biBSpreer10Diss">[Spr10a]</a>, Section 4.5.1. The series can be constructed as the generalization of the boundary of a genus <span class="SimpleMath">1</span> handlebody decomposition of the manifold <code class="code">manifold_3_14_1_5</code> from the classification in <a href="chapBib.html#biBLutz03TrigMnfFewVertVertTrans">[Lut03]</a>.</p>


<div class="example"><pre>
 gap&gt; c:=SCSeriesLe(7);                     
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="Le_14 = { (1:1:1:11),(1:2:4:7),(1:4:2:7),(2:1:4:7),(2:5:2:5),(2:4:2:6) \
 }"
  Dim=3
 
 /SimplicialComplex]
 gap&gt; d:=SCLib.DetermineTopologicalType(c);;
 gap&gt; SCReference(d);
 "manifold_3_14_1_5 in F.H.Lutz: 'The Manifold Page', http://www.math.tu-berlin\
 .de/diskregeom/stellar/,\r\nF.H.Lutz: 'Triangulated manifolds with few vertice\
 s and vertex-transitive group actions', Doctoral Thesis TU Berlin 1999, Shaker\
 -Verlag, Aachen 1999"
 </pre></div>

<p><a id="X7DDC1B127F21CFA4" name="X7DDC1B127F21CFA4"></a></p>

<h5>6.3-11 SCSeriesPrimeTorus</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSeriesPrimeTorus</code>( <var class="Arg">l</var>, <var class="Arg">j</var>, <var class="Arg">p</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Generates the well known triangulated torus <span class="SimpleMath">{ (l:j:p-l-j),(l:p-l-j:j) }</span> with <span class="SimpleMath">p</span> vertices, <span class="SimpleMath">3p</span> edges and <span class="SimpleMath">2p</span> triangles where <span class="SimpleMath">j</span> has to be greater than <span class="SimpleMath">l</span> and <span class="SimpleMath">p</span> must be any prime number greater than <span class="SimpleMath">6</span>.</p>


<div class="example"><pre>
 gap&gt; l:=List([2..19],x-&gt;SCSeriesPrimeTorus(1,x,41));; 
 gap&gt; Set(List(l,x-&gt;SCHomology(x)));
 [ [ [ 0, [  ] ], [ 2, [  ] ], [ 1, [  ] ] ] ]
 </pre></div>

<p><a id="X7F4308DB7C3699D1" name="X7F4308DB7C3699D1"></a></p>

<h4>6.4 <span class="Heading">Generating new complexes from old</span></h4>

<p><a id="X8255A2F97A7432F9" name="X8255A2F97A7432F9"></a></p>

<h5>6.4-1 SCCartesianPower</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCCartesianPower</code>( <var class="Arg">complex</var>, <var class="Arg">n</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>The new complex is <span class="SimpleMath">PL</span>-homeomorphic to <span class="SimpleMath">n</span> times the cartesian product of <var class="Arg">complex</var>, of dimensions <span class="SimpleMath">n ⋅ d</span> and has <span class="SimpleMath">f_d^n ⋅ n ⋅ frac2n-12^n-1}!</span> facets where <span class="SimpleMath">d</span> denotes the dimension and <span class="SimpleMath">f_d</span> denotes the number of facets of <var class="Arg">complex</var>. Note that the complex returned by the function is not the <span class="SimpleMath">n</span>-fold cartesian product <var class="Arg">complex</var><span class="SimpleMath">^n</span> of <var class="Arg">complex</var> (which, in general, is not simplicial) but a simplicial subdivision of <var class="Arg">complex</var><span class="SimpleMath">^n</span>.</p>


<div class="example"><pre>
 gap&gt; c:=SCBdSimplex(2);;
 gap&gt; 4torus:=SCCartesianPower(c,4);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, TopologicalType, Vertices.
 
  Name="(S^1_3)^4"
  Dim=4
  TopologicalType="(S^1)^4"
 
 /SimplicialComplex]
 gap&gt; 4torus.Homology;
 [ [ 0, [  ] ], [ 4, [  ] ], [ 6, [  ] ], [ 4, [  ] ], [ 1, [  ] ] ]
 gap&gt; 4torus.Chi;
 0
 gap&gt; 4torus.F;
 [ 81, 1215, 4050, 4860, 1944 ]
 </pre></div>

<p><a id="X859DA29B83BDE35E" name="X859DA29B83BDE35E"></a></p>

<h5>6.4-2 SCCartesianProduct</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCCartesianProduct</code>( <var class="Arg">complex1</var>, <var class="Arg">complex2</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the simplicial cartesian product of <var class="Arg">complex1</var> and <var class="Arg">complex2</var> where <var class="Arg">complex1</var> and <var class="Arg">complex2</var> are pure, simplicial complexes. The original vertex labeling of <var class="Arg">complex1</var> and <var class="Arg">complex2</var> is changed into the standard one. The new complex has vertex labels of type <span class="SimpleMath">[v_i, v_j]</span> where <span class="SimpleMath">v_i</span> is a vertex of <var class="Arg">complex1</var> and <span class="SimpleMath">v_j</span> is a vertex of <var class="Arg">complex2</var>.</p>

<p>If <span class="SimpleMath">n_i</span>, <span class="SimpleMath">i=1,2</span>, are the number facets and <span class="SimpleMath">d_i</span>, <span class="SimpleMath">i=1,2</span>, are the dimensions of <var class="Arg">complexi</var>, then the new complex has <span class="SimpleMath">n_1 ⋅ n_2 ⋅ d_1+d_2 choose d_1</span> facets. The number of vertices of the new complex equals the product of the numbers of vertices of the arguments.</p>


<div class="example"><pre>
 gap&gt; c1:=SCBdSimplex(2);;
 gap&gt; c2:=SCBdSimplex(3);;
 gap&gt; c3:=SCCartesianProduct(c1,c2);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, TopologicalType, Vertices.
 
  Name="S^1_3xS^2_4"
  Dim=3
  TopologicalType="S^1xS^1"
 
 /SimplicialComplex]
 gap&gt; c3.Homology;
 [ [ 0, [  ] ], [ 1, [  ] ], [ 1, [  ] ], [ 1, [  ] ] ]
 gap&gt; c3.F;
 [ 12, 48, 72, 36 ]
 </pre></div>

<p><a id="X82C9F57780C0B7F8" name="X82C9F57780C0B7F8"></a></p>

<h5>6.4-3 SCConnectedComponents</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCConnectedComponents</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: a list of simplicial complexes of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes all connected components of an arbitrary simplicial complex.</p>


<div class="example"><pre>
 gap&gt; c:=SC([[1,2,3],[3,4,5],[4,5,6,7,8]]);;
 gap&gt; SCRename(c,"connected complex");;
 gap&gt; SCConnectedComponents(c);
 [ [SimplicialComplex
     
      Properties known: Dim, FacetsEx, Name, Vertices.
     
      Name="Connected component #1 of connected complex"
      Dim=4
     
     /SimplicialComplex] ]
 gap&gt; c:=SC([[1,2,3],[4,5],[6,7,8]]);;
 gap&gt; SCRename(c,"non-connected complex");;
 gap&gt; SCConnectedComponents(c);
 [ [SimplicialComplex
     
      Properties known: Dim, FacetsEx, Name, Vertices.
     
      Name="Connected component #1 of non-connected complex"
      Dim=2
     
     /SimplicialComplex], [SimplicialComplex
     
      Properties known: Dim, FacetsEx, Name, Vertices.
     
      Name="Connected component #2 of non-connected complex"
      Dim=1
     
     /SimplicialComplex], [SimplicialComplex
     
      Properties known: Dim, FacetsEx, Name, Vertices.
     
      Name="Connected component #3 of non-connected complex"
      Dim=2
     
     /SimplicialComplex] ]
 </pre></div>

<p><a id="X7C63CDF28162C755" name="X7C63CDF28162C755"></a></p>

<h5>6.4-4 SCConnectedProduct</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCConnectedProduct</code>( <var class="Arg">complex</var>, <var class="Arg">n</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>If <span class="SimpleMath">n ≥ 2</span>, the function internally calls <span class="SimpleMath">1 ×</span> <code class="func">SCConnectedSum</code> (<a href="chap6.html#X81338CE18195607C"><span class="RefLink">6.4-5</span></a>) and <span class="SimpleMath">(n-2) ×</span> <code class="func">SCConnectedSumMinus</code> (<a href="chap6.html#X78B843417D63B408"><span class="RefLink">6.4-6</span></a>).</p>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("T^2"){[1..6]};
 [ [ 4, "T^2 (VT)" ], [ 5, "T^2 (VT)" ], [ 9, "T^2 (VT)" ], [ 10, "T^2 (VT)" ],
   [ 18, "T^2 (VT)" ], [ 20, "(T^2)#2" ] ]
 gap&gt; torus:=SCLib.Load(last[1][1]);;
 gap&gt; genus10:=SCConnectedProduct(torus,10);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="T^2 (VT)#+-T^2 (VT)#+-T^2 (VT)#+-T^2 (VT)#+-T^2 (VT)#+-T^2 (VT)#+-T^2 (\
 VT)#+-T^2 (VT)#+-T^2 (VT)#+-T^2 (VT)"
  Dim=2
 
 /SimplicialComplex]
 gap&gt; genus10.Chi;
 -18
 gap&gt; genus10.F;
 [ 43, 183, 122 ]
 </pre></div>

<p><a id="X81338CE18195607C" name="X81338CE18195607C"></a></p>

<h5>6.4-5 SCConnectedSum</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCConnectedSum</code>( <var class="Arg">complex1</var>, <var class="Arg">complex2</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>In a lexicographic ordering the smallest facet of both <var class="Arg">complex1</var> and <var class="Arg">complex2</var> is removed and the complexes are glued together along the resulting boundaries. The bijection used to identify the vertices of the boundaries differs from the one chosen in <code class="func">SCConnectedSumMinus</code> (<a href="chap6.html#X78B843417D63B408"><span class="RefLink">6.4-6</span></a>) by a transposition. Thus, the topological type of <code class="code">SCConnectedSum</code> is different from the one of <code class="func">SCConnectedSumMinus</code> (<a href="chap6.html#X78B843417D63B408"><span class="RefLink">6.4-6</span></a>) whenever <var class="Arg">complex1</var> and <var class="Arg">complex2</var> do not allow an orientation reversing homeomorphism.</p>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("T^2"){[1..6]};
 [ [ 4, "T^2 (VT)" ], [ 5, "T^2 (VT)" ], [ 9, "T^2 (VT)" ], [ 10, "T^2 (VT)" ],
   [ 18, "T^2 (VT)" ], [ 20, "(T^2)#2" ] ]
 gap&gt; torus:=SCLib.Load(last[1][1]);;
 gap&gt; genus2:=SCConnectedSum(torus,torus);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="T^2 (VT)#+-T^2 (VT)"
  Dim=2
 
 /SimplicialComplex]
 gap&gt; genus2.Homology;
 [ [ 0, [  ] ], [ 4, [  ] ], [ 1, [  ] ] ]
 gap&gt; genus2.Chi;
 -2
 </pre></div>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("CP^2");
 [ [ 16, "CP^2 (VT)" ], [ 99, "CP^2#-CP^2" ], [ 100, "CP^2#CP^2" ], 
   [ 400, "CP^2#(S^2xS^2)" ], [ 2486, "Gaifullin CP^2" ], 
   [ 4401, "(S^3~S^1)#(CP^2)^{#5} (VT)" ] ]
 gap&gt; cp2:=SCLib.Load(last[1][1]);;
 gap&gt; c1:=SCConnectedSum(cp2,cp2);;
 gap&gt; c2:=SCConnectedSumMinus(cp2,cp2);;
 gap&gt; c1.F=c2.F;
 true
 gap&gt; c1.ASDet=c2.ASDet;
 true
 gap&gt; SCIsIsomorphic(c1,c2);
 false
 gap&gt; PrintArray(SCIntersectionForm(c1));
 [ [  1,  0 ],
   [  0,  1 ] ]
 gap&gt; PrintArray(SCIntersectionForm(c2));
 [ [   1,   0 ],
   [   0,  -1 ] ]
 </pre></div>

<p><a id="X78B843417D63B408" name="X78B843417D63B408"></a></p>

<h5>6.4-6 SCConnectedSumMinus</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCConnectedSumMinus</code>( <var class="Arg">complex1</var>, <var class="Arg">complex2</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>In a lexicographic ordering the smallest facet of both <var class="Arg">complex1</var> and <var class="Arg">complex2</var> is removed and the complexes are glued together along the resulting boundaries. The bijection used to identify the vertices of the boundaries differs from the one chosen in <code class="func">SCConnectedSum</code> (<a href="chap6.html#X81338CE18195607C"><span class="RefLink">6.4-5</span></a>) by a transposition. Thus, the topological type of <code class="code">SCConnectedSumMinus</code> is different from the one of <code class="func">SCConnectedSum</code> (<a href="chap6.html#X81338CE18195607C"><span class="RefLink">6.4-5</span></a>) whenever <var class="Arg">complex1</var> and <var class="Arg">complex2</var> do not allow an orientation reversing homeomorphism.</p>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("T^2"){[1..6]};
 [ [ 4, "T^2 (VT)" ], [ 5, "T^2 (VT)" ], [ 9, "T^2 (VT)" ], [ 10, "T^2 (VT)" ],
   [ 18, "T^2 (VT)" ], [ 20, "(T^2)#2" ] ]
 gap&gt; torus:=SCLib.Load(last[1][1]);;
 gap&gt; genus2:=SCConnectedSumMinus(torus,torus);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="T^2 (VT)#+-T^2 (VT)"
  Dim=2
 
 /SimplicialComplex]
 gap&gt; genus2.Homology;
 [ [ 0, [  ] ], [ 4, [  ] ], [ 1, [  ] ] ]
 gap&gt; genus2.Chi;
 -2
 </pre></div>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("CP^2");
 [ [ 16, "CP^2 (VT)" ], [ 99, "CP^2#-CP^2" ], [ 100, "CP^2#CP^2" ], 
   [ 400, "CP^2#(S^2xS^2)" ], [ 2486, "Gaifullin CP^2" ], 
   [ 4401, "(S^3~S^1)#(CP^2)^{#5} (VT)" ] ]
 gap&gt; cp2:=SCLib.Load(last[1][1]);;
 gap&gt; c1:=SCConnectedSum(cp2,cp2);;
 gap&gt; c2:=SCConnectedSumMinus(cp2,cp2);;
 gap&gt; c1.F=c2.F;
 true
 gap&gt; c1.ASDet=c2.ASDet;
 true
 gap&gt; SCIsIsomorphic(c1,c2);
 false
 gap&gt; PrintArray(SCIntersectionForm(c1));
 [ [  1,  0 ],
   [  0,  1 ] ]
 gap&gt; PrintArray(SCIntersectionForm(c2));
 [ [   1,   0 ],
   [   0,  -1 ] ]
 </pre></div>

<p><a id="X84F3487182AB102A" name="X84F3487182AB102A"></a></p>

<h5>6.4-7 SCDifferenceCycleCompress</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCDifferenceCycleCompress</code>( <var class="Arg">simplex</var>, <var class="Arg">modulus</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: list with possibly duplicate entries upon success, <code class="keyw">fail</code> otherwise.</p>

<p>A difference cycle is returned, i. e. a list of integer values of length <span class="SimpleMath">(d+1)</span>, if <span class="SimpleMath">d</span> is the dimension of <var class="Arg">simplex</var>, and a sum equal to <var class="Arg">modulus</var>. In some sense this is the inverse operation of <code class="func">SCDifferenceCycleExpand</code> (<a href="chap6.html#X8510B6CF85070A28"><span class="RefLink">6.4-8</span></a>).</p>


<div class="example"><pre>
 gap&gt; sphere:=SCBdSimplex(4);;
 gap&gt; gens:=SCGenerators(sphere);
 [ [ [ 1, 2, 3, 4 ], [ 5 ] ] ]
 gap&gt; diffcycle:=SCDifferenceCycleCompress(gens[1][1],5);
 [ 1, 1, 1, 2 ]
 gap&gt; c:=SCDifferenceCycleExpand([1,1,1,2]);;
 gap&gt; c.Facets;
 [ [ 1, 2, 3, 4 ], [ 1, 2, 3, 5 ], [ 1, 2, 4, 5 ], [ 1, 3, 4, 5 ], 
   [ 2, 3, 4, 5 ] ]
 </pre></div>

<p><a id="X8510B6CF85070A28" name="X8510B6CF85070A28"></a></p>

<h5>6.4-8 SCDifferenceCycleExpand</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCDifferenceCycleExpand</code>( <var class="Arg">diffcycle</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p><var class="Arg">diffcycle</var> induces a simplex <span class="SimpleMath">∆ = ( v_1 , ... , v_n+1 )</span> by <span class="SimpleMath">v_1 =</span><var class="Arg">diffcycle[1]</var>, <span class="SimpleMath">v_i = v_i-1 +</span> <var class="Arg">diffcycle[i]</var> and a cyclic group action by <span class="SimpleMath">Z_σ</span> where <span class="SimpleMath">σ = ∑</span> <var class="Arg">diffcycle[i]</var> is the modulus of <code class="code">diffcycle</code>. The function returns the <span class="SimpleMath">Z_σ</span>-orbit of <span class="SimpleMath">∆</span>.</p>

<p>Note that modulo operations in <strong class="pkg">GAP</strong> are often a little bit cumbersome, since all integer ranges usually start from <span class="SimpleMath">1</span>.</p>


<div class="example"><pre>
 gap&gt; c:=SCDifferenceCycleExpand([1,1,2]);;
 gap&gt; c.Facets;
 [ [ 1, 2, 3 ], [ 1, 2, 4 ], [ 1, 3, 4 ], [ 2, 3, 4 ] ]
 </pre></div>

<p><a id="X8278E1157A318C32" name="X8278E1157A318C32"></a></p>

<h5>6.4-9 SCStronglyConnectedComponents</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCStronglyConnectedComponents</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: a list of simplicial complexes of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes all strongly connected components of an arbitrary simplicial complex.</p>


<div class="example"><pre>
 gap&gt; c:=SC([[1,2,3],[3,4,5],[4,5,6,7,8,9],[6,7,8,9,10,11]]);;
 gap&gt; comps:=SCStronglyConnectedComponents(c);
 [ [SimplicialComplex
     
      Properties known: Dim, FacetsEx, Name, Vertices.
     
      Name="Strongly connected component #1 of unnamed complex 74"
      Dim=2
     
     /SimplicialComplex], [SimplicialComplex
     
      Properties known: Dim, FacetsEx, Name, Vertices.
     
      Name="Strongly connected component #2 of unnamed complex 74"
      Dim=5
     
     /SimplicialComplex], [SimplicialComplex
     
      Properties known: Dim, FacetsEx, Name, Vertices.
     
      Name="Strongly connected component #3 of unnamed complex 74"
      Dim=5
     
     /SimplicialComplex] ]
 gap&gt; comps[1].Facets;
 [ [ 1, 2, 3 ] ]
 gap&gt; comps[2].Facets;
 [ [ 3, 4, 5 ], [ 4, 5, 6, 7, 8, 9 ] ]
 gap&gt; comps[3].Facets;
 [ [ 6, 7, 8, 9, 10, 11 ] ]
 </pre></div>

<p><a id="X87C1C49987E75A9C" name="X87C1C49987E75A9C"></a></p>

<h4>6.5 <span class="Heading">Simplicial complexes from transitive permutation groups</span></h4>

<p>Beginning from Version 1.3.0, <strong class="pkg">simpcomp</strong> is able to generate triangulations from a prescribed transitive group action on its set of vertices. Note that the corresponding group is a subgroup of the full automorphism group, but not necessarily the full automorphism group of the triangulations obtained in this way. The methods and algorithms are based on the works of Frank H. Lutz <a href="chapBib.html#biBLutz03TrigMnfFewVertVertTrans">[Lut03]</a>, <a href="chapBib.html#biBLutz08ManifoldPage">[ManifoldPage]</a> and in particular his program <code class="code">MANIFOLD_VT</code>.</p>

<p><a id="X7C1592677A76A3E5" name="X7C1592677A76A3E5"></a></p>

<h5>6.5-1 SCsFromGroupExt</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCsFromGroupExt</code>( <var class="Arg">G</var>, <var class="Arg">n</var>, <var class="Arg">d</var>, <var class="Arg">objectType</var>, <var class="Arg">cache</var>, <var class="Arg">removeDoubleEntries</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: a list of simplicial complexes of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes all combinatorial <var class="Arg">d</var>-pseudomanifolds as a union of orbits of the group action of <var class="Arg">G</var> on <code class="code">(d+1)</code>-tuples on the set of <var class="Arg">n</var> vertices, see <a href="chapBib.html#biBLutz03TrigMnfFewVertVertTrans">[Lut03]</a>. The integer argument <var class="Arg">objectType</var> specifies, whether complexes exceeding the maximal size of each vertex link for combinatorial manifolds are sorted out (<code class="code">objectType = 0</code>) or not (<code class="code">objectType = 1</code>, in this case some combinatorial pseudomanifolds won't be found, but no combinatorial manifold will be sorted out). The integer argument <var class="Arg">cache</var> specifies if the orbits are held in memory during the computation, a value of <code class="code">0</code> means that the orbits are discarded, trading speed for memory, any other value means that they are kept, trading memory for speed. The boolean argument <var class="Arg">removeDoubleEntries</var> specifies whether the results are checked for combinatorial isomorphism, preventing isomorphic entries.</p>


<div class="example"><pre>
 gap&gt; G:=PrimitiveGroup(8,5);
 PGL(2, 7)
 gap&gt; Size(G);
 336
 gap&gt; Transitivity(G);
 3
 gap&gt; list:=SCsFromGroupExt(G,8,3,1,0,true);
 [ [SimplicialComplex
     
      Properties known: Dim, FacetsEx, Name, Vertices.
     
      Name="Complex 1 of PGL(2, 7) (single orbit)"
      Dim=3
     
     /SimplicialComplex] ]
 gap&gt; SCNeighborliness(list[1]); 
 3
 gap&gt; list[1].F;
 [ 8, 28, 56, 28 ]
 gap&gt; list[1].IsManifold; 
 false
 gap&gt; SCLibDetermineTopologicalType(SCLink(list[1],1));
 [SimplicialComplex
 
  Properties known: BoundaryEx, Dim, FacetsEx, HasBoundary, 
                    IsPseudoManifold, Name, SkelExs[], Vertices.
 
  Name="lk([ 1 ]) in Complex 1 of PGL(2, 7) (single orbit)"
  Dim=2
  HasBoundary=false
  IsPseudoManifold=true
 
 /SimplicialComplex]
 gap&gt; # there are no 3-neighborly 3-manifolds with 8 vertices
 gap&gt; list:=SCsFromGroupExt(PrimitiveGroup(8,5),8,3,0,0,true); 
 gap&gt; [  ]
 </pre></div>

<p><a id="X7A04D77085D9BE4E" name="X7A04D77085D9BE4E"></a></p>

<h5>6.5-2 SCsFromGroupByTransitivity</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCsFromGroupByTransitivity</code>( <var class="Arg">n</var>, <var class="Arg">d</var>, <var class="Arg">k</var>, <var class="Arg">maniflag</var>, <var class="Arg">computeAutGroup</var>, <var class="Arg">removeDoubleEntries</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: a list of simplicial complexes of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes all combinatorial <var class="Arg">d</var>-pseudomanifolds as union of orbits of group actions for all <var class="Arg">k</var>-transitive groups on <code class="code">(d+1)</code>-tuples on the set of <var class="Arg">n</var> vertices, see <a href="chapBib.html#biBLutz03TrigMnfFewVertVertTrans">[Lut03]</a>. The boolean argument <var class="Arg">maniflag</var> specifies, whether the resulting complexes should be listed separately by combinatorial manifolds, combinatorial pseudomanifolds and complexes where the verification that the object is at least a combinatorial pseudomanifold failed. The boolean argument <var class="Arg">computeAutGroup</var> specifies whether or not the real automorphism group should be computed (note that a priori the generating group is just a subgroup of the automorphism group). The boolean argument <var class="Arg">removeDoubleEntries</var> specifies whether the results are checked for combinatorial isomorphism, preventing isomorphic entries. Internally calls <code class="func">SCsFromGroupExt</code> (<a href="chap6.html#X7C1592677A76A3E5"><span class="RefLink">6.5-1</span></a>) for every group.</p>


<div class="example"><pre>
 gap&gt; list:=SCsFromGroupByTransitivity(8,3,2,true,true,true);
 #I  SCsFromGroupByTransitivity: Building list of groups...
 #I  SCsFromGroupByTransitivity: ...2 groups found.
 #I  degree 8: [ AGL(1, 8), PSL(2, 7) ]
 #I  SCsFromGroupByTransitivity: Processing dimension 3.
 #I  SCsFromGroupByTransitivity: Processing degree 8.
 #I  SCsFromGroupByTransitivity: 1 / 2 groups calculated, found 0 complexes.
 #I  SCsFromGroupByTransitivity: Calculating 
 0 automorphism and homology groups...
 #I  SCsFromGroupByTransitivity: ...all automorphism groups calculated for grou\
 p 1 / 2.
 #I  SCsFromGroupByTransitivity: 2 / 2 groups calculated, found 1 complexes.
 #I  SCsFromGroupByTransitivity: Calculating 
 1 automorphism and homology groups...
 #I  group not listed
 #I  SCsFromGroupByTransitivity: 1 / 1 automorphism groups calculated.
 #I  SCsFromGroupByTransitivity: ...all automorphism groups calculated for grou\
 p 2 / 2.
 #I  SCsFromGroupByTransitivity: Checking for double entries...
 #I  SCsFromGroupByTransitivity: ...done dim = 3, deg =  8, 0 manifolds, 
 1 pseudomanifolds, 0 candidates found.
 #I  SCsFromGroupByTransitivity: ...done dim = 3.
 [ [  ], [ [SimplicialComplex
         
          Properties known: AutomorphismGroup, AutomorphismGroupSize, 
                            AutomorphismGroupStructure, 
                            AutomorphismGroupTransitivity, BoundaryEx, Dim, 
                            DualGraph, FVector, FacetsEx, GeneratorsEx, 
                            HasBoundary, Homology, IsConnected, IsEmpty, 
                            IsManifold, IsPseudoManifold, Name, NumFaces[], 
                            SkelExs[], Vertices.
         
          Name="Complex 1 of PSL(2, 7) (multiple orbits)"
          Dim=3
          AutomorphismGroupSize=336
          AutomorphismGroupStructure="PSL(3,2) : C2"
          AutomorphismGroupTransitivity=3
          FVector=[ 8, 28, 56, 28 ]
          HasBoundary=false
          Homology=[ [ 0, [ ] ], [ 0, [ ] ], [ 8, [ ] ], [ 1, [ ] ] ]
          IsConnected=true
          IsPseudoManifold=true
         
         /SimplicialComplex] ], [  ] ]
 </pre></div>

<p><a id="X81CE90127800B91A" name="X81CE90127800B91A"></a></p>

<h4>6.6 <span class="Heading">Computing properties of simplicial complexes</span></h4>

<p>The following functions compute basic properties of simplicial complexes of type <code class="code">SCSimplicialComplex</code>. None of these functions alter the complex. All properties are returned as immutable objects (this ensures data consistency of the cached properties of a simplicial complex). Use <code class="code">ShallowCopy</code> or the internal <strong class="pkg">simpcomp</strong> function <code class="code">SCIntFunc.DeepCopy</code> to get a mutable copy.</p>

<p>Note: every simplicial complex is internally stored with the standard vertex labeling from <span class="SimpleMath">1</span> to <span class="SimpleMath">n</span> and a maptable to restore the original vertex labeling. Thus, we have to relabel some of the complex properties (facets, face lattice, generators, etc...) whenever we want to return them to the user. As a consequence, some of the functions exist twice, one of them with the appendix "Ex". These functions return the standard labeling whereas the other ones relabel the result to the original labeling.</p>

<p><a id="X7B69B327809F67A0" name="X7B69B327809F67A0"></a></p>

<h5>6.6-1 SCAltshulerSteinberg</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCAltshulerSteinberg</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: a non-negative integer upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the Altshuler-Steinberg determinant.</p>

<p>Definition: Let <span class="SimpleMath">v_i</span>, <span class="SimpleMath">1 ≤ i ≤ n</span> be the vertices and let <span class="SimpleMath">F_j</span>, <span class="SimpleMath">1 ≤ j ≤ m</span> be the facets of a pure simplicial complex <span class="SimpleMath">C</span>, then the determinant of <span class="SimpleMath">AS ∈ Z^n × m</span>, <span class="SimpleMath">AS_ij=1</span> if <span class="SimpleMath">v_i ∈ F_j</span>, <span class="SimpleMath">AS_ij=0</span> otherwise, is called the Altshuler-Steinberg matrix. The Altshuler-Steinberg determinant is the determinant of the quadratic matrix <span class="SimpleMath">AS ⋅ AS^T</span>.</p>

<p>The Altshuler-Steinberg determinant is a combinatorial invariant of <span class="SimpleMath">C</span> and can be checked before searching for an isomorphism between two simplicial complexes.</p>


<div class="example"><pre>
 gap&gt; list:=SCLib.SearchByName("T^2");; 
 gap&gt; torus:=SCLib.Load(last[1][1]);;
 gap&gt; SCAltshulerSteinberg(torus);
 73728
 gap&gt; c:=SCBdSimplex(3);;
 gap&gt; SCAltshulerSteinberg(c);
 9
 gap&gt; c:=SCBdSimplex(4);;
 gap&gt; SCAltshulerSteinberg(c);
 16
 gap&gt; c:=SCBdSimplex(5);;
 gap&gt; SCAltshulerSteinberg(c);
 25
 </pre></div>

<p><a id="X7B88925386E197AC" name="X7B88925386E197AC"></a></p>

<h5>6.6-2 SCAutomorphismGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCAutomorphismGroup</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: a <strong class="pkg">GAP</strong> permutation group upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the automorphism group of a strongly connected pseudomanifold <var class="Arg">complex</var>, i. e. the group of all automorphisms on the set of vertices of <var class="Arg">complex</var> that do not change the complex as a whole. Necessarily the group is a subgroup of the symmetric group <span class="SimpleMath">S_n</span> where <span class="SimpleMath">n</span> is the number of vertices of the simplicial complex.</p>

<p>The function uses an efficient algorithm provided by the package <strong class="pkg">GRAPE</strong> (see <a href="chapBib.html#biBSoicher06GRAPE">[Soi06]</a>, which is based on the program <code class="code">nauty</code> by Brendan McKay <a href="chapBib.html#biBMcKay84Nauty">[McK84]</a>). If the package <strong class="pkg">GRAPE</strong> is not available, this function call falls back to <code class="func">SCAutomorphismGroupInternal</code> (<a href="chap6.html#X7A33B8177A7ACD3A"><span class="RefLink">6.6-3</span></a>).</p>

<p>The position of the group in the <strong class="pkg">GAP</strong> libraries of small groups, transitive groups or primitive groups is given. If the group is not listed, its structure description, provided by the <strong class="pkg">GAP</strong> function <code class="code">StructureDescription()</code>, is returned as the name of the group. Note that the latter form is not always unique, since every non trivial semi-direct product is denoted by ''<code class="code">:</code>''.</p>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("K3");            
 [ [ 7494, "K3 surface" ] ]
 gap&gt; k3surf:=SCLib.Load(last[1][1]);; 
 gap&gt; SCAutomorphismGroup(k3surf);               
 Group([ (1,3,8,4,9,16,15,2,14,12,6,7,13,5,10), 
   (1,13)(2,14)(3,15)(4,16)(5,9)(6,10)(7,11)(8,12) ])
 </pre></div>

<p><a id="X7A33B8177A7ACD3A" name="X7A33B8177A7ACD3A"></a></p>

<h5>6.6-3 SCAutomorphismGroupInternal</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCAutomorphismGroupInternal</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: a <strong class="pkg">GAP</strong> permutation group upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the automorphism group of a strongly connected pseudomanifold <var class="Arg">complex</var>, i. e. the group of all automorphisms on the set of vertices of <var class="Arg">complex</var> that do not change the complex as a whole. Necessarily the group is a subgroup of the symmetric group <span class="SimpleMath">S_n</span> where <span class="SimpleMath">n</span> is the number of vertices of the simplicial complex.</p>

<p>The position of the group in the <strong class="pkg">GAP</strong> libraries of small groups, transitive groups or primitive groups is given. If the group is not listed, its structure description, provided by the <strong class="pkg">GAP</strong> function <code class="code">StructureDescription()</code>, is returned as the name of the group. Note that the latter form is not always unique, since every non trivial semi-direct product is denoted by ''<code class="code">:</code>''.</p>


<div class="example"><pre>
 gap&gt; c:=SCBdSimplex(5);;
 gap&gt; SCAutomorphismGroupInternal(c);
 Sym( [ 1 .. 6 ] )
 </pre></div>


<div class="example"><pre>
 gap&gt; c:=SC([[1,2],[2,3],[1,3]]);;
 gap&gt; g:=SCAutomorphismGroupInternal(c);
 PrimitiveGroup(3,2) = S(3)
 gap&gt; List(g);
 [ (), (1,3,2), (1,2,3), (2,3), (1,3), (1,2) ]
 gap&gt; StructureDescription(g);
 "S3"
 </pre></div>

<p><a id="X78F6EF808047772C" name="X78F6EF808047772C"></a></p>

<h5>6.6-4 SCAutomorphismGroupSize</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCAutomorphismGroupSize</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: a positive integer group upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the size of the automorphism group of a strongly connected pseudomanifold <var class="Arg">complex</var>, see <code class="func">SCAutomorphismGroup</code> (<a href="chap6.html#X7B88925386E197AC"><span class="RefLink">6.6-2</span></a>).</p>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("K3");            
 [ [ 7494, "K3 surface" ] ]
 gap&gt; k3surf:=SCLib.Load(last[1][1]);;           
 gap&gt; SCAutomorphismGroupSize(k3surf);               
 240
 </pre></div>

<p><a id="X7EAC3A5D7A3339BB" name="X7EAC3A5D7A3339BB"></a></p>

<h5>6.6-5 SCAutomorphismGroupStructure</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCAutomorphismGroupStructure</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: the <strong class="pkg">GAP</strong> structure description upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the <strong class="pkg">GAP</strong> structure description of the automorphism group of a strongly connected pseudomanifold <var class="Arg">complex</var>, see <code class="func">SCAutomorphismGroup</code> (<a href="chap6.html#X7B88925386E197AC"><span class="RefLink">6.6-2</span></a>).</p>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("K3");     
 [ [ 7494, "K3 surface" ] ]
 gap&gt; k3surf:=SCLib.Load(last[1][1]);;      
 gap&gt; SCAutomorphismGroupStructure(k3surf);
 "((C2 x C2 x C2 x C2) : C5) : C3"
 </pre></div>

<p><a id="X7E9D5C257F88E5E0" name="X7E9D5C257F88E5E0"></a></p>

<h5>6.6-6 SCAutomorphismGroupTransitivity</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCAutomorphismGroupTransitivity</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: a positive integer upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the transitivity of the automorphism group of a strongly connected pseudomanifold <var class="Arg">complex</var>, i. e. the maximal integer <span class="SimpleMath">t</span> such that for any two ordered <span class="SimpleMath">t</span>-tuples <span class="SimpleMath">T_1</span> and <span class="SimpleMath">T_2</span> of vertices of <var class="Arg">complex</var>, there exists an element <span class="SimpleMath">g</span> in the automorphism group of <var class="Arg">complex</var> for which <span class="SimpleMath">gT_1=T_2</span>, see <a href="chapBib.html#biBHuppert67EndlGruppen">[Hup67]</a>.</p>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("K3");            
 [ [ 7494, "K3 surface" ] ]
 gap&gt; k3surf:=SCLib.Load(last[1][1]);;           
 gap&gt; SCAutomorphismGroupTransitivity(k3surf);               
 2
 </pre></div>

<p><a id="X836DC73380EA7414" name="X836DC73380EA7414"></a></p>

<h5>6.6-7 SCBoundary</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCBoundary</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>The function computes the boundary of a simplicial complex <var class="Arg">complex</var> satisfying the weak pseudomanifold property and returns it as a simplicial complex. In addition, it is stored as a property of <var class="Arg">complex</var>.</p>

<p>The boundary of a simplicial complex is defined as the simplicial complex consisting of all <span class="SimpleMath">d-1</span>-faces that are contained in exactly one facet.</p>

<p>If <var class="Arg">complex</var> does not fulfill the weak pseudomanifold property (i. e. if the valence of any <span class="SimpleMath">d-1</span>-face exceeds <span class="SimpleMath">2</span>) the function returns <code class="keyw">fail</code>.</p>


<div class="example"><pre>
 gap&gt; c:=SC([[1,2,3,4],[1,2,3,5],[1,2,4,5],[1,3,4,5]]);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="unnamed complex 50"
  Dim=3
 
 /SimplicialComplex]
 gap&gt; SCBoundary(c);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="Bd(unnamed complex 50)"
  Dim=2
 
 /SimplicialComplex]
 gap&gt; c;  
 [SimplicialComplex
 
  Properties known: BoundaryEx, Dim, FacetsEx, HasBoundary, Name, 
                    SkelExs[], Vertices.
 
  Name="unnamed complex 50"
  Dim=3
  HasBoundary=true
 
 /SimplicialComplex]
 </pre></div>

<p><a id="X812AE7397B4FC88E" name="X812AE7397B4FC88E"></a></p>

<h5>6.6-8 SCDehnSommervilleCheck</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCDehnSommervilleCheck</code>( <var class="Arg">c</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Checks if the simplicial complex <var class="Arg">c</var> fulfills the Dehn Sommerville equations: <span class="SimpleMath">h_j - h_d+1-j = (-1)^d+1-j d+1 choose j (χ (M) - 2)</span> for <span class="SimpleMath">0 ≤ j ≤ fracd2</span> and <span class="SimpleMath">d</span> even, and <span class="SimpleMath">h_j - h_d+1-j = 0</span> for <span class="SimpleMath">0 ≤ j ≤ fracd-12</span> and <span class="SimpleMath">d</span> odd. Where <span class="SimpleMath">h_j</span> is the <span class="SimpleMath">j</span>th component of the <span class="SimpleMath">h</span>-vector, see <code class="func">SCHVector</code> (<a href="chap6.html#X84FBF0A685547ECD"><span class="RefLink">6.6-25</span></a>).</p>


<div class="example"><pre>
 gap&gt; c:=SCBdCrossPolytope(6);;
 gap&gt; SCDehnSommervilleCheck(c);
 true
 gap&gt; c:=SC([[1,2,3],[1,4,5]]);;
 gap&gt; SCDehnSommervilleCheck(c);
 false
 </pre></div>

<p><a id="X859C3981831B4B81" name="X859C3981831B4B81"></a></p>

<h5>6.6-9 SCDehnSommervilleMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCDehnSommervilleMatrix</code>( <var class="Arg">d</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: a <code class="code">(d+1)</code><span class="SimpleMath">×</span><code class="code">Int(d+1/2)</code> matrix with integer entries upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the coefficients of the Dehn Sommerville equations for dimension <code class="code">d</code>: <span class="SimpleMath">h_j - h_d+1-j = (-1)^d+1-j d+1 choose j (χ (M) - 2)</span> for <span class="SimpleMath">0 ≤ j ≤ fracd2</span> and <span class="SimpleMath">d</span> even, and <span class="SimpleMath">h_j - h_d+1-j = 0</span> for <span class="SimpleMath">0 ≤ j ≤ fracd-12</span> and <span class="SimpleMath">d</span> odd. Where <span class="SimpleMath">h_j</span> is the <span class="SimpleMath">j</span>th component of the <span class="SimpleMath">h</span>-vector, see <code class="func">SCHVector</code> (<a href="chap6.html#X84FBF0A685547ECD"><span class="RefLink">6.6-25</span></a>).</p>


<div class="example"><pre>
 gap&gt; m:=SCDehnSommervilleMatrix(6);;
 gap&gt; PrintArray(m);
 [ [    1,   -1,    1,   -1,    1,   -1,    1 ],
   [    0,   -2,    3,   -4,    5,   -6,    7 ],
   [    0,    0,    0,   -4,   10,  -20,   35 ],
   [    0,    0,    0,    0,    0,   -6,   21 ] ]
 </pre></div>

<p><a id="X82351AAE793DCB68" name="X82351AAE793DCB68"></a></p>

<h5>6.6-10 SCDim</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCDim</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: an integer <span class="SimpleMath">≥ -1</span> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the dimension of a simplicial complex. If the complex is not pure, the dimension of the highest dimensional simplex is returned.</p>


<div class="example"><pre>
 gap&gt; complex:=SC([[1,2,3], [1,2,4], [1,3,4], [2,3,4]]);;
 gap&gt; SCDim(complex);                                    
 2
 gap&gt; c:=SC([[1], [2,4], [3,4], [5,6,7,8]]);;
 gap&gt; SCDim(c);
 3
 </pre></div>

<p><a id="X798175C58050DDBD" name="X798175C58050DDBD"></a></p>

<h5>6.6-11 SCDualGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCDualGraph</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: 1-dimensional simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the dual graph of <var class="Arg">complex</var>.</p>


<div class="example"><pre>
 gap&gt; sphere:=SCBdSimplex(5);;
 gap&gt; graph:=SCFaces(sphere,1);       
 [ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 1, 5 ], [ 1, 6 ], [ 2, 3 ], [ 2, 4 ], 
   [ 2, 5 ], [ 2, 6 ], [ 3, 4 ], [ 3, 5 ], [ 3, 6 ], [ 4, 5 ], [ 4, 6 ], 
   [ 5, 6 ] ]
 gap&gt; graph:=SC(graph);;              
 gap&gt; dualGraph:=SCDualGraph(sphere); 
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="dual graph of S^4_6"
  Dim=1
 
 /SimplicialComplex]
 gap&gt; graph.Facets = dualGraph.Facets;
 true
 </pre></div>

<p><a id="X788BAE187D584103" name="X788BAE187D584103"></a></p>

<h5>6.6-12 SCEulerCharacteristic</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCEulerCharacteristic</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: integer upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the Euler characteristic <span class="Math"> Computes the Euler characteristic </span> of a simplicial complex <span class="SimpleMath">C</span>, where <span class="SimpleMath">f_i</span> denotes the <span class="SimpleMath">i</span>-th component of the <span class="SimpleMath">f</span>-vector.</p>


<div class="example"><pre>
 gap&gt; complex:=SCFromFacets([[1,2,3], [1,2,4], [1,3,4], [2,3,4]]);;
 gap&gt; SCEulerCharacteristic(complex);
 2
 gap&gt; s2:=SCBdSimplex(3);;
 gap&gt; s2.EulerCharacteristic;
 2
 </pre></div>

<p><a id="X81F8071385FD9C1D" name="X81F8071385FD9C1D"></a></p>

<h5>6.6-13 SCFVector</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCFVector</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: a list of non-negative integers upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the <span class="SimpleMath">f</span>-vector of the simplicial complex <var class="Arg">complex</var>, i. e. the number of <span class="SimpleMath">i</span>-dimensional faces for <span class="SimpleMath">0 ≤ i ≤ d</span>, where <span class="SimpleMath">d</span> is the dimension of <var class="Arg">complex</var>. A memory-saving implicit algorithm is used that avoids calculating the face lattice of the complex. Internally calls <code class="func">SCNumFaces</code> (<a href="chap6.html#X7AC2427184B44C65"><span class="RefLink">6.6-48</span></a>).</p>


<div class="example"><pre>
 gap&gt; complex:=SC([[1,2,3], [1,2,4], [1,3,4], [2,3,4]]);;
 gap&gt; SCFVector(complex);
 [ 4, 6, 4 ]
 </pre></div>

<p><a id="X7F8B561C823DDDBA" name="X7F8B561C823DDDBA"></a></p>

<h5>6.6-14 SCFaceLattice</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCFaceLattice</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: a list of face lists upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the entire face lattice of a <span class="SimpleMath">d</span>-dimensional simplicial complex, i. e. all of its <span class="SimpleMath">i</span>-skeletons for <span class="SimpleMath">0 ≤ i ≤ d</span>. The faces are returned in the original labeling.</p>


<div class="example"><pre>
 gap&gt; c:=SC([["a","b","c"],["a","b","d"], ["a","c","d"], ["b","c","d"]]);;
 gap&gt; SCFaceLattice(c);
 [ [ [ "a" ], [ "b" ], [ "c" ], [ "d" ] ], 
   [ [ "a", "b" ], [ "a", "c" ], [ "a", "d" ], [ "b", "c" ], [ "b", "d" ], 
       [ "c", "d" ] ], 
   [ [ "a", "b", "c" ], [ "a", "b", "d" ], [ "a", "c", "d" ], 
       [ "b", "c", "d" ] ] ]
 </pre></div>

<p><a id="X7AE0029985BD0775" name="X7AE0029985BD0775"></a></p>

<h5>6.6-15 SCFaceLatticeEx</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCFaceLatticeEx</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: a list of face lists upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the entire face lattice of a <span class="SimpleMath">d</span>-dimensional simplicial complex, i. e. all of its <span class="SimpleMath">i</span>-skeletons for <span class="SimpleMath">0 ≤ i ≤ d</span>. The faces are returned in the standard labeling.</p>


<div class="example"><pre>
 gap&gt; c:=SC([["a","b","c"],["a","b","d"], ["a","c","d"], ["b","c","d"]]);;
 gap&gt; SCFaceLatticeEx(c);
 [ [ [ 1 ], [ 2 ], [ 3 ], [ 4 ] ], 
   [ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 3 ], [ 2, 4 ], [ 3, 4 ] ], 
   [ [ 1, 2, 3 ], [ 1, 2, 4 ], [ 1, 3, 4 ], [ 2, 3, 4 ] ] ]
 </pre></div>

<p><a id="X7F6FE9B27B8D6922" name="X7F6FE9B27B8D6922"></a></p>

<h5>6.6-16 SCFaces</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCFaces</code>( <var class="Arg">complex</var>, <var class="Arg">k</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: a face list upon success, <code class="keyw">fail</code> otherwise.</p>

<p>This is a synonym of the function <code class="func">SCSkel</code> (<a href="chap7.html#X8026B46F8236124D"><span class="RefLink">7.3-13</span></a>).</p>

<p><a id="X7B40DFE780A47109" name="X7B40DFE780A47109"></a></p>

<h5>6.6-17 SCFacesEx</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCFacesEx</code>( <var class="Arg">complex</var>, <var class="Arg">k</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: a face list upon success, <code class="keyw">fail</code> otherwise.</p>

<p>This is a synonym of the function <code class="func">SCSkelEx</code> (<a href="chap7.html#X84ACF7D580FE8B76"><span class="RefLink">7.3-14</span></a>).</p>

<p><a id="X7BDD568184E3419D" name="X7BDD568184E3419D"></a></p>

<h5>6.6-18 SCFacets</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCFacets</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: a facet list upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Returns the facets of a simplicial complex in the original vertex labeling.</p>


<div class="example"><pre>
 gap&gt; c:=SC([[2,3],[3,4],[4,2]]);;
 gap&gt; SCFacets(c);
 [ [ 2, 3 ], [ 2, 4 ], [ 3, 4 ] ]
 </pre></div>

<p><a id="X87DC942881235E25" name="X87DC942881235E25"></a></p>

<h5>6.6-19 SCFacetsEx</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCFacetsEx</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: a facet list upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Returns the facets of a simplicial complex as they are stored, i. e. with standard vertex labeling from 1 to n.</p>


<div class="example"><pre>
 gap&gt; c:=SC([[2,3],[3,4],[4,2]]);;
 gap&gt; SCFacetsEx(c);
 [ [ 1, 2 ], [ 1, 3 ], [ 2, 3 ] ]
 </pre></div>

<p><a id="X79F60850875BB683" name="X79F60850875BB683"></a></p>

<h5>6.6-20 SCFpBettiNumbers</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCFpBettiNumbers</code>( <var class="Arg">complex</var>, <var class="Arg">p</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: a list of non-negative integers upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the Betti numbers of a simplicial complex with respect to the field <span class="SimpleMath">F_p</span> for any prime number <code class="code">p</code>.</p>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("K^2");    
 [ [ 17, "K^2 (VT)" ], [ 571, "K^2 (VT)" ] ]
 gap&gt; kleinBottle:=SCLib.Load(last[1][1]);; 
 gap&gt; SCHomology(kleinBottle);      
 [ [ 0, [  ] ], [ 1, [ 2 ] ], [ 0, [  ] ] ]
 gap&gt; SCFpBettiNumbers(kleinBottle,2);
 [ 1, 2, 1 ]
 gap&gt; SCFpBettiNumbers(kleinBottle,3);
 [ 1, 1, 0 ]
 </pre></div>

<p><a id="X875963367A7745FB" name="X875963367A7745FB"></a></p>

<h5>6.6-21 SCFundamentalGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCFundamentalGroup</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: a <strong class="pkg">GAP</strong> fp group upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the first fundamental group of <var class="Arg">complex</var>, which must be a connected simplicial complex, and returns it in form of a finitely presented group. The generators of the group are given as 2-tuples that correspond to the edges of <var class="Arg">complex</var> in standard labeling. You can use GAP's <code class="code">SimplifiedFpGroup</code> to simplify the group presenation.</p>


<div class="example"><pre>
 gap&gt; list:=SCLib.SearchByName("RP^2");
 [ [ 3, "RP^2 (VT)" ], [ 635, "RP^2xS^1" ] ]
 gap&gt; c:=SCLib.Load(list[1][1]);
 [SimplicialComplex
 
  Properties known: AltshulerSteinberg, AutomorphismGroup, 
                    AutomorphismGroupSize, AutomorphismGroupStructure, 
                    AutomorphismGroupTransitivity, ConnectedComponents, 
                    Dim, DualGraph, EulerCharacteristic, FVector, 
                    FacetsEx, GVector, GeneratorsEx, HVector, 
                    HasBoundary, HasInterior, Homology, Interior, 
                    IsCentrallySymmetric, IsConnected, 
                    IsEulerianManifold, IsManifold, IsOrientable, 
                    IsPseudoManifold, IsPure, IsStronglyConnected, 
                    MinimalNonFacesEx, Name, Neighborliness, 
                    NumFaces[], Orientation, Reference, SkelExs[], 
                    Vertices.
 
  Name="RP^2 (VT)"
  Dim=2
  AltshulerSteinberg=3645
  AutomorphismGroupSize=60
  AutomorphismGroupStructure="A5"
  AutomorphismGroupTransitivity=2
  EulerCharacteristic=1
  FVector=[ 6, 15, 10 ]
  GVector=[ 2, 3 ]
  HVector=[ 3, 6, 0 ]
  HasBoundary=false
  HasInterior=true
  Homology=[ [ 0, [ ] ], [ 0, [ 2 ] ], [ 0, [ ] ] ]
  IsCentrallySymmetric=false
  IsConnected=true
  IsEulerianManifold=true
  IsOrientable=false
  IsPseudoManifold=true
  IsPure=true
  IsStronglyConnected=true
  Neighborliness=2
 
 /SimplicialComplex]
 gap&gt; g:=SCFundamentalGroup(c);;
 gap&gt; StructureDescription(g);
 "C2"
 </pre></div>

<p><a id="X7B9F77A885E1BABE" name="X7B9F77A885E1BABE"></a></p>

<h5>6.6-22 SCGVector</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCGVector</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: a list of integers upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the g-vector of a simplicial complex. The <span class="SimpleMath">g</span>-vector is defined as follows:</p>

<p>Let <span class="SimpleMath">h</span> be the <span class="SimpleMath">h</span>-vector of a <span class="SimpleMath">d</span>-dimensional simplicial complex C, then <span class="Math"> Let <span class="SimpleMath">h</span> be the <span class="SimpleMath">h</span>-vector of a <span class="SimpleMath">d</span>-dimensional simplicial complex C, then </span> is called the <span class="SimpleMath">g</span>-vector of <span class="SimpleMath">C</span>. For the definition of the <span class="SimpleMath">h</span>-vector see <code class="func">SCHVector</code> (<a href="chap6.html#X84FBF0A685547ECD"><span class="RefLink">6.6-25</span></a>). The information contained in <span class="SimpleMath">g</span> suffices to determine the <span class="SimpleMath">f</span>-vector of <span class="SimpleMath">C</span>.</p>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("RP^2");
 [ [ 3, "RP^2 (VT)" ], [ 635, "RP^2xS^1" ] ]
 gap&gt; rp2_6:=SCLib.Load(last[1][1]);;
 gap&gt; SCFVector(rp2_6);
 [ 6, 15, 10 ]
 gap&gt; SCHVector(rp2_6);
 [ 3, 6, 0 ]
 gap&gt; SCGVector(rp2_6);
 [ 2, 3 ]
 </pre></div>

<p><a id="X863CA73D7F66B295" name="X863CA73D7F66B295"></a></p>

<h5>6.6-23 SCGenerators</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCGenerators</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: a list of pairs of the form <code class="code">[ list, integer ]</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the generators of a simplicial complex in the original vertex labeling.</p>

<p>The generating set of a simplicial complex is a list of simplices that will generate the complex by uniting their <span class="SimpleMath">G</span>-orbits if <span class="SimpleMath">G</span> is the automorphism group of <var class="Arg">complex</var>.</p>

<p>The function returns the simplices together with the length of their orbits.</p>


<div class="example"><pre>
 gap&gt; list:=SCLib.SearchByName("T^2");;
 gap&gt; torus:=SCLib.Load(list[1][1]);;
 gap&gt; SCGenerators(torus); 
 [ [ [ 1, 2, 4 ], 14 ] ]
 </pre></div>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("K3");
 [ [ 7494, "K3 surface" ] ]
 gap&gt; SCLib.Load(last[1][1]);
 [SimplicialComplex
 
  Properties known: AltshulerSteinberg, AutomorphismGroup, 
                    AutomorphismGroupSize, AutomorphismGroupStructure, 
                    AutomorphismGroupTransitivity, ConnectedComponents, 
                    Dim, DualGraph, EulerCharacteristic, FVector, 
                    FacetsEx, GVector, GeneratorsEx, HVector, 
                    HasBoundary, HasInterior, Homology, Interior, 
                    IsCentrallySymmetric, IsConnected, 
                    IsEulerianManifold, IsManifold, IsOrientable, 
                    IsPseudoManifold, IsPure, IsStronglyConnected, 
                    MinimalNonFacesEx, Name, Neighborliness, 
                    NumFaces[], Orientation, SkelExs[], Vertices.
 
  Name="K3 surface"
  Dim=4
  AltshulerSteinberg=883835714748069945165599539200
  AutomorphismGroupSize=240
  AutomorphismGroupStructure="((C2 x C2 x C2 x C2) : C5) : C3"
  AutomorphismGroupTransitivity=2
  EulerCharacteristic=24
  FVector=[ 16, 120, 560, 720, 288 ]
  GVector=[ 10, 55, 220 ]
  HVector=[ 11, 66, 286, -99, 23 ]
  HasBoundary=false
  HasInterior=true
  Homology=[ [ 0, [ ] ], [ 0, [ ] ], [ 22, [ ] ], [ 0, [ ] ], [ 1, [ ] ] ]
  IsCentrallySymmetric=false
  IsConnected=true
  IsEulerianManifold=true
  IsOrientable=true
  IsPseudoManifold=true
  IsPure=true
  IsStronglyConnected=true
  Neighborliness=3
 
 /SimplicialComplex]
 gap&gt; SCGenerators(last);
 [ [ [ 1, 2, 3, 8, 12 ], 240 ], [ [ 1, 2, 5, 8, 14 ], 48 ] ]
 </pre></div>

<p><a id="X789F8FC77FC0E701" name="X789F8FC77FC0E701"></a></p>

<h5>6.6-24 SCGeneratorsEx</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCGeneratorsEx</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: a list of pairs of the form <code class="code">[ list, integer ]</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the generators of a simplicial complex in the standard vertex labeling.</p>

<p>The generating set of a simplicial complex is a list of simplices that will generate the complex by uniting their <span class="SimpleMath">G</span>-orbits if <span class="SimpleMath">G</span> is the automorphism group of <var class="Arg">complex</var>.</p>

<p>The function returns the simplices together with the length of their orbits.</p>


<div class="example"><pre>
 gap&gt; list:=SCLib.SearchByName("T^2");;
 gap&gt; torus:=SCLib.Load(list[1][1]);;
 gap&gt; SCGeneratorsEx(torus); 
 [ [ [ 1, 2, 4 ], 14 ] ]
 </pre></div>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("K3");
 [ [ 7494, "K3 surface" ] ]
 gap&gt; SCLib.Load(last[1][1]);
 [SimplicialComplex
 
  Properties known: AltshulerSteinberg, AutomorphismGroup, 
                    AutomorphismGroupSize, AutomorphismGroupStructure, 
                    AutomorphismGroupTransitivity, ConnectedComponents, 
                    Dim, DualGraph, EulerCharacteristic, FVector, 
                    FacetsEx, GVector, GeneratorsEx, HVector, 
                    HasBoundary, HasInterior, Homology, Interior, 
                    IsCentrallySymmetric, IsConnected, 
                    IsEulerianManifold, IsManifold, IsOrientable, 
                    IsPseudoManifold, IsPure, IsStronglyConnected, 
                    MinimalNonFacesEx, Name, Neighborliness, 
                    NumFaces[], Orientation, SkelExs[], Vertices.
 
  Name="K3 surface"
  Dim=4
  AltshulerSteinberg=883835714748069945165599539200
  AutomorphismGroupSize=240
  AutomorphismGroupStructure="((C2 x C2 x C2 x C2) : C5) : C3"
  AutomorphismGroupTransitivity=2
  EulerCharacteristic=24
  FVector=[ 16, 120, 560, 720, 288 ]
  GVector=[ 10, 55, 220 ]
  HVector=[ 11, 66, 286, -99, 23 ]
  HasBoundary=false
  HasInterior=true
  Homology=[ [ 0, [ ] ], [ 0, [ ] ], [ 22, [ ] ], [ 0, [ ] ], [ 1, [ ] ] ]
  IsCentrallySymmetric=false
  IsConnected=true
  IsEulerianManifold=true
  IsOrientable=true
  IsPseudoManifold=true
  IsPure=true
  IsStronglyConnected=true
  Neighborliness=3
 
 /SimplicialComplex]
 gap&gt; SCGeneratorsEx(last);
 [ [ [ 1, 2, 3, 8, 12 ], 240 ], [ [ 1, 2, 5, 8, 14 ], 48 ] ]
 </pre></div>

<p><a id="X84FBF0A685547ECD" name="X84FBF0A685547ECD"></a></p>

<h5>6.6-25 SCHVector</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCHVector</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: a list of integers upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the <span class="SimpleMath">h</span>-vector of a simplicial complex. The <span class="SimpleMath">h</span>-vector is defined as <span class="Math"> Computes the <span class="SimpleMath">h</span>-vector of a simplicial complex. The <span class="SimpleMath">h</span>-vector is defined as </span> for <span class="SimpleMath">0 ≤ k ≤ d</span>, where <span class="SimpleMath">f_-1 := 1</span>. For all simplicial complexes we have <span class="SimpleMath">h_0 = 1</span>, hence the returned list starts with the second entry of the <span class="SimpleMath">h</span>-vector.</p>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("RP^2");
 [ [ 3, "RP^2 (VT)" ], [ 635, "RP^2xS^1" ] ]
 gap&gt; rp2_6:=SCLib.Load(last[1][1]);;
 gap&gt; SCFVector(rp2_6);
 [ 6, 15, 10 ]
 gap&gt; SCHVector(rp2_6);
 [ 3, 6, 0 ]
 </pre></div>

<p><a id="X796EBADE7803C622" name="X796EBADE7803C622"></a></p>

<h5>6.6-26 SCHasBoundary</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCHasBoundary</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Checks if a simplicial complex <var class="Arg">complex</var> that fulfills the weak pseudo manifold property has a boundary, i. e. <span class="SimpleMath">d-1</span>-faces of valence <span class="SimpleMath">1</span>. If <var class="Arg">complex</var> is closed <code class="keyw">false</code> is returned, if <var class="Arg">complex</var> does not fulfill the weak pseudomanifold property, <code class="keyw">fail</code> is returned, otherwise <code class="keyw">true</code> is returned.</p>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("K^2"); 
 [ [ 17, "K^2 (VT)" ], [ 571, "K^2 (VT)" ] ]
 gap&gt; kleinBottle:=SCLib.Load(last[1][1]);;
 gap&gt; SCHasBoundary(kleinBottle);
 false
 </pre></div>


<div class="example"><pre>
 gap&gt; c:=SC([[1,2,3,4],[1,2,3,5],[1,2,4,5],[1,3,4,5]]);;
 gap&gt; SCHasBoundary(c);
 true
 </pre></div>

<p><a id="X7C2A5B4D7E77E444" name="X7C2A5B4D7E77E444"></a></p>

<h5>6.6-27 SCHasInterior</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCHasInterior</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Returns <code class="keyw">true</code> if a simplicial complex <var class="Arg">complex</var> that fulfills the weak pseudomanifold property has at least one <span class="SimpleMath">d-1</span>-face of valence <span class="SimpleMath">2</span>, i. e. if there exist at least one <span class="SimpleMath">d-1</span>-face that is not in the boundary of <var class="Arg">complex</var>, if no such face can be found <code class="keyw">false</code> is returned. It <var class="Arg">complex</var> does not fulfill the weak pseudomanifold property <code class="keyw">fail</code> is returned.</p>


<div class="example"><pre>
 gap&gt; c:=SC([[1,2,3,4],[1,2,3,5],[1,2,4,5],[1,3,4,5]]);;
 gap&gt; SCHasInterior(c)
 true
 gap&gt; c:=SC([[1,2,3,4]]);;
 gap&gt; SCHasInterior(c);
 false
 </pre></div>

<p><a id="X78D66254858CE901" name="X78D66254858CE901"></a></p>

<h5>6.6-28 SCHomology</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCHomology</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: a list of pairs of the form <code class="code">[ integer, list ]</code>.</p>

<p>Computes the integral simplicial homology groups of a simplicial complex <var class="Arg">complex</var> (internally calls the function <code class="code">SimplicialHomology(complex.FacetsEx)</code> from the <strong class="pkg">homology</strong> package, version 1.4.2., see <a href="chapBib.html#biBDumas04Homology">[DHSW04]</a>).</p>

<p>If the <strong class="pkg">homology</strong> package is not available, this function call falls back to <code class="func">SCHomologyInternal</code> (<a href="chap8.html#X858989CE797A8366"><span class="RefLink">8.1-5</span></a>). The output is a list of homology groups of the form <span class="SimpleMath">[H_0,....,H_d]</span>, where <span class="SimpleMath">d</span> is the dimension of <var class="Arg">complex</var>. The format of the homology groups <span class="SimpleMath">H_i</span> is given in terms of their maximal cyclic subgroups, i.e. a homology group <span class="SimpleMath">H_i≅ Z^f + Z / t_1 Z × dots × Z / t_n Z</span> is returned in form of a list <span class="SimpleMath">[ f, [t_1,...,t_n] ]</span>, where <span class="SimpleMath">f</span> is the (integer) free part of <span class="SimpleMath">H_i</span> and <span class="SimpleMath">t_i</span> denotes the torsion parts of <span class="SimpleMath">H_i</span> ordered in weakly increasing size.</p>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("K^2");
 [ [ 17, "K^2 (VT)" ], [ 571, "K^2 (VT)" ] ]
 gap&gt; kleinBottle:=SCLib.Load(last[1][1]);;
 gap&gt; kleinBottle.Homology;          
 [ [ 0, [  ] ], [ 1, [ 2 ] ], [ 0, [  ] ] ]
 gap&gt; SCLib.SearchByName("L_"){[1..10]};
 [ [ 139, "L_3_1" ], [ 634, "L_4_1" ], [ 754, "L_5_2" ], 
   [ 2416, "(S^2~S^1)#L_3_1" ], [ 2417, "(S^2xS^1)#L_3_1" ], [ 2490, "L_5_1" ],
   [ 2492, "(S^2~S^1)#2#L_3_1" ], [ 2494, "(S^2xS^1)#2#L_3_1" ], 
   [ 7467, "L_7_2" ], [ 7468, "L_8_3" ] ]
 gap&gt; c:=SCConnectedSum(SCConnectedProduct(SCLib.Load(last[9][1]),3),
                        SCConnectedProduct(SCLib.Load(last[10][1]),2));
 &gt; [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="L_7_2#+-L_7_2#+-L_7_2#+-L_8_3#+-L_8_3"
  Dim=3
 
 /SimplicialComplex]
 gap&gt; SCHomology(c);
 [ [ 0, [  ] ], [ 0, [ 7, 56, 56 ] ], [ 0, [  ] ], [ 1, [  ] ] ]
 gap&gt; SCFpBettiNumbers(c,2);
 [ 1, 2, 2, 1 ]
 gap&gt; SCFpBettiNumbers(c,3);
 [ 1, 0, 0, 1 ]
 </pre></div>

<p><a id="X7B0C12F5780FDD9B" name="X7B0C12F5780FDD9B"></a></p>

<h5>6.6-29 SCIncidences</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCIncidences</code>( <var class="Arg">complex</var>, <var class="Arg">k</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: a list of face lists upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Returns a list of all <var class="Arg">k</var>-faces of the simplicial complex <var class="Arg">complex</var>. The list is sorted by the valence of the faces in the <var class="Arg">k</var>+1-skeleton of the complex, i. e. the <span class="SimpleMath">i</span>-th entry of the list contains all <var class="Arg">k</var>-faces of valence <span class="SimpleMath">i</span>. The faces are returned in the original labeling.</p>


<div class="example"><pre>
 gap&gt; c:=SC([[1,2,3],[2,3,4],[3,4,5],[4,5,6],[1,5,6],[1,4,6],[2,3,6]]);;
 gap&gt; SCIncidences(c,1);
 [ [ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 1, 5 ], [ 2, 4 ], [ 2, 6 ], [ 3, 5 ], 
       [ 3, 6 ] ], [ [ 1, 6 ], [ 3, 4 ], [ 4, 5 ], [ 4, 6 ], [ 5, 6 ] ], 
   [ [ 2, 3 ] ] ]
 </pre></div>

<p><a id="X7B4CA6FE78A9880F" name="X7B4CA6FE78A9880F"></a></p>

<h5>6.6-30 SCIncidencesEx</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCIncidencesEx</code>( <var class="Arg">complex</var>, <var class="Arg">k</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: a list of face lists upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Returns a list of all <var class="Arg">k</var>-faces of the simplicial complex <var class="Arg">complex</var>. The list is sorted by the valence of the faces in the <var class="Arg">k</var>+1-skeleton of the complex, i. e. the <span class="SimpleMath">i</span>-th entry of the list contains all <var class="Arg">k</var>-faces of valence <span class="SimpleMath">i</span>. The faces are returned in the standard labeling.</p>


<div class="example"><pre>
 gap&gt; c:=SC([[1,2,3],[2,3,4],[3,4,5],[4,5,6],[1,5,6],[1,4,6],[2,3,6]]);;
 gap&gt; SCIncidences(c,1);
 [ [ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 1, 5 ], [ 2, 4 ], [ 2, 6 ], [ 3, 5 ], 
       [ 3, 6 ] ], [ [ 1, 6 ], [ 3, 4 ], [ 4, 5 ], [ 4, 6 ], [ 5, 6 ] ], 
   [ [ 2, 3 ] ] ]
 </pre></div>

<p><a id="X862926A079F6DFC2" name="X862926A079F6DFC2"></a></p>

<h5>6.6-31 SCInterior</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCInterior</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes all <span class="SimpleMath">d-1</span>-faces of valence <span class="SimpleMath">2</span> of a simplicial complex <var class="Arg">complex</var> that fulfills the weak pseudomanifold property, i. e. the function returns the part of the <span class="SimpleMath">d-1</span>-skeleton of <span class="SimpleMath">C</span> that is not part of the boundary.</p>


<div class="example"><pre>
 gap&gt; c:=SC([[1,2,3,4],[1,2,3,5],[1,2,4,5],[1,3,4,5]]);;
 gap&gt; SCInterior(c).Facets;
 [ [ 1, 2, 3 ], [ 1, 2, 4 ], [ 1, 2, 5 ], [ 1, 3, 4 ], [ 1, 3, 5 ], 
   [ 1, 4, 5 ] ]
 gap&gt; c:=SC([[1,2,3,4]]);;
 gap&gt; SCInterior(c).Facets;
 [  ]
 </pre></div>

<p><a id="X8123A6E282CD0174" name="X8123A6E282CD0174"></a></p>

<h5>6.6-32 SCIsCentrallySymmetric</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCIsCentrallySymmetric</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Checks if a simplicial complex <var class="Arg">complex</var> is centrally symmetric, i. e. if its automorphism group contains a fixed point free involution.</p>


<div class="example"><pre>
 gap&gt; c:=SCBdCrossPolytope(4);;
 gap&gt; SCIsCentrallySymmetric(c);
 true
 </pre></div>


<div class="example"><pre>
 gap&gt; c:=SCBdSimplex(4);;
 gap&gt; SCIsCentrallySymmetric(c);
 false
 </pre></div>

<p><a id="X81AF20DC814B51A6" name="X81AF20DC814B51A6"></a></p>

<h5>6.6-33 SCIsConnected</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCIsConnected</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Checks if a simplicial complex <var class="Arg">complex</var> is connected.</p>


<div class="example"><pre>
 gap&gt; c:=SCBdSimplex(1);;
 gap&gt; SCIsConnected(c);
 false
 gap&gt; c:=SCBdSimplex(2);;
 gap&gt; SCIsConnected(c);
 true
 </pre></div>

<p><a id="X860375D980E9A801" name="X860375D980E9A801"></a></p>

<h5>6.6-34 SCIsEmpty</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCIsEmpty</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Checks if a simplicial complex <var class="Arg">complex</var> is the empty complex, i. e. a <code class="code">SCSimplicialComplex</code> object with empty facet list.</p>


<div class="example"><pre>
 gap&gt; c:=SC([[1]]);;
 gap&gt; SCIsEmpty(c);
 false
 gap&gt; c:=SC([]);;
 gap&gt; SCIsEmpty(c);
 true
 gap&gt; c:=SC([[]]);;
 gap&gt; SCIsEmpty(c);
 true
 </pre></div>

<p><a id="X83E01C957D2F2458" name="X83E01C957D2F2458"></a></p>

<h5>6.6-35 SCIsEulerianManifold</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCIsEulerianManifold</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Checks whether a given simplicial complex <var class="Arg">complex</var> is a Eulerian manifold or not, i. e. checks if all vertex links of <var class="Arg">complex</var> have the Euler characteristic of a sphere. In particular the function returns <code class="keyw">false</code> in case <var class="Arg">complex</var> has a non-empty boundary.</p>


<div class="example"><pre>
 gap&gt; c:=SCBdSimplex(4);;
 gap&gt; SCIsEulerianManifold(c);
 true
 gap&gt; SCLib.SearchByName("Moebius");
 [ [ 1, "Moebius Strip" ] ]
 gap&gt; moebius:=SCLib.Load(last[1][1]); # a moebius strip
 [SimplicialComplex
 
  Properties known: Dim, EulerCharacteristic, FVector, FacetsEx, 
                    GVector, HVector, HasBoundary, Homology, 
                    IsConnected, IsManifold, IsPseudoManifold, 
                    MinimalNonFacesEx, Name, NumFaces[], SkelExs[], 
                    Vertices.
 
  Name="Moebius Strip"
  Dim=2
  EulerCharacteristic=0
  FVector=[ 5, 10, 5 ]
  GVector=[ 1, 1 ]
  HVector=[ 2, 3, -1 ]
  HasBoundary=true
  Homology=[ [ 0 ], [ 1 ], [ 0 ] ]
  IsConnected=true
  IsPseudoManifold=true
 
 /SimplicialComplex]
 gap&gt; SCIsEulerianManifold(moebius);
 false
 </pre></div>

<p><a id="X843C3E7F79D8093F" name="X843C3E7F79D8093F"></a></p>

<h5>6.6-36 SCIsFlag</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCIsFlag</code>( <var class="Arg">complex</var>, <var class="Arg">k</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Checks if <var class="Arg">complex</var> is flag. A simplicial complex is a flag complex if all edges of a potential face of the complex are in the complex, or equivalently if all of its minimal non-faces are edges (cf. <a href="chapBib.html#biBFrohmader08FaceVecFlagCompl">[Fro08]</a>).</p>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("RP^2");   
 [ [ 3, "RP^2 (VT)" ], [ 635, "RP^2xS^1" ] ]
 gap&gt; rp2_6:=SCLib.Load(last[1][1]);;
 gap&gt; SCIsFlag(rp2_6);
 true
 </pre></div>

<p><a id="X7E66FE0C83A3D371" name="X7E66FE0C83A3D371"></a></p>

<h5>6.6-37 SCIsHomologySphere</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCIsHomologySphere</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Checks whether a simplicial complex <var class="Arg">complex</var> is a homology sphere, i. e. has the homology of a sphere, or not.</p>


<div class="example"><pre>
 gap&gt; c:=SC([[2,3],[3,4],[4,2]]);;
 gap&gt; SCIsHomologySphere(c);
 true
 </pre></div>

<p><a id="X87BC29AF878E7FD8" name="X87BC29AF878E7FD8"></a></p>

<h5>6.6-38 SCIsInKd</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCIsInKd</code>( <var class="Arg">complex</var>, <var class="Arg">k</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> / <code class="keyw">false</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Checks whether the simplicial complex <var class="Arg">complex</var> that must be a combinatorial <span class="SimpleMath">d</span>-manifold is in the class <span class="SimpleMath">mathcalK^k(d)</span>, <span class="SimpleMath">1≤ k≤ ⌊fracd+12⌋</span>, of simplicial complexes that only have <span class="SimpleMath">k</span>-stacked spheres as vertex links, see <a href="chapBib.html#biBEffenberger09StackPolyTightTrigMnf">[Eff11b]</a>. Note that it is not checked whether <var class="Arg">complex</var> is a combinatorial manifold -- if not, the algorithm will not succeed. Returns <code class="keyw">true</code> / <code class="keyw">false</code> upon success. If <code class="keyw">true</code> is returned this means that <var class="Arg">complex</var> is at least <var class="Arg">k</var>-stacked and thus that the complex is in the class <span class="SimpleMath">mathcalK^k(d)</span>, i.e. all vertex links are <code class="code">i</code>-stacked spheres. If <code class="keyw">false</code> is returnd the complex cannot be <var class="Arg">k</var>-stacked. In some cases the question can not be decided. In this case <code class="keyw">fail</code> is returned.</p>

<p>Internally calls <code class="func">SCIsKStackedSphere</code> (<a href="chap9.html#X79FBFD6A7F2CC7E7"><span class="RefLink">9.2-5</span></a>) for all links. Please note that this is a radomized algorithm that may give an indefinite answer to the membership problem.</p>


<div class="example"><pre>
 gap&gt; list:=SCLib.SearchByName("S^2~S^1");;{[1..3]};
 gap&gt; c:=SCLib.Load(list[1][1]);;
 gap&gt; c.AutomorphismGroup;
 Group([ (1,3)(4,9)(5,8)(6,7), (1,9,8,7,6,5,4,3,2) ])
 gap&gt; SCIsInKd(c,1);
 #I  SCIsKStackedSphere: checking if complex is a 1-stacked sphere...
 #I  SCIsKStackedSphere: try 1/50
 #I  SCIsKStackedSphere: complex is a 1-stacked sphere.
 true
 </pre></div>

<p><a id="X7F4BECCA7E67B1B2" name="X7F4BECCA7E67B1B2"></a></p>

<h5>6.6-39 SCIsKNeighborly</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCIsKNeighborly</code>( <var class="Arg">complex</var>, <var class="Arg">k</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code> upon success, <code class="keyw">fail</code> otherwise.</p>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("RP^2");   
 [ [ 3, "RP^2 (VT)" ], [ 635, "RP^2xS^1" ] ]
 gap&gt; rp2_6:=SCLib.Load(last[1][1]);;
 gap&gt; SCFVector(rp2_6);
 [ 6, 15, 10 ]
 gap&gt; SCIsKNeighborly(rp2_6,2);
 true
 gap&gt; SCIsKNeighborly(rp2_6,3);
 false
 </pre></div>

<p><a id="X78C860DC851167F7" name="X78C860DC851167F7"></a></p>

<h5>6.6-40 SCIsOrientable</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCIsOrientable</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Checks if a simplicial complex <var class="Arg">complex</var>, satisfying the weak pseudomanifold property, is orientable.</p>


<div class="example"><pre>
 gap&gt; c:=SCBdCrossPolytope(4);;
 gap&gt; SCIsOrientable(c);
 true
 </pre></div>

<p><a id="X79DFCA08808665B7" name="X79DFCA08808665B7"></a></p>

<h5>6.6-41 SCIsPseudoManifold</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCIsPseudoManifold</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Checks if a simplicial complex <var class="Arg">complex</var> fulfills the weak pseudomanifold property, i. e. if every <span class="SimpleMath">d-1</span>-face of <var class="Arg">complex</var> is contained in at most <span class="SimpleMath">2</span> facets.</p>


<div class="example"><pre>
 gap&gt; c:=SC([[1,2,3],[1,2,4],[1,3,4],[2,3,4],[1,5,6],[1,5,7],[1,6,7],[5,6,7]]);;
 gap&gt; SCIsPseudoManifold(c);
 true
 gap&gt; c:=SC([[1,2],[2,3],[3,1],[1,4],[4,5],[5,1]]);;
 gap&gt; SCIsPseudoManifold(c);
 false
 </pre></div>

<p><a id="X7AAA757F842EA23A" name="X7AAA757F842EA23A"></a></p>

<h5>6.6-42 SCIsPure</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCIsPure</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: a boolean upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Checks if a simplicial complex <var class="Arg">complex</var> is pure.</p>


<div class="example"><pre>
 gap&gt; c:=SC([[1,2], [1,4], [2,4], [2,3,4]]);;
 gap&gt; SCIsPure(c);
 false
 gap&gt; c:=SC([[1,2], [1,4], [2,4]]);;
 gap&gt; SCIsPure(c);
 true
 </pre></div>

<p><a id="X7EA4F4DB78758652" name="X7EA4F4DB78758652"></a></p>

<h5>6.6-43 SCIsShellable</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCIsShellable</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>The simplicial complex <var class="Arg">complex</var> must be pure, strongly connected and must fulfill the weak pseudomanifold property with non-empty boundary (cf. <code class="func">SCBoundary</code> (<a href="chap6.html#X836DC73380EA7414"><span class="RefLink">6.6-7</span></a>)).</p>

<p>The function checks whether <var class="Arg">complex</var> is shellable or not. An ordering <span class="SimpleMath">(F_1, F_2, ... , F_r)</span> on the facet list of a simplicial complex is called a shelling if and only if <span class="SimpleMath">F_i ∩ (F_1 ∪ ... ∪ F_i-1)</span> is a pure simplicial complex of dimension <span class="SimpleMath">d-1</span> for all <span class="SimpleMath">i = 1, ... , r</span>. A simplicial complex is called shellable, if at least one shelling exists.</p>

<p>See <a href="chapBib.html#biBZiegler95LectPolytopes">[Zie95]</a>, <a href="chapBib.html#biBPachner87KonstrMethKombHomeo">[Pac87]</a> to learn more about shellings.</p>


<div class="example"><pre>
 gap&gt; c:=SCBdCrossPolytope(4);;       
 gap&gt; c:=Difference(c,SC([[1,3,5,7]]));; # bounded version
 gap&gt; SCIsShellable(c);
 true
 </pre></div>

<p><a id="X7A2BD5657BBE1CC7" name="X7A2BD5657BBE1CC7"></a></p>

<h5>6.6-44 SCIsStronglyConnected</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCIsStronglyConnected</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Checks if a simplicial complex <var class="Arg">complex</var> is strongly connected, i. e. if for any pair of facets <span class="SimpleMath">(hat∆,tilde∆)</span> there exists a sequence of facets <span class="SimpleMath">( ∆_1 , ... , ∆_k )</span> with <span class="SimpleMath">∆_1 = hat∆</span> and <span class="SimpleMath">∆_k = tilde∆</span> and dim<span class="SimpleMath">(∆_i , ∆_i+1 ) = d - 1</span> for all <span class="SimpleMath">1 ≤ i ≤ k - 1</span>.</p>


<div class="example"><pre>
 gap&gt; c:=SC([[1,2,3],[1,2,4],[1,3,4],[2,3,4], [1,5,6],[1,5,7],[1,6,7],[5,6,7]]);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="unnamed complex 24"
  Dim=2
 
 /SimplicialComplex]
 gap&gt; SCIsConnected(c);        
 true
 gap&gt; SCIsStronglyConnected(c);                                                
 false
 </pre></div>

<p><a id="X7B935899849C8E40" name="X7B935899849C8E40"></a></p>

<h5>6.6-45 SCMinimalNonFaces</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCMinimalNonFaces</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: a list of face lists upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes all missing proper faces of a simplicial complex <var class="Arg">complex</var> by calling <code class="func">SCMinimalNonFacesEx</code> (<a href="chap6.html#X7DE069A0823BD56E"><span class="RefLink">6.6-46</span></a>). The simplices are returned in the original labeling of <var class="Arg">complex</var>.</p>


<div class="example"><pre>
 gap&gt; c:=SCFromFacets(["abc","abd"]);;
 gap&gt; SCMinimalNonFaces(c);           
 [ [  ], [ "cd" ] ]
 </pre></div>

<p><a id="X7DE069A0823BD56E" name="X7DE069A0823BD56E"></a></p>

<h5>6.6-46 SCMinimalNonFacesEx</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCMinimalNonFacesEx</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: a list of face lists upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes all missing proper faces of a simplicial complex <var class="Arg">complex</var>, i.e. the missing <span class="SimpleMath">(i+1)</span>-tuples in the <span class="SimpleMath">i</span>-dimensional skeleton of a <var class="Arg">complex</var>. A missing <span class="SimpleMath">i+1</span>-tuple is not listed if it only consists of missing <span class="SimpleMath">i</span>-tuples. Note that whenever <var class="Arg">complex</var> is <span class="SimpleMath">k</span>-neighborly the first <span class="SimpleMath">k+1</span> entries are empty. The simplices are returned in the standard labeling <span class="SimpleMath">1,dots,n</span>, where <span class="SimpleMath">n</span> is the number of vertices of <var class="Arg">complex</var>.</p>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("T^2"){[1..10]}; 
 [ [ 4, "T^2 (VT)" ], [ 5, "T^2 (VT)" ], [ 9, "T^2 (VT)" ], [ 10, "T^2 (VT)" ],
   [ 18, "T^2 (VT)" ], [ 20, "(T^2)#2" ], [ 24, "(T^2)#3" ], 
   [ 41, "T^2 (VT)" ], [ 44, "(T^2)#4" ], [ 65, "T^2 (VT)" ] ]
 gap&gt; torus:=SCLib.Load(last[1][1]);;
 gap&gt; SCFVector(torus);
 [ 7, 21, 14 ]
 gap&gt; SCMinimalNonFacesEx(torus);
 [ [  ], [  ] ]
 gap&gt; SCMinimalNonFacesEx(SCBdCrossPolytope(4));
 [ [  ], [ [ 1, 2 ], [ 3, 4 ], [ 5, 6 ], [ 7, 8 ] ], [  ] ]
 </pre></div>

<p><a id="X82A224DF787A97BE" name="X82A224DF787A97BE"></a></p>

<h5>6.6-47 SCNeighborliness</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCNeighborliness</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: a positive integer upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Returns <span class="SimpleMath">k</span> if a simplicial complex <var class="Arg">complex</var> is <span class="SimpleMath">k</span>-neighborly but not <span class="SimpleMath">(k+1)</span>-neighborly. See also <code class="func">SCIsKNeighborly</code> (<a href="chap6.html#X7F4BECCA7E67B1B2"><span class="RefLink">6.6-39</span></a>).</p>

<p>Note that every complex is at least <span class="SimpleMath">1</span>-neighborly.</p>


<div class="example"><pre>
 gap&gt; c:=SCBdSimplex(4);;
 gap&gt; SCNeighborliness(c);
 4
 gap&gt; c:=SCBdCrossPolytope(4);;
 gap&gt; SCNeighborliness(c);
 1
 gap&gt; SCLib.SearchByAttribute("F[3]=Binomial(F[1],3) and Dim=4");
 [ [ 16, "CP^2 (VT)" ], [ 7494, "K3 surface" ] ]
 gap&gt; cp2:=SCLib.Load(last[2][1]);;
 gap&gt; SCNeighborliness(cp2);
 3
 </pre></div>

<p><a id="X7AC2427184B44C65" name="X7AC2427184B44C65"></a></p>

<h5>6.6-48 SCNumFaces</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCNumFaces</code>( <var class="Arg">complex</var>[, <var class="Arg">i</var>] )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: an integer or a list of integers upon success, <code class="keyw">fail</code> otherwise.</p>

<p>If <var class="Arg">i</var> is not specified the function computes the <span class="SimpleMath">f</span>-vector of the simplicial complex <var class="Arg">complex</var> (cf. <code class="func">SCFVector</code> (<a href="chap6.html#X81F8071385FD9C1D"><span class="RefLink">6.6-13</span></a>)). If the optional integer parameter <var class="Arg">i</var> is passed, only the <var class="Arg">i</var>-th position of the <span class="SimpleMath">f</span>-vector of <var class="Arg">complex</var> is calculated. In any case a memory-saving implicit algorithm is used that avoids calculating the face lattice of the complex.</p>


<div class="example"><pre>
 gap&gt; complex:=SC([[1,2,3], [1,2,4], [1,3,4], [2,3,4]]);;
 gap&gt; SCNumFaces(complex,1);
 6
 </pre></div>

<p><a id="X78DACE3478340DB8" name="X78DACE3478340DB8"></a></p>

<h5>6.6-49 SCOrientation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCOrientation</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: a list of the type <span class="SimpleMath">{ ± 1 }^f_d</span> or <code class="code">[ ]</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>This function tries to compute an orientation of a pure simplicial complex <var class="Arg">complex</var> that fulfills the weak pseudomanifold property. If <var class="Arg">complex</var> is orientable, an orientation in form of a list of orientations for the facets of <var class="Arg">complex</var> is returned, otherwise an empty set.</p>


<div class="example"><pre>
 gap&gt; c:=SCBdCrossPolytope(4);;
 gap&gt; SCOrientation(c);
 [ 1, -1, -1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, -1, -1, 1 ]
 </pre></div>

<p><a id="X8026B46F8236124D" name="X8026B46F8236124D"></a></p>

<h5>6.6-50 SCSkel</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSkel</code>( <var class="Arg">complex</var>, <var class="Arg">k</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: a face list or a list of face lists upon success, <code class="keyw">fail</code> otherwise.</p>

<p>If <var class="Arg">k</var> is an integer, the <var class="Arg">k</var>-skeleton of a simplicial complex <var class="Arg">complex</var>, i. e. all <var class="Arg">k</var>-faces of <var class="Arg">complex</var>, is computed. If <var class="Arg">k</var> is a list, a list of all <var class="Arg">k</var><code class="code">[i]</code>-faces of <var class="Arg">complex</var> for each entry <var class="Arg">k</var><code class="code">[i]</code> (which has to be an integer) is returned. The faces are returned in the original labeling.</p>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("RP^2"); 
 [ [ 3, "RP^2 (VT)" ], [ 635, "RP^2xS^1" ] ]
 gap&gt; rp2_6:=SCLib.Load(last[1][1]);;      
 gap&gt; rp2_6:=SC(rp2_6.Facets+10);;
 gap&gt; SCSkelEx(rp2_6,1);
 [ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 1, 5 ], [ 1, 6 ], [ 2, 3 ], [ 2, 4 ], 
   [ 2, 5 ], [ 2, 6 ], [ 3, 4 ], [ 3, 5 ], [ 3, 6 ], [ 4, 5 ], [ 4, 6 ], 
   [ 5, 6 ] ]
 gap&gt; SCSkel(rp2_6,1);  
 [ [ 11, 12 ], [ 11, 13 ], [ 11, 14 ], [ 11, 15 ], [ 11, 16 ], [ 12, 13 ], 
   [ 12, 14 ], [ 12, 15 ], [ 12, 16 ], [ 13, 14 ], [ 13, 15 ], [ 13, 16 ], 
   [ 14, 15 ], [ 14, 16 ], [ 15, 16 ] ]
 </pre></div>

<p><a id="X84ACF7D580FE8B76" name="X84ACF7D580FE8B76"></a></p>

<h5>6.6-51 SCSkelEx</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSkelEx</code>( <var class="Arg">complex</var>, <var class="Arg">k</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: a face list or a list of face lists upon success, <code class="keyw">fail</code> otherwise.</p>

<p>If <var class="Arg">k</var> is an integer, the <var class="Arg">k</var>-skeleton of a simplicial complex <var class="Arg">complex</var>, i. e. all <var class="Arg">k</var>-faces of <var class="Arg">complex</var>, is computed. If <var class="Arg">k</var> is a list, a list of all <var class="Arg">k</var><code class="code">[i]</code>-faces of <var class="Arg">complex</var> for each entry <var class="Arg">k</var><code class="code">[i]</code> (which has to be an integer) is returned. The faces are returned in the standard labeling.</p>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("RP^2"); 
 [ [ 3, "RP^2 (VT)" ], [ 635, "RP^2xS^1" ] ]
 gap&gt; rp2_6:=SCLib.Load(last[1][1]);;      
 gap&gt; rp2_6:=SC(rp2_6.Facets+10);;
 gap&gt; SCSkelEx(rp2_6,1);
 [ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 1, 5 ], [ 1, 6 ], [ 2, 3 ], [ 2, 4 ], 
   [ 2, 5 ], [ 2, 6 ], [ 3, 4 ], [ 3, 5 ], [ 3, 6 ], [ 4, 5 ], [ 4, 6 ], 
   [ 5, 6 ] ]
 gap&gt; SCSkel(rp2_6,1);  
 [ [ 11, 12 ], [ 11, 13 ], [ 11, 14 ], [ 11, 15 ], [ 11, 16 ], [ 12, 13 ], 
   [ 12, 14 ], [ 12, 15 ], [ 12, 16 ], [ 13, 14 ], [ 13, 15 ], [ 13, 16 ], 
   [ 14, 15 ], [ 14, 16 ], [ 15, 16 ] ]
 </pre></div>

<p><a id="X7E770DE27938B140" name="X7E770DE27938B140"></a></p>

<h5>6.6-52 SCSpanningTree</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSpanningTree</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes a spanning tree of a connected simplicial complex <var class="Arg">complex</var> using a greedy algorithm.</p>


<div class="example"><pre>
 gap&gt; c:=SC([["a","b","c"],["a","b","d"], ["a","c","d"], ["b","c","d"]]);;
 gap&gt; s:=SCSpanningTree(c);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="spanning tree of unnamed complex 1"
  Dim=1
 
 /SimplicialComplex]
 gap&gt; s.Facets;
 [ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ] ]
 </pre></div>

<p><a id="X8284003382F863A0" name="X8284003382F863A0"></a></p>

<h4>6.7 <span class="Heading">Operations on simplicial complexes</span></h4>

<p>The following functions perform operations on simplicial complexes. Most of them return simplicial complexes. Thus, this section is closely related to the Sections <a href="chap6.html#X7F4308DB7C3699D1"><span class="RefLink">6.4</span></a> ''Generate new complexes from old''. However, the data generated here is rather seen as an intrinsic attribute of the original complex and not as an independent complex.</p>

<p><a id="X818757A17DA5CFFC" name="X818757A17DA5CFFC"></a></p>

<h5>6.7-1 SCAlexanderDual</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCAlexanderDual</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>The Alexander dual of a simplicial complex <var class="Arg">complex</var> with set of vertices <span class="SimpleMath">V</span> is the simplicial complex where any subset of <span class="SimpleMath">V</span> spans a face if and only if its complement in <span class="SimpleMath">V</span> is a non-face of <var class="Arg">complex</var>.</p>


<div class="example"><pre>
 gap&gt; c:=SC([[1,2],[2,3],[3,4],[4,1]]);;
 gap&gt; dual:=SCAlexanderDual(c);;
 gap&gt; dual.F;
 [ 4, 2 ]
 gap&gt; dual.IsConnected;
 false
 gap&gt; dual.Facets;
 [ [ 1, 3 ], [ 2, 4 ] ]
 </pre></div>

<p><a id="X82D22356858062D6" name="X82D22356858062D6"></a></p>

<h5>6.7-2 SCClose</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCClose</code>( <var class="Arg">complex</var>[, <var class="Arg">apex</var>] )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Closes a simplicial complex <var class="Arg">complex</var> by building a cone over its boundary. If <var class="Arg">apex</var> is specified it is assigned to the apex of the cone and the original vertex labeling of <var class="Arg">complex</var> is preserved, otherwise an arbitrary vertex label is chosen and <var class="Arg">complex</var> is returned in the standard labeling.</p>


<div class="example"><pre>
 gap&gt; s:=SCSimplex(5);;                                       
 gap&gt; b:=SCSimplex(5);;
 gap&gt; s:=SCClose(b,13);;
 gap&gt; SCIsIsomorphic(s,SCBdSimplex(6));                       
 true
 </pre></div>

<p><a id="X7A4EBD017F4D9747" name="X7A4EBD017F4D9747"></a></p>

<h5>6.7-3 SCCollapseGreedy</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCCollapseGreedy</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Employs a greedy collapsing algorithm in order to collapse the simplicial complex <var class="Arg">complex</var>. The source code of this function is taken from <a href="chapBib.html#biBLutz08ManifoldPage">[ManifoldPage]</a>.</p>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("T^2"){[1..6]}; 
 [ [ 4, "T^2 (VT)" ], [ 5, "T^2 (VT)" ], [ 9, "T^2 (VT)" ], [ 10, "T^2 (VT)" ],
   [ 18, "T^2 (VT)" ], [ 20, "(T^2)#2" ] ]
 gap&gt; torus:=SCLib.Load(last[1][1]);;
 gap&gt; bdtorus:=SCDifference(torus,SC([torus.Facets[1]]));;
 gap&gt; coll:=SCCollapseGreedy(bdtorus);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="collapsed version of T^2 (VT) \ unnamed complex 18"
  Dim=1
 
 /SimplicialComplex]
 gap&gt; coll.Facets;
 [ [ 3, 6 ], [ 3, 7 ], [ 5, 6 ], [ 5, 7 ], [ 6, 7 ] ]
 gap&gt; sphere:=SCBdSimplex(4);;                              
 gap&gt; bdsphere:=SCDifference(sphere,SC([sphere.Facets[1]]));;
 gap&gt; coll:=SCCollapseGreedy(bdsphere);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="collapsed version of S^3_5 \ unnamed complex 22"
  Dim=0
 
 /SimplicialComplex]
 gap&gt; coll.Facets;                     
 [ [ 5 ] ]
 </pre></div>

<p><a id="X7CF53D8D7E0FA702" name="X7CF53D8D7E0FA702"></a></p>

<h5>6.7-4 SCCone</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCCone</code>( <var class="Arg">complex</var>, <var class="Arg">apex</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>If the second argument is passed every facet of the simplicial complex <var class="Arg">complex</var> is united with <var class="Arg">apex</var>. If not, an arbitrary vertex label <span class="SimpleMath">v</span> is used (which is not a vertex of <var class="Arg">complex</var>). In the first case the vertex labeling remains unchanged. In the second case the function returns the new complex in the standard vertex labeling from <span class="SimpleMath">1</span> to <span class="SimpleMath">n+1</span> and the apex of the cone is <span class="SimpleMath">n+1</span>.</p>

<p>If called with a facet list instead of a <code class="code">SCSimplicialComplex</code> object and <var class="Arg">apex</var> is not specified, internally falls back to the homology package <a href="chapBib.html#biBDumas04Homology">[DHSW04]</a>, if available.</p>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("RP^3");
 [ [ 45, "RP^3" ], [ 113, "RP^3=L(2,1) (VT)" ], [ 589, "(S^2~S^1)#RP^3" ], 
   [ 590, "(S^2xS^1)#RP^3" ], [ 632, "(S^2~S^1)#2#RP^3" ], 
   [ 633, "(S^2xS^1)#2#RP^3" ], [ 2414, "RP^3#RP^3" ], 
   [ 2426, "RP^3=L(2,1) (VT)" ], [ 2488, "(S^2~S^1)#3#RP^3" ], 
   [ 2489, "(S^2xS^1)#3#RP^3" ], [ 2502, "RP^3=L(2,1) (VT)" ], 
   [ 7473, "(S^2~S^1)#4#RP^3" ], [ 7474, "(S^2xS^1)#4#RP^3" ], 
   [ 7505, "(S^2~S^1)#5#RP^3" ], [ 7506, "(S^2xS^1)#5#RP^3" ] ]
 gap&gt; rp3:=SCLib.Load(last[1][1]);;
 gap&gt; rp3.F;
 [ 11, 51, 80, 40 ]
 gap&gt; cone:=SCCone(rp3);;
 gap&gt; cone.F;
 [ 12, 62, 131, 120, 40 ]
 </pre></div>


<div class="example"><pre>
 gap&gt; s:=SCBdSimplex(4)+12;;
 gap&gt; s.Facets;             
 [ [ 13, 14, 15, 16 ], [ 13, 14, 15, 17 ], [ 13, 14, 16, 17 ], 
   [ 13, 15, 16, 17 ], [ 14, 15, 16, 17 ] ]
 gap&gt; cc:=SCCone(s,13);;    
 gap&gt; cc:=SCCone(s,12);;
 gap&gt; cc.Facets;
 [ [ 12, 13, 14, 15, 16 ], [ 12, 13, 14, 15, 17 ], [ 12, 13, 14, 16, 17 ], 
   [ 12, 13, 15, 16, 17 ], [ 12, 14, 15, 16, 17 ] ]
 </pre></div>

<p><a id="X800BDDD878DFCBDB" name="X800BDDD878DFCBDB"></a></p>

<h5>6.7-5 SCDeletedJoin</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCDeletedJoin</code>( <var class="Arg">complex1</var>, <var class="Arg">complex2</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Calculates the simplicial deleted join of the simplicial complexes <var class="Arg">complex1</var> and <var class="Arg">complex2</var>. If called with a facet list instead of a <code class="code">SCSimplicialComplex</code> object, the function internally falls back to the <strong class="pkg">homology</strong> package <a href="chapBib.html#biBDumas04Homology">[DHSW04]</a>, if available.</p>


<div class="example"><pre>
 gap&gt; deljoin:=SCDeletedJoin(SCBdSimplex(3),SCBdSimplex(3));
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="S^2_4 deljoin S^2_4"
  Dim=3
 
 /SimplicialComplex]
 gap&gt; bddeljoin:=SCBoundary(deljoin);;
 gap&gt; bddeljoin.Homology;
 [ [ 1, [  ] ], [ 0, [  ] ], [ 2, [  ] ] ]
 gap&gt; deljoin.Facets;
 [ [ [ 1, 1 ], [ 2, 1 ], [ 3, 1 ], [ 4, 2 ] ], 
   [ [ 1, 1 ], [ 2, 1 ], [ 3, 2 ], [ 4, 1 ] ], 
   [ [ 1, 1 ], [ 2, 1 ], [ 3, 2 ], [ 4, 2 ] ], 
   [ [ 1, 1 ], [ 2, 2 ], [ 3, 1 ], [ 4, 1 ] ], 
   [ [ 1, 1 ], [ 2, 2 ], [ 3, 1 ], [ 4, 2 ] ], 
   [ [ 1, 1 ], [ 2, 2 ], [ 3, 2 ], [ 4, 1 ] ], 
   [ [ 1, 1 ], [ 2, 2 ], [ 3, 2 ], [ 4, 2 ] ], 
   [ [ 1, 2 ], [ 2, 1 ], [ 3, 1 ], [ 4, 1 ] ], 
   [ [ 1, 2 ], [ 2, 1 ], [ 3, 1 ], [ 4, 2 ] ], 
   [ [ 1, 2 ], [ 2, 1 ], [ 3, 2 ], [ 4, 1 ] ], 
   [ [ 1, 2 ], [ 2, 1 ], [ 3, 2 ], [ 4, 2 ] ], 
   [ [ 1, 2 ], [ 2, 2 ], [ 3, 1 ], [ 4, 1 ] ], 
   [ [ 1, 2 ], [ 2, 2 ], [ 3, 1 ], [ 4, 2 ] ], 
   [ [ 1, 2 ], [ 2, 2 ], [ 3, 2 ], [ 4, 1 ] ] ]
 </pre></div>

<p><a id="X7FB3D29178076EB4" name="X7FB3D29178076EB4"></a></p>

<h5>6.7-6 SCDifference</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCDifference</code>( <var class="Arg">complex1</var>, <var class="Arg">complex2</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Forms the ``difference'' of two simplicial complexes <var class="Arg">complex1</var> and <var class="Arg">complex2</var> as the simplicial complex formed by the difference of the face lattices of <var class="Arg">complex1</var> minus <var class="Arg">complex2</var>. The two arguments are not altered. Note: for the difference process the vertex labelings of the complexes are taken into account, see also <code class="func">Operation Difference (SCSimplicialComplex, SCSimplicialComplex)</code> (<a href="chap5.html#X80CFABE083100541"><span class="RefLink">5.3-2</span></a>).</p>


<div class="example"><pre>
 gap&gt; c:=SCBdSimplex(3);;
 gap&gt; d:=SC([[1,2,3]]);;
 gap&gt; disc:=SCDifference(c,d);;
 gap&gt; disc.Facets;
 [ [ 1, 2, 4 ], [ 1, 3, 4 ], [ 2, 3, 4 ] ]
 gap&gt; empty:=SCDifference(d,c);;
 gap&gt; empty.Dim;
 -1
 </pre></div>

<p><a id="X7C8D11C684825ADC" name="X7C8D11C684825ADC"></a></p>

<h5>6.7-7 SCFillSphere</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCFillSphere</code>( <var class="Arg">complex</var>[, <var class="Arg">vertex</var>] )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise .</p>

<p>Fills the given simplicial sphere <var class="Arg">complex</var> by forming the suspension of the anti star of <var class="Arg">vertex</var> over <var class="Arg">vertex</var>. This is a triangulated <span class="SimpleMath">(d+1)</span>-ball with the boundary <var class="Arg">complex</var>, see <a href="chapBib.html#biBBagchi08LBTNormPseudoMnf">[BD08a]</a>. If the optional argument <var class="Arg">vertex</var> is not supplied, the first vertex of <var class="Arg">complex</var> is chosen.</p>

<p>Note that it is not checked whether <var class="Arg">complex</var> really is a simplicial sphere -- this has to be done by the user!</p>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("S^4");
 [ [ 36, "S^4 (VT)" ], [ 37, "S^4 (VT)" ], [ 38, "S^4 (VT)" ], 
   [ 130, "S^4 (VT)" ], [ 463, "S^4~S^1 (VT)" ], [ 713, "S^4xS^1 (VT)" ], 
   [ 1472, "S^4xS^1 (VT)" ], [ 1473, "S^4~S^1 (VT)" ], 
   [ 1474, "S^4~S^1 (VT)" ], [ 1475, "S^4xS^1 (VT)" ], 
   [ 2477, "S^4~S^1 (VT)" ], [ 2478, "S^4 (VT)" ], [ 3435, "S^4 (VT)" ], 
   [ 4395, "S^4~S^1 (VT)" ], [ 4396, "S^4~S^1 (VT)" ], 
   [ 4397, "S^4~S^1 (VT)" ], [ 4398, "S^4~S^1 (VT)" ], 
   [ 4399, "S^4~S^1 (VT)" ], [ 4402, "S^4~S^1 (VT)" ], 
   [ 4403, "S^4~S^1 (VT)" ], [ 4404, "S^4~S^1 (VT)" ], [ 7479, "S^4xS^2" ], 
   [ 7540, "S^4xS^3" ], [ 7574, "S^4xS^4" ] ]
 gap&gt; s:=SCLib.Load(last[1][1]);;
 gap&gt; filled:=SCFillSphere(s);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="FilledSphere(S^4 (VT)) at vertex [ 1 ]"
  Dim=5
 
 /SimplicialComplex]
 gap&gt; SCHomology(filled);
 [ [ 0, [  ] ], [ 0, [  ] ], [ 0, [  ] ], [ 0, [  ] ], [ 0, [  ] ], 
   [ 0, [  ] ] ]
 gap&gt; SCCollapseGreedy(filled);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="collapsed version of FilledSphere(S^4 (VT)) at vertex [ 1 ]"
  Dim=0
 
 /SimplicialComplex]
 gap&gt; bd:=SCBoundary(filled);;
 gap&gt; bd=s;
 true
 </pre></div>

<p><a id="X7DCB16857D49EC37" name="X7DCB16857D49EC37"></a></p>

<h5>6.7-8 SCHandleAddition</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCHandleAddition</code>( <var class="Arg">complex</var>, <var class="Arg">f1</var>, <var class="Arg">f2</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code>, <code class="keyw">fail</code> otherwise.</p>

<p>Returns a simplicial complex obtained by identifying the vertices of facet <var class="Arg">f1</var> with the ones from facet <var class="Arg">f2</var> in <var class="Arg">complex</var>. A combinatorial handle addition is possible, whenever we have d<span class="SimpleMath">(v,w) ≥ 3</span> for any two vertices <span class="SimpleMath">v ∈</span><var class="Arg">f1</var> and <span class="SimpleMath">w ∈</span><var class="Arg">f2</var>, where d<span class="SimpleMath">(⋅,⋅)</span> is the length of the shortest path from <span class="SimpleMath">v</span> to <span class="SimpleMath">w</span>. This condition is not checked by this algorithm. See <a href="chapBib.html#biBBagchi08OnWalkupKd">[BD08b]</a> for further information.</p>


<div class="example"><pre>
 gap&gt; c:=SC([[1,2,4],[2,4,5],[2,3,5],[3,5,6],[1,3,6],[1,4,6]]);;
 gap&gt; c:=SCUnion(c,SCUnion(SCCopy(c)+3,SCCopy(c)+6));;
 gap&gt; c:=SCUnion(c,SC([[1,2,3],[10,11,12]]));;
 gap&gt; c.Facets;
 [ [ 1, 2, 3 ], [ 1, 2, 4 ], [ 1, 3, 6 ], [ 1, 4, 6 ], [ 2, 3, 5 ], 
   [ 2, 4, 5 ], [ 3, 5, 6 ], [ 4, 5, 7 ], [ 4, 6, 9 ], [ 4, 7, 9 ], 
   [ 5, 6, 8 ], [ 5, 7, 8 ], [ 6, 8, 9 ], [ 7, 8, 10 ], [ 7, 9, 12 ], 
   [ 7, 10, 12 ], [ 8, 9, 11 ], [ 8, 10, 11 ], [ 9, 11, 12 ], [ 10, 11, 12 ] ]
 gap&gt; c.Homology;
 [ [ 0, [  ] ], [ 0, [  ] ], [ 1, [  ] ] ]
 gap&gt; torus:=SCHandleAddition(c,[1,2,3],[10,11,12]);;
 gap&gt; torus.Homology;
 [ [ 0, [  ] ], [ 2, [  ] ], [ 1, [  ] ] ]
 gap&gt; ism:=SCIsManifold(torus);;
 gap&gt; ism;
 true
 </pre></div>

<p><a id="X7B4BE2C783E6D0BF" name="X7B4BE2C783E6D0BF"></a></p>

<h5>6.7-9 SCIntersection</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCIntersection</code>( <var class="Arg">complex1</var>, <var class="Arg">complex2</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Forms the ``intersection'' of two simplicial complexes <var class="Arg">complex1</var> and <var class="Arg">complex2</var> as the simplicial complex formed by the intersection of the face lattices of <var class="Arg">complex1</var> and <var class="Arg">complex2</var>. The two arguments are not altered. Note: for the intersection process the vertex labelings of the complexes are taken into account. See also <code class="func">Operation Intersection (SCSimplicialComplex, SCSimplicialComplex)</code> (<a href="chap5.html#X851CE49F7F7437C3"><span class="RefLink">5.3-3</span></a>).</p>


<div class="example"><pre>
 gap&gt; c:=SCBdSimplex(3);;        
 gap&gt; d:=SCBdSimplex(3)+1;;      
 gap&gt; d.Facets;
 [ [ 2, 3, 4 ], [ 2, 3, 5 ], [ 2, 4, 5 ], [ 3, 4, 5 ] ]
 gap&gt; c:=SCBdSimplex(3);;  
 gap&gt; d:=SCBdSimplex(3);;  
 gap&gt; d:=SCMove(d,[[1,2,3],[]])+1;;
 gap&gt; s1:=SCIntersection(c,d);;
 gap&gt; s1.Facets;               
 [ [ 2, 3 ], [ 2, 4 ], [ 3, 4 ] ]
 </pre></div>

<p><a id="X85659EC77DFF8183" name="X85659EC77DFF8183"></a></p>

<h5>6.7-10 SCIsIsomorphic</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCIsIsomorphic</code>( <var class="Arg">complex1</var>, <var class="Arg">complex2</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>The function returns <code class="keyw">true</code>, if the simplicial complexes <var class="Arg">complex1</var> and <var class="Arg">complex2</var> are combinatorially isomorphic, <code class="keyw">false</code> if not.</p>


<div class="example"><pre>
 gap&gt; c1:=SC([[11,12,13],[11,12,14],[11,13,14],[12,13,14]]);;
 gap&gt; c2:=SCBdSimplex(3);;
 gap&gt; SCIsIsomorphic(c1,c2);
 true
 gap&gt; c3:=SCBdCrossPolytope(3);;
 gap&gt; SCIsIsomorphic(c1,c3);
 false
 </pre></div>

<p><a id="X81D9CC438313F589" name="X81D9CC438313F589"></a></p>

<h5>6.7-11 SCIsSubcomplex</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCIsSubcomplex</code>( <var class="Arg">sc1</var>, <var class="Arg">sc2</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Returns <code class="keyw">true</code> if the simplicial complex <var class="Arg">sc2</var> is a sub-complex of simplicial complex <var class="Arg">sc1</var>, <code class="keyw">false</code> otherwise. If dim(<var class="Arg">sc2</var>) <span class="SimpleMath">≤</span> dim(<var class="Arg">sc1</var>) the facets of <var class="Arg">sc2</var> are compared with the dim(<var class="Arg">sc2</var>)-skeleton of <var class="Arg">sc1</var>. Only works for pure simplicial complexes. Note: for the intersection process the vertex labelings of the complexes are taken into account.</p>


<div class="example"><pre>
 gap&gt; SCLib.SearchByAttribute("F[1]=10"){[1..10]};
 [ [ 17, "K^2 (VT)" ], [ 18, "T^2 (VT)" ], [ 19, "S^3 (VT)" ], 
   [ 20, "(T^2)#2" ], [ 21, "S^3 (VT)" ], [ 22, "S^2xS^1 (VT)" ], 
   [ 23, "S^3 (VT)" ], [ 24, "(T^2)#3" ], [ 25, "(P^2)#7 (VT)" ], 
   [ 26, "S^3 (VT)" ] ]
 gap&gt; k:=SCLib.Load(last[1][1]);;
 gap&gt; c:=SCBdSimplex(9);;
 gap&gt; k.F;
 [ 10, 30, 20 ]
 gap&gt; c.F;
 [ 10, 45, 120, 210, 252, 210, 120, 45, 10 ]
 gap&gt; SCIsSubcomplex(c,k);
 true
 gap&gt; SCIsSubcomplex(k,c);
 false
 </pre></div>

<p><a id="X8623B92580E8B4E4" name="X8623B92580E8B4E4"></a></p>

<h5>6.7-12 SCIsomorphism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCIsomorphism</code>( <var class="Arg">complex1</var>, <var class="Arg">complex2</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: a list of pairs of vertex labels or <code class="keyw">false</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Returns an isomorphism of simplicial complex <var class="Arg">complex1</var> to simplicial complex <var class="Arg">complex2</var> in the standard labeling if they are combinatorially isomorphic, <code class="keyw">false</code> otherwise. Internally calls <code class="func">SCIsomorphismEx</code> (<a href="chap6.html#X86576B7287686E2B"><span class="RefLink">6.7-13</span></a>).</p>


<div class="example"><pre>
 gap&gt; c1:=SC([[11,12,13],[11,12,14],[11,13,14],[12,13,14]]);;
 gap&gt; c2:=SCBdSimplex(3);;
 gap&gt; SCIsomorphism(c1,c2);
 [ [ 11, 1 ], [ 12, 2 ], [ 13, 3 ], [ 14, 4 ] ]
 gap&gt; SCIsomorphismEx(c1,c2);
 [ [ [ 1, 1 ], [ 2, 2 ], [ 3, 3 ], [ 4, 4 ] ] ]
 </pre></div>

<p><a id="X86576B7287686E2B" name="X86576B7287686E2B"></a></p>

<h5>6.7-13 SCIsomorphismEx</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCIsomorphismEx</code>( <var class="Arg">complex1</var>, <var class="Arg">complex2</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: a list of pairs of vertex labels or <code class="keyw">false</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Returns an isomorphism of simplicial complex <var class="Arg">complex1</var> to simplicial complex <var class="Arg">complex2</var> in the standard labeling if they are combinatorially isomorphic, <code class="keyw">false</code> otherwise. If the <span class="SimpleMath">f</span>-vector and the Altshuler-Steinberg determinant of <var class="Arg">complex1</var> and <var class="Arg">complex2</var> are equal, the internal function <code class="code">SCIntFunc.SCComputeIsomorphismsEx(complex1,complex2,true)</code> is called.</p>


<div class="example"><pre>
 gap&gt; c1:=SC([[11,12,13],[11,12,14],[11,13,14],[12,13,14]]);;
 gap&gt; c2:=SCBdSimplex(3);;
 gap&gt; SCIsomorphism(c1,c2);
 [ [ 11, 1 ], [ 12, 2 ], [ 13, 3 ], [ 14, 4 ] ]
 gap&gt; SCIsomorphismEx(c1,c2);
 [ [ [ 1, 1 ], [ 2, 2 ], [ 3, 3 ], [ 4, 4 ] ] ]
 </pre></div>

<p><a id="X86AC8D81837CC677" name="X86AC8D81837CC677"></a></p>

<h5>6.7-14 SCJoin</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCJoin</code>( <var class="Arg">complex1</var>, <var class="Arg">complex2</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Calculates the simplicial join of the simplicial complexes <var class="Arg">complex1</var> and <var class="Arg">complex2</var>. If facet lists instead of <code class="code">SCSimplicialComplex</code> objects are passed as arguments, the function internally falls back to the homology package <a href="chapBib.html#biBDumas04Homology">[DHSW04]</a>, if available. Note that the vertex labelings of the complexes passed as arguments are not propagated to the new complex.</p>


<div class="example"><pre>
 gap&gt; sphere:=SCJoin(SCBdSimplex(2),SCBdSimplex(2));
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="S^1_3 join S^1_3"
  Dim=3
 
 /SimplicialComplex]
 gap&gt; SCHasBoundary(sphere);
 false
 gap&gt; sphere.Facets;
 [ [ [ 1, 1 ], [ 1, 2 ], [ 2, 1 ], [ 2, 2 ] ], 
   [ [ 1, 1 ], [ 1, 2 ], [ 2, 1 ], [ 2, 3 ] ], 
   [ [ 1, 1 ], [ 1, 2 ], [ 2, 2 ], [ 2, 3 ] ], 
   [ [ 1, 1 ], [ 1, 3 ], [ 2, 1 ], [ 2, 2 ] ], 
   [ [ 1, 1 ], [ 1, 3 ], [ 2, 1 ], [ 2, 3 ] ], 
   [ [ 1, 1 ], [ 1, 3 ], [ 2, 2 ], [ 2, 3 ] ], 
   [ [ 1, 2 ], [ 1, 3 ], [ 2, 1 ], [ 2, 2 ] ], 
   [ [ 1, 2 ], [ 1, 3 ], [ 2, 1 ], [ 2, 3 ] ], 
   [ [ 1, 2 ], [ 1, 3 ], [ 2, 2 ], [ 2, 3 ] ] ]
 gap&gt; sphere.Homology;
 [ [ 0, [  ] ], [ 0, [  ] ], [ 0, [  ] ], [ 1, [  ] ] ]
 </pre></div>


<div class="example"><pre>
 gap&gt; ball:=SCJoin(SC([[1]]),SCBdSimplex(2));
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="unnamed complex 4 join S^1_3"
  Dim=2
 
 /SimplicialComplex]
 gap&gt; ball.Homology;
 [ [ 0, [  ] ], [ 0, [  ] ], [ 0, [  ] ] ]
 gap&gt; ball.Facets;
 [ [ [ 1, 1 ], [ 2, 1 ], [ 2, 2 ] ], [ [ 1, 1 ], [ 2, 1 ], [ 2, 3 ] ], 
   [ [ 1, 1 ], [ 2, 2 ], [ 2, 3 ] ] ]
 </pre></div>

<p><a id="X8482E1F67C927BB7" name="X8482E1F67C927BB7"></a></p>

<h5>6.7-15 SCNeighbors</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCNeighbors</code>( <var class="Arg">complex</var>, <var class="Arg">face</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: a list of faces upon success, <code class="keyw">fail</code> otherwise.</p>

<p>In a simplicial complex <var class="Arg">complex</var> all neighbors of the <code class="code">k</code>-face <var class="Arg">face</var>, i. e. all <code class="code">k</code>-faces distinct from <var class="Arg">face</var> intersecting with <var class="Arg">face</var> in a common <span class="SimpleMath">(k-1)</span>-face, are returned in the original labeling.</p>


<div class="example"><pre>
 gap&gt; c:=SCFromFacets(Combinations(["a","b","c"],2));
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="unnamed complex 29"
  Dim=1
 
 /SimplicialComplex]
 gap&gt; SCNeighbors(c,["a","d"]);
 [ [ "a", "b" ], [ "a", "c" ] ]
 </pre></div>

<p><a id="X7F8FBEF17ACD0D4F" name="X7F8FBEF17ACD0D4F"></a></p>

<h5>6.7-16 SCNeighborsEx</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCNeighborsEx</code>( <var class="Arg">complex</var>, <var class="Arg">face</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: a list of faces upon success, <code class="keyw">fail</code> otherwise.</p>

<p>In a simplicial complex <var class="Arg">complex</var> all neighbors of the <code class="code">k</code>-face <var class="Arg">face</var>, i. e. all <code class="code">k</code>-faces distinct from <var class="Arg">face</var> intersecting with <var class="Arg">face</var> in a common <span class="SimpleMath">(k-1)</span>-face, are returned in the standard labeling.</p>


<div class="example"><pre>
 gap&gt; c:=SCFromFacets(Combinations(["a","b","c"],2));
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="unnamed complex 28"
  Dim=1
 
 /SimplicialComplex]
 gap&gt; SCLabels(c);
 [ "a", "b", "c" ]
 gap&gt; SCNeighborsEx(c,[1,2]);
 [ [ 1, 3 ], [ 2, 3 ] ]
 </pre></div>

<p><a id="X7EDA334983025D3D" name="X7EDA334983025D3D"></a></p>

<h5>6.7-17 SCShelling</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCShelling</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: a facet list or <code class="keyw">false</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>The simplicial complex <var class="Arg">complex</var> must be pure, strongly connected and must fulfill the weak pseudomanifold property with non-empty boundary (cf. <code class="func">SCBoundary</code> (<a href="chap6.html#X836DC73380EA7414"><span class="RefLink">6.6-7</span></a>)).</p>

<p>An ordering <span class="SimpleMath">(F_1, F_2, ... , F_r)</span> on the facet list of a simplicial complex is a shelling if and only if <span class="SimpleMath">F_i ∩ (F_1 ∪ ... ∪ F_i-1)</span> is a pure simplicial complex of dimension <span class="SimpleMath">d-1</span> for all <span class="SimpleMath">i = 1, ... , r</span>.</p>

<p>The function checks whether <var class="Arg">complex</var> is shellable or not. In the first case a permuted version of the facet list of <var class="Arg">complex</var> is returned encoding a shelling of <var class="Arg">complex</var>, otherwise <code class="keyw">false</code> is returned.</p>

<p>Internally calls <code class="func">SCShellingExt</code> (<a href="chap6.html#X7F967A717D4E41C0"><span class="RefLink">6.7-18</span></a>)<code class="code">(complex,false,[]);</code>. To learn more about shellings see <a href="chapBib.html#biBZiegler95LectPolytopes">[Zie95]</a>, <a href="chapBib.html#biBPachner87KonstrMethKombHomeo">[Pac87]</a>.</p>


<div class="example"><pre>
 gap&gt; c:=SC([[1,2,3],[1,2,4],[1,3,4]]);;
 gap&gt; SCShelling(c);
 [ [ [ 1, 2, 3 ], [ 1, 2, 4 ], [ 1, 3, 4 ] ] ]
 </pre></div>

<p><a id="X7F967A717D4E41C0" name="X7F967A717D4E41C0"></a></p>

<h5>6.7-18 SCShellingExt</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCShellingExt</code>( <var class="Arg">complex</var>, <var class="Arg">all</var>, <var class="Arg">checkvector</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: a list of facet lists (if <var class="Arg">checkvector = []</var>) or <code class="keyw">true</code> or <code class="keyw">false</code> (if <var class="Arg">checkvector</var> is not empty), <code class="keyw">fail</code> otherwise.</p>

<p>The simplicial complex <var class="Arg">complex</var> must be pure of dimension <span class="SimpleMath">d</span>, strongly connected and must fulfill the weak pseudomanifold property with non-empty boundary (cf. <code class="func">SCBoundary</code> (<a href="chap6.html#X836DC73380EA7414"><span class="RefLink">6.6-7</span></a>)).</p>

<p>An ordering <span class="SimpleMath">(F_1, F_2, ... , F_r)</span> on the facet list of a simplicial complex is a shelling if and only if <span class="SimpleMath">F_i ∩ (F_1 ∪ ... ∪ F_i-1)</span> is a pure simplicial complex of dimension <span class="SimpleMath">d-1</span> for all <span class="SimpleMath">i = 1, ... , r</span>.</p>

<p>If <var class="Arg">all</var> is set to <code class="keyw">true</code> all possible shellings of <var class="Arg">complex</var> are computed. If <var class="Arg">all</var> is set to <code class="keyw">false</code>, at most one shelling is computed.</p>

<p>Every shelling is represented as a permuted version of the facet list of <var class="Arg">complex</var>. The list <var class="Arg">checkvector</var> encodes a shelling in a shorter form. It only contains the indices of the facets. If an order of indices is assigned to <var class="Arg">checkvector</var> the function tests whether it is a valid shelling or not.</p>

<p>See <a href="chapBib.html#biBZiegler95LectPolytopes">[Zie95]</a>, <a href="chapBib.html#biBPachner87KonstrMethKombHomeo">[Pac87]</a> to learn more about shellings.</p>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("RP^2");                 
 [ [ 3, "RP^2 (VT)" ], [ 635, "RP^2xS^1" ] ]
 gap&gt; rp2:=SCLib.Load(last[1][1]);;                        
 gap&gt; rp2:=SCDifference(rp2,SC([rp2.Facets[1]]));; # bounded version
 gap&gt; all:=SCShellingExt(rp2,true,[]);;
 gap&gt; Size(all);                                  
 1488
 gap&gt; all[1];
 [ [ 1, 2, 6 ], [ 1, 4, 6 ], [ 1, 4, 5 ], [ 1, 3, 5 ], [ 2, 4, 5 ], 
   [ 2, 3, 4 ], [ 2, 5, 6 ], [ 3, 4, 6 ], [ 3, 5, 6 ] ]
 gap&gt; all:=SCShellingExt(rp2,false,[]);
 [ [ [ 1, 2, 6 ], [ 1, 4, 6 ], [ 1, 4, 5 ], [ 1, 3, 5 ], [ 2, 4, 5 ], 
       [ 2, 3, 4 ], [ 2, 5, 6 ], [ 3, 4, 6 ], [ 3, 5, 6 ] ] ]
 gap&gt; all:=SCShellingExt(rp2,false,[4, 9, 3, 2, 5, 6, 7, 1, 8]);
 true
 gap&gt; all:=SCShellingExt(rp2,true,[4, 9, 3, 2, 5, 6, 7, 1, 8]);
 true
 gap&gt; all:=SCShellingExt(rp2,true,[1 .. 9]);
 #I  SCShellingExt: 2 is not a valid shelling facet.
 false
 </pre></div>

<p><a id="X8373598C7FF5D28E" name="X8373598C7FF5D28E"></a></p>

<h5>6.7-19 SCShellings</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCShellings</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: a list of facet lists upon success, <code class="keyw">fail</code> otherwise.</p>

<p>The simplicial complex <var class="Arg">complex</var> must be pure, strongly connected and must fulfill the weak pseudomanifold property with non-empty boundary (cf. <code class="func">SCBoundary</code> (<a href="chap6.html#X836DC73380EA7414"><span class="RefLink">6.6-7</span></a>)).</p>

<p>An ordering <span class="SimpleMath">(F_1, F_2, ... , F_r)</span> on the facet list of a simplicial complex is a shelling if and only if <span class="SimpleMath">F_i ∩ (F_1 ∪ ... ∪ F_i-1)</span> is a pure simplicial complex of dimension <span class="SimpleMath">d-1</span> for all <span class="SimpleMath">i = 1, ... , r</span>.</p>

<p>The function checks whether <var class="Arg">complex</var> is shellable or not. In the first case a list of permuted facet lists of <var class="Arg">complex</var> is returned containing all possible shellings of <var class="Arg">complex</var>, otherwise <code class="keyw">false</code> is returned.</p>

<p>Internally calls <code class="func">SCShellingExt</code> (<a href="chap6.html#X7F967A717D4E41C0"><span class="RefLink">6.7-18</span></a>)<code class="code">(complex,true,[]);</code>. To learn more about shellings see <a href="chapBib.html#biBZiegler95LectPolytopes">[Zie95]</a>, <a href="chapBib.html#biBPachner87KonstrMethKombHomeo">[Pac87]</a>.</p>


<div class="example"><pre>
 gap&gt; c:=SC([[1,2,3],[1,2,4],[1,3,4]]);;
 gap&gt; SCShellings(c);
 [ [ [ 1, 2, 3 ], [ 1, 2, 4 ], [ 1, 3, 4 ] ], 
   [ [ 1, 2, 3 ], [ 1, 3, 4 ], [ 1, 2, 4 ] ], 
   [ [ 1, 2, 4 ], [ 1, 2, 3 ], [ 1, 3, 4 ] ], 
   [ [ 1, 3, 4 ], [ 1, 2, 3 ], [ 1, 2, 4 ] ], 
   [ [ 1, 2, 4 ], [ 1, 3, 4 ], [ 1, 2, 3 ] ], 
   [ [ 1, 3, 4 ], [ 1, 2, 4 ], [ 1, 2, 3 ] ] ]
 </pre></div>

<p><a id="X7987AAE481C31F38" name="X7987AAE481C31F38"></a></p>

<h5>6.7-20 SCSpan</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSpan</code>( <var class="Arg">complex</var>, <var class="Arg">subset</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the reduced face lattice of all faces of a simplicial complex <var class="Arg">complex</var> that are spanned by <var class="Arg">subset</var>, a subset of the set of vertices of <var class="Arg">complex</var>.</p>


<div class="example"><pre>
 gap&gt; c:=SCBdCrossPolytope(4);;
 gap&gt; SCVertices(c);
 [ 1, 2, 3, 4, 5, 6, 7, 8 ]
 gap&gt; span:=SCSpan(c,[1,2,3,4]);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="span([ 1, 2, 3, 4 ]) in Bd(\beta^4)"
  Dim=1
 
 /SimplicialComplex]
 gap&gt; span.Facets;
 [ [ 1, 3 ], [ 1, 4 ], [ 2, 3 ], [ 2, 4 ] ]
 </pre></div>


<div class="example"><pre>
 gap&gt; c:=SC([[1,2],[1,4,5],[2,3,4]]);;
 gap&gt; span:=SCSpan(c,[2,3,5]);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="span([ 2, 3, 5 ]) in unnamed complex 119"
  Dim=1
 
 /SimplicialComplex]
 gap&gt; SCFacets(span);
 [ [ 2, 3 ], [ 5 ] ]
 </pre></div>

<p><a id="X7AAA4669793C57DC" name="X7AAA4669793C57DC"></a></p>

<h5>6.7-21 SCSuspension</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSuspension</code>( <var class="Arg">complex</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Calculates the simplicial suspension of the simplicial complex <var class="Arg">complex</var>. Internally falls back to the homology package <a href="chapBib.html#biBDumas04Homology">[DHSW04]</a> (if available) if a facet list is passed as argument. Note that the vertex labelings of the complexes passed as arguments are not propagated to the new complex.</p>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("Poincare");
 [ [ 7469, "Poincare_sphere" ] ]
 gap&gt; phs:=SCLib.Load(last[1][1]);
 [SimplicialComplex
 
  Properties known: AltshulerSteinberg, AutomorphismGroup, 
                    AutomorphismGroupSize, AutomorphismGroupStructure, 
                    AutomorphismGroupTransitivity, ConnectedComponents, 
                    Dim, DualGraph, EulerCharacteristic, FVector, 
                    FacetsEx, GVector, GeneratorsEx, HVector, 
                    HasBoundary, HasInterior, Homology, Interior, 
                    IsCentrallySymmetric, IsConnected, 
                    IsEulerianManifold, IsManifold, IsOrientable, 
                    IsPseudoManifold, IsPure, IsStronglyConnected, 
                    MinimalNonFacesEx, Name, Neighborliness, 
                    NumFaces[], Orientation, SkelExs[], Vertices.
 
  Name="Poincare_sphere"
  Dim=3
  AltshulerSteinberg=115400413872363901952
  AutomorphismGroupSize=1
  AutomorphismGroupStructure="1"
  AutomorphismGroupTransitivity=0
  EulerCharacteristic=0
  FVector=[ 16, 106, 180, 90 ]
  GVector=[ 11, 52 ]
  HVector=[ 12, 64, 12, 1 ]
  HasBoundary=false
  HasInterior=true
  Homology=[ [ 0, [ ] ], [ 0, [ ] ], [ 0, [ ] ], [ 1, [ ] ] ]
  IsCentrallySymmetric=false
  IsConnected=true
  IsEulerianManifold=true
  IsOrientable=true
  IsPseudoManifold=true
  IsPure=true
  IsStronglyConnected=true
  Neighborliness=1
 
 /SimplicialComplex]
 gap&gt; susp:=SCSuspension(phs);;
 gap&gt; edwardsSphere:=SCSuspension(susp);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="susp of susp of Poincare_sphere"
  Dim=5
 
 /SimplicialComplex]
 </pre></div>

<p><a id="X81DA367A813F7599" name="X81DA367A813F7599"></a></p>

<h5>6.7-22 SCUnion</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCUnion</code>( <var class="Arg">complex1</var>, <var class="Arg">complex2</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Forms the union of two simplicial complexes <var class="Arg">complex1</var> and <var class="Arg">complex2</var> as the simplicial complex formed by the union of their facets sets. The two arguments are not altered. Note: for the union process the vertex labelings of the complexes are taken into account, see also <code class="func">Operation Union (SCSimplicialComplex, SCSimplicialComplex)</code> (<a href="chap5.html#X82C94EE47E339DD8"><span class="RefLink">5.3-1</span></a>). Facets occurring in both arguments are treated as one facet in the new complex.</p>


<div class="example"><pre>
 gap&gt; c:=SCUnion(SCBdSimplex(3),SCBdSimplex(3)+3); #a wedge of two 2-spheres
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="S^2_4 cup S^2_4"
  Dim=2
 
 /SimplicialComplex]
 </pre></div>

<p><a id="X7D5639CB87A0D3F1" name="X7D5639CB87A0D3F1"></a></p>

<h5>6.7-23 SCVertexIdentification</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCVertexIdentification</code>( <var class="Arg">complex</var>, <var class="Arg">v1</var>, <var class="Arg">v2</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Identifies vertex <var class="Arg">v1</var> with vertex <var class="Arg">v2</var> in a simplicial complex <var class="Arg">complex</var> and returns the result as a new object. A vertex identification of <var class="Arg">v1</var> and <var class="Arg">v2</var> is possible whenever d(<var class="Arg">v1</var>,<var class="Arg">v2</var>) <span class="SimpleMath">≥ 3</span>. This is not checked by this algorithm.</p>


<div class="example"><pre>
 gap&gt; c:=SC([[1,2],[2,3],[3,4]]);;
 gap&gt; circle:=SCVertexIdentification(c,[1],[4]);;
 gap&gt; circle.Facets;
 [ [ 1, 2 ], [ 1, 3 ], [ 2, 3 ] ]
 gap&gt; circle.Homology;
 [ [ 0, [  ] ], [ 1, [  ] ] ]
 </pre></div>

<p><a id="X7E7B17317D1B618D" name="X7E7B17317D1B618D"></a></p>

<h5>6.7-24 SCWedge</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCWedge</code>( <var class="Arg">complex1</var>, <var class="Arg">complex2</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Calculates the wedge product of the complexes supplied as arguments. Note that the vertex labelings of the complexes passed as arguments are not propagated to the new complex.</p>


<div class="example"><pre>
 gap&gt; wedge:=SCWedge(SCBdSimplex(2),SCBdSimplex(2));
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="unnamed complex 17"
  Dim=1
 
 /SimplicialComplex]
 gap&gt; wedge.Facets;
 [ [ 1, [ 1, 2 ] ], [ 1, [ 1, 3 ] ], [ 1, [ 2, 2 ] ], [ 1, [ 2, 3 ] ], 
   [ [ 1, 2 ], [ 1, 3 ] ], [ [ 2, 2 ], [ 2, 3 ] ] ]
 </pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap5.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap7.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chap13.html">13</a>  <a href="chap14.html">14</a>  <a href="chap15.html">15</a>  <a href="chap16.html">16</a>  <a href="chap17.html">17</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
