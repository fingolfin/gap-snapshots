%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%W  lists.tex                 GAP documentation             Thomas Breuer
%W                                                         & Frank Celler
%W                                                     & Martin Schoenert
%W                                                       & Heiko Theissen
%%
%H  @(#)$Id: lists.tex,v 4.34 2002/10/04 12:04:17 gap Exp $
%%
%Y  Copyright 1997,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,   Germany
%%
%%  This file contains a tutorial introduction to lists and records.
%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Chapter{Lists and Records}

Modern mathematics, especially algebra, is based on set theory. When sets
are represented in a computer, they inadvertently turn into lists. That's
why we start our  survey of the various  objects {\GAP} can handle with a
description of  lists  and their  manipulation. {\GAP}  regards sets as a
special kind of lists, namely as lists without  holes or duplicates whose
entries are ordered with respect to the precedence relation~`\<'.

After  the introduction of  the basic  manipulations with lists in~"Plain
Lists", some difficulties concerning identity and mutability of lists are
discussed  in~"Identical Lists"  and~"Immutability".  Sets,  ranges, row
vectors, and matrices are introduced as special kinds of lists in~"Sets",
"Ranges", "Vectors and Matrices".   Handy list   operations are
shown in~"List Operations". Finally we explain how to use records
in~"Plain Records". 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Plain Lists}

\atindex{lists!plain}{@lists!plain|indexit}
A *list* is a collection of objects separated by  commas and enclosed  in
brackets.  Let us for example construct the list `primes' of the first 10
prime numbers.
\beginexample
gap> primes:= [2, 3, 5, 7, 11, 13, 17, 19, 23, 29];
[ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 ]
\endexample
The next two primes are  31 and 37.  They may be appended to the existing
list by the function `Append' which takes  the existing list as its first
and another list as a second argument.  The  second argument  is appended
to the list `primes' and  no  value is returned.  Note that  by appending
another list the object `primes' is changed.
\beginexample
gap> Append(primes, [31, 37]);
gap> primes;
[ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37 ]
\endexample
You can as well add single new elements to existing lists by the function
`Add'  which takes  the existing list  as its  first argument  and  a new
element as  its second argument.  The  new  element  is added to the list
`primes' and again no value is returned but the list `primes' is changed.
\beginexample
gap> Add(primes, 41);
gap> primes;
[ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41 ]
\endexample
Single elements of a list are referred to by their position in the  list.
To get the value  of the seventh prime, that is the seventh entry in  our
list `primes', you simply type
\beginexample
gap> primes[7];
17
\endexample
This value can be handled like any other value, for example multiplied by 2
or assigned to a  variable. On the other hand  this mechanism allows one to
assign a value to  a position in  a  list. So the   next prime 43  may be
inserted  in the   list directly  after the  last   occupied position  of
`primes'. This  last occupied    position  is returned  by  the  function
`Length'.
\beginexample
gap> Length(primes);
13
gap> primes[14]:= 43;
43
gap> primes;
[ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43 ]
\endexample
Note that this operation again has changed the object `primes'.  The
next position after the end of a list is not the only position capable
of taking a new value.  If you know that 71 is the 20th prime, you can
enter it right now in the 20th position of `primes'.  This will result
in a list with holes which is however still a list and now has length
20.
\beginexample
gap> primes[20]:= 71;
71
gap> primes;
[ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,,,,,, 71 ]
gap> Length(primes);
20
\endexample
The list itself however must  exist before a  value can be  assigned to a
position of the list.  This list may be the empty list `[ ]'.
\beginexample
gap> lll[1]:= 2;
Variable: 'lll' must have a value

\endexample

\beginexample
gap> lll:= []; lll[1]:= 2;
[  ]
2
\endexample
Of course  existing entries of a list  can be  changed by this mechanism,
too. We will not do it here because `primes' then may no longer be a list
of primes. Try for yourself to change the 17 in the list into a 9.

To get the position    of 17 in  the   list  `primes' use   the  function
`Position' which takes the list as its  first argument and the element as
its second argument  and returns the position of  the first occurrence of
the element 17 in the list `primes'.
If the element is not contained in the list then `Position' will return
the special object `fail'.
\beginexample
gap> Position(primes, 17);
7
gap> Position(primes, 20);
fail
\endexample
In  all  of the  above changes to  the  list `primes',  the list has been
automatically resized.  There  is no need  for you to tell {\GAP} how big
you want a list to be.  This is all done dynamically.

It is not necessary for the objects collected in a list to be of the same
type.
\beginexample
gap> lll:= [true, "This is a String",,, 3];
[ true, "This is a String",,, 3 ]
\endexample
In the same way a list may be part of another  list.  A list  may even be
part of itself.
\beginexample
gap> lll[3]:= [4,5,6];; lll;
[ true, "This is a String", [ 4, 5, 6 ],, 3 ]
gap> lll[4]:= lll;
[ true, "This is a String", [ 4, 5, 6 ], ~, 3 ]
\endexample
Now the tilde in the fourth position of `lll'  denotes the object that is
currently  printed. Note that  the result  of the  last operation is  the
actual value  of  the  object  `lll'   on  the  right  hand side  of  the
assignment. In  fact it is  identical to the value  of the whole list
`lll' on the left hand side of the assignment.

\index{strings}\index{lists!dense}
A *string*  is a  special type  of list,
namely a dense  list of *characters*, where *dense* means  that the list has
no  holes. Here,  *characters* are  special {\GAP}  objects representing  an
element of the character set of the operating system. The input of printable
characters is  by enclosing them in  single quotes `\pif'. A  string literal
can either be entered as the list of characters or by writing the characters
between doublequotes `"'. Strings are  handled specially by `Print'. You can
learn much more about strings in the reference manual.

\beginexample
gap> s1 := ['H','a','l','l','o',' ','w','o','r','l','d','.'];
"Hallo world."
gap> s1 = "Hallo world.";
true
gap> s1[7];
'w'
\endexample

Sublists of lists can easily be extracted and assigned using the operator
`<list>\{ <positions> \}'.
\beginexample
gap> sl := lll{ [ 1, 2, 3 ] };
[ true, "This is a String", [ 4, 5, 6 ] ]
gap> sl{ [ 2, 3 ] } := [ "New String", false ];
[ "New String", false ]
gap> sl;
[ true, "New String", false ]
\endexample
This way you get a new list whose <i>th entry is that element of the
original list whose position is the <i>th entry of the argument in the
curly braces.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Identical Lists}

\atindex{lists!identical}{@lists!identical|indexit}
This second  section  about lists is dedicated  to  the subtle difference
between  *equality*  and *identity*  of lists. It is really important to
understand   this  difference in  order   to  understand how complex data
structures are  realized in {\GAP}.   This section applies  to all {\GAP}
objects  that have  subobjects,  e.g.,  to lists   and to  records. After
reading the section~"Plain Records" about records you should return to
this section and translate it into the record context.

Two  lists are *equal* if all their entries are equal.  This means that the
equality operator `=' returns `true' for the  comparison of  two lists if
and  only if these two lists are of the same length and for each position
the values in the respective lists are equal.
\beginexample
gap> numbers := primes;; numbers = primes;
true
\endexample
We assigned  the  list `primes' to the variable  `numbers' and, of course
they are equal as they have  both  the same length  and the same entries.
Now we  will change the  third number to  4 and  compare the result again
with `primes'.
\beginexample
gap> numbers[3]:= 4;; numbers = primes;
true
\endexample
You  see that  `numbers' and  `primes'  are still   equal, check this  by
printing the value of `primes'. The list `primes' is  no longer a list of
primes! What has  happened?  The truth is  that  the  lists  `primes' and
`numbers' are  not only equal but they are also *identical*. `primes' and
`numbers' are two variables pointing to the  same list. If you change the
value of  the subobject `numbers[3]'  of `numbers' this will  also change
`primes'.  Variables do *not* point to  a certain block of storage memory
but they do  point  to an object that  occupies  storage memory.   So the
assignment `numbers := primes' did *not* create a new list in a different
place of memory but only created the new name `numbers'  for the same old
list of primes.

From this we see that *the same object can have several names.*

If you want to change a list with the  contents of `primes' independently
from `primes'  you will have to  make a copy of  `primes' by the function
`ShallowCopy' which takes an object as its argument and returns a copy of
the argument. (We will first restore the old value of `primes'.)
\beginexample
gap> primes[3]:= 5;; primes;
[ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,,,,,, 71 ]
gap> numbers:= ShallowCopy(primes);; numbers = primes;
true
gap> numbers[3]:= 4;; numbers = primes;
false
\endexample
Now `numbers' is no longer equal to `primes' and `primes' still is a list
of primes.  Check this by printing the values of `numbers' and `primes'.

Lists and records can be changed this way because {\GAP} objects of these
types have subobjects.
To clarify this statement consider the following example.
\beginexample
gap> i:= 1;; j:= i;; i:= i+1;; 
\endexample
By adding 1 to `i' the value of `i' has  changed.   What  happens to `j'?
After the second statement `j' points to the same object  as `i',  namely
to the  integer 1.  The  addition  does *not* change  the object `1'  but
creates a new object according  to the instruction `i+1'.  It is actually
the assignment that changes the value of `i'.  Therefore `j' still points
to  the object `1'.  Integers  (like permutations and  booleans)  have no
subobjects.  Objects  of these types  cannot  be  changed but can only be
replaced by other objects.   And a replacement does not change the values
of other variables.  In the above example an assignment of a new value to
the variable `numbers' would also not change the value of `primes'.

Finally try the following examples and explain the results.
\beginexample
gap> l:= [];; l:= [l];
[ [  ] ]
gap> l[1]:= l;
[ ~ ]
\endexample
Now return to Section~"Plain Lists" and find out whether the functions
`Add' and `Append' change their arguments.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Immutability}

{\GAP} has a mechanism that protects lists against  changes like the ones
that have bothered   us in    Section~"Identical Lists". The     function
`Immutable' takes as argument a list and returns an immutable copy of it,
i.e., a list  which  looks exactly like the   old one, but has  two extra
properties:
(1)~The new list is immutable, i.e.,  the list itself and its subobjects 
    cannot be changed.
(2)~In constructing the copy, every part of  the list that can be changed
    has been copied, so that changes to the  old list will not affect the
    new one.  In other words, the new  list has no  mutable subobjects in
    common with the old list.
%notest
\beginexample
gap> list := [ 1, 2, "three", [ 4 ] ];; copy := Immutable( list );;
gap> list[3][5] := 'w';; list; copy;
[ 1, 2, "threw", [ 4 ] ]
[ 1, 2, "three", [ 4 ] ]
gap> copy[3][5] := 'w';
Lists Assignment: <list> must be a mutable list
not in any function
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you can 'return;' and ignore the assignment to continue
brk> quit;
\endexample
As a consequence of  these rules, in the  immutable copy of a list  which
contains an already immutable list as subobject, this immutable subobject
need not be copied,  because it is unchangeable. Immutable lists are
useful in many complex {\GAP} objects,  for example as generator lists of
groups. By  making them immutable, {\GAP}  ensures that no generators can
be added to the list, removed or exchanged. Such  changes would of course
lead  to serious inconsistencies with  other  knowledge that may already
have been calculated for the group.

A converse function to `Immutable' is `ShallowCopy', which produces a
new mutable list whose $i$th entry is the $i$th entry of the old
list. The single entries are not copied, they are just placed in the
new list.  If the old list is immutable, and hence the list entries
are immutable themselves, the result of `ShallowCopy' is mutable only
on the top level.

It should be noted that also other objects than lists can appear in
mutable or immutable form.
Records (see Section~"Plain Records") provide another example.

%\indextt{StructuralCopy}
%\exercise How can  you produce  a  mutable ``deep copy'' of  an immutable
%list?
%
%\answer `StructuralCopy( list )' will copy `list' only as deep  as  it is
%mutable, hence it will not copy an immutable list at all.  So you have to
%iterate the effect  of `ShallowCopy', e.g.,  with the following recursive
%function:
%\begintt
%DeepCopy := function( old )
%local   new,  entry;
%    new := [  ];  for entry  in old  do
%    if IsList( entry )  then  Add( new, DeepCopy( entry ) );
%                        else  Add( new, entry );  fi;  od;
%    return new;
%end;
%\endtt
%This works only if the original list  does not contain the same subobject
%(up to `IsIdenticalObj', see Section~"Objects vs. Elements") twice.
%For example, the list which {\GAP} prints as `[ ~ ]' will cause this
%function to recurse infinitely.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Sets}

\index{lists!strictly sorted}\index{family}
{\GAP} knows several special kinds of lists.  A *set* in {\GAP} is a
list that contains no holes (such a list is called *dense*) and whose
elements are strictly sorted w.r.t.~`\<'; in particular, a set cannot
contain duplicates.  (More precisely, the elements of a set in {\GAP}
are required to lie in the same *family*, but roughly this means that
they can be compared using the `\<' operator.)

This provides a natural model for mathematical sets whose elements are
given by an explicit enumeration.

{\GAP} also calls a set a *strictly sorted list*, and the function
`IsSSortedList' tests whether a given list is a set.  It returns a
boolean value.  For almost any list whose elements are contained in
the same family, there exists a corresponding set.  This set is
constructed by the function `Set' which takes the list as its argument
and returns a set obtained from this list by ignoring holes and
duplicates and by sorting the elements.

The elements of the sets used in the examples of this section are
strings.
\beginexample
gap> fruits:= ["apple", "strawberry", "cherry", "plum"];
[ "apple", "strawberry", "cherry", "plum" ]
gap> IsSSortedList(fruits);
false
gap> fruits:= Set(fruits);
[ "apple", "cherry", "plum", "strawberry" ]
\endexample
Note that the original list `fruits' is not changed by the function
`Set'.  We have to make a new assignment to the variable `fruits' in
order to make it a set.

The operator `in' is  used  to test whether an  object is an element of a
set.  It returns a boolean value `true' or `false'.
\beginexample
gap> "apple" in fruits;
true
gap> "banana" in fruits;
false
\endexample
The operator `in' can also be applied to ordinary lists. It is however
much  faster  to perform  a  membership test for   sets since sets are
always  sorted and a  binary search  can be  used  instead of a linear
search.  New elements  may be added to a  set by the function `AddSet'
which takes the  set `fruits' as its first  argument and an element as
its second argument   and adds the element  to  the set  if  it wasn't
already there. Note that the object `fruits' is changed.
\beginexample
gap> AddSet(fruits, "banana");
gap> fruits;  #  The banana is inserted in the right place.
[ "apple", "banana", "cherry", "plum", "strawberry" ]
gap> AddSet(fruits, "apple");
gap> fruits;  #  fruits has not changed.
[ "apple", "banana", "cherry", "plum", "strawberry" ]
\endexample
Note that inserting new elements into a set with `AddSet' is usually more
expensive than simply adding new elements at the end of a list.

Sets can be intersected by the function `Intersection'  and united by the
function `Union' which both take  two sets as their arguments  and return
the intersection resp. union of the two sets as a new object.
\beginexample
gap> breakfast:= ["tea", "apple", "egg"];
[ "tea", "apple", "egg" ]
gap> Intersection(breakfast, fruits);
[ "apple" ]
\endexample
The  arguments  of the functions  `Intersection'  and `Union' could be
ordinary lists, while their  result is always  a set. Note that in the
preceding  example at least one  argument of  `Intersection' was not a
set.   The functions   `IntersectSet' and  `UniteSet'   also form  the
intersection resp.~union of two sets. They will however not return the
result  but change their  first argument  to be  the result.  Try them
carefully.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Ranges}

A *range* is a finite arithmetic progression of integers. This is another
special kind of list. A range is described by the first two values and the last
value of the arithmetic progression which are given in the form
`[<first>,<second>..<last>]'.
In the usual case of an ascending list of
consecutive integers the second entry may be omitted.
\beginexample
gap> [1..999999];     #  a range of almost a million numbers
[ 1 .. 999999 ]
gap> [1, 2..999999];  #  this is equivalent
[ 1 .. 999999 ]
gap> [1, 3..999999];  #  here the step is 2
[ 1, 3 .. 999999 ]
gap> Length( last );
500000
gap> [ 999999, 999997 .. 1 ];
[ 999999, 999997 .. 1 ]
\endexample
This compact printed representation of a fairly long  list corresponds to
a  compact internal representation.
The function `IsRange' tests whether an object is a range,
the function `ConvertToRangeRep' changes the representation of a list
that is in fact a range to this compact internal representation.
\beginexample
gap> a:= [-2,-1,0,1,2,3,4,5];
[ -2, -1, 0, 1, 2, 3, 4, 5 ]
gap> IsRange( a );
true
gap> ConvertToRangeRep( a );;  a;
[ -2 .. 5 ]
gap> a[1]:= 0;; IsRange( a );
false
\endexample
Note that this  change of representation does  *not* change the  value of
the list `a'. The list `a'  still behaves in any context  in the same way
as it would have in the long representation.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{For and While Loops}

\atindex{loops!for}{@loops!\noexpand`for'|indexit}
\atindex{loops!while}{@loops!\noexpand`while'|indexit}

Given a list `pp' of permutations we can form their product by means of a
`for' loop instead of writing down the product explicitly.

\beginexample
gap> pp:= [ (1,3,2,6,8)(4,5,9), (1,6)(2,7,8), (1,5,7)(2,3,8,6),
>           (1,8,9)(2,3,5,6,4), (1,9,8,6,3,4,7,2)];;
gap> prod:= ();        
()
gap> for p in pp do
>       prod:= prod*p;    
>    od;
gap> prod;        
(1,8,4,2,3,6,5,9)
\endexample

First a  new variable `prod'  is initialized  to the identity permutation
`()'. Then the loop variable `p' takes as its value one permutation after
the other from the list `pp' and is multiplied with  the present value of
`prod'  resulting in a  new value which  is then assigned  to `prod'.

The `for' loop has the following syntax

\)\fmark for <var> in <list> do <statements> od;

The  effect of the `for'  loop  is to execute the <statements> for  every
element  of  the <list>.   A `for'  loop  is  a  statement  and therefore
terminated by a semicolon.  The list of <statements>  is enclosed by  the
keywords `do' and `od'  (reverse  `do').  A `for'  loop returns no value.
Therefore we had to ask explicitly for the value of `prod' in the
preceding example.

The `for' loop can loop over any kind of list, even a list with holes.
In many programming languages the `for' loop has the form

`for <var> from <first> to <last> do <statements> od;'

In {\GAP} this is merely a special case of the general `for' loop as defined
above where the <list> in the loop body is a range (see~"Ranges"):

\)\fmark for <var> in [<first>..<last>] do <statements>  od;

You can for  instance loop over a range to compute the factorial $15!$
of the number $15$ in the following way.

\beginexample
gap> ff:= 1;
1
gap> for i in [1..15] do
>       ff:= ff * i;
>    od;
gap> ff;
1307674368000
\endexample

The  `while' loop has the following syntax

\)\fmark while <condition> do <statements>  od; 

The `while'  loop loops over the <statements>  as long as  the 
<condition> evaluates  to  `true'. Like the `for' loop the `while' loop 
is terminated by the keyword `od' followed by a semicolon.

We can use  our list `primes' to perform a very simple factorization.  We
begin by  initializing a list `factors' to the empty list.   In this list
we want to collect the prime factors of the number 1333.  Remember that a
list has to exist  before any values  can be assigned to positions of the
list.  Then we  will loop over the list `primes' and  test for each prime
whether it divides the  number.  If it does we will  divide the number by
that prime, add it to the list `factors' and continue.

\beginexample
gap> n:= 1333;;
gap> factors:= [];;
gap> for p in primes do
>       while n mod p = 0 do
>          n:= n/p;
>          Add(factors, p);
>       od;
>    od;
gap> factors;
[ 31, 43 ]
gap> n;
1
\endexample

As `n' now has the value 1 all prime factors  of 1333 have been found and
`factors' contains a complete factorization of  1333.  This can of course
be verified by multiplying 31 and 43.

This loop  may  be applied  to arbitrary  numbers in order  to find prime
factors.  But  as `primes' is not a complete list of all primes this loop
may fail  to find all prime factors of  a number greater than 2000,  say.
You  can try to improve it in such a way that new primes are added to the
list `primes' if needed.

You have already seen that list objects may be  changed.   This of
course also holds  for the  list in a loop body.  In most  cases  you have to be
careful not  to change this list, but there are situations  where this is
quite useful.  The following example  shows a quick way  to determine the
primes smaller than 1000 by a sieve method.  Here we will make use of the
function `Unbind' to delete entries from a list, and the 'if'
statement covered in "If Statements".
\beginexample
gap> primes:= [];;
gap> numbers:= [2..1000];;
gap> for p in numbers do
>       Add(primes, p);
>       for n in numbers do
>          if n mod p = 0 then
>             Unbind(numbers[n-1]);
>          fi;
>       od;
>    od;
\endexample
The inner loop  removes all entries from `numbers' that are  divisible by
the last detected prime `p'.  This is done by the function `Unbind' which
deletes the binding of the list position  `numbers[n-1]' to the value `n'
so that afterwards `numbers[n-1]' no longer has  an  assigned value.  The
next  element encountered in `numbers'  by the outer  loop necessarily is
the next prime.

In a similar way it is possible to enlarge the list which is looped over.
This yields a nice and short orbit  algorithm for the  action of a group,
for example.

More about `for' and `while' loops can be found in the
sections~"ref:While" and~"ref:For" of the reference manual.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{List Operations}

There is a more comfortable way than that given in the previous section to
compute the product of a list of numbers or permutations.
\beginexample
gap> Product([1..15]);
1307674368000
gap> Product(pp);
(1,8,4,2,3,6,5,9)
\endexample
The function  `Product'  takes a  list as  its argument and computes  the
product  of  the  elements  of the  list.   This  is possible whenever  a
multiplication of  the elements of the list is defined.  So  `Product' 
executes a loop over all elements of the list.

There are other often used loops available as functions.   Guess what the
function `Sum' does.  The function `List' may  take a list and a function
as its arguments.  It will then apply the function to each element of the
list  and return  the corresponding list of results.   A list of cubes is
produced as follows with the function `cubed' from Section~"Functions".
\beginexample
gap> cubed:= x -> x^3;;
gap> List([2..10], cubed);
[ 8, 27, 64, 125, 216, 343, 512, 729, 1000 ]
\endexample
To add all these cubes  we might apply the  function  `Sum' to  the  last
list.  But we may  as well  give the  function  `cubed' to  `Sum'  as  an
additional argument.
\beginexample
gap> Sum(last) = Sum([2..10], cubed);
true
\endexample
The  primes less than 30 can  be retrieved out  of the list `primes' from
Section~"Plain Lists" by the function `Filtered'. This function takes the
list `primes' and a property as its arguments and will return the list of
those elements of `primes' which have this property. Such a property will
be represented  by  a function  that  returns  a boolean  value. In  this
example the property  of  being less than  30 can be represented  by  the
function `x  -> x \<   30' since `x \<   30' will evaluate to `true'  for
values `x' less than 30 and to `false' otherwise.
\beginexample
gap> Filtered(primes, x-> x < 30);
[ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 ]
\endexample
We have already  mentioned the operator `\{  \}' that  forms sublists. It
takes a  list of positions  as its argument  and will return  the list of
elements from the original list corresponding to these positions.
\beginexample
gap> primes{ [1 .. 10] };
[ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 ]
\endexample

Finally we mention the function `ForAll' that checks whether a property
holds for all elements of a list. It takes as its arguments  a list and a 
function that returns a boolean value. `ForAll' checks whether the
function returns `true' for all elements of the list.

\beginexample
gap> list:= [ 1, 2, 3, 4 ];;
gap> ForAll( list, x -> x > 0 );
true
gap> ForAll( list, x -> x in primes );
false
\endexample
 
You will find more predefined `for' loops in chapter~"ref:Lists" of the
reference manual.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Vectors and Matrices}

\index{vectors!row}\index{matrices}
This section describes how {\GAP} uses lists to represent row vectors and
matrices. A *row vector* is a dense list of elements from a common field.
A *matrix* is a dense list of row vectors over a common field and of
equal length.
\beginexample
gap> v:= [3, 6, 2, 5/2];;  IsRowVector(v);
true
\endexample
Row vectors  may be  added and multiplied   by scalars from  their field.
Multiplication of   row vectors of  equal length  results in their scalar
product.
\beginexample
gap> 2 * v;  v * 1/3;
[ 6, 12, 4, 5 ]
[ 1, 2, 2/3, 5/6 ]
gap> v * v;   # the scalar product of `v' with itself
221/4
\endexample
Note  that   the expression `v   *  1/3' is   actually evaluated by first
multiplying `v' by 1 (which yields again `v')  and by then dividing by 3.
This  is  also an allowed scalar   operation.  The expression `v/3' would
result in  the same value.

Such arithmetical operations (if the results are again vectors)
result in *mutable* vectors except if the operation is binary
and both operands are immutable;
thus the vectors shown in the examples above are all mutable.

So if you want to produce a mutable list with 100~entries equal to~25,
you can simply say `25  + 0 * [ 1 .. 100 ]'.
Note that ranges are also vectors (over the rationals),
and that `[ 1 .. 100 ]' is mutable.

%In many algorithms, mutable lists of this type are needed as an initial
%value for a data structure. To avoid the necessity to use `ShallowCopy',
%{\GAP} offers the operation `ListWithIdenticalEntries(<len>,<val>)' that
%will produce such a mutable list.

%\indextt{ListWithIdenticalEntries}
%\exercise  How can  you produce  a mutable  list  with 100~entries  equal
%to~25?
%
%\answer `ShallowCopy( 25 + 0 * [ 1 .. 100 ] )' or `List(  [ 1 .. 100 ], x
%->  25 )'. Since such constructions  are frequently needed, {\GAP} offers
%you a shortcut: you can simply say `ListWithIdenticalEntries( 100, 25 )'.

A matrix is a dense list of row vectors of equal length.
\beginexample
gap> m:= [[1,-1, 1],
>         [2, 0,-1],
>         [1, 1, 1]];
[ [ 1, -1, 1 ], [ 2, 0, -1 ], [ 1, 1, 1 ] ]
gap> m[2][1];
2
\endexample
Syntactically a matrix is a list of lists. So the number  2 in the second
row  and the first  column of the matrix `m'  is referred to as the first
element of the second element of the list `m' via `m[2][1]'.

A matrix may be multiplied by scalars, row vectors and other matrices.
(If the row vectors and matrices involved in such a multiplication do not
have suitable dimensions then the ``missing'' entries are treated as zeros,
so the results may look unexpectedly in such cases.)

\beginexample
gap> [1, 0, 0] * m;
[ 1, -1, 1 ]
gap> [1, 0, 0, 2] * m;
[ 1, -1, 1 ]
gap> m * [1, 0, 0];
[ 1, 2, 1 ]
gap> m * [1, 0, 0, 2];
[ 1, 2, 1 ]
\endexample
Note that multiplication  of a row vector with  a matrix will result in a
linear combination of the  rows of the  matrix, while multiplication of a
matrix with a row  vector results in  a linear combination of the columns
of the  matrix. In  the latter case  the  row vector is considered   as a
column vector.

A vector or matrix of integers can also be multiplied
with a finite field scalar and vice versa.
Such products result in a matrix over the finite field with the integers
mapped into the finite field in the obvious way.
Finite field matrices are nicer to read when they are `Display'ed rather
than `Print'ed.
(Here  we write `Z(q)' to denote a  primitive root of the finite field
with `q' elements.)
\beginexample
gap> Display( m * One( GF(5) ) );
 1 4 1
 2 . 4
 1 1 1
gap> Display( m^2 * Z(2) + m * Z(4) );
z = Z(4)
 z^1 z^1 z^2
   1   1 z^2
 z^1 z^1 z^2
\endexample
Submatrices    can  easily     be    extracted  using    the   expression
`<mat>\{<rows>\}\{<columns>\}'. They   can also be  assigned to, provided
the big matrix  is mutable (which  it is not if it  is  the result of  an
arithmetical operation, see above).
\beginexample
gap> sm := m{ [ 1, 2 ] }{ [ 2, 3 ] };
[ [ -1, 1 ], [ 0, -1 ] ]
gap> sm{ [ 1, 2 ] }{ [2] } := [[-2],[0]];;  sm;
[ [ -1, -2 ], [ 0, 0 ] ]
\endexample
The first curly brackets contain the selection of rows,
the second that of columns.

Matrices appear not only in linear algebra, but also as group elements,
provided they are invertible.
Here we have the opportunity to meet a group-theoretical function,
namely `Order', which computes the order of a group element.
\beginexample
gap> Order( m * One( GF(5) ) );
8
gap> Order( m );
infinity
\endexample
For matrices whose entries are more complex objects, for example rational
functions, {\GAP}'s `Order' methods might not be able to prove that the
matrix has infinite order, and one gets the following warning.
\begintt
|#I  Order: warning, order of <mat> might be infinite
\endtt
In such a case, if the order of the matrix really is infinite, you will
have to interrupt {\GAP} by  pressing `<ctl>-C' (followed by `<ctl>-D' or
`quit;'  to leave the   break loop).

To prove that the order of `m' is infinite, we also could look at the
minimal polynomial of `m' over the rationals.
\beginexample
gap> f:= MinimalPolynomial( Rationals, m );;  Factors( f );
[ x_1-2, x_1^2+3 ]
\endexample
`Factors'  returns a list of  irreducible factors  of the polynomial `f'.
The first  irreducible factor $X-2$ reveals   that 2 is an  eigenvalue of
`m', hence its order cannot be finite.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Plain Records}

A record provides another way to  build new data structures.  Like a list
a record contains subobjects.
In a record the elements, the so-called *record components*,
are not indexed by numbers but by names.

In this section you will see how to define and how to use records.
Records are changed by assignments to record components.

Initially a record is defined as a comma separated list of assignments to
its record components.

\beginexample
gap> date:= rec(year:= 1997,
>               month:= "Jul",
>               day:= 14);
rec( year := 1997, month := "Jul", day := 14 )
\endexample

The value of a record component is accessible by  the record name and the
record  component name separated   by one dot   as  the record  component
selector.

\beginexample
gap> date.year;
1997
\endexample

Assignments to new record components  are possible in  the same way.  The
record is automatically resized to hold the new component.

\beginexample
gap> date.time:= rec(hour:= 19, minute:= 23, second:= 12);
rec( hour := 19, minute := 23, second := 12 )
gap> date;
rec( year := 1997, month := "Jul", day := 14, 
  time := rec( hour := 19, minute := 23, second := 12 ) )
\endexample

We may use the `Display' function to illustrate the hierarchy of the record
components.

\beginexample
gap> Display( date );
rec(
  year := 1997,
  month := "Jul",
  day := 14,
  time := rec(
      hour := 19,
      minute := 23,
      second := 12 ) )
\endexample

Records are objects  that  may be  changed.   An assignment to  a  record
component  changes the original  object.
The remarks made in Sections~"Identical Lists" and "Immutability"
about identity and mutability of lists are also true for records.

Sometimes it is interesting to know which  components of a certain record
are  bound.  This information is available  from the function `RecNames',
which  takes a record as  its  argument and  returns  a list of names of
all bound components of this record as a list of strings.

\beginexample
gap> RecNames(date);
[ "year", "month", "day", "time" ]
\endexample

%\exercise Finally try the following examples and explain the results.
%\b eginexample
%gap> r:= rec();
%rec(
%   )
%gap> r:= rec(r:= r);
%rec(
%  r := rec(
%       ) )
%gap> r.r:= r;
%rec(
%  r := ~ )
%\e ndexample
%
%\answer  The  first  assignment to `r'    creates a  record.   The second
%assignment assigns a  new object to `r', namely  a record whose component
%`r' contains the old record object created  in the first assignment.  The
%last assignment changes the value of the record component `r' and creates
%a recursive object.

Now return to Sections "Identical Lists"  and "Immutability" and find out
what these sections mean for records.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Further Information about Lists}

(The following cross-references point to the {\GAP} Reference Manual.)

% In this chapter you have encountered the fundamental concept of a list.
% You have seen how to construct lists, how to extend them and how to refer
% to single elements of a list.
% Moreover you have seen that lists may contain elements of different
% types, even holes (unbound  entries),
% and that a list may be an entry of itself or of one of its entries.
% 
% You have seen the difference between equal lists and identical lists.
% Since lists are objects that have subobjects, they can be mutable or
% immutable, and mutable lists can be changed.
% Changing an object will change the values of all variables that point to
% that object.
% Be careful, since one object can have several names.
% The function `ShallowCopy' creates a shallow copy of a list which is then
% a new object.
% 
You will find more about lists, sets, and ranges in Chapter~"ref:Lists",
in particular more about identical lists in Section~"ref:Identical Lists".
% 
% You have seen that sets are a special kind of list.
% There are functions to expand sets, intersect or unite sets, and there is
% the membership test with the `in' operator.
% Sets are described in more detail in Chapter~"ref:Sets".
% 
% You have seen that finite arithmetic progressions of integers can be
% represented in a compact way as ranges.
% Chapter~"ref:Ranges" contains a detailed description of ranges.
% 
A more detailed description of strings is contained in
Chapter~"ref:Strings and Characters".
% 
% You have met row vectors and matrices as special lists,
% and you have seen how to refer to entries of a matrix and how to multiply
% scalars, row vectors, and matrices.
% 
Fields are described in Chapter~"ref:Fields and Division Rings", some
known fields in {\GAP} are described in Chapters~"ref:Rational
Numbers", "ref:Abelian Number Fields", and~"ref:Finite Fields".  Row
vectors and matrices are described in more detail in Chapters~"ref:Row
Vectors" and~"ref:Matrices".  Vector spaces are described in
Chapter~"ref:Vector Spaces", further matrix related structures are
described in Chapters~"ref:Matrix Groups", "ref:Algebras",
and~"ref:Lie Algebras".
% 
% You have learned how to loop over a list by the `for' loop and how to
% loop with respect to a logical condition with the `while' loop.
% You have seen that even the list in the loop body can be changed.

% 
% You have seen some functions which implement often used `for' loops.
% There are functions like `Product' to form the product of the elements of
% a list.
% The function `List' can apply a function to all elements of a list
% and the function `Filtered' creates a sublist of a given list.
You will find more list operations in Chapter~"ref:Lists".

Records and functions for records are described in detail
in Chapter~"ref:Records".

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%E

