<html><head><title>[tut] 6 Vector Spaces and Algebras</title></head>
<body text="#000000" bgcolor="#ffffff">
[<a href="../index.htm">Top</a>] [<a href = "chapters.htm">Up</a>] [<a href ="CHAP005.htm">Previous</a>] [<a href ="CHAP007.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<h1>6 Vector Spaces and Algebras</h1><p>
<P>
<H3>Sections</H3>
<oL>
<li> <A HREF="CHAP006.htm#SECT001">Vector Spaces</a>
<li> <A HREF="CHAP006.htm#SECT002">Algebras</a>
<li> <A HREF="CHAP006.htm#SECT003">Further Information about Vector Spaces and Algebras</a>
</ol><p>
<p>
This chapter contains an introduction into vector spaces and
algebras in <font face="Gill Sans,Helvetica,Arial">GAP</font>.
<p>
<p>
<h2><a name="SECT001">6.1 Vector Spaces</a></h2>
<p><p>
A <strong>vector space</strong> over the field <i>F</i> is an additive group that is closed
under scalar multiplication with elements in <i>F</i>.
In <font face="Gill Sans,Helvetica,Arial">GAP</font>, only those domains that are
constructed as vector spaces are regarded as vector spaces .
In particular, an additive group that does not know about an
acting domain of scalars is not regarded as a vector space in <font face="Gill Sans,Helvetica,Arial">GAP</font>.
<p>
Probably the most common <i>F</i>-vector spaces in <font face="Gill Sans,Helvetica,Arial">GAP</font> are so-called
<strong>row spaces</strong>.
They consist of row vectors, that is, lists whose elements lie in <i>F</i>.
In the following example we compute the vector space spanned by the
row vectors <code>[ 1, 1, 1 ]</code> and <code>[ 1, 0, 2 ]</code> over the rationals.
<p>
<pre>
gap&gt; F:= Rationals;;
gap&gt; V:= VectorSpace( F, [ [ 1, 1, 1 ], [ 1, 0, 2 ] ] );
&lt;vector space over Rationals, with 2 generators&gt;
gap&gt; [ 2, 1, 3 ] in V;
true
</pre>
<p>
The full row space <i>F</i><sup><i>n</i></sup> is created by commands like:
<p>
<pre>
gap&gt; F:= GF( 7 );;
gap&gt; V:= F^3;   # The full row space over F of dimension 3. 
( GF(7)^3 )
gap&gt; [ 1, 2, 3 ] * One( F ) in V;  
true
</pre>
<p>
In the same way we can also create matrix spaces. Here the short notation
<code></code><var>field</var><code>^[</code><var>dim1</var><code>,</code><var>dim2</var><code>]</code> can be used:
<p>
<pre>
gap&gt; m1:= [ [ 1, 2 ], [ 3, 4 ] ];; m2:= [ [ 0, 1 ], [ 1, 0 ] ];;
gap&gt; V:= VectorSpace( Rationals, [ m1, m2 ] );
&lt;vector space over Rationals, with 2 generators&gt;
gap&gt; m1+m2 in V;
true
gap&gt; W:= Rationals^[3,2];
( Rationals^[ 3, 2 ] )
gap&gt; [ [ 1, 1 ], [ 2, 2 ], [ 3, 3 ] ] in W;
true
</pre>
<p>
A field is naturally a vector space over itself. 
<p>
<pre>
gap&gt; IsVectorSpace( Rationals );
true
</pre>
<p>
If &#934; is an algebraic extension of <i>F</i>, then &#934; is
also a vector space over <i>F</i> (and indeed over any subfield of &#934;
that contains <i>F</i>). This field <i>F</i> is stored in the attribute
<code>LeftActingDomain</code>.
In <font face="Gill Sans,Helvetica,Arial">GAP</font>, the default is to view fields as vector spaces
over their <strong>prime</strong> fields.
By the function <code>AsVectorSpace</code>, we can view fields
as vector spaces over fields other than the prime field.
<p>
<pre>
gap&gt; F:= GF( 16 );;
gap&gt; LeftActingDomain( F );
GF(2)
gap&gt; G:= AsVectorSpace( GF( 4 ), F );
AsField( GF(2^2), GF(2^4) )
gap&gt; F = G;
true
gap&gt; LeftActingDomain( G );
GF(2^2)
</pre>
<p>
A vector space has three important attributes: its <strong>field</strong> of definition,
its <strong>dimension</strong> and a <strong>basis</strong>. We already encountered the function 
<code>LeftActingDomain</code> in the example above. It extracts the field of definition
of a vector space.
The function <code>Dimension</code> provides the dimension of the space.
Here is one more example.
<p>
<pre>
gap&gt; F:= GF( 9 );;
gap&gt; m:= [ [ Z(3)^0, 0*Z(3), 0*Z(3) ], [ 0*Z(3), Z(3)^0, Z(3)^0 ] ];;
gap&gt; V:= VectorSpace( F, m );
&lt;vector space over GF(3^2), with 2 generators&gt;
gap&gt; Dimension( V );
2
gap&gt; W:= AsVectorSpace( GF( 3 ), V );
&lt;vector space over GF(3), with 4 generators&gt;
gap&gt; V = W;
true
gap&gt; Dimension( W );
4
gap&gt; LeftActingDomain( W );
GF(3)
</pre>
<p>
One of the most important attributes is a <strong>basis</strong>. For a given basis <i>B</i> of 
<i>V</i>, every vector <i>v</i> in <i>V</i> can be expressed uniquely as 
<i>v</i> = &#8721;<sub><i>b</i>  &#8712; <i>B</i></sub> <i>c</i><sub><i>b</i></sub> <i>b</i>, with coefficients <i>c</i><sub><i>b</i></sub>  &#8712; <i>F</i>.
<p>
In <font face="Gill Sans,Helvetica,Arial">GAP</font>, bases are special lists of vectors.
They are used mainly for the computation of coefficients and linear
combinations. 
<p>
Given a vector space <i>V</i>, a basis of <i>V</i> is obtained by
simply applying the function <code>Basis</code> to <i>V</i>. The vectors that form
the basis are extracted from the basis by <code>BasisVectors</code>. 
<p>
<pre>
gap&gt; m1:= [ [ 1, 2 ], [ 3, 4 ] ];; m2:= [ [ 1, 1 ], [ 1, 0 ] ];;
gap&gt; V:= VectorSpace( Rationals, [ m1, m2 ] );
&lt;vector space over Rationals, with 2 generators&gt;
gap&gt; B:= Basis( V );
SemiEchelonBasis( &lt;vector space over Rationals, with 2 generators&gt;, ... )
gap&gt; BasisVectors( Basis( V ) );
[ [ [ 1, 2 ], [ 3, 4 ] ], [ [ 0, 1 ], [ 2, 4 ] ] ]
</pre>
<p>
The coefficients of 
a vector relative to a given basis are found by the function
<code>Coefficients</code>. Furthermore, linear combinations of the basis vectors
are constructed using <code>LinearCombination</code>.
<p>
<pre>
gap&gt; V:= VectorSpace( Rationals, [ [ 1, 2 ], [ 3, 4 ] ] );
&lt;vector space over Rationals, with 2 generators&gt;
gap&gt; B:= Basis( V );
SemiEchelonBasis( &lt;vector space over Rationals, with 2 generators&gt;, ... )
gap&gt; BasisVectors( Basis( V ) );
[ [ 1, 2 ], [ 0, 1 ] ]
gap&gt; Coefficients( B, [ 1, 0 ] );
[ 1, -2 ]
gap&gt; LinearCombination( B, [ 1, -2 ] );
[ 1, 0 ]
</pre>
<p>
In the above examples we have seen that <font face="Gill Sans,Helvetica,Arial">GAP</font> often chooses the basis
it wants to work with. It is also possible to construct bases with
prescribed basis vectors by giving a list of these vectors as second argument 
to <code>Basis</code>.
<p>
<pre>
gap&gt; V:= VectorSpace( Rationals, [ [ 1, 2 ], [ 3, 4 ] ] );; 
gap&gt; B:= Basis( V, [ [ 1, 0 ], [ 0, 1 ] ] );
SemiEchelonBasis( &lt;vector space over Rationals, with 2 generators&gt;, 
[ [ 1, 0 ], [ 0, 1 ] ] )
gap&gt; Coefficients( B, [ 1, 2 ] );
[ 1, 2 ]
</pre>
<p>
We can construct subspaces and quotient spaces of vector spaces. The
natural projection map (constructed by <code>NaturalHomomorphismBySubspace</code>),
connects a vector space with its quotient space.
<p>
<pre>
gap&gt; V:= Rationals^4;
( Rationals^4 )
gap&gt; W:= Subspace( V, [ [ 1, 2, 3, 4 ], [ 0, 9, 8, 7 ] ] );
&lt;vector space over Rationals, with 2 generators&gt;
gap&gt; VmodW:= V/W;
( Rationals^2 )
gap&gt; h:= NaturalHomomorphismBySubspace( V, W );
&lt;linear mapping by matrix, ( Rationals^4 ) -&gt; ( Rationals^2 )&gt;
gap&gt; Image( h, [ 1, 2, 3, 4 ] );
[ 0, 0 ]
gap&gt; PreImagesRepresentative( h, [ 1, 0 ] );
[ 1, 0, 0, 0 ]
</pre>
<p>
<p>
<h2><a name="SECT002">6.2 Algebras</a></h2>
<p><p>
If a multiplication is defined for the elements of a vector space,
and if the vector space is closed under this multiplication then it is
called an <strong>algebra</strong>. For example, every field is an algebra:
<p>
<pre>
gap&gt; f:= GF(8); IsAlgebra( f );
GF(2^3)
true
</pre>
<p>
One of the most important classes of algebras are sub-algebras of matrix
algebras. On the set of all <i>n</i>&times;<i>n</i> matrices over a field <i>F</i> 
it is possible to define a multiplication in many ways.
The most frequent are the ordinary matrix multiplication and the Lie
multiplication.
<p>
Each matrix constructed as <code>[ </code><var>row1</var><code>, </code><var>row2</var><code>, ... ]</code> is regarded by <font face="Gill Sans,Helvetica,Arial">GAP</font>
as an <strong>ordinary</strong> matrix, its multiplication is the ordinary associative
matrix multiplication.
The sum and product of two ordinary matrices are again ordinary matrices.
<p>
The <strong>full</strong> matrix associative algebra can be created as follows:
<p>
<pre>
gap&gt; F:= GF( 9 );;
gap&gt; A:= F^[3,3];
( GF(3^2)^[ 3, 3 ] )
</pre>
<p>
An algebra can be constructed from generators using the function <code>Algebra</code>.
It takes as arguments the field of coefficients and a list of generators.
Of course the coefficient field and the generators must fit together;
if we want to construct an algebra of ordinary matrices,
we may take the field generated by the entries of the generating matrices,
or a subfield or extension field.
<p>
<pre>
gap&gt; m1:= [ [ 1, 1 ], [ 0, 0 ] ];; m2:= [ [ 0, 0 ], [ 0, 1 ] ];;
gap&gt; A:= Algebra( Rationals, [ m1, m2 ] );
&lt;algebra over Rationals, with 2 generators&gt;
</pre>
<p>
An interesting class of algebras for which many special algorithms
are implemented is the class of <strong>Lie algebras</strong>.
They arise for example as algebras of matrices whose product is defined
by the Lie bracket [ <i>A</i>, <i>B</i> ] = <i>A</i> * <i>B</i> &#8722; <i>B</i> * <i>A</i>,
where * denotes the ordinary matrix product.
<p>
Since the multiplication of objects in <font face="Gill Sans,Helvetica,Arial">GAP</font> is always assumed to be
the operation <code>\*</code> (resp. the infix operator <code>*</code>), 
and since there is already the ``ordinary'' matrix product defined for
ordinary matrices, as mentioned above,
we must use a different construction for matrices that occur as elements
of Lie algebras.
Such Lie matrices can be constructed by <code>LieObject</code> from ordinary matrices,
the sum and product of Lie matrices are again Lie matrices.
<p>
<pre>
gap&gt; m:= LieObject( [ [ 1, 1 ], [ 1, 1 ] ] ); 
LieObject( [ [ 1, 1 ], [ 1, 1 ] ] )
gap&gt; m*m;
LieObject( [ [ 0, 0 ], [ 0, 0 ] ] )
gap&gt; IsOrdinaryMatrix( m1 ); IsOrdinaryMatrix( m );
true
false
gap&gt; IsLieMatrix( m1 ); IsLieMatrix( m );
false
true
</pre>
<p>
Given a field <code>F</code> and a list <code>mats</code> of Lie objects over <code>F</code>, we can construct
the Lie algebra generated by <code>mats</code> using the function <code>Algebra</code>. 
Alternatively, if we do not want to be bothered with the function
<code>LieObject</code>, we can use the function <code>LieAlgebra</code> that takes a field
and a list of ordinary matrices, and constructs the Lie algebra generated
by the corresponding Lie matrices.
Note that this means that the ordinary matrices used in the call of 
<code>LieAlgebra</code> are not contained in the returned Lie algebra.
<p>
<pre>
gap&gt; m1:= [ [ 0, 1 ], [ 0, 0 ] ];;
gap&gt; m2:= [ [ 0, 0 ], [ 1, 0 ] ];; 
gap&gt; L:= LieAlgebra( Rationals, [ m1, m2 ] );
&lt;Lie algebra over Rationals, with 2 generators&gt;
gap&gt; m1 in L;
false
</pre>
<p>
A second way of creating an algebra is by specifying a multiplication 
table. Let <i>A</i> be a finite dimensional algebra with basis 
{<i>x</i><sub>1</sub>,&#8230;,<i>x</i><sub><i>n</i></sub>}, then for 1 &#8804; <i>i</i>,<i>j</i> &#8804; <i>n</i> the product <i>x</i><sub><i>i</i></sub><i>x</i><sub><i>j</i></sub> is
a linear combination of basis elements, i.e., there are <i>c</i><sub><i>ij</i></sub><sup><i>k</i></sup> in the
ground field such that
<br clear="all" /><table border="0" width="100%"><tr><td><table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center"> <i>x</i><sub><i>i</i></sub> <i>x</i><sub><i>j</i></sub> = </td><td nowrap="nowrap" align="center"><small><i>n</i></small><!--sup--><br /><font size="+3">&#8721;<br /></font><small><i>k</i>=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center"><i>c</i><sub><i>ij</i></sub><sup><i>k</i></sup> <i>x</i><sub><i>k</i></sub>. </td></tr></table></td></tr></table>
It is not difficult to show that the constants <i>c</i><sub><i>ij</i></sub><sup><i>k</i></sup>
determine the multiplication completely. Therefore, the <i>c</i><sub><i>ij</i></sub><sup><i>k</i></sup> are
called <strong>structure constants</strong>. In <font face="Gill Sans,Helvetica,Arial">GAP</font> we can create a finite dimensional
algebra by specifying an array of structure constants.
<p>
In <font face="Gill Sans,Helvetica,Arial">GAP</font> such a table of structure constants is represented using 
lists. The obvious way to do this
would be to construct a ``three-dimensional'' list <code>T</code> such that  
<code>T[i][j][k]</code> equals
<i>c</i><sub><i>ij</i></sub><sup><i>k</i></sup>. But it often happens that many of these constants vanish.
Therefore a more complicated structure is used in order to be able to 
omit
the zeros. A multiplication table of an <i>n</i>-dimensional algebra is an 
<i>n</i>&times;<i>n</i> array <code>T</code> such that <code>T[i][j]</code> describes the product
of the <code>i</code>-th and the <code>j</code>-th basis element. This product is encoded
in the following way. The entry <code>T[i][j]</code> is a list of two elements. 
The first of these is a list of
indices <i>k</i> such that <i>c</i><sub><i>ij</i></sub><sup><i>k</i></sup> is nonzero. The second list contains the
corresponding constants <i>c</i><sub><i>ij</i></sub><sup><i>k</i></sup>. Suppose, for example,  that <code>S</code> 
is the table 
of an algebra with basis {<i>x</i><sub>1</sub>,&#8230;,<i>x</i><sub>8</sub>} and that <code>S[3][7]</code> 
equals <code>[ [ 2, 4, 6 ], [ 1/2, 2, 2/3 ] ]</code>. Then in the algebra we 
have the relation 
<br clear="all" /><table border="0" width="100%"><tr><td><table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center"> <i>x</i><sub>3</sub> <i>x</i><sub>7</sub> = (1/2) <i>x</i><sub>2</sub> + 2 <i>x</i><sub>4</sub> + (2/3) <i>x</i><sub>6</sub>. </td></tr></table></td></tr></table>
Furthermore, if <code>S[6][1] = [ [  ], [  ] ]</code> then the product of the
sixth and first basis elements is zero.
<p>
Finally two numbers are added to the table. The first number can be
1, -1, or 0. If it is 1, then the table is known to be symmetric,
i.e., <i>c</i><sub><i>ij</i></sub><sup><i>k</i></sup>=<i>c</i><sub><i>ji</i></sub><sup><i>k</i></sup>. If this number is -1, then the table is
known to be antisymmetric (this happens for instance when the algebra
is a Lie algebra).
The remaining case, 0, occurs in all other cases. 
The second number that is added is the zero element of the field over 
which the algebra is defined.  
<p>
Empty structure constants tables are created by the function
<code>EmptySCTable</code>, which takes a dimension <i>d</i>, a zero element <i>z</i>,
and optionally one of the strings <code>"symmetric"</code>, <code>"antisymmetric"</code>,
and returns an empty structure constants table <i>T</i> corresponding to
a <i>d</i>-dimensional algebra over a field with zero element <i>z</i>.
Structure constants can be entered into the table <i>T</i> using the function
<code>SetEntrySCTable</code>.
It takes four arguments, namely <i>T</i>, two indices <i>i</i> and <i>j</i>,
and a list of the form <code>[<i>c</i><sub><i>ij</i></sub><sup><i>k</i><sub>1</sub></sup>,<i>k</i><sub>1</sub>,<i>c</i><sub><i>ij</i></sub><sup><i>k</i><sub>2</sub></sup>,<i>k</i><sub>2</sub>,...]</code>.
In this call to <code>SetEntrySCTable</code>,
the product of the <i>i</i>-th and the <i>j</i>-th basis vector
in any algebra described by <i>T</i> is set to &#8721;<sub><i>l</i></sub> <i>c</i><sub><i>ij</i></sub><sup><i>k</i><sub><i>l</i></sub></sup> <i>x</i><sub><i>k</i><sub><i>l</i></sub></sub>.
(Note that in the empty table, this product was zero.)
If <i>T</i> knows that it is (anti)symmetric, then at the same time also
the product of the <i>j</i>-th and the <i>i</i>-th basis vector is set appropriately.
<p>
In the following example we temporarily increase the line length limit from
its default value 80 to 82 in order to make the long output expression fit
into one line.
<p>
<pre>
gap&gt; SizeScreen([ 82, ]);;
gap&gt; T:= EmptySCTable( 2, 0, "symmetric" );
[ [ [ [  ], [  ] ], [ [  ], [  ] ] ], [ [ [  ], [  ] ], [ [  ], [  ] ] ], 1, 0 ]
gap&gt; SetEntrySCTable( T, 1, 2, [1/2,1,1/3,2] );  T;
[ [ [ [  ], [  ] ], [ [ 1, 2 ], [ 1/2, 1/3 ] ] ], 
  [ [ [ 1, 2 ], [ 1/2, 1/3 ] ], [ [  ], [  ] ] ], 1, 0 ]
gap&gt; SizeScreen([ 80, ]);;
</pre>
<p>
If we have defined a structure constants table, then we can construct
the corresponding algebra by <code>AlgebraByStructureConstants</code>.
<p>
<pre>
gap&gt; A:= AlgebraByStructureConstants( Rationals, T );
&lt;algebra of dimension 2 over Rationals&gt;
</pre>
<p>
If we know that a structure constants table defines a Lie algebra,
then we can construct the corresponding Lie algebra by
<code>LieAlgebraByStructureConstants</code>;
the algebra returned by this function knows that it is a Lie algebra,
so <font face="Gill Sans,Helvetica,Arial">GAP</font> need not check the Jacobi identity.
<p>
<pre>
gap&gt; T:= EmptySCTable( 2, 0, "antisymmetric" );;
gap&gt; SetEntrySCTable( T, 1, 2, [2/3,1] );
gap&gt; L:= LieAlgebraByStructureConstants( Rationals, T );
&lt;Lie algebra of dimension 2 over Rationals&gt;
</pre>
<p>
In <font face="Gill Sans,Helvetica,Arial">GAP</font> an algebra is naturally a vector space. Hence all the functionality
for vector spaces is also available for algebras.
<p>
<pre>
gap&gt; F:= GF(2);;
gap&gt; z:= Zero( F );;  o:= One( F );;
gap&gt; T:= EmptySCTable( 3, z, "antisymmetric" );;
gap&gt; SetEntrySCTable( T, 1, 2, [ o, 1, o, 3 ] );
gap&gt; SetEntrySCTable( T, 1, 3, [ o, 1 ] );
gap&gt; SetEntrySCTable( T, 2, 3, [ o, 3 ] );
gap&gt; A:= AlgebraByStructureConstants( F, T );
&lt;algebra of dimension 3 over GF(2)&gt;
gap&gt; Dimension( A );
3
gap&gt; LeftActingDomain( A );
GF(2)
gap&gt; Basis( A );
CanonicalBasis( &lt;algebra of dimension 3 over GF(2)&gt; )
</pre>
<p>
Subalgebras and ideals of an algebra can be constructed by specifying
a set of generators for the subalgebra or ideal. The quotient space
of an algebra by an ideal is naturally an algebra itself.
<p>
In the following example we temporarily increase the line length limit from
its default value 80 to 81 in order to make the long output expression fit
into one line.
<p>
<pre>
gap&gt; m:= [ [ 1, 2, 3 ], [ 0, 1, 6 ], [ 0, 0, 1 ] ];;
gap&gt; A:= Algebra( Rationals, [ m ] );;
gap&gt; subA:= Subalgebra( A, [ m-m^2 ] );
&lt;algebra over Rationals, with 1 generators&gt;
gap&gt; Dimension( subA );
2
gap&gt; SizeScreen([ 81, ]);;
gap&gt; idA:= Ideal( A, [ m-m^3 ] );
&lt;two-sided ideal in &lt;algebra of dimension 3 over Rationals&gt;, (1 generators)&gt;
gap&gt; SizeScreen([ 80, ]);;
gap&gt; Dimension( idA ); 
2
gap&gt; B:= A/idA;
&lt;algebra of dimension 1 over Rationals&gt;
</pre>
<p>
The call <code>B:= A/idA</code> creates a new algebra that does not ``know'' about
its connection with <code>A</code>. If we want to connect an algebra with its factor
via a homomorphism, then we first have to create the homomorphism
(<code>NaturalHomomorphismByIdeal</code>). After this we create the factor algebra 
from the homomorphism by the function <code>ImagesSource</code>. In the next example
we divide an algebra <code>A</code> by its radical and lift the central idempotents
of the factor to the original algebra <code>A</code>.
<p>
<pre>
gap&gt; m1:=[[1,0,0],[0,2,0],[0,0,3]];;
gap&gt; m2:=[[0,1,0],[0,0,2],[0,0,0]];;
gap&gt; A:= Algebra( Rationals, [ m1, m2 ] );;
gap&gt; Dimension( A );
6
</pre>
<p>
<pre>
gap&gt; R:= RadicalOfAlgebra( A );
&lt;algebra of dimension 3 over Rationals&gt;
gap&gt; h:= NaturalHomomorphismByIdeal( A, R );
&lt;linear mapping by matrix, &lt;algebra of dimension 
6 over Rationals&gt; -&gt; &lt;algebra of dimension 3 over Rationals&gt;&gt;
</pre>
<p>
<pre>
gap&gt; AmodR:= ImagesSource( h );
&lt;algebra of dimension 3 over Rationals&gt;
gap&gt; id:= CentralIdempotentsOfAlgebra( AmodR );
[ v.3, v.2+(-3)*v.3, v.1+(-2)*v.2+(3)*v.3 ]
gap&gt; PreImagesRepresentative( h, id[1] );
[ [ 0, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 1 ] ]
gap&gt; PreImagesRepresentative( h, id[2] );
[ [ 0, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 0 ] ]
gap&gt; PreImagesRepresentative( h, id[3] );
[ [ 1, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 0 ] ]
</pre>
<p>
Structure constants tables for the simple Lie algebras are present in <font face="Gill Sans,Helvetica,Arial">GAP</font>.
They can be constructed using the function <code>SimpleLieAlgebra</code>. The Lie 
algebras constructed by this function come with a root system attached.
<p>
<pre>
gap&gt; L:= SimpleLieAlgebra( "G", 2, Rationals );
&lt;Lie algebra of dimension 14 over Rationals&gt;
gap&gt; R:= RootSystem( L );
&lt;root system of rank 2&gt;
gap&gt; PositiveRoots( R );
[ [ 2, -1 ], [ -3, 2 ], [ -1, 1 ], [ 1, 0 ], [ 3, -1 ], [ 0, 1 ] ]
gap&gt; CartanMatrix( R );
[ [ 2, -1 ], [ -3, 2 ] ]
</pre>
<p>
Another example of algebras is provided by <strong>quaternion algebras</strong>.
We define a quaternion algebra over an extension field of the
rationals, namely the field generated by &#8730;5.
(The number <code>EB(5)</code> is equal to 1/2 (&#8722;1+&#8730;5).
The field is printed as <code>NF(5,[ 1, 4 ])</code>.)
<p>
<pre>
gap&gt; b5:= EB(5);
E(5)+E(5)^4
gap&gt; q:= QuaternionAlgebra( FieldByGenerators( [ b5 ] ) );
&lt;algebra-with-one of dimension 4 over NF(5,[ 1, 4 ])&gt;
gap&gt; gens:= GeneratorsOfAlgebra( q );
[ e, i, j, k ]
gap&gt; e:= gens[1];; i:= gens[2];; j:= gens[3];; k:= gens[4];;
gap&gt; IsAssociative( q );
true
gap&gt; IsCommutative( q );
false
gap&gt; i*j; j*i;
k
(-1)*k
gap&gt; One( q );
e
</pre>
<p>
If the coefficient field is a real subfield of the complex numbers
then the quaternion algebra is in fact a division ring.
<p>
<pre>
gap&gt; IsDivisionRing( q );
true
gap&gt; Inverse( e+i+j );
(1/3)*e+(-1/3)*i+(-1/3)*j
</pre>
<p>
So <font face="Gill Sans,Helvetica,Arial">GAP</font> knows about this fact.
As in any ring, we can look at groups of units.
(The function <code>StarCyc</code> used below computes the unique algebraic
conjugate of an element in a quadratic subfield of a cyclotomic field.)
<p>
<pre>
gap&gt; c5:= StarCyc( b5 );
E(5)^2+E(5)^3
gap&gt; g1:= 1/2*( b5*e + i - c5*j );
(1/2*E(5)+1/2*E(5)^4)*e+(1/2)*i+(-1/2*E(5)^2-1/2*E(5)^3)*j
gap&gt; Order( g1 );
5
gap&gt; g2:= 1/2*( -c5*e + i + b5*k );
(-1/2*E(5)^2-1/2*E(5)^3)*e+(1/2)*i+(1/2*E(5)+1/2*E(5)^4)*k
gap&gt; Order( g2 );
10
gap&gt; g:=Group( g1, g2 );;
#I  default `IsGeneratorsOfMagmaWithInverses' method returns `true' for 
[ (1/2*E(5)+1/2*E(5)^4)*e+(1/2)*i+(-1/2*E(5)^2-1/2*E(5)^3)*j, 
  (-1/2*E(5)^2-1/2*E(5)^3)*e+(1/2)*i+(1/2*E(5)+1/2*E(5)^4)*k ]
gap&gt; Size( g );
120
gap&gt; IsPerfect( g );
true
</pre>
<p>
Since there is only one perfect group of order 120, up to isomorphism,
we see that the group <code>g</code> is isomorphic to <i>SL</i><sub>2</sub>(5).
As usual, a permutation representation of the group can be constructed
using a suitable action of the group.
<p>
<pre>
gap&gt; cos:= RightCosets( g, Subgroup( g, [ g1 ] ) );;
gap&gt; Length( cos );
24
gap&gt; hom:= ActionHomomorphism( g, cos, OnRight );;
gap&gt; im:= Image( hom );
Group([ (2,3,5,9,15)(4,7,12,8,14)(10,17,23,20,24)(11,19,22,16,13), 
  (1,2,4,8,3,6,11,20,17,19)(5,10,18,7,13,22,12,21,24,15)(9,16)(14,23) ])
gap&gt; Size( im );
120
</pre>
<p>
To get a matrix representation of <code>g</code> or of the whole algebra <code>q</code>,
we must specify a basis of the vector space on which the algebra acts,
and compute the linear action of elements w.r.t. this basis.
<p>
<pre>
gap&gt; bas:= CanonicalBasis( q );;
gap&gt; BasisVectors( bas );
[ e, i, j, k ]
gap&gt; op:= OperationAlgebraHomomorphism( q, bas, OnRight );
&lt;op. hom. AlgebraWithOne( NF(5,[ 1, 4 ]), 
[ e, i, j, k ] ) -&gt; matrices of dim. 4&gt;
gap&gt; ImagesRepresentative( op, e );
[ [ 1, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 0, 0, 1 ] ]
gap&gt; ImagesRepresentative( op, i );
[ [ 0, 1, 0, 0 ], [ -1, 0, 0, 0 ], [ 0, 0, 0, -1 ], [ 0, 0, 1, 0 ] ]
gap&gt; ImagesRepresentative( op, g1 );
[ [ 1/2*E(5)+1/2*E(5)^4, 1/2, -1/2*E(5)^2-1/2*E(5)^3, 0 ], 
  [ -1/2, 1/2*E(5)+1/2*E(5)^4, 0, -1/2*E(5)^2-1/2*E(5)^3 ], 
  [ 1/2*E(5)^2+1/2*E(5)^3, 0, 1/2*E(5)+1/2*E(5)^4, -1/2 ], 
  [ 0, 1/2*E(5)^2+1/2*E(5)^3, 1/2, 1/2*E(5)+1/2*E(5)^4 ] ]
</pre>
<p>
<p>
<h2><a name="SECT003">6.3 Further Information about Vector Spaces and Algebras</a></h2>
<p><p>
More information about vector spaces can be found in
Chapter&nbsp;<a href="../ref/CHAP059.htm">Vector Spaces</a>.
Chapter&nbsp;<a href="../ref/CHAP060.htm">Algebras</a> deals with the functionality for general algebras.
Furthermore, concerning special functions for Lie algebras,
there is Chapter&nbsp;<a href="../ref/CHAP061.htm">Lie Algebras</a>.
<p>
<p>
[<a href="../index.htm">Top</a>] [<a href = "chapters.htm">Up</a>] [<a href ="CHAP005.htm">Previous</a>] [<a href ="CHAP007.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<P>
<font face="Gill Sans,Helvetica,Arial">GAP 4 manual<br>November 2006
</font></body></html>