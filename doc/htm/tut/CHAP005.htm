<html><head><title>[tut] 5 Groups and Homomorphisms</title></head>
<body text="#000000" bgcolor="#ffffff">
[<a href="../index.htm">Top</a>] [<a href = "chapters.htm">Up</a>] [<a href ="CHAP004.htm">Previous</a>] [<a href ="CHAP006.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<h1>5 Groups and Homomorphisms</h1><p>
<P>
<H3>Sections</H3>
<oL>
<li> <A HREF="CHAP005.htm#SECT001">Permutation groups</a>
<li> <A HREF="CHAP005.htm#SECT002">Actions of Groups</a>
<li> <A HREF="CHAP005.htm#SECT003">Subgroups as Stabilizers</a>
<li> <A HREF="CHAP005.htm#SECT004">Group Homomorphisms by Images</a>
<li> <A HREF="CHAP005.htm#SECT005">Nice Monomorphisms</a>
<li> <A HREF="CHAP005.htm#SECT006">Further Information about Groups and Homomorphisms</a>
</ol><p>
<p>
In this chapter we will show  some computations with groups. The examples
deal mostly with permutation groups, because they are the easiest 
to input.  The functions mentioned here, like <code>Group</code>, <code>Size</code> or
<code>SylowSubgroup</code>, however, are the same for all  kinds of groups, although
the algorithms which compute the information  of course will be different
in most cases.
<p>
<p>
<h2><a name="SECT001">5.1 Permutation groups</a></h2>
<p><p>
Permutation  groups  are so easy to  input  because their elements, i.e.,
permutations,  are  so easy to  type: they  are  entered and displayed in
disjoint cycle notation. So let's construct a permutation group:
<p>
<pre>
gap&gt; s8 := Group( (1,2), (1,2,3,4,5,6,7,8) );
Group([ (1,2), (1,2,3,4,5,6,7,8) ])
</pre>
<p>
We formed the group generated by the permutations <code>(1,2)</code> and
<code>(1,2,3,4,5,6,7,8)</code>, which is well known to be the symmetric group on
eight points, and assigned it to the identifier <code>s8</code>.  Now the group
<i>S</i><sub>8</sub> contains the alternating group on eight points which can be
described in several ways, e.g., as the group of all even permutations
in <code>s8</code>, or as its derived subgroup.
<p>
<pre>
gap&gt; a8 := DerivedSubgroup( s8 );
Group([ (1,2,3), (2,3,4), (2,4)(3,5), (2,6,4), (2,4)(5,7), (2,8,6,4)(3,5) ])
gap&gt; Size( a8 ); IsAbelian( a8 ); IsPerfect( a8 );
20160
false
true
</pre>
<p>
Once information about a group like <code>s8</code> or <code>a8</code> has been computed, it
is stored in the group so that  it can simply be looked  up when it is
required  again.   This holds for  all pieces   of  information in the
previous  example.  Namely,  <code>a8</code>  stores its  order and  that   it is
nonabelian  and perfect,  and <code>s8</code>  stores its  derived subgroup <code>a8</code>.
Had we computed <code>a8</code> as  <code>CommutatorSubgroup( s8,  s8 )</code>, however,  it
would not have been stored,  because it would  then have been computed
as a function of <strong>two</strong> arguments, and hence one could not attribute it
to just one of them. (Of course  the function <code>CommutatorSubgroup</code> can
compute the commutator  subgroup  of <strong>two</strong> arbitrary  subgroups.)  The
situation is  a bit  different for  Sylow  <var>p</var>-subgroups: The function
<code>SylowSubgroup</code> also  requires  two arguments,  namely a   group and a
prime <var>p</var>, but the result is  stored in the  group --- namely together
with the prime  <var>p</var> in a  list called <code>ComputedSylowSubgroups</code>, but we
won't dwell on the details here.
<p>
<pre>
gap&gt; syl2 := SylowSubgroup( a8, 2 );; Size( syl2 );
64
gap&gt; Normalizer( a8, syl2 ) = syl2;
true
gap&gt; cent := Centralizer( a8, Centre( syl2 ) );; Size( cent );
192
gap&gt; DerivedSeries( cent );; List( last, Size );
[ 192, 96, 32, 2, 1 ]
</pre>
<p>
We have typed double semicolons  after some commands  to avoid the output
of the  groups   (which would  be  printed  by their  generator   lists).
Nevertheless, the beginner  is  encouraged to   type  a single  semicolon
instead and study the full output. This  remark also applies for the rest
of this tutorial.
<p>
With the next  examples, we want  to calculate a  subgroup of <code>a8</code>, then
its  normalizer and finally determine the  structure of the extension. We
begin by forming a subgroup   generated by three commuting   involutions,
i.e., a subgroup  isomorphic to the   additive group of the  vector space
2<sup>3</sup>.
<p>
<pre>
gap&gt; elab := Group( (1,2)(3,4)(5,6)(7,8), (1,3)(2,4)(5,7)(6,8),
&gt;                   (1,5)(2,6)(3,7)(4,8) );;
gap&gt; Size( elab );
8
gap&gt; IsElementaryAbelian( elab );
true
</pre>
<p>
As usual, <font face="Gill Sans,Helvetica,Arial">GAP</font> prints the group by giving  all its generators. This can
be annoying, especially if there are many of them or  if they are of huge
degree. It also makes  it difficult to recognize  a particular group when
there already several  around. Note  that  although it is no  problem for
<strong>us</strong> to    specify a particular  group to   <font face="Gill Sans,Helvetica,Arial">GAP</font>, by  using well-chosen
identifiers such as <code>a8</code>  and <code>elab</code>, it is  impossible for <font face="Gill Sans,Helvetica,Arial">GAP</font> to use
these identifiers when printing  a group for us,  because the group  does
not know which identifier(s) point  to it, in fact  there can be several.
In order to    give a name  to  the  group  itself (rather   than  to the
identifier), you have to use the function <code>SetName</code>.  We do this with the
name <code>2^3</code> here which reflects  the mathematical properties of the group.
From now on,  <font face="Gill Sans,Helvetica,Arial">GAP</font> will use  this name when  printing the group for us,
but we still cannot use this name to specify the group to <font face="Gill Sans,Helvetica,Arial">GAP</font>, because
the name does  not know to which group   it was assigned (after  all, you
could assign the   same  name to several  groups).  When  talking  to the
computer, you must always use identifiers.
<p>
<pre>
gap&gt; SetName( elab, "2^3" ); elab;
2^3
gap&gt; norm := Normalizer( a8, elab );; Size( norm );
1344
</pre>
<p>
<a name = "I0"></a>

Now that  we  have the subgroup <code>norm</code>   of order 1344   and its subgroup
<code>elab</code>, we want to look  at its factor  group. But since  we also want to
find preimages of factor group elements in <code>norm</code>, we really want to look
at the  <strong>natural homomorphism</strong> defined on  <code>norm</code> with  kernel <code>elab</code> and
whose image is the factor group.
<p>
<pre>
gap&gt; hom := NaturalHomomorphismByNormalSubgroup( norm, elab );
&lt;action epimorphism&gt;
gap&gt; f := Image( hom );
Group([ (), (), (), (4,5)(6,7), (4,6)(5,7), (2,3)(6,7), (2,4)(3,5), 
  (1,2)(5,6) ])
gap&gt; Size( f );
168
</pre>
<p>
The factor group  is again represented as  a  permutation group. However,
the action domain  of this factor  group has  nothing  to do with  the
action domain of <code>norm</code>. (It only happens that both are subsets of the
natural numbers.) We can now form  images and preimages under the natural
homomorphism. The set of  preimages of an element under  <code>hom</code> is a coset
modulo <code>elab</code>. We use the function  <code>PreImages</code> here because <code>hom</code> is not
a bijection, so an  element of the range can   have several preimages  or
none at all.
<p>
<pre>
gap&gt; ker:= Kernel( hom );
2^3
gap&gt; x := (1,8,3,5,7,6,2);; Image( hom, x );
(1,7,5,6,2,3,4)
gap&gt; coset := PreImages( hom, last );
RightCoset(2^3,(2,8,6,7,3,4,5))
</pre>
<p>
Note that <font face="Gill Sans,Helvetica,Arial">GAP</font> is free to choose any representative for the coset
of preimages.
Of course the quotient of two representatives lies in the kernel of
the homomorphism.
<p>
<pre>
gap&gt; rep:= Representative( coset );
(2,8,6,7,3,4,5)
gap&gt; x * rep^-1 in ker;
true
</pre>
<p>
The factor  group <code>f</code>  is  a simple  group,  i.e., it has  no non-trivial
normal subgroups. <font face="Gill Sans,Helvetica,Arial">GAP</font> can detect this fact,  and it can then also find
the name by which this simple group is known among group theorists. (Such
names are of course not available for non-simple groups.)
<p>
<pre>
gap&gt; IsSimple( f ); IsomorphismTypeInfoFiniteSimpleGroup( f );
true
rec( series := "L", parameter := [ 2, 7 ], 
  name := "A(1,7) = L(2,7) ~ B(1,7) = O(3,7) ~ C(1,7) = S(2,7) ~ 2A(1,7) = U(2\
,7) ~ A(2,2) = L(3,2)" )
gap&gt; SetName( f, "L_3(2)" );
</pre>
<p>
We give <code>f</code> the name  <code>L_3(2)</code> because the  last part of the name  string
reveals that  it is isomorphic to  the simple linear group <i>L</i><sub>3</sub>(2). This
group, however, also has a  lot of other  names. Names that are connected
with a  <code>=</code> sign  are different names   for the same matrix group,  e.g.,
<code>A(2,2)</code> is the  Lie type notation for  the  classical notation <code>L(3,2)</code>.
Other pairs  of  names are  connected via <code>&nbsp;</code>,  these then  specify other
classical  groups  that are isomorphic  to that  linear  group (e.g., the
symplectic group <code>S(2,7)</code>, whose Lie type notation would be <code>C(1,7)</code>).
<p>
The group <code>norm</code> acts on the eight elements of its normal subgroup <code>elab</code>
by conjugation,  yielding  a representation   of <i>L</i><sub>3</sub>(2) in   <code>s8</code> which
leaves one    point  fixed  (namely  point&nbsp;<code>1</code>).    The   image of   this
representation can be computed with the function  <code>Action</code>; it is even
contained  in the group <code>norm</code> and  we can show  that <code>norm</code>  is indeed a
split extension of the elementary abelian group 2<sup>3</sup>  with this image of
<i>L</i><sub>3</sub>(2).
<p>
<pre>
gap&gt; op := Action( norm, elab );
Group([ (), (), (), (5,6)(7,8), (5,7)(6,8), (3,4)(7,8), (3,5)(4,6), 
  (2,3)(6,7) ])
gap&gt; IsSubgroup( a8, op ); IsSubgroup( norm, op );
true
true
gap&gt; IsTrivial( Intersection( elab, op ) );
true
gap&gt; SetName( norm, "2^3:L_3(2)" );
</pre>
<p>
By the way, you should not try the operator <code>&lt;</code>  instead of the function
<code>IsSubgroup</code>. Something like
<p>
<pre>
gap&gt; elab &lt; a8;
false
</pre>
<p>
will not cause an error, but the result does not signify anything about the
inclusion of one group in another; <code>&lt;</code> tests  which of the two groups is
less in some total order. On the other hand, the equality operator <code>=</code> in
fact does test the equality of its arguments.
<p>
<hr>Summary.   In  this section   we have   used   the elementary group
functions to determine  the structure of  a normalizer. We have  assigned
names  to the involved groups which  reflect their mathematical structure
and <font face="Gill Sans,Helvetica,Arial">GAP</font> uses these names when printing the groups.
<p>
<p>
<h2><a name="SECT002">5.2 Actions of Groups</a></h2>
<p><p>
In  order to get  another  representation  of  <code>a8</code>, we consider  another
action, namely  that on  the elements   of a  certain conjugacy  class by
conjugation.
<p>
In the following example we temporarily increase the line length limit
from its default value 80 to 82 in order to make the long expression fit
into one line.
<p>
<pre>
gap&gt; ccl := ConjugacyClasses( a8 );; Length( ccl );
14
gap&gt; List( ccl, c -&gt; Order( Representative( c ) ) );
[ 1, 2, 2, 3, 6, 3, 4, 4, 5, 15, 15, 6, 7, 7 ]
gap&gt; SizeScreen([ 82, ]);;
gap&gt; List( ccl, Size );
[ 1, 210, 105, 112, 1680, 1120, 2520, 1260, 1344, 1344, 1344, 3360, 2880, 2880 ]
gap&gt; SizeScreen([ 80, ]);;
</pre>
<p>
Note  the  difference between <code>Order</code>  (which   means the element order),
<code>Size</code> (which means the size of the conjugacy  class) and <code>Length</code> (which
means the length of  a list). We choose to  let <code>a8</code> operate on the class
of length&nbsp;112.
<p>
<pre>
gap&gt; class := First( ccl, c -&gt; Size(c) = 112 );;
gap&gt; op := Action( a8, AsList( class ) );;
</pre>
<p>
We use <code>AsList</code> here  to convert the conjugacy class  into a list  of its
elements whereas we   wrote  <code>Action( norm,  elab )</code>   directly in the
previous section. The reason is that  the elementary abelian group <code>elab</code>
can  be quickly enumerated by   <font face="Gill Sans,Helvetica,Arial">GAP</font>  whereas the standard  enumeration
method for conjugacy classes is  slower than just explicit calculation of
the elements. However, <font face="Gill Sans,Helvetica,Arial">GAP</font> is reluctant  to construct explicit element
lists, because for really large groups this direct method is infeasible.
<p>
Note also  the function <code>First</code>, used to  find the  first element in a
list which  passes some test. See  <a href="../ref/CHAP021.htm#SSEC020.20">First</a> in the reference manual
for more details.
<p>
We now have a permutation representation <code>op</code> on 112 points, which we
test for primitivity. If it is not primitive, we can obtain a minimal
block system (i.e., one where the blocks have minimal length) by the
function <code>Blocks</code>.
<p>
<pre>
gap&gt; IsPrimitive( op, [ 1 .. 112 ] );
false
gap&gt; blocks := Blocks( op, [ 1 .. 112 ] );;
</pre>
<p>
Note that we  must specify the domain  of the action. You  might think
that the   functions <code>IsPrimitive</code> and <code>Blocks</code>  could  use <code>[1..112]</code> as
default  domain if no  domain was  given. But  this  is not so  easy, for
example  would the default domain  of <code>Group(  (2,3,4)  )</code> be <code>[1..4]</code> or
<code>[2..4]</code>? To  avoid confusion, all action  functions  require that you
specify  the domain of action. If  we had specified  <code>[1..113]</code> in the
primitivity test above,  point&nbsp;113  would have been  a fixpoint  (and the
action would not even have been transitive).
<p>
Now <code>blocks</code> is a list of blocks (i.e., a list of lists), which we do not
print  here for the  sake of saving paper (try  it for yourself). In fact
all we want to know is the size of  the blocks, or  rather how many there
are (the product of these two numbers must of course be&nbsp;112). Then we can
obtain a new  permutation group  of the  corresponding  degree by letting
<code>op</code> act on these blocks setwise.
<p>
<pre>
gap&gt; Length( blocks[1] );  Length( blocks );
2
56
gap&gt; op2 := Action( op, blocks, OnSets );;
gap&gt; IsPrimitive( op2, [ 1 .. 56 ] );
true
</pre>
<p>
Note that we give a third argument (the action function <code>OnSets</code>) to
indicate that the action is not the default action on points but an
action on sets of elements given as sorted lists.
(Section&nbsp;<a href="../ref/CHAP039.htm#SECT002">Basic Actions</a> of the reference manual lists all
actions that are pre-defined by <font face="Gill Sans,Helvetica,Arial">GAP</font>.)
<p>
The action of <code>op</code> on the given block system gave us a new representation
on 56 points which is primitive, i.e., the  point stabilizer is a maximal
subgroup. We  compute its preimage in the  representation on eight points
using the   associated   action homomorphisms (which   of   course are
monomorphisms). We construct  the  composition of two  homomorphisms with
the <code>*</code> operator, reading left-to-right.
<p>
<pre>
gap&gt; ophom := ActionHomomorphism( a8, op );;
gap&gt; ophom2 := ActionHomomorphism( op, op2 );;
gap&gt; composition := ophom * ophom2;;
gap&gt; stab := Stabilizer( op2, 2 );;
gap&gt; preim := PreImages( composition, stab );
Group([ (1,4,2), (3,6,7), (3,8,5,7,6), (1,4)(7,8) ])
</pre>
<p>
The normalizer of an element in the conjugacy class <code>class</code> is a group of
order 360, too. In fact, it is a conjugate of the maximal subgroup we had
found before, and a conjugating element in <code>a8</code>  is found by the function
<code>RepresentativeAction</code>.
<p>
<pre>
gap&gt; sgp := Normalizer( a8, Subgroup(a8,[Representative(class)]) );;
gap&gt; Size( sgp );
360
gap&gt; RepresentativeAction( a8, sgp, preim );
(3,4)(7,8)
</pre>
<p>
<a name = "I1"></a>

<a name = "I1"></a>
<a name = "I2"></a>

<a name = "I1"></a>
<a name = "I2"></a>
<a name = "I3"></a>

So far we have seen  a few applications  of the functions <code>Action</code> and
<code>ActionHomomorphism</code>. But perhaps even  more  interesting is the  fact
that  the  natural  homomorphism <code>hom</code>   constructed  above  is  also  an
<strong>action  homomorphism</strong>;  this  is also  the  reason  why its image  is
represented as a permutation group:  it is the natural representation for
actions. We will now look at this action homomorphism again to find
out on what   objects it  operates.  These  objects  form the   so-called
<strong>external set</strong> which is  associated with every action homomorphism. We
will  mention  external sets  only   superficially in this  tutorial, for
details see <a href="../ref/CHAP039.htm#SECT011">External Sets</a> in the  reference manual. For the moment,
we need   only know that   the external set is  obtained  by the function
<code>UnderlyingExternalSet</code>.
<p>
<pre>
gap&gt; t := UnderlyingExternalSet( hom );
&lt;xset:RightTransversal(2^3:L_3(2),Group(
[ (1,5)(2,6)(3,7)(4,8), (1,3)(2,4)(5,7)(6,8), (1,2)(3,4)(5,6)(7,8), 
  (5,6)(7,8), (5,7)(6,8), (3,4)(7,8), (3,5)(4,6) ]))&gt;
</pre>
<p>
<a name = "I4"></a>

For  the   natural homomorphism   <code>hom</code> the  external   set  is a  <strong>right
transversal</strong> of a subgroup  <var>U</var>   in <code>norm</code>,  and   action on the   right
transversal really means action  on the cosets  of the subgroup <var>U</var>. When
executing  the function  call <code>NaturalHomomorphismByNormalSubgroup( norm,
elab )</code>, <font face="Gill Sans,Helvetica,Arial">GAP</font> has  chosen a subgroup  <var>U</var> for which  the kernel of this
action (i.e., the core of  <var>U</var> in <code>norm</code>)  is the desired normal subgroup
<code>elab</code>. For the purpose of operating on the cosets, the right transversal
<code>t</code> contains  one representative  from each coset  of <var>U</var>.  Regarded this
way, a transversal  is simply a list of  group elements, and you can make
<font face="Gill Sans,Helvetica,Arial">GAP</font> produce this list by <code>AsList(t)</code>. (Try it.)
<p>
The  image of  such   a   representative from  <code>AsList(t)</code> under    right
multiplication with an  element  from <code>norm</code>  will in general  not be  in
<code>AsList(t)</code>,  because it will   not  be among the  chosen representatives
again.   Hence right multiplication is not   an action on <code>AsList(t)</code>.
However, <font face="Gill Sans,Helvetica,Arial">GAP</font> uses a special trick to be discussed below to make this a
well-defined  action  on the  cosets   represented by the  elements of
<code>AsList(t)</code>. For now, it is important  to know that  the external set <code>t</code>
is   more  than just the  right  transversal  on  which  the group <code>norm</code>
operates. Altogether three things  are necessary to specify an action:
a  group&nbsp;<var>G</var>, a  set&nbsp;<var>D</var>, and a   function <i>opr</i> :<i>D</i> &times;<i>G</i> &#8594; <i>D</i> . We can access these ingredients with the following functions:
<p>
<pre>
gap&gt; ActingDomain(t);  # the group
2^3:L_3(2)
gap&gt; Enumerator(t);
RightTransversal(2^3:L_3(2),Group(
[ (1,5)(2,6)(3,7)(4,8), (1,3)(2,4)(5,7)(6,8), (1,2)(3,4)(5,6)(7,8), 
  (5,6)(7,8), (5,7)(6,8), (3,4)(7,8), (3,5)(4,6) ]))
gap&gt; FunctionAction(t);
function( pnt, elm ) ... end
gap&gt; NameFunction( last );
"OnRight"
</pre>
<p>
The function  which   is  named  <code>"OnRight"</code>  is  also   assigned to  the
identifier <code>OnRight</code>, and it means multiplication from the right; this is
the usual way to operate on a right transversal. <code>OnRight( </code><var>d</var><code>, </code><var>g</var><code> )</code> is
defined as <code></code><var>d</var><code> * </code><var>g</var><code></code>.
<p>
<a name = "I5"></a>

Observe  that the external set <code>t</code>  and  its <code>Enumerator</code> are printed the
same way, but  be aware that an   external set also comprises  the acting
domain  and the action function.  The  <code>Enumerator</code> itself, i.e.,  the
right transversal, in turn comprises knowledge about the group <code>norm</code> and
the  subgroup <var>U</var>,  and  this is what  allows  the special trick promised
above. As far as <code>Position</code> is  concerned, the <code>Enumerator</code> behaves as an
(immutable) list and you can ask for the position of an element in it.
<p>
<pre>
gap&gt; elm := (1,4)(2,7)(3,6)(5,8);;
gap&gt; Position( Enumerator(t), elm );
fail
gap&gt; PositionCanonical( Enumerator(t), elm );
5
</pre>
<p>
<a name = "I6"></a>

The result <code>fail</code>   means that the element was   not found at  all in the
list: it is not among the chosen  representatives. The difference between
the functions <code>Position</code> and <code>PositionCanonical</code> is that the first simply
looks whether <code>elm</code> is contained among the representatives which together
form the  right transversal <code>t</code>, whereas  the second really looks for the
position of the  coset described by  the  representative <code>elm</code>. In  other
words, it first replaces <code>elm</code> by a  canonical representative of the same
coset (which must be contained in <code>Enumerator(t)</code>) and then looks for its
position, hence the name. The  function <code>ActionHomomorphism</code> (and  its
relatives) always use  <code>PositionCanonical</code> when they calculate the images
of   the  generators of  the    source  group (here,  <code>norm</code>)   under the
homomorphism  (here, <code>hom</code>).  Therefore  they  can  give a   well-defined
action on an   <var>enumerator</var>, even   if the   action  would not   be
well-defined on <code>AsList( </code><var>enumerator</var><code> )</code>.
<p>
The image of  the natural homomorphism  is the permutation group <code>f</code> that
results from the action of <code>norm</code> on the right  transversal. It can be
calculated by either of the following commands. The second of them shows
that the external set <code>t</code> contains all information  that is necessary for
<code>Action</code> to do its work.
<p>
<pre>
gap&gt; Action( norm, Enumerator(t), OnRight ) = f;
true
gap&gt; Action( t ) = f;
true
</pre>
<p>
We  have specified the action function  <code>OnRight</code> in this example, but
we have seen  examples like <code>Action( norm,  elab )</code> earlier where this
third argument was not given. If an action function is omitted, <font face="Gill Sans,Helvetica,Arial">GAP</font>
always assumes <code>OnPoints</code> which is defined as <code>OnPoints( </code><var>d</var><code>, </code><var>g</var><code> ) = </code><var>d</var><code>
^ </code><var>g</var><code></code>. This ``caret''  operator denotes conjugation in  a group if  both
arguments <var>d</var> and  <var>g</var> are group elements  (contained in a common group),
but it also  denotes the natural  action  of permutations on  positive
integers (and exponentiation of integers as well, of course).
<p>
<hr>Summary. In this section we have learned  how groups can operate on
<font face="Gill Sans,Helvetica,Arial">GAP</font>   objects such as  integers  and   group  elements.  We  have used
<code>ActionHomomorphism</code>,    among   others,   to   construct   a  natural
homomorphism,  in which case the  group operated on the right transversal
of a suitable subgroup. This right transversal gave us an example for the
use of <code>PositionCanonical</code>, which allowed  us to specify cosets by giving
representatives.
<p>
<p>
<h2><a name="SECT003">5.3 Subgroups as Stabilizers</a></h2>
<p><p>
Action functions can also be  used without constructing external sets.
We will try to   find several subgroups  in <code>a8</code>  as stabilizers of  such
actions. One subgroup is immediately  available, namely the stabilizer
of one point. The index of the stabilizer must of course  be equal to the
length of the orbit, i.e.,&nbsp;8.
<p>
<pre>
gap&gt; u8 := Stabilizer( a8, 1 );
Group([ (2,3,4), (2,4)(3,5), (2,6,4), (2,4)(5,7), (2,8,6,4)(3,5) ])
gap&gt; Index( a8, u8 );
8
gap&gt; Orbit( a8, 1 ); Length( last );
[ 1, 3, 2, 4, 5, 6, 7, 8 ]
8
</pre>
<p>
This gives us a hint how to find further  subgroups. Each subgroup is the
stabilizer of a point of an appropriate  transitive action (namely the
action  on  the cosets of that  subgroup  or another action that is
equivalent to  this action).  So the question   is how  to find  other
actions. The obvious thing is to operate  on pairs of points. So using
the function <code>Tuples</code> we first generate a list of all pairs.
<p>
<pre>
gap&gt; pairs := Tuples( [1..8], 2 );;
</pre>
<p>
Now we would like to have <code>a8</code> operate on this  domain. But we cannot use
the  default action <code>OnPoints</code>  because    <code></code><var>list</var><code> ^ </code><var>perm</var><code></code> is    not
defined. So we  must tell the functions  from the actions package  how
the group elements operate on the elements of  the domain. In our example
we can do this by simply passing <code>OnPairs</code> as an optional last argument.
All functions from the actions package accept such an optional argument
that describes the action. One example is <code>IsTransitive</code>.
<p>
<pre>
gap&gt; IsTransitive( a8, pairs, OnPairs );
false
</pre>
<p>
The action is of course not transitive, since the pairs <code>[ 1, 1 ]</code> and
<code>[ 1, 2 ]</code> cannot lie in the same orbit.
So we want to  find out what the orbits are.
The function <code>Orbits</code> does that for us.
It returns a list of all the orbits.
We look at the orbit lengths and representatives for the orbits.
<p>
<pre>
gap&gt; orbs := Orbits( a8, pairs, OnPairs );; Length( orbs );
2
gap&gt; List( orbs, Length );
[ 8, 56 ]
gap&gt; List( orbs, o -&gt; o[1] );
[ [ 1, 1 ], [ 1, 2 ] ]
</pre>
<p>
The action of <code>a8</code>   on the first  orbit (this  is the one  containing
<code>[1,1]</code>, try <code>[1,1] in orbs[1]</code>) is of  course equivalent to the original
action, so we ignore it and work with the second orbit.
<p>
<pre>
gap&gt; u56 := Stabilizer( a8, orbs[2][1], OnPairs );; Index( a8, u56 );
56
</pre>
<p>
So   now   we have  found   a  second subgroup.   To   make the following
computations a little bit easier and more efficient  we would now like to
work on the points <code>[1..56]</code>  instead of the list  of pairs. The function
<code>ActionHomomorphism</code> does what  we need.   It creates a   homomorphism
defined on <code>a8</code> whose image is a new group  that operates on <code>[1..56]</code> in
the same way that <code>a8</code> operates on the second orbit.
<p>
<pre>
gap&gt; h56 := ActionHomomorphism( a8, orbs[2], OnPairs );;
gap&gt; a8_56 := Image( h56 );;
</pre>
<p>
We would now like to know if the subgroup <code>u56</code> of index 56 that we found
is  maximal or  not.
As we have used already in Section&nbsp;<a href="CHAP005.htm#SECT002">Actions of groups</a>,
a subgroup is maximal if and only if the action on the cosets of this
subgroup is primitive.
<p>
<pre>
gap&gt; IsPrimitive( a8_56, [1..56] );
false
</pre>
<p>
Remember that we  can leave out the  function  if we mean  <code>OnPoints</code> but
that we have to specify the action domain for all action functions.
<p>
We see that <code>a8_56</code>   is not primitive. This  means  of course   that the
action  of <code>a8</code>  on  <code>orb[2]</code>  is not  primitive,  because those   two
actions are equivalent. So the stabilizer <code>u56</code> is not maximal. Let us
try to find its supergroups. We use the function <code>Blocks</code> to find a block
system. The  (optional) third  argument  in the following   example tells
<code>Blocks</code> that we want a block system where 1 and 14 lie in one block.
<p>
<pre>
gap&gt; blocks := Blocks( a8_56, [1..56], [1,14] );
[ [ 1, 3, 4, 5, 6, 14, 31 ], [ 2, 13, 15, 16, 17, 23, 24 ], 
  [ 7, 8, 22, 34, 37, 47, 49 ], [ 9, 11, 18, 20, 35, 38, 48 ], 
  [ 10, 25, 26, 27, 32, 39, 50 ], [ 12, 28, 29, 30, 33, 36, 40 ], 
  [ 19, 21, 42, 43, 45, 46, 55 ], [ 41, 44, 51, 52, 53, 54, 56 ] ]
</pre>
<p>
The result is a list  of sets, such that  <code>a8_56</code> operates on those sets.
Now we would like  the stabilizer of this  action on the sets. Because
we  want to operate on   the sets we  have  to  pass <code>OnSets</code> as  third
argument.
<p>
<pre>
gap&gt; u8_56 := Stabilizer( a8_56, blocks[1], OnSets );;
gap&gt; Index( a8_56, u8_56 );
8
gap&gt; u8b := PreImages( h56, u8_56 );; Index( a8, u8b );
8
gap&gt; IsConjugate( a8, u8, u8b );
true
</pre>
<p>
So we have found a supergroup of <code>u56</code> that is conjugate in <code>a8</code> to <code>u8</code>.
This is not surprising, since <code>u8</code> is a point stabilizer, and <code>u56</code> is a
two point stabilizer in the natural action of <code>a8</code> on eight points.
<p>
Here  is a <strong>warning</strong>:   If you specify <code>OnSets</code>  as  third argument  to a
function like  <code>Stabilizer</code>, you have to  make sure that the  point (i.e.
the second argument) is  indeed a set. Otherwise you  will get a puzzling
error message or  even  wrong results! In  the above  example, the second
argument  <code>blocks[1]</code>  came from the  function  <code>Blocks</code>, which returns a
list of sets, so everything was OK.
<p>
Actually there  is a third  block system of <code>a8_56</code>  that gives rise to a
third subgroup.
<p>
<pre>
gap&gt; blocks := Blocks( a8_56, [1..56], [1,13] );;
gap&gt; u28_56 := Stabilizer( a8_56, [1,13], OnSets );;
gap&gt; u28 := PreImages( h56, u28_56 );;
gap&gt; Index( a8, u28 );
28
</pre>
<p>
We know that  the subgroup <code>u28</code> of index  28 is maximal, because we know
that  <code>a8</code> has no  subgroups  of index 2,  4,  or 7.  However we can also
quickly verify this by checking  that <code>a8_56</code> operates primitively on the
28 blocks.
<p>
<pre>
gap&gt; IsPrimitive( a8_56, blocks, OnSets );
true
</pre>
<p>
<code>Stabilizer</code> is not only applicable to groups like <code>a8</code> but also to their
subgroups like  <code>u56</code>. So another  method  to find  a  new subgroup is to
compute the stabilizer of another point in <code>u56</code>. Note that <code>u56</code> already
leaves 1 and 2 fixed.
<p>
<pre>
gap&gt; u336 := Stabilizer( u56, 3 );;
gap&gt; Index( a8, u336 );
336
</pre>
<p>
Other  functions  are also applicable  to  subgroups. In the following we
show that  <code>u336</code> operates regularly on the  60&nbsp;triples of <code>[4..8]</code> which
contain no element twice. We  constuct the list  of these 60&nbsp;triples with
the function <code>Orbit</code> (using <code>OnTuples</code>  as the natural generalization  of
<code>OnPairs</code>)  and   then  pass it   as  action domain  to   the function
<code>IsRegular</code>.  The positive result of  the regularity test means that this
action is equivalent  to the actions of <code>u336</code>  on  its 60 elements
from the right.
<p>
<pre>
gap&gt; IsRegular( u336, Orbit( u336, [4,5,6], OnTuples ), OnTuples );
true
</pre>
<p>
Just as we did in the  case of the  action on the  pairs above, we now
construct a new permutation group that operates on <code>[1..336]</code> in the same
way that <code>a8</code> operates on the cosets of <code>u336</code>. But this time we let <code>a8</code>
operate  on a right   transversal, just like  <code>norm</code>  did in  the natural
homomorphism above.
<p>
<pre>
gap&gt; t := RightTransversal( a8, u336 );;
gap&gt; a8_336 := Action( a8, t, OnRight );;
</pre>
<p>
To find  subgroups above <code>u336</code> we again look for nontrivial block systems.
<p>
<pre>
gap&gt; blocks := Blocks( a8_336, [1..336] );; blocks[1];
[ 1, 43, 85 ]
</pre>
<p>
We see that the union of <code>u336</code> with its 43rd and its 85th coset
is a subgroup in <code>a8_336</code>, its index is 112.
We can obtain it as the closure of <code>u336</code> with a representative
of the  43rd coset, which can be found as the 43rd element
of the transversal&nbsp;<code>t</code>.
Note that in the representation <code>a8_336</code> on 336 points,
this subgroup corresponds to the stabilizer of the block <code>[ 1, 43, 85 ]</code>.
<p>
<pre>
gap&gt; u112 := ClosureGroup( u336, t[43] );;
gap&gt; Index( a8, u112 );
112
</pre>
<p>
Above this subgroup of index 112 lies a  subgroup  of index 56, which  is
not conjugate to <code>u56</code>.  In fact, unlike <code>u56</code> it is  maximal.  We obtain
this subgroup in  the same way that we obtained <code>u112</code>, this time forcing
two points, namely 7 and 43 into the first block.
<p>
<pre>
gap&gt; blocks := Blocks( a8_336, [1..336], [1,7,43] );;
gap&gt; Length( blocks );
56
gap&gt; u56b := ClosureGroup( u112, t[7] );; Index( a8, u56b );
56
gap&gt; IsPrimitive( a8_336, blocks, OnSets );
true
</pre>
<p>
We  already mentioned  in Section&nbsp;<a href="CHAP005.htm#SECT002">Actions of groups</a>
that there is another  standard
action of permutations, namely the  conjugation.
E.g., since no  other action is specified  in the  following example,
<code>OrbitLength</code> simply operates via <code>OnPoints</code>,
and because <code><i>perm</i> <sub>1</sub> ^ <i>perm</i> <sub>2</sub></code> is defined as the conjugation
of <i>perm</i><sub>2</sub> on <i>perm</i><sub>1</sub>, in fact we compute the length of
the conjugacy class of <code>(1,2)(3,4)(5,6)(7,8)</code>.
<p>
<pre>
gap&gt; OrbitLength( a8, (1,2)(3,4)(5,6)(7,8) );
105
gap&gt; orb := Orbit( a8, (1,2)(3,4)(5,6)(7,8) );;
gap&gt; u105 := Stabilizer( a8, (1,2)(3,4)(5,6)(7,8) );; Index( a8, u105 );
105
</pre>
<p>
Note that although the length of a conjugacy class of any element <var>elm</var>
in any finite group <var>G</var> can be computed as <code>OrbitLength( </code><var>G</var><code>, </code><var>elm</var><code> )</code>,
the command <code>Size( ConjugacyClass( </code><var>G</var><code>, </code><var>elm</var><code> ) )</code> is probably more
efficient.
<p>
<pre>
gap&gt; Size( ConjugacyClass( a8, (1,2)(3,4)(5,6)(7,8) ) );
105
</pre>
<p>
Of course the stabilizer <code>u105</code> is in fact the centralizer of the element
<code>(1,2)(3,4)(5,6)(7,8)</code>.  <code>Stabilizer</code> notices    that and computes    the
stabilizer using the centralizer algorithm for permutation groups. In the
usual way we now look for the subgroups above <code>u105</code>.
<p>
<pre>
gap&gt; blocks := Blocks( a8, orb );; Length( blocks );
15
gap&gt; blocks[1];
[ (1,2)(3,4)(5,6)(7,8), (1,3)(2,4)(5,7)(6,8), (1,4)(2,3)(5,8)(6,7), 
  (1,5)(2,6)(3,7)(4,8), (1,6)(2,5)(3,8)(4,7), (1,7)(2,8)(3,5)(4,6), 
  (1,8)(2,7)(3,6)(4,5) ]
</pre>
<p>
To find the subgroup of index 15 we  again use closure. Now  we must be a
little bit  careful to avoid    confusion. <code>u105</code> is the  stabilizer   of
<code>(1,2)(3,4)(5,6)(7,8)</code>. We  know  that there is  a correspondence between
the  points  of  the   orbit and  the   cosets  of  <code>u105</code>.   The   point
<code>(1,2)(3,4)(5,6)(7,8)</code> corresponds   to <code>u105</code>.
To get the subgroup above <code>u105</code> that has index 15 in <code>a8</code>,
we must form the closure of <code>u105</code> with an element of the coset that
corresponds to any other point in the first block.
If we choose the point <code>(1,3)(2,4)(5,8)(6,7)</code>,
we must use an element of <code>a8</code> that maps <code>(1,2)(3,4)(5,6)(7,8)</code> to
<code>(1,3)(2,4)(5,8)(6,7)</code>.
The function <code>RepresentativeAction</code> does what we need.
It takes a group and two points and returns an element of the group
that maps the first point to the second.
In fact it also allows you to specify the action as an optional fourth
argument as usual, but we do not need this here.
If no such element exists in the  group, i.e., if the two points do not
lie in one orbit under the group,
<code>RepresentativeAction</code> returns <code>fail</code>.
<p>
<pre>
gap&gt; rep := RepresentativeAction( a8, (1,2)(3,4)(5,6)(7,8),
&gt;                                        (1,3)(2,4)(5,8)(6,7) );
(2,3)(6,8)
gap&gt; u15 := ClosureGroup( u105, rep );; Index( a8, u15 );
15
</pre>
<p>
<code>u15</code> is of course a maximal  subgroup, because <code>a8</code>  has no subgroups of
index 3 or&nbsp;5.  There is in fact  another  class of subgroups  of index 15
above <code>u105</code> that we get by adding <code>(2,3)(6,7)</code> to <code>u105</code>.
<p>
<pre>
gap&gt; u15b := ClosureGroup( u105, (2,3)(6,7) );; Index( a8, u15b );
15
gap&gt; RepresentativeAction( a8, u15, u15b );
fail
</pre>
<p>
<code>RepresentativeAction</code> tells us that  there is no  element <var>g</var> in <code>a8</code>
such that <code>u15 ^ </code><var>g</var><code> = u15b</code>. Because <code>^</code> also denotes the conjugation of
subgroups this tells us  that  <code>u15</code> and  <code>u15b</code> are not  conjugate.
<p>
<hr>Summary. In this section we  have demonstrated some functions from
the actions package. There  is a whole class of  functions that we did
not mention, namely  those that take a  single element instead of a whole
group as first argument, e.g., <code>Cycle</code> and <code>Permutation</code>. These are fully
described  in Chapter <a href="../ref/CHAP039.htm">Group Actions</a>  in the  reference
manual.
<p>
<p>
<h2><a name="SECT004">5.4 Group Homomorphisms by Images</a></h2>
<p><p>
We   have already  seen  examples of   group homomorphisms  in  the  last
sections,  namely natural homomorphisms  and  action homomorphisms. In
this section we will show how to construct a  group homomorphism <i>G</i>&#8594; <i>H</i>
by specifying a generating set for <i>G</i> and the images of these generators
in&nbsp;<i>H</i>. We use the function <code>GroupHomomorphismByImages( </code><var>G</var><code>, </code><var>H</var><code>, </code><var>gens</var><code>,
</code><var>imgs</var><code> )</code> where <var>gens</var> is a  generating set for <var>G</var> and  <var>imgs</var> is a list
whose <i>i</i>th entry is the image of <code></code><var>gens</var><code>[ <i>i</i> ]</code> under the homomorphism.
<p>
<pre>
gap&gt; s4 := Group((1,2,3,4),(1,2));; s3 := Group((1,2,3),(1,2));;
gap&gt; hom := GroupHomomorphismByImages( s4, s3,
&gt;           GeneratorsOfGroup(s4), [(1,2),(2,3)] );
[ (1,2,3,4), (1,2) ] -&gt; [ (1,2), (2,3) ]
gap&gt; Kernel( hom );
Group([ (1,4)(2,3), (1,3)(2,4) ])
gap&gt; Image( hom, (1,2,3) );
(1,2,3)
gap&gt; Image( hom, DerivedSubgroup(s4) );
Group([ (1,3,2), (1,3,2) ])
</pre>
<p>
<pre>
gap&gt; PreImage( hom, (1,2,3) );
Error, &lt;map&gt; must be an inj. and surj. mapping called from
&lt;function&gt;( &lt;arguments&gt; ) called from read-eval-loop
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you can 'return;' to continue
brk&gt; quit;
</pre>
<p>
<pre>
gap&gt; PreImagesRepresentative( hom, (1,2,3) );
(1,4,2)
gap&gt; PreImage( hom, TrivialSubgroup(s3) );  # the kernel
Group([ (1,4)(2,3), (1,3)(2,4) ])
</pre>
<p>
This homomorphism  from <i>S</i><sub>4</sub> onto  <i>S</i><sub>3</sub>  is well known  from elementary
group theory.  Images   of elements and  subgroups  under   <code>hom</code> can  be
calculated with the function <code>Image</code>. But since the mapping <code>hom</code> is  not
bijective, we  cannot use   the   function <code>PreImage</code> for  preimages   of
elements  (they can have   several preimages). Instead,   we have  to use
<code>PreImagesRepresentative</code>, which  returns  one  preimage if at  least one
exists (and would  return <code>fail</code> if none  exists, which  cannot occur for
our surjective <code>hom</code>.)  On the other hand, we  can use <code>PreImage</code> for the
preimage of a set (which always exists, even if it  is empty).
<p>
Suppose we mistype the input when trying to construct a homomorphism,
as in the following example.
<p>
<pre>
gap&gt; GroupHomomorphismByImages( s4, s3,
&gt;        GeneratorsOfGroup(s4), [(1,2,3),(2,3)] );
fail
</pre>
<p>
There is no such homomorphism, hence <code>fail</code> is returned.
But note that because of this, <code>GroupHomomorphismByImages</code> must do
some checks, and this was also done for the mapping <code>hom</code> above.
One can avoid these checks if one is sure that the desired
homomorphism really exists.
For that, the function <code>GroupHomomorphismByImagesNC</code> can be used;
the <code>NC</code> stands for ``no check''.
<p>
But note that horrible things can happen if <code>GroupHomomorphismByImagesNC</code>
is used when the input does not describe a homomorphism.
<p>
<pre>
gap&gt; hom2 := GroupHomomorphismByImagesNC( s4, s3,
&gt;            GeneratorsOfGroup(s4), [(1,2,3),(2,3)] );
[ (1,2,3,4), (1,2) ] -&gt; [ (1,2,3), (2,3) ]
gap&gt; Size( Kernel(hom2) );
24
</pre>
<p>
In other words, <font face="Gill Sans,Helvetica,Arial">GAP</font> claims that the kernel is the full <code>s4</code>,
yet <code>hom2</code> obviously has some non-trivial images!
Clearly there is no such thing as a homomorphism
which maps an element of order&nbsp;4 (namely, (1,2,3,4))
to an element of order&nbsp;3 (namely, (1,2,3)).
<strong>But if you use the command <code>GroupHomomorphismByImagesNC</code>,
<font face="Gill Sans,Helvetica,Arial">GAP</font> trusts you.</strong>
<p>
<pre>
gap&gt; IsGroupHomomorphism( hom2 );
true
</pre>
<p>
And then it produces serious nonsense if the thing is not a homomorphism,
as seen above!
<p>
Besides the safe command <code>GroupHomomorphismByImages</code>,
which returns <code>fail</code> if the requested homomorphism does not exist,
there is the function <code>GroupGeneralMappingByImages</code>,
which returns a general mapping (that is, a possibly multi-valued
mapping) that can be tested with <code>IsGroupHomomorphism</code>.
<p>
<pre>
gap&gt; hom2 := GroupGeneralMappingByImages( s4, s3,
&gt;            GeneratorsOfGroup(s4), [(1,2,3),(2,3)] );;
gap&gt; IsGroupHomomorphism( hom2 );
false
</pre>
<p>
<a name = "I7"></a>

<a name = "I7"></a>
<a name = "I8"></a>

<a name = "I7"></a>
<a name = "I8"></a>
<a name = "I9"></a>

<a name = "I10"></a>

But the  possibility of testing for being  a homomorphism is not the only
reason  why    <font face="Gill Sans,Helvetica,Arial">GAP</font> offers  <strong>group   general  mappings</strong>.  Another (more
important?) reason is that  their existence allows ``reversal of arrows''
in a  homomorphism such   as  our original  <code>hom</code>. By   this we mean  the
<code>GroupHomomorphismByImages</code> with left and right sides exchanged, in which
case it is of course merely a <code>GroupGeneralMappingByImages</code>.
<p>
<pre>
gap&gt; rev := GroupGeneralMappingByImages( s3, s4,
&gt;           [(1,2),(2,3)], GeneratorsOfGroup(s4) );;
</pre>
<p>
Now we have 
<br clear="all" /><table border="0" width="100%"><tr><td><table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center"><i>a</i> </td><td nowrap="nowrap" align="center"><small><i>h</i></small><!--sup--><br />&#8594; <br /><small></small>&nbsp;<br /></td><td nowrap="nowrap" align="center"><i>om</i> <i>b</i> &#8660; <i>b</i> </td><td nowrap="nowrap" align="center"><small><i>r</i></small><!--sup--><br />&#8594; <br /><small></small>&nbsp;<br /></td><td nowrap="nowrap" align="center"><i>ev</i> <i>a</i></td></tr></table></td></tr></table>
for <i>a</i> &#8712; <tt>s</tt><tt>4</tt> and <i>b</i> &#8712; <tt>s</tt><tt>3</tt>. Since every
such <i>b</i> has 4&nbsp;preimages under <code>hom</code>, it now has 4&nbsp;images under <code>rev</code>.
Just as the 4&nbsp;preimages form a coset of the kernel <i>V</i><sub>4</sub> &#8804; <tt>s</tt><tt>4</tt> of
<code>hom</code>, they also form a coset of the <strong>cokernel</strong> <i>V</i><sub>4</sub> &#8804; <tt>s</tt><tt>4</tt> of
<code>rev</code>.  The cokernel itself is the set of all images of <code>One( s3 )</code>
(it is a normal subgroup in the group of all images under <code>rev</code>). The
operation 'One' returns the identity element of a group, see <a href="../ref/CHAP030.htm#SSEC010.2">One</a>
in the reference manual.  And this is why <font face="Gill Sans,Helvetica,Arial">GAP</font> wants to perform such
a reversal of arrows: it calculates the kernel of a homomorphism like
<code>hom</code> as the cokernel of the reversed group general mapping (here <code>rev</code>).
<p>
<pre>
gap&gt; CoKernel( rev );
Group([ (1,4)(2,3), (1,3)(2,4) ])
</pre>
<p>
<a name = "I11"></a>

<a name = "I12"></a>

The  reason  why  <code>rev</code>   is not  a    homomorphism is  that   it is  not
single-valued  (because <code>hom</code> was   not injective). But there  is another
critical  condition: If   we   reverse the arrows   of  a  non-surjective
homomorphism,  we  obtain a group  general mapping  which  is not defined
everywhere, i.e.,  which is not total  (although it will be single-valued
if the original homomorphism is  injective). <font face="Gill Sans,Helvetica,Arial">GAP</font> requires that a group
homomorphism be  both  single-valued  and total,
so you will get <code>fail</code> if you say
<code>GroupHomomorphismByImages( </code><var>G</var><code>, </code><var>H</var><code>, </code><var>gens</var><code>, </code><var>imgs</var><code> )</code> where <var>gens</var> does
not generate <var>G</var> (even if this would give a decent homomorphism on the
subgroup generated by <var>gens</var>).  For a full description,
see Chapter <a href="../ref/CHAP038.htm">Group Homomorphisms</a> in the reference manual.
<p>
The last  example of this   section shows that  the  notion of kernel and
cokernel naturally extends even to the case  where neither <code>hom2</code> nor its
inverse general mapping (with arrows reversed) is a homomorphism.
<p>
<pre>
gap&gt; CoKernel( hom2 );  Kernel( hom2 );
Group([ (2,3), (1,3) ])
Group([ (3,4), (2,3,4), (1,2,4) ])
gap&gt; IsGroupHomomorphism( InverseGeneralMapping( hom2 ) );
false
</pre>
<p>
<hr>Summary.   In this section   we  have constructed homomorphisms by
specifying images for a set of generators. We have seen that by reversing
the direction of  the mapping, we get  group general mappings, which need
not be single-valued (unless the mapping was injective) nor total (unless
the mapping was surjective).
<p>
<p>
<h2><a name="SECT005">5.5 Nice Monomorphisms</a></h2>
<p><p>
For some types of groups, the best method to calculate in an isomorphic
group in a ``better'' representation (say, a permutation group).  We call an
injective homomorphism, that will give such an isomorphic image a ``nice
monomorphism''.
<p>
For example in the case of a matrix group we can take the action on the
underlying vector space (or a suitable subset) to obtain such a
monomorphism:
<p>
<pre>
gap&gt; grp:=GL(2,3);;
gap&gt; dom:=GF(3)^2;;
gap&gt; hom := ActionHomomorphism( grp, dom );; IsInjective( hom );
true
gap&gt; p := Image( hom,grp );
Group([ (4,7)(5,8)(6,9), (2,7,6)(3,4,8) ])
</pre>
<p>
To  demonstrate the technique  of   nice  monomorphisms, we  compute  the
conjugacy classes of the  permutation group and  lift them back into  the
matrix group with the monomorphism <code>hom</code>. Lifting  back a conjugacy class
means finding the preimage of  the representative and of the centralizer;
the latter  is   called  <code>StabilizerOfExternalSet</code>   in <font face="Gill Sans,Helvetica,Arial">GAP</font>   (because
conjugacy  classes are represented as   external sets, see
Section&nbsp;<a href="../ref/CHAP037.htm#SECT010">Conjugacy Classes</a> in the reference manual).
<p>
<pre>
gap&gt; pcls := ConjugacyClasses( p );; gcls := [  ];;
gap&gt; for pc  in pcls  do
&gt;      gc:=ConjugacyClass(grp,PreImagesRepresentative(hom,Representative(pc)));
&gt;      SetStabilizerOfExternalSet(gc,PreImage(hom,
&gt;                                 StabilizerOfExternalSet(pc)));
&gt;      Add( gcls, gc );
&gt;    od;
gap&gt; List( gcls, Size );
[ 1, 8, 12, 1, 8, 6, 6, 6 ]
</pre>
<p>
All the steps we have made above are automatically performed by <font face="Gill Sans,Helvetica,Arial">GAP</font> if
you  simply ask for <code>ConjugacyClasses(   grp   )</code>, provided that   <font face="Gill Sans,Helvetica,Arial">GAP</font>
already knows  that <code>grp</code> is finite (e.g.,  because  you asked <code>IsFinite(
grp  )</code> before). The reason  for this is that  a  finite matrix group like
<code>grp</code> is ``handled by a nice monomorphism''. For such groups, <font face="Gill Sans,Helvetica,Arial">GAP</font> uses
the command <code>NiceMonomorphism</code> to construct a monomorphism (such as the
<code>hom</code> in the previous example) and then proceeds as we have done above.
<p>
<pre>
gap&gt; grp:=GL(2,3);;
gap&gt; IsHandledByNiceMonomorphism( grp );
true
gap&gt; hom := NiceMonomorphism( grp );
&lt;action isomorphism&gt;
gap&gt; p :=Image(hom,grp);
Group([ (4,7)(5,8)(6,9), (2,7,6)(3,4,8) ])
gap&gt; cc := ConjugacyClasses( grp );; ForAll(cc, x-&gt; x in gcls); 
true
gap&gt; ForAll(gcls, x-&gt;x in cc); # cc and gcls might be ordered differently
true
</pre>
<p>
Note that a nice monomorphism might be defined on a larger group than <code>grp</code>
-- so we have to use <code>Image(hom,grp)</code> and not only <code>Image(hom)</code>.
<p>
Nice monomorphisms are not only used for matrix groups, but also for
other kinds of groups in which one cannot calculate easily enough. As
another example, let us show that the automorphism group of the
quaternion group of order&nbsp;8 is isomorphic to the symmetric group of
degree&nbsp;4  by examining the ``nice object'' associated with that
automorphism group.
<p>
<pre>
gap&gt; p:=Group((1,7,6,8)(2,5,3,4), (1,2,6,3)(4,8,5,7));;
gap&gt; aut := AutomorphismGroup( p );; NiceMonomorphism(aut);;
gap&gt; niceaut := NiceObject( aut );
Group([ (1,2)(3,4), (3,4)(5,6), (1,3)(2,4)(5,6), (1,6)(2,5)(3,4) ])
gap&gt; IsomorphismGroups( niceaut, SymmetricGroup( 4 ) );
[ (1,2)(3,4), (3,4)(5,6), (1,3)(2,4)(5,6), (1,6)(2,5)(3,4) ] -&gt; 
[ (1,4)(2,3), (1,2)(3,4), (2,3), (2,4) ]
</pre>
<p>
The range of  a nice monomorphism is  in most cases a permutation  group,
because  nice monomorphisms  are mostly action  homomorphisms. In some
cases,  like in  our last example,  the  group is solvable  and you might
prefer a pc group as nice object. You cannot change the nice monomorphism
of  the automorphism  group (because it  is   the value  of the attribute
<code>NiceMonomorphism</code>), but you can compose  it with an isomorphism from the
permutation  group to  a  pc   group  to   obtain your  personal    nicer
monomorphism. If  you reconstruct  the automorphism  group,  you can even
prescribe it this nicer monomorphism as its <code>NiceMonomorphism</code>, because a
newly-constructed group will not yet have a <code>NiceMonomorphism</code> set.
<p>
<pre>
gap&gt; nicer := NiceMonomorphism(aut) * IsomorphismPcGroup(niceaut);;
gap&gt; aut2 := GroupByGenerators( GeneratorsOfGroup( aut ) );;
gap&gt; SetIsHandledByNiceMonomorphism( aut2, true );
gap&gt; SetNiceMonomorphism( aut2, nicer );
gap&gt; NiceObject( aut2 );  # a pc group
Group([ f4, f3, f1*f2^2*f3, f1*f2*f3*f4 ])
</pre>
<p>
The star <code>*</code> denotes composition of mappings  from the left to the right,
as we  have  seen in  Section <a href="CHAP005.htm#SECT002">Actions of  groups</a> above.
Reconstructing the
automorphism group may of course result in the  loss of other information
<font face="Gill Sans,Helvetica,Arial">GAP</font> had already gathered, besides the (not-so-)nice monomorphism.
<p>
<hr>Summary.  In this section we have  seen  how calculations in groups
can be carried  out in isomorphic  images in  nicer groups. We  have seen
that <font face="Gill Sans,Helvetica,Arial">GAP</font>  pursues this technique  automatically for certain classes of
groups, e.g., for matrix groups that are known to be finite.
<p>
<p>
<h2><a name="SECT006">5.6 Further Information about Groups and Homomorphisms</a></h2>
<p><p>
Groups and the functions for groups are treated in Chapter&nbsp;<a href="../ref/CHAP037.htm">Groups</a>.
There are several chapters dealing with groups in specific representations,
for example Chapter&nbsp;<a href="../ref/CHAP041.htm">Permutation Groups</a> on permutation groups,
<a href="../ref/CHAP043.htm">Polycyclic Groups</a> on polycyclic (including finite solvable) groups,
<a href="../ref/CHAP042.htm">Matrix Groups</a> on matrix groups and <a href="../ref/CHAP045.htm">Finitely Presented Groups</a> on
finitely presented groups.
Chapter&nbsp;<a href="../ref/CHAP039.htm">Group Actions</a> deals with group actions. Group
homomorphisms are the subject of Chapter&nbsp;<a href="../ref/CHAP038.htm">Group Homomorphisms</a>.
<p>
<p>
[<a href="../index.htm">Top</a>] [<a href = "chapters.htm">Up</a>] [<a href ="CHAP004.htm">Previous</a>] [<a href ="CHAP006.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<P>
<font face="Gill Sans,Helvetica,Arial">GAP 4 manual<br>August 2005
</font></body></html>