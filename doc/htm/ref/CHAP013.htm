<html><head><title>[ref] 13 Types of Objects</title></head>
<body text="#000000" bgcolor="#ffffff">
[<a href="../index.htm">Top</a>] [<a href = "chapters.htm">Up</a>] [<a href ="CHAP012.htm">Previous</a>] [<a href ="CHAP014.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<h1>13 Types of Objects</h1><p>
<P>
<H3>Sections</H3>
<oL>
<li> <A HREF="CHAP013.htm#SECT001">Families</a>
<li> <A HREF="CHAP013.htm#SECT002">Filters</a>
<li> <A HREF="CHAP013.htm#SECT003">Categories</a>
<li> <A HREF="CHAP013.htm#SECT004">Representation</a>
<li> <A HREF="CHAP013.htm#SECT005">Attributes</a>
<li> <A HREF="CHAP013.htm#SECT006">Setter and Tester for Attributes</a>
<li> <A HREF="CHAP013.htm#SECT007">Properties</a>
<li> <A HREF="CHAP013.htm#SECT008">Other Filters</a>
<li> <A HREF="CHAP013.htm#SECT009">Types</a>
</ol><p>
<p>
Every <font face="Gill Sans,Helvetica,Arial">GAP</font> object has a <strong>type</strong>. The type of an object is the
information which is used to decide whether an operation is admissible
or possible with that object as an argument, and if so, how it is to
be performed
(see Chapter&nbsp;<a href="../prg/CHAP002.htm">Method Selection</a> in ``Programming in <font face="Gill Sans,Helvetica,Arial">GAP</font>'').
<p>
For example, the types determine whether two objects can be multiplied
and what function is called to compute the product.  Analogously, the
type of an object determines whether and how the size of the object
can be computed. It is sometimes useful in discussing the type system,
to identify types with the set of objects that have this type. Partial
types can then also be regarded as sets, such that any type is the
intersection of its parts.
<p>
The type of an object consists of two main parts, which describe
different aspects of the object.
<p>
The <strong>family</strong> determines the relation of the object to other objects.
For example, all permutations form a family.  Another family consists
of all collections of permutations, this family contains the set of
permutation groups as a subset.  A third family consists of all
rational functions with coefficients in a certain family.
<p>
The other part of a type is a collection of <strong>filters</strong> (actually stored
as a bit-list indicating, from the complete set of possible filters,
which are included in this particular type). These filters are all
treated equally by the method selection, but, from the viewpoint of
their creation and use, they can be divided (with a small number of
unimportant exceptions) into categories, representations, attribute
testers and properties. Each of these is described in more detail below.
<p>
This chapter does not describe how types and their constituent parts
can be created.  Information about this topic can be found in
``Programming in <font face="Gill Sans,Helvetica,Arial">GAP</font>'' in Section&nbsp;<a href="../prg/CHAP003.htm">Creating New Objects</a>.)
<p>
<strong>Note:</strong> Detailed understanding of the type system is not
required to use <font face="Gill Sans,Helvetica,Arial">GAP</font>. It can be helpful, however, to understand how things
work and why <font face="Gill Sans,Helvetica,Arial">GAP</font> behaves the way it does.
<p>
A discussion of the type system can be found in <a href="biblio.htm#BreuerLinton98"><cite>BreuerLinton98</cite></a>.
<p>
<p>
<h2><a name="SECT001">13.1 Families</a></h2>
<p><p>
The family of an object determines its relationship to other objects.
<p>
More precisely, the families form a partition of all <font face="Gill Sans,Helvetica,Arial">GAP</font> objects
such that the following two conditions hold: objects that are equal
w.r.t. <code>`='</code> lie in the same family; and the family of the result of
an operation depends only on the families of its operands.
<p>
The first condition means that a family can be regarded as a set of
elements instead of a set of objects.  Note that this does not hold
for categories and representations (see below), two objects that are
equal w.r.t. <code>`='</code> need not lie in the same categories and
representations.  For example, a sparsely represented matrix can be
equal to a densely represented matrix.  Similarly, each domain is
equal w.r.t. <code>`='</code> to the sorted list of its elements, but a domain
is not a list, and a list is not a domain.
<p>
<a name = "SSEC001.1"></a>
<li><code>FamilyObj( </code><var>obj</var><code> ) F</code>
<p>
returns the family of the object <var>obj</var>.
<p>
The family of the object <var>obj</var> is itself an object, its family is the
<code>FamilyOfFamilies</code>.
<p>
It should be emphasized that families may be created when they are
needed.  For example, the family of elements of a finitely presented
group is created only after the presentation has been constructed.
Thus families are the dynamic part of the type system, that is, the
part that is not fixed after the initialisation of <font face="Gill Sans,Helvetica,Arial">GAP</font>.
<p>
Families can be parametrized.  For example, the elements of each
finitely presented group form a family of their own.  Here the family
of elements and the finitely presented group coincide when viewed as
sets.  Note that elements in different finitely presented groups lie
in different families.  This distinction allows <font face="Gill Sans,Helvetica,Arial">GAP</font> to forbid
multiplications of elements in different finitely presented groups.
<p>
As a special case, families can be parametrized by other families.  An
important example is the family of <strong>collections</strong> that can be formed
for each family.  A collection consists of objects that lie in the
same family, it is either a nonempty dense list of objects from the
same family or a domain.
<p>
Note that every domain is a collection, that is, it is not possible to
construct domains whose elements lie in different families.  For
example, a polynomial ring over the rationals cannot contain the
integer <code>0</code> because the family that contains the integers does not
contain polynomials.  So one has to distinguish the integer zero from
each zero polynomial.
<p>
Let us look at this example from a different viewpoint.  A polynomial
ring and its coefficients ring lie in different families, hence the
coefficients ring cannot be embedded ``naturally'' into the polynomial
ring in the sense that it is a subset.  But it is possible to allow,
e.g., the multiplication of an integer and a polynomial over the
integers.  The relation between the arguments, namely that one is a
coefficient and the other a polynomial, can be detected from the
relation of their families.  Moreover, this analysis is easier than in
a situation where the rationals would lie in one family together with
all polynomials over the rationals, because then the relation of
families would not distinguish the multiplication of two polynomials,
the multiplication of two coefficients, and the multiplication of a
coefficient with a polynomial.  So the wish to describe relations
between elements can be taken as a motivation for the introduction of
families.
<p>
<p>
<h2><a name="SECT002">13.2 Filters</a></h2>
<p><p>
A <strong>filter</strong> is a special unary <font face="Gill Sans,Helvetica,Arial">GAP</font> function that returns either <code>true</code>
or <code>false</code>, depending on whether or not the argument lies in the set defined
by the filter.
Filters are used to express different aspects of information about a <font face="Gill Sans,Helvetica,Arial">GAP</font>
object, which are described below
(see&nbsp;<a href="CHAP013.htm#SECT003">Categories</a>, <a href="CHAP013.htm#SECT004">Representation</a>, <a href="CHAP013.htm#SECT005">Attributes</a>,
<a href="CHAP013.htm#SECT006">Setter and Tester for Attributes</a>, <a href="CHAP013.htm#SECT007">Properties</a>, <a href="CHAP013.htm#SECT008">Other Filters</a>).
<p>
Presently any filter in <font face="Gill Sans,Helvetica,Arial">GAP</font> is implemented as a function which
corresponds to a set of positions in the bitlist which forms part of the
type of each <font face="Gill Sans,Helvetica,Arial">GAP</font> object, and returns <code>true</code> if and only if the bitlist
of the type of the argument has the value <code>true</code> at all of these positions.
<p>
The intersection (or meet) of two filters <var>filt1</var>, <var>filt2</var> is again a
filter, it can be formed as
<p>
<a name = "I0"></a>

<code>&nbsp;</code><var>filt1</var><code> and </code><var>filt2</var><code></code>
<p>
See <a href="CHAP020.htm#SSEC003.3">and!for filters</a> for more details.
<p>
For example, <code>IsList and IsEmpty</code> is a filter that returns <code>true</code> if
its argument is an empty list, and <code>false</code> otherwise.  The filter
<code>IsGroup</code> is defined as the intersection of the category
<code>IsMagmaWithInverses</code> and the property <code>IsAssociative</code>.
<p>
A filter that is not the meet of other filters is called a <strong>simple
filter</strong>.
For example, each attribute tester (see&nbsp;<a href="CHAP013.htm#SECT006">Setter and Tester for Attributes</a>)
is a simple filter.
Each simple filter corresponds to a position in the bitlist currently
used as part of the data structure representing a type.
<p>
Every filter <var>filt</var> has a <strong>rank</strong>, which is used to define a ranking of
the methods installed for an operation, see Section&nbsp;<a href="../prg/CHAP002.htm#SECT002">Method Installation</a> in ``Programming in <font face="Gill Sans,Helvetica,Arial">GAP</font>''.
The rank of a filter can be accessed as
<p>
<a name = "SSEC002.1"></a>
<li><code>RankFilter( </code><var>filt</var><code> ) F</code>
<p>
For simple filters, an <strong>incremental rank</strong> is defined when the filter is
created, see the sections about the creation of filters
<a href="../prg/CHAP003.htm#SECT001">Creating Categories</a>, <a href="../prg/CHAP003.htm#SECT002">Creating Representations</a>,
<a href="../prg/CHAP003.htm#SECT003">Creating Attributes and Properties</a>, <a href="../prg/CHAP003.htm#SECT004">Creating Other Filters</a>; all
in ``Programming in <font face="Gill Sans,Helvetica,Arial">GAP</font>''.
For an arbitrary filter, its rank is given by the sum of the incremental
ranks of the <strong>involved</strong> simple filters;
in addition to the implied filters, these are also the required filters
of attributes (again see the sections about the creation of filters).
In other words, for the purpose of computing the rank and <strong>only</strong> for this
purpose, attribute testers are treated as if they would imply the
requirements of their attributes.
<p>
<a name = "SSEC002.2"></a>
<li><code>NamesFilter( </code><var>filt</var><code> ) F</code>
<p>
<code>NamesFilter</code> returns a list of names of the <strong>implied</strong> simple filters
of the filter <var>filt</var>, these are all those simple filters <var>imp</var> such that
every object in <var>filt</var> also lies in <var>imp</var>.
For implications between filters, see <a href="CHAP013.htm#SSEC002.3">ShowImpliedFilters</a> as well as
sections&nbsp;<a href="../prg/CHAP002.htm#SECT007">Logical Implications</a>, <a href="../prg/CHAP003.htm#SECT001">Creating Categories</a>,
<a href="../prg/CHAP003.htm#SECT002">Creating Representations</a>, <a href="../prg/CHAP003.htm#SECT003">Creating Attributes and Properties</a> in
``Programming in <font face="Gill Sans,Helvetica,Arial">GAP</font>''
<p>
<a name = "SSEC002.3"></a>
<li><code>ShowImpliedFilters( </code><var>filter</var><code> ) F</code>
<p>
Displays information about the filters that may be implied by 
<var>filter</var>. They are given by their names. <code>ShowImpliedFilters</code> first
displays the names of all filters that are unconditionally implied by
<var>filter</var>. It then displays implications that require further filters to
be present (indicating by <code>+</code> the required further filters).
The function displays only first-level implications, implications that
follow in turn are not displayed (though <font face="Gill Sans,Helvetica,Arial">GAP</font> will do these).
<p>
<pre>
gap&gt; ShowImpliedFilters(IsMatrix);
Implies:
   IsGeneralizedRowVector
   IsNearAdditiveElementWithInverse
   IsAdditiveElement
   IsMultiplicativeElement


May imply with:
+IsGF2MatrixRep
   IsOrdinaryMatrix

+CategoryCollections(CategoryCollections(IsAdditivelyCommutativeElement))
   IsAdditivelyCommutativeElement

+IsInternalRep
   IsOrdinaryMatrix

</pre>
<p>
<p>
<h2><a name="SECT003">13.3 Categories</a></h2>
<p><p>
The <strong>categories</strong> of an object are filters (see&nbsp;<a href="CHAP013.htm#SECT002">Filters</a>) determine what
operations an object admits.
For example, all integers form a category, all rationals form a category,
and all rational functions form a category.
An object which claims to lie in a certain category is accepting the
requirement that it should have methods for certain operations (and
perhaps that their behaviour should satisfy certain axioms).
For example, an object lying in the category <code>IsList</code> must have methods
for <code>Length</code>, <code>IsBound\[\]</code> and the list element access operation
<code>\[\]</code>.
<p>
An object can lie in several categories.  For example, a row vector
lies in the categories <code>IsList</code> and <code>IsVector</code>; each list lies in the
category <code>IsCopyable</code>, and depending on whether or not it is mutable,
it may lie in the category <code>IsMutable</code>.  Every domain lies in the
category <code>IsDomain</code>.
<p>
Of course some categories of a mutable object may change when the
object is changed.  For example, after assigning values to positions
of a mutable non-dense list, this list may become part of the category
<code>IsDenseList</code>.
<p>
However, if an object is immutable then the set of categories it lies
in is fixed.
<p>
All categories in the library are created during initialization, in
particular they are not created dynamically at runtime.
<p>
The following list gives an overview of important categories of
arithmetic objects.  Indented categories are to be understood as
subcategories of the non indented category listed above it.
<pre>
    IsObject
        IsExtLElement
        IsExtRElement
            IsMultiplicativeElement
                IsMultiplicativeElementWithOne
                    IsMultiplicativeElementWithInverse
        IsExtAElement
            IsAdditiveElement
                IsAdditiveElementWithZero
                    IsAdditiveElementWithInverse
</pre>
Every object lies in the category <code>IsObject</code>.
<p>
The categories <code>IsExtLElement</code> and <code>IsExtRElement</code> contain objects
that can be multiplied with other objects via <code>*</code> from the left and
from the right, respectively.  These categories are required for the
operands of the operation <code>*</code>.
<p>
The category <code>IsMultiplicativeElement</code> contains objects that can be
multiplied from the left and from the right with objects from the same
family.  <code>IsMultiplicativeElementWithOne</code> contains objects <var>obj</var> for
which a multiplicatively neutral element can be obtained by taking the
zeroth power <code></code><var>obj</var><code>^0</code>.  <code>IsMultiplicativeElementWithInverse</code> contains
objects <var>obj</var> for which a multiplicative inverse can be obtained by
forming <code></code><var>obj</var><code>^-1</code>.
<p>
Likewise, the categories <code>IsExtAElement</code>, <code>IsAdditiveElement</code>,
<code>IsAdditiveElementWithZero</code>, and <code>IsAdditiveElementWithInverse</code>
contain objects that can be added via <code>+</code> to other objects, objects
that can be added to objects of the same family, objects for which an
additively neutral element can be obtained by multiplication with
zero, and objects for which an additive inverse can be obtained by
multiplication with <code>-1</code>.
<p>
So a vector lies in <code>IsExtLElement</code>, <code>IsExtRElement</code>, and
<code>IsAdditiveElementWithInverse</code>.  A ring element must additionally lie
in <code>IsMultiplicativeElement</code>.
<p>
As stated above it is not guaranteed by the categories of objects
whether the result of an operation with these objects as arguments is
defined.  For example, the category <code>IsMatrix</code> is a subcategory of
<code>IsMultiplicativeElementWithInverse</code>.  Clearly not every matrix has a
multiplicative inverse.  But the category <code>IsMatrix</code> makes each matrix
an admissible argument of the operation <code>Inverse</code>, which may sometimes
return 'fail'.  Likewise, two matrices can be multiplied only if they
are of appropriate shapes.
<p>
Analogous to the categories of arithmetic elements, there are
categories of domains of these elements.
<pre>
    IsObject
        IsDomain
            IsMagma
                IsMagmaWithOne
                    IsMagmaWithInversesIfNonzero
                        IsMagmaWithInverses
            IsAdditiveMagma
                IsAdditiveMagmaWithZero
                    IsAdditiveMagmaWithInverses
            IsExtLSet
            IsExtRSet
</pre>
Of course <code>IsDomain</code> is a subcategory of <code>IsObject</code>.  A domain that is
closed under multiplication <code>*</code> is called a magma and it lies in the
category <code>IsMagma</code>.  If a magma is closed under taking the identity,
it lies in <code>IsMagmaWithOne</code>, and if it is also closed under taking
inverses, it lies in <code>IsMagmaWithInverses</code>.  The category
<code>IsMagmaWithInversesIfNonzero</code> denotes closure under taking inverses
only for nonzero elements, every division ring lies in this category.
<p>
Note that every set of categories constitutes its own notion of
generation, for example a group may be generated as a magma with
inverses by some elements, but to generate it as a magma with one it
may be necessary to take the union of these generators and their
inverses.
<p>
<a name = "SSEC003.1"></a>
<li><code>CategoriesOfObject( </code><var>object</var><code> ) O</code>
<p>
returns a list of the names of the categories in which <var>object</var> lies.
<p>
<pre>
gap&gt; g:=Group((1,2),(1,2,3));;
gap&gt; CategoriesOfObject(g);
[ "IsListOrCollection", "IsCollection", "IsExtLElement", 
  "CategoryCollections(IsExtLElement)", "IsExtRElement", 
  "CategoryCollections(IsExtRElement)", 
  "CategoryCollections(IsMultiplicativeElement)", 
  "CategoryCollections(IsMultiplicativeElementWithOne)", 
  "CategoryCollections(IsMultiplicativeElementWithInverse)", 
  "CategoryCollections(IsAssociativeElement)", 
  "CategoryCollections(IsFiniteOrderElement)", "IsGeneralizedDomain", 
  "CategoryCollections(IS_PERM)", "IsMagma", "IsMagmaWithOne", 
  "IsMagmaWithInversesIfNonzero", "IsMagmaWithInverses" ]
</pre>
<p>
<p>
<h2><a name="SECT004">13.4 Representation</a></h2>
<p><p>
The <strong>representation</strong> of an object is a set of filters (see&nbsp;<a href="CHAP013.htm#SECT002">Filters</a>)
that determines how an object is actually represented.
For example, a matrix or a polynomial can be stored sparsely or
densely; all dense polynomials form a representation. An object which
claims to lie in a certain representation is accepting the requirement
that certain fields in the data structure be present and have
specified meanings.
<p>
<font face="Gill Sans,Helvetica,Arial">GAP</font> distinguishes four essentially different ways to represent
objects.  First there are the representations <code>IsInternalRep</code> for
internal objects such as integers and permutations, and
<code>IsDataObjectRep</code> for other objects that are created and whose data
are accessible only by kernel functions. The data structures
underlying such objects cannot be manipulated at the <font face="Gill Sans,Helvetica,Arial">GAP</font> level.
<p>
All other objects are either in the representation
<code>IsComponentObjectRep</code> or in the representation
<code>IsPositionalObjectRep</code>, see&nbsp;<a href="../prg/CHAP003.htm#SECT009">Component Objects</a>
and&nbsp;<a href="../prg/CHAP003.htm#SECT010">Positional Objects</a> in ``Programming in <font face="Gill Sans,Helvetica,Arial">GAP</font>''.
<p>
An object can belong to several representations in the sense that it
lies in several subrepresentations of <code>IsComponentObjectRep</code> or of
<code>IsPositionalObjectRep</code>.  The representations to which an object
belongs should form a chain and either two representations are disjoint
or one is contained in the other.  So the subrepresentations of
<code>IsComponentObjectRep</code> and <code>IsPositionalObjectRep</code> each form
trees. In the language of Object Oriented Programming, we support only
single inheritance for representations.
<p>
These trees are typically rather shallow, since for one representation
to be contained in another implies that all the components of the data
structure implied by the containing representation, are present in,
and have the same meaning in, the smaller representation (whose data
structure presumably contains some additional components).
<p>
Objects may change their representation, for example a mutable list
of characters can be converted into a string.
<p>
All representations in the library are created during initialization,
in particular they are not created dynamically at runtime.
<p>
Examples of subrepresentations of <code>IsPositionalObjectRep</code> are
<code>IsModulusRep</code>, which is used for residue classes in the ring of
integers, and <code>IsDenseCoeffVectorRep</code>, which is used for elements of
algebras that are defined by structure constants.
<p>
An important subrepresentation of <code>IsComponentObjectRep</code> is
<code>IsAttributeStoringRep</code>, which is used for many domains and some other
objects.  It provides automatic storing of all attribute values (see
below).
<p>
<a name = "SSEC004.1"></a>
<li><code>RepresentationsOfObject( </code><var>object</var><code> ) O</code>
<p>
returns a list of the names of the representations <var>object</var> has.
<p>
<pre>
gap&gt; g:=Group((1,2),(1,2,3));;
gap&gt; RepresentationsOfObject(g);
[ "IsComponentObjectRep", "IsAttributeStoringRep" ]
</pre>
<p>
<p>
<h2><a name="SECT005">13.5 Attributes</a></h2>
<p><p>
The attributes of an object are filters (see&nbsp;<a href="CHAP013.htm#SECT002">Filters</a>) that describe
knowledge about it.
<p>
An attribute is a unary operation without side-effects.
<p>
An object may store values of its attributes once they have been
computed, and claim that it knows these values.  Note that ``store''
and ``know'' have to be understood in the sense that it is very cheap
to get such a value when the attribute is called again.
<p>
The stored value of an attribute is in general immutable
(see&nbsp;<a href="CHAP012.htm#SECT006">Mutability and Copyability</a>), except if the attribute had been
specally constructed as ``mutable attribute''.
<p>
It depends on the representation of an object (see&nbsp;<a href="CHAP013.htm#SECT004">Representation</a>)
which attribute values it stores.  An object in the representation
<code>IsAttributeStoringRep</code> stores <strong>all</strong> attribute values once they are
computed.  Moreover, for an object in this representation, subsequent
calls to an attribute will return the <strong>same</strong> object; this is achieved
via a special method for each attribute setter that stores the
attribute value in an object in <code>IsAttributeStoringRep</code>, and a special
method for the attribute itself that fetches the stored attribute
value.  (These methods are called the ``system setter'' and the
``system getter'' of the attribute, respectively.)indexsystem
getterindexsystem setter
<p>
Note also that it is impossible to get rid of a stored attribute
value because the system may have drawn conclusions from the old
attribute value, and just removing the value might leave the data
structures in an inconsistent state. If necessary, a new object can be
constructed.
<p>
Properties are a special form of attributes that have the value <code>true</code>
or <code>false</code>, see section&nbsp;<a href="CHAP013.htm#SECT007">Properties</a>.
<p>
All attributes in the library are created during initialization,
in particular they are not created dynamically at runtime.
<p>
Examples of attributes for multiplicative elements are <code>Inverse</code>, <code>One</code>,
and <code>Order</code>.
<code>Size</code> is an attribute for domains, <code>Centre</code> is an attribute for magmas,
and <code>DerivedSubgroup</code> is an attribute for groups.
<p>
<a name = "SSEC005.1"></a>
<li><code>KnownAttributesOfObject( </code><var>object</var><code> ) O</code>
<p>
returns a list of the names of the attributes whose values are known for 
<var>object</var>.
<p>
<pre>
gap&gt; g:=Group((1,2),(1,2,3));;Size(g);;
gap&gt; KnownAttributesOfObject(g);
[ "Size", "OneImmutable", "NrMovedPoints", "MovedPoints", 
  "GeneratorsOfMagmaWithInverses", "MultiplicativeNeutralElement", "Pcgs", 
  "GeneralizedPcgs", "StabChainMutable", "StabChainOptions" ]
</pre>
<p>
Several attributes have methods for more than one argument.  For example
<code>IsTransitive</code> (see&nbsp;<a href="CHAP039.htm#SSEC009.1">IsTransitive!for group actions</a>) is an attribute for 
a <i>G</i>-set that
can also be called for the two arguments, being a group <i>G</i> and its operation
domain.  If attributes are called with more than one argument then the
return value is not stored in any of the arguments.
<p>
<p>
<h2><a name="SECT006">13.6 Setter and Tester for Attributes</a></h2>
<p><p>
<a name = "I1"></a>

<a name = "I1"></a>
<a name = "I2"></a>

For every attribute two further operations, the <strong>attribute setter</strong> and the
<strong>attribute tester</strong> are defined.
<p>
To check whether an object belongs to an attribute <var>attr</var>,
the tester
<p>
<a name = "SSEC006.1"></a>
<li><code>Tester( </code><var>attr</var><code> ) O</code>
<p>
of the attribute is used;
this is a filter (see&nbsp;<a href="CHAP013.htm#SECT002">Filters</a>) that returns <code>true</code> or <code>false</code>,
depending on whether or not the value of <var>attr</var> for the object is known.
For example, <code>Tester( Size )( </code><var>obj</var><code> )</code> is <code>true</code> if the size of the object
<var>obj</var> is known.
<p>
To store a value for the attribute <var>attr</var> in an object,
the setter
<p>
<a name = "SSEC006.2"></a>
<li><code>Setter( </code><var>attr</var><code> ) O</code>
<p>
of the attribute is used.
The setter is called automatically when the attribute value has been
computed for the first time.
One can also call the setter explicitly,
for example, <code>Setter( Size )( </code><var>obj</var><code>, </code><var>val</var><code> )</code> sets <var>val</var> as size of the
object <var>obj</var> if the size was not yet known.
<p>
For each attribute <var>attr</var> that is declared with <code>DeclareAttribute</code>
resp.&nbsp;<code>DeclareProperty</code> (see&nbsp;<a href="../prg/CHAP003.htm#SECT017">Global Variables in the Library</a> in
``Programming in <font face="Gill Sans,Helvetica,Arial">GAP</font>''),
tester and setter are automatically made accessible by the names
<code>Has</code><var>attr</var><code></code> and <code>Set</code><var>attr</var><code></code>, respectively.
For example, the tester for <code>Size</code> is called <code>HasSize</code>,
and the setter is called <code>SetSize</code>.
<p>
<pre>
gap&gt; g:=Group((1,2,3,4),(1,2));;Size(g);
24
gap&gt; HasSize(g);
true
gap&gt; SetSize(g,99);
gap&gt; Size(g);
24
</pre>
<p>
For two properties <var>prop1</var> and <var>prop2</var>,
the intersection <code></code><var>prop1</var><code> and </code><var>prop2</var><code></code> (see&nbsp;<a href="CHAP013.htm#SECT002">Filters</a>) is again a property
for which a setter and a tester exist.
Setting the value of this intersection to <code>true</code> for a <font face="Gill Sans,Helvetica,Arial">GAP</font> object
means to set the values of <var>prop1</var> and <var>prop2</var> to <code>true</code> for this object.
<p>
<pre>
gap&gt; prop:= IsFinite and IsCommutative;
&lt;Operation "&lt;&lt;and-filter&gt;&gt;"&gt;
gap&gt; g:= Group( (1,2,3), (4,5) );;
gap&gt; Tester( prop )( g );
false
gap&gt; Setter( prop )( g, true );
gap&gt; Tester( prop )( g );  prop( g );
true
true
</pre>
<p>
It is <strong>not allowed</strong> to set the value of such an intersection to <code>false</code>
for an object.
<p>
<pre>
gap&gt; Setter( prop )( Rationals, false );
You cannot set an "and-filter" except to true
not in any function
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you can type 'return true;' to set all components true
(but you might really want to reset just one component) to continue
brk&gt; 
</pre>
<p>
<a name = "SSEC006.3"></a>
<li><code>AttributeValueNotSet( </code><var>attr</var><code>, </code><var>obj</var><code> ) F</code>
<p>
If the value of the attribute <var>attr</var> is already stored for <var>obj</var>,
<code>AttributeValueNotSet</code> simply returns this value.
Otherwise the value of <code></code><var>attr</var><code>( </code><var>obj</var><code> )</code> is computed and returned
<strong>without storing it</strong> in <var>obj</var>.
This can be useful when ``large'' attribute values (such as element lists)
are needed only once and shall not be stored in the object.
<pre>
gap&gt; HasAsSSortedList(g);
false
gap&gt; AttributeValueNotSet(AsSSortedList,g);
[ (), (4,5), (1,2,3), (1,2,3)(4,5), (1,3,2), (1,3,2)(4,5) ]
gap&gt; HasAsSSortedList(g);
false
</pre>
<p>
The normal behaviour of attributes (when called with just one argument)
is that once a method has been selected and executed, and has returned a
value the setter of the attribute is called, to (possibly) store the
computed value. In special circumstances, this behaviour can be altered
dynamically on an attribute-by-attribute basis, using the functions
<code>DisableAttributeValueStoring</code> and <code>EnableAttributeValueStoring</code>.
<p>
In general, the code in the library assumes, for efficiency, but not for
correctness, that attribute values <strong>will</strong> be stored (in suitable
objects), so disabling storing may cause substantial computations to be
repeated.
<p>
<a name = "SSEC006.4"></a>
<li><code>InfoAttributes V</code>
<p>
This info class (together with <code>InfoWarning</code>; see&nbsp;<a href="CHAP007.htm#SSEC004.6">InfoWarning</a>) is  used
for messages about attribute storing  being  disabled  (at  level  2)  or
enabled (level 3). It may be  used  in  the  future  for  other  messages
concerning changes to attribute behaviour.
<p>
<a name = "SSEC006.5"></a>
<li><code>DisableAttributeValueStoring( </code><var>attr</var><code> ) F</code>
<p>
disables the usual call of <code>Setter( </code><var>attr</var><code> )</code> when a  method  for  <var>attr</var>
returns a value. In consequence the values will  never  be  stored.  Note
that <var>attr</var> must be an attribute and <strong>not</strong> a property.
<p>
<a name = "SSEC006.6"></a>
<li><code>EnableAttributeValueStoring( </code><var>attr</var><code> ) F</code>
<p>
enables the usual call of <code>Setter( </code><var>attr</var><code> )</code> when  a  method  for  <var>attr</var>
returns a value. In consequence the  values  may  be  stored.  This  will
usually  have  no  effect   unless   <code>DisableAttributeValueStoring</code>   has
previously been used for <var>attr</var>. Note that <var>attr</var> must  be  an  attribute
and <strong>not</strong> a property.
<p>
<pre>
gap&gt; g := Group((1,2,3,4,5),(1,2,3));
Group([ (1,2,3,4,5), (1,2,3) ])
gap&gt; KnownAttributesOfObject(g);
[ "LargestMovedPoint", "GeneratorsOfMagmaWithInverses", 
  "MultiplicativeNeutralElement" ]
gap&gt; SetInfoLevel(InfoAttributes,3);
gap&gt; DisableAttributeValueStoring(Size);
#I  Disabling value storing for Size
gap&gt; Size(g);
60
gap&gt; KnownAttributesOfObject(g);
[ "OneImmutable", "LargestMovedPoint", "NrMovedPoints", "MovedPoints", 
  "GeneratorsOfMagmaWithInverses", "MultiplicativeNeutralElement", 
  "StabChainMutable", "StabChainOptions" ]
gap&gt; Size(g);
60
gap&gt; EnableAttributeValueStoring(Size);
#I  Enabling value storing for Size
gap&gt; Size(g);
60
gap&gt; KnownAttributesOfObject(g);
[ "Size", "OneImmutable", "LargestMovedPoint", "NrMovedPoints", 
  "MovedPoints", "GeneratorsOfMagmaWithInverses", 
  "MultiplicativeNeutralElement", "StabChainMutable", "StabChainOptions" ]
</pre>
<p>
<p>
<h2><a name="SECT007">13.7 Properties</a></h2>
<p><p>
The properties of an object are those of its attributes (see&nbsp;<a href="CHAP013.htm#SECT005">Attributes</a>)
whose values can only be <code>true</code> or <code>false</code>.
<p>
The main difference between attributes and properties is that a
property defines two sets of objects, namely the usual set of all
objects for which the value is known, and the set of all objects for
which the value is known to be <code>true</code>.
<p>
(Note that it makes no sense to consider a third set, namely the set
of objects for which the value of a property is <code>true</code> whether or not
it is known, since there may be objects for which the containment in
this set cannot be decided.)
<p>
For a property <var>prop</var>, the containment of an object <var>obj</var> in the first
set is checked again by applying <code>Tester( </code><var>prop</var><code> )</code> to <var>obj</var>,
and <var>obj</var> lies in the second set if and only if
<code>Tester( </code><var>prop</var><code> )( </code><var>obj</var><code> ) and </code><var>prop</var><code>( </code><var>obj</var><code> )</code> is <code>true</code>.
<p>
If a property value is known for an immutable object then this value is
also stored, as part of the type of the object.
To some extent, property values of mutable objects also can be stored,
for example a mutable list all of whose entries are immutable can store
whether it is strictly sorted. When the object is mutated (for example
by list assignment) the type may need to be adjusted.
<p>
Important properties for domains are <code>IsAssociative</code>, <code>IsCommutative</code>,
<code>IsAnticommutative</code>, <code>IsLDistributive</code>, and <code>IsRDistributive</code>,
which mean that the multiplication of elements in the domain satisfies
(<i>a</i> * <i>b</i> ) * <i>c</i> = <i>a</i> * ( <i>b</i> * <i>c</i> ), <i>a</i> * <i>b</i> = <i>b</i> * <i>a</i>,
<i>a</i> * <i>b</i> = &#8722; ( <i>b</i> * <i>a</i> ), <i>a</i> * ( <i>b</i> + <i>c</i> ) = <i>a</i> * <i>b</i> + <i>a</i> * <i>c</i>,
and ( <i>a</i> + <i>b</i> ) * <i>c</i> = <i>a</i> * <i>c</i> + <i>b</i> * <i>c</i>, respectively,
for all <i>a</i>, <i>b</i>, <i>c</i> in the domain.
<p>
<a name = "SSEC007.1"></a>
<li><code>KnownPropertiesOfObject( </code><var>object</var><code> ) O</code>
<p>
returns a list of the names of the properties whose values are known for
<var>object</var>.
<p>
<a name = "SSEC007.2"></a>
<li><code>KnownTruePropertiesOfObject( </code><var>object</var><code> ) O</code>
<p>
returns a list of the names of the properties known to be <code>true</code> for
<var>object</var>.
<p>
<pre>
gap&gt; g:=Group((1,2),(1,2,3));;
gap&gt; KnownPropertiesOfObject(g);
[ "IsFinite", "CanEasilyCompareElements", "CanEasilySortElements", 
  "IsDuplicateFree", "IsGeneratorsOfMagmaWithInverses", "IsAssociative", 
  "IsSimpleSemigroup", "IsFinitelyGeneratedGroup", 
  "IsSubsetLocallyFiniteGroup", "KnowsHowToDecompose", "IsChainTypeGroup", 
  "IsStabChainViaChainSubgroup" ]
gap&gt; Size(g);
6
gap&gt; KnownPropertiesOfObject(g);
[ "IsEmpty", "IsTrivial", "IsNonTrivial", "IsFinite", 
  "CanEasilyCompareElements", "CanEasilySortElements", "IsDuplicateFree", 
  "IsGeneratorsOfMagmaWithInverses", "IsAssociative", "IsSimpleSemigroup", 
  "IsFinitelyGeneratedGroup", "IsSubsetLocallyFiniteGroup", 
  "KnowsHowToDecompose", "IsPerfectGroup", "IsSolvableGroup", 
  "IsPolycyclicGroup", "IsChainTypeGroup", "IsStabChainViaChainSubgroup" ]
gap&gt; KnownTruePropertiesOfObject(g);
[ "IsNonTrivial", "IsFinite", "CanEasilyCompareElements", 
  "CanEasilySortElements", "IsDuplicateFree", 
  "IsGeneratorsOfMagmaWithInverses", "IsAssociative", "IsSimpleSemigroup", 
  "IsFinitelyGeneratedGroup", "IsSubsetLocallyFiniteGroup", 
  "KnowsHowToDecompose", "IsSolvableGroup", "IsPolycyclicGroup" ]
</pre>
<p>
<p>
<h2><a name="SECT008">13.8 Other Filters</a></h2>
<p><p>
There are situations where one wants to express a kind of knowledge
that is based on some heuristic.
<p>
For example, the filters (see&nbsp;<a href="CHAP013.htm#SECT002">Filters</a>) <code>CanEasilyTestMembership</code> and
<code>CanEasilyComputePcgs</code> are defined in the <font face="Gill Sans,Helvetica,Arial">GAP</font> library.
Note that such filters do not correspond to a mathematical concept,
contrary to properties (see&nbsp;<a href="CHAP013.htm#SECT007">Properties</a>).
Also it need not be defined what ``easily'' means for an arbitrary <font face="Gill Sans,Helvetica,Arial">GAP</font>
object, and in this case one cannot compute the value for an arbitrary
<font face="Gill Sans,Helvetica,Arial">GAP</font> object.
In order to access this kind of knowledge as a part of the type of an object,
<font face="Gill Sans,Helvetica,Arial">GAP</font> provides filters for which the value is <code>false</code> by default,
and it is changed to <code>true</code> in certain situations,
either explicitly (for the given object) or via a logical implication
(see&nbsp;<a href="../prg/CHAP002.htm#SECT007">Logical Implications</a> in ``Programming in <font face="Gill Sans,Helvetica,Arial">GAP</font>'')
from other filters.
<p>
For example, a <code>true</code> value of <code>CanEasilyComputePcgs</code> for a group
means that certain methods are applicable that use a pcgs
(see&nbsp;<a href="CHAP043.htm#SECT001">Polycyclic Generating Systems</a>) for the group.
There are logical implications to set the filter value to <code>true</code>
for permutation groups that are known to be solvable,
and for groups that have already a (sufficiently nice) pcgs stored.
In the case one has a solvable matrix group and wants to enable methods
that use a pcgs, one can set the <code>CanEasilyComputePcgs</code> value to
<code>true</code> for this particular group.
<p>
A filter <var>filt</var> of the kind described here is different from
the other filters introduced in the previous sections.
In particular, <var>filt</var> is not a category (see&nbsp;<a href="CHAP013.htm#SECT003">Categories</a>) or a property
(see&nbsp;<a href="CHAP013.htm#SECT007">Properties</a>) because its value may change for a given object,
and <var>filt</var> is not a representation (see&nbsp;<a href="CHAP013.htm#SECT004">Representation</a>) because it has
nothing to do with the way an object is made up from some data.
<var>filt</var> is similar to an attribute tester
(see&nbsp;<a href="CHAP013.htm#SECT006">Setter and Tester for Attributes</a>),
the only difference is that <var>filt</var> does not refer to an attribute value;
note that <var>filt</var> is also used in the same way as an attribute tester;
namely, the <code>true</code> value may be required for certain methods to be
applicable.
<p>
<p>
<h2><a name="SECT009">13.9 Types</a></h2>
<p><p>
We stated above (see <a href="CHAP013.htm">Types of Objects</a>) that, for an object <var>obj</var>,
its <strong>type</strong> is formed from its family and its filters.  There is a also
a third component, used in a few situations, namely defining data of
the type.
<p>
<a name = "SSEC009.1"></a>
<li><code>TypeObj( </code><var>obj</var><code> ) F</code>
<p>
returns the type of the object <var>obj</var>. 
<p>
The type of an object is itself an object.
<p>
Two types are equal if and only if the two families are identical,
the filters are equal, and, if present, also the defining data of the
types are equal.
<p>
The last part of the type, defining data, has not been mentioned
before and seems to be of minor importance.  It can be used, e.g., for
cosets <i>U</i> <i>g</i> of a group <i>U</i>, where the type of each coset may contain
the group <i>U</i> as defining data.  As a consequence, two such cosets mod
<i>U</i> and <i>V</i> can have the same type only if <i>U</i> = <i>V</i>.  The defining data
of the type <var>type</var> can be accessed as
<p>
<a name = "SSEC009.2"></a>
<li><code>DataType( </code><var>type</var><code> ) F</code>
<p>
<p>
[<a href="../index.htm">Top</a>] [<a href = "chapters.htm">Up</a>] [<a href ="CHAP012.htm">Previous</a>] [<a href ="CHAP014.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<P>
<font face="Gill Sans,Helvetica,Arial">GAP 4 manual<br>August 2005
</font></body></html>