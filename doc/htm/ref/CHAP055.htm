<html><head><title>[ref] 55 Modules</title></head>
<body text="#000000" bgcolor="#ffffff">
[<a href="../index.htm">Top</a>] [<a href = "chapters.htm">Up</a>] [<a href ="CHAP054.htm">Previous</a>] [<a href ="CHAP056.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<h1>55 Modules</h1><p>
<P>
<H3>Sections</H3>
<oL>
<li> <A HREF="CHAP055.htm#SECT001">Generating modules</a>
<li> <A HREF="CHAP055.htm#SECT002">Submodules</a>
<li> <A HREF="CHAP055.htm#SECT003">Free Modules</a>
</ol><p>
<p>
<p>
<h2><a name="SECT001">55.1 Generating modules</a></h2>
<p><p>
<a name = "SSEC001.1"></a>
<li><code>IsLeftOperatorAdditiveGroup( </code><var>D</var><code> ) C</code>
<p>
A domain <var>D</var> lies in <code>IsLeftOperatorAdditiveGroup</code> if it is an additive
group that is closed under scalar multplication from the
left, and such that &#955;*(<i>x</i>+<i>y</i>)=&#955;*<i>x</i>+&#955;*<i>y</i> for all
scalars &#955; and elements <i>x</i>,<i>y</i> &#8712; <i>D</i>.
<p>
<a name = "SSEC001.2"></a>
<li><code>IsLeftModule( </code><var>M</var><code> ) C</code>
<p>
A domain <var>M</var> lies in <code>IsLeftModule</code> if it lies in
<code>IsLeftOperatorAdditiveGroup</code>, <em>and</em>the set of scalars forms a ring,
<em>and</em>(&#955;+&#956;)*<i>x</i>=&#955;*<i>x</i>+&#956;*<i>x</i> for scalars &#955;,&#956;
and <i>x</i> &#8712; <i>M</i>, <em>and</em>scalar multiplication satisfies &#955;*(&#956;*<i>x</i>) = (&#955;*&#956;)*<i>x</i> for scalars &#955;,&#956; and <i>x</i> &#8712; <i>M</i>.
<p>
<pre>
gap&gt; V:= FullRowSpace( Rationals, 3 );
( Rationals^3 )
gap&gt; IsLeftModule( V );
true
</pre>
<p>
<a name = "SSEC001.3"></a>
<li><code>GeneratorsOfLeftOperatorAdditiveGroup( </code><var>D</var><code> ) A</code>
<p>
returns a list of elements of <var>D</var> that generates <var>D</var> as a left operator
additive group.
<p>
<a name = "SSEC001.4"></a>
<li><code>GeneratorsOfLeftModule( </code><var>M</var><code> ) A</code>
<p>
returns a list of elements of <var>M</var> that generate <var>M</var> as a left module.
<p>
<pre>
gap&gt; V:= FullRowSpace( Rationals, 3 );;
gap&gt; GeneratorsOfLeftModule( V );
[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ]
</pre>
<p>
<a name = "SSEC001.5"></a>
<li><code>AsLeftModule( </code><var>R</var><code>, </code><var>D</var><code> ) O</code>
<p>
if the domain <var>D</var> forms an additive group and is closed under left
multiplication by the elements of <var>R</var>, then <code>AsLeftModule( </code><var>R</var><code>, </code><var>D</var><code> )</code>
returns the domain <var>D</var> viewed as a left module.
<p>
<pre>
gap&gt; coll:= [ [0*Z(2),0*Z(2)], [Z(2),0*Z(2)], [0*Z(2),Z(2)], [Z(2),Z(2)] ];
[ [ 0*Z(2), 0*Z(2) ], [ Z(2)^0, 0*Z(2) ], [ 0*Z(2), Z(2)^0 ], 
  [ Z(2)^0, Z(2)^0 ] ]
gap&gt; AsLeftModule( GF(2), coll );
&lt;vector space of dimension 2 over GF(2)&gt;
</pre>
<p>
<a name = "SSEC001.6"></a>
<li><code>IsRightOperatorAdditiveGroup( </code><var>D</var><code> ) C</code>
<p>
A domain <var>D</var> lies in <code>IsRightOperatorAdditiveGroup</code> if it is an additive
group that is closed under scalar multplication from the
right, and such that (<i>x</i>+<i>y</i>)*&#955; = <i>x</i>*&#955;+<i>y</i>*&#955; for all
scalars &#955; and elements <i>x</i>,<i>y</i> &#8712; <i>D</i>.
<p>
<a name = "SSEC001.7"></a>
<li><code>IsRightModule( </code><var>M</var><code> ) C</code>
<p>
A domain <var>M</var> lies in <code>IsRightModule</code> if it lies in
<code>IsRightOperatorAdditiveGroup</code>, <em>and</em>the set of scalars forms a ring,
<em>and</em><i>x</i>*(&#955;+&#956;) = <i>x</i>*&#955;+<i>x</i>*&#956; for scalars &#955;,&#956;
and <i>x</i> &#8712; <i>M</i>, <em>and</em>scalar multiplication satisfies (<i>x</i>*&#956;)*&#955; =  <i>x</i>*(&#956;*&#955;) for scalars &#955;,&#956; and <i>x</i> &#8712; <i>M</i>.
<p>
<a name = "SSEC001.8"></a>
<li><code>GeneratorsOfRightOperatorAdditiveGroup( </code><var>D</var><code> ) A</code>
<p>
returns a list of elements of <var>D</var> that generates <var>D</var> as a right operator
additive group.
<p>
<a name = "SSEC001.9"></a>
<li><code>GeneratorsOfRightModule( </code><var>M</var><code> ) A</code>
<p>
returns a list of elements of <var>M</var> that generate <var>M</var> as a left module.
<p>
<a name = "SSEC001.10"></a>
<li><code>LeftModuleByGenerators( </code><var>R</var><code>, </code><var>gens</var><code> ) O</code>
<li><code>LeftModuleByGenerators( </code><var>R</var><code>, </code><var>gens</var><code>, </code><var>zero</var><code> ) O</code>
<p>
returns the left module over <var>R</var> generated by <var>gens</var>.
<p>
<pre>
gap&gt; coll:= [ [Z(2),0*Z(2)], [0*Z(2),Z(2)], [Z(2),Z(2)] ];;
gap&gt; V:= LeftModuleByGenerators( GF(16), coll );
&lt;vector space over GF(2^4), with 3 generators&gt;
</pre>
<p>
<a name = "SSEC001.11"></a>
<li><code>LeftActingDomain( </code><var>D</var><code> ) A</code>
<p>
Let <var>D</var> be an external left set, that is, <var>D</var> is closed under the action
of a domain <i>L</i> by multiplication from the left.
Then <i>L</i> can be accessed as value of <code>LeftActingDomain</code> for <var>D</var>.
<p>
<p>
<h2><a name="SECT002">55.2 Submodules</a></h2>
<p><p>
<a name = "SSEC002.1"></a>
<li><code>Submodule( </code><var>M</var><code>, </code><var>gens</var><code> ) F</code>
<li><code>Submodule( </code><var>M</var><code>, </code><var>gens</var><code>, "basis" ) F</code>
<p>
is the left module generated by the collection <var>gens</var>,
with parent module <var>M</var>.
The second form generates the submodule of <var>M</var> for that the list <var>gens</var>
is known to be a list of basis vectors;
in this case, it is <strong>not</strong> checked whether <var>gens</var> really are linearly
independent and whether all in <var>gens</var> lie in <var>M</var>.
<p>
<pre>
gap&gt; coll:= [ [Z(2),0*Z(2)], [0*Z(2),Z(2)], [Z(2),Z(2)] ];;
gap&gt; V:= LeftModuleByGenerators( GF(16), coll );;
gap&gt; W:= Submodule( V, [ coll[1], coll[2] ] );
&lt;vector space over GF(2^4), with 2 generators&gt;
gap&gt; Parent( W ) = V;
true
</pre>
<p>
<a name = "SSEC002.2"></a>
<li><code>SubmoduleNC( </code><var>M</var><code>, </code><var>gens</var><code> ) F</code>
<li><code>SubmoduleNC( </code><var>M</var><code>, </code><var>gens</var><code>, "basis" ) F</code>
<p>
<code>SubmoduleNC</code> does the same as <code>Submodule</code>, except that it does not check
whether all in <var>gens</var> lie in <var>M</var>.
<p>
<a name = "SSEC002.3"></a>
<li><code>ClosureLeftModule( </code><var>M</var><code>, </code><var>m</var><code> ) O</code>
<p>
is the left module generated by the left module generators of <var>M</var> and the
element <var>m</var>.
<p>
<pre>
gap&gt; V:= LeftModuleByGenerators( Rationals, [ [ 1, 0, 0 ], [ 0, 1, 0 ] ] );
&lt;vector space over Rationals, with 2 generators&gt;
gap&gt; ClosureLeftModule( V, [ 1, 1, 1 ] );
&lt;vector space over Rationals, with 3 generators&gt;
</pre>
<p>
<a name = "SSEC002.4"></a>
<li><code>TrivialSubmodule( </code><var>M</var><code> ) A</code>
<p>
returns the zero submodule of <var>M</var>.
<p>
<pre>
gap&gt; V:= LeftModuleByGenerators( Rationals, [ [ 1, 0, 0 ], [ 0, 1, 0 ] ] );;
gap&gt; TrivialSubmodule( V );
&lt;vector space over Rationals, with 0 generators&gt;
</pre>
<p>
<p>
<h2><a name="SECT003">55.3 Free Modules</a></h2>
<p><p>
<a name = "SSEC003.1"></a>
<li><code>IsFreeLeftModule( </code><var>M</var><code> ) C</code>
<p>
A left module is free as module if it is isomorphic to a direct sum of
copies of its left acting domain.
<p>
Free left modules can have bases.
<p>
The characteristic (see&nbsp;<a href="CHAP030.htm#SSEC010.1">Characteristic</a>) of a free left module
is defined as the characteristic of its left acting domain
(see&nbsp;<a href="CHAP055.htm#SSEC001.11">LeftActingDomain</a>).
<p>
<a name = "SSEC003.2"></a>
<li><code>FreeLeftModule( </code><var>R</var><code>, </code><var>gens</var><code> ) F</code>
<li><code>FreeLeftModule( </code><var>R</var><code>, </code><var>gens</var><code>, </code><var>zero</var><code> ) F</code>
<li><code>FreeLeftModule( </code><var>R</var><code>, </code><var>gens</var><code>, "basis" ) F</code>
<li><code>FreeLeftModule( </code><var>R</var><code>, </code><var>gens</var><code>, </code><var>zero</var><code>, "basis" ) F</code>
<p>
<code>FreeLeftModule( </code><var>R</var><code>, </code><var>gens</var><code> )</code> is the free left module over the ring
<var>R</var>, generated by the vectors in the collection <var>gens</var>.
<p>
If there are three arguments, a ring <var>R</var> and a collection <var>gens</var>
and an element <var>zero</var>,
then <code>FreeLeftModule( </code><var>R</var><code>, </code><var>gens</var><code>, </code><var>zero</var><code> )</code> is the <var>R</var>-free left module
generated by <var>gens</var>, with zero element <var>zero</var>.
<p>
If the last argument is the string <code>"basis"</code> then the vectors in
<var>gens</var> are known to form a basis of the free module.
<p>
It should be noted that the generators <var>gens</var> must be vectors,
that is, they must support an addition and a scalar action of <var>R</var>
via left multiplication.
(See also Section&nbsp;<a href="CHAP030.htm#SECT003">Constructing Domains</a> for the general meaning of
``generators'' in <font face="Gill Sans,Helvetica,Arial">GAP</font>.)
In particular, <code>FreeLeftModule</code> is <strong>not</strong> an equivalent of commands
such as <code>FreeGroup</code> (see&nbsp;<a href="CHAP035.htm#SSEC002.1">FreeGroup</a>) in the sense of a constructor of
a free group on abstract generators;
Such a construction seems to be unnecessary for vector spaces,
for that one can use for example row spaces (see&nbsp;<a href="CHAP059.htm#SSEC008.4">FullRowSpace</a>)
in the finite dimensional case
and polynomial rings (see&nbsp;<a href="CHAP064.htm#SSEC014.1">PolynomialRing</a>) in the infinite dimensional
case.
Moreover, the definition of a ``natural'' addition for elements of a
given magma (for example a permutation group) is possible via the
construction of magma rings (see Chapter <a href="../ref/CHAP063.htm">Magma Rings</a>).
<p>
<pre>
gap&gt; V:= FreeLeftModule( Rationals, [ [ 1, 0, 0 ], [ 0, 1, 0 ] ], "basis" );
&lt;vector space of dimension 2 over Rationals&gt;
</pre>
<p>
<a name = "SSEC003.3"></a>
<li><code>AsFreeLeftModule( </code><var>F</var><code>, </code><var>D</var><code> ) O</code>
<p>
if the domain <var>D</var> is a free left module over <var>F</var>, then
<code>AsFreeLeftModule( </code><var>F</var><code>, </code><var>D</var><code> )</code> returns the domain <var>D</var> viewed as free
 left module over <var>F</var>.
<p>
<a name = "SSEC003.4"></a>
<li><code>Dimension( </code><var>M</var><code> ) A</code>
<p>
A free left module has dimension <i>n</i> if it is isomorphic to a direct sum
of <i>n</i> copies of its left acting domain.
<p>
(We do <strong>not</strong> mark <code>Dimension</code> as invariant under isomorphisms
since we want to call <code>UseIsomorphismRelation</code> also for free left modules
over different left acting domains.)
<p>
<pre>
gap&gt; V:= FreeLeftModule( Rationals, [ [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ] );;
gap&gt; Dimension( V );
2
</pre>
<p>
<a name = "SSEC003.5"></a>
<li><code>IsFiniteDimensional( </code><var>M</var><code> ) P</code>
<p>
is <code>true</code> if <var>M</var> is a free left module that is finite dimensional
over its left acting domain, and <code>false</code> otherwise.
<p>
<pre>
gap&gt; V:= FreeLeftModule( Rationals, [ [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ] );;
gap&gt; IsFiniteDimensional( V );
true
</pre>
<p>
<a name = "SSEC003.6"></a>
<li><code>UseBasis( </code><var>V</var><code>, </code><var>gens</var><code> ) O</code>
<p>
The vectors in the list <var>gens</var> are known to form a basis of the
free left module <var>V</var>.
<code>UseBasis</code> stores information in <var>V</var> that can be derived form this fact,
namely
<ul>
<li>
  <var>gens</var> are stored as left module generators if no such generators were
  bound (this is useful especially if <var>V</var> is an algebra),
<li>
  the dimension of <var>V</var> is stored.
</ul>
<p>
<pre>
gap&gt; V:= FreeLeftModule( Rationals, [ [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ] );;
gap&gt; UseBasis( V, [ [ 1, 0 ], [ 1, 1 ] ] );
gap&gt; V;  # now V knows its dimension
&lt;vector space of dimension 2 over Rationals&gt;
</pre>
<p>
<a name = "SSEC003.7"></a>
<li><code>IsRowModule( </code><var>V</var><code> ) P</code>
<p>
A <strong>row module</strong> is a free left module whose elements are row vectors.
<p>
<a name = "SSEC003.8"></a>
<li><code>IsMatrixModule( </code><var>V</var><code> ) P</code>
<p>
A <strong>matrix module</strong> is a free left module whose elements are matrices.
<p>
<a name = "SSEC003.9"></a>
<li><code>IsFullRowModule( </code><var>M</var><code> ) P</code>
<p>
A <strong>full row module</strong> is a module <i>R</i><sup><i>n</i></sup>,
for a ring <i>R</i> and a nonnegative integer <i>n</i>.
<p>
More precisely, a full row module is a free left module over a ring <i>R</i>
such that the elements are row vectors with entries in <i>R</i> and such that
the dimension is equal to the length of the row vectors.
<p>
Several functions delegate their tasks to full row modules,
for example <code>Iterator</code> and <code>Enumerator</code>.
<p>
<a name = "SSEC003.10"></a>
<li><code>FullRowModule( </code><var>R</var><code>, </code><var>n</var><code> ) F</code>
<p>
is the row module <code></code><var>R</var><code>^</code><var>n</var><code></code>,
for a ring <var>R</var> and a nonnegative integer <var>n</var>.
<p>
<pre>
gap&gt; V:= FullRowModule( Integers, 5 );
( Integers^5 )
</pre>
<p>
<a name = "SSEC003.11"></a>
<li><code>IsFullMatrixModule( </code><var>M</var><code> ) P</code>
<p>
A <strong>full matrix module</strong> is a module <i>R</i><sup>[<i>m</i>,<i>n</i>]</sup>,
for a ring <i>R</i> and two nonnegative integers <i>m</i>, <i>n</i>.
<p>
More precisely, a full matrix module is a free left module over a ring
<i>R</i> such that the elements are matrices with entries in <i>R</i>
and such that the dimension is equal to the number of entries in each
matrix.
<p>
<a name = "SSEC003.12"></a>
<li><code>FullMatrixModule( </code><var>R</var><code>, </code><var>m</var><code>, </code><var>n</var><code> ) F</code>
<p>
is the row module <code></code><var>R</var><code>^[</code><var>m</var><code>,</code><var>n</var><code>]</code>,
for a ring <var>R</var> and nonnegative integers <var>m</var> and <var>n</var>.
<p>
<pre>
gap&gt; FullMatrixModule( GaussianIntegers, 3, 6 );
( GaussianIntegers^[ 3, 6 ] )
</pre>
<p>
<a name = "SSEC003.13"></a>
<li><code>IsHandledByNiceBasis( </code><var>M</var><code> ) C</code>
<p>
For a free left module <var>M</var> in this category, essentially all operations
are performed using a ``nicer'' free left module,
which is usually a row module.
<p>
<p>
[<a href="../index.htm">Top</a>] [<a href = "chapters.htm">Up</a>] [<a href ="CHAP054.htm">Previous</a>] [<a href ="CHAP056.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<P>
<font face="Gill Sans,Helvetica,Arial">GAP 4 manual<br>October 2007
</font></body></html>