<html><head><title>[ref] 56 Fields and Division Rings</title></head>
<body text="#000000" bgcolor="#ffffff">
[<a href="../index.htm">Top</a>] [<a href = "chapters.htm">Up</a>] [<a href ="CHAP055.htm">Previous</a>] [<a href ="CHAP057.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<h1>56 Fields and Division Rings</h1><p>
<P>
<H3>Sections</H3>
<oL>
<li> <A HREF="CHAP056.htm#SECT001">Generating Fields</a>
<li> <A HREF="CHAP056.htm#SECT002">Subfields of Fields</a>
<li> <A HREF="CHAP056.htm#SECT003">Galois Action</a>
</ol><p>
<p>
<a name = "I0"></a>

<a name = "I1"></a>

A <strong>division ring</strong> is a ring (see Chapter&nbsp;<a href="CHAP054.htm">Rings</a>) in which every non-zero
element has an inverse.
The most important class of division rings are the commutative ones,
which are called <strong>fields</strong>.
<p>
<font face="Gill Sans,Helvetica,Arial">GAP</font> supports finite fields (see Chapter&nbsp;<a href="CHAP057.htm">Finite Fields</a>) and
abelian number fields (see Chapter&nbsp;<a href="CHAP058.htm">Abelian Number Fields</a>),
in particular the field of rationals (see Chapter&nbsp;<a href="CHAP016.htm">Rational Numbers</a>).
<p>
This chapter describes the general <font face="Gill Sans,Helvetica,Arial">GAP</font> functions for fields and
division rings.
<p>
If a field <var>F</var> is a subfield of a commutative ring <var>C</var>,
<var>C</var> can be considered as a vector space over the (left) acting domain
<var>F</var> (see Chapter&nbsp;<a href="CHAP059.htm">Vector Spaces</a>).
In this situation, we call <var>F</var> the <strong>field of definition</strong> of <var>C</var>.
<p>
Each field in <font face="Gill Sans,Helvetica,Arial">GAP</font> is represented as a vector space over a subfield
(see&nbsp;<a href="CHAP056.htm#SSEC001.2">IsField</a>), thus each field is in fact a field extension in a
natural way, which is used by functions such as <code>Norm</code> and <code>Trace</code>
(see&nbsp;<a href="CHAP056.htm#SECT003">Galois Action</a>).
<p>
<p>
<h2><a name="SECT001">56.1 Generating Fields</a></h2>
<p><p>
<a name = "SSEC001.1"></a>
<li><code>IsDivisionRing( </code><var>D</var><code> ) C</code>
<p>
A <strong>division ring</strong> in <font face="Gill Sans,Helvetica,Arial">GAP</font> is a nontrivial associative algebra <var>D</var>
with a multiplicative inverse for each nonzero element.
In <font face="Gill Sans,Helvetica,Arial">GAP</font> every division ring is a vector space over a division ring
(possibly over itself).
Note that being a division ring is thus not a property that a ring can
get, because a ring is usually not represented as a vector space.
<p>
The field of coefficients is stored as <code>LeftActingDomain( </code><var>D</var><code> )</code>.
<p>
<a name = "SSEC001.2"></a>
<li><code>IsField( </code><var>D</var><code> ) P</code>
<p>
A <strong>field</strong> is a commutative division ring
(see&nbsp;<a href="CHAP056.htm#SSEC001.1">IsDivisionRing</a> and&nbsp;<a href="CHAP033.htm#SSEC004.9">IsCommutative</a>).
<p>
<pre>
gap&gt; IsField( GaloisField(16) );           # the field with 16 elements
true
gap&gt; IsField( Rationals );                 # the field of rationals
true
gap&gt; q:= QuaternionAlgebra( Rationals );;  # a noncommutative division ring
gap&gt; IsField( q );  IsDivisionRing( q );
false
true
gap&gt; mat:= [ [ 1 ] ];;  a:= Algebra( Rationals, [ mat ] );;
gap&gt; IsDivisionRing( a );   # an algebra not constructed as a division ring
false
</pre>
<p>
<a name = "SSEC001.3"></a>
<li><code>Field( </code><var>z</var><code>, ... ) F</code>
<li><code>Field( </code><var>list</var><code> ) F</code>
<li><code>Field( </code><var>F</var><code>, </code><var>list</var><code> ) F</code>
<p>
<code>Field</code> returns the smallest field <i>K</i> that contains all the elements
<i>z</i> , &#8230;,
or the smallest field <i>K</i> that contains all elements in the list <var>list</var>.
If no subfield <var>F</var> is given, <i>K</i> is constructed as a field over itself,
i.e. the left acting domain of <i>K</i> is <i>K</i>.
In the third form, <code>Field</code> constructs the field generated by the
field <var>F</var> and the elements in the list <var>list</var>,
as a vector space over <var>F</var>.
<p>
<a name = "SSEC001.4"></a>
<li><code>DefaultField( </code><var>z</var><code>, ... ) F</code>
<li><code>DefaultField( </code><var>list</var><code> ) F</code>
<p>
<code>DefaultField</code> returns a field <i>K</i> that contains all the elements
<i>z</i> , &#8230;,
or a field <i>K</i> that contains all elements in the list <var>list</var>.
<p>
This field need not be the smallest field in which the elements lie,
cf.&nbsp;<code>Field</code> (see&nbsp;<a href="CHAP056.htm#SSEC001.3">Field</a>).
For example, for elements from cyclotomic fields <code>DefaultField</code> returns
the smallest cyclotomic field in which the elements lie,
but the elements may lie in a smaller number field
which is not a cyclotomic field.
<p>
<pre>
gap&gt; Field( Z(4) );  Field( [ Z(4), Z(8) ] );  # finite fields
GF(2^2)
GF(2^6)
gap&gt; Field( E(9) );  Field( CF(4), [ E(9) ] ); # abelian number fields
CF(9)
AsField( GaussianRationals, CF(36) )
gap&gt; f1:= Field( EB(5) );  f2:= DefaultField( EB(5) );
NF(5,[ 1, 4 ])
CF(5)
gap&gt; f1 = f2;  IsSubset( f2, f1 );
false
true
</pre>
<p>
<a name = "SSEC001.5"></a>
<li><code>DefaultFieldByGenerators( [ </code><var>z</var><code>, ... ] ) O</code>
<p>
returns the default field containing the elements <var>z</var>,&#8230;.
This field may be bigger than the smallest field containing these
elements.
<p>
<a name = "SSEC001.6"></a>
<li><code>GeneratorsOfDivisionRing( </code><var>D</var><code> ) A</code>
<p>
generators with respect to addition, multiplication, and taking inverses
(the identity cannot be omitted ...)
<p>
<a name = "SSEC001.7"></a>
<li><code>GeneratorsOfField( </code><var>F</var><code> ) A</code>
<p>
generators with respect to addition, multiplication, and taking
inverses. This attribute is the same as <code>GeneratorsOfDivisionRing</code>
(see&nbsp;<a href="CHAP056.htm#SSEC001.6">GeneratorsOfDivisionRing</a>).
<p>
<a name = "SSEC001.8"></a>
<li><code>DivisionRingByGenerators( [ </code><var>z</var><code>, ... ] ) O</code>
<li><code>DivisionRingByGenerators( </code><var>F</var><code>, [ </code><var>z</var><code>, ... ] ) O</code>
<p>
The first version returns a division ring as vector space over
<code>FieldOverItselfByGenerators( </code><var>gens</var><code> )</code>.
<p>
<a name = "SSEC001.9"></a>
<li><code>AsDivisionRing( </code><var>C</var><code> ) O</code>
<li><code>AsDivisionRing( </code><var>F</var><code>, </code><var>C</var><code> ) O</code>
<a name = "SSEC001.9"></a>
<li><code>AsField( </code><var>C</var><code> ) O</code>
<li><code>AsField( </code><var>F</var><code>, </code><var>C</var><code> ) O</code>
<p>
If the collection <var>C</var> can be regarded as a division ring then
<code>AsDivisionRing( </code><var>C</var><code> )</code> is the division ring that consists of the
elements of <var>C</var>, viewed as a vector space over its prime field;
otherwise <code>fail</code> is returned.
<p>
In the second form, if <var>F</var> is a division ring contained in <var>C</var> then
the returned division ring is viewed as a vector space over <var>F</var>.
<p>
<code>AsField</code> is just a synonym for <code>AsDivisionRing</code>.
<p>
<p>
<h2><a name="SECT002">56.2 Subfields of Fields</a></h2>
<p><p>
<a name = "SSEC002.1"></a>
<li><code>Subfield( </code><var>F</var><code>, </code><var>gens</var><code> ) F</code>
<a name = "SSEC002.1"></a>
<li><code>SubfieldNC( </code><var>F</var><code>, </code><var>gens</var><code> ) F</code>
<p>
Constructs the subfield of <var>F</var> generated by <var>gens</var>.
<p>
<a name = "SSEC002.2"></a>
<li><code>FieldOverItselfByGenerators( [ </code><var>z</var><code>, ... ] ) O</code>
<p>
This  operation is  needed for  the  call of <code>Field</code> or
<code>FieldByGenerators</code>
without  explicitly given subfield, in  order to construct  a left acting
domain for such a field.
<p>
<a name = "SSEC002.3"></a>
<li><code>PrimitiveElement( </code><var>D</var><code> ) A</code>
<p>
is an element of <var>D</var> that generates <var>D</var> as a division ring together with
the left acting domain.
<p>
<a name = "SSEC002.4"></a>
<li><code>PrimeField( </code><var>D</var><code> ) A</code>
<p>
The <strong>prime field</strong> of a division ring <var>D</var> is the smallest field which is
contained in <var>D</var>.
For example, the prime field of any field in characteristic zero
is isomorphic to the field of rational numbers.
<p>
<a name = "SSEC002.5"></a>
<li><code>IsPrimeField( </code><var>D</var><code> ) P</code>
<p>
A division ring is a prime field if it is equal to its prime field
(see&nbsp;<a href="CHAP056.htm#SSEC002.4">PrimeField</a>).
<p>
<a name = "SSEC002.6"></a>
<li><code>DegreeOverPrimeField( </code><var>F</var><code> ) A</code>
<p>
is the degree of the field <var>F</var> over its prime field (see&nbsp;<a href="CHAP056.htm#SSEC002.4">PrimeField</a>).
<p>
<a name = "SSEC002.7"></a>
<li><code>DefiningPolynomial( </code><var>F</var><code> ) A</code>
<p>
is the defining polynomial of the field <var>F</var> as a field extension
over the left acting domain of <var>F</var>.
A root of the defining polynomial can be computed with
<code>RootOfDefiningPolynomial</code> (see&nbsp;<a href="CHAP056.htm#SSEC002.8">RootOfDefiningPolynomial</a>).
<p>
<a name = "SSEC002.8"></a>
<li><code>RootOfDefiningPolynomial( </code><var>F</var><code> ) A</code>
<p>
is a root in the field <var>F</var> of its defining polynomial as a field
extension over the left acting domain of <var>F</var>.
The defining polynomial can be computed with
<code>DefiningPolynomial</code> (see&nbsp;<a href="CHAP056.htm#SSEC002.7">DefiningPolynomial</a>).
<p>
<a name = "SSEC002.9"></a>
<li><code>FieldExtension( </code><var>F</var><code>, </code><var>poly</var><code> ) O</code>
<p>
is the field obtained on adjoining a root of the irreducible polynomial
<var>poly</var> to the field <var>F</var>.
<p>
<a name = "SSEC002.10"></a>
<li><code>Subfields( </code><var>F</var><code> ) A</code>
<p>
is the set of all subfields of the field <var>F</var>.
<p>
<p>
<h2><a name="SECT003">56.3 Galois Action</a></h2>
<p><p>
Let <i>L</i>  &gt;  <i>K</i> be a field extension of finite degree.
Then to each element &#945; &#8712; <i>L</i>, we can associate a <i>K</i>-linear
mapping &#981;<sub>&#945;</sub> on <i>L</i>, and for a fixed <i>K</i>-basis of <i>L</i>,
we can associate to &#945; the matrix <i>M</i><sub>&#945;</sub> (over <i>K</i>)
of this mapping.
<p>
The <strong>norm</strong> of &#945; is defined as the determinant of <i>M</i><sub>&#945;</sub>,
the <strong>trace</strong> of &#945; is defined as the trace of <i>M</i><sub>&#945;</sub>,
the <strong>minimal polynomial</strong> &#956;<sub>&#945;</sub> and the
<strong>trace polynomial</strong> &#967;<sub>&#945;</sub> of &#945;
are defined as the minimal polynomial (see&nbsp;<a href="CHAP056.htm#SSEC003.2">MinimalPolynomial!over a field</a>)
and the characteristic polynomial (see&nbsp;<a href="CHAP024.htm#SSEC012.1">CharacteristicPolynomial</a> and
<a href="CHAP056.htm#SSEC003.3">TracePolynomial</a>) of <i>M</i><sub>&#945;</sub>.
(Note that &#956;<sub>&#945;</sub> depends only on <i>K</i> whereas &#967;<sub>&#945;</sub>
depends on both <i>L</i> and <i>K</i>.)
<p>
Thus norm and trace of &#945; are elements of <i>K</i>,
and &#956;<sub>&#945;</sub> and &#967;<sub>&#945;</sub> are polynomials over <i>K</i>,
&#967;<sub>&#945;</sub> being a power of &#956;<sub>&#945;</sub>,
and the degree of &#967;<sub>&#945;</sub> equals the degree of the field
extension <i>L</i>  &gt;  <i>K</i>.
<p>
The <strong>conjugates</strong> of &#945; in <i>L</i> are those roots of &#967;<sub>&#945;</sub>
(with multiplicity) that lie in <i>L</i>;
note that if only <i>L</i> is given, there is in general no way to access
the roots outside <i>L</i>.
<p>
Analogously, the <strong>Galois group</strong> of the extension <i>L</i>  &gt;  <i>K</i> is defined as
the group of all those field automorphisms of <i>L</i> that fix <i>K</i>
pointwise.
<p>
If <i>L</i>  &gt;  <i>K</i> is a Galois extension then the conjugates of &#945; are
all roots of &#967;<sub>&#945;</sub> (with multiplicity),
the set of conjugates equals the roots of &#956;<sub>&#945;</sub>,
the norm of &#945; equals the product and the trace of &#945;
equals the sum of the conjugates of &#945;,
and the Galois group in the sense of the above definition equals
the usual Galois group,
<p>
Note that <code>MinimalPolynomial( </code><var>F</var><code>, </code><var>z</var><code> )</code> is a polynomial <strong>over</strong> <var>F</var>,
whereas <code>Norm( </code><var>F</var><code>, </code><var>z</var><code> )</code> is the norm of the element <var>z</var> <strong>in</strong> <var>F</var>
w.r.t.&nbsp;the field extension <i>F</i> &gt;    <tt>LeftActingDomain</tt><tt>(</tt> <i>F</i>  <tt>)</tt>.
<p>
<a name = "I2"></a>

<a name = "SSEC003.1"></a>
<li><code>GaloisGroup( </code><var>F</var><code> ) A</code>
<p>
The <strong>Galois group</strong> of a field <var>F</var> is the group of all field automorphisms
of <var>F</var> that fix the subfield <i>K</i> = <tt>LeftActingDomain</tt><tt>(</tt> <i>F</i>  <tt>)</tt> pointwise.
<p>
Note that the field extension <i>F</i> &gt;    <i>K</i> need <strong>not</strong> be a Galois extension.
<p>
<pre>
gap&gt; g:= GaloisGroup( AsField( GF(2^2), GF(2^12) ) );;
gap&gt; Size( g );  IsCyclic( g );
6
true
gap&gt; h:= GaloisGroup( CF(60) );;
gap&gt; Size( h );  IsAbelian( h );
16
true
</pre>
<p>
<a name = "SSEC003.2"></a>
<li><code>MinimalPolynomial( </code><var>F</var><code>, </code><var>z</var><code>[, </code><var>ind</var><code>] ) O</code>
<p>
returns the minimal polynomial of <var>z</var> over the field <var>F</var>.
This is a generator of the ideal in <i>F</i> [<i>x</i>] of all polynomials
which vanish on <var>z</var>.
(This definition is consistent with the general definition of
<code>MinimalPolynomial</code> for rings, see&nbsp;<a href="CHAP064.htm#SSEC008.1">MinimalPolynomial</a>.)
<p>
<pre>
gap&gt; MinimalPolynomial( Rationals, E(8) );
x_1^4+1
gap&gt; MinimalPolynomial( CF(4), E(8) );
x_1^2+(-E(4))
gap&gt; MinimalPolynomial( CF(8), E(8) );
x_1+(-E(8))
</pre>
<p>
<a name = "SSEC003.3"></a>
<li><code>TracePolynomial( </code><var>L</var><code>, </code><var>K</var><code>, </code><var>z</var><code>[, </code><var>inum</var><code>] ) O</code>
<p>
returns the polynomial that is the product of (<i>X</i> &#8722; <i>c</i>) where <i>c</i> runs
over the conjugates of <var>z</var> in the field extension <var>L</var> over <var>K</var>.
The polynomial is returned as a univariate polynomial over <var>K</var> in the
indeterminate number <var>inum</var> (defaulting to 1).
<p>
This polynomial is sometimes also called the <strong>characteristic polynomial</strong>
of <var>z</var> w.r.t.&nbsp;the field extension <i>L</i> &gt;    <i>K</i> .
Therefore methods are installed for <code>CharacteristicPolynomial</code>
(see&nbsp;<a href="CHAP024.htm#SSEC012.1">CharacteristicPolynomial</a>)
that call <code>TracePolynomial</code> in the case of field extensions.
<p>
<a name = "I3"></a>

<pre>
gap&gt; TracePolynomial( CF(8), Rationals, E(8) );
x_1^4+1
gap&gt; TracePolynomial( CF(16), Rationals, E(8) );
x_1^8+2*x_1^4+1
</pre>
<p>
<a name = "SSEC003.4"></a>
<li><code>Norm( </code><var>z</var><code> ) A</code>
<li><code>Norm( </code><var>L</var><code>, </code><var>z</var><code> ) O</code>
<li><code>Norm( </code><var>L</var><code>, </code><var>K</var><code>, </code><var>z</var><code> ) O</code>
<p>
<code>Norm</code> returns the norm of the field element <var>z</var>.
If two fields <var>L</var> and <var>K</var> are given then the norm is computed
w.r.t.&nbsp;the field extension <i>L</i> &gt;    <i>K</i> ,
if only one field <var>L</var> is given then <code>LeftActingDomain( </code><var>L</var><code> )</code> is taken as
default for the subfield <var>K</var>,
and if no field is given then <code>DefaultField( </code><var>z</var><code> )</code> is taken as default
for <var>L</var>.
<p>
<a name = "SSEC003.5"></a>
<li><code>Trace( </code><var>z</var><code> ) A</code>
<li><code>Trace( </code><var>mat</var><code> ) A</code>
<li><code>Trace( </code><var>L</var><code>, </code><var>z</var><code> ) O</code>
<li><code>Trace( </code><var>L</var><code>, </code><var>K</var><code>, </code><var>z</var><code> ) O</code>
<p>
<code>Trace</code> returns the trace of the field element <var>z</var>.
If two fields <var>L</var> and <var>K</var> are given then the trace is computed
w.r.t.&nbsp;the field extension <i>L</i> &gt;    <i>K</i> ,
if only one field <var>L</var> is given then <code>LeftActingDomain( </code><var>L</var><code> )</code> is taken as
default for the subfield <var>K</var>,
and if no field is given then <code>DefaultField( </code><var>z</var><code> )</code> is taken as default
for <var>L</var>.
<p>
The <strong>trace of a matrix</strong> is the sum of its diagonal entries.
Note that this is <strong>not</strong> compatible with the definition of <code>Trace</code> for
field elements,
so the one-argument version is not suitable when matrices shall be
regarded as field elements.
<p>
<a name = "SSEC003.6"></a>
<li><code>Conjugates( </code><var>z</var><code> ) A</code>
<li><code>Conjugates( </code><var>L</var><code>, </code><var>z</var><code> ) O</code>
<li><code>Conjugates( </code><var>L</var><code>, </code><var>K</var><code>, </code><var>z</var><code> ) O</code>
<p>
<code>Conjugates</code> returns the list of <strong>conjugates</strong> of the field element <var>z</var>.
If two fields <var>L</var> and <var>K</var> are given then the conjugates are computed
w.r.t.&nbsp;the field extension <i>L</i> &gt;    <i>K</i> ,
if only one field <var>L</var> is given then <code>LeftActingDomain( </code><var>L</var><code> )</code> is taken as
default for the subfield <var>K</var>,
and if no field is given then <code>DefaultField( </code><var>z</var><code> )</code> is taken as default
for <var>L</var>.
<p>
The result list will contain duplicates if <var>z</var> lies in a proper subfield
of <var>L</var>, respectively of the default field of <var>z</var>.
The result list need not be sorted.
<p>
<pre>
gap&gt; Norm( E(8) );  Norm( CF(8), E(8) );
1
1
gap&gt; Norm( CF(8), CF(4), E(8) );
-E(4)
gap&gt; Norm( AsField( CF(4), CF(8) ), E(8) );
-E(4)
gap&gt; Trace( E(8) );  Trace( CF(8), CF(8), E(8) );
0
E(8)
gap&gt; Conjugates( CF(8), E(8) );
[ E(8), E(8)^3, -E(8), -E(8)^3 ]
gap&gt; Conjugates( CF(8), CF(4), E(8) );
[ E(8), -E(8) ]
gap&gt; Conjugates( CF(16), E(8) );
[ E(8), E(8)^3, -E(8), -E(8)^3, E(8), E(8)^3, -E(8), -E(8)^3 ]
</pre>
<p>
The default methods for field elements are as follows.
<code>MinimalPolynomial</code> solves a system of linear equations,
<code>TracePolynomial</code> computes the appropriate power of the minimal
polynomial,
<code>Norm</code> and <code>Trace</code> values are obtained as coefficients of the
characteristic polynomial,
and <code>Conjugates</code> uses the factorization of the characteristic polynomial.
<p>
For elements in finite fields and cyclotomic fields, one wants to do the
computations in a different way since the field extensions in question
are Galois extensions, and the Galois groups are well-known in these
cases.
More general,
if a field is in the category <code>IsFieldControlledByGaloisGroup</code> then
the default methods are the following.
<code>Conjugates</code> returns the sorted list of images (with multiplicity) of the
element under the Galois group,
<code>Norm</code> computes the product of the conjugates,
<code>Trace</code> computes the sum of the conjugates,
<code>TracePolynomial</code> and <code>MinimalPolynomial</code> compute the product of
linear factors <i>x</i> &#8722; <i>c</i> with <i>c</i> ranging over the conjugates and the set
of conjugates, respectively.
<p>
<a name = "SSEC003.7"></a>
<li><code>NormalBase( </code><var>F</var><code> ) A</code>
<li><code>NormalBase( </code><var>F</var><code>, </code><var>elm</var><code> ) O</code>
<p>
Let <var>F</var> be a field that is a Galois extension of its subfield
<code>LeftActingDomain( </code><var>F</var><code> )</code>.
Then <code>NormalBase</code> returns a list of elements in <var>F</var> that form a normal
basis of <var>F</var>, that is, a vector space basis that is closed under the
action of the Galois group (see&nbsp;<a href="CHAP056.htm#SSEC003.1">GaloisGroup!of field</a>) of <var>F</var>.
<p>
If a second argument <var>elm</var> is given,
it is used as a hint for the algorithm to find a normal basis with the
algorithm described in&nbsp;<a href="biblio.htm#Art68"><cite>Art68</cite></a>.
<p>
<pre>
gap&gt; NormalBase( CF(5) );
[ -E(5), -E(5)^2, -E(5)^3, -E(5)^4 ]
gap&gt; NormalBase( CF(4) );
[ 1/2-1/2*E(4), 1/2+1/2*E(4) ]
gap&gt; NormalBase( GF(3^6) );
[ Z(3^6)^2, Z(3^6)^6, Z(3^6)^18, Z(3^6)^54, Z(3^6)^162, Z(3^6)^486 ]
gap&gt; NormalBase( GF( GF(8), 2 ) );
[ Z(2^6), Z(2^6)^8 ]
</pre>
<p>
<p>
[<a href="../index.htm">Top</a>] [<a href = "chapters.htm">Up</a>] [<a href ="CHAP055.htm">Previous</a>] [<a href ="CHAP057.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<P>
<font face="Gill Sans,Helvetica,Arial">GAP 4 manual<br>September 2006
</font></body></html>