<html><head><title>[ref] 6 Main Loop and Break Loop</title></head>
<body text="#000000" bgcolor="#ffffff">
[<a href="../index.htm">Top</a>] [<a href = "chapters.htm">Up</a>] [<a href ="CHAP005.htm">Previous</a>] [<a href ="CHAP007.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<h1>6 Main Loop and Break Loop</h1><p>
<P>
<H3>Sections</H3>
<oL>
<li> <A HREF="CHAP006.htm#SECT001">Main Loop</a>
<li> <A HREF="CHAP006.htm#SECT002">Special Rules for Input Lines</a>
<li> <A HREF="CHAP006.htm#SECT003">View and Print</a>
<li> <A HREF="CHAP006.htm#SECT004">Break Loops</a>
<li> <A HREF="CHAP006.htm#SECT005">Variable Access in a Break Loop</a>
<li> <A HREF="CHAP006.htm#SECT006">Error</a>
<li> <A HREF="CHAP006.htm#SECT007">ErrorCount</a>
<li> <A HREF="CHAP006.htm#SECT008">Leaving GAP</a>
<li> <A HREF="CHAP006.htm#SECT009">Line Editing</a>
<li> <A HREF="CHAP006.htm#SECT010">Editing Files</a>
<li> <A HREF="CHAP006.htm#SECT011">Editor Support</a>
<li> <A HREF="CHAP006.htm#SECT012">SizeScreen</a>
</ol><p>
<p>
This chapter is a first of a series of chapters that describe the
interactive environment in which you use <font face="Gill Sans,Helvetica,Arial">GAP</font>.
<p>
<p>
<h2><a name="SECT001">6.1 Main Loop</a></h2>
<p><p>
<a name = "I0"></a>

<a name = "I0"></a>
<a name = "I1"></a>

<a name = "I2"></a>

<a name = "I2"></a>
<a name = "I3"></a>

<a name = "I4"></a>

<a name = "I4"></a>
<a name = "I5"></a>

<a name = "I6"></a>

<a name = "I7"></a>

<a name = "I7"></a>
<a name = "I8"></a>

The normal interaction with <font face="Gill Sans,Helvetica,Arial">GAP</font> happens in the so-called
<strong>read-eval-print</strong> loop.
This means that you type an input, <font face="Gill Sans,Helvetica,Arial">GAP</font> first reads it,
evaluates it, and then shows the result.
Note that the term <strong>print</strong> may be confusing since there is a <font face="Gill Sans,Helvetica,Arial">GAP</font>
function called <code>Print</code> (see&nbsp;<a href="CHAP006.htm#SECT003">View and Print</a>) which is in fact <strong>not</strong>
used in the read-eval-print loop, but traditions are hard to break.
In the following, whenever we want to express that <font face="Gill Sans,Helvetica,Arial">GAP</font> places some
characters on the standard output, we will say that <font face="Gill Sans,Helvetica,Arial">GAP</font> <strong>shows</strong>
something.
<p>
The exact sequence in the read-eval-print loop is as follows.
<p>
To signal that it is ready to accept your input,
<font face="Gill Sans,Helvetica,Arial">GAP</font> shows the <strong>prompt</strong> <code>gap&gt;</code>.
When you see this, you know that <font face="Gill Sans,Helvetica,Arial">GAP</font> is waiting for your input.
<p>
Note that every statement must be terminated by a semicolon. You must
also enter <var>return</var> (i.e., strike the ``return'' key)
before <font face="Gill Sans,Helvetica,Arial">GAP</font> starts to read and evaluate your input.
(The ``return'' key may actually be marked with the word <code>Enter</code> and a
returning arrow on your terminal.)
Because <font face="Gill Sans,Helvetica,Arial">GAP</font> does not do anything until you enter <var>return</var>, you can
edit your input to fix typos and only when everything is correct enter
<var>return</var> and have <font face="Gill Sans,Helvetica,Arial">GAP</font> take a look at it (see&nbsp;<a href="CHAP006.htm#SECT009">Line Editing</a>). It is
also possible to enter several statements as input on a single line. Of
course each statement must be terminated by a semicolon.
<p>
It is absolutely acceptable to enter a single statement on several lines.
When you have entered the beginning of a statement, but the statement is
not yet complete, and you enter <var>return</var>,
<font face="Gill Sans,Helvetica,Arial">GAP</font> will show the <strong>partial prompt</strong> <code>&gt;</code>.
When you see this, you know that <font face="Gill Sans,Helvetica,Arial">GAP</font> is waiting for the rest
of the statement. This happens also when you forget
the semicolon <code>;</code> that terminates every <font face="Gill Sans,Helvetica,Arial">GAP</font> statement.
Note that when <var>return</var> has been entered and the current statement is not
yet complete, <font face="Gill Sans,Helvetica,Arial">GAP</font> will already evaluate those parts of the input that 
are complete, for example function calls that appear as arguments in
another function call which needs several input lines.
So it may happen that one has to wait some time for the partial prompt.
<p>
When you enter <var>return</var>, <font face="Gill Sans,Helvetica,Arial">GAP</font> first checks your input to see if it is
syntactically correct (see Chapter&nbsp;<a href="CHAP004.htm">The Programming Language</a> for the
definition of syntactically correct). If it is not, <font face="Gill Sans,Helvetica,Arial">GAP</font> prints an
error message of the following form
<p>
<pre>
gap&gt; 1 * ;
Syntax error: expression expected
1 * ;
    ^
</pre>
<p>
The first line tells you what is wrong about the input, in this case the
<code>*</code> operator takes two expressions as operands, so obviously the right
one is missing. If the input came from a file (see&nbsp;<a href="CHAP009.htm#SSEC007.1">Read</a>), this line
will also contain the filename and the line number. The second line is a
copy of the input. And the third line contains a caret pointing to the
place in the previous line where <font face="Gill Sans,Helvetica,Arial">GAP</font> realized that something is wrong.
This need not be the exact place where the error is, but it is usually
quite close.
<p>
Sometimes, you will also see a partial prompt after you have entered an
input that is syntactically incorrect. This is because <font face="Gill Sans,Helvetica,Arial">GAP</font> is so
confused by your input, that it thinks that there is still something to
follow. In this case you should enter <code>;</code><var>return</var><code></code> repeatedly, ignoring
further error messages, until you see the full prompt again. When you
see the full prompt, you know that <font face="Gill Sans,Helvetica,Arial">GAP</font> forgave you and is now ready to
accept your next -- hopefully correct -- input.
<p>
If your input is syntactically correct, <font face="Gill Sans,Helvetica,Arial">GAP</font> evaluates or executes it,
i.e., performs the required computations (see Chapter&nbsp;<a href="CHAP004.htm">The Programming Language</a> for the definition of the evaluation).
<p>
If you do not see a prompt, you know that <font face="Gill Sans,Helvetica,Arial">GAP</font> is still working on your
last input. Of course, you can <strong>type ahead</strong>, i.e., already start
entering new input, but it will not be accepted by <font face="Gill Sans,Helvetica,Arial">GAP</font> until <font face="Gill Sans,Helvetica,Arial">GAP</font>
has completed the ongoing computation.
<p>
When <font face="Gill Sans,Helvetica,Arial">GAP</font> is ready it will usually show the result of the computation,
i.e., the value computed. Note that not all statements produce a value,
for example, if you enter a <code>for</code> loop, nothing will be printed, because
the <code>for</code> loop does not produce a value that could be shown.
<p>
Also sometimes you do not want to see the result. For example if you
have computed a value and now want to assign the result to a variable,
you probably do not want to see the value again. You can terminate
statements by <strong>two semicolons</strong> to suppress showing the result.
<p>
If you have entered several statements on a single line <font face="Gill Sans,Helvetica,Arial">GAP</font> will first
read, evaluate, and show the first one, then read, evaluate, and show
the second one, and so on. This means that the second statement will not
even be checked for syntactical correctness until <font face="Gill Sans,Helvetica,Arial">GAP</font> has completed
the first computation.
<p>
After the result has been shown <font face="Gill Sans,Helvetica,Arial">GAP</font> will display another prompt, and
wait for your next input.
And the whole process starts all over again.
Note that if you have entered several statements on a single line,
a new prompt will only be printed after <font face="Gill Sans,Helvetica,Arial">GAP</font> has read, evaluated,
and shown the last statement.
<p>
In each statement that you enter, the result of the previous statement
that produced a value is available in the variable <code>last</code>. The next to
previous result is available in <code>last2</code> and the result produced before
that is available in <code>last3</code>.
<p>
<pre>
gap&gt; 1; 2; 3;
1
2
3
gap&gt; last3 + last2 * last;
7
</pre>
<p>
Also in each statement the time spent by the last statement, whether it
produced a value or not, is available in the variable <code>time</code>. This is an
integer that holds the number of milliseconds.
<p>
<p>
<h2><a name="SECT002">6.2 Special Rules for Input Lines</a></h2>
<p><p>
The input for some <font face="Gill Sans,Helvetica,Arial">GAP</font> objects may not fit on one line, in particular 
big integers, long strings or long identifiers. In these cases you can still
type or paste them in long single lines, but on screen you will only
see the last part (with a <code>$</code> character in front). For nicer display you
can also specify  the input on several lines. This is achieved by ending a
line  by a backslash or by a backslash and a carriage return character, then
continue the input on the beginning of the next line. When reading this 
<font face="Gill Sans,Helvetica,Arial">GAP</font> will ignore such continuation backslashes, carriage return characters 
and newline characters. <font face="Gill Sans,Helvetica,Arial">GAP</font> also prints long strings and integers this way.
<p>
<pre>
gap&gt; n := 1234\
&gt; 567890;
1234567890
gap&gt; "This is a very long string that does not fit on a line \
gap&gt; and is therefore continued on the next line.";
"This is a very long string that does not fit on a line and is therefore conti\
nued on the next line."
gap&gt; bla\
gap&gt; bla := 5;; blabla;
5
</pre>
<p>
There is a special rule about <font face="Gill Sans,Helvetica,Arial">GAP</font> prompts in input lines: In line editing 
mode (usual user input and <font face="Gill Sans,Helvetica,Arial">GAP</font> started without <code>-n</code>)  in lines starting 
with <code>gap&gt; </code>, <code>&gt; </code> or <code>brk&gt; </code> this beginning part is removed. This rule is very convenient because it allows to cut and paste input from other <font face="Gill Sans,Helvetica,Arial">GAP</font> sessions
or manual examples easily into your current session.
<p>
<p>
<h2><a name="SECT003">6.3 View and Print</a></h2>
<p><p>
<a name = "SSEC003.1"></a>
<li><code>View( </code><var>obj1</var><code>, </code><var>obj2</var><code>... ) F</code>
<p>
<code>View</code> shows the objects <var>obj1</var>, <var>obj2</var>... etc. <strong>in a short form</strong>
on the standard output.
<code>View</code> is called in the read--eval--print loop,
thus the output looks exactly like the representation of the
objects shown by the main loop.
Note that no space or newline is printed between the objects.
<p>
<a name = "SSEC003.2"></a>
<li><code>Print( </code><var>obj1</var><code>, </code><var>obj2</var><code>... ) F</code>
<p>
Also <code>Print</code> shows the objects <var>obj1</var>, <var>obj2</var>... etc.
on the standard output.
The difference compared to <code>View</code> is in general that the shown form
is not required to be short,
and that in many cases the form shown by <code>Print</code> is <font face="Gill Sans,Helvetica,Arial">GAP</font> readable.
<p>
<pre>
gap&gt; z:= Z(2);
Z(2)^0
gap&gt; v:= [ z, z, z, z, z, z, z ];
[ Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0 ]
gap&gt; ConvertToVectorRep(v);; v;
&lt;a GF2 vector of length 7&gt;
gap&gt; Print( v );
[ Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0 ]gap&gt; 
</pre>
<p>
Another difference is that <code>Print</code> shows strings without the enclosing
quotes, so <code>Print</code> can be used to produce formatted text on the
standard output (see also chapter&nbsp;<a href="CHAP026.htm">Strings and Characters</a>).
Some characters preceded by a backslash, such as <code>\n</code>, are processed
specially (see chapter&nbsp;<a href="CHAP026.htm#SECT001">Special Characters</a>).
<code>PrintTo</code> can be used to print to a file (see&nbsp;<a href="CHAP009.htm#SSEC007.3">PrintTo</a>).
<p>
<pre>
gap&gt; for i in [1..5] do
&gt;      Print( i, " ", i^2, " ", i^3, "\n" );
&gt;    od;
1 1 1
2 4 8
3 9 27
4 16 64
5 25 125
</pre>
<p>
<pre>
gap&gt; g:= SmallGroup(12,5);
&lt;pc group of size 12 with 3 generators&gt;
gap&gt; Print( g, "\n" );
Group( [ f1, f2, f3 ] )
gap&gt; View( g );
&lt;pc group of size 12 with 3 generators&gt;gap&gt; 
</pre>
<p>
<a name = "SSEC003.3"></a>
<li><code>ViewObj( </code><var>obj</var><code> ) O</code>
<a name = "SSEC003.3"></a>
<li><code>PrintObj( </code><var>obj</var><code> ) O</code>
<p>
The functions <code>View</code> and <code>Print</code> actually call the operations
<code>ViewObj</code> and&nbsp;<code>PrintObj</code>, respectively, for each argument.
By installing special methods for these operations,
it is possible to achieve special printing behavior for certain objects
(see chapter&nbsp;<a href="../prg/CHAP002.htm">Method Selection</a> in the Programmer's Manual).
The only exceptions are strings (see Chapter&nbsp;<a href="CHAP026.htm">Strings and Characters</a>),
for which the default <code>PrintObj</code> and <code>ViewObj</code> methods as well as the
function <code>View</code> print also the enclosing doublequotes, whereas <code>Print</code>
strips the doublequotes.
<p>
The default method for <code>ViewObj</code> is to call <code>PrintObj</code>.
So it is sufficient to have a <code>PrintObj</code> method for an object in order
to <code>View</code> it.
If one wants to supply a ``short form'' for <code>View</code>,
one can install additionally a method for <code>ViewObj</code>.
<p>
<a name = "SSEC003.4"></a>
<li><code>Display( </code><var>obj</var><code> ) O</code>
<p>
Displays the object <var>obj</var> in a nice, formatted way which is easy to read
(but might be difficult for machines to understand). The actual format
used for this depends on the type of <var>obj</var>. Each method should print a
newline character as last character.
<p>
<pre>
gap&gt; Display( [ [ 1, 2, 3 ], [ 4, 5, 6 ] ] * Z(5) );
 2 4 1
 3 . 2
</pre>
<p>
One can assign a string to an object that <code>Print</code> will use instead of
the default used by <code>Print</code>, via <code>SetName</code> (see&nbsp;<a href="CHAP012.htm#SSEC008.1">SetName</a>).
Also, <code>Name</code> (see&nbsp;<a href="CHAP012.htm#SSEC008.2">Name</a>) returns the string previously assigned to
the object for printing, via <code>SetName</code>.
The following is an example in the context of domains.
<p>
<pre>
gap&gt; g:= Group( (1,2,3,4) );
Group([ (1,2,3,4) ])
gap&gt; SetName( g, "C4" ); g;
C4
gap&gt; Name( g );
"C4"
</pre>
<p>
<p>
<h2><a name="SECT004">6.4 Break Loops</a></h2>
<p><p>
When an error has occurred or when you interrupt <font face="Gill Sans,Helvetica,Arial">GAP</font> (usually by
hitting <var>ctrl</var>-<code>C</code>) <font face="Gill Sans,Helvetica,Arial">GAP</font> enters a break loop, that is in most respects
like the main read eval print loop (see&nbsp;<a href="CHAP006.htm#SECT001">Main Loop</a>). That is, you can
enter statements, <font face="Gill Sans,Helvetica,Arial">GAP</font> reads them, evaluates them, and shows the
result if any. However those evaluations happen within the context in
which the error occurred. So you can look at the arguments and local
variables of the functions that were active when the error happened and
even change them. The prompt is changed from <code>gap&gt;</code> to <code>brk&gt;</code> to
indicate that you are in a break loop.
<p>
<pre>
gap&gt; 1/0;
Rational operations: &lt;divisor&gt; must not be zero
not in any function
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you can replace &lt;divisor&gt; via 'return &lt;divisor&gt;;' to continue
</pre>
<p>
If errors occur within a break loop <font face="Gill Sans,Helvetica,Arial">GAP</font> enters another break loop at a
<strong>deeper level</strong>. This is indicated by a number appended to <code>brk</code>:
<p>
<pre>
brk&gt; 1/0;
Rational operations: &lt;divisor&gt; must not be zero
not in any function
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you can replace &lt;divisor&gt; via 'return &lt;divisor&gt;;' to continue
brk_02&gt;
</pre>
<p>
There are two ways to leave a break loop.
<p>
<a name = "SSEC004.1"></a>
<li><code>quit</code>
<p>
The first is to <strong>quit</strong> the break loop.
To do this you enter <code>quit;</code> or type the <var>eof</var> (<strong>e</strong>nd <strong>o</strong>f <strong>f</strong>ile) character,
which is usually <var>ctrl</var>-<code>D</code> except when using the <code>-e</code> option (see 
Section&nbsp;<a href="CHAP003.htm#SECT001">Command Line Options</a>).
Note that <font face="Gill Sans,Helvetica,Arial">GAP</font> code between <code>quit;</code> and the end of the input line
is ignored.
<p>
<pre>
brk_02&gt; quit;
brk&gt;
</pre>
<p>
In this case control returns to the break loop one level above or
to the main loop, respectively.
So iterated break loops must be left iteratively.
Note also that if you type <code>quit;</code> from a <code>gap&gt;</code> prompt, <font face="Gill Sans,Helvetica,Arial">GAP</font> will exit
(see&nbsp;<a href="CHAP006.htm#SECT008">Leaving GAP</a>).
<p>
<strong>Note:</strong>
If you leave a break loop with <code>quit</code> without completing a command
it is possible (though not very likely) that data structures
will be corrupted or incomplete data have been stored in objects.
Therefore no guarantee can be given that calculations afterwards
will return correct results! If you have been using options <code>quit</code>ting
a break loop generally leaves the options stack with options you no 
longer want. The function <code>ResetOptionsStack</code> (see&nbsp;<a href="CHAP008.htm">ResetOptionsStack</a>)
removes all options on the options stack, and this is the sole intended
purpose of this function.
<p>
<a name = "I9"></a>

<a name = "SSEC004.2"></a>
<li><code>return [</code><var>obj</var><code>];</code>
<p>
The other way is to <strong>return</strong> from a break loop. To do this you type
<code>return;</code> or <code>return </code><var>expr</var><code>;</code>.
If the break loop was entered because you interrupted <font face="Gill Sans,Helvetica,Arial">GAP</font>,
then you can continue by typing <code>return;</code>.
If the break loop was entered due to an error,
you may have to modify the value of a variable before typing <code>return;</code>
(see the example for&nbsp;<a href="CHAP021.htm#SSEC001.2">IsDenseList</a>) or you may have to return a <var>value</var>
(by typing: <code>return </code><var>value</var><code>;</code>) to continue the computation;
in any case, the message printed on entering the break loop will 
tell you which of these alternatives is possible.
For example, if the break loop was entered because a variable had no
assigned value, the value to be returned is often a value that this 
variable should have to continue the computation.
<p>
<pre>
brk&gt; return 9;  # we had tried to enter the divisor 9 but typed 0 ...
1/9
gap&gt; 
</pre>
<p>
<a name = "SSEC004.3"></a>
<li><code>OnBreak V</code>
<p>
By default, when a break loop is entered, <font face="Gill Sans,Helvetica,Arial">GAP</font> prints a trace of the 
innermost 5 commands currently being executed. This behaviour can be
configured by changing the value of the global variable
<code>OnBreak</code>. When a break loop is entered, the value of <code>OnBreak</code> is
checked. If it is a function, then it is called with no arguments. By
default, the value of <code>OnBreak</code> is <code>Where</code> (see <a href="CHAP006.htm#SSEC004.5">Where</a>).
<p>
<pre>
gap&gt; OnBreak := function() Print("Hello\n"); end;
function(  ) ... end
</pre>
<p>
<pre>
gap&gt; Error("!\n");
Error, !
Hello
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you can 'return;' to continue
brk&gt; quit;
</pre>
<p>
In cases where a break loop is entered during a function that was  called
with options (see Chapter&nbsp;<a href="CHAP008.htm">Options Stack</a>), a <code>quit;</code> will also cause the
options stack to be reset  and  an  <code>Info</code>-ed  warning  stating  this  is
emitted at <code>InfoWarning</code> level 1 (see Chapter&nbsp;<a href="CHAP007.htm#SECT004">Info functions</a>).
<p>
Note that for break loops entered by a call to <code>Error</code>,
the lines after ``<code>Entering break read-eval-print loop ...</code>'' and before
the <code>brk&gt;</code> prompt can also be customised, namely by redefining
<code>OnBreakMessage</code> (see&nbsp;<a href="CHAP006.htm#SSEC004.4">OnBreakMessage</a>).
<p>
<a name = "I10"></a>

Also, note that one can achieve the effect of changing <code>OnBreak</code> <strong>locally</strong>.
As mentioned above, the default value of <code>OnBreak</code> is <code>Where</code>. Thus,
a call to <code>Error</code> (see&nbsp;<a href="CHAP006.htm#SSEC006.1">Error</a>) generally gives a trace back up to
five levels of calling functions. Conceivably, we might like to have
a function like <code>Error</code> that does not trace back without globally
changing <code>OnBreak</code>. Such a function we might call <code>ErrorNoTraceBack</code>
and here is how we might define it. (Note <code>ErrorNoTraceBack</code> is
<strong>not</strong> a <font face="Gill Sans,Helvetica,Arial">GAP</font> function.)
<p>
<pre>
gap&gt; ErrorNoTraceBack := function(arg) # arg is a special variable that GAP   
&gt;                                      # knows to treat as a list of arg'ts
&gt;      local SavedOnBreak, ENTBOnBreak;
&gt;      SavedOnBreak := OnBreak;        # save the current value of OnBreak
&gt; 
&gt;      ENTBOnBreak := function()       # our `local' OnBreak
&gt;      local s;
&gt;        for s in arg do
&gt;          Print(s);
&gt;        od;
&gt;        OnBreak := SavedOnBreak;      # restore OnBreak afterwards
&gt;      end;
&gt; 
&gt;      OnBreak := ENTBOnBreak;
&gt;      Error();
&gt;    end;
function( arg ) ... end
</pre>
<p>
Here is a somewhat trivial demonstration of the use of <code>ErrorNoTraceBack</code>.
<p>
<pre>
gap&gt; ErrorNoTraceBack("Gidday!", " How's", " it", " going?\n");
Error, Gidday! How's it going?
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you can 'return;' to continue
brk&gt; quit;
</pre>
<p>
Now we call <code>Error</code> with the same arguments to show the difference.
<p>
<pre>
gap&gt; Error("Gidday!", " How's", " it", " going?\n");
Error, Gidday! How's it going?
Hello
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you can 'return;' to continue
brk&gt; quit;
</pre>
<p>
Observe that the value of <code>OnBreak</code> before the <code>ErrorNoTraceBack</code> call
was restored. However, we had changed <code>OnBreak</code> from its default value;
to restore <code>OnBreak</code> to its default value, we should do the following.
<p>
<pre>
gap&gt; OnBreak := Where;;
</pre>
<p>
<a name = "I11"></a>

<a name = "SSEC004.4"></a>
<li><code>OnBreakMessage V</code>
<p>
When a break loop is entered by a call to <code>Error</code> (see&nbsp;<a href="CHAP006.htm#SSEC006.1">Error</a>) the
message after the ``<code>Entering break read-eval-print loop ...</code>'' line is 
produced by the function <code>OnBreakMessage</code>, which just like
<code>OnBreak</code> (see&nbsp;<a href="CHAP006.htm#SSEC004.3">OnBreak</a>) is a user-configurable global variable that is a
<strong>function</strong> with <strong>no arguments</strong>.
<p>
<pre>
gap&gt; OnBreakMessage(); # By default, OnBreakMessage prints the following
you can 'quit;' to quit to outer loop, or
you can 'return;' to continue
</pre>
<p>
Perhaps you are familiar with what's possible in a break loop, and so
don't need to be reminded. In this case, you might wish to do the
following (the first line just makes it easy to restore the default 
value later).
<p>
<pre>
gap&gt; NormalOnBreakMessage := OnBreakMessage;; # save the default value 
gap&gt; OnBreakMessage := function() end;        # do-nothing function
function(  ) ... end
</pre>
<p>
With <code>OnBreak</code> still set away from its default value, calling <code>Error</code>
as we did above, now produces:
<p>
<pre>
gap&gt; Error("!\n");
Error, !
Hello
Entering break read-eval-print loop ...
brk&gt; quit; # to get back to outer loop
</pre>
<p>
However, suppose you are writing a function which detects an error
condition and <code>OnBreakMessage</code> needs to be changed only <strong>locally</strong>,
i.e., the instructions on how to recover from the break loop need
to be specific to that function. The same idea used to define 
<code>ErrorNoTraceBack</code> (see <a href="CHAP006.htm#SSEC004.3">OnBreak</a>) can be adapted to achieve 
this. The function <code>CosetTableFromGensAndRels</code> (see&nbsp;<a href="CHAP045.htm#SSEC005.5">CosetTableFromGensAndRels</a>)
is an example in the <font face="Gill Sans,Helvetica,Arial">GAP</font> code where the idea is actually used.
<p>
<a name = "I12"></a>

<a name = "SSEC004.5"></a>
<li><code>Where( [</code><var>nr</var><code>] ) F</code>
<p>
shows the last <var>nr</var> commands on the execution stack during whose execution
the error occurred. If not given, <var>nr</var> defaults to 5. (Assume, for the
following example, that after the last example <code>OnBreak</code> (see&nbsp;<a href="CHAP006.htm#SSEC004.3">OnBreak</a>) 
has been set back to its default value.)
<p>
<pre>
gap&gt; StabChain(SymmetricGroup(100)); # After this we typed ^C  
user interrupt at
bpt := S.orbit[1];
 called from
SiftedPermutation( S, (g * rep) ^ -1 ) called from
StabChainStrong( S.stabilizer, [ sch ], options ); called from
StabChainStrong( S.stabilizer, [ sch ], options ); called from
StabChainStrong( S, GeneratorsOfGroup( G ), options ); called from
StabChainOp( G, rec(
     ) ) called from
...
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you can 'return;' to continue
brk&gt; Where(2);
 called from
SiftedPermutation( S, (g * rep) ^ -1 ) called from
StabChainStrong( S.stabilizer, [ sch ], options ); called from
...
</pre>
<p>
Note that the variables displayed even in the first line of the <code>Where</code> list
(after the <code>called from</code> line) may be already one environment level higher 
and <code>DownEnv</code> (see&nbsp;<a href="CHAP006.htm#SSEC005.1">DownEnv</a>) may be necessary to access them.
<p>
At the moment this backtrace does not work from within compiled code (this
includes the method selection which by default is compiled into the kernel).
If this creates problems for debugging, call <font face="Gill Sans,Helvetica,Arial">GAP</font> with the <code>-M</code> option
(see&nbsp;<a href="CHAP003.htm#SECT002">Advanced Features of GAP</a>) to avoid loading compiled code.
<p>
(Function calls to <code>Info</code> and methods installed for binary operations are
handled in a special way. In rare circumstances it is possible therefore
that they do not show up in a <code>Where</code> log but the log refers to the <strong>last</strong>
proper function call that happened before.)
<p>
The command line option <code>-T</code> to <font face="Gill Sans,Helvetica,Arial">GAP</font> disables the break loop. This
is mainly intended for testing purposes and for special
applications. If this option is given then errors simply cause <font face="Gill Sans,Helvetica,Arial">GAP</font>
to return to the main loop.
<p>
<p>
<h2><a name="SECT005">6.5 Variable Access in a Break Loop</a></h2>
<p><p>
In a break loop access to variables of the current break level and higher
levels is possible, but if the same variable name is used for different
objects or if a function calls itself recursively, of course only the
variable at the lowest level can be accessed.
<p>
<a name = "SSEC005.1"></a>
<li><code>DownEnv( [</code><var>nr</var><code>] ) F</code>
<a name = "SSEC005.1"></a>
<li><code>UpEnv( [</code><var>nr</var><code>] ) F</code>
<p>
<code>DownEnv</code> moves up <var>nr</var> steps in the environment and allows one to inspect
variables on this level; if <var>nr</var> is negative it steps down in the environment
again; <var>nr</var> defaults to 1 if not given. <code>UpEnv</code> acts similarly to <code>DownEnv</code>
but in the reverse direction. (The names of <code>DownEnv</code> and <code>UpEnv</code> are the
wrong way 'round; I guess it all depends on which direction defines is
``up'' -- just use <code>DownEnv</code> and get used to that.)
<p>
<pre>
gap&gt; OnBreak := function() Where(0); end;; # eliminate back-tracing on
gap&gt;                                       # entry to break loop
gap&gt; test:= function( n )
&gt;    if n &gt; 3 then Error( "!\n" ); fi; test( n+1 ); end;;
gap&gt; test( 1 );
Error, !
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you can 'return;' to continue
brk&gt; Where();
 called from
test( n + 1 ); called from
test( n + 1 ); called from
test( n + 1 ); called from
&lt;function&gt;( &lt;arguments&gt; ) called from read-eval-loop
brk&gt; n;
4
brk&gt; DownEnv();
brk&gt; n;
3
brk&gt; Where();
 called from
test( n + 1 ); called from
test( n + 1 ); called from
&lt;function&gt;( &lt;arguments&gt; ) called from read-eval-loop
brk&gt; DownEnv( 2 );
brk&gt; n;
1
brk&gt; Where();
 called from
&lt;function&gt;( &lt;arguments&gt; ) called from read-eval-loop
brk&gt; DownEnv( -2 );
brk&gt; n;
3
brk&gt; quit;
gap&gt; OnBreak := Where;; # restore OnBreak to its default value
</pre>
<p>
Note that the change of the environment caused by <code>DownEnv</code> only affects
variable access in the break loop. If you use <code>return</code> to continue a
calculation <font face="Gill Sans,Helvetica,Arial">GAP</font> automatically jumps to the right environment level
again.
<p>
Note also that search for variables looks first in the chain of outer
functions which enclosed the definition of a currently executing
function, before it looks at the chain of calling functions which led
to the current invocation of the function. 
<p>
<pre>
gap&gt; foo := function()
&gt; local x; x := 1;
&gt; return function() local y; y := x*x; Error("!!\n"); end;
&gt; end;
function(  ) ... end
gap&gt; bar := foo();
function(  ) ... end
gap&gt; fun := function() local x; x := 3; bar(); end;
function(  ) ... end
gap&gt; fun();
Error, !!
 called from
bar(  ); called from
&lt;function&gt;( &lt;arguments&gt; ) called from read-eval-loop
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you can 'return;' to continue
brk&gt; x;
1
brk&gt; DownEnv(1);
brk&gt; x;
3
</pre>
<p>
Here the <code>x</code> of <code>foo</code> which contained the definition of <code>bar</code> is found 
before that of <code>fun</code> which caused its execution. Using <code>DownEnv</code> we
can access the <code>x</code> from <code>fun</code>.
<p>
<p>
<h2><a name="SECT006">6.6 Error</a></h2>
<p><p>
<a name = "SSEC006.1"></a>
<li><code>Error( </code><var>messages</var><code>... ) F</code>
<p>
<code>Error</code> signals an error from within a function. First the messages
<var>messages</var> are printed, this is done exactly as if <code>Print</code>
(see&nbsp;<a href="CHAP006.htm#SECT003">View and Print</a>)
were called with these arguments. Then a break loop (see&nbsp;<a href="CHAP006.htm#SECT004">Break Loops</a>) is
entered, unless the standard error output is not connected to a terminal.
You can leave this break loop with <code>return;</code> to continue execution with the
statement following the call to <code>Error</code>.
<p>
<p>
<h2><a name="SECT007">6.7 ErrorCount</a></h2>
<p><p>
<a name = "SSEC007.1"></a>
<li><code>ErrorCount() F</code>
<p>
<code>ErrorCount</code> returns a count of the number of errors (including user
interruptions) which have occurred in the <font face="Gill Sans,Helvetica,Arial">GAP</font> session so far.
This count is reduced modulo 2<sup>28</sup> on 32 bit systems,
2<sup>60</sup> on 64 bit systems.
The count is incremented by each error, even if <font face="Gill Sans,Helvetica,Arial">GAP</font> was
started with the <code>-T</code> option to disable the break loop.
<p>
<p>
<h2><a name="SECT008">6.8 Leaving GAP</a></h2>
<p><p>
<a name = "I13"></a>

<a name = "I14"></a>

<a name = "I15"></a>

<a name = "I16"></a>

The normal way to terminate a <font face="Gill Sans,Helvetica,Arial">GAP</font> session is to enter either
<code>quit;</code> (note the semicolon) or an end-of-file character (usually
ctrl-D) at the <code>gap&gt;</code> prompt in the main read eval print loop. 
<p>
An emergency way to leave <font face="Gill Sans,Helvetica,Arial">GAP</font> is to enter 
<a name = "SSEC008.1"></a>
<li><code>QUIT</code>
<p>
at any <code>gap&gt;</code>
or <code>brk&gt;</code> or <code>brk_</code><var>nn</var><code>&gt;</code> prompt. 
<p>
<a name = "SSEC008.2"></a>
<li><code>InstallAtExit( </code><var>func</var><code> ) F</code>
<a name = "SSEC008.2"></a>
<li><code>QUITTING V</code>
<p>
Before actually terminating, <font face="Gill Sans,Helvetica,Arial">GAP</font> will call (with no arguments) all
of the functions that have been installed using <code>InstallAtExit</code>. These
typically perform tasks such as cleaning up temporary files created
during the session, and closing open files. If an error occurs during
the execution of one of these functions, that function is simply
abandoned, no break loop is entered. 
<p>
<pre>
gap&gt; InstallAtExit(function() Print("bye\n"); end);
gap&gt; quit;
bye
</pre>
<p>
During execution of these functions, the global variable <code>QUITTING</code>
will be set to <code>true</code> if <font face="Gill Sans,Helvetica,Arial">GAP</font> is exiting because the user typed
<code>QUIT</code> and <code>false</code> otherwise. Since <code>QUIT</code> is considered as an emergency
measure, different action may be appropriate.
<p>
<a name = "SSEC008.3"></a>
<li><code>SaveOnExitFile V</code>
<p>
If, when <font face="Gill Sans,Helvetica,Arial">GAP</font> is exiting due to a <code>quit</code> or end-of-file (ie not due
to a <code>QUIT</code>) the variable <code>SaveOnExitFile</code> is bound to a string value,
then the system will try to save the workspace to that file.
<p>
<p>
<h2><a name="SECT009">6.9 Line Editing</a></h2>
<p><p>
<font face="Gill Sans,Helvetica,Arial">GAP</font> allows one you to edit the current input line with a number of editing
commands. Those commands are accessible either as <strong>control keys</strong> or as
<strong>escape keys</strong>. You enter a control key by pressing the <var>ctrl</var> key, and,
while still holding the <var>ctrl</var> key down, hitting another key <var>key</var>. You
enter an escape key by hitting <var>esc</var> and then hitting another key <var>key</var>.
Below we denote control keys by <var>ctrl</var>-<var>key</var> and escape keys by
<var>esc</var>-<var>key</var>. The case of <var>key</var> does not matter, i.e., <var>ctrl</var>-<code>A</code> and
<var>ctrl</var>-<code>a</code> are equivalent.
<p>
Normally, line editing will be enabled if the input is connected to a
terminal. Line editing can be enabled or disabled using the command line
options <code>-f</code> and <code>-n</code> respectively (see&nbsp;<a href="CHAP003.htm#SECT001">Command Line Options</a>), however
this is a machine dependent feature of <font face="Gill Sans,Helvetica,Arial">GAP</font>.
<p>
Typing <var>ctrl</var>-<var>key</var> or <var>esc</var>-<var>key</var> for characters not mentioned below
always inserts <var>ctrl</var>-<var>key</var> resp.&nbsp;<var>esc</var>-<var>key</var> at the current cursor position.
<p>
The first few commands allow you to move the cursor on the current line.
<p>
<var>ctrl</var>-<code>A</code> move the cursor to the beginning of the line.
<p>
<var>esc</var>-<code>B</code> move the cursor to the beginning of the previous word.
<p>
<var>ctrl</var>-<code>B</code> move the cursor backward one character.
<p>
<var>ctrl</var>-<code>F</code> move the cursor forward one character. 
<p>
<var>esc</var>-<code>F</code> move the cursor to the end of the next word. 
<p>
<var>ctrl</var>-<code>E</code> move the cursor to the end of the line.
<p>
The next commands delete or kill text.
The last killed text can be reinserted, possibly at a different position,
with the ``yank'' command <var>ctrl</var>-<code>Y</code>.
<p>
<var>ctrl</var>-<code>H</code> or <var>del</var> delete the character left of the cursor. 
<p>
<var>ctrl</var>-<code>D</code> delete the character under the cursor. 
<p>
<var>ctrl</var>-<code>K</code> kill up to the end of the line. 
<p>
<var>esc</var>-<code>D</code> kill forward to the end of the next word. 
<p>
<var>esc</var>-<var>del</var> kill backward to the beginning of the last word. 
<p>
<var>ctrl</var>-<code>X</code> kill entire input line, and discard all pending input. 
<p>
<var>ctrl</var>-<code>Y</code> insert (yank) a just killed text.
<p>
The next commands allow you to change the input.
<p>
<var>ctrl</var>-<code>T</code> exchange (twiddle) current and previous character. 
<p>
<var>esc</var>-<code>U</code> uppercase next word. 
<p>
<var>esc</var>-<code>L</code> lowercase next word. 
<p>
<var>esc</var>-<code>C</code> capitalize next word.
<p>
The <var>tab</var> character, which is in fact the control key <var>ctrl</var>-<code>I</code>, looks at
the characters before the cursor, interprets them as the beginning of an
identifier and tries to complete this identifier. If there is more than
one possible completion, it completes to the longest common prefix of all
those completions. If the characters to the left of the cursor are
already the longest common prefix of all completions hitting <var>tab</var> a
second time will display all possible completions.
<p>
<var>tab</var>  complete the identifier before the cursor.
<p>
The next commands allow you to fetch previous lines, e.g., to correct
typos, etc. This history is limited to about 8000 characters.
<p>
<var>ctrl</var>-<code>L</code> insert last input line before current character.
<p>
<var>ctrl</var>-<code>P</code> redisplay the last input line, another <var>ctrl</var>-<code>P</code> will
  redisplay the line before that, etc. If the cursor is
  not in the first column only the lines starting with the
  string to the left of the cursor are taken.
<p>
<var>ctrl</var>-<code>N</code> Like <var>ctrl</var>-<code>P</code> but goes the other way round through the
  history.
<p>
<var>esc</var>-<code>&lt;</code> goes to the beginning of the history.
<p>
<var>esc</var>-<code>&gt;</code> goes to the end of the history.
<p>
<var>ctrl</var>-<code>O</code> accepts this line and perform a <var>ctrl</var>-<code>N</code>.
<p>
Finally there are a few miscellaneous commands.
<p>
<var>ctrl</var>-<code>V</code> enter next character literally, i.e., enter it even if it
  is one of the control keys.
<p>
<var>ctrl</var>-<code>U</code> execute the next line editing command 4 times.
<p>
<var>esc</var>-<var>num</var> execute the next line editing command <var>num</var> times.
<p>
<var>esc</var>-<var>ctrl</var>-<code>L</code> redisplay input line.
<p>
The four arrow keys (cursor keys) can be used instead of <var>ctrl</var>-<code>B</code>,
<var>ctrl</var>-<code>F</code>, <var>ctrl</var>-<code>P</code>, and <var>ctrl</var>-<code>N</code>, respectively.
<p>
<p>
<h2><a name="SECT010">6.10 Editing Files</a></h2>
<p><p>
In most cases, it is preferable to create longer input (in particular <font face="Gill Sans,Helvetica,Arial">GAP</font>
programs) separately in an editor, and to read in the result via <code>Read</code>.
Note that <code>Read</code> by default reads from the directory in which <font face="Gill Sans,Helvetica,Arial">GAP</font> was
started (respectively under Windows the directory containing the <font face="Gill Sans,Helvetica,Arial">GAP</font>
binary), so you might hav eto give an absolute path to the file.
<p>
If you cannot create several windows, the <code>Edit</code> command may be used to
leave <font face="Gill Sans,Helvetica,Arial">GAP</font>, start an editor, and read in the edited file automatically.
<a name = "SSEC010.1"></a>
<li><code>Edit( </code><var>filename</var><code> ) F</code>
<p>
<code>Edit</code> starts an editor with the file whose filename is given by the
string <var>filename</var>, and reads the file back into <font face="Gill Sans,Helvetica,Arial">GAP</font> when you exit the
editor again.
You should set the <font face="Gill Sans,Helvetica,Arial">GAP</font> variable <code>EDITOR</code> to the name of
the editor that you usually use, e.g., <code>/usr/ucb/vi</code>.
This can for example be done in your <code>.gaprc</code> file (see the sections on
operating system dependent features in Chapter&nbsp;<a href="CHAP073.htm">Installing GAP</a>).
<p>
<p>
<h2><a name="SECT011">6.11 Editor Support</a></h2>
<p><p>
<a name = "I17"></a>

<a name = "I18"></a>

<a name = "I19"></a>

<a name = "I20"></a>

In the <code>etc</code> subdirectory of the <font face="Gill Sans,Helvetica,Arial">GAP</font> installation
we provide some setup files for the editors  <code>vim</code> and <code>emacs</code>/<code>xemacs</code>.
<p>
<code>vim</code> is a powerful editor that understands the basic <code>vi</code> commands but
provides much more functionality. You can find more information about it
(and download it) from <a href="http://www.vim.org">http://www.vim.org</a>.
<p>
To get support for <font face="Gill Sans,Helvetica,Arial">GAP</font> syntax in vim, create in your home directory a
directory <code>.vim</code> and a subdirectory <code>.vim/indent</code> (If you are not using
Unix, refer to the <code>vim</code> documentation on where to place syntax files).
Then copy the file <code>etc/gap.vim</code> in this<code>.vim</code> directory and copy the file
<code>etc/gap_indent.vim</code> to <code>.vim/indent/gap.vim</code>.
<p>
Then edit the <code>.vimrc</code> file in your home directory. Add lines as in  the
following example:
<p>
<pre>
if has("syntax")
  syntax on             " Default to no syntax highlightning 
endif

" For GAP files
augroup gap
  " Remove all gap autocommands
  au!
  autocmd BufRead,BufNewFile *.g,*.gi,*.gd source ~/.vim/gap.vim
autocmd BufRead,BufNewFile *.g,*.gi,*.gd set filetype=gap comments=s:##\ \ ,m:##\ \ ,e:##\ \ b:#

" I'm using the external program `par' for formating comment lines starting
" with `##  '. Include these lines only when you have par installed.
  autocmd BufRead,BufNewFile *.g,*.gi,*.gd set formatprg="par w76p4s0j"
  autocmd BufWritePost,FileWritePost *.g,*.gi,*.gd set formatprg="par w76p0s0j"
augroup END
</pre>
<p>
See the headers  of the two mentioned files for  additional comments.
Adjust details according to  your personal taste.
<p>
Setup files for <code>(x)emacs</code> are contained in the <code>etc/emacs</code> subdirectory.
<p>
<p>
<h2><a name="SECT012">6.12 SizeScreen</a></h2>
<p><p>
<a name = "SSEC012.1"></a>
<li><code>SizeScreen() F</code>
<li><code>SizeScreen( [ </code><var>x</var><code>, </code><var>y</var><code> ] ) F</code>
<p>
With no arguments, <code>SizeScreen</code> returns the size of the screen as a  list
with two entries. The first is the length of each line, the second is the
number of lines.
<p>
With one argument that is a list,  <code>SizeScreen</code>  sets  the  size  of  the
screen; <var>x</var> is the length of each line,  <var>y</var>  is  the  number  of  lines.
Either value <var>x</var> or <var>y</var> may be missing (i.e.&nbsp;left unbound), to leave this
value unaffected. It returns the new values. Note that  those  parameters
can also be set with the command line options <code>-x </code><var>x</var><code></code> and <code>-y </code><var>y</var><code></code>  (see
Section&nbsp;<a href="CHAP003.htm#SECT001">Command line options</a>).
<p>
To check/change whether line breaking occurs for files and streams 
see&nbsp;<a href="CHAP010.htm#SSEC004.9">PrintFormattingStatus</a> and&nbsp;<a href="CHAP010.htm#SSEC004.8">SetPrintFormattingStatus</a>.
<p>
The screen width must be between 20 and 256 characters (inclusive) and 
the depth at least 10 lines. Values outside this range will be
adjusted to the nearest endpoint of the range.
<p>
<p>
[<a href="../index.htm">Top</a>] [<a href = "chapters.htm">Up</a>] [<a href ="CHAP005.htm">Previous</a>] [<a href ="CHAP007.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<P>
<font face="Gill Sans,Helvetica,Arial">GAP 4 manual<br>November 2006
</font></body></html>