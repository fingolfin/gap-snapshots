<html><head><title>[ref] 41 Permutation Groups</title></head>
<body text="#000000" bgcolor="#ffffff">
[<a href="../index.htm">Top</a>] [<a href = "chapters.htm">Up</a>] [<a href ="CHAP040.htm">Previous</a>] [<a href ="CHAP042.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<h1>41 Permutation Groups</h1><p>
<P>
<H3>Sections</H3>
<oL>
<li> <A HREF="CHAP041.htm#SECT001">The Natural Action</a>
<li> <A HREF="CHAP041.htm#SECT002">Computing a Permutation Representation</a>
<li> <A HREF="CHAP041.htm#SECT003">Symmetric and Alternating Groups</a>
<li> <A HREF="CHAP041.htm#SECT004">Primitive Groups</a>
<li> <A HREF="CHAP041.htm#SECT005">Stabilizer Chains</a>
<li> <A HREF="CHAP041.htm#SECT006">Randomized Methods for Permutation Groups</a>
<li> <A HREF="CHAP041.htm#SECT007">Construction of Stabilizer Chains</a>
<li> <A HREF="CHAP041.htm#SECT008">Stabilizer Chain Records</a>
<li> <A HREF="CHAP041.htm#SECT009">Operations for Stabilizer Chains</a>
<li> <A HREF="CHAP041.htm#SECT010">Low Level Routines to Modify and Create Stabilizer Chains</a>
<li> <A HREF="CHAP041.htm#SECT011">Backtrack</a>
<li> <A HREF="CHAP041.htm#SECT012">Working with large degree permutation groups</a>
</ol><p>
<p>
<a name = ""></a>
<li><code>IsPermGroup( </code><var>obj</var><code> ) C</code>
<p>
A permutation group is a  group of permutations on  a finite set
&#8486; of  positive integers. <font face="Gill Sans,Helvetica,Arial">GAP</font> does <strong>not</strong>  require the user to
specify the operation domain  &#8486; when a permutation  group is
defined.
<p>
<pre>
gap&gt; g:=Group((1,2,3,4),(1,2));
Group([ (1,2,3,4), (1,2) ])
</pre>
<p>
Permutation groups are groups and therefore all operations for groups (see
Chapter&nbsp;<a href="CHAP037.htm">Groups</a>) can be applied to them. In many cases special methods are
installed for permutation groups that make computations more effective.
<p>
<p>
<h2><a name="SECT001">41.1 The Natural Action</a></h2>
<p><p>
The functions <code>MovedPoints</code>, <code>NrMovedPoints</code>, <code>LargestMovedPoint</code>,
and <code>SmallestMovedPoint</code> are defined for arbitrary collections of
permutations (see&nbsp;<a href="CHAP040.htm#SECT002">Moved Points of Permutations</a>),
in particular they can be applied to permutation groups.
<pre>
gap&gt; g:= Group( (2,3,5,6), (2,3) );;
gap&gt; MovedPoints( g );  NrMovedPoints( g );
[ 2, 3, 5, 6 ]
4
gap&gt; LargestMovedPoint( g );  SmallestMovedPoint( g );
6
2
</pre>
<p>
The action of a permutation group on the positive integers is a group
action (via the acting function <code>OnPoints</code>).
Therefore all action functions can be applied
(see the Chapter&nbsp;<a href="CHAP039.htm">Group Actions</a>),
for example <code>Orbit</code>, <code>Stabilizer</code>, <code>Blocks</code>, <code>IsTransitive</code>, <code>IsPrimitive</code>.
<p>
If one has a list of group generators and is interested in the moved points
(see above) or orbits, it may be useful to avoid the explicit construction
of the group for efficiency reasons.
For the special case of the action of permutations on positive integers
via <code>^</code>, the following functions are provided for this purpose.
<p>
<a name = "SSEC001.1"></a>
<li><code>OrbitPerms( </code><var>perms</var><code>, </code><var>pnt</var><code> ) F</code>
<p>
returns the orbit of the positive integer <var>pnt</var>
under the group generated by the permutations in the list <var>perms</var>.
<p>
<a name = "SSEC001.2"></a>
<li><code>OrbitsPerms( </code><var>perms</var><code>, </code><var>D</var><code> ) F</code>
<p>
returns the list of orbits of the positive integers in the list <var>D</var>
under the group generated by the permutations in the list <var>perms</var>.
<p>
<pre>
gap&gt; OrbitPerms( [ (1,2,3)(4,5), (3,6) ], 1 );
[ 1, 2, 3, 6 ]
gap&gt; OrbitsPerms( [ (1,2,3)(4,5), (3,6) ], [ 1 .. 6 ] );
[ [ 1, 2, 3, 6 ], [ 4, 5 ] ]
</pre>
<p>
Similarly, several functions concerning the natural action of
permutation groups address stabilizer chains (see&nbsp;<a href="CHAP041.htm#SECT005">Stabilizer Chains</a>)
rather than permutation groups themselves, for example <code>BaseStabChain</code>
(see&nbsp;<a href="CHAP041.htm#SSEC009.1">BaseStabChain</a>).
<p>
<p>
<h2><a name="SECT002">41.2 Computing a Permutation Representation</a></h2>
<p><p>
<a name = "SSEC002.1"></a>
<li><code>IsomorphismPermGroup( </code><var>G</var><code> ) A</code>
<p>
returns an isomorphism &#981; from the group <var>G</var> onto
a permutation group <var>P</var> which is isomorphic to <var>G</var>.
The method will select a suitable permutation representation.
<p>
<pre>
gap&gt; g:=SmallGroup(24,12);
&lt;pc group of size 24 with 4 generators&gt;
gap&gt; iso:=IsomorphismPermGroup(g);
&lt;action isomorphism&gt;
gap&gt; Image(iso,g.3*g.4);
(1,4)(2,3)(5,8)(6,7)(9,12)(10,11)(13,16)(14,15)(17,20)(18,19)(21,24)(22,23)
</pre>
<p>
In many cases the permutation representation constructed by
<code>IsomorphismPermGroup</code> is regular.
<p>
<a name = "SSEC002.2"></a>
<li><code>SmallerDegreePermutationRepresentation( </code><var>G</var><code> ) F</code>
<p>
Let <var>G</var> be a permutation group that acts transitively
on its moved points.
<code>SmallerDegreePermutationRepresentation</code> tries to find a faithful
permutation representation of smaller degree.
The result is a group homomorphism onto a permutation group,
in the worst case this is the identity mapping on <var>G</var>.
<p>
Note that the result is not guaranteed to be a faithful permutation
representation of smallest degree,
or of smallest degree among the transitive permutation representations
of <var>G</var>.
Using <font face="Gill Sans,Helvetica,Arial">GAP</font> interactively, one might be able to choose subgroups
of small index for which the cores intersect trivially;
in this case, the actions on the cosets of these subgroups give rise to
an intransitive permutation representation
the degree of which may be smaller than the original degree.
<p>
The methods used might involve the use of random elements and the
permutation representation (or even the degree of the representation) is
not guaranteed to be the same for different calls of
<code>SmallerDegreePermutationRepresentation</code>.
<p>
<pre>
gap&gt; image:= Image( iso );;  NrMovedPoints( image );
24
gap&gt; small:= SmallerDegreePermutationRepresentation( image );;
gap&gt; Image( small );
Group([ (2,3), (2,4,3), (1,3)(2,4), (1,2)(3,4) ])
</pre>
<p>
<p>
<h2><a name="SECT003">41.3 Symmetric and Alternating Groups</a></h2>
<p><p>
The commands <code>SymmetricGroup</code> and <code>AlternatingGroup</code> (see&nbsp;<a href="CHAP048.htm#SECT001">Basic Groups</a>)
construct symmetric and alternating permutation groups.
<font face="Gill Sans,Helvetica,Arial">GAP</font> can also detect whether a given permutation group is a symmetric
or alternating group on the set of its moved points;
if so then the group is called a <strong>natural</strong> symmetric or alternating group,
respectively.
<p>
<a name = "SSEC003.1"></a>
<li><code>IsNaturalSymmetricGroup( </code><var>group</var><code> ) P</code>
<p>
A group is a natural symmetric group if it is  a permutation group acting
as symmetric group on its moved points.
<p>
<a name = "SSEC003.2"></a>
<li><code>IsNaturalAlternatingGroup( </code><var>group</var><code> ) P</code>
<p>
A   group is a  natural  alternating group if  it is  a permutation group
acting as alternating group on its moved points.
<p>
For groups that are known to be natural symmetric or natural alternating
groups, very efficient methods for computing membership, conjugacy classes,
Sylow subgroups etc.&nbsp;are used.
<pre>
gap&gt; g:=Group((1,5,7,8,99),(1,99,13,72));;
gap&gt; IsNaturalSymmetricGroup(g);
true
gap&gt; g;
Sym( [ 1, 5, 7, 8, 13, 72, 99 ] )
gap&gt; IsNaturalSymmetricGroup( Group( (1,2)(4,5), (1,2,3)(4,5,6) ) );
false
</pre>
<p>
The following functions can be used to check whether a given group
(not necessarily a permutation group)
is isomorphic to a symmetric or alternating group.
<p>
There are no methods yet for IsSymmetricGroup and IsAlternatingGroup!
<p>
<a name = "SSEC003.3"></a>
<li><code>IsSymmetricGroup( </code><var>group</var><code> ) P</code>
<p>
is <code>true</code> if the group <var>group</var> is isomorphic to a natural symmetric group.
<p>
<a name = "SSEC003.4"></a>
<li><code>IsAlternatingGroup( </code><var>group</var><code> ) P</code>
<p>
Such a group is a group isomorphic to a natural alternating group.
<p>
<a name = "SSEC003.5"></a>
<li><code>SymmetricParentGroup( </code><var>grp</var><code> ) A</code>
<p>
For a permutation group <var>grp</var> this function returns the symmetric group
that moves the same points as <var>grp</var> does.
<p>
<pre>
gap&gt; SymmetricParentGroup( Group( (1,2), (4,5), (7,8,9) ) );
Sym( [ 1, 2, 4, 5, 7, 8, 9 ] )
</pre>
<p>
<p>
<h2><a name="SECT004">41.4 Primitive Groups</a></h2>
<p><p>
<a name = "SSEC004.1"></a>
<li><code>ONanScottType( </code><var>G</var><code> ) A</code>
<p>
returns the type of <var>G</var> of a primitive permutation group <var>G</var>, according
to the O'Nan-Scott classification. The labelling of the different types
is not consistent in the literature, we use the following:
<dl compact>
<dt>1<dd>Affine.
<dt>2<dd>Almost simple.
<dt>3a<dd>Diagonal, Socle consists of two normal subgroups.
<dt>3b<dd>Diagonal, Socle is minimal normal.
<dt>4a<dd>Product action with the first factor primitive of type 3a.
<dt>4b<dd>Product action with the first factor primitive of type 3b.
<dt>4c<dd>Product action with the first factor primitive of type 2.
<dt>5<dd>Twisted wreath product
</dl>
As it can contain letters, the type is returned as a string.
<p>
If <var>G</var> is not a permutation group or does not act primitively on the
points moved by it, the result is undefined.
<p>
<a name = "SSEC004.2"></a>
<li><code>SocleTypePrimitiveGroup( </code><var>G</var><code> ) A</code>
<p>
returns the socle type of a primitive permutation group. The socle of a
primitive group is the direct product of isomorphic simple groups,
therefore the type is indicated by a record with components <code>series</code>,
<code>parameter</code> (both as described under
<code>IsomorphismTypeInfoFiniteSimpleGroup</code>,
see&nbsp;<a href="CHAP037.htm#SSEC015.11">IsomorphismTypeInfoFiniteSimpleGroup</a>) and <code>width</code> for the number of
direct factors.
<p>
If <var>G</var> does not have a faithful primitive action, the result is undefined.
<p>
<pre>
gap&gt; g:=AlternatingGroup(5);;
gap&gt; h:=DirectProduct(g,g);;
gap&gt; p:=List([1,2],i-&gt;Projection(h,i));;
gap&gt; ac:=Action(h,AsList(g),
&gt; function(g,h) return Image(p[1],h)^-1*g*Image(p[2],h);end);;
gap&gt; Size(ac);NrMovedPoints(ac);IsPrimitive(ac,[1..60]);
3600
60
true
gap&gt; ONanScottType(ac);
"3a"
gap&gt; SocleTypePrimitiveGroup(ac);
rec( series := "A", width := 2, 
  name := "A(5) ~ A(1,4) = L(2,4) ~ B(1,4) = O(3,4) ~ C(1,4) = S(2,4) ~ 2A(1,4\
) = U(2,4) ~ A(1,5) = L(2,5) ~ B(1,5) = O(3,5) ~ C(1,5) = S(2,5) ~ 2A(1,5) = U\
(2,5)", parameter := 5 )
</pre>
<p>
<p>
<h2><a name="SECT005">41.5 Stabilizer Chains</a></h2>
<p><p>
Many of the algorithms for permutation groups use a <strong>stabilizer chain</strong> of
the group.
The concepts of stabilizer chains, <strong>bases</strong>, and <strong>strong generating sets</strong> were
introduced by Charles Sims in&nbsp;<a href="biblio.htm#Sim70"><cite>Sim70</cite></a>.
A further discussion of base change is given in
section&nbsp;<a href="../ext/CHAP008.htm#SECT001">Generalized Conjugation Technique</a> in ``Extending <font face="Gill Sans,Helvetica,Arial">GAP</font>''.
<p>
Let <i>B</i>=[<i>b</i><sub>1</sub>, &#8230;, <i>b</i><sub><i>n</i></sub>] be a list of points, <i>G</i><sup>(1)</sup> = <i>G</i> and <i>G</i><sup>(<i>i</i>+1)</sup> = <i>Stab</i><sub><i>G</i><sup>(<i>i</i>)</sup></sub>(<i>b</i><sub><i>i</i></sub>), such that <i>G</i><sup>(<i>n</i>+1)</sup> = { () }.
Then the list [<i>b</i><sub>1</sub>, &#8230;, <i>b</i><sub><i>n</i></sub>] is called a <strong>base</strong> of <i>G</i>,
the points <i>b</i><sub><i>i</i></sub> are called <strong>base
points</strong>.  A set <i>S</i> of generators for <i>G</i> satisfying the condition  &lt;  <i>S</i> &#8745;<i>G</i><sup>(<i>i</i>)</sup>  &gt;  = <i>G</i><sup>(<i>i</i>)</sup> for each 1  &#8804; <i>i</i>  &#8804; <i>n</i>, is called a <strong>strong
generating set</strong> (SGS) of <i>G</i>. (More precisely we ought to say that it is a
SGS of <i>G</i> <strong>relative</strong> to <i>B</i>).
The chain of subgroups <i>G</i><sup>(<i>i</i>)</sup> of <i>G</i> itself is
called the <strong>stabilizer chain</strong> of <i>G</i> relative to <i>B</i>.
<p>
Since [<i>b</i><sub>1</sub>, &#8230;, <i>b</i><sub><i>n</i></sub>], where <i>n</i> is the degree of <i>G</i> and <i>b</i><sub><i>i</i></sub> are the
moved points of <i>G</i>, certainly is a base for <i>G</i> there exists a base for
each permutation group. The number of points in a base is called the
<strong>length</strong> of the base. A base <i>B</i> is called <strong>reduced</strong> if there exists no <i>i</i>
such that <i>G</i><sup>(<i>i</i>)</sup> = <i>G</i><sup>(<i>i</i>+1)</sup>. (This however does not imply that no subset
of <i>B</i> could also serve as a base.)
Note that different reduced bases for one permutation group <i>G</i>
may have different lengths.
For example, the irreducible degree 416 permutation representation
of the Chevalley Group <i>G</i><sub>2</sub>(4) possesses reduced bases of length 5 and 7.
<p>
Let <i>R</i><sup>(<i>i</i>)</sup> be a right transversal of <i>G</i><sup>(<i>i</i>+1)</sup> in <i>G</i><sup>(<i>i</i>)</sup>, i.e. a set
of right coset representatives of the cosets of <i>G</i><sup>(<i>i</i>+1)</sup> in <i>G</i><sup>(<i>i</i>)</sup>.
Then each element <i>g</i> of <i>G</i> has a unique representation of the form <i>g</i> = <i>r</i><sub><i>n</i></sub> &#8230;<i>r</i><sub>1</sub> with <i>r</i><sub><i>i</i></sub>  &#8712; <i>R</i><sup>(<i>i</i>)</sup>.
The cosets of <i>G</i><sup>(<i>i</i>+1)</sup> in <i>G</i><sup>(<i>i</i>)</sup> are in bijective correspondence with
the points in <i>O</i><sup>(<i>i</i>)</sup> : = <i>b</i><sub><i>i</i></sub><sup><i>G</i><sup>(<i>i</i>)</sup></sup>.
So we could represent a transversal as a list <i>T</i> such that <i>T</i>[<i>p</i>] is a
representative of the coset corresponding to the point <i>p</i>  &#8712; <i>O</i><sup>(<i>i</i>)</sup>,
i.e., an element of <i>G</i><sup>(<i>i</i>)</sup> that takes <i>b</i><sub><i>i</i></sub> to <i>p</i>.
(Note that such a list has holes in all positions corresponding to points
not contained in <i>O</i><sup>(<i>i</i>)</sup>.)
<p>
This approach however will store many different permutations as coset
representatives which can be a problem if the degree <i>n</i> gets bigger. Our
goal therefore is to store as few different permutations as possible such
that we can still reconstruct each representative in <i>R</i><sup>(<i>i</i>)</sup>, and from
them the elements in <i>G</i>. A <strong>factorized inverse transversal</strong> <i>T</i> is a list
where <i>T</i>[<i>p</i>] is a generator of <i>G</i><sup>(<i>i</i>)</sup> such that <i>p</i><sup><i>T</i>[<i>p</i>]</sup> is a point
that lies earlier in <i>O</i><sup>(<i>i</i>)</sup> than <i>p</i> (note that we consider <i>O</i><sup>(<i>i</i>)</sup> as
a list, not as a set). If we assume inductively that we know an element <i>r</i>  &#8712; <i>G</i><sup>(<i>i</i>)</sup> that takes <i>b</i><sub><i>i</i></sub> to <i>p</i><sup><i>T</i>[<i>p</i>]</sup>, then <i>r</i> <i>T</i>[<i>p</i>]<sup>&#8722;1</sup> is an
element in <i>G</i><sup>(<i>i</i>)</sup> that takes <i>b</i><sub><i>i</i></sub> to <i>p</i>. <font face="Gill Sans,Helvetica,Arial">GAP</font> uses such factorized
inverse transversals.
<p>
Another name for a factorized inverse transversal is a
<strong>Schreier tree</strong>. The vertices of the tree are the points in <i>O</i><sup>(<i>i</i>)</sup>,
and the root of the tree is <i>b</i><sub><i>i</i></sub>.
The edges are defined as the ordered pairs (<i>p</i>, <i>p</i><sup><i>T</i>[<i>p</i>]</sup>),
for <i>p</i>  &#8712; <i>O</i><sup>(<i>i</i>)</sup> \{ <i>b</i><sub><i>i</i></sub>}. The edge (<i>p</i>, <i>p</i><sup><i>T</i>[<i>p</i>]</sup>)
is labelled with the generator <i>T</i>[<i>p</i>], and the product of edge labels
along the unique path from <i>p</i> to <i>b</i><sub><i>i</i></sub> is the inverse of the
transversal element carrying <i>b</i><sub><i>i</i></sub> to <i>p</i>.
<p>
Before we describe the construction of stablizer chains
in&nbsp;<a href="CHAP041.htm#SECT007">Construction of Stabilizer Chains</a>,
we explain in&nbsp;<a href="CHAP041.htm#SECT006">Randomized Methods for Permutation Groups</a> the idea of
using non-deterministic algorithms;
this is necessary for understanding the options available for the
construction of stabilizer chains.
After that, in&nbsp;<a href="CHAP041.htm#SECT008">Stabilizer Chain Records</a> it is explained
how a stabilizer chain is stored in <font face="Gill Sans,Helvetica,Arial">GAP</font>,
<a href="CHAP041.htm#SECT009">Operations for Stabilizer Chains</a> lists operations for stabilizer
chains,
and&nbsp;<a href="CHAP041.htm#SECT010">Low Level Routines to Modify and Create Stabilizer Chains</a> lists
low level routines for manipulating stabilizer chains.
<p>
<p>
<h2><a name="SECT006">41.6 Randomized Methods for Permutation Groups</a></h2>
<p><p>
<a name = "I0"></a>

For most computations with permutation groups,
it is crucial to construct stabilizer chains efficiently. Sims's
original construction <a href="biblio.htm#Sim70"><cite>Sim70</cite></a> is deterministic, and is called
the Schreier-Sims algorithm, because it is based
on Schreier's Lemma (p. 96 in <a href="biblio.htm#Hall"><cite>Hall</cite></a>): given <i>K</i>=&#9001;<i>S</i> &#9002;
and a transversal <i>T</i> for <i>K</i> mod <i>L</i>, one can obtain
&#124;<i>S</i>&#124;&#124;<i>T</i>&#124; generators for <i>L</i>. This lemma is applied recursively,
with consecutive point stabilizers <i>G</i><sup>(<i>i</i>)</sup> and <i>G</i><sup>(<i>i</i>+1)</sup>
playing the role of <i>K</i> and <i>L</i>.
<p>
In permutation groups of large degree, the number of Schreier generators
to be processed becomes too large, and the deterministic Schreier-Sims
algorithm becomes impractical. Therefore, <font face="Gill Sans,Helvetica,Arial">GAP</font> uses randomized
algorithms. The method selection process, which is quite different
from Version 3, works the following way.
<p>
If a group acts on not more than a hundred points,
Sims's original deterministic algorithm is applied. In groups of
degree greater than hundred, a heuristic algorithm based
on ideas in <a href="biblio.htm#BCFS91"><cite>BCFS91</cite></a> constructs a stabilizer chain.
This construction is complemented by a
verify-routine that either proves the correctness of the stabilizer chain
or causes the extension of the chain to a correct one.
The user can influence the verification process by setting
the value of the record component <code>random</code>
(cf.&nbsp;<a href="CHAP041.htm#SECT007">Construction of Stabilizer Chains</a>).
<p>
If <code>random</code> =1000 then a slight extension of an unpublished method of
Sims is used. The outcome of this verification process is always
correct. The user also can prescribe any integer 1  &#8804; <i>x</i>  &#8804; 999
as the value of <code>random</code>. In this case, a randomized verification
process from <a href="biblio.htm#BCFS91"><cite>BCFS91</cite></a> is applied, and the result of the
stabilizer chain construction is guaranteed to be correct with probability
at least <i>x</i>/1000. The practical performance of the algorithm is
much better than the theoretical guarantee.
<p>
If the stabilizer chain is not correct then the elements in the
product of transversals <i>R</i><sup>(<i>m</i>)</sup><i>R</i><sup>(<i>m</i>&#8722;1)</sup>&#8230;<i>R</i><sup>(1)</sup> constitute a
proper subset of the group <i>G</i> in question.
This means that a membership test with this stabilizer chain
returns <code>false</code> for
all elements that are not in <i>G</i>,
but it may also return <code>false</code> for some elements of <i>G</i>;
in other words, the result <code>true</code> of a membership test is always correct,
whereas the result <code>false</code> may be incorrect.
<p>
The construction and verification phases are separated because
there are situations where the verification step can be omitted;
if one happens to know the order of the group in advance then the
randomized construction of the stabilizer chain stops
as soon as the product of the lengths of the basic orbits
of the chain equals the group order, and the chain will be correct
(see the <code>size</code> option of the <code>StabChain</code> command in&nbsp;<a href="CHAP041.htm#SSEC007.1">StabChain</a>).
<p>
Although the worst case running time is roughly quadratic for
Sims's verification and roughly linear for the randomized one,
in most examples the running time of the stabilizer chain
construction with <code>random</code>=1000 (i.e., guaranteed correct output)
is about the same as the running time of randomized verification
with guarantee of at least 90% correctness. Therefore, we suggest
to use the default value <code>random</code>=1000. Possible uses of
<code>random</code> &lt; 1000 are when one has to run through a large collection
of subgroups, and a low value of random is used to choose quickly
a candidate for more thorough examination; another use is when
the user suspects that the quadratic bottleneck of the guaranteed
correct verification is hit.
<p>
We will illustrate these ideas in two examples.
<p>
<pre>
gap&gt; h:= SL(4,7);;
gap&gt; o:= Orbit( h, [1,0,0,0]*Z(7)^0, OnLines );;
gap&gt; op:= Action( h, o, OnLines );;
gap&gt; NrMovedPoints( op );
400
</pre>
<p>
We created a permutation group on 400 points.
First we compute a guaranteed correct stabilizer chain.
(The <code>StabChain</code> command is described in&nbsp;<a href="CHAP041.htm#SSEC007.1">StabChain</a>.)
<p>
<pre>
gap&gt; h:= Group( GeneratorsOfGroup( op ) );;
gap&gt; StabChain( h );;  time;
1120
gap&gt; Size( h );
2317591180800
</pre>
<p>
Now randomized verification will be used.
We require that the result is guaranteed correct with probability 90%.
This means that if we would do this calculation many times over,
<font face="Gill Sans,Helvetica,Arial">GAP</font> would <strong>guarantee</strong> that in least 90% percent of all calculations
the result is correct.
In fact the results are much better than the guarantee,
but we cannot promise that this will really happen.
(For the meaning of the <code>random</code> component in the second argument of
<code>StabChain</code>, see&nbsp;<a href="CHAP041.htm#SSEC007.1">StabChain</a>.)
<p>
First the group is created anew.
<p>
<pre>
gap&gt; h:= Group( GeneratorsOfGroup( op ) );;
gap&gt; StabChain( h, rec( random:= 900 ) );;  time;
1410
gap&gt; Size( h );
2317591180800
</pre>
<p>
The result is still correct, and the running time is actually somewhat
slower.
If you give the algorithm additional information so that it can check
its results,
things become faster and the result is guaranteed to be correct.
<p>
<pre>
gap&gt; h:=Group( GeneratorsOfGroup( op ) );;
gap&gt; SetSize( h, 2317591180800 );
gap&gt; StabChain( h );;  time;
170
</pre>
<p>
The second example gives a typical group when the verification
with <code>random</code> =1000 is slow. The problem is that the group
has a stabilizer subgroup <i>G</i><sup>(<i>i</i>)</sup> such that the fundamental
orbit <i>O</i><sup>(<i>i</i>)</sup> is split into a lot of orbits when we stabilize
<i>b</i><sub><i>i</i></sub> and one additional point of <i>O</i><sup>(<i>i</i>)</sup>.
<p>
<pre>
gap&gt; p1:=PermList(Concatenation([401],[1..400]));;
gap&gt; p2:=PermList(List([1..400],i-&gt;(i*20 mod 401)));;
gap&gt; d:=DirectProduct(Group(p1,p2),SymmetricGroup(5));;
gap&gt; h:=Group(GeneratorsOfGroup(d));;
gap&gt; StabChain(h);;time;Size(h);
1030
192480
gap&gt; h:=Group(GeneratorsOfGroup(d));;
gap&gt; StabChain(h,rec(random:=900));;time;Size(h);
570
192480
</pre>
<p>
When stabilizer chains of a group <i>G</i> are created
with <code>random</code>  &lt; 1000, this is noted in the group <i>G</i>,
by setting of the record component <code>random</code>
in the value of the attribute <code>StabChainOptions</code> for <i>G</i>
(see&nbsp;<a href="CHAP041.htm#SSEC007.2">StabChainOptions</a>).
As errors induced by the random methods might propagate,
any group or homomorphism created from <i>G</i> inherits a <code>random</code> component
in its <code>StabChainOptions</code> from the corresponding component for <i>G</i>.
<p>
A lot of algorithms dealing with permutation groups use randomized
methods; however, if the initial stabilizer chain construction
for a group is correct, these further methods will provide
guaranteed correct output.
<p>
<p>
<h2><a name="SECT007">41.7 Construction of Stabilizer Chains</a></h2>
<p><p>
<a name = "SSEC007.1"></a>
<li><code>StabChain( </code><var>G</var><code>[, </code><var>options</var><code>] ) F</code>
<li><code>StabChain( </code><var>G</var><code>, </code><var>base</var><code> ) F</code>
<a name = "SSEC007.1"></a>
<li><code>StabChainOp( </code><var>G</var><code>, </code><var>options</var><code> ) O</code>
<a name = "SSEC007.1"></a>
<li><code>StabChainMutable( </code><var>G</var><code> ) AM</code>
<li><code>StabChainMutable( </code><var>permhomom</var><code> ) AM</code>
<a name = "SSEC007.1"></a>
<li><code>StabChainImmutable( </code><var>G</var><code> ) A</code>
<p>
These commands compute a stabilizer chain for the permutation group <var>G</var>;
additionally, <code>StabChainMutable</code> is also an attribute for the group
homomorphism <var>permhomom</var> whose source is a permutation group.
<p>
<code>StabChainOp</code> is an operation with two arguments <var>G</var> and <var>options</var>,
the latter being a record which controls some aspects of the computation
of a stabilizer chain (see below);
<code>StabChainOp</code> returns a <strong>mutable</strong> stabilizer chain.
<code>StabChainMutable</code> is a <strong>mutable</strong> attribute for groups or homomorphisms,
its default method for groups is to call <code>StabChainOp</code> with empty
options record.
<code>StabChainImmutable</code> is an attribute with <strong>immutable</strong> values;
its default method dispatches to <code>StabChainMutable</code>.
<p>
<code>StabChain</code> is a function with first argument a permutation group <var>G</var>,
and optionally a record <var>options</var> as second argument.
If the value of <code>StabChainImmutable</code> for <var>G</var> is already known and if this
stabilizer chain matches the requirements of <var>options</var>,
<code>StabChain</code> simply returns this stored stabilizer chain.
Otherwise <code>StabChain</code> calls <code>StabChainOp</code> and returns an immutable copy
of the result; additionally, this chain is stored as <code>StabChainImmutable</code>
value for <var>G</var>.
If no <var>options</var> argument is given,
its components default to the global variable <code>DefaultStabChainOptions</code>
(see&nbsp;<a href="CHAP041.htm#SSEC007.3">DefaultStabChainOptions</a>).
If <var>base</var> is a list of positive integers,
the version <code>StabChain( </code><var>G</var><code>, </code><var>base</var><code> )</code> defaults to
<code>StabChain( </code><var>G</var><code>, rec( base:= </code><var>base</var><code> ) )</code>.
<p>
If given, <var>options</var> is a record whose components specify properties of
the desired stabilizer chain or which may help the algorithm.
Default values for all of them can be given in the global variable
<code>DefaultStabChainOptions</code> (see&nbsp;<a href="CHAP041.htm#SSEC007.3">DefaultStabChainOptions</a>).
The following options are supported.
<p>
<dl compact>
<dt><code>base</code> (default an empty list) <dd>
    A list of points, through which the resulting stabilizer chain
    shall run.
    For the base <i>B</i> of the resulting stabilizer chain <var>S</var> this means
    the following.
    If the <code>reduced</code> component of <var>options</var> is <code>true</code> then those points
    of <code>base</code> with nontrivial basic orbits form the initial segment
    of <i>B</i>, if the <code>reduced</code> component is <code>false</code> then <code>base</code> itself
    is the initial segment of <i>B</i>.
    Repeated occurrences of points in <code>base</code> are ignored.
    If a stabilizer chain for <var>G</var> is already known then the stabilizer
    chain is computed via a base change.
<p>
<dt><code>knownBase</code> (no default value) <dd>
    A list of points which is known to be a base for the group.
    Such a known base makes it easier to test whether a permutation
    given as a word in terms of a set of generators is the identity,
    since it suffices to map the known base with each factor
    consecutively, rather than multiplying the whole permutations
    (which would mean to map every point).
    This speeds up the Schreier-Sims algorithm which is used when a new
    stabilizer chain is constructed;
    it will not affect a base change, however.
    The component <code>knownBase</code> bears no relation to the <code>base</code>
    component, you may specify a known base <code>knownBase</code> and a desired
    base <code>base</code> independently.
<p>
<dt><code>reduced</code> (default <code>true</code>) <dd>
    If this is <code>true</code> the resulting stabilizer chain <var>S</var> is reduced,
    i.e., the case  <i>G</i><sup>(<i>i</i>)</sup> = <i>G</i><sup>(<i>i</i>+1)</sup> does not occur.
    Setting <code>reduced</code> to <code>false</code> makes sense only if the component
    <code>base</code> (see above) is also set;
    in this case all points of <code>base</code> will occur in the base <i>B</i> of <var>S</var>,
    even if they have trivial basic orbits.
    Note that if <code>base</code> is just an initial segment of <i>B</i>,
    the basic orbits of the points in <i>B</i> \<tt>base</tt> are always
    nontrivial.
<p>
<dt><code>tryPcgs</code> (default <code>true</code>) <dd>
    If this is <code>true</code> and either the degree is at most 100 or the group
    is known to be solvable, <font face="Gill Sans,Helvetica,Arial">GAP</font> will first try to construct a pcgs
    (see Chapter&nbsp;<a href="CHAP043.htm">Polycyclic Groups</a>) for <var>G</var> which will succeed and
    implicitly construct a stabilizer chain if <var>G</var> is solvable.
    If <var>G</var> turns out non-solvable, one of the other methods will be used.
    This solvability check is comparatively fast, even if it fails,
    and it can save a lot of time if <var>G</var> is solvable.
<p>
<dt><code>random</code> (default <code>1000</code>) <dd>
    If the value is less than&nbsp;1000,
    the resulting chain is correct with probability
    at least&nbsp;<tt>random</tt>/1000.
    The <code>random</code> option is explained in more detail
    in&nbsp;<a href="CHAP041.htm#SECT006">Randomized Methods for Permutation Groups</a>.
<p>
<code>size</code> (default <code>Size( </code><var>G</var><code> )</code> if this is known,
<dt>        i.e., if <code>HasSize( </code><var>G</var><code> )</code> is <code>true</code>) <dd>
    If this component is present, its value is assumed to be the order
    of the group <var>G</var>.
    This information can be used to prove that a non-deterministically
    constructed stabilizer chain is correct.
    In this case, <font face="Gill Sans,Helvetica,Arial">GAP</font> does a non-deterministic construction until the
    size is correct.
<p>
<code>limit</code> (default <code>Size( Parent( </code><var>G</var><code> ) )</code> or
<dt>         <code>StabChainOptions( Parent( </code><var>G</var><code> ) ).limit</code> if this is present) <dd>
    If this component is present, it must be greater than or equal to
    the order of <var>G</var>.
    The stabilizer chain construction stops if size <code>limit</code> is reached.
</dl>
<p>
<a name = "SSEC007.2"></a>
<li><code>StabChainOptions( </code><var>G</var><code> ) AM</code>
<p>
is a record that stores the options with which the stabilizer chain
stored in <code>StabChainImmutable</code> has been computed
(see&nbsp;<a href="CHAP041.htm#SSEC007.1">StabChain</a> for the options that are supported).
<p>
<a name = "SSEC007.3"></a>
<li><code>DefaultStabChainOptions V</code>
<p>
are the options for <code>StabChain</code> which are set as default.
<p>
<a name = "SSEC007.4"></a>
<li><code>StabChainBaseStrongGenerators( </code><var>base</var><code>, </code><var>sgs</var><code>, </code><var>one</var><code> ) F</code>
<p>
If a base <var>base</var> for a permutation group <i>G</i> and a strong generating set
<var>sgs</var> for <i>G</i> with respect to <var>base</var> are given. <var>one</var> must be the
appropriate <code>One</code> (in most cases this will be <code>()</code>).
This function constructs a stabilizer chain  without the need to find
Schreier generators;
so this is much faster than the other algorithms.
<p>
<a name = "SSEC007.5"></a>
<li><code>MinimalStabChain( </code><var>G</var><code> ) A</code>
<p>
returns the reduced stabilizer chain corresponding to the base
[1,2,3,4,&#8230;].
<p>
<p>
<h2><a name="SECT008">41.8 Stabilizer Chain Records</a></h2>
<p><p>
If a  permutation group  has a   stabilizer chain, this   is stored  as a
recursive structure. This  structure  is itself  a record&nbsp;<var>S</var>  and it has
(1)&nbsp;components that provide information about  one level&nbsp;<i>G</i><sup>(<i>i</i>)</sup> of the
stabilizer chain (which  we call  the  ``current stabilizer'')  and (2)&nbsp;a
component <code>stabilizer</code>  that  holds   another such  record,   namely  the
stabilizer chain  of    the next stabilizer&nbsp;<i>G</i><sup>(<i>i</i>+1)</sup>.  This  gives   a
recursive  structure  where the  ``outermost''  record  representing  the
``topmost'' stabilizer is bound to the group record component <code>stabChain</code>
and   has the components explained below.
Note: Since the structure is recursive, <strong>never print a stabilizer chain!</strong>
(Unless you want to exercise the scrolling capabilities of your terminal.)
<p>
<dl compact>
<dt><code>identity</code> <dd>
        the identity element of the current stabilizer.
<p>
<dt><code>labels</code> <dd>
        a list of permutations which contains labels for the Schreier tree
        of  the current stabilizer,  i.e., it contains
        elements for the factorized
        inverse transversal.  The  first entry  is this list  is
        always the  <code>identity</code>.
        Note that <font face="Gill Sans,Helvetica,Arial">GAP</font> tries to arrange things so that the <code>labels</code>
        components are identical (i.e., the same <font face="Gill Sans,Helvetica,Arial">GAP</font> object)
        in every stabilizer of the chain;
        thus the <code>labels</code> of a stabilizer do not necessarily all lie
        in the this stabilizer (but see <code>genlabels</code> below).
<p>
<dt><code>genlabels</code> <dd>
        a list of integers indexing some of the permutations in the
        <code>labels</code> component. The    <code>labels</code> addressed in this   way
        form a generating set for the current stabilizer. If the
        <code>genlabels</code> component is empty,  the rest of the stabilizer chain
        represents  the trivial subgroup, and  can be ignored, e.g., when
        calculating the size.
<p>
<dt><code>generators</code> <dd>
        a list of generators for the current stabilizer. Usually, it is
        <code>labels{ genlabels }</code>.
<p>
<dt><code>orbit</code> <dd>
        the vertices of  the Schreier tree,  which  form the basic  orbit
        <i>b</i><sub><i>i</i></sub><sup><i>G</i><sup>(<i>i</i>)</sup></sup>, ordered in such a way that the  base point <i>b</i><sub><i>i</i></sub> is
<p>
<dt><code>transversal</code> <dd>
	The factorized inverse transversal found during the orbit algorithm.
	The element <var>g</var> stored at <code>transversal[</code><var>i</var><code>]</code> will map <var>i</var> to another
	point <var>j</var> that in the Schreier tree is closer to the base point. By
	iterated application (<code>transversal[</code><var>j</var><code>]</code> and so on) eventually the
	base point is reached and an element that maps <var>i</var> to the base
	point foiund as product.
<p>
<dt><code>translabels</code> <dd>
	An index list such that 
	<code>transversal[</code><var>j</var><code>] =  labels[ translabels[</code><var>j</var><code>] ]</code>.
	This list takes up comparatively little memory and is used to speed
	up base changes.
<p>
<dt><code>stabilizer</code> <dd>
        If  the  current stabilizer is  not   yet the trivial  group, the
        stabilizer chain continues with   the stabilizer of  the  current
        base  point,  which is    again  represented as  a   record  with
        components <code>labels</code>,    <code>identity</code>,    <code>genlabels</code>, <code>generators</code>,
        <code>orbit</code>,     <code>translabels</code>,  <code>transversal</code>     (and      possibly
        <code>stabilizer</code>). This record is bound to the <code>stabilizer</code> component
        of the current stabilizer. The last member  of a stabilizer chain
        is recognized  by the fact that  it has no <code>stabilizer</code> component
        bound.
</dl>
It is possible that different stabilizer  chains share the same record as
one of their iterated <code>stabilizer</code> components.
<p>
<pre>
gap&gt; g:=Group((1,2,3,4),(1,2));;
gap&gt; StabChain(g);
&lt;stabilizer chain record, Base [ 1, 2, 3 ], Orbit length 4, Size: 24&gt;
gap&gt; BaseOfGroup(g);
[ 1, 2, 3 ]
gap&gt; StabChainOptions(g);
rec( random := 1000 )
gap&gt; DefaultStabChainOptions;
rec( reduced := true, random := 1000, tryPcgs := true )
</pre>
<p>
<p>
<h2><a name="SECT009">41.9 Operations for Stabilizer Chains</a></h2>
<p><p>
<a name = "SSEC009.1"></a>
<li><code>BaseStabChain( </code><var>S</var><code> ) F</code>
<p>
returns the base belonging to the stabilizer chain <var>S</var>.
<p>
<a name = "SSEC009.2"></a>
<li><code>BaseOfGroup( </code><var>G</var><code> ) A</code>
<p>
returns a base of the permutation group <var>G</var>.
There is <strong>no</strong> guarantee that a stabilizer chain stored in <var>G</var>
corresponds to this base!
<p>
<a name = "SSEC009.3"></a>
<li><code>SizeStabChain( </code><var>S</var><code> ) F</code>
<p>
returns the product of the orbit lengths in the stabilizer chain <var>S</var>,
that is, the order of the group described by <var>S</var>.
<p>
<a name = "SSEC009.4"></a>
<li><code>StrongGeneratorsStabChain( </code><var>S</var><code> ) F</code>
<p>
returns a strong generating set corresponding to the stabilizer chain <var>S</var>.
<p>
<a name = "SSEC009.5"></a>
<li><code>GroupStabChain( [</code><var>G</var><code>, ] </code><var>S</var><code> ) F</code>
<p>
constructs a permutation group with stabilizer chain <var>S</var>, i.e., a group
with  generators <code>Generators( </code><var>S</var><code>  )</code>   to  which <var>S</var> is assigned as
component  <code>stabChain</code>. If the  optional argument <var>G</var> is  given, the
result  will have the parent <var>G</var>.
<p>
<a name = "SSEC009.6"></a>
<li><code>OrbitStabChain( </code><var>S</var><code>, </code><var>pnt</var><code> ) F</code>
<p>
returns the orbit of <var>pnt</var> under the group described by the stabilizer
chain <var>S</var>.
<p>
<a name = "SSEC009.7"></a>
<li><code>IndicesStabChain( </code><var>S</var><code> ) F</code>
<p>
 returns a list of the indices of the stabilizers in the stabilizer
 chain <var>S</var>.
<p>
<a name = "SSEC009.8"></a>
<li><code>ListStabChain( </code><var>S</var><code> ) F</code>
<p>
returns a list that contains at position <i>i</i> the stabilizer of the first
<i>i</i>&#8722;1 base points in the stabilizer chain <var>S</var>.
<p>
<a name = "SSEC009.9"></a>
<li><code>ElementsStabChain( </code><var>S</var><code> ) F</code>
<p>
returns a list of all elements of the group described by the stabilizer
chain <var>S</var>.
<p>
<a name = "SSEC009.10"></a>
<li><code>InverseRepresentative( </code><var>S</var><code>, </code><var>pnt</var><code> ) F</code>
<p>
calculates the transversal element which  maps <var>pnt</var> back to  the base
point of  <var>S</var>. It just  runs back through the  Schreier tree from <var>pnt</var>
to the root and multiplies the labels along the way.
<p>
<a name = "SSEC009.11"></a>
<li><code>SiftedPermutation( </code><var>S</var><code>, </code><var>g</var><code> ) F</code>
<p>
sifts the permutation <var>g</var> through the stabilizer chain <var>S</var> and returns
the result after the last step.
<p>
The element <var>g</var> is sifted as follows: <var>g</var> is replaced by
<code></code><var>g</var><code> * InverseRepresentative( </code><var>S</var><code>, </code><var>S</var><code>.orbit[1]^</code><var>g</var><code> )</code>,
then <var>S</var> is replaced by <code></code><var>S</var><code>.stabilizer</code> and this process is repeated
until <var>S</var> is trivial or <code></code><var>S</var><code>.orbit[1]^</code><var>g</var><code></code> is not in the basic orbit
<code></code><var>S</var><code>.orbit</code>.
The remainder <var>g</var> is returned, it is the identity permutation if and
only if the original <var>g</var> is in the group <i>G</i> described by
the original&nbsp;<var>S</var>.
<p>
<a name = "SSEC009.12"></a>
<li><code>MinimalElementCosetStabChain( </code><var>S</var><code>, </code><var>g</var><code> ) F</code>
<p>
Let <i>G</i> be the group described by the stabilizer chain <var>S</var>.
This function returns a permutation <i>h</i> such that <i>G</i> <i>g</i>  = <i>G</i> <i>h</i>
(that is, <i>g</i>  / <i>h</i>  &#8712; <i>G</i>) and with the additional property that
the list of images under <i>h</i> of the base belonging to <var>S</var> is minimal
w.r.t.&nbsp;lexicographical ordering.
<p>
<a name = "SSEC009.13"></a>
<li><code>LargestElementStabChain( </code><var>S</var><code>, </code><var>id</var><code> ) F</code>
<p>
Let <i>G</i> be the group described by the stabilizer chain <var>S</var>.
This function returns the element <i>h</i>  &#8712; <i>G</i> with the property that
the list of images under <i>h</i> of the base belonging to <var>S</var> is maximal
w.r.t.&nbsp;lexicographical ordering.
The second argument must be an identity element (used to start the
recursion)
<p>
<a name = "SSEC009.14"></a>
<li><code>ApproximateSuborbitsStabilizerPermGroup( </code><var>G</var><code>, </code><var>pnt</var><code> ) F</code>
<p>
returns an approximation of the orbits of <code>Stabilizer( </code><var>G</var><code>, </code><var>pnt</var><code> )</code>
on all points of the orbit <code>Orbit( </code><var>G</var><code>, </code><var>pnt</var><code> )</code>,
without computing the full point stabilizer;
As not all Schreier generators are used,
the result may represent the orbits of only a subgroup of the point
stabilizer.
<p>
<p>
<h2><a name="SECT010">41.10 Low Level Routines to Modify and Create Stabilizer Chains</a></h2>
<p><p>
These operations modify a stabilizer chain or obtain new chains with
specific properties. They are rather technical and should only be used if
such low-level routines are deliberately required. (For all functions in
this section the parameter <var>S</var> is a stabilizer chain.)
<p>
<a name = "SSEC010.1"></a>
<li><code>CopyStabChain( </code><var>S</var><code> ) F</code>
<p>
This function returns a copy of the stabilizer chain <var>S</var>
that has no mutable object (list or record) in common with <var>S</var>.
The <code>labels</code>  components of the result are possibly shared by several
levels, but superfluous labels are removed.
(An entry in <code>labels</code> is superfluous if it does not occur among the
<code>genlabels</code> or <code>translabels</code> on any of the levels which share that
<code>labels</code> component.)
<p>
This is useful for  stabiliser sub-chains that  have been obtained as
the (iterated) <code>stabilizer</code> component of a bigger chain.
<p>
<a name = "SSEC010.2"></a>
<li><code>CopyOptionsDefaults( </code><var>G</var><code>, </code><var>options</var><code> ) F</code>
<p>
sets components in a stabilizer chain options record <var>options</var> according
to what is known about the group <var>G</var>. This can be used to obtain a new
stabilizer chain for <var>G</var> quickly.
<p>
<a name = "SSEC010.3"></a>
<li><code>ChangeStabChain( </code><var>S</var><code>, </code><var>base</var><code>[, </code><var>reduced</var><code>] ) F</code>
<p>
changes or reduces a stabilizer chain <var>S</var> to be adapted to the base
<var>base</var>.
The optional argument <var>reduced</var> is interpreted as follows.
<p>
<dl compact>
<dt><code>reduced = false</code> : <dd>
    change the stabilizer chain, do not reduce it,
<p>
<dt><code>reduced = true</code> : <dd>
    change the stabilizer chain, reduce it.
</dl>
<p>
<a name = "SSEC010.4"></a>
<li><code>ExtendStabChain( </code><var>S</var><code>, </code><var>base</var><code> ) F</code>
<p>
extends the stabilizer chain <var>S</var> so that it corresponds to base <var>base</var>.
The original base of <var>S</var> must be a subset of <var>base</var>.
<p>
<a name = "SSEC010.5"></a>
<li><code>ReduceStabChain( </code><var>S</var><code> ) F</code>
<p>
changes the stabilizer chain <var>S</var> to a reduced stabilizer chain by
eliminating trivial steps.
<p>
<a name = "SSEC010.6"></a>
<li><code>RemoveStabChain( </code><var>S</var><code> ) F</code>
<p>
<var>S</var> must be a stabilizer record in a stabilizer chain. This chain then
is cut off at <var>S</var> by changing the entries in <var>S</var>. This can be used to
remove trailing trivial steps.
<p>
<a name = "SSEC010.7"></a>
<li><code>EmptyStabChain( </code><var>labels</var><code>, </code><var>id</var><code>[, </code><var>pnt</var><code>] ) F</code>
<p>
constructs  a   stabilizer  chain  for   the trivial   group with
<code>identity=</code><var>id</var><code></code> and <code>labels={<i>id</i>}&#8746;<i>labels</i></code>  (but of course with
<code>genlabels=[ ]</code> and <code>generators=[ ]</code>). If the optional third argument
<var>pnt</var>  is present, the only stabilizer   of the chain is initialized
with the  one-point basic orbit  <code>[ </code><var>pnt</var><code> ]</code> and with <code>translabels</code> and
<code>transversal</code> components.
<p>
<a name = "SSEC010.8"></a>
<li><code>InsertTrivialStabilizer( </code><var>S</var><code>, </code><var>pnt</var><code> ) F</code>
<p>
<code>InsertTrivialStabilizer</code> initializes the current stabilizer with <var>pnt</var>
as <code>EmptyStabChain</code> did,  but  assigns the original <var>S</var> to the  new
<code></code><var>S</var><code>.stabilizer</code> component,  such that  a new level with trivial basic
orbit (but identical  <code>labels</code> and <code>ShallowCopy</code>ed <code>genlabels</code> and
<code>generators</code>) is  inserted.
This function should be used only if <var>pnt</var> really is fixed by the generators
of <var>S</var>, because then new generators can be added and the orbit and
transversal at the same time extended with
<code>AddGeneratorsExtendSchreierTree</code>.
<p>
<a name = "SSEC010.9"></a>
<li><code>IsFixedStabilizer( </code><var>S</var><code>, </code><var>pnt</var><code> ) F</code>
<p>
returns <code>true</code>  if <var>pnt</var> is fixed by   all generators of  <var>S</var> and <code>false</code>
otherwise.
<p>
<a name = "SSEC010.10"></a>
<li><code>AddGeneratorsExtendSchreierTree( </code><var>S</var><code>, </code><var>new</var><code> ) F</code>
<p>
adds the elements  in <var>new</var> to the list  of generators of <var>S</var> and at the
same time extends the  orbit and transversal. This is the only legal way
to extend  a  Schreier tree (because this involves careful handling of
the tree components).
<p>
<p>
<h2><a name="SECT011">41.11 Backtrack</a></h2>
<p><p>
A main use for stabilizer chains is in backtrack algorithms for permutation
groups. <font face="Gill Sans,Helvetica,Arial">GAP</font> implements a partition-backtrack algorithm as described in
<a href="biblio.htm#Leon91"><cite>Leon91</cite></a> and refined in <a href="biblio.htm#Theissen97"><cite>Theissen97</cite></a>.
<p>
<a name = "SSEC011.1"></a>
<li><code>SubgroupProperty( </code><var>G</var><code>, </code><var>Pr</var><code>[, </code><var>L</var><code> ] ) F</code>
<p>
<var>Pr</var> must be a one-argument function that returns <code>true</code> or <code>false</code> for
elements of <var>G</var> and the subset of elements of <var>G</var> that fulfill <var>Pr</var> must
be a subgroup. (<strong>If the latter is not true the result of this operation
is unpredictable!</strong>) This command computes this subgroup.
The optional argument <var>L</var> must be a subgroup of the set of all elements
fulfilling <var>Pr</var> and can be given if known
in order to speed up the calculation.
<p>
<a name = "SSEC011.2"></a>
<li><code>ElementProperty( </code><var>G</var><code>, </code><var>Pr</var><code>[, </code><var>L</var><code>[, </code><var>R</var><code>]] ) F</code>
<p>
<code>ElementProperty</code> returns an element &#960; of the permutation group <var>G</var>
such that the one-argument function <var>Pr</var> returns <code>true</code> for &#960;.
It returns <code>fail</code> if no such element exists in <var>G</var>.
The optional arguments <var>L</var> and <var>R</var> are subgroups of <var>G</var> such that the
property <var>Pr</var> has the same value for all elements in the cosets <var>L</var><var>g</var>
and <var>g</var><var>R</var>, respectively.
<p>
A typical example of using the optional subgroups <var>L</var> and <var>R</var> is the
conjugacy test for elements <var>a</var> and <var>b</var> for which one can set
<i>L</i> :=<i>C</i><sub><i>G</i></sub>(<i>a</i> ) and <i>R</i> :=<i>C</i><sub><i>G</i></sub>(<i>b</i> ).
<p>
<pre>
gap&gt; propfun:= el -&gt; (1,2,3)^el in [ (1,2,3), (1,3,2) ];;
gap&gt; SubgroupProperty( g, propfun, Subgroup( g, [ (1,2,3) ] ) );
Group([ (1,2,3), (2,3) ])
gap&gt; ElementProperty( g, el -&gt; Order( el ) = 2 );
(2,4)
</pre>
<p>
Chapter&nbsp;<a href="CHAP040.htm">Permutations</a> describes special operations to construct
permutations in the symmetric group without using backtrack constructions.
<p>
Backtrack routines are also called by the methods for permutation groups
that compute centralizers, normalizers, intersections, conjugating elements
as well as
stabilizers for the operations of a permutation group
<code>OnPoints</code>, <code>OnSets</code>, <code>OnTuples</code> and <code>OnSetSets</code>. Some of these methods use
more specific refinements than <code>SubgroupProperty</code> or <code>ElementProperty</code>.
For the definition of refinements, and how one can define refinements, see
Section&nbsp;<a href="../ext/CHAP008.htm#SECT002">The General Backtrack Algorithm with Ordered Partitions</a> in
``Extending <font face="Gill Sans,Helvetica,Arial">GAP</font>''.
<p>
<a name = "SSEC011.3"></a>
<li><code>TwoClosure( </code><var>G</var><code> ) A</code>
<p>
The <strong>2-closure</strong> of a transitive permutation group <var>G</var> on <i>n</i> points is
the largest subgroup of <i>S</i><sub><i>n</i></sub> which has the same orbits on sets of
ordered pairs of points as the group <var>G</var> has.
It also can be interpreted as the stabilizer of the orbital graphs of
<var>G</var>.
<p>
<pre>
gap&gt; TwoClosure(Group((1,2,3),(2,3,4)));
Sym( [ 1 .. 4 ] )
</pre>
<p>
<a name = "SSEC011.4"></a>
<li><code>InfoBckt V</code>
<p>
is the info class for the partition backtrack routines.
<p>
<p>
<h2><a name="SECT012">41.12 Working with large degree permutation groups</a></h2>
<p><p>
Permutation groups of large degree (usually at least a few 10000) can pose
a challenge to the heuristics used in the algorithms for permutation groups.
This section lists a few useful tricks that may speed up calculations with
such large groups enormously.
<p>
The first aspect concerns solvable groups: A lot of calculations (including
an initial stabilizer chain computation thanks to the algorithm from
<a href="biblio.htm#Sims90b"><cite>Sims90b</cite></a>) are faster if a permutation group is known to be solvable.
On the other hand, proving nonsolvability can be expensive for higher
degrees. Therefore <font face="Gill Sans,Helvetica,Arial">GAP</font> will automatically test a permutation group for
solvability, only if the degree is not exceeding 100.
(See also the <code>tryPcgs</code> component of <code>StabChainOptions</code>.)
It is therefore beneficial to tell a group of larger degree, which is known
to be solvable, that it is, using <code>SetIsSolvableGroup(</code><var>G</var><code>,true)</code>.
<p>
The second aspect concerns memory usage. A permutation on more than 65536
points requires 4 byte per point for storing. So permutations on 256000
poitns require roughly 1MB of storage per permutation. Just storing the
permutations required for a stabilizer chain might already go beyond the
available memory, in particular if the base is not very short. In such a
situation it can be useful, to replace the permutations by straight line
program elements (see&nbsp;<a href="CHAP035.htm#SECT009">Straight Line Program Elements</a>).
<p>
The following code gives an example of usage:
We create a group of degree 231000. Using straight line program elements,
one can compute a stabilizer chain in about 200 MB of memory.
<p>
<pre>
gap&gt; Read("largeperms"); # read generators from file
gap&gt; gens:=StraightLineProgGens(permutationlist);;
gap&gt; g:=Group(gens);
&lt;permutation group with 5 generators&gt;
gap&gt; # use random algorithm (faster, but result is monte carlo)
gap&gt; StabChainOptions(g).random:=1;;
gap&gt; Size(g); # enforce computation of a stabilizer chain
3529698298145066075557232833758234188056080273649172207877011796336000
</pre>
<p>
Without straight line program elements, the same calculation runs into
memory problems after a while even with 512MB of workspace:
<pre>
gap&gt; h:=Group(permutationlist);
&lt;permutation group with 5 generators&gt;
gap&gt; StabChainOptions(h).random:=1;;
gap&gt; Size(h);
exceeded the permitted memory (`-o' command line option) at
mlimit := 1; called from
SCRMakeStabStrong( S.stabilizer, [ g ], param, orbits, where, basesize,
 base, correct, missing, false ); called from
 SCRMakeStabStrong( S.stabilizer, [ g ], param, orbits, where, basesize,
...
</pre>
<p>
The advantage in memory usage however is paid for in runtime: Comparisons of
elements become much more expensive. One can avoid some of the related
problems by registering a known base with the straight line program elements
(see&nbsp;<code>StraightLineProgGens</code>). In this case element comparison will only
compare the images of the given base points.
If we are planning to do extensive calculations with the group, it can even
be worth to recreate it with straight line program elements knowing a
previously computed base:
<p>
<pre>
gap&gt; # get the base we computed already
gap&gt; bas:=BaseStabChain(StabChainMutable(g));
[ 1, 4, 7, 10, 13, 16, 19, 22, 25, 28, 31, 34, 37, 40, 43, 46, 49, 52, 55,
...
  2530, 2533, 2554, 2563, 2569 ]
gap&gt; gens:=StraightLineProgGens(permutationlist,bas);;
gap&gt; g:=Group(gens);;
gap&gt; SetSize(g,
&gt; 3529698298145066075557232833758234188056080273649172207877011796336000);
gap&gt; Random(g);; # enforce computation of a stabilizer chain
</pre>
<p>
As we know already base and size, this second stabilizer chain calculation
is much faster than the first one and takes less memory.
<p>
<p>
[<a href="../index.htm">Top</a>] [<a href = "chapters.htm">Up</a>] [<a href ="CHAP040.htm">Previous</a>] [<a href ="CHAP042.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<P>
<font face="Gill Sans,Helvetica,Arial">GAP 4 manual<br>September 2006
</font></body></html>