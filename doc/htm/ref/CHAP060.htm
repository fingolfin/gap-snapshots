<html><head><title>[ref] 60 Algebras</title></head>
<body text="#000000" bgcolor="#ffffff">
[<a href="../index.htm">Top</a>] [<a href = "chapters.htm">Up</a>] [<a href ="CHAP059.htm">Previous</a>] [<a href ="CHAP061.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<h1>60 Algebras</h1><p>
<P>
<H3>Sections</H3>
<oL>
<li> <A HREF="CHAP060.htm#SECT001">Constructing Algebras by Generators</a>
<li> <A HREF="CHAP060.htm#SECT002">Constructing Algebras as Free Algebras</a>
<li> <A HREF="CHAP060.htm#SECT003">Constructing Algebras by Structure Constants</a>
<li> <A HREF="CHAP060.htm#SECT004">Some Special Algebras</a>
<li> <A HREF="CHAP060.htm#SECT005">Subalgebras</a>
<li> <A HREF="CHAP060.htm#SECT006">Ideals</a>
<li> <A HREF="CHAP060.htm#SECT007">Categories and Properties of Algebras</a>
<li> <A HREF="CHAP060.htm#SECT008">Attributes and Operations for Algebras</a>
<li> <A HREF="CHAP060.htm#SECT009">Homomorphisms of Algebras</a>
<li> <A HREF="CHAP060.htm#SECT010">Representations of Algebras</a>
</ol><p>
<p>
An algebra is a vector space equipped with a bilinear map (multiplication).
This chapter describes the functions in <font face="Gill Sans,Helvetica,Arial">GAP</font> that deal with 
general algebras and associative algebras. 
<p>
Algebras in <font face="Gill Sans,Helvetica,Arial">GAP</font> are vector spaces in a natural way. So all the
functionality for vector spaces (see Chapter <a href="../ref/CHAP059.htm">vector spaces</a>) is also 
applicable to algebras.
<p>
<a name = ""></a>
<li><code>InfoAlgebra V</code>
<p>
is the info class for the functions dealing with algebras
(see&nbsp;<a href="CHAP007.htm#SECT004">Info Functions</a>).
<p>
<p>
<h2><a name="SECT001">60.1 Constructing Algebras by Generators</a></h2>
<p><p>
<a name = "SSEC001.1"></a>
<li><code>Algebra( </code><var>F</var><code>, </code><var>gens</var><code> ) F</code>
<li><code>Algebra( </code><var>F</var><code>, </code><var>gens</var><code>, </code><var>zero</var><code> ) F</code>
<li><code>Algebra( </code><var>F</var><code>, </code><var>gens</var><code>, "basis" ) F</code>
<li><code>Algebra( </code><var>F</var><code>, </code><var>gens</var><code>, </code><var>zero</var><code>, "basis" ) F</code>
<p>
<code>Algebra( </code><var>F</var><code>, </code><var>gens</var><code> )</code> is the algebra over the division ring
<var>F</var>, generated by the vectors in the list <var>gens</var>.
<p>
If there are three arguments, a division ring <var>F</var> and a list <var>gens</var>
and an element <var>zero</var>,
then <code>Algebra( </code><var>F</var><code>, </code><var>gens</var><code>, </code><var>zero</var><code> )</code> is the <var>F</var>-algebra
generated by <var>gens</var>, with zero element <var>zero</var>.
<p>
If the last argument is the string <code>"basis"</code> then the vectors in
<var>gens</var> are known to form a basis of the algebra (as an <var>F</var>-vector space).
<p>
<pre>
gap&gt; m:= [ [ 0, 1, 2 ], [ 0, 0, 3], [ 0, 0, 0 ] ];;
gap&gt; A:= Algebra( Rationals, [ m ] );
&lt;algebra over Rationals, with 1 generators&gt;
gap&gt; Dimension( A );
2
</pre>
<p>
<a name = "SSEC001.2"></a>
<li><code>AlgebraWithOne( </code><var>F</var><code>, </code><var>gens</var><code> ) F</code>
<li><code>AlgebraWithOne( </code><var>F</var><code>, </code><var>gens</var><code>, </code><var>zero</var><code> ) F</code>
<li><code>AlgebraWithOne( </code><var>F</var><code>, </code><var>gens</var><code>, "basis" ) F</code>
<li><code>AlgebraWithOne( </code><var>F</var><code>, </code><var>gens</var><code>, </code><var>zero</var><code>, "basis" ) F</code>
<p>
<code>AlgebraWithOne( </code><var>F</var><code>, </code><var>gens</var><code> )</code> is the algebra-with-one over the division
ring <var>F</var>, generated by the vectors in the list <var>gens</var>.
<p>
If there are three arguments, a division ring <var>F</var> and a list <var>gens</var>
and an element <var>zero</var>,
then <code>AlgebraWithOne( </code><var>F</var><code>, </code><var>gens</var><code>, </code><var>zero</var><code> )</code> is the <var>F</var>-algebra-with-one
generated by <var>gens</var>, with zero element <var>zero</var>.
<p>
If the last argument is the string <code>"basis"</code> then the vectors in
<var>gens</var> are known to form a basis of the algebra (as an <var>F</var>-vector space).
<p>
<pre>
gap&gt; m:= [ [ 0, 1, 2 ], [ 0, 0, 3], [ 0, 0, 0 ] ];;
gap&gt; A:= AlgebraWithOne( Rationals, [ m ] );
&lt;algebra-with-one over Rationals, with 1 generators&gt;
gap&gt; Dimension( A );
3
gap&gt; One(A);
[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ]
</pre>
<p>
<p>
<h2><a name="SECT002">60.2 Constructing Algebras as Free Algebras</a></h2>
<p><p>
<a name = "SSEC002.1"></a>
<li><code>FreeAlgebra( </code><var>R</var><code>, </code><var>rank</var><code> ) F</code>
<li><code>FreeAlgebra( </code><var>R</var><code>, </code><var>rank</var><code>, </code><var>name</var><code> ) F</code>
<li><code>FreeAlgebra( </code><var>R</var><code>, </code><var>name1</var><code>, </code><var>name2</var><code>, ... ) F</code>
<p>
is a free (nonassociative) algebra of rank <var>rank</var> over the ring <var>R</var>.
Here <var>name</var>, and <var>name1</var>, <var>name2</var>,... are optional strings that can be used
to provide names for the generators.
<p>
<pre>
gap&gt; A:= FreeAlgebra( Rationals, "a", "b" );
&lt;algebra over Rationals, with 2 generators&gt;
gap&gt; g:= GeneratorsOfAlgebra( A );
[ (1)*a, (1)*b ]
gap&gt; (g[1]*g[2])*((g[2]*g[1])*g[1]);
(1)*((a*b)*((b*a)*a))
</pre>
<p>
<a name = "SSEC002.2"></a>
<li><code>FreeAlgebraWithOne( </code><var>R</var><code>, </code><var>rank</var><code> ) F</code>
<li><code>FreeAlgebraWithOne( </code><var>R</var><code>, </code><var>rank</var><code>, </code><var>name</var><code> ) F</code>
<li><code>FreeAlgebraWithOne( </code><var>R</var><code>, </code><var>name1</var><code>, </code><var>name2</var><code>, ... ) F</code>
<p>
is a free (nonassociative) algebra-with-one of rank <var>rank</var> over the ring
<var>R</var>.
Here <var>name</var>, and <var>name1</var>, <var>name2</var>,... are optional strings that can be used
to provide names for the generators.
<p>
<pre>
gap&gt; A:= FreeAlgebraWithOne( Rationals, 4, "q" );
&lt;algebra-with-one over Rationals, with 4 generators&gt;
gap&gt; GeneratorsOfAlgebra( A );
[ (1)*&lt;identity ...&gt;, (1)*q.1, (1)*q.2, (1)*q.3, (1)*q.4 ]
gap&gt; One( A );
(1)*&lt;identity ...&gt;
</pre>
<p>
<a name = "SSEC002.3"></a>
<li><code>FreeAssociativeAlgebra( </code><var>R</var><code>, </code><var>rank</var><code> ) F</code>
<li><code>FreeAssociativeAlgebra( </code><var>R</var><code>, </code><var>rank</var><code>, </code><var>name</var><code> ) F</code>
<li><code>FreeAssociativeAlgebra( </code><var>R</var><code>, </code><var>name1</var><code>, </code><var>name2</var><code>, ... ) F</code>
<p>
is a free associative algebra of rank <var>rank</var> over the ring <var>R</var>.
Here <var>name</var>, and <var>name1</var>, <var>name2</var>,... are optional strings that can be used
to provide names for the generators.
<p>
<pre>
gap&gt; A:= FreeAssociativeAlgebra( GF( 5 ), 4, "a" );
&lt;algebra over GF(5), with 4 generators&gt;
</pre>
<p>
<a name = "SSEC002.4"></a>
<li><code>FreeAssociativeAlgebraWithOne( </code><var>R</var><code>, </code><var>rank</var><code> ) F</code>
<li><code>FreeAssociativeAlgebraWithOne( </code><var>R</var><code>, </code><var>rank</var><code>, </code><var>name</var><code> ) F</code>
<li><code>FreeAssociativeAlgebraWithOne( </code><var>R</var><code>, </code><var>name1</var><code>, </code><var>name2</var><code>, ... ) F</code>
<p>
is a free associative algebra-with-one of rank <var>rank</var> over the ring <var>R</var>.
Here <var>name</var>, and <var>name1</var>, <var>name2</var>,... are optional strings that can be used
to provide names for the generators.
<p>
<pre>
gap&gt; A:= FreeAssociativeAlgebraWithOne( Rationals, "a", "b", "c" );
&lt;algebra-with-one over Rationals, with 3 generators&gt;
gap&gt; GeneratorsOfAlgebra( A );
[ (1)*&lt;identity ...&gt;, (1)*a, (1)*b, (1)*c ]
gap&gt; One( A );
(1)*&lt;identity ...&gt;
</pre>
<p>
<p>
<h2><a name="SECT003">60.3 Constructing Algebras by Structure Constants</a></h2>
<p><p>
For an introduction into structure constants and how they are handled
by <font face="Gill Sans,Helvetica,Arial">GAP</font>, we refer to Section <a href="../tut/CHAP006.htm#SECT002">Algebras</a> of the user's tutorial.
<p>
<a name = "SSEC003.1"></a>
<li><code>EmptySCTable( </code><var>dim</var><code>, </code><var>zero</var><code> ) F</code>
<li><code>EmptySCTable( </code><var>dim</var><code>, </code><var>zero</var><code>, "symmetric" ) F</code>
<li><code>EmptySCTable( </code><var>dim</var><code>, </code><var>zero</var><code>, "antisymmetric" ) F</code>
<p>
<code>EmptySCTable</code> returns a structure constants table for an algebra of
dimension <var>dim</var>, describing trivial multiplication.
<var>zero</var> must be the zero of the coefficients domain.
If the multiplication is known to be (anti)commutative then
this can be indicated by the optional third argument.
<p>
For filling up the structure constants table, see <a href="CHAP060.htm#SSEC003.2">SetEntrySCTable</a>.
<p>
<pre>
gap&gt; EmptySCTable( 2, Zero( GF(5) ), "antisymmetric" );
[ [ [ [  ], [  ] ], [ [  ], [  ] ] ], [ [ [  ], [  ] ], [ [  ], [  ] ] ], -1, 
  0*Z(5) ]
</pre>
<p>
<a name = "SSEC003.2"></a>
<li><code>SetEntrySCTable( </code><var>T</var><code>, </code><var>i</var><code>, </code><var>j</var><code>, </code><var>list</var><code> ) F</code>
<p>
sets the entry of the structure constants table <var>T</var> that describes the
product of the <var>i</var>-th basis element with the <var>j</var>-th basis element to the
value given by the list <var>list</var>.
<p>
If <var>T</var> is known to be antisymmetric or symmetric then also the value
<code></code><var>T</var><code>[</code><var>j</var><code>][</code><var>i</var><code>]</code> is set.
<p>
<var>list</var> must be of the form
[ <i>c</i><sub><i>ij</i></sub><sup><i>k</i><sub>1</sub></sup>, <i>k</i><sub>1</sub>, <i>c</i><sub><i>ij</i></sub><sup><i>k</i><sub>2</sub></sup>, <i>k</i><sub>2</sub>, &#8230;].
<p>
The entries at the odd positions of <var>list</var> must be compatible with the
zero element stored in <var>T</var>.
For convenience, these entries may also be rational numbers that are
automatically replaced by the corresponding elements in the appropriate
prime field in finite characteristic if necessary.
<p>
<pre>
gap&gt; T:= EmptySCTable( 2, 0 );;
gap&gt; SetEntrySCTable( T, 1, 1, [ 1/2, 1, 2/3, 2 ] );
gap&gt; T;
[ [ [ [ 1, 2 ], [ 1/2, 2/3 ] ], [ [  ], [  ] ] ], 
  [ [ [  ], [  ] ], [ [  ], [  ] ] ], 0, 0 ]
</pre>
<p>
<a name = "SSEC003.3"></a>
<li><code>GapInputSCTable( </code><var>T</var><code>, </code><var>varname</var><code> ) F</code>
<p>
is a string that describes the structure constants table <var>T</var> in terms of
<code>EmptySCTable</code> and <code>SetEntrySCTable</code>.
The assignments are made to the variable <var>varname</var>.
<p>
<pre>
gap&gt; T:= EmptySCTable( 2, 0 );;
gap&gt; SetEntrySCTable( T, 1, 2, [ 1, 2 ] );
gap&gt; SetEntrySCTable( T, 2, 1, [ 1, 2 ] );
gap&gt; GapInputSCTable( T, "T" );
"T:= EmptySCTable( 2, 0 );\nSetEntrySCTable( T, 1, 2, [1,2] );\nSetEntrySCTabl\
e( T, 2, 1, [1,2] );\n"
</pre>
<p>
<a name = "SSEC003.4"></a>
<li><code>TestJacobi( </code><var>T</var><code> ) F</code>
<p>
tests whether the structure constants table <var>T</var> satisfies the Jacobi
identity
<i>v</i><sub><i>i</i></sub>*(<i>v</i><sub><i>j</i></sub>*<i>v</i><sub><i>k</i></sub>)+<i>v</i><sub><i>j</i></sub>*(<i>v</i><sub><i>k</i></sub>*<i>v</i><sub><i>i</i></sub>)+<i>v</i><sub><i>k</i></sub>*(<i>v</i><sub><i>i</i></sub>*<i>v</i><sub><i>j</i></sub>)=0
for all basis vectors <i>v</i><sub><i>i</i></sub> of the underlying algebra,
where <i>i</i>  &#8804; <i>j</i>  &#8804; <i>k</i>.
(Thus antisymmetry is assumed.)
<p>
The function returns <code>true</code> if the Jacobi identity is satisfied,
and a failing triple <code>[ i, j, k ]</code> otherwise.
<p>
<pre>
gap&gt; T:= EmptySCTable( 2, 0, "antisymmetric" );;
gap&gt; SetEntrySCTable( T, 1, 2, [ 1, 2 ] );;
gap&gt; TestJacobi( T );
true
</pre>
<p>
<a name = "SSEC003.5"></a>
<li><code>AlgebraByStructureConstants( </code><var>R</var><code>, </code><var>sctable</var><code> ) F</code>
<li><code>AlgebraByStructureConstants( </code><var>R</var><code>, </code><var>sctable</var><code>, </code><var>name</var><code> ) F</code>
<li><code>AlgebraByStructureConstants( </code><var>R</var><code>, </code><var>sctable</var><code>, </code><var>names</var><code> ) F</code>
<li><code>AlgebraByStructureConstants( </code><var>R</var><code>, </code><var>sctable</var><code>, </code><var>name1</var><code>, </code><var>name2</var><code>, ... ) F</code>
<p>
returns a free left module <i>A</i> over the ring <var>R</var>,
with multiplication defined by the structure constants table <var>sctable</var>.
Here <var>name</var> and <var>name1</var>, <var>name2</var>, <code>...</code> are optional strings
that can be used to provide names for the elements of the canonical basis
of <i>A</i>.
<var>names</var> is a list of strings that can be entered instead of the specific
names <var>name1</var>, <var>name2</var>, <code>...</code>.
The vectors of the canonical basis of <i>A</i> correspond to the vectors of
the basis given by <var>sctable</var>.
<p>
It is <strong>not</strong> checked whether the coefficients in <var>sctable</var> are really
elements in <var>R</var>.
<p>
<pre>
gap&gt; T:= EmptySCTable( 2, 0 );;
gap&gt; SetEntrySCTable( T, 1, 1, [ 1/2, 1, 2/3, 2 ] );
gap&gt; A:= AlgebraByStructureConstants( Rationals, T );
&lt;algebra of dimension 2 over Rationals&gt;
gap&gt; b:= BasisVectors( Basis( A ) );;
gap&gt; b[1]^2;
(1/2)*v.1+(2/3)*v.2
gap&gt; b[1]*b[2];
0*v.1
</pre>
<p>
<a name = "SSEC003.6"></a>
<li><code>IdentityFromSCTable( </code><var>T</var><code> ) F</code>
<p>
Let <var>T</var> be a structure constants table of an algebra <i>A</i> of dimension <i>n</i>.
<code>IdentityFromSCTable( </code><var>T</var><code> )</code> is either <code>fail</code> or the vector of length
<i>n</i> that contains the coefficients of the multiplicative identity of <i>A</i>
with respect to the basis that belongs to <var>T</var>.
<p>
<pre>
gap&gt; T:= EmptySCTable( 2, 0 );;
gap&gt; SetEntrySCTable( T, 1, 1, [ 1, 1 ] );;
gap&gt; SetEntrySCTable( T, 1, 2, [ 1, 2 ] );;
gap&gt; SetEntrySCTable( T, 2, 1, [ 1, 2 ] );;
gap&gt; IdentityFromSCTable( T );
[ 1, 0 ]
</pre>
<p>
<a name = "SSEC003.7"></a>
<li><code>QuotientFromSCTable( </code><var>T</var><code>, </code><var>num</var><code>, </code><var>den</var><code> ) F</code>
<p>
Let <var>T</var> be a structure constants table of an algebra <i>A</i> of dimension <i>n</i>.
<code>QuotientFromSCTable( </code><var>T</var><code> )</code> is either <code>fail</code> or the vector of length
<i>n</i> that contains the coefficients of the quotient of <var>num</var> and <var>den</var>
with respect to the basis that belongs to <var>T</var>.
<p>
We solve the equation system <i>num</i>  = <i>x</i> <i>den</i> .
If no solution exists, <code>fail</code> is returned.
<p>
In terms of the basis <i>B</i> with vectors <i>b</i><sub>1</sub>, &#8230;, <i>b</i><sub><i>n</i></sub> this means
for <i>num</i>  = &#8721;<sub><i>i</i>=1</sub><sup><i>n</i></sup> <i>a</i><sub><i>i</i></sub> <i>b</i><sub><i>i</i></sub>,
    <i>den</i>  = &#8721;<sub><i>i</i>=1</sub><sup><i>n</i></sup> <i>c</i><sub><i>i</i></sub> <i>b</i><sub><i>i</i></sub>,
    <i>x</i> = &#8721;<sub><i>i</i>=1</sub><sup><i>n</i></sup> <i>x</i><sub><i>i</i></sub> <i>b</i><sub><i>i</i></sub> that
<i>a</i><sub><i>k</i></sub> = &#8721;<sub><i>i</i>,<i>j</i></sub> <i>c</i><sub><i>i</i></sub> <i>x</i><sub><i>j</i></sub> <i>c</i><sub><i>ijk</i></sub> for all <i>k</i>.
Here <i>c</i><sub><i>ijk</i></sub> denotes the structure constants with respect to <i>B</i>.
This means that (as a vector) <i>a</i>=<i>xM</i> with
<i>M</i><sub><i>jk</i></sub> = &#8721;<sub><i>i</i>=1</sub><sup><i>n</i></sup> <i>c</i><sub><i>ijk</i></sub> <i>c</i><sub><i>i</i></sub>.
<p>
<pre>
gap&gt; T:= EmptySCTable( 2, 0 );;
gap&gt; SetEntrySCTable( T, 1, 1, [ 1, 1 ] );;
gap&gt; SetEntrySCTable( T, 2, 1, [ 1, 2 ] );;
gap&gt; SetEntrySCTable( T, 1, 2, [ 1, 2 ] );;
gap&gt; QuotientFromSCTable( T, [0,1], [1,0] );
[ 0, 1 ]
</pre>
<p>
<p>
<h2><a name="SECT004">60.4 Some Special Algebras</a></h2>
<p><p>
<a name = "SSEC004.1"></a>
<li><code>QuaternionAlgebra( </code><var>F</var><code> ) F</code>
<li><code>QuaternionAlgebra( </code><var>F</var><code>, </code><var>a</var><code>, </code><var>b</var><code> ) F</code>
<p>
is a quaternion algebra over the field <var>F</var> with parameters <var>a</var> and <var>b</var> in
<var>F</var>, i.e., a four-dimensional associative <var>F</var>-algebra with basis
(<i>e</i>,<i>i</i>,<i>j</i>,<i>k</i>) and multiplication defined by
<i>e</i> <i>e</i> = <i>e</i>, <i>e</i> <i>i</i> = <i>i</i> <i>e</i> = <i>i</i>, <i>e</i> <i>j</i> = <i>j</i> <i>e</i> = <i>j</i>, <i>e</i> <i>k</i> = <i>k</i> <i>e</i> = <i>k</i>,
<i>i</i> <i>i</i> = <i>a</i>  <i>e</i>, <i>i</i> <i>j</i> = &#8722; <i>j</i> <i>i</i> = <i>k</i>, <i>i</i> <i>k</i> = &#8722; <i>k</i> <i>i</i> = <i>a</i>  <i>j</i>,
<i>j</i> <i>j</i> = <i>b</i>  <i>e</i>, <i>j</i> <i>k</i> = &#8722; <i>k</i> <i>j</i> = <i>b</i>  <i>i</i>,
<i>k</i> <i>k</i> = &#8722; <i>a</i>  <i>b</i>  <i>e</i>.
The default value for both <var>a</var> and <var>b</var> is &#8722;1  &#8712; <i>F</i> .
<p>
The <code>GeneratorsOfAlgebra</code> (see&nbsp;<a href="CHAP060.htm#SSEC008.1">GeneratorsOfAlgebra</a>) and
<code>CanonicalBasis</code> (see&nbsp;<a href="CHAP059.htm#SSEC004.3">CanonicalBasis</a>) value of an algebra constructed
with <code>QuaternionAlgebra</code> is the list [ <i>e</i>, <i>i</i>, <i>j</i>, <i>k</i> ].
<p>
The embedding of the field <code>GaussianRationals</code> into a quaternion algebra
<i>A</i> over <code>Rationals</code> is not uniquely determined.
One can specify one as a vector space homomorphism that maps <code>1</code> to the
first algebra generator of <i>A</i>, and <code>E(4)</code> to one of the others.
<p>
<pre>
gap&gt; QuaternionAlgebra( Rationals );
&lt;algebra-with-one of dimension 4 over Rationals&gt;
</pre>
<p>
<a name = "SSEC004.2"></a>
<li><code>ComplexificationQuat( </code><var>vector</var><code> ) F</code>
<li><code>ComplexificationQuat( </code><var>matrix</var><code> ) F</code>
<p>
Let <i>A</i> = <i>e</i> <i>F</i> &#8853;<i>i</i> <i>F</i> &#8853;<i>j</i> <i>F</i> &#8853;<i>k</i> <i>F</i> be a quaternion algebra
over the field <i>F</i> of cyclotomics, with basis (<i>e</i>,<i>i</i>,<i>j</i>,<i>k</i>).
<p>
If <i>v</i> = <i>v</i><sub>1</sub> + <i>v</i><sub>2</sub> <i>j</i> is a row vector over <i>A</i> with <i>v</i><sub>1</sub> = <i>e</i> <i>w</i><sub>1</sub> + <i>i</i> <i>w</i><sub>2</sub>
and <i>v</i><sub>2</sub> = <i>e</i> <i>w</i><sub>3</sub> + <i>i</i> <i>w</i><sub>4</sub> then <code>ComplexificationQuat( <i>v</i> )</code> is the
concatenation of <i>w</i><sub>1</sub> + <tt>E</tt><tt>(</tt><tt>4</tt><tt>)</tt> <i>w</i><sub>2</sub> and <i>w</i><sub>3</sub> + <tt>E</tt><tt>(</tt><tt>4</tt><tt>)</tt> <i>w</i><sub>4</sub>.
<p>
If <i>M</i> = <i>M</i><sub>1</sub> + <i>M</i><sub>2</sub> <i>j</i> is a matrix over <i>A</i> with <i>M</i><sub>1</sub> = <i>e</i> <i>N</i><sub>1</sub> + <i>i</i> <i>N</i><sub>2</sub>
and <i>M</i><sub>2</sub> = <i>e</i> <i>N</i><sub>3</sub> + <i>i</i> <i>N</i><sub>4</sub> then <code>ComplexificationQuat( </code><var>M</var><code> )</code> is the
block matrix <i>A</i> over <i>e</i> <i>F</i> &#8853;<i>i</i> <i>F</i> such that <i>A</i>(1,1)=<i>N</i><sub>1</sub> + <tt>E</tt><tt>(</tt><tt>4</tt><tt>)</tt> <i>N</i><sub>2</sub>,
<i>A</i>(2,2)=<i>N</i><sub>1</sub> &#8722; <tt>E</tt><tt>(</tt><tt>4</tt><tt>)</tt> <i>N</i><sub>2</sub>, <i>A</i>(1,2)=<i>N</i><sub>3</sub> + <tt>E</tt><tt>(</tt><tt>4</tt><tt>)</tt> <i>N</i><sub>4</sub> and <i>A</i>(2,1) = &#8722; <i>N</i><sub>3</sub> + <tt>E</tt><tt>(</tt><tt>4</tt><tt>)</tt> <i>N</i><sub>4</sub>.
<p>
Then <code>ComplexificationQuat(</code><var>v</var><code>)*ComplexificationQuat(</code><var>M</var><code>)=
      ComplexificationQuat(</code><var>v</var><code>*</code><var>M</var><code>)</code>, since
<br clear="all" /><table border="0" width="100%"><tr><td><table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center"> <i>v</i> <i>M</i> = <i>v</i><sub>1</sub> <i>M</i><sub>1</sub> + <i>v</i><sub>2</sub> <i>j</i> <i>M</i><sub>1</sub> + <i>v</i><sub>1</sub> <i>M</i><sub>2</sub> <i>j</i> + <i>v</i><sub>2</sub> <i>j</i> <i>M</i><sub>2</sub> <i>j</i> = ( <i>v</i><sub>1</sub> <i>M</i><sub>1</sub> &#8722; <i>v</i><sub>2</sub></td><td nowrap="nowrap" align="center"><div class="hrcomp"><hr noshade="noshade" size="1"/></div><div class="norm"><i>M</i><sub>2</sub><br /></div><div class="comb">&nbsp;</div></td><td nowrap="nowrap" align="center">) + ( <i>v</i><sub>1</sub> <i>M</i><sub>2</sub> + <i>v</i><sub>2</sub></td><td nowrap="nowrap" align="center"><div class="hrcomp"><hr noshade="noshade" size="1"/></div><div class="norm"><i>M</i><sub>1</sub><br /></div><div class="comb">&nbsp;</div></td><td nowrap="nowrap" align="center">) <i>j</i>. </td></tr></table></td></tr></table>
<p>
<a name = "SSEC004.3"></a>
<li><code>OctaveAlgebra( </code><var>F</var><code> ) F</code>
<p>
The algebra of octonions over <var>F</var>.
<p>
<pre>
gap&gt; OctaveAlgebra( Rationals );
&lt;algebra of dimension 8 over Rationals&gt;
</pre>
<p>
<a name = "SSEC004.4"></a>
<li><code>FullMatrixAlgebra( </code><var>R</var><code>, </code><var>n</var><code> ) F</code>
<a name = "SSEC004.4"></a>
<li><code>MatrixAlgebra( </code><var>R</var><code>, </code><var>n</var><code> ) F</code>
<a name = "SSEC004.4"></a>
<li><code>MatAlgebra( </code><var>R</var><code>, </code><var>n</var><code> ) F</code>
<p>
is the full matrix algebra <i>R</i> <sup><i>n</i> &times;<i>n</i> </sup>, for a ring <var>R</var> and a 
nonnegative integer <var>n</var>.
<p>
<pre>
gap&gt; A:=FullMatrixAlgebra( Rationals, 20 );
( Rationals^[ 20, 20 ] )
gap&gt; Dimension( A );
400
</pre>
<p>
<a name = "SSEC004.5"></a>
<li><code>NullAlgebra( </code><var>R</var><code> ) A</code>
<p>
The zero-dimensional algebra over <var>R</var>.
<p>
<pre>
gap&gt; A:= NullAlgebra( Rationals );
&lt;algebra over Rationals&gt;
gap&gt; Dimension( A );
0
</pre>
<p>
<p>
<h2><a name="SECT005">60.5 Subalgebras</a></h2>
<p><p>
<a name = "SSEC005.1"></a>
<li><code>Subalgebra( </code><var>A</var><code>, </code><var>gens</var><code> ) F</code>
<li><code>Subalgebra( </code><var>A</var><code>, </code><var>gens</var><code>, "basis" ) F</code>
<p>
is the <i>F</i>-algebra generated by <var>gens</var>, with parent algebra <var>A</var>, where
<i>F</i> is the left acting domain of <var>A</var>.
<p>
<strong>Note</strong> that being a subalgebra of <var>A</var> means to be an algebra, to be
contained in <var>A</var>, <strong>and</strong> to have the same left acting domain as <var>A</var>.
<p>
An optional argument <code>"basis"</code> may be added if it is known that
the generators already form a basis of the algebra.
Then it is <strong>not</strong> checked whether <var>gens</var> really are linearly independent
and whether all elements in <var>gens</var> lie in <var>A</var>.
<p>
<pre>
gap&gt; m:= [ [ 0, 1, 2 ], [ 0, 0, 3], [ 0, 0, 0 ] ];;
gap&gt; A:= Algebra( Rationals, [ m ] );
&lt;algebra over Rationals, with 1 generators&gt;
gap&gt; B:= Subalgebra( A, [ m^2 ] );
&lt;algebra over Rationals, with 1 generators&gt;
</pre>
<p>
<a name = "SSEC005.2"></a>
<li><code>SubalgebraNC( </code><var>A</var><code>, </code><var>gens</var><code> ) F</code>
<li><code>SubalgebraNC( </code><var>A</var><code>, </code><var>gens</var><code>, "basis" ) F</code>
<p>
<code>SubalgebraNC</code> constructs the subalgebra generated by <var>gens</var>, only it 
does not check whether all elements in <var>gens</var> lie in <var>A</var>.
<p>
<pre>
gap&gt; m:= RandomMat( 3, 3 );;
gap&gt; A:= Algebra( Rationals, [ m ] );
&lt;algebra over Rationals, with 1 generators&gt;
gap&gt; SubalgebraNC( A, [ IdentityMat( 3, 3 ) ], "basis" );
&lt;algebra of dimension 1 over Rationals&gt;
</pre>
<p>
<a name = "SSEC005.3"></a>
<li><code>SubalgebraWithOne( </code><var>A</var><code>, </code><var>gens</var><code> ) F</code>
<li><code>SubalgebraWithOne( </code><var>A</var><code>, </code><var>gens</var><code>, "basis" ) F</code>
<p>
is the algebra-with-one generated by <var>gens</var>, with parent algebra <var>A</var>.
<p>
The optional third argument <code>"basis"</code> may be added if it is
known that the elements from <var>gens</var> are linearly independent.
Then it is <strong>not</strong> checked whether <var>gens</var> really are linearly independent
and whether all elements in <var>gens</var> lie in <var>A</var>.
<p>
<pre>
gap&gt; m:= [ [ 0, 1, 2 ], [ 0, 0, 3], [ 0, 0, 0 ] ];;
gap&gt; A:= AlgebraWithOne( Rationals, [ m ] );
&lt;algebra-with-one over Rationals, with 1 generators&gt;
gap&gt; B1:= SubalgebraWithOne( A, [ m ] );;
gap&gt; B2:= Subalgebra( A, [ m ] );;
gap&gt; Dimension( B1 );
3
gap&gt; Dimension( B2 );
2
</pre>
<p>
<a name = "SSEC005.4"></a>
<li><code>SubalgebraWithOneNC( </code><var>A</var><code>, </code><var>gens</var><code> ) F</code>
<li><code>SubalgebraWithOneNC( </code><var>A</var><code>, </code><var>gens</var><code>, "basis" ) F</code>
<p>
<code>SubalgebraWithOneNC</code> does not check whether all elements in <var>gens</var> lie
in <var>A</var>.
<p>
<pre>
gap&gt; m:= RandomMat( 3, 3 );; A:= Algebra( Rationals, [ m ] );;
gap&gt; SubalgebraWithOneNC( A, [ m ] );
&lt;algebra-with-one over Rationals, with 1 generators&gt;
</pre>
<p>
<a name = "SSEC005.5"></a>
<li><code>TrivialSubalgebra( </code><var>A</var><code> ) A</code>
<p>
The zero dimensional subalgebra of the algebra <var>A</var>.
<p>
<pre>
gap&gt; A:= QuaternionAlgebra( Rationals );;
gap&gt; B:= TrivialSubalgebra( A );
&lt;algebra over Rationals&gt;
gap&gt; Dimension( B );
0
</pre>
<p>
<p>
<h2><a name="SECT006">60.6 Ideals</a></h2>
<p><p>
For constructing and working with ideals in algebras the same functions
are available as for ideals in rings. So for the precise description of
these functions we refer to Chapter <a href="CHAP054.htm">Rings</a>. Here we give examples
demonstrating the use of ideals in algebras. For an introduction into
the concstruction of quotient algebras we refer to Chapter <a href="../tut/CHAP006.htm#SECT002">algebras</a>
of the user's tutorial.
<p>
<pre>
gap&gt; m:= [ [ 0, 2, 3 ], [ 0, 0, 4 ], [ 0, 0, 0] ];;
gap&gt; A:= AlgebraWithOne( Rationals, [ m ] );;
gap&gt; I:= Ideal( A, [ m ] );  # i.e., the two-sided ideal of `A' generated by `m'.
&lt;two-sided ideal in &lt;algebra-with-one of dimension 3 over Rationals&gt;, 
  (1 generators)&gt;
gap&gt; Dimension( I );
2
gap&gt; GeneratorsOfIdeal( I );
[ [ [ 0, 2, 3 ], [ 0, 0, 4 ], [ 0, 0, 0 ] ] ]
gap&gt; BasisVectors( Basis( I ) );
[ [ [ 0, 1, 3/2 ], [ 0, 0, 2 ], [ 0, 0, 0 ] ], 
  [ [ 0, 0, 1 ], [ 0, 0, 0 ], [ 0, 0, 0 ] ] ]
</pre>
<p>
<pre>
gap&gt; A:= FullMatrixAlgebra( Rationals, 4 );;
gap&gt; m:= NullMat( 4, 4 );; m[1][4]:=1;;
gap&gt; I:= LeftIdeal( A, [ m ] );
&lt;left ideal in ( Rationals^[ 4, 4 ] ), (1 generators)&gt;
gap&gt; Dimension( I );
4
gap&gt; GeneratorsOfLeftIdeal( I );
[ [ [ 0, 0, 0, 1 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ] ] ]
</pre>
<p>
<pre>
gap&gt; mats:= [ [[1,0],[0,0]], [[0,1],[0,0]], [[0,0],[0,1]] ];;
gap&gt; A:= Algebra( Rationals, mats );;
gap&gt; # Form the two-sided ideal for which `mats[2]' is known to be
gap&gt; # the unique basis element.
gap&gt; I:= Ideal( A, [ mats[2] ], "basis" );
&lt;two-sided ideal in &lt;algebra of dimension 3 over Rationals&gt;, (dimension 1)&gt;
</pre>
<p>
<p>
<h2><a name="SECT007">60.7 Categories and Properties of Algebras</a></h2>
<p><p>
<a name = "SSEC007.1"></a>
<li><code>IsFLMLOR( </code><var>obj</var><code> ) C</code>
<p>
A FLMLOR (``free left module left operator ring'') in <font face="Gill Sans,Helvetica,Arial">GAP</font> is a ring
that is also a free left module.
<p>
Note that this means that being a FLMLOR is not a property a
ring can get,
since a ring is usually not represented as an external left set.
<p>
Examples are magma rings (e.g. over the integers) or algebras.
<p>
<pre>
gap&gt; A:= FullMatrixAlgebra( Rationals, 2 );;
gap&gt; IsFLMLOR ( A );
true
</pre>
<p>
<a name = "SSEC007.2"></a>
<li><code>IsFLMLORWithOne( </code><var>obj</var><code> ) C</code>
<p>
A FLMLOR-with-one in <font face="Gill Sans,Helvetica,Arial">GAP</font> is a ring-with-one that is also a free left
module.
<p>
Note that this means that being a FLMLOR-with-one is not a property a
ring-with-one can get,
since a ring-with-one is usually not represented as an external left set.
<p>
Examples are magma rings-with-one or algebras-with-one (but also over the
integers).
<p>
<pre>
gap&gt; A:= FullMatrixAlgebra( Rationals, 2 );;
gap&gt; IsFLMLORWithOne ( A );
true
</pre>
<p>
<a name = "SSEC007.3"></a>
<li><code>IsAlgebra( </code><var>obj</var><code> ) C</code>
<p>
An algebra in <font face="Gill Sans,Helvetica,Arial">GAP</font> is a ring that is also a left vector space.
Note that this means that being an algebra is not a property a ring can
get, since a ring is usually not represented as an external left set.
<p>
<pre>
gap&gt; A:= MatAlgebra( Rationals, 3 );;
gap&gt; IsAlgebra( A );
true
</pre>
<p>
<a name = "SSEC007.4"></a>
<li><code>IsAlgebraWithOne( </code><var>obj</var><code> ) C</code>
<p>
An algebra-with-one in <font face="Gill Sans,Helvetica,Arial">GAP</font> is a ring-with-one that is also
a left vector space.
Note that this means that being an algebra-with-one is not a property a
ring-with-one can get,
since a ring-with-one is usually not represented as an external left set.
<p>
<pre>
gap&gt; A:= MatAlgebra( Rationals, 3 );;
gap&gt; IsAlgebraWithOne( A );
true
</pre>
<p>
<a name = "SSEC007.5"></a>
<li><code>IsLieAlgebra( </code><var>A</var><code> ) P</code>
<p>
An algebra <var>A</var> is called Lie algebra if <i>a</i> * <i>a</i> = 0 for all <i>a</i> in <var>A</var>
and ( <i>a</i> * ( <i>b</i> * <i>c</i> ) ) + ( <i>b</i> * ( <i>c</i> * <i>a</i> ) ) + ( <i>c</i> * ( <i>a</i> * <i>b</i> ) ) = 0
for all <i>a</i>, <i>b</i>, <i>c</i> in <var>A</var> (Jacobi identity).
<p>
<pre>
gap&gt; A:= FullMatrixLieAlgebra( Rationals, 3 );;
gap&gt; IsLieAlgebra( A );
true
</pre>
<p>
<a name = "SSEC007.6"></a>
<li><code>IsSimpleAlgebra( </code><var>A</var><code> ) P</code>
<p>
is <code>true</code> if the algebra <var>A</var> is simple, and <code>false</code> otherwise. This 
function is only implemented for the cases where <var>A</var> is an associative or
a Lie algebra. And for Lie algebras it is only implemented fot the
case where the ground field is of characteristic 0.
<p>
<pre>
gap&gt; A:= FullMatrixLieAlgebra( Rationals, 3 );;
gap&gt; IsSimpleAlgebra( A );
false
gap&gt; A:= MatAlgebra( Rationals, 3 );;
gap&gt; IsSimpleAlgebra( A );
true
</pre>
<p>
<a name = "SSEC007.7"></a>
<li><code>IsFiniteDimensional(</code><var>matalg</var><code>) O</code>
<p>
returns <code>true</code> (always) for a matrix algebra <var>matalg</var>, since
matrix algebras are always finite dimensional.
<p>
<pre>
gap&gt; A:= MatAlgebra( Rationals, 3 );;
gap&gt; IsFiniteDimensional( A );
true
</pre>
<p>
<a name = "SSEC007.8"></a>
<li><code>IsQuaternion( </code><var>obj</var><code> ) C</code>
<a name = "SSEC007.8"></a>
<li><code>IsQuaternionCollection( </code><var>obj</var><code> ) C</code>
<a name = "SSEC007.8"></a>
<li><code>IsQuaternionCollColl( </code><var>obj</var><code> ) C</code>
<p>
<code>IsQuaternion</code> is the category of elements in an algebra constructed by 
<code>QuaternionAlgebra</code>. A collection of quaternions lies in the category
<code>IsQuaternionCollection</code>. Finally, a collection of quaternion collections
(e.g., a matrix of quaternions) lies in the category
<code>IsQuaternionCollColl</code>.
<p>
<pre>
gap&gt; A:= QuaternionAlgebra( Rationals );;
gap&gt; b:= BasisVectors( Basis( A ) );
[ e, i, j, k ]
gap&gt; IsQuaternion( b[1] );
true
gap&gt; IsQuaternionCollColl( [ [ b[1], b[2] ], [ b[3], b[4] ] ] );
true
</pre>
<p>
<p>
<h2><a name="SECT008">60.8 Attributes and Operations for Algebras</a></h2>
<p><p>
<a name = "SSEC008.1"></a>
<li><code>GeneratorsOfAlgebra( </code><var>A</var><code> ) A</code>
<p>
returns a list of elements that generate <var>A</var> as an algebra.
<p>
<pre>
gap&gt; m:= [ [ 0, 1, 2 ], [ 0, 0, 3 ], [ 0, 0, 0 ] ];;
gap&gt; A:= AlgebraWithOne( Rationals, [ m ] );
&lt;algebra-with-one over Rationals, with 1 generators&gt;
gap&gt; GeneratorsOfAlgebra( A );
[ [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ], 
  [ [ 0, 1, 2 ], [ 0, 0, 3 ], [ 0, 0, 0 ] ] ]
</pre>
<p>
<a name = "SSEC008.2"></a>
<li><code>GeneratorsOfAlgebraWithOne( </code><var>A</var><code> ) A</code>
<p>
returns a list of elements of <var>A</var> that generate <var>A</var> as an algebra with
one. 
<p>
<pre>
gap&gt; m:= [ [ 0, 1, 2 ], [ 0, 0, 3 ], [ 0, 0, 0 ] ];;
gap&gt; A:= AlgebraWithOne( Rationals, [ m ] );
&lt;algebra-with-one over Rationals, with 1 generators&gt;
gap&gt; GeneratorsOfAlgebraWithOne( A );
[ [ [ 0, 1, 2 ], [ 0, 0, 3 ], [ 0, 0, 0 ] ] ]
</pre>
<p>
<a name = "SSEC008.3"></a>
<li><code>ProductSpace( </code><var>U</var><code>, </code><var>V</var><code> ) O</code>
<p>
is the vector space &#9001;<i>u</i> * <i>v</i> ; <i>u</i>  &#8712; <i>U</i>, <i>v</i>  &#8712; <i>V</i> &#9002;,
where <i>U</i> and <i>V</i> are subspaces of the same algebra.
<p>
If <i>U</i>  = <i>V</i>  is known to be an algebra then the product space is also
an algebra, moreover it is an ideal in <var>U</var>.
If <var>U</var> and <var>V</var> are known to be ideals in an algebra <i>A</i>
then the product space is known to be an algebra and an ideal in <i>A</i>.
<p>
<pre>
gap&gt; A:= QuaternionAlgebra( Rationals );;
gap&gt; b:= BasisVectors( Basis( A ) );;
gap&gt; B:= Subalgebra( A, [ b[4] ] );
&lt;algebra over Rationals, with 1 generators&gt;
gap&gt; ProductSpace( A, B );
&lt;vector space of dimension 4 over Rationals&gt;
</pre>
<p>
<a name = "SSEC008.4"></a>
<li><code>PowerSubalgebraSeries( </code><var>A</var><code> ) A</code>
<p>
returns a list of subalgebras of <var>A</var>, the first term of which is <var>A</var>;
and every next term is the product space of the previous term with itself.
<p>
<pre>
gap&gt; A:= QuaternionAlgebra( Rationals );
&lt;algebra-with-one of dimension 4 over Rationals&gt;
gap&gt; PowerSubalgebraSeries( A );
[ &lt;algebra-with-one of dimension 4 over Rationals&gt; ]
</pre>
<p>
<a name = "SSEC008.5"></a>
<li><code>AdjointBasis( </code><var>B</var><code> ) A</code>
<p>
Let <i>x</i> be an element of an algebra <i>A</i>. Then the adjoint map
of <i>x</i> is the left multiplication by <i>x</i>. It is a linear map of <i>A</i>.
For the basis <var>B</var> of an algebra <i>A</i>, this function returns a
particular basis <i>C</i> of the matrix space generated by <i>ad</i> <i>A</i>,
(the matrix spaces spanned by the matrices of the left multiplication);
namely a basis consisting of elements of the form <i>ad</i> <i>x</i><sub><i>i</i></sub>,
where <i>x</i><sub><i>i</i></sub> is a basis element of <var>B</var>.
<p>
<pre>
gap&gt; A:= QuaternionAlgebra( Rationals );;
gap&gt; AdjointBasis( Basis( A ) );
Basis( &lt;vector space over Rationals, with 4 generators&gt;, 
[ [ [ 1, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 0, 0, 1 ] ], 
  [ [ 0, -1, 0, 0 ], [ 1, 0, 0, 0 ], [ 0, 0, 0, -1 ], [ 0, 0, 1, 0 ] ], 
  [ [ 0, 0, -1, 0 ], [ 0, 0, 0, 1 ], [ 1, 0, 0, 0 ], [ 0, -1, 0, 0 ] ], 
  [ [ 0, 0, 0, -1 ], [ 0, 0, -1, 0 ], [ 0, 1, 0, 0 ], [ 1, 0, 0, 0 ] ] ] )
</pre>
<p>
<a name = "SSEC008.6"></a>
<li><code>IndicesOfAdjointBasis( </code><var>B</var><code> ) A</code>
<p>
 Let <var>A</var> be an algebra and let <var>B</var>
 be the basis that is output by <code>AdjointBasis( Basis( </code><var>A</var><code> ) )</code>. 
 This function 
 returns a list of indices. If <i>i</i> is an index belonging to this
 list, then <i>ad</i> <i>x</i><sub><i>i</i></sub> is a basis vector of the matrix space spanned
 by <i>ad</i> <i>A</i>, where <i>x</i><sub><i>i</i></sub> is the <i>i</i>-th basis vector of the basis <var>B</var>.
<p>
<pre>
gap&gt; L:= FullMatrixLieAlgebra( Rationals, 3 );;
gap&gt; B:= AdjointBasis( Basis( L ) );;
gap&gt; IndicesOfAdjointBasis( B );
[ 1, 2, 3, 4, 5, 6, 7, 8 ]
</pre>
<p>
<a name = "SSEC008.7"></a>
<li><code>AsAlgebra( </code><var>F</var><code>, </code><var>A</var><code> ) O</code>
<p>
Returns the algebra over <var>F</var> generated by <var>A</var>.
<p>
<pre>
gap&gt; V:= VectorSpace( Rationals, [ IdentityMat( 2 ) ] );;
gap&gt; AsAlgebra( Rationals, V );
&lt;algebra of dimension 1 over Rationals&gt;
</pre>
<p>
<a name = "SSEC008.8"></a>
<li><code>AsAlgebraWithOne( </code><var>F</var><code>, </code><var>A</var><code> ) O</code>
<p>
If the algebra <var>A</var> has an identity, then it can be viewed as an
algebra with one over <var>F</var>. This function returns this algebra with one.
<p>
<pre>
gap&gt; V:= VectorSpace( Rationals, [ IdentityMat( 2 ) ] );;
gap&gt; A:= AsAlgebra( Rationals, V );;
gap&gt; AsAlgebraWithOne( Rationals, A );
&lt;algebra-with-one over Rationals, with 1 generators&gt;
</pre>
<p>
<a name = "SSEC008.9"></a>
<li><code>AsSubalgebra( </code><var>A</var><code>, </code><var>B</var><code> ) O</code>
<p>
If all elements of the algebra <var>B</var> happen to be contained in the
algebra <var>A</var>, then <var>B</var> can be viewed as a subalgebra of <var>A</var>. This 
function returns this subalgebra.
<p>
<pre>
gap&gt; A:= FullMatrixAlgebra( Rationals, 2 );;
gap&gt; V:= VectorSpace( Rationals, [ IdentityMat( 2 ) ] );;
gap&gt; B:= AsAlgebra( Rationals, V );;
gap&gt; BA:= AsSubalgebra( A, B );
&lt;algebra of dimension 1 over Rationals&gt;
</pre>
<p>
<a name = "SSEC008.10"></a>
<li><code>AsSubalgebraWithOne( </code><var>A</var><code>, </code><var>B</var><code> ) O</code>
<p>
If <var>B</var> is an algebra with one, all elements of which happen to be
contained in the algebra with one <var>A</var>, then <var>B</var> can be viewed as a
subalgebra with one of <var>A</var>. This function returns this subalgebra
with one.
<p>
<pre>
gap&gt; A:= FullMatrixAlgebra( Rationals, 2 );;
gap&gt; V:= VectorSpace( Rationals, [ IdentityMat( 2 ) ] );;
gap&gt; B:= AsAlgebra( Rationals, V );;
gap&gt; C:= AsAlgebraWithOne( Rationals, B );;
gap&gt; AC:= AsSubalgebraWithOne( A, C );
&lt;algebra-with-one over Rationals, with 1 generators&gt;
</pre>
<p>
<a name = "SSEC008.11"></a>
<li><code>MutableBasisOfClosureUnderAction( </code><var>F</var><code>, </code><var>Agens</var><code>, </code><var>from</var><code>, </code><var>init</var><code>, </code><var>opr</var><code>, </code><var>zero</var><code>, </code><var>maxdim</var><code> ) F</code>
<p>
Let <var>F</var> be a ring, <var>Agens</var> a list of generators for an <var>F</var>-algebra <i>A</i>,
and <var>from</var> one of <code>"left"</code>, <code>"right"</code>, <code>"both"</code>; (this means that elements
of <i>A</i> act via multiplication from the respective side(s).)
<var>init</var> must be a list of initial generating vectors,
and <var>opr</var> the operation (a function of two arguments).
<p>
<code>MutableBasisOfClosureUnderAction</code> returns a mutable basis of the
<var>F</var>-free left module generated by the vectors in <var>init</var>
and their images under the action of <var>Agens</var> from the respective side(s).
<p>
<var>zero</var> is the zero element of the desired module.
<var>maxdim</var> is an upper bound for the dimension of the closure; if no such
upper bound is known then the value of <var>maxdim</var> must be <code>infinity</code>.
<p>
<code>MutableBasisOfClosureUnderAction</code> can be used to compute a basis of an
<strong>associative</strong> algebra generated by the elements in <var>Agens</var>. In this 
case <var>from</var> may be <code>"left"</code> or <code>"right"</code>, <var>opr</var> is the multiplication <code>*</code>,
and <var>init</var> is a list containing either the identity of the algebra or a
list of algebra generators.
(Note that if the algebra has an identity then it is in general not
sufficient to take algebra-with-one generators as <var>init</var>,
whereas of course <var>Agens</var> need not contain the identity.)
<p>
(Note that bases of <strong>not</strong> necessarily associative algebras can be
computed using <code>MutableBasisOfNonassociativeAlgebra</code>.)
<p>
Other applications of <code>MutableBasisOfClosureUnderAction</code> are the
computations of bases for (left/ right/ two-sided) ideals <i>I</i> in an
<strong>associative</strong> algebra <i>A</i> from ideal generators of <i>I</i>;
in these cases <var>Agens</var> is a list of algebra generators of <i>A</i>,
<var>from</var> denotes the appropriate side(s),
<var>init</var> is a list of ideal generators of <i>I</i>, and <var>opr</var> is again <code>*</code>.
<p>
(Note that bases of ideals in <strong>not</strong> necessarily associative algebras can
be computed using <code>MutableBasisOfIdealInNonassociativeAlgebra</code>.)
<p>
Finally, bases of right <i>A</i>-modules also can be computed using
<code>MutableBasisOfClosureUnderAction</code>.
The only difference to the ideal case is that <var>init</var> is now a list of
right module generators, and <var>opr</var> is the operation of the module.
<p>
<pre>
gap&gt; A:= QuaternionAlgebra( Rationals );;
gap&gt; g:= GeneratorsOfAlgebra( A );;
gap&gt; B:= MutableBasisOfClosureUnderAction( Rationals, g, "left", [ g[1] ], \*, Zero(A), 4 );
&lt;mutable basis over Rationals, 4 vectors&gt;
gap&gt; BasisVectors( B );
[ e, i, j, k ]
</pre>
<p>
<a name = "SSEC008.12"></a>
<li><code>MutableBasisOfNonassociativeAlgebra( </code><var>F</var><code>, </code><var>Agens</var><code>, </code><var>zero</var><code>, </code><var>maxdim</var><code> ) F</code>
<p>
is a mutable basis of the (not necessarily associative) <var>F</var>-algebra that
is generated by <var>Agens</var>, has zero element <var>zero</var>, and has dimension at
most <var>maxdim</var>.
If no finite bound for the dimension is known then <code>infinity</code> must be
the value of <var>maxdim</var>.
<p>
The difference to <code>MutableBasisOfClosureUnderAction</code> is that in general
it is not sufficient to multiply just with algebra generators.
(For special cases of nonassociative algebras, especially for Lie
algebras, multiplying with algebra generators suffices.)
<p>
<pre>
gap&gt; L:= FullMatrixLieAlgebra( Rationals, 4 );;
gap&gt; m1:= Random( L );;
gap&gt; m2:= Random( L );;
gap&gt; MutableBasisOfNonassociativeAlgebra( Rationals, [ m1, m2 ], Zero( L ),
&gt; 16 );
&lt;mutable basis over Rationals, 16 vectors&gt;
</pre>
<p>
<a name = "SSEC008.13"></a>
<li><code>MutableBasisOfIdealInNonassociativeAlgebra( </code><var>F</var><code>, </code><var>Vgens</var><code>, </code><var>Igens</var><code>, </code><var>zero</var><code>, </code><var>from</var><code>, </code><var>maxdim</var><code> ) F</code>
<p>
is a mutable basis of the ideal generated by <var>Igens</var> under the action of
the (not necessarily associative) <var>F</var>-algebra with vector space
generators <var>Vgens</var>.
The zero element of the ideal is <var>zero</var>,
<var>from</var> is one of <code>"left"</code>, <code>"right"</code>, <code>"both"</code> (with the same meaning as
in <code>MutableBasisOfClosureUnderAction</code>),
and <var>maxdim</var> is a known upper bound on the dimension of the ideal;
if no finite bound for the dimension is known then <code>infinity</code> must be
the value of <var>maxdim</var>.
<p>
The difference to <code>MutableBasisOfClosureUnderAction</code> is that in general
it is not sufficient to multiply just with algebra generators.
(For special cases of nonassociative algebras, especially for Lie
algebras, multiplying with algebra generators suffices.)
<p>
<pre>
gap&gt; mats:= [  [[ 1, 0 ], [ 0, -1 ]], [[0,1],[0,0]] ];;
gap&gt; A:= Algebra( Rationals, mats );;
gap&gt; basA:= BasisVectors( Basis( A ) );;
gap&gt; B:= MutableBasisOfIdealInNonassociativeAlgebra( Rationals, basA,
&gt; [ mats[2] ], 0*mats[1], "both", infinity );
&lt;mutable basis over Rationals, 1 vectors&gt;
gap&gt; BasisVectors( B );
[ [ [ 0, 1 ], [ 0, 0 ] ] ]
</pre>
<p>
<a name = "SSEC008.14"></a>
<li><code>DirectSumOfAlgebras( </code><var>A1</var><code>, </code><var>A2</var><code> ) O</code>
<li><code>DirectSumOfAlgebras( </code><var>list</var><code> ) O</code>
<p>
is the direct sum of the two algebras <var>A1</var> and <var>A2</var> respectively of the 
algebras in the list <var>list</var>.
<p>
If all involved algebras are associative algebras then the result is also
known to be associative.
If all involved algebras are Lie algebras then the result is also known
to be a Lie algebra.
<p>
All involved algebras must have the same left acting domain.
<p>
The default case is that the result is a structure constants algebra.
If all involved algebras are matrix algebras, and either both are Lie
algebras or both are associative then the result is again a
matrix algebra of the appropriate type.
<p>
<pre>
gap&gt; A:= QuaternionAlgebra( Rationals );;
gap&gt; DirectSumOfAlgebras( [A, A, A] );
&lt;algebra of dimension 12 over Rationals&gt;
</pre>
<p>
<a name = "SSEC008.15"></a>
<li><code>FullMatrixAlgebraCentralizer( </code><var>F</var><code>, </code><var>lst</var><code> ) F</code>
<p>
Compute the centralizer of the list of matrices in the list <var>lst</var> in the 
full matrix algebra over the ring <var>F</var>. 
<p>
<pre>
gap&gt; A:= QuaternionAlgebra( Rationals );;
gap&gt; mats:= List(BasisVectors(Basis( A ) ), x -&gt; AdjointMatrix(Basis(A), x ));;
gap&gt; FullMatrixAlgebraCentralizer( Rationals, mats );
&lt;algebra-with-one of dimension 4 over Rationals&gt;
</pre>
<p>
<a name = "SSEC008.16"></a>
<li><code>RadicalOfAlgebra( </code><var>A</var><code> ) A</code>
<p>
is the maximal nilpotent ideal of <var>A</var>, where <var>A</var> is an associative 
algebra.
<p>
<pre>
gap&gt; m:= [ [ 0, 1, 2 ], [ 0, 0, 3 ], [ 0, 0, 0 ] ];;
gap&gt; A:= AlgebraWithOneByGenerators( Rationals, [ m ] );
&lt;algebra-with-one over Rationals, with 1 generators&gt;
gap&gt; RadicalOfAlgebra( A );
&lt;algebra of dimension 2 over Rationals&gt;
</pre>
<p>
<a name = "SSEC008.17"></a>
<li><code>CentralIdempotentsOfAlgebra( </code><var>A</var><code> ) A</code>
<p>
For an associative algebra <var>A</var>, this function returns
a list of central primitive idempotents such that their sum is
the identity element of <var>A</var>. Therefore <var>A</var> is required to have an
identity.
<p>
(This is a synonym of <code>CentralIdempotentsOfSemiring</code>.)
<p>
<pre>
gap&gt; A:= QuaternionAlgebra( Rationals );;
gap&gt; B:= DirectSumOfAlgebras( [A, A, A] );
&lt;algebra of dimension 12 over Rationals&gt;
gap&gt; CentralIdempotentsOfAlgebra( B );
[ v.9, v.5, v.1 ]
</pre>
<p>
<a name = "SSEC008.18"></a>
<li><code>DirectSumDecomposition( </code><var>L</var><code> ) A</code>
<p>
This function calculates a list of ideals of the algebra <var>L</var> such
that <var>L</var> is equal to their direct sum. Currently this is only implemented
for semisimple associative algebras, and Lie algebras (semisimple or not).
<p>
<pre>
gap&gt; G:= SymmetricGroup( 4 );;
gap&gt; A:= GroupRing( Rationals, G );
&lt;algebra-with-one over Rationals, with 2 generators&gt;
gap&gt; dd:= DirectSumDecomposition( A );
[ &lt;two-sided ideal in &lt;algebra-with-one of dimension 24 over Rationals&gt;, 
      (1 generators)&gt;, 
  &lt;two-sided ideal in &lt;algebra-with-one of dimension 24 over Rationals&gt;, 
      (1 generators)&gt;, 
  &lt;two-sided ideal in &lt;algebra-with-one of dimension 24 over Rationals&gt;, 
      (1 generators)&gt;, 
  &lt;two-sided ideal in &lt;algebra-with-one of dimension 24 over Rationals&gt;, 
      (1 generators)&gt;, 
  &lt;two-sided ideal in &lt;algebra-with-one of dimension 24 over Rationals&gt;, 
      (1 generators)&gt; ]
gap&gt; List( dd, Dimension );
[ 1, 1, 4, 9, 9 ]
</pre>
<p>
<a name = "SSEC008.19"></a>
<li><code>LeviMalcevDecomposition( </code><var>L</var><code> ) A</code>
<p>
A Levi-Malcev subalgebra of the algebra <var>L</var> is a semisimple subalgebra
complementary to the radical of <var>L</var>. This function returns
a list with two components. The first component is a Levi-Malcev 
subalgebra, the second the radical. This function is implemented for 
associative and Lie algebras. 
<p>
<pre>
gap&gt; m:= [ [ 1, 2, 0 ], [ 0, 1, 3 ], [ 0, 0, 1] ];;
gap&gt; A:= Algebra( Rationals, [ m ] );;
gap&gt; LeviMalcevDecomposition( A );
[ &lt;algebra of dimension 1 over Rationals&gt;, 
  &lt;algebra of dimension 2 over Rationals&gt; ]
</pre>
<p>
<a name = "SSEC008.20"></a>
<li><code>Grading( </code><var>A</var><code> ) A</code>
<p>
Let <i>G</i> be an Abelian group and <i>A</i> an algebra. Then <i>A</i> is said to 
be graded over <i>G</i> if for every <i>g</i>  &#8712; <i>G</i> there is a subspace <i>A</i><sub><i>g</i></sub>
of <i>A</i> such that <i>A</i><sub><i>g</i></sub> &#183;<i>A</i><sub><i>h</i></sub>  &#8834; <i>A</i><sub><i>g</i>+<i>h</i></sub> for <i>g</i>, <i>h</i>  &#8712; <i>G</i>. 
In <font face="Gill Sans,Helvetica,Arial">GAP</font>&nbsp;4 a <strong>grading</strong> of an algebra is a record containing the following
components: 
<p>
<dl compact>
<dt><code>source</code><dd>
  the Abelian group over which the algebra is graded.
<dt><code>hom_components</code><dd>
  a function assigning to each element from the
  source a subspace of the algebra.
<dt><code>min_degree</code><dd>
  in the case where the algebra is graded over the integers
  this is the minimum number for which <code>hom_components</code> returns a nonzero
  subspace.
<dt><code>max_degree</code><dd>
  is analogous to <code>min_degree</code>.
</dl>
We note that there are no methods to compute a grading of an 
arbitrary algebra; however some algebras get a natural grading when
they are constructed (see <a href="../ref/CHAP061.htm#SSEC008.4">JenningsLieAlgebra</a>, 
<a href="../ref/CHAP061.htm#SSEC011.2">NilpotentQuotientOfFpLieAlgebra</a>).
<p>
We note also that these components may be not enough to handle 
the grading efficiently, and another record component may be needed.
For instance in a Lie algebra <i>L</i> constructed by 
<code>JenningsLieAlgebra</code>, the length of the of the range
<code>[ Grading(L)!.min_degree .. Grading(L)!.max_degree ]</code> may be 
non-polynomial in the dimension of <i>L</i>.
To handle efficiently this situation, an optional component can be 
used:
<p>
<dl compact>
<dt><code>non_zero_hom_components</code><dd>
  the subset of <code>source</code> for which <code>hom_components</code> returns a nonzero
  subspace.
</dl>
<p>
<pre>
gap&gt; G:= SmallGroup(3^6, 100 );
&lt;pc group of size 729 with 6 generators&gt;
gap&gt; L:= JenningsLieAlgebra( G );
&lt;Lie algebra of dimension 6 over GF(3)&gt;
gap&gt; g:= Grading( L );
rec( min_degree := 1, max_degree := 9, source := Integers, 
  hom_components := function( d ) ... end )
gap&gt; g.hom_components( 3 );
&lt;vector space over GF(3), with 1 generators&gt;
gap&gt; g.hom_components( 14 );
&lt;vector space over GF(3), with 0 generators&gt;
</pre>
<p>
<p>
<h2><a name="SECT009">60.9 Homomorphisms of Algebras</a></h2>
<p><p>
Algebra homomorphisms are vector space homomorphisms that preserve the
multiplication.
So the default methods for vector space homomorphisms work,
and in fact there is not much use of the fact that source and range are
algebras, except that preimages and images are algebras (or even ideals)
in certain cases.
<p>
<a name = "SSEC009.1"></a>
<li><code>AlgebraGeneralMappingByImages( </code><var>A</var><code>, </code><var>B</var><code>, </code><var>gens</var><code>, </code><var>imgs</var><code> ) O</code>
<p>
is a general mapping from the <i>F</i>-algebra <var>A</var> to the <i>F</i>-algebra <var>B</var>.
This general mapping is defined by mapping the entries in the list <var>gens</var>
(elements of <var>A</var>) to the entries in the list <var>imgs</var> (elements of <var>B</var>),
and taking the <i>F</i>-linear and multiplicative closure.
<p>
<var>gens</var> need not generate <var>A</var> as an <i>F</i>-algebra, and if the
specification does not define a linear and multiplicative mapping then
the result will be multivalued.
Hence, in general it is not a mapping.
For constructing a linear map that is not
necessarily multiplicative, we refer to <code>LeftModuleHomomorphismByImages</code>
(<a href="../ref/CHAP059.htm#SSEC009.2">leftmodulehomomorphismbyimages</a>).
<p>
<pre>
gap&gt; A:= QuaternionAlgebra( Rationals );;
gap&gt; B:= FullMatrixAlgebra( Rationals, 2 );;
gap&gt; bA:= BasisVectors( Basis( A ) );; bB:= BasisVectors( Basis( B ) );;
gap&gt; f:= AlgebraGeneralMappingByImages( A, B, bA, bB );
[ e, i, j, k ] -&gt; [ [ [ 1, 0 ], [ 0, 0 ] ], [ [ 0, 1 ], [ 0, 0 ] ], 
  [ [ 0, 0 ], [ 1, 0 ] ], [ [ 0, 0 ], [ 0, 1 ] ] ]
gap&gt; Images( f, bA[1] );
&lt;add. coset of &lt;algebra over Rationals, with 60 generators&gt;&gt;
</pre>
<p>
<a name = "SSEC009.2"></a>
<li><code>AlgebraHomomorphismByImages( </code><var>A</var><code>, </code><var>B</var><code>, </code><var>gens</var><code>, </code><var>imgs</var><code> ) F</code>
<p>
<code>AlgebraHomomorphismByImages</code> returns the algebra homomorphism with
source <var>A</var> and range <var>B</var> that is defined by mapping the list <var>gens</var> of
generators of <var>A</var> to the list <var>imgs</var> of images in <var>B</var>.
<p>
If <var>gens</var> does not generate <var>A</var> or if the homomorphism does not exist
(i.e., if mapping the generators describes only a multi-valued mapping)
then <code>fail</code> is returned.
<p>
One can avoid the checks by calling <code>AlgebraHomomorphismByImagesNC</code>,
and one can construct multi-valued mappings with
<code>AlgebraGeneralMappingByImages</code>.
<p>
<pre>
gap&gt; T:= EmptySCTable( 2, 0 );;
gap&gt; SetEntrySCTable( T, 1, 1, [1,1] ); SetEntrySCTable( T, 2, 2, [1,2] );
gap&gt; A:= AlgebraByStructureConstants( Rationals, T );;
gap&gt; m1:= NullMat( 2, 2 );; m1[1][1]:= 1;;
gap&gt; m2:= NullMat( 2, 2 );; m2[2][2]:= 1;;
gap&gt; B:= AlgebraByGenerators( Rationals, [ m1, m2 ] );;
gap&gt; bA:= BasisVectors( Basis( A ) );; bB:= BasisVectors( Basis( B ) );;
gap&gt; f:= AlgebraHomomorphismByImages( A, B, bA, bB );
[ v.1, v.2 ] -&gt; [ [ [ 1, 0 ], [ 0, 0 ] ], [ [ 0, 0 ], [ 0, 1 ] ] ]
gap&gt; Image( f, bA[1]+bA[2] );
[ [ 1, 0 ], [ 0, 1 ] ]
</pre>
<p>
<a name = "SSEC009.3"></a>
<li><code>AlgebraHomomorphismByImagesNC( </code><var>A</var><code>, </code><var>B</var><code>, </code><var>gens</var><code>, </code><var>imgs</var><code> ) O</code>
<p>
<code>AlgebraHomomorphismByImagesNC</code> is the operation that is called by the
function <code>AlgebraHomomorphismByImages</code>.
Its methods may assume that <var>gens</var> generates <var>A</var> and that the mapping of
<var>gens</var> to <var>imgs</var> defines an algebra homomorphism.
Results are unpredictable if these conditions do not hold.
<p>
For creating a possibly multi-valued mapping from <var>A</var> to <var>B</var> that
respects addition, multiplication, and scalar multiplication,
<code>AlgebraGeneralMappingByImages</code> can be used.
<p>
For the definitions of the algebras <code>A</code> and <code>B</code> in the next example we refer
to the previous example.
<p>
<pre>
gap&gt; f:= AlgebraHomomorphismByImagesNC( A, B, bA, bB );
[ v.1, v.2 ] -&gt; [ [ [ 1, 0 ], [ 0, 0 ] ], [ [ 0, 0 ], [ 0, 1 ] ] ]
</pre>
<p>
<a name = "SSEC009.4"></a>
<li><code>AlgebraWithOneGeneralMappingByImages( </code><var>A</var><code>, </code><var>B</var><code>, </code><var>gens</var><code>, </code><var>imgs</var><code> ) O</code>
<p>
This function is analogous to <a href="CHAP060.htm#SSEC009.1">AlgebraGeneralMappingByImages</a>;
the only difference being that the identity of <var>A</var> is automatically
mapped to the identity of <var>B</var>.
<p>
<pre>
gap&gt; A:= QuaternionAlgebra( Rationals );;
gap&gt; B:= FullMatrixAlgebra( Rationals, 2 );;
gap&gt; bA:= BasisVectors( Basis( A ) );; bB:= BasisVectors( Basis( B ) );;
gap&gt; f:= AlgebraWithOneGeneralMappingByImages(A,B,bA{[2,3,4]},bB{[1,2,3]});
[ i, j, k, e ] -&gt; [ [ [ 1, 0 ], [ 0, 0 ] ], [ [ 0, 1 ], [ 0, 0 ] ], 
  [ [ 0, 0 ], [ 1, 0 ] ], [ [ 1, 0 ], [ 0, 1 ] ] ]
</pre>
<p>
<a name = "SSEC009.5"></a>
<li><code>AlgebraWithOneHomomorphismByImages( </code><var>A</var><code>, </code><var>B</var><code>, </code><var>gens</var><code>, </code><var>imgs</var><code> ) F</code>
<p>
<code>AlgebraWithOneHomomorphismByImages</code> returns the algebra-with-one
homomorphism with source <var>A</var> and range <var>B</var> that is defined by mapping the
list <var>gens</var> of generators of <var>A</var> to the list <var>imgs</var> of images in <var>B</var>.
<p>
The difference between an algebra homomorphism and an algebra-with-one
homomorphism is that in the latter case,
it is assumed that the identity of <var>A</var> is mapped to the identity of <var>B</var>,
and therefore <var>gens</var> needs to generate <var>A</var> only as an
algebra-with-one.
<p>
If <var>gens</var> does not generate <var>A</var> or if the homomorphism does not exist
(i.e., if mapping the generators describes only a multi-valued mapping)
then <code>fail</code> is returned.
<p>
One can avoid the checks by calling
<code>AlgebraWithOneHomomorphismByImagesNC</code>,
and one can construct multi-valued mappings with
<code>AlgebraWithOneGeneralMappingByImages</code>.
<p>
<pre>
gap&gt; m1:= NullMat( 2, 2 );; m1[1][1]:=1;;
gap&gt; m2:= NullMat( 2, 2 );; m2[2][2]:=1;;
gap&gt; A:= AlgebraByGenerators( Rationals, [m1,m2] );;
gap&gt; T:= EmptySCTable( 2, 0 );;
gap&gt; SetEntrySCTable( T, 1, 1, [1,1] );
gap&gt; SetEntrySCTable( T, 2, 2, [1,2] );
gap&gt; B:= AlgebraByStructureConstants(Rationals, T);;
gap&gt; bA:= BasisVectors( Basis( A ) );; bB:= BasisVectors( Basis( B ) );;
gap&gt; f:= AlgebraWithOneHomomorphismByImages( A, B, bA{[1]}, bB{[1]} );
[ [ [ 1, 0 ], [ 0, 0 ] ], [ [ 1, 0 ], [ 0, 1 ] ] ] -&gt; [ v.1, v.1+v.2 ]
</pre>
<p>
<a name = "SSEC009.6"></a>
<li><code>AlgebraWithOneHomomorphismByImagesNC( </code><var>A</var><code>, </code><var>B</var><code>, </code><var>gens</var><code>, </code><var>imgs</var><code> ) O</code>
<p>
<code>AlgebraWithOneHomomorphismByImagesNC</code> is the operation that is called by
the function <code>AlgebraWithOneHomomorphismByImages</code>.
Its methods may assume that <var>gens</var> generates <var>A</var> and that the mapping of
<var>gens</var> to <var>imgs</var> defines an algebra-with-one homomorphism.
Results are unpredictable if these conditions do not hold.
<p>
For creating a possibly multi-valued mapping from <var>A</var> to <var>B</var> that
respects addition, multiplication, identity, and scalar multiplication,
<code>AlgebraWithOneGeneralMappingByImages</code> can be used.
<p>
<pre>
gap&gt; m1:= NullMat( 2, 2 );; m1[1][1]:=1;;
gap&gt; m2:= NullMat( 2, 2 );; m2[2][2]:=1;;
gap&gt; A:= AlgebraByGenerators( Rationals, [m1,m2] );;
gap&gt; T:= EmptySCTable( 2, 0 );;
gap&gt; SetEntrySCTable( T, 1, 1, [1,1] );
gap&gt; SetEntrySCTable( T, 2, 2, [1,2] );
gap&gt; B:= AlgebraByStructureConstants( Rationals, T);;
gap&gt; bA:= BasisVectors( Basis( A ) );; bB:= BasisVectors( Basis( B ) );;
gap&gt; f:= AlgebraWithOneHomomorphismByImagesNC( A, B, bA{[1]}, bB{[1]} );
[ [ [ 1, 0 ], [ 0, 0 ] ], [ [ 1, 0 ], [ 0, 1 ] ] ] -&gt; [ v.1, v.1+v.2 ]
</pre>
<p>
<a name = "SSEC009.7"></a>
<li><code>NaturalHomomorphismByIdeal( </code><var>A</var><code>, </code><var>I</var><code> ) O</code>
<p>
is the homomorphism of algebras provided by the natural
projection map of <var>A</var> onto the quotient algebra <var>A</var>/<var>I</var>.
This map can be used to take pre-images in the original algebra from
elements in the quotient.
<p>
<pre>
gap&gt; L:= FullMatrixLieAlgebra( Rationals, 3 );;
gap&gt; C:= LieCentre( L );
&lt;two-sided ideal in &lt;Lie algebra of dimension 9 over Rationals&gt;, (dimension 1
 )&gt;
gap&gt; hom:= NaturalHomomorphismByIdeal( L, C );
&lt;linear mapping by matrix, &lt;Lie algebra of dimension 
9 over Rationals&gt; -&gt; &lt;Lie algebra of dimension 8 over Rationals&gt;&gt;
gap&gt; ImagesSource( hom );
&lt;Lie algebra of dimension 8 over Rationals&gt;
</pre>
<p>
<a name = "SSEC009.8"></a>
<li><code>OperationAlgebraHomomorphism( </code><var>A</var><code>, </code><var>B</var><code>[, </code><var>opr</var><code>] ) O</code>
<li><code>OperationAlgebraHomomorphism( </code><var>A</var><code>, </code><var>V</var><code>[, </code><var>opr</var><code>] ) O</code>
<p>
<code>OperationAlgebraHomomorphism</code> returns an algebra homomorphism from the
<i>F</i>-algebra <var>A</var> into a matrix algebra over <i>F</i> that describes the
<i>F</i>-linear action of <var>A</var> on the basis <var>B</var> of a free left module
respectively on the free left module <var>V</var> (in which case some basis of <var>V</var>
is chosen), via the operation <var>opr</var>.
<p>
The homomorphism need not be surjective.
The default value for <var>opr</var> is <code>OnRight</code>.
<p>
If <var>A</var> is an algebra-with-one then the operation homomorphism is an
algebra-with-one homomorphism because the identity of <var>A</var> must act
as the identity.
<p>
<pre>
gap&gt; m1:= NullMat( 2, 2 );; m1[1][1]:= 1;;
gap&gt; m2:= NullMat( 2, 2 );; m2[2][2]:= 1;;
gap&gt; B:= AlgebraByGenerators( Rationals, [ m1, m2 ] );;
gap&gt; V:= FullRowSpace( Rationals, 2 );
( Rationals^2 )
gap&gt; f:=OperationAlgebraHomomorphism( B, Basis( V ), OnRight );
&lt;op. hom. Algebra( Rationals, 
[ [ [ 1, 0 ], [ 0, 0 ] ], [ [ 0, 0 ], [ 0, 1 ] ] ] ) -&gt; matrices of dim. 2&gt;
gap&gt; Image( f, m1 );
[ [ 1, 0 ], [ 0, 0 ] ]
</pre>
<p>
<a name = "SSEC009.9"></a>
<li><code>IsomorphismFpAlgebra( </code><var>A</var><code> ) A</code>
<p>
isomorphism from the algebra <var>A</var> onto a finitely presented algebra. Currently this
is only implemented for associative algebras with one.
<p>
<pre>
gap&gt; A:= QuaternionAlgebra( Rationals );
&lt;algebra-with-one of dimension 4 over Rationals&gt;
gap&gt; f:= IsomorphismFpAlgebra( A );
[ e, i, j, k, e ] -&gt; [ [(1)*x.1], [(1)*x.2], [(1)*x.3], [(1)*x.4], 
  [(1)*&lt;identity ...&gt;] ]
</pre>
<p>
<a name = "SSEC009.10"></a>
<li><code>IsomorphismMatrixAlgebra( </code><var>A</var><code> ) A</code>
<p>
isomorphism from the algebra <var>A</var> onto a matrix algebra. Currently this
is only implemented for associative algebras with one.
<p>
<pre>
gap&gt; T:= EmptySCTable( 2, 0 );;
gap&gt; SetEntrySCTable( T, 1, 1, [1,1] ); SetEntrySCTable( T, 2, 2, [1,2] );
gap&gt; A:= AlgebraByStructureConstants( Rationals, T );;
gap&gt; A:= AsAlgebraWithOne( Rationals, A );;
gap&gt; f:=IsomorphismMatrixAlgebra( A );
&lt;op. hom. AlgebraWithOne( Rationals, ... ) -&gt; matrices of dim. 2&gt;
gap&gt; Image( f, BasisVectors( Basis( A ) )[1] );
[ [ 1, 0 ], [ 0, 0 ] ]
</pre>
<p>
<a name = "SSEC009.11"></a>
<li><code>IsomorphismSCAlgebra( </code><var>B</var><code> ) A</code>
<li><code>IsomorphismSCAlgebra( </code><var>A</var><code> ) A</code>
<p>
For a basis <var>B</var> of an algebra <i>A</i>, say, <code>IsomorphismSCAlgebra</code> returns an
algebra isomorphism from <i>A</i> to an algebra <i>S</i> given by structure
constants (see&nbsp;<a href="CHAP060.htm#SECT003">Constructing Algebras by Structure Constants</a>),
such that the canonical basis of <i>S</i> is the image of <var>B</var>.
<p>
For an algebra <var>A</var>, <code>IsomorphismSCAlgebra</code> chooses a basis of <var>A</var> and
returns the <code>IsomorphismSCAlgebra</code> value for that basis.
<p>
<pre>
gap&gt; IsomorphismSCAlgebra( GF(8) );
CanonicalBasis( GF(2^3) ) -&gt; CanonicalBasis( &lt;algebra of dimension 3 over GF(
2)&gt; )
gap&gt; IsomorphismSCAlgebra( GF(2)^[2,2] );
CanonicalBasis( ( GF(2)^[ 2, 2 ] ) ) -&gt; CanonicalBasis( &lt;algebra of dimension 
4 over GF(2)&gt; )
</pre>
<p>
<a name = "SSEC009.12"></a>
<li><code>RepresentativeLinearOperation( </code><var>A</var><code>, </code><var>v</var><code>, </code><var>w</var><code>, </code><var>opr</var><code> ) O</code>
<p>
is an element of the algebra <var>A</var> that maps the vector <var>v</var>
to the vector <var>w</var> under the linear operation described by the function
<var>opr</var>. If no such element exists then <code>fail</code> is returned.
<p>
<pre>
gap&gt; m1:= NullMat( 2, 2 );; m1[1][1]:= 1;;
gap&gt; m2:= NullMat( 2, 2 );; m2[2][2]:= 1;;
gap&gt; B:= AlgebraByGenerators( Rationals, [ m1, m2 ] );;
gap&gt; RepresentativeLinearOperation( B, [1,0], [1,0], OnRight );
[ [ 1, 0 ], [ 0, 0 ] ]
gap&gt; RepresentativeLinearOperation( B, [1,0], [0,1], OnRight );
fail
</pre>
<p>
<p>
<h2><a name="SECT010">60.10 Representations of Algebras</a></h2>
<p><p>
An algebra module is a vector space together with an action of an
algebra. So a module over an algebra is constructed by giving generators
of a vector space, and a function for calculating the action of
algebra elements on elements of the vector space. When creating an
algebra module, the generators of the vector space are wrapped up and
given the category <code>IsLeftAlgebraModuleElement</code> or
<code>IsRightModuleElement</code> if the algebra acts from the left, or right
respectively. (So in the case of a bi-module the elements get
both categories.) Most linear algebra computations are delegated to
the original vector space.
<p>
The transition between the original vector space and the corresponding
algebra module is handled by <code>ExtRepOfObj</code> and <code>ObjByExtRep</code>.
For an element <code>v</code> of the algebra module, <code>ExtRepOfObj( v )</code> returns
the underlying element of the original vector space. Furthermore, if <code>vec</code>
is an element of the original vector space, and <code>fam</code> the elements
family of the corresponding algebra module, then <code>ObjByExtRep( fam, vec )</code>
returns the corresponding element of the algebra module. Below is an
example of this.
<p>
The action of the algebra on elements of the algebra module is constructed
by using the operator <code>^</code>. If <code>x</code> is an element of an algebra <code>A</code>, and
<code>v</code> an element of a left <code>A</code>-module, then <code>x^v</code> calculates the result
of the action of <code>x</code> on <code>v</code>. Similarly, if <code>v</code> is an element of
a right <code>A</code>-module, then <code>v^x</code> calculates the action of <code>x</code> on <code>v</code>.
<p>
<a name = "SSEC010.1"></a>
<li><code>LeftAlgebraModuleByGenerators( </code><var>A</var><code>, </code><var>op</var><code>, </code><var>gens</var><code> ) O</code>
<p>
Constructs the left algebra module over <var>A</var> generated by the list of
vectors
<var>gens</var>. The action of <var>A</var> is described by the function <var>op</var>. This must
be a function of two arguments; the first argument is the algebra element,
and the second argument is a vector; it outputs the result of applying
the algebra element to the vector.
<p>
<a name = "SSEC010.2"></a>
<li><code>RightAlgebraModuleByGenerators( </code><var>A</var><code>, </code><var>op</var><code>, </code><var>gens</var><code> ) O</code>
<p>
Constructs the right algebra module over <var>A</var> generated by the list of
vectors
<var>gens</var>. The action of <var>A</var> is described by the function <var>op</var>. This must
be a function of two arguments; the first argument is a vector, and the
second argument is the algebra element; it outputs the result of applying
the algebra element to the vector.
<p>
<a name = "SSEC010.3"></a>
<li><code>BiAlgebraModuleByGenerators( </code><var>A</var><code>, </code><var>B</var><code>, </code><var>opl</var><code>, </code><var>opr</var><code>, </code><var>gens</var><code> ) O</code>
<p>
Constructs the algebra bi-module over <var>A</var> and <var>B</var> generated by the list of
vectors
<var>gens</var>. The left action of <var>A</var> is described by the function <var>opl</var>,
and the right action of <var>B</var> by the function <var>opr</var>. <var>opl</var> must be a
function of two arguments; the first argument is the algebra element,
and the second argument is a vector; it outputs the result of applying
the algebra element on the left to the vector. <var>opr</var> must
be a function of two arguments; the first argument is a vector, and the
second argument is the algebra element; it outputs the result of applying
the algebra element on the right to the vector.
<p>
<pre>
gap&gt; A:= Rationals^[3,3];
( Rationals^[ 3, 3 ] )
gap&gt; V:= LeftAlgebraModuleByGenerators( A, \*, [ [ 1, 0, 0 ] ] );
&lt;left-module over ( Rationals^[ 3, 3 ] )&gt;
gap&gt; W:= RightAlgebraModuleByGenerators( A, \*, [ [ 1, 0, 0 ] ] );
&lt;right-module over ( Rationals^[ 3, 3 ] )&gt;
gap&gt; M:= BiAlgebraModuleByGenerators( A, A, \*, \*, [ [ 1, 0, 0 ] ] );
&lt;bi-module over ( Rationals^[ 3, 3 ] ) (left) and ( Rationals^
[ 3, 3 ] ) (right)&gt;
</pre>
<p>
In the above examples, the modules <code>V</code>, <code>W</code>, and <code>M</code> are 3-dimensional
vector spaces over the rationals.
The algebra <code>A</code> acts from the left on <code>V</code>, from the right on <code>W</code>,
and from the left and from the right on <code>M</code>.
<p>
<a name = "SSEC010.4"></a>
<li><code>LeftAlgebraModule( </code><var>A</var><code>, </code><var>op</var><code>, </code><var>V</var><code> ) O</code>
<p>
Constructs the left algebra module over <var>A</var> with underlying space <var>V</var>.
The action of <var>A</var> is described by the function <var>op</var>. This must
be a function of two arguments; the first argument is the algebra element,
and the second argument is a vector from <var>V</var>; it outputs the result of 
applying the algebra element to the vector.
<p>
<a name = "SSEC010.5"></a>
<li><code>RightAlgebraModule( </code><var>A</var><code>, </code><var>op</var><code>, </code><var>V</var><code> ) O</code>
<p>
Constructs the right algebra module over <var>A</var> with underlying space <var>V</var>.
The action of <var>A</var> is described by the function <var>op</var>. This must
be a function of two arguments; the first argument is a vector, from <var>V</var>
and the
second argument is the algebra element; it outputs the result of applying
the algebra element to the vector.
<p>
<a name = "SSEC010.6"></a>
<li><code>BiAlgebraModule( </code><var>A</var><code>, </code><var>B</var><code>, </code><var>opl</var><code>, </code><var>opr</var><code>, </code><var>V</var><code> ) O</code>
<p>
Constructs the algebra bi-module over <var>A</var> and <var>B</var> with underlying space 
<var>V</var>. The left action of <var>A</var> is described by the function <var>opl</var>,
and the right action of <var>B</var> by the function <var>opr</var>. <var>opl</var> must be a
function of two arguments; the first argument is the algebra element,
and the second argument is a vector from <var>V</var>; it outputs the result of 
applying
the algebra element on the left to the vector. <var>opr</var> must
be a function of two arguments; the first argument is a vector from <var>V</var>, 
and the
second argument is the algebra element; it outputs the result of applying
the algebra element on the right to the vector.
<p>
<pre>
gap&gt; A:= Rationals^[3,3];;
gap&gt; V:= Rationals^3;
( Rationals^3 )
gap&gt; V:= Rationals^3;;
gap&gt; M:= BiAlgebraModule( A, A, \*, \*, V );
&lt;bi-module over ( Rationals^[ 3, 3 ] ) (left) and ( Rationals^
[ 3, 3 ] ) (right)&gt;
gap&gt; Dimension( M );
3
</pre>
<p>
<a name = "SSEC010.7"></a>
<li><code>GeneratorsOfAlgebraModule( </code><var>M</var><code> ) A</code>
<p>
A list of elements of <var>M</var> that generate <var>M</var> as an algebra module.
<p>
<pre>
gap&gt; A:= Rationals^[3,3];;
gap&gt; V:= LeftAlgebraModuleByGenerators( A, \*, [ [ 1, 0, 0 ] ] );;
gap&gt; GeneratorsOfAlgebraModule( V );
[ [ 1, 0, 0 ] ]
</pre>
<p>
<a name = "SSEC010.8"></a>
<li><code>IsAlgebraModuleElement( </code><var>obj</var><code> ) C</code>
<a name = "SSEC010.8"></a>
<li><code>IsAlgebraModuleElementCollection( </code><var>obj</var><code> ) C</code>
<a name = "SSEC010.8"></a>
<li><code>IsAlgebraModuleElementFamily( </code><var>fam</var><code> ) C</code>
<p>
Category of algebra module elements. If an object has
<code>IsAlgebraModuleElementCollection</code>, then it is an algebra module.
If a family has <code>IsAlgebraModuleElementFamily</code>, then it is a family
of algebra module elements (every algebra module has its own elements
family).
<p>
<a name = "SSEC010.9"></a>
<li><code>IsLeftAlgebraModuleElement( </code><var>obj</var><code> ) C</code>
<a name = "SSEC010.9"></a>
<li><code>IsLeftAlgebraModuleElementCollection( </code><var>obj</var><code> ) C</code>
<p>
Category of left algebra module elements. If an object has
<code>IsLeftAlgebraModuleElementCollection</code>, then it is a left-algebra module.
<p>
<a name = "SSEC010.10"></a>
<li><code>IsRightAlgebraModuleElement( </code><var>obj</var><code> ) C</code>
<a name = "SSEC010.10"></a>
<li><code>IsRightAlgebraModuleElementCollection( </code><var>obj</var><code> ) C</code>
<p>
Category of right algebra module elements. If an object has
<code>IsRightAlgebraModuleElementCollection</code>, then it is a right-algebra module.
<p>
<pre>
gap&gt; A:= Rationals^[3,3];
( Rationals^[ 3, 3 ] )
gap&gt; M:= BiAlgebraModuleByGenerators( A, A, \*, \*, [ [ 1, 0, 0 ] ] );
&lt;bi-module over ( Rationals^[ 3, 3 ] ) (left) and ( Rationals^
[ 3, 3 ] ) (right)&gt;
gap&gt; vv:= BasisVectors( Basis( M ) );
[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ]
gap&gt; IsLeftAlgebraModuleElement( vv[1] );
true
gap&gt; IsRightAlgebraModuleElement( vv[1] );
true
gap&gt; vv[1] = [ 1, 0, 0 ];
false
gap&gt; ExtRepOfObj( vv[1] ) = [ 1, 0, 0 ];
true
gap&gt; ObjByExtRep( ElementsFamily( FamilyObj( M ) ), [ 1, 0, 0 ] ) in M;
true
gap&gt; xx:= BasisVectors( Basis( A ) );;
gap&gt; xx[4]^vv[1];  # left action
[ 0, 1, 0 ]
gap&gt; vv[1]^xx[2];  # right action
[ 0, 1, 0 ]
</pre>
<p>
<a name = "SSEC010.11"></a>
<li><code>LeftActingAlgebra( </code><var>V</var><code> ) A</code>
<p>
Here <var>V</var> is a left-algebra module; this function returns the algebra
that acts from the left on <var>V</var>.
<p>
<a name = "SSEC010.12"></a>
<li><code>RightActingAlgebra( </code><var>V</var><code> ) A</code>
<p>
Here <var>V</var> is a right-algebra module; this function returns the algebra
that acts from the right on <var>V</var>.
<p>
<a name = "SSEC010.13"></a>
<li><code>ActingAlgebra( </code><var>V</var><code> ) O</code>
<p>
Here <var>V</var> is an algebra module; this function returns the algebra
that acts on <var>V</var> (this is the same as <code>LeftActingAlgebra( </code><var>V</var><code> )</code> if <var>V</var> is
a left module, and <code>RightActingAlgebra( </code><var>V</var><code> )</code> if <var>V</var> is a right module;
it will signal an error if <var>V</var> is a bi-module).
<p>
<pre>
gap&gt; A:= Rationals^[3,3];;
gap&gt; M:= BiAlgebraModuleByGenerators( A, A, \*, \*, [ [ 1, 0, 0 ] ] );;
gap&gt; LeftActingAlgebra( M );
( Rationals^[ 3, 3 ] )
gap&gt; RightActingAlgebra( M );
( Rationals^[ 3, 3 ] )
gap&gt; V:= RightAlgebraModuleByGenerators( A, \*, [ [ 1, 0, 0 ] ] );;
gap&gt; ActingAlgebra( V );
( Rationals^[ 3, 3 ] )
</pre>
<p>
<a name = "SSEC010.14"></a>
<li><code>IsBasisOfAlgebraModuleElementSpace( </code><var>B</var><code> ) C</code>
<p>
If a basis <var>B</var> lies in the category <code>IsBasisOfAlgebraModuleElementSpace</code>,
then
<var>B</var> is a basis of a subspace of an algebra module. This means that
<var>B</var> has the record field <code></code><var>B</var><code>!.delegateBasis</code> set. This last object
is a basis of the corresponding subspace of the vector space underlying
the algebra module (i.e., the vector
space spanned by all <code>ExtRepOfObj( v )</code> for <code>v</code> in
the algebra module).
<p>
<pre>
gap&gt; A:= Rationals^[3,3];;
gap&gt; M:= BiAlgebraModuleByGenerators( A, A, \*, \*, [ [ 1, 0, 0 ] ] );;
gap&gt; B:= Basis( M );
Basis( &lt;3-dimensional bi-module over ( Rationals^
[ 3, 3 ] ) (left) and ( Rationals^[ 3, 3 ] ) (right)&gt;, 
[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ] )
gap&gt; IsBasisOfAlgebraModuleElementSpace( B );
true
gap&gt; B!.delegateBasis;
SemiEchelonBasis( &lt;vector space of dimension 3 over Rationals&gt;, 
[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ] )
</pre>
<p>
<a name = "SSEC010.15"></a>
<li><code>MatrixOfAction( </code><var>B</var><code>, </code><var>x</var><code> ) O</code>
<li><code>MatrixOfAction( </code><var>B</var><code>, </code><var>x</var><code>, </code><var>side</var><code> ) O</code>
<p>
Here <var>B</var> is a basis of an algebra module and <var>x</var> is an element
of the algebra that acts on this module. This function returns
the matrix of the action of <var>x</var> with respect to <var>B</var>. If <var>x</var> acts
from the left, then the coefficients of the images of the basis
elements of <var>B</var> (under the action of <var>x</var>) are the columns of the output.
If <var>x</var> acts from the
right, then they are the rows of the output.
<p>
If the module is a bi-module, then the third parameter <var>side</var> must
be specified. This is the string <code>left</code>, or <code>right</code> depending whether
<var>x</var> acts from the left or the right.
<p>
<pre>
gap&gt; M:= LeftAlgebraModuleByGenerators( A, \*, [ [ 1, 0, 0 ] ] );;
gap&gt; x:= Basis(A)[3];
[ [ 0, 0, 1 ], [ 0, 0, 0 ], [ 0, 0, 0 ] ]
gap&gt; MatrixOfAction( Basis( M ), x );
[ [ 0, 0, 1 ], [ 0, 0, 0 ], [ 0, 0, 0 ] ]
</pre>
<p>
<a name = "SSEC010.16"></a>
<li><code>SubAlgebraModule( </code><var>M</var><code>, </code><var>gens</var><code> [, </code><var>"basis"</var><code>] ) O</code>
<p>
is the sub-module of the algebra module <var>M</var>, generated by the vectors
in <var>gens</var>. If as an optional argument the string <code>basis</code> is added, then
it is
assumed that the vectors in <var>gens</var> form a basis of the submodule.
<p>
<pre>
gap&gt; m1:= NullMat( 2, 2 );; m1[1][1]:= 1;;
gap&gt; m2:= NullMat( 2, 2 );; m2[2][2]:= 1;;
gap&gt; A:= Algebra( Rationals, [ m1, m2 ] );;
gap&gt; M:= LeftAlgebraModuleByGenerators( A, \*, [ [ 1, 0 ], [ 0, 1 ] ] );
&lt;left-module over &lt;algebra over Rationals, with 2 generators&gt;&gt;
gap&gt; bb:= BasisVectors( Basis( M ) );
[ [ 1, 0 ], [ 0, 1 ] ]
gap&gt; V:= SubAlgebraModule( M, [ bb[1] ] );
&lt;left-module over &lt;algebra over Rationals, with 2 generators&gt;&gt;
gap&gt; Dimension( V );
1
</pre>
<p>
<a name = "SSEC010.17"></a>
<li><code>LeftModuleByHomomorphismToMatAlg( </code><var>A</var><code>, </code><var>hom</var><code> ) O</code>
<p>
Here <var>A</var> is an algebra and <var>hom</var> a homomorphism from <var>A</var> into a matrix
algebra. This function returns the left <var>A</var>-module defined by the
homomorphism <var>hom</var>.
<p>
<a name = "SSEC010.18"></a>
<li><code>RightModuleByHomomorphismToMatAlg( </code><var>A</var><code>, </code><var>hom</var><code> ) O</code>
<p>
Here <var>A</var> is an algebra and <var>hom</var> a homomorphism from <var>A</var> into a matrix
algebra. This function returns the right <var>A</var>-module defined by the
homomorphism <var>hom</var>.
<p>
First we produce a structure constants algebra with basis elements
<i>x</i>, <i>y</i>, <i>z</i> such that <i>x</i><sup>2</sup> = <i>x</i>, <i>y</i><sup>2</sup> = <i>y</i>, <i>xz</i> = <i>z</i>, <i>zy</i> = <i>z</i>
and all other products are zero.
<p>
<pre>
gap&gt; T:= EmptySCTable( 3, 0 );;
gap&gt; SetEntrySCTable( T, 1, 1, [ 1, 1 ]);
gap&gt; SetEntrySCTable( T, 2, 2, [ 1, 2 ]);
gap&gt; SetEntrySCTable( T, 1, 3, [ 1, 3 ]);
gap&gt; SetEntrySCTable( T, 3, 2, [ 1, 3 ]);
gap&gt; A:= AlgebraByStructureConstants( Rationals, T );
&lt;algebra of dimension 3 over Rationals&gt;
</pre>
<p>
Now we construct an isomorphic matrix algebra.
<p>
<pre>
gap&gt; m1:= NullMat( 2, 2 );; m1[1][1]:= 1;;
gap&gt; m2:= NullMat( 2, 2 );; m2[2][2]:= 1;;
gap&gt; m3:= NullMat( 2, 2 );; m3[1][2]:= 1;;
gap&gt; B:= Algebra( Rationals, [ m1, m2, m3 ] );
&lt;algebra over Rationals, with 3 generators&gt;
</pre>
<p>
Finally we construct the homomorphism and the corresponding right module.
<p>
<pre>
gap&gt; f:= AlgebraHomomorphismByImages( A, B, Basis(A), [ m1, m2, m3 ] );;
gap&gt; RightModuleByHomomorphismToMatAlg( A, f );
&lt;right-module over &lt;algebra of dimension 3 over Rationals&gt;&gt;
</pre>
<p>
<a name = "SSEC010.19"></a>
<li><code>AdjointModule( </code><var>A</var><code> ) A</code>
<p>
returns the <var>A</var>-module defined by the left action of <var>A</var> on itself.
<p>
<pre>
gap&gt; m1:= NullMat( 2, 2 );; m1[1][1]:= 1;;
gap&gt; m2:= NullMat( 2, 2 );; m2[2][2]:= 1;;
gap&gt; m3:= NullMat( 2, 2 );; m3[1][2]:= 1;;
gap&gt; A:= Algebra( Rationals, [ m1, m2, m3 ] );
&lt;algebra over Rationals, with 3 generators&gt;
gap&gt; V:= AdjointModule( A );
&lt;3-dimensional left-module over &lt;algebra of dimension 3 over Rationals&gt;&gt;
gap&gt; v:= Basis( V )[3];
[ [ 0, 1 ], [ 0, 0 ] ]
gap&gt; W:= SubAlgebraModule( V, [ v ] );
&lt;left-module over &lt;algebra of dimension 3 over Rationals&gt;&gt;
gap&gt; Dimension( W );
1
</pre>
<p>
<a name = "SSEC010.20"></a>
<li><code>FaithfulModule( </code><var>A</var><code> ) A</code>
<p>
returns a faithful finite-dimensional left-module over the algebra <var>A</var>.
This is only implemented for associative algebras, and for Lie algebras
of characteristic 0. (It may also work for certain Lie algebras
of characteristic <i>p</i> &gt; 0.)
<p>
<pre>
gap&gt; T:= EmptySCTable( 2, 0 );;
gap&gt; A:= AlgebraByStructureConstants( Rationals, T );
&lt;algebra of dimension 2 over Rationals&gt;
</pre>
<p>
<code>A</code> is a 2-dimensional algebra where all products are zero.
<p>
<pre>
gap&gt; V:= FaithfulModule( A );
&lt;left-module over &lt;algebra of dimension 2 over Rationals&gt;&gt;
gap&gt; vv:= BasisVectors( Basis( V ) );
[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ]
gap&gt; xx:= BasisVectors( Basis( A ) );
[ v.1, v.2 ]
gap&gt; xx[1]^vv[3];
[ 1, 0, 0 ]
</pre>
<p>
<a name = "SSEC010.21"></a>
<li><code>ModuleByRestriction( </code><var>V</var><code>, </code><var>sub</var><code> ) O</code>
<li><code>ModuleByRestriction( </code><var>V</var><code>, </code><var>subl</var><code>, </code><var>subr</var><code> ) O</code>
<p>
Here <var>V</var> is an algebra module and <var>sub</var> is a subalgebra
of the acting algebra of <var>V</var>. This function returns the
module that is the restriction of <var>V</var> to <var>sub</var>. So it has the
same underlying vector space as <var>V</var>, but the acting algebra is
<var>sub</var>.  If two subalgebras are given then <var>V</var> is assumed to be a
bi-module, and <var>subl</var> a subalgebra of the algebra acting on the left,
and <var>subr</var> a subalgebra of the algebra acting on the right.
<p>
<pre>
gap&gt; A:= Rationals^[3,3];;
gap&gt; V:= LeftAlgebraModuleByGenerators( A, \*, [ [ 1, 0, 0 ] ] );;
gap&gt; B:= Subalgebra( A, [ Basis(A)[1] ] );
&lt;algebra over Rationals, with 1 generators&gt;
gap&gt; W:= ModuleByRestriction( V, B );
&lt;left-module over &lt;algebra over Rationals, with 1 generators&gt;&gt;
</pre>
<p>
<a name = "SSEC010.22"></a>
<li><code>NaturalHomomorphismBySubAlgebraModule( </code><var>V</var><code>, </code><var>W</var><code> ) O</code>
<p>
Here <var>V</var> must be a sub-algebra module of <var>V</var>. This function returns
the projection from <var>V</var> onto <code></code><var>V</var><code>/</code><var>W</var><code></code>. It is a linear map, that is
also a module homomorphism. As usual images can be formed with
<code>Image( f, v )</code> and pre-images with <code>PreImagesRepresentative( f, u )</code>.
<p>
The quotient module can also be formed
by entering <code></code><var>V</var><code>/</code><var>W</var><code></code>.
<p>
<pre>
gap&gt; A:= Rationals^[3,3];;
gap&gt; B:= DirectSumOfAlgebras( A, A );
&lt;algebra over Rationals, with 6 generators&gt;
gap&gt; T:= StructureConstantsTable( Basis( B ) );;
gap&gt; C:= AlgebraByStructureConstants( Rationals, T );
&lt;algebra of dimension 18 over Rationals&gt;
gap&gt; V:= AdjointModule( C );
&lt;left-module over &lt;algebra of dimension 18 over Rationals&gt;&gt;
gap&gt; W:= SubAlgebraModule( V, [ Basis(V)[1] ] );
&lt;left-module over &lt;algebra of dimension 18 over Rationals&gt;&gt;
gap&gt; f:= NaturalHomomorphismBySubAlgebraModule( V, W );
&lt;linear mapping by matrix, &lt;
18-dimensional left-module over &lt;algebra of dimension 18 over Rationals&gt;&gt; -&gt; &lt;
9-dimensional left-module over &lt;algebra of dimension 18 over Rationals&gt;&gt;&gt;
gap&gt; quo:= ImagesSource( f );  # i.e., the quotient module
&lt;9-dimensional left-module over &lt;algebra of dimension 18 over Rationals&gt;&gt;
gap&gt; v:= Basis( quo )[1];
[ 1, 0, 0, 0, 0, 0, 0, 0, 0 ]
gap&gt; PreImagesRepresentative( f, v );
v.4
gap&gt; Basis( C )[4]^v;
[ 1, 0, 0, 0, 0, 0, 0, 0, 0 ]
</pre>
<p>
<a name = "SSEC010.23"></a>
<li><code>DirectSumOfAlgebraModules( </code><var>list</var><code> ) O</code>
<li><code>DirectSumOfAlgebraModules( </code><var>V</var><code>, </code><var>W</var><code> ) O</code>
<p>
Here <var>list</var> must be a list of algebra modules. This function returns the
direct sum of the elements in the list (as an algebra module).
The modules must be defined over the same algebras.
<p>
In the second form is short for <code>DirectSumOfAlgebraModules( [ </code><var>V</var><code>, </code><var>W</var><code> ] )</code>
<p>
<pre>
gap&gt; A:= FullMatrixAlgebra( Rationals, 3 );;
gap&gt; V:= BiAlgebraModuleByGenerators( A, A, \*, \*, [ [1,0,0] ] );;
gap&gt; W:= DirectSumOfAlgebraModules( V, V );
&lt;6-dimensional left-module over ( Rationals^[ 3, 3 ] )&gt;
gap&gt; BasisVectors( Basis( W ) );
[ ( [ 1, 0, 0 ] )(+)( [ 0, 0, 0 ] ), ( [ 0, 1, 0 ] )(+)( [ 0, 0, 0 ] ), 
  ( [ 0, 0, 1 ] )(+)( [ 0, 0, 0 ] ), ( [ 0, 0, 0 ] )(+)( [ 1, 0, 0 ] ), 
  ( [ 0, 0, 0 ] )(+)( [ 0, 1, 0 ] ), ( [ 0, 0, 0 ] )(+)( [ 0, 0, 1 ] ) ]
</pre>
<p>
<a name = "SSEC010.24"></a>
<li><code>TranslatorSubalgebra( </code><var>M</var><code>, </code><var>U</var><code>, </code><var>W</var><code> ) O</code>
<p>
 Here <var>M</var> is an algebra module, and <var>U</var> and <var>W</var> are two subspaces of <var>M</var>. 
 Let <var>A</var> be the algebra acting on <var>M</var>. This function returns the subspace
 of elements of <var>A</var> that map <var>U</var> into <var>W</var>. If <var>W</var> is a sub-algebra-module
 (i.e., closed under the action of <var>A</var>), then this space is a subalgebra
 of <var>A</var>. 
<p>
 This function works for left, or right modules over a
 finite-dimensional algebra. We
 stress that it is not checked whether <var>U</var> and <var>W</var> are indeed subspaces
 of <var>M</var>. If this is not the case nothing is guaranteed about the behaviour
 of the function.
<p>
<pre>
gap&gt; A:= FullMatrixAlgebra( Rationals, 3 );
( Rationals^[ 3, 3 ] )
gap&gt; V:= Rationals^[3,2];
( Rationals^[ 3, 2 ] )
gap&gt; M:= LeftAlgebraModule( A, \*, V );
&lt;left-module over ( Rationals^[ 3, 3 ] )&gt;
gap&gt; bm:= Basis(M);;
gap&gt; U:= SubAlgebraModule( M, [ bm[1] ] );   
&lt;left-module over ( Rationals^[ 3, 3 ] )&gt;
gap&gt; TranslatorSubalgebra( M, U, M );
&lt;algebra of dimension 9 over Rationals&gt;
gap&gt; W:= SubAlgebraModule( M, [ bm[4] ] );
&lt;left-module over ( Rationals^[ 3, 3 ] )&gt;
gap&gt; T:=TranslatorSubalgebra( M, U, W );
&lt;algebra of dimension 0 over Rationals&gt;
</pre>
<p>
<p>
[<a href="../index.htm">Top</a>] [<a href = "chapters.htm">Up</a>] [<a href ="CHAP059.htm">Previous</a>] [<a href ="CHAP061.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<P>
<font face="Gill Sans,Helvetica,Arial">GAP 4 manual<br>August 2005
</font></body></html>