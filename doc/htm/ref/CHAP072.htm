<html><head><title>[ref] 72 Monomiality Questions</title></head>
<body text="#000000" bgcolor="#ffffff">
[<a href="../index.htm">Top</a>] [<a href = "chapters.htm">Up</a>] [<a href ="CHAP071.htm">Previous</a>] [<a href ="CHAP073.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<h1>72 Monomiality Questions</h1><p>
<P>
<H3>Sections</H3>
<oL>
<li> <A HREF="CHAP072.htm#SECT001">Character Degrees and Derived Length</a>
<li> <A HREF="CHAP072.htm#SECT002">Primitivity of Characters</a>
<li> <A HREF="CHAP072.htm#SECT003">Testing Monomiality</a>
<li> <A HREF="CHAP072.htm#SECT004">Minimal Nonmonomial Groups</a>
</ol><p>
<p>
This chapter describes functions dealing with the monomiality
of finite (solvable) groups and their characters.
<p>
All these functions assume <strong>characters</strong> to be class function objects
as described in Chapter&nbsp;<a href="CHAP070.htm">Class Functions</a>,
lists of character <strong>values</strong> are not allowed.
<p>
The usual <strong>property tests</strong> of <font face="Gill Sans,Helvetica,Arial">GAP</font> that return either <code>true</code>
or <code>false</code> are not sufficient for us.
When we ask whether a group character &#967; has a certain property,
such as quasiprimitivity,
we usually want more information than just yes or no.
Often we are interested in the reason <strong>why</strong> a group character &#967; was
proved to have a certain property,
e.g., whether monomiality of &#967; was proved by the observation
that the underlying group is nilpotent,
or whether it was necessary to construct a linear character of a subgroup
from which &#967; can be induced.
In the latter case we also may be interested in this linear character.
Therefore we need test functions that return a record containing such
useful information.
For example, the record returned by the function <code>TestQuasiPrimitive</code>
(see&nbsp;<a href="CHAP072.htm#SSEC002.3">TestQuasiPrimitive</a>) contains the component <code>isQuasiPrimitive</code>
(which is the known boolean property flag),
and additionally the component <code>comment</code>,
a string telling the reason for the value of the <code>isQuasiPrimitive</code>
component,
and in the case that the argument &#967; was <strong>not</strong> quasiprimitive
also the component <code>character</code>,
which is an irreducible constituent of a nonhomogeneous restriction
of &#967; to a normal subgroup.
Besides these test functions there are also the known properties,
e.g., the property <code>IsQuasiPrimitive</code> which will call the attribute
<code>TestQuasiPrimitive</code>,
and return the value of the <code>isQuasiPrimitive</code> component of the result.
<p>
A few words about how to use the monomiality functions seem to be
necessary.
Monomiality questions usually involve computations in many subgroups
and factor groups of a given group,
and for these groups often expensive calculations such as that of
the character table are necessary.
So one should be careful not to construct the same group over and over
again, instead the same group object should be reused,
such that its character table need to be computed only once.
For example,
suppose you want to restrict a character to a normal subgroup
<i>N</i> that was constructed as a normal closure of some group elements,
and suppose that you have already computed with normal subgroups
(by calls to <code>NormalSubgroups</code> or <code>MaximalNormalSubgroups</code>)
and their character tables.
Then you should look in the lists of known normal subgroups
whether <i>N</i> is contained,
and if so you can use the known character table.
A mechanism that supports this for normal subgroups is described in
<a href="CHAP069.htm#SECT021">Storing Normal Subgroup Information</a>.
<p>
Also the following hint may be useful in this context.
If you know that sooner or later you will compute the character table of
a group <i>G</i> then it may be advisable to compute it as soon as possible.
For example, if you need the normal subgroups of <i>G</i> then they can be
computed more efficiently if the character table of <i>G</i> is known,
and they can be stored compatibly to the contained <i>G</i>-conjugacy classes.
This correspondence of classes list and normal subgroup can be used very
often.
<p>
Several <strong>examples</strong> in this chapter use the symmetric group <i>S</i><sub>4</sub> and the
special linear group <i>SL</i>(2,3).
For running the examples, you must first define the groups,
for example as follows.
<p>
<pre>
gap&gt; S4:= SymmetricGroup( 4 );;  SetName( S4, "S4" );
gap&gt; Sl23:= SL( 2, 3 );;
</pre>
<p>
<a name = ""></a>
<li><code>InfoMonomial V</code>
<p>
Most of the functions described in this chapter print some
(hopefully useful) <strong>information</strong> if the info level of the info class
<code>InfoMonomial</code> is at least 1 (see&nbsp;<a href="CHAP007.htm#SECT004">Info Functions</a> for details).
<p>
<p>
<h2><a name="SECT001">72.1 Character Degrees and Derived Length</a></h2>
<p><p>
<a name = "SSEC001.1"></a>
<li><code>Alpha( </code><var>G</var><code> ) A</code>
<p>
For a group <var>G</var>, <code>Alpha</code> returns a list whose <var>i</var>-th entry is the maximal
derived length of groups <i>G</i>  / ker(&#967;) for &#967; &#8712; <i>Irr</i>(<i>G</i> ) with
&#967;(1) at most the <var>i</var>-th irreducible degree of <var>G</var>.
<p>
<a name = "SSEC001.2"></a>
<li><code>Delta( </code><var>G</var><code> ) A</code>
<p>
For a group <var>G</var>, <code>Delta</code> returns the list
<code>[ 1, alp[2] - alp[1], ..., alp[</code><var>n</var><code>] - alp[</code><var>n</var><code>-1] ]</code>,
where <code>alp = Alpha( </code><var>G</var><code> )</code> (see&nbsp;<a href="CHAP072.htm#SSEC001.1">Alpha</a>).
<p>
<a name = "SSEC001.3"></a>
<li><code>IsBergerCondition( </code><var>G</var><code> ) P</code>
<li><code>IsBergerCondition( </code><var>chi</var><code> ) P</code>
<p>
Called with an irreducible character <var>chi</var> of the group <i>G</i>,
<code>IsBergerCondition</code> returns <code>true</code> if <var>chi</var> satisfies
<i>M</i><sup>&#8242;</sup>  &#8804; ker(&#967;) for every normal subgroup <i>M</i> of <i>G</i>
with the property that <i>M</i>  &#8804; ker(&#968;) for all &#968; &#8712; <i>Irr</i>(<i>G</i>) with
&#968;(1)  &lt;  &#967;(1),
and <code>false</code> otherwise.
<p>
Called with a group <var>G</var>, <code>IsBergerCondition</code> returns <code>true</code> if
all irreducible characters of <var>G</var> satisfy the inequality above,
and <code>false</code> otherwise.
<p>
For groups of odd order the result is always <code>true</code> by a theorem of
T.&nbsp;R.&nbsp;Berger (see&nbsp;<a href="biblio.htm#Ber76"><cite>Ber76</cite></a>, Thm.&nbsp;2.2).
<p>
In the case that <code>false</code> is returned <code>InfoMonomial</code> tells about a
degree for which the inequality is violated.
<p>
<pre>
gap&gt; Alpha( Sl23 );
[ 1, 3, 3 ]
gap&gt; Alpha( S4 );
[ 1, 2, 3 ]
gap&gt; Delta( Sl23 );
[ 1, 2, 0 ]
gap&gt; Delta( S4 );
[ 1, 1, 1 ]
gap&gt; IsBergerCondition( S4 );
true
gap&gt; IsBergerCondition( Sl23 );
false
gap&gt; List( Irr( Sl23 ), IsBergerCondition );
[ true, true, true, false, false, false, true ]
gap&gt; List( Irr( Sl23 ), Degree );
[ 1, 1, 1, 2, 2, 2, 3 ]
</pre>
<p>
<p>
<h2><a name="SECT002">72.2 Primitivity of Characters</a></h2>
<p><p>
<a name = "SSEC002.1"></a>
<li><code>TestHomogeneous( </code><var>chi</var><code>, </code><var>N</var><code> ) F</code>
<p>
For a group character <var>chi</var> of the group <i>G</i>, say, and a normal subgroup
<var>N</var> of <i>G</i>,
<code>TestHomogeneous</code> returns a record with information whether the
restriction of <var>chi</var> to <var>N</var> is homogeneous,
i.e., is a multiple of an irreducible character.
<p>
<var>N</var> may be given also as list of conjugacy class positions w.r.t.&nbsp;the
character table of <i>G</i>.
<p>
The components of the result are
<p>
<p>
<dl compact>
<dt><code>isHomogeneous</code> <dd> <code>true</code> or <code>false</code>,
<p>
<dt><code>comment</code> <dd> a string telling a reason for the value of the
                     <code>isHomogeneous</code> component,
<p>
<dt><code>character</code> <dd> irreducible constituent of the restriction, only
                     bound if the restriction had to be checked,
<p>
<dt><code>multiplicity</code> <dd> multiplicity of the <code>character</code> component in the
                     restriction of <var>chi</var>.
</dl>
<p>
<pre>
gap&gt; n:= DerivedSubgroup( Sl23 );;
gap&gt; chi:= Irr( Sl23 )[7];
Character( CharacterTable( SL(2,3) ), [ 3, 3, 0, 0, 0, 0, -1 ] )
gap&gt; TestHomogeneous( chi, n );
rec( isHomogeneous := false, comment := "restriction checked", 
  character := Character( CharacterTable( Group(
    [ [ [ 0*Z(3), Z(3) ], [ Z(3)^0, 0*Z(3) ] ], 
      [ [ Z(3), 0*Z(3) ], [ 0*Z(3), Z(3) ] ], 
      [ [ Z(3), Z(3)^0 ], [ Z(3)^0, Z(3)^0 ] ] ]) ), [ 1, -1, 1, -1, 1 ] ), 
  multiplicity := 1 )
gap&gt; chi:= Irr( Sl23 )[4];
Character( CharacterTable( SL(2,3) ), [ 2, -2, 1, 1, -1, -1, 0 ] )
gap&gt; cln:= ClassPositionsOfNormalSubgroup( CharacterTable( Sl23 ), n );
[ 1, 2, 7 ]
gap&gt; TestHomogeneous( chi, cln );
rec( isHomogeneous := true, comment := "restricts irreducibly" )
</pre>
<p>
<a name = "SSEC002.2"></a>
<li><code>IsPrimitiveCharacter( </code><var>chi</var><code> ) P</code>
<p>
For a character <var>chi</var> of the group <i>G</i>, say,
<code>IsPrimitiveCharacter</code> returns <code>true</code> if <var>chi</var> is not induced from any
proper subgroup, and <code>false</code> otherwise.
<p>
<pre>
gap&gt; IsPrimitive( Irr( Sl23 )[4] );
true
gap&gt; IsPrimitive( Irr( Sl23 )[7] );
false
</pre>
<p>
<a name = "SSEC002.3"></a>
<li><code>TestQuasiPrimitive( </code><var>chi</var><code> ) A</code>
<a name = "SSEC002.3"></a>
<li><code>IsQuasiPrimitive( </code><var>chi</var><code> ) P</code>
<p>
<code>TestQuasiPrimitive</code> returns a record with information about
quasiprimitivity of the group character <var>chi</var>,
i.e., whether <var>chi</var> restricts homogeneously to every normal subgroup
of its group.
The result record contains at least the components
<code>isQuasiPrimitive</code> (with value either <code>true</code> or <code>false</code>) and
<code>comment</code> (a string telling a reason for the value of the component
<code>isQuasiPrimitive</code>).
If <var>chi</var> is not quasiprimitive then there is additionally a component
<code>character</code>, with value an irreducible constituent of a nonhomogeneous
restriction of <var>chi</var>.
<p>
<code>IsQuasiPrimitive</code> returns <code>true</code> or <code>false</code>,
depending on whether the character <var>chi</var> is quasiprimitive.
<p>
Note that for solvable groups, quasiprimitivity is the same as
primitivity (see&nbsp;<a href="CHAP072.htm#SSEC002.2">IsPrimitiveCharacter</a>).
<p>
<pre>
gap&gt; chi:= Irr( Sl23 )[4];
Character( CharacterTable( SL(2,3) ), [ 2, -2, 1, 1, -1, -1, 0 ] )
gap&gt; TestQuasiPrimitive( chi );
rec( isQuasiPrimitive := true, comment := "all restrictions checked" )
gap&gt; chi:= Irr( Sl23 )[7];
Character( CharacterTable( SL(2,3) ), [ 3, 3, 0, 0, 0, 0, -1 ] )
gap&gt; TestQuasiPrimitive( chi );
rec( isQuasiPrimitive := false, comment := "restriction checked", 
  character := Character( CharacterTable( Group(
    [ [ [ 0*Z(3), Z(3) ], [ Z(3)^0, 0*Z(3) ] ], 
      [ [ Z(3), 0*Z(3) ], [ 0*Z(3), Z(3) ] ], 
      [ [ Z(3), Z(3)^0 ], [ Z(3)^0, Z(3)^0 ] ] ]) ), [ 1, -1, 1, -1, 1 ] ) )
</pre>
<p>
<a name = "SSEC002.4"></a>
<li><code>TestInducedFromNormalSubgroup( </code><var>chi</var><code>[, </code><var>N</var><code>] ) F</code>
<a name = "SSEC002.4"></a>
<li><code>IsInducedFromNormalSubgroup( </code><var>chi</var><code> ) P</code>
<p>
<code>TestInducedFromNormalSubgroup</code> returns a record with information
whether the irreducible character <var>chi</var> of the group <i>G</i>, say,
is induced from a proper normal subgroup of <i>G</i>.
If the second argument <var>N</var> is present, which must be a normal subgroup of
<i>G</i> or the list of class positions of a normal subgroup of <i>G</i>,
it is checked whether <var>chi</var> is induced from <var>N</var>.
<p>
The result contains always the components
<code>isInduced</code> (either <code>true</code> or <code>false</code>) and
<code>comment</code> (a string telling a reason for the value of the component
<code>isInduced</code>).
In the <code>true</code> case there is a  component <code>character</code> which
contains a character of a maximal normal subgroup from which <var>chi</var> is
induced.
<p>
<code>IsInducedFromNormalSubgroup</code> returns <code>true</code> if <var>chi</var> is induced from a
proper normal subgroup of <i>G</i>, and <code>false</code> otherwise.
<p>
<pre>
gap&gt; List( Irr( Sl23 ), IsInducedFromNormalSubgroup );
[ false, false, false, false, false, false, true ]
gap&gt; List( Irr( S4 ){ [ 1, 3, 4 ] },
&gt;          TestInducedFromNormalSubgroup );
[ rec( isInduced := false, comment := "linear character" ), 
  rec( isInduced := true, comment := "induced from component '.character'", 
      character := Character( CharacterTable( Alt( [ 1 .. 4 ] ) ), 
        [ 1, 1, E(3)^2, E(3) ] ) ), 
  rec( isInduced := false, comment := "all maximal normal subgroups checked" 
     ) ]
</pre>
<p>
<p>
<h2><a name="SECT003">72.3 Testing Monomiality</a></h2>
<p><p>
A character &#967; of a finite group <i>G</i> is called <strong>monomial</strong> if &#967;
is induced from a linear character of a subgroup of <i>G</i>.
A finite group <i>G</i> is called <strong>monomial</strong> (or <strong><i>M</i>-group</strong>) if each
ordinary irreducible character of <i>G</i> is monomial.
<p>
There are <font face="Gill Sans,Helvetica,Arial">GAP</font> properties <code>IsMonomialGroup</code> (see&nbsp;<a href="CHAP037.htm#SSEC015.9">IsMonomialGroup</a>)
and <code>IsMonomialCharacter</code>, but one can use <code>IsMonomial</code> instead.
<a name = "I0"></a>

<a name = "I0"></a>
<a name = "I1"></a>

<p>
<a name = "SSEC003.1"></a>
<li><code>TestMonomial( </code><var>chi</var><code> ) A</code>
<li><code>TestMonomial( </code><var>G</var><code> ) A</code>
<li><code>TestMonomial( </code><var>chi</var><code>, </code><var>uselattice</var><code> ) O</code>
<li><code>TestMonomial( </code><var>G</var><code>, </code><var>uselattice</var><code> ) O</code>
<p>
Called with a group character <var>chi</var> of a group <var>G</var>, <code>TestMonomial</code>
returns a record containing information about monomiality of the group
<var>G</var> or the group character <var>chi</var>, respectively.
<p>
If <code>TestMonomial</code> proves the character <var>chi</var> to be monomial then
the result contains components <code>isMonomial</code> (with value <code>true</code>),
<code>comment</code> (a string telling a reason for monomiality),
and if it was necessary to compute a linear character from which <var>chi</var> is
induced, also a component <code>character</code>.
<p>
If <code>TestMonomial</code> proves <var>chi</var> or <var>G</var> to be nonmonomial then the value of
the component <code>isMonomial</code> is <code>false</code>,
and in the case of <var>G</var> a nonmonomial character is the value
of the component <code>character</code> if it had been necessary to compute it.
<p>
A Boolean can be entered as the second argument <var>uselattice</var>;
if the value is <code>true</code> then the subgroup lattice of the underlying group
is used if necessary,
if the value is <code>false</code> then the subgroup lattice is used only for groups
of order at most <code>TestMonomialUseLattice</code> (see&nbsp;<a href="CHAP072.htm#SSEC003.2">TestMonomialUseLattice</a>).
The default value of <var>uselattice</var> is <code>false</code>.
<p>
For a group whose lattice must not be used, it may happen that 
<code>TestMonomial</code> cannot prove or disprove monomiality; then the result
record contains the component <code>isMonomial</code> with value <code>"?"</code>.
This case occurs in the call for a character <var>chi</var> if and only if
<var>chi</var> is not induced from the inertia subgroup of a component of any
reducible restriction to a normal subgroup.
It can happen that <var>chi</var> is monomial in this situation.
For a group, this case occurs if no irreducible character can be proved
to be nonmonomial, and if no decision is possible for at least one
irreducible character.
<p>
<pre>
gap&gt; TestMonomial( S4 );
rec( isMonomial := true, comment := "abelian by supersolvable group" )
gap&gt; TestMonomial( Sl23 );
rec( isMonomial := false, comment := "list Delta( G ) contains entry &gt; 1" )
</pre>
<p>
<a name = "SSEC003.2"></a>
<li><code>TestMonomialUseLattice V</code>
<p>
This global variable controls for which groups the operation
<code>TestMonomial</code> (see&nbsp;<a href="CHAP072.htm#SSEC003.1">TestMonomial</a>) may compute the subgroup lattice.
The value can be set to a positive integer or <code>infinity</code>,
the default is 1000.
<p>
<a name = "SSEC003.3"></a>
<li><code>IsMonomialNumber( </code><var>n</var><code> ) P</code>
<p>
For a positive integer <var>n</var>, <code>IsMonomialNumber</code> returns <code>true</code> if every
solvable group of order <var>n</var> is monomial, and <code>false</code> otherwise.
One can also use <code>IsMonomial</code> instead.
<a name = "I2"></a>

<p>
Let &#957;<sub><i>p</i></sub>(<i>n</i>) denote the multiplicity of the prime <i>p</i> as
factor of <i>n</i>, and <i>ord</i>(<i>p</i>,<i>q</i>) the multiplicative order of <i>p</i>  mod <i>q</i>.
<p>
Then there exists a solvable nonmonomial group of order <i>n</i>
if and only if one of the following conditions is satisfied.
<p>
<dl compact>
<dt>1.<dd>
     &#957;<sub>2</sub>(<i>n</i>)  &#8805; 2 and there is a <i>p</i> such that
     &#957;<sub><i>p</i></sub>(<i>n</i>)  &#8805; 3 and <i>p</i>  &#8801; &#8722;1  mod 4,
<p>
<dt>2.<dd>
     &#957;<sub>2</sub>(<i>n</i>)  &#8805; 3 and there is a <i>p</i> such that
     &#957;<sub><i>p</i></sub>(<i>n</i>)  &#8805; 3 and <i>p</i>  &#8801; 1  mod 4,
<p>
<dt>3.<dd>
     there are odd prime divisors <i>p</i> and <i>q</i> of <i>n</i> such that
     <i>ord</i>(<i>p</i>,<i>q</i>) is even and <i>ord</i>(<i>p</i>,<i>q</i>)  &lt;  &#957;<sub><i>p</i></sub>(<i>n</i>)
     (especially &#957;<sub><i>p</i></sub>(<i>n</i>)  &#8805; 3),
<p>
<dt>4.<dd>
     there is a prime divisor <i>q</i> of <i>n</i> such that
     &#957;<sub>2</sub>(<i>n</i>)  &#8805; 2 <i>ord</i>(2,<i>q</i>) + 2
     (especially &#957;<sub>2</sub>(<i>n</i>)  &#8805; 4),
<p>
<dt>5.<dd>
     &#957;<sub>2</sub>(<i>n</i>)  &#8805; 2 and there is a <i>p</i> such that
     <i>p</i>  &#8801; 1  mod 4, <i>ord</i>(<i>p</i>,<i>q</i>) is odd,
     and 2 <i>ord</i>(<i>p</i>,<i>q</i>)  &lt;  &#957;<sub><i>p</i></sub>(<i>n</i>)
     (especially &#957;<sub><i>p</i></sub>(<i>n</i>)  &#8805; 3).
</dl>
<p>
These five possibilities correspond to the five types of solvable minimal
nonmonomial groups (see&nbsp;<a href="CHAP072.htm#SSEC004.2">MinimalNonmonomialGroup</a>) that can occur as
subgroups and factor groups of groups of order <var>n</var>.
<p>
<pre>
gap&gt; Filtered( [ 1 .. 111 ], x -&gt; not IsMonomial( x ) );
[ 24, 48, 72, 96, 108 ]
</pre>
<p>
<a name = "SSEC003.4"></a>
<li><code>TestMonomialQuick( </code><var>chi</var><code> ) A</code>
<li><code>TestMonomialQuick( </code><var>G</var><code> ) A</code>
<p>
<code>TestMonomialQuick</code> does some cheap tests whether the irreducible
character <var>chi</var> resp.&nbsp;the group <var>G</var> is monomial.
Here ``cheap'' means in particular that no computations of character
tables are involved.
The return value is a record with components
<p>
<dl compact>
<dt><code>isMonomial</code> <dd> either <code>true</code> or <code>false</code> or the string <code>"?"</code>,
     depending on whether (non)monomiality could be proved, and
<p>
<dt><code>comment</code> <dd> a string telling the reason for the value of the
     <code>isMonomial</code> component.
</dl>
<p>
A group <var>G</var> is proved to be monomial by <code>TestMonomialQuick</code> if
<var>G</var> is nilpotent or Sylow abelian by supersolvable,
or if <var>G</var> is solvable and its order is not divisible by the third power
of a prime,
Nonsolvable groups are proved to be nonmonomial by <code>TestMonomialQuick</code>.
<p>
An irreducible character <var>chi</var> is proved to be monomial if
it is linear, or if its codegree is a prime power,
or if its group knows to be monomial,
or if the factor group modulo the kernel can be proved to be monomial by
<code>TestMonomialQuick</code>.
<p>
<pre>
gap&gt; TestMonomialQuick( Irr( S4 )[3] );
rec( isMonomial := true, comment := "whole group is monomial" )
gap&gt; TestMonomialQuick( S4 );
rec( isMonomial := true, comment := "abelian by supersolvable group" )
gap&gt; TestMonomialQuick( Sl23 );
rec( isMonomial := "?", comment := "no decision by cheap tests" )
</pre>
<p>
<a name = "SSEC003.5"></a>
<li><code>TestSubnormallyMonomial( </code><var>G</var><code> ) A</code>
<li><code>TestSubnormallyMonomial( </code><var>chi</var><code> ) A</code>
<a name = "SSEC003.5"></a>
<li><code>IsSubnormallyMonomial( </code><var>G</var><code> ) P</code>
<li><code>IsSubnormallyMonomial( </code><var>chi</var><code> ) P</code>
<p>
A character of the group <i>G</i> is called <strong>subnormally monomial</strong>
(SM for short) if it is induced from a linear character of a subnormal
subgroup of <i>G</i>.
A group <i>G</i> is called SM if all its irreducible characters are SM.
<p>
<code>TestSubnormallyMonomial</code> returns a record with information whether the
group <var>G</var> or the irreducible character <var>chi</var> of <var>G</var> is SM.
<p>
The result has components
<code>isSubnormallyMonomial</code> (either <code>true</code> or <code>false</code>) and
<code>comment</code> (a string telling a reason for the value of the component
<code>isSubnormallyMonomial</code>);
in the case that the <code>isSubnormallyMonomial</code> component has value <code>false</code>
there is also a component <code>character</code>,
with value an irreducible character of <i>G</i> that is not SM.
<p>
<code>IsSubnormallyMonomial</code> returns <code>true</code> if the group <var>G</var> or the
group character <var>chi</var> is subnormally monomial, and <code>false</code> otherwise.
<p>
<pre>
gap&gt; TestSubnormallyMonomial( S4 );
rec( isSubnormallyMonomial := false, 
  character := Character( CharacterTable( S4 ), [ 3, -1, -1, 0, 1 ] ), 
  comment := "found non-SM character" )
gap&gt; TestSubnormallyMonomial( Irr( S4 )[4] );
rec( isSubnormallyMonomial := false, 
  comment := "all subnormal subgroups checked" )
gap&gt; TestSubnormallyMonomial( DerivedSubgroup( S4 ) );
rec( isSubnormallyMonomial := true, comment := "all irreducibles checked" )
</pre>
<p>
<a name = "SSEC003.6"></a>
<li><code>TestRelativelySM( </code><var>G</var><code> ) A</code>
<li><code>TestRelativelySM( </code><var>chi</var><code> ) A</code>
<li><code>TestRelativelySM( </code><var>G</var><code>, </code><var>N</var><code> ) O</code>
<li><code>TestRelativelySM( </code><var>chi</var><code>, </code><var>N</var><code> ) O</code>
<a name = "SSEC003.6"></a>
<li><code>IsRelativelySM( </code><var>chi</var><code> ) P</code>
<li><code>IsRelativelySM( </code><var>G</var><code> ) P</code>
<p>
In the first two cases, <code>TestRelativelySM</code> returns a record with
information whether the argument, which must be a SM group <var>G</var> or
an irreducible character <var>chi</var> of a SM group <i>G</i>,
is relatively SM with respect to every normal subgroup of <var>G</var>.
<p>
In the second two cases, a normal subgroup <var>N</var> of <var>G</var> is the second
argument.
Here <code>TestRelativelySM</code> returns a record with information whether the
first argument is relatively SM with respect to <var>N</var>,
i.e, whether there is a subnormal subgroup <i>H</i> of <i>G</i> that contains <var>N</var>
such that the character <var>chi</var> resp.&nbsp;every irreducible character of <i>G</i>
is induced from a character &#968; of <i>H</i> such that the restriction of
&#968; to <var>N</var> is irreducible.
<p>
The result record has the components
<code>isRelativelySM</code> (with value either <code>true</code> or <code>false</code>) and
<code>comment</code> (a string that describes a reason).
If the argument is a group <var>G</var> that is not relatively SM with respect to
a normal subgroup then additionally the component <code>character</code> is bound,
with value a not relatively SM character of such a normal subgroup.
<p>
<code>IsRelativelySM</code> returns <code>true</code> if the SM group <var>G</var> or the irreducible
character <var>chi</var> of the SM group <var>G</var> is relatively SM with respect to
every normal subgroup of <var>G</var>, and <code>false</code> otherwise.
<p>
<strong>Note</strong> that it is <strong>not</strong> checked whether <var>G</var> is SM.
<p>
<pre>
gap&gt; IsSubnormallyMonomial( DerivedSubgroup( S4 ) );
true
gap&gt; TestRelativelySM( DerivedSubgroup( S4 ) );
rec( isRelativelySM := true, 
  comment := "normal subgroups are abelian or have nilpotent factor group" )
</pre>
<p>
<p>
<h2><a name="SECT004">72.4 Minimal Nonmonomial Groups</a></h2>
<p><p>
<a name = "SSEC004.1"></a>
<li><code>IsMinimalNonmonomial( </code><var>G</var><code> ) P</code>
<p>
A group <var>G</var> is called <strong>minimal nonmonomial</strong> if it is nonmonomial,
and all proper subgroups and factor groups are monomial.
<p>
<pre>
gap&gt; IsMinimalNonmonomial( Sl23 );  IsMinimalNonmonomial( S4 );
true
false
</pre>
<p>
<a name = "SSEC004.2"></a>
<li><code>MinimalNonmonomialGroup( </code><var>p</var><code>, </code><var>factsize</var><code> ) F</code>
<p>
is a solvable minimal nonmonomial group described by the parameters
<var>factsize</var> and <var>p</var> if such a group exists, and <code>false</code> otherwise.
<p>
Suppose that the required group <i>K</i> exists.
Then <var>factsize</var> is the size of the Fitting factor <i>K</i> / <i>F</i>(<i>K</i>),
and this value is 4, 8, an odd prime, twice an odd prime,
or four times an odd prime.
In the case that <var>factsize</var> is twice an odd prime, the centre <i>Z</i>(<i>K</i>) is
cyclic of order 2<sup><i>p</i> +1</sup>.
In all other cases <var>p</var> is the (unique) prime that divides
the order of <i>F</i>(<i>K</i>).
<p>
The solvable minimal nonmonomial groups were classified by van der Waall,
see&nbsp;<a href="biblio.htm#vdW76"><cite>vdW76</cite></a>.
<p>
<pre>
gap&gt; MinimalNonmonomialGroup(  2,  3 ); # the group SL(2,3)
2^(1+2):3
gap&gt; MinimalNonmonomialGroup(  3,  4 );
3^(1+2):4
gap&gt; MinimalNonmonomialGroup(  5,  8 );
5^(1+2):Q8
gap&gt; MinimalNonmonomialGroup( 13, 12 );
13^(1+2):2.D6
gap&gt; MinimalNonmonomialGroup(  1, 14 );
2^(1+6):D14
gap&gt; MinimalNonmonomialGroup(  2, 14 );
(2^(1+6)Y4):D14
</pre>
<p>
<p>
[<a href="../index.htm">Top</a>] [<a href = "chapters.htm">Up</a>] [<a href ="CHAP071.htm">Previous</a>] [<a href ="CHAP073.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<P>
<font face="Gill Sans,Helvetica,Arial">GAP 4 manual<br>May 2005
</font></body></html>