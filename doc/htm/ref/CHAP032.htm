<html><head><title>[ref] 32 Relations</title></head>
<body text="#000000" bgcolor="#ffffff">
[<a href="../index.htm">Top</a>] [<a href = "chapters.htm">Up</a>] [<a href ="CHAP031.htm">Previous</a>] [<a href ="CHAP033.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<h1>32 Relations</h1><p>
<P>
<H3>Sections</H3>
<oL>
<li> <A HREF="CHAP032.htm#SECT001">General Binary Relations</a>
<li> <A HREF="CHAP032.htm#SECT002">Properties and Attributes of Binary Relations</a>
<li> <A HREF="CHAP032.htm#SECT003">Binary Relations on Points</a>
<li> <A HREF="CHAP032.htm#SECT004">Closure Operations and Other Constructors</a>
<li> <A HREF="CHAP032.htm#SECT005">Equivalence Relations</a>
<li> <A HREF="CHAP032.htm#SECT006">Attributes of and Operations on Equivalence Relations</a>
<li> <A HREF="CHAP032.htm#SECT007">Equivalence Classes</a>
</ol><p>
<p>
<a name = "I0"></a>

<a name = "I1"></a>

<a name = "I2"></a>

A <strong>binary relation</strong> <var>R</var> on a set <var>X</var> is a subset of <i>X</i> &times;<i>X</i>. 
A binary relation can also be thought of as a (general) mapping
from <var>X</var> to itself or as a directed graph where each edge 
represents a tuple of <var>R</var>. 
<p>
In <font face="Gill Sans,Helvetica,Arial">GAP</font>, a relation is conceptually represented as  a  general  mapping
from <var>X</var> to itself. The category <code>IsBinaryRelation</code> is the  same  as  the
category <code>IsEndoGeneralMapping</code> (see&nbsp;<a href="CHAP031.htm#SSEC012.3">IsEndoGeneralMapping</a>).  Attributes
and properties of relations in <font face="Gill Sans,Helvetica,Arial">GAP</font> are supported  for  relations,  via
considering relations as a subset of <i>X</i>&times;<i>X</i>, or as a directed graph;
examples include finding the strongly connected components of a relation,
via <code>StronglyConnectedComponents</code> (see&nbsp;<a href="CHAP032.htm#SSEC004.5">StronglyConnectedComponents</a>), or
enumerating the tuples of the relation.
<p>
<p>
<h2><a name="SECT001">32.1 General Binary Relations</a></h2>
<p><p>
<a name = "SSEC001.1"></a>
<li><code>IsBinaryRelation( </code><var>R</var><code> ) C</code>
<p>
is   exactly   the   same   category   as   (i.e.    a    synonym    for)
<code>IsEndoGeneralMapping</code> (see&nbsp;<a href="CHAP031.htm#SSEC012.3">IsEndoGeneralMapping</a>).
<p>
We have the following general constructors.
<p>
<a name = "SSEC001.2"></a>
<li><code>BinaryRelationByElements( </code><var>domain</var><code>, </code><var>elms</var><code> ) F</code>
<p>
is  the  binary  relation  on  <var>domain</var>  and  with  underlying   relation
consisting of the tuples collection <var>elms</var>. This construction is  similar
to <code>GeneralMappingByElements</code> (see&nbsp;<a href="CHAP031.htm#SSEC001.1">GeneralMappingByElements</a>) where  the
source and range are the same set.
<p>
<a name = "SSEC001.3"></a>
<li><code>IdentityBinaryRelation( </code><var>degree</var><code> ) F</code>
<li><code>IdentityBinaryRelation( </code><var>domain</var><code> ) F</code>
<p>
is the binary relation which consists of diagonal tuples i.e.  tuples  of
the form (<i>x</i>,<i>x</i>). In the first form if a  positive  integer  <var>degree</var>  is
given then the domain is  the  integers  {1,...,<i>degree</i> }.  In  the
second form, the tuples are from the domain <var>domain</var>.
<p>
<a name = "SSEC001.4"></a>
<li><code>EmptyBinaryRelation( </code><var>degree</var><code> ) F</code>
<li><code>EmptyBinaryRelation( </code><var>domain</var><code> ) F</code>
<p>
is the relation with <var>R</var> empty. In the first form  of  the  command  with
<var>degree</var> an integer, the domain is the points {1,..., <i>degree</i> }. In
the second form, the domain is that given by the argument <var>domain</var>.
<p>
<p>
<h2><a name="SECT002">32.2 Properties and Attributes of Binary Relations</a></h2>
<p><p>
<a name = "SSEC002.1"></a>
<li><code>IsReflexiveBinaryRelation( </code><var>R</var><code> ) P</code>
<p>
returns <code>true</code> if the binary relation <var>R</var> is reflexive, and <code>false</code>
otherwise.
<p>
<a name = "I3"></a>

A binary relation <var>R</var> (as tuples) on a set <var>X</var> is <strong>reflexive</strong> if
for all <i>x</i> &#8712; <i>X</i>, (<i>x</i>,<i>x</i>) &#8712; <i>R</i>. Alternatively, <var>R</var> as a mapping
is reflexive if for all <i>x</i> &#8712; <i>X</i>, <i>x</i> is an element of the image set
<i>R</i>(<i>x</i>).   
<p>
A reflexive binary relation is necessarily a total endomorphic 
mapping (tested via <code>IsTotal</code>; see&nbsp;<a href="CHAP031.htm#SSEC002.1">IsTotal</a>).
<p>
<a name = "SSEC002.2"></a>
<li><code>IsSymmetricBinaryRelation( </code><var>R</var><code> ) P</code>
<p>
returns <code>true</code> if the binary relation <var>R</var> is symmetric, and <code>false</code>
otherwise.
<p>
<a name = "I4"></a>

A binary relation <var>R</var> (as tuples) on a set <var>X</var> is <strong>symmetric</strong> if
(<i>x</i>,<i>y</i>) &#8712; <i>R</i> then (<i>y</i>,<i>x</i>) &#8712; <i>R</i>. Alternatively, <var>R</var> as a mapping
is symmetric if for all <i>x</i> &#8712; <i>X</i>, the preimage set of <i>x</i> under <i>R</i> equals
the image set <i>R</i>(<i>x</i>).
<p>
<a name = "SSEC002.3"></a>
<li><code>IsTransitiveBinaryRelation( </code><var>R</var><code> ) P</code>
<p>
returns <code>true</code> if the binary relation <var>R</var> is transitive, and <code>false</code>
otherwise.
<p>
<a name = "I5"></a>

A binary relation <var>R</var> (as tuples) on a set <var>X</var> is <strong>transitive</strong> if
(<i>x</i>,<i>y</i>), (<i>y</i>,<i>z</i>) &#8712; <i>R</i> then (<i>x</i>,<i>z</i>) &#8712; <i>R</i>. Alternatively, <var>R</var> as a mapping
is transitive if for all <i>x</i> &#8712; <i>X</i>, the image set <i>R</i>(<i>R</i>(<i>x</i>)) of the image 
set <i>R</i>(<i>x</i>) of <i>x</i> is a subset of <i>R</i>(<i>x</i>).
<p>
<a name = "SSEC002.4"></a>
<li><code>IsAntisymmetricBinaryRelation( </code><var>rel</var><code> ) P</code>
<p>
returns <code>true</code> if the binary relation <var>rel</var> is antisymmetric, and <code>false</code>
otherwise.
<p>
<a name = "I6"></a>

A binary relation <var>R</var> (as tuples) on a set <var>X</var> is <strong>antisymmetric</strong> if
(<i>x</i>,<i>y</i>), (<i>y</i>,<i>x</i>) &#8712; <i>R</i> implies <i>x</i> = <i>y</i>. Alternatively, <var>R</var> as a mapping
is antisymmetric if for all <i>x</i> &#8712; <i>X</i>, the intersection of the
preimage set of <i>x</i> under <i>R</i> and
the image set <i>R</i>(<i>x</i>) is {<i>x</i>}.
<p>
<a name = "SSEC002.5"></a>
<li><code>IsPreOrderBinaryRelation( </code><var>rel</var><code> ) P</code>
<p>
returns <code>true</code> if the binary relation <var>rel</var> is a preorder, and <code>false</code>
otherwise.
<p>
<a name = "I7"></a>

A <strong>preorder</strong> is a binary relation that is both reflexive and transitive.
<p>
<a name = "SSEC002.6"></a>
<li><code>IsPartialOrderBinaryRelation( </code><var>rel</var><code> ) P</code>
<p>
returns <code>true</code> if the binary relation  <var>rel</var>  is  a  partial  order,  and
<code>false</code> otherwise.
<p>
<a name = "I8"></a>

A <strong>partial order</strong> is a preorder which is also antisymmetric.
<p>
<a name = "SSEC002.7"></a>
<li><code>IsHasseDiagram( </code><var>rel</var><code> ) P</code>
<p>
returns <code>true</code> if the binary relation <var>rel</var>  is  a  Hasse  Diagram  of  a
partial  order,  i.e.  was  computed   via   <code>HasseDiagramBinaryRelation</code>
(see&nbsp;<a href="CHAP032.htm#SSEC004.4">HasseDiagramBinaryRelation</a>).
<p>
<a name = "SSEC002.8"></a>
<li><code>IsEquivalenceRelation( </code><var>R</var><code> ) P</code>
<p>
returns <code>true</code> if the binary relation <var>R</var> is an equivalence relation, and
<code>false</code> otherwise.
<p>
<a name = "I9"></a>

Recall, that a relation <var>R</var> on the set <var>X</var> is an  <strong>equivalence  relation</strong>
if it is symmetric, transitive, and reflexive.
<p>
<a name = "SSEC002.9"></a>
<li><code>Successors( </code><var>R</var><code> ) A</code>
<p>
returns the list of images of a binary relation <var>R</var>.  If  the  underlying
domain of the relation is not <code>[1..</code><var>n</var><code>]</code> for some positive  integer  <var>n</var>,
then an error is signalled.
<p>
The returned value of <code>Successors</code> is a list of lists where the lists are
ordered as the elements according to the sorted order of  the  underlying
set of <var>R</var>. Each list consists of the images of the element  whose  index
is the same as the list with the underlying set in sorted order.
<p>
The <code>Successors</code> of a relation is the adjacency list representation
of the relation. 
<p>
<a name = "SSEC002.10"></a>
<li><code>DegreeOfBinaryRelation( </code><var>R</var><code> ) A</code>
<p>
returns the size of the underlying domain of  the  binary  relation  <var>R</var>.
This is most natural when working with a binary relation on points.
<p>
<a name = "SSEC002.11"></a>
<li><code>PartialOrderOfHasseDiagram( </code><var>HD</var><code> ) A</code>
<p>
is the partial order associated with the Hasse Diagram <var>HD</var> 
i.e. the partial order generated by the reflexive and 
transitive closure of <var>HD</var>. 
<p>
<p>
<h2><a name="SECT003">32.3 Binary Relations on Points</a></h2>
<p><p>
We have special construction methods when the underlying <var>X</var> of our relation
is the set of integers {1,..., <i>n</i> }. 
<p>
<a name = "SSEC003.1"></a>
<li><code>BinaryRelationOnPoints( </code><var>list</var><code> ) F</code>
<a name = "SSEC003.1"></a>
<li><code>BinaryRelationOnPointsNC( </code><var>list</var><code> ) F</code>
<p>
Given a list of <var>n</var> lists, each containing elements from 
the set {1,...,<i>n</i>},
this function constructs a binary relation such that 1 is related
to <var>list</var><code>[1]</code>, 2 to <var>list</var><code>[2]</code> and so on.
The first version checks whether the list supplied is valid. The
the <code>NC</code> version skips this check.
<p>
<a name = "SSEC003.2"></a>
<li><code>RandomBinaryRelationOnPoints( </code><var>degree</var><code> ) F</code>
<p>
creates a relation on points with degree <var>degree</var>.
<p>
<a name = "SSEC003.3"></a>
<li><code>AsBinaryRelationOnPoints( </code><var>trans</var><code> ) F</code>
<li><code>AsBinaryRelationOnPoints( </code><var>perm</var><code> ) F</code>
<li><code>AsBinaryRelationOnPoints( </code><var>rel</var><code> ) F</code>
<p>
return the relation on points  represented  by  general  relation  <var>rel</var>,
transformation <var>trans</var> or permutation  <var>perm</var>.  If  <var>rel</var>  is  already  a
binary relation on points then <var>rel</var> is returned.
<p>
Transformations and permutations are special general endomorphic 
mappings and have a natural representation as a binary relation on
points. 
<p>
In the last form, an isomorphic relation on points is constructed
where the points are indices of the elements of the underlying domain
in sorted order.
<p>
<p>
<h2><a name="SECT004">32.4 Closure Operations and Other Constructors</a></h2>
<p><p>
<a name = "SSEC004.1"></a>
<li><code>ReflexiveClosureBinaryRelation( </code><var>R</var><code> ) O</code>
<p>
is the smallest binary relation containing the binary relation <var>R</var>  which
is  reflexive.  This  closure  inherents  the  properties  symmetric  and
transitive from <var>R</var>. E.g. if <var>R</var> is symmetric then its reflexive  closure
is also.
<p>
<a name = "SSEC004.2"></a>
<li><code>SymmetricClosureBinaryRelation( </code><var>R</var><code> ) O</code>
<p>
is the smallest binary relation containing the binary relation <var>R</var>  which
is  symmetric.  This  closure  inherents  the  properties  reflexive  and
transitive from <var>R</var>. E.g. if <var>R</var> is reflexive then its symmetric  closure
is also.
<p>
<a name = "SSEC004.3"></a>
<li><code>TransitiveClosureBinaryRelation( </code><var>rel</var><code> ) O</code>
<p>
is the smallest binary relation containing the binary relation <var>R</var>  which
is  transitive.  This  closure  inerents  the  properties  reflexive  and
symmetric from <var>R</var>. E.g. if <var>R</var> is symmetric then its transitive  closure
is also.
<p>
<code>TransitiveClosureBinaryRelation</code> is a modified version of the 
Floyd-Warshall method of solving the all-pairs shortest-paths problem 
on a directed graph. Its asymptotic runtime is <i>O</i>(<i>n</i><sup>3</sup>) where n is 
the size of the vertex set. It only assumes there is an arbitrary 
(but fixed) ordering of the vertex set. 
<p>
<a name = "SSEC004.4"></a>
<li><code>HasseDiagramBinaryRelation( </code><var>partial-order</var><code> ) O</code>
<p>
is the smallest relation contained in the partial  order  <var>partial-order</var>
whose reflexive and transitive closure is equal to <var>partial-order</var>.
<p>
<a name = "SSEC004.5"></a>
<li><code>StronglyConnectedComponents( </code><var>R</var><code> ) O</code>
<p>
returns an equivalence relation on the vertices of  the  binary  relation
<var>R</var>.
<p>
<a name = "SSEC004.6"></a>
<li><code>PartialOrderByOrderingFunction( </code><var>dom</var><code>, </code><var>orderfunc</var><code> ) F</code>
<p>
constructs a partial order whose elements are from the domain <var>dom</var>
and are ordered using the ordering function <var>orderfunc</var>. The ordering
function must be a binary function returning a boolean value. If the 
ordering function does not describe a partial order then <code>fail</code> is
returned.
<p>
<p>
<h2><a name="SECT005">32.5 Equivalence Relations</a></h2>
<p><p>
<a name = "I10"></a>

An <strong>equivalence relation</strong> <var>E</var> over the set <var>X</var> is a relation on <var>X</var> which 
is reflexive, symmetric, and transitive. 
of the set <var>X</var>. A <strong>partition</strong> <var>P</var> is a set of subsets of <var>X</var> such that
for all <i>R</i>,<i>S</i> &#8712; <i>P</i> <i>R</i>&#8745;<i>S</i> is the empty set and &#8746;<i>P</i>=<i>X</i>.  
An equivalence relation induces a partition such that if (<i>x</i>,<i>y</i>) &#8712; <i>E</i> then
<i>x</i>,<i>y</i> are in the same element of <var>P</var>.
<p>
Like all binary relations in <font face="Gill Sans,Helvetica,Arial">GAP</font> equivalence 
relations are regarded as general endomorphic mappings (and the operations,
properties and attributes of general mappings are available). 
However, partitions provide an efficient way of representing equivalence 
relations.  Moreover, only the non-singleton classes
or blocks are listed allowing for small equivalence relations to be
represented on infinite sets. Hence the main attribute of equivalence 
relations is <code>EquivalenceRelationPartition</code> which provides the partition
induced by the given equivalence.
<p>
<a name = "SSEC005.1"></a>
<li><code>EquivalenceRelationByPartition( </code><var>domain</var><code>, </code><var>list</var><code> ) F</code>
<a name = "SSEC005.1"></a>
<li><code>EquivalenceRelationByPartitionNC( </code><var>domain</var><code>, </code><var>list</var><code> ) F</code>
<p>
constructs the equivalence relation over the set <var>domain</var>
which induces the partition represented by <var>list</var>. 
This representation includes only the non-trivial blocks 
(or equivalent classes). <var>list</var> is a list of lists,
each of these lists contain elements of <var>domain</var> and are 
pairwise mutually exclusive.
<p>
The list of lists do not need to be in any order nor do the 
elements in the blocks (see <code>EquivalenceRelationPartition</code>).
a list of elements of <var>domain</var>
The partition <var>list</var> is a 
list of lists, each of these is a list of elements of <var>domain</var>
that makes up a block (or equivalent class). The 
<var>domain</var> is the domain over which the relation is defined, and 
<var>list</var> is a list of lists, each of these is a list of elements
of <var>domain</var> which are related to each other.
<var>list</var> need only contain the nontrivial blocks 
and singletons will be ignored. The NC version will not check
to see if the lists are pairwise mutually exclusive or that
they contain only elements of the domain.
<p>
<a name = "SSEC005.2"></a>
<li><code>EquivalenceRelationByRelation( </code><var>rel</var><code> ) F</code>
<p>
returns the smallest equivalence 
relation containing the binary relation <var>rel</var>.
<p>
<a name = "SSEC005.3"></a>
<li><code>EquivalenceRelationByPairs( </code><var>D</var><code>, </code><var>elms</var><code> ) F</code>
<a name = "SSEC005.3"></a>
<li><code>EquivalenceRelationByPairsNC( </code><var>D</var><code>, </code><var>elms</var><code> ) F</code>
<p>
return the smallest equivalence relation
on the domain <var>D</var> such that every pair in <var>elms</var>
is in the relation.
<p>
In the second form, it is not checked that <var>elms</var> are in the domain <var>D</var>.
<p>
<a name = "SSEC005.4"></a>
<li><code>EquivalenceRelationByProperty( </code><var>domain</var><code>, </code><var>property</var><code> ) F</code>
<p>
creates an equivalence relation on <var>domain</var> whose only defining
datum is that of having the property <var>property</var>.
<p>
<p>
<h2><a name="SECT006">32.6 Attributes of and Operations on Equivalence Relations</a></h2>
<p><p>
<a name = "SSEC006.1"></a>
<li><code>EquivalenceRelationPartition( </code><var>equiv</var><code> ) A</code>
<p>
returns a list of lists of elements 
of the underlying set of the equivalence relation <var>equiv</var>.
The lists are precisely the nonsingleton equivalence classes of the
equivalence.
This allows us to describe ``small'' equivalences on infinite sets.
<p>
<a name = "SSEC006.2"></a>
<li><code>GeneratorsOfEquivalenceRelationPartition( </code><var>equiv</var><code> ) A</code>
<p>
is a set of generating pairs for the equivalence relation  <var>equiv</var>.  This
set is not unique. The equivalence <var>equiv</var> is  the  smallest  equivalence
relation over the underlying set <var>X</var> which contains the generating pairs.
<p>
<a name = "SSEC006.3"></a>
<li><code>JoinEquivalenceRelations( </code><var>equiv1</var><code>, </code><var>equiv2</var><code> ) O</code>
<a name = "SSEC006.3"></a>
<li><code>MeetEquivalenceRelations( </code><var>equiv1</var><code>, </code><var>equiv2</var><code> ) O</code>
<p>
<code>JoinEquivalenceRelations(</code><var>equiv1</var><code>,</code><var>equiv2</var><code>)</code> returns the smallest
equivalence relation containing both the equivalence relations
<var>equiv1</var> and <var>equiv2</var>.
<p>
<code>MeetEquivalenceRelations( </code><var>equiv1</var><code>,</code><var>equiv2</var><code> )</code> returns the 
intersection of the two equivalence relations <var>equiv1</var> and <var>equiv2</var>.
<p>
<p>
<h2><a name="SECT007">32.7 Equivalence Classes</a></h2>
<p><p>
<a name = "SSEC007.1"></a>
<li><code>IsEquivalenceClass( </code><var>O</var><code> ) C</code>
<p>
returns <code>true</code> if the object <var>O</var> is an equivalence class, and <code>false</code>
otherwise.
<p>
<a name = "I11"></a>

An <strong>equivalence class</strong> is a collection of elements which are mutually
related to each other in the associated equivalence relation. Note,
this is a special category of object and not just a list of elements.
<p>
<a name = "SSEC007.2"></a>
<li><code>EquivalenceClassRelation( </code><var>C</var><code> ) A</code>
<p>
returns the equivalence relation of which <var>C</var> is a class.
<p>
<a name = "SSEC007.3"></a>
<li><code>EquivalenceClasses( </code><var>rel</var><code> ) A</code>
<p>
returns a list of all equivalence classes of the equivalence relation <var>rel</var>.
Note that it is possible for different methods to yield the list
in different orders, so that for two equivalence relations
<i>c</i>1 and <i>c</i>2 we may have <i>c</i>1 = <i>c</i>2 without having
<tt>EquivalenceClasses</tt>( <i>c</i>1 ) = <tt>EquivalenceClasses</tt>( <i>c</i>2 ).
<p>
<a name = "SSEC007.4"></a>
<li><code>EquivalenceClassOfElement( </code><var>rel</var><code>, </code><var>elt</var><code> ) O</code>
<a name = "SSEC007.4"></a>
<li><code>EquivalenceClassOfElementNC( </code><var>rel</var><code>, </code><var>elt</var><code> ) O</code>
<p>
return the equivalence class of <var>elt</var> in the binary relation <var>rel</var>,
where <var>elt</var> is an element (i.e. a pair) of the domain of <var>rel</var>. 
In the second form, it is not checked that <var>elt</var> is in the domain 
over which <var>rel</var> is defined.
<p>
<p>
[<a href="../index.htm">Top</a>] [<a href = "chapters.htm">Up</a>] [<a href ="CHAP031.htm">Previous</a>] [<a href ="CHAP033.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<P>
<font face="Gill Sans,Helvetica,Arial">GAP 4 manual<br>October 2007
</font></body></html>