<html><head><title>[ref] 21 Lists</title></head>
<body text="#000000" bgcolor="#ffffff">
[<a href="../index.htm">Top</a>] [<a href = "chapters.htm">Up</a>] [<a href ="CHAP020.htm">Previous</a>] [<a href ="CHAP022.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<h1>21 Lists</h1><p>
<P>
<H3>Sections</H3>
<oL>
<li> <A HREF="CHAP021.htm#SECT001">List Categories</a>
<li> <A HREF="CHAP021.htm#SECT002">Basic Operations for Lists</a>
<li> <A HREF="CHAP021.htm#SECT003">List Elements</a>
<li> <A HREF="CHAP021.htm#SECT004">List Assignment</a>
<li> <A HREF="CHAP021.htm#SECT005">IsBound and Unbind for Lists</a>
<li> <A HREF="CHAP021.htm#SECT006">Identical Lists</a>
<li> <A HREF="CHAP021.htm#SECT007">Duplication of Lists</a>
<li> <A HREF="CHAP021.htm#SECT008">Membership Test for Lists</a>
<li> <A HREF="CHAP021.htm#SECT009">Enlarging Internally Represented Lists</a>
<li> <A HREF="CHAP021.htm#SECT010">Comparisons of Lists</a>
<li> <A HREF="CHAP021.htm#SECT011">Arithmetic for Lists</a>
<li> <A HREF="CHAP021.htm#SECT012">Filters Controlling the Arithmetic Behaviour of Lists</a>
<li> <A HREF="CHAP021.htm#SECT013">Additive Arithmetic for Lists</a>
<li> <A HREF="CHAP021.htm#SECT014">Multiplicative Arithmetic for Lists</a>
<li> <A HREF="CHAP021.htm#SECT015">Mutability Status and List Arithmetic</a>
<li> <A HREF="CHAP021.htm#SECT016">Finding Positions in Lists</a>
<li> <A HREF="CHAP021.htm#SECT017">Properties and Attributes for Lists</a>
<li> <A HREF="CHAP021.htm#SECT018">Sorting Lists</a>
<li> <A HREF="CHAP021.htm#SECT019">Sorted Lists and Sets</a>
<li> <A HREF="CHAP021.htm#SECT020">Operations for Lists</a>
<li> <A HREF="CHAP021.htm#SECT021">Advanced List Manipulations</a>
<li> <A HREF="CHAP021.htm#SECT022">Ranges</a>
<li> <A HREF="CHAP021.htm#SECT023">Enumerators</a>
</ol><p>
<p>
Lists are the most important way to treat objects together.
A <strong>list</strong> arranges objects in a definite order.
So each list implies a partial mapping from the integers to the elements
of the list.
I.e., there is a first element of a list, a second, a third, and so on.
Lists can occur in mutable or immutable form,
see&nbsp;<a href="CHAP012.htm#SECT006">Mutability and Copyability</a> for the concept of mutability,
and&nbsp;<a href="CHAP021.htm#SECT007">Duplication of Lists</a> for the case of lists.
<p>
This chapter deals mainly with the aspect of lists in <font face="Gill Sans,Helvetica,Arial">GAP</font>
as <strong>data structures</strong>.
Chapter&nbsp;<a href="CHAP028.htm">Collections</a> tells more about the <strong>collection</strong> aspect of certain
lists,
and more about lists as <strong>arithmetic objects</strong> can be found in the chapters
<a href="CHAP023.htm">Row Vectors</a> and <a href="CHAP024.htm">Matrices</a>.
<p>
Lists are used to implement ranges (see&nbsp;<a href="CHAP021.htm#SECT022">Ranges</a>),
sets (see&nbsp;<a href="CHAP021.htm#SECT019">Sorted Lists and Sets</a>),indexSets
strings (see&nbsp;<a href="CHAP026.htm">Strings and Characters</a>),
row vectors (see&nbsp;<a href="CHAP023.htm">Row Vectors</a>), and matrices (see&nbsp;<a href="CHAP024.htm">Matrices</a>);
Boolean lists (see&nbsp;<a href="CHAP022.htm">Boolean Lists</a>) are a further special kind of lists.
<p>
Several operations for lists, such as <code>Intersection</code> and <code>Random</code>,
will be described in Chapter&nbsp;<a href="CHAP028.htm">Collections</a>,
in particular see&nbsp;<a href="CHAP028.htm#SECT002">Lists and Collections</a>.
<p>
<p>
<h2><a name="SECT001">21.1 List Categories</a></h2>
<p><p>
A list can be written by writing down the elements in order between
square brackets <code>[</code>, <code>]</code>, and separating them with commas <code>,</code>. An <strong>empty
list</strong>, i.e., a list with no elements, is written as <code>[]</code>.
<p>
<pre>
gap&gt; [ 1, 2, 3 ];              # a list with three elements
[ 1, 2, 3 ]
gap&gt; [ [], [ 1 ], [ 1, 2 ] ];  # a list may contain other lists
[ [  ], [ 1 ], [ 1, 2 ] ]
</pre>
<p>
Each list constructed this way is mutable (see&nbsp;<a href="CHAP012.htm#SECT006">Mutability and Copyability</a>).
<p>
<a name = "SSEC001.1"></a>
<li><code>IsList( </code><var>obj</var><code> ) C</code>
<p>
tests whether <var>obj</var> is a list.
<p>
<pre>
gap&gt; IsList( [ 1, 3, 5, 7 ] );  IsList( 1 );
true
false
</pre>
<p>
<a name = "SSEC001.2"></a>
<li><code>IsDenseList( </code><var>obj</var><code> ) C</code>
<p>
A list is <strong>dense</strong> if it has no holes, i.e., contains an element at every
position up to the length.
It is absolutely legal to have lists with holes.
They are created by leaving the entry between the commas empty.
Holes at the end of a list are ignored.
Lists with holes are sometimes convenient when the list represents
a mapping from a finite, but not consecutive,
subset of the positive integers.
<p>
<pre>
gap&gt; IsDenseList( [ 1, 2, 3 ] );
true
gap&gt; l := [ , 4, 9,, 25,, 49,,,, 121 ];;  IsDenseList( l );
false
gap&gt; l[3];
9
gap&gt; l[4];
List Element: &lt;list&gt;[4] must have an assigned value
not in any function
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you can 'return;' after assigning a value to continue
brk&gt; l[4] := 16;;  # assigning a value
brk&gt; return;       # to escape the break-loop
16
gap&gt; 
</pre>
<p>
Observe that requesting the value of <code>l[4]</code>, which was not
assigned, caused the entry of a <code>break</code>-loop (see Section&nbsp;<a href="CHAP006.htm#SECT004">Break Loops</a>).
After assigning a value and typing <code>return;</code>, <font face="Gill Sans,Helvetica,Arial">GAP</font> is finally
able to comply with our request (by responding with <code>16</code>).
<p>
<a name = "SSEC001.3"></a>
<li><code>IsHomogeneousList( </code><var>obj</var><code> ) C</code>
<p>
returns <code>true</code> if <var>obj</var> is a list  and  it  is  homogeneous,  or  <code>false</code>
otherwise.
<p>
A <strong>homogeneous</strong> list is a dense list whose elements lie in the same
family (see&nbsp;<a href="CHAP013.htm#SECT001">Families</a>).
The empty list is homogeneous but not a collection (see&nbsp;<a href="CHAP028.htm">Collections</a>),
a nonempty homogeneous list is also a collection.
<p>
<pre>
gap&gt; IsHomogeneousList( [ 1, 2, 3 ] );  IsHomogeneousList( [] );
true
true
gap&gt; IsHomogeneousList( [ 1, false, () ] );
false
</pre>
<p>
<a name = "SSEC001.4"></a>
<li><code>IsTable( </code><var>obj</var><code> ) C</code>
<p>
A <strong>table</strong> is a nonempty list of homogeneous lists which lie in the same
family.
Typical examples of tables are matrices (see&nbsp;<a href="CHAP024.htm">Matrices</a>).
<p>
<pre>
gap&gt; IsTable( [ [ 1, 2 ], [ 3, 4 ] ] );        # in fact a matrix
true
gap&gt; IsTable( [ [ 1 ], [ 2, 3 ] ] );           # not rectangular but a table
true
gap&gt; IsTable( [ [ 1, 2 ], [ () , (1,2) ] ] );  # not homogeneous
false
</pre>
<p>
<a name = "SSEC001.5"></a>
<li><code>IsConstantTimeAccessList( </code><var>list</var><code> ) C</code>
<p>
This category indicates whether the access to each element of the list
<var>list</var> will take roughly the same time.
This is implied for example by <code>IsList and IsInternalRep</code>,
so all strings, Boolean lists, ranges, and internally represented plain
lists are in this category.
<p>
But also other enumerators (see&nbsp;<a href="CHAP021.htm#SECT023">Enumerators</a>) can lie in this category
if they guarantee constant time access to their elements.
<p>
<p>
<h2><a name="SECT002">21.2 Basic Operations for Lists</a></h2>
<p><p>
The basic operations for lists are element access (see&nbsp;<a href="CHAP021.htm#SECT003">List Elements</a>),
assignment of elements to a list (see&nbsp;<a href="CHAP021.htm#SECT004">List Assignment</a>),
fetching the length of a list (see&nbsp;<a href="CHAP021.htm#SSEC017.5">Length</a>),
the test for a hole at a given position, and unbinding an element at a given
position (see&nbsp;<a href="CHAP021.htm#SECT005">IsBound and Unbind for Lists</a>).
<p>
The term basic operation means that each other list operation can be
formulated in terms of the basic operations.
(But note that usually a more efficient method than this one is implemented.)
<p>
Any <font face="Gill Sans,Helvetica,Arial">GAP</font> object <var>list</var> in the category <code>IsList</code> (see&nbsp;<a href="CHAP021.htm#SSEC001.1">IsList</a>) is regarded
as a list, and if methods for the basic list operations are installed for
<var>list</var> then <var>list</var> can be used also for the other list operations.
<p>
For internally represented lists, kernel methods are provided for the basic
list operations.
For other lists, it is possible to install appropriate methods for these
operations.
This permits the implementation of lists that do not need to store all list
elements (see also&nbsp;<a href="CHAP021.htm#SECT023">Enumerators</a>);
for example, the elements might be described by an algorithm, such as the
elements list of a group.
For this reduction of space requirements, however, a price in access time
may have to be paid (see&nbsp;<a href="CHAP021.htm#SSEC017.6">ConstantTimeAccessList</a>).
<p>
<a name = "SSEC002.1"></a>
<li><code>\[\]( </code><var>list</var><code>, </code><var>pos</var><code> ) O</code>
<a name = "SSEC002.1"></a>
<li><code>IsBound\[\]( </code><var>list</var><code>, </code><var>pos</var><code> ) O</code>
<a name = "SSEC002.1"></a>
<li><code>\[\]\:\=( </code><var>list</var><code>, </code><var>pos</var><code>, </code><var>val</var><code> ) O</code>
<a name = "SSEC002.1"></a>
<li><code>Unbind\[\]( </code><var>list</var><code>, </code><var>pos</var><code> ) O</code>
<p>
These operations implement element access, test for element boundedness,
list element assignment, and removal of the element at position <var>pos</var>.
In all cases, the index <var>pos</var> must be a positive integer.
<p>
Note that the special characters <code>[</code>, <code>]</code>, <code>:</code>, and <code>=</code> must be escaped with
a backslash <code>\</code> (see&nbsp;<a href="CHAP004.htm#SECT003">Symbols</a>);
so <code>\[\]</code> denotes the operation for element access in a list,
whereas <code>[]</code> denotes an empty list.
(Maybe the variable names involving special characters look strange,
but nevertheless they are quite suggestive.)
<p>
<code>\[\]( </code><var>list</var><code>, </code><var>pos</var><code> )</code> is equivalent to <code></code><var>list</var><code>[ </code><var>pos</var><code> ]</code>,
which clearly will usually be preferred;
the former is useful mainly if one wants to access the operation itself,
for example if one wants to install a method for element access in a
special kind of lists.
<p>
Similarly, <code>IsBound\[\]</code> is used explicitly mainly in method installations.
In other situations, one can simply call <code>IsBound</code>, which then delegates to
<code>IsBound\[\]</code> if the first argument is a list, and to <code>IsBound\.</code> if the
first argument is a record.
<p>
Analogous statements hold for <code>\[\]\:\=</code> and <code>Unbind\[\]</code>.
<p>
<p>
<h2><a name="SECT003">21.3 List Elements</a></h2>
<p><p>
<a name = "I0"></a>

<a name = "SSEC003.1"></a>
<li><code></code><var>list</var><code> [ </code><var>pos</var><code> ]</code>
<p>
The above construct evaluates to the <var>pos</var>-th element of the list <var>list</var>.
<var>pos</var> must be a positive integer. List indexing is done with origin 1,
i.e., the first element of the list is the element at position 1.
<pre>
gap&gt; l := [ 2, 3, 5, 7, 11, 13 ];;  l[1];  l[2];  l[6];
2
3
13
</pre>
If <var>list</var> is not a list, or <var>pos</var> does not evaluate to a
positive integer, or <code></code><var>list</var><code>[</code><var>pos</var><code>]</code> is unbound an error is signalled.
<p>
<a name = "SSEC003.2"></a>
<li><code></code><var>list</var><code>{ </code><var>poss</var><code> }</code>
<p>
<a name = "I1"></a>

The above construct evaluates to a new list <var>new</var> whose first element is
<code></code><var>list</var><code>[</code><var>poss</var><code>[1]]</code>, whose second element is <code></code><var>list</var><code>[</code><var>poss</var><code>[2]]</code>, and so
on. <var>poss</var> must be a dense list of positive integers. However, it does not
need to be sorted and may contain duplicate elements. If for any <var>i</var>,
<code></code><var>list</var><code>[ </code><var>poss</var><code>[</code><var>i</var><code>] ]</code> is unbound, an error is signalled.
<p>
<pre>
gap&gt; l := [ 2, 3, 5, 7, 11, 13, 17, 19 ];;
gap&gt; l{[4..6]};  l{[1,7,1,8]};
[ 7, 11, 13 ]
[ 2, 17, 2, 19 ]
</pre>
<p>
The result is a <strong>new</strong> list, that is not identical to any other list. The
elements of that list, however, are identical to the corresponding elements
of the left operand (see&nbsp;<a href="CHAP021.htm#SECT006">Identical Lists</a>).
<p>
It is possible to nest such <strong>sublist extractions</strong>, as can be seen in the
following example.
<p>
<pre>
gap&gt; m := [ [1,2,3], [4,5,6], [7,8,9], [10,11,12] ];;  m{[1,2,3]}{[3,2]};
[ [ 3, 2 ], [ 6, 5 ], [ 9, 8 ] ]
gap&gt; l := m{[1,2,3]};; l{[3,2]};
[ [ 7, 8, 9 ], [ 4, 5, 6 ] ]
</pre>
<p>
Note the difference between the two examples.  The latter extracts
elements 1, 2, and 3 from <var>m</var> and then extracts the elements 3 and 2 from
<strong>this list</strong>. The former extracts elements 1, 2, and 3 from <var>m</var> and then
extracts the elements 3 and 2 from <strong>each of those element lists</strong>.
<p>
To be precise: With each selector <code>[</code><var>pos</var><code>]</code> or <code>{</code><var>poss</var><code>}</code> we associate
a <strong>level</strong> that is defined as the number of selectors of the form
<code>{</code><var>poss</var><code>}</code> to its left in the same expression. For example
<p>
<pre>
    l[pos1]{poss2}{poss3}[pos4]{poss5}[pos6]
level   0      0      1     2      2     3
</pre>
<p>
Then  a selector <code></code><var>list</var><code>[</code><var>pos</var><code>]</code> of level <var>level</var> is computed as
<code>ListElement(</code><var>list</var><code>,</code><var>pos</var><code>,</code><var>level</var><code>)</code>, where <code>ListElement</code> is defined as
follows.
(Note that <code>ListElement</code> is <strong>not</strong> a <font face="Gill Sans,Helvetica,Arial">GAP</font> function.)
<p>
<pre>
ListElement := function ( list, pos, level )
 if level = 0 then
  return list[pos];
 else
  return List( list, elm -&gt; ListElement(elm,pos,level-1) );
 fi;
end;
</pre>
<p>
and a selector <code></code><var>list</var><code>{</code><var>poss</var><code>}</code> of level <var>level</var> is computed as
<code>ListElements(</code><var>list</var><code>,</code><var>poss</var><code>,</code><var>level</var><code>)</code>, where <code>ListElements</code> is defined as
follows.
(Note that <code>ListElements</code> is <strong>not</strong> a <font face="Gill Sans,Helvetica,Arial">GAP</font> function.)
<p>
<pre>
ListElements := function ( list, poss, level )
 if level = 0 then
  return list{poss};
  else
   return List( list, elm -&gt; ListElements(elm,poss,level-1) );
  fi;
end;
</pre>
<p>
<a name = "SSEC003.3"></a>
<li><code>\{\}( </code><var>list</var><code>, </code><var>poss</var><code> ) O</code>
<p>
This operation implements <strong>sublist access</strong>.
For any list, the default method is to loop over the entries in the list
<var>poss</var>, and to delegate to the element access operation.
(For the somewhat strange variable name, cf.&nbsp;<a href="CHAP021.htm#SECT002">Basic Operations for Lists</a>.)
<p>
<p>
<h2><a name="SECT004">21.4 List Assignment</a></h2>
<p><p>
<a name = "I2"></a>

<a name = "SSEC004.1"></a>
<li><code></code><var>list</var><code>[ </code><var>pos</var><code> ] := </code><var>object</var><code>;</code>
<p>
The list element assignment assigns the object <var>object</var>,
which can be of any type, to the list entry at the position <var>pos</var>,
which must be a positive integer,
in the mutable (see&nbsp;<a href="CHAP012.htm#SECT006">Mutability and Copyability</a>) list <var>list</var>.
That means that accessing the <var>pos</var>-th element of the list <var>list</var> will
return <var>object</var> after this assignment.
<p>
<pre>
gap&gt; l := [ 1, 2, 3 ];;
gap&gt; l[1] := 3;; l;             # assign a new object
[ 3, 2, 3 ]
gap&gt; l[2] := [ 4, 5, 6 ];; l;   # &lt;object&gt; may be of any type
[ 3, [ 4, 5, 6 ], 3 ]
gap&gt; l[ l[1] ] := 10;; l;       # &lt;index&gt; may be an expression
[ 3, [ 4, 5, 6 ], 10 ]
</pre>
<p>
If the index <var>pos</var> is larger than the length of the list <var>list</var> (see
<a href="CHAP021.htm#SSEC017.5">Length</a>), the list is automatically enlarged to make room for the new
element. Note that it is possible to generate lists with holes that way.
<p>
<pre>
gap&gt; l[4] := "another entry";; l;  # &lt;list&gt; is enlarged
[ 3, [ 4, 5, 6 ], 10, "another entry" ]
gap&gt; l[ 10 ] := 1;; l;             # now &lt;list&gt; has a hole
[ 3, [ 4, 5, 6 ], 10, "another entry",,,,,, 1 ]
</pre>
<p>
The  function <code>Add</code> (see <a href="CHAP021.htm#SSEC004.4">Add</a>) should be used if you want to add an
element to the end of the list.
<p>
Note that assigning to a list changes the list,
thus this list must be mutable (see&nbsp;<a href="CHAP012.htm#SECT006">Mutability and Copyability</a>).
See&nbsp;<a href="CHAP021.htm#SECT006">Identical Lists</a> for subtleties of changing lists.
<p>
If <var>list</var> does not evaluate to a list, <var>pos</var> does not evaluate to a
positive integer or <var>object</var> is a call to a function which does not
return a value (for example <code>Print</code>) an error is signalled.
<p>
<a name = "SSEC004.2"></a>
<li><code></code><var>list</var><code>{ </code><var>poss</var><code> } := </code><var>objects</var><code>;</code>
<p>
The sublist assignment assigns the object <code></code><var>objects</var><code>[1]</code>, which can be of
any type, to the list <var>list</var> at the position <code></code><var>poss</var><code>[1]</code>, the object
<code></code><var>objects</var><code>[2]</code> to <code></code><var>list</var><code>[</code><var>poss</var><code>[2]]</code>, and so on. <var>poss</var> must be a dense
list of positive integers, it need, however, not be sorted and may
contain duplicate elements. <var>objects</var> must be a dense list and must have
the same length as <var>poss</var>.
<p>
<pre>
gap&gt; l := [ 2, 3, 5, 7, 11, 13, 17, 19 ];;
gap&gt; l{[1..4]} := [10..13];; l;
[ 10, 11, 12, 13, 11, 13, 17, 19 ]
gap&gt; l{[1,7,1,10]} := [ 1, 2, 3, 4 ];; l;
[ 3, 11, 12, 13, 11, 13, 2, 19,, 4 ]
</pre>
<p>
It is possible to nest such sublist assignments, as can be seen in the
following example.
<p>
<pre>
gap&gt; m := [ [1,2,3], [4,5,6], [7,8,9], [10,11,12] ];;
gap&gt; m{[1,2,3]}{[3,2]} := [ [11,12], [13,14], [15,16] ];; m;
[ [ 1, 12, 11 ], [ 4, 14, 13 ], [ 7, 16, 15 ], [ 10, 11, 12 ] ]
</pre>
<p>
The exact behaviour is defined in the same way as for list extractions
(see  <a href="CHAP021.htm#SECT003">List Elements</a>).  Namely  with each  selector <code>[</code><var>pos</var><code>]</code> or
<code>{</code><var>poss</var><code>}</code> we associate a <strong>level</strong> that is defined as the number of
selectors of the form <code>{</code><var>poss</var><code>}</code> to its left in the same expression.
For example
<p>
<pre>
    l[pos1]{poss2}{poss3}[pos4]{poss5}[pos6]
level   0      0      1     1      1     2
</pre>
<p>
Then a list assignment <code></code><var>list</var><code>[</code><var>pos</var><code>] := </code><var>vals</var><code>;</code> of level <var>level</var> is
computed as <code>ListAssignment( </code><var>list</var><code>, </code><var>pos</var><code>, </code><var>vals</var><code>, </code><var>level</var><code> )</code>, where
<code>ListAssignment</code> is defined as follows.
(Note that <code>ListAssignment</code> is <strong>not</strong> a <font face="Gill Sans,Helvetica,Arial">GAP</font> function.)
<p>
<pre>
ListAssignment := function ( list, pos, vals, level )
 local i;
 if level = 0 then
  list[pos] := vals;
 else
  for i in [1..Length(list)] do
   ListAssignment( list[i], pos, vals[i], level-1 );
  od;
 fi;
end;
</pre>
<p>
and a list assignment <code></code><var>list</var><code>{</code><var>poss</var><code>} := </code><var>vals</var><code></code> of level <var>level</var> is
computed as <code>ListAssignments( </code><var>list</var><code>, </code><var>poss</var><code>, </code><var>vals</var><code>, </code><var>level</var><code> )</code>, where
<code>ListAssignments</code> is defined as follows.
(Note that <code>ListAssignments</code> is <strong>not</strong> a <font face="Gill Sans,Helvetica,Arial">GAP</font> function.)
<p>
<pre>
ListAssignments := function ( list, poss, vals, level )
 local i;
 if level = 0 then
  list{poss} := vals;
 else
  for i in [1..Length(list)] do
   ListAssignments( list[i], poss, vals[i], level-1 );
  od;
 fi;
end;
</pre>
<p>
<a name = "SSEC004.3"></a>
<li><code>\{\}\:\=( </code><var>list</var><code>, </code><var>poss</var><code>, </code><var>val</var><code> ) O</code>
<p>
This operation implements sublist assignment.
For any list, the default method is to loop over the entries in the list
<var>poss</var>, and to delegate to the element assignment operation.
(For the somewhat strange variable name, cf.&nbsp;<a href="CHAP021.htm#SECT002">Basic Operations for Lists</a>.)
<p>
<a name = "SSEC004.4"></a>
<li><code>Add( </code><var>list</var><code>, </code><var>obj</var><code> ) O</code>
<li><code>Add( </code><var>list</var><code>, </code><var>obj</var><code>, </code><var>pos</var><code> ) O</code>
<p>
adds the element <var>obj</var> to the mutable list <var>list</var>. The two argument version 
adds <var>obj</var> at the end of <var>list</var>,
i.e., it is equivalent to the assignment
<code></code><var>list</var><code>[ Length(</code><var>list</var><code>) + 1 ] := </code><var>obj</var><code></code>, see&nbsp;<a href="CHAP021.htm#SSEC004.1">list element!assignment</a>.
<p>
The three argument version adds <var>obj</var> in position <var>pos</var>, moving all later
elements of the list (if any) up by one position. Any holes at or after
position <var>pos</var> are also moved up by one position, and new holes are created
before <var>pos</var> if they are needed.
<p>
Nothing is returned by <code>Add</code>, the function is only called for its side
effect.
<p>
<a name = "SSEC004.5"></a>
<li><code>Remove( </code><var>list</var><code> ) O</code>
<li><code>Remove( </code><var>list</var><code>, </code><var>pos</var><code> ) O</code>
<p>
removes an element from <var>list</var>. The one argument form removes the last 
element. The two argument form removes the element in position <var>pos</var>,
moving all subsequent elements down one position. Any holes  after
position <var>pos</var> are also moved down by one position.
<p>
Remove( <var>list</var> ) always returns the removed element. In this case <var>list</var>
must be non-empty. Remove( <var>list</var>, <var>pos</var> )
returns the old value of <var>list</var>[<var>pos</var>] if it was bound, and nothing if it
was not. Note that accessing or assigning the return value of this form of
the Remove operation is only safe when you <strong>know</strong> that there will be a 
value, otherwise it will cause an error.
<p>
<pre>
gap&gt; l := [ 2, 3, 5 ];; Add( l, 7 ); l;
[ 2, 3, 5, 7 ]
gap&gt; Add(l,4,2); l;
[ 2, 4, 3, 5, 7]
gap&gt; Remove(l,2); l;
4
[ 2, 3, 5, 7]
gap&gt; Remove(l); l;
7
[ 2, 3, 5]
gap&gt; Remove(l,5); l;
[ 2, 3, 5]
</pre>
<p>
These two operations are implemented with the aid of a 
more general kernel function
<p>
<a name = "SSEC004.6"></a>
<li><code>COPY_LIST_ENTRIES( </code><var>from-list</var><code>, </code><var>from-index</var><code>, </code><var>from-step</var><code>, </code><var>to-list</var><code>, </code><var>to-index</var><code>, </code><var>to-step</var><code>, </code><var>number</var><code> ) F</code>
<p>
This function copies <var>number</var> elements from <var>from-list</var>,
starting at position <var>from-index</var> and incrementing the position by
<var>from-step</var> each time, into <var>to-list</var> starting at position <var>to-index</var>
and incrementing the position by <var>to-step</var> each time. <var>from-list</var> and
<var>to-list</var> must be plain lists.  <var>from-step</var> and/or <var>to-step</var> can be
negative. Unbound positions of <var>from-list</var> are simply copied to
<var>to-list</var>.
<p>
<a name = "SSEC004.7"></a>
<li><code>Append( </code><var>list1</var><code>, </code><var>list2</var><code> ) O</code>
<p>
adds the elements of the list <var>list2</var> to the end of the mutable list
<var>list1</var>, see&nbsp;<a href="CHAP021.htm#SSEC004.2">sublist!assignment</a>.
<var>list2</var> may contain holes, in which case the corresponding entries in
<var>list1</var> will be left unbound.
<code>Append</code> returns nothing, it is only called for its side effect.
<p>
Note that <code>Append</code> changes its first argument, while <code>Concatenation</code>
(see&nbsp;<a href="CHAP021.htm#SSEC020.1">Concatenation</a>) creates a new list and leaves its arguments
unchanged.
<p>
<pre>
gap&gt; l := [ 2, 3, 5 ];; Append( l, [ 7, 11, 13 ] ); l;
[ 2, 3, 5, 7, 11, 13 ]
gap&gt; Append( l, [ 17,, 23 ] ); l;
[ 2, 3, 5, 7, 11, 13, 17,, 23 ]
</pre>
<p>
<p>
<h2><a name="SECT005">21.5 IsBound and Unbind for Lists</a></h2>
<p><p>
<a name = "SSEC005.1"></a>
<li><code>IsBound( </code><var>list</var><code>[</code><var>n</var><code>] ) M</code>
<p>
<code>IsBound</code> returns <code>true</code> if the list <var>list</var> has a
element at the position <var>n</var>, and <code>false</code> otherwise.
<var>list</var> must evaluate to a list, otherwise an error is signalled.
<p>
<pre>
gap&gt; l := [ , 2, 3, , 5, , 7, , , , 11 ];;
gap&gt; IsBound( l[7] );
true
gap&gt; IsBound( l[4] );
false
gap&gt; IsBound( l[101] );
false
</pre>
<p>
<a name = "SSEC005.2"></a>
<li><code>Unbind( </code><var>list</var><code>[</code><var>n</var><code>] ) M</code>
<p>
<code>Unbind</code> deletes the element at the position <var>n</var> in the mutable list <var>list</var>.
That is, after execution of <code>Unbind</code>, <var>list</var> no longer
has an assigned value at the position <var>n</var>.
Thus <code>Unbind</code> can be used to produce holes in a list.
Note that it is not an error to unbind a nonexisting list element.
<var>list</var> must evaluate to a list, otherwise an error is signalled.
<p>
<pre>
gap&gt; l := [ , 2, 3, 5, , 7, , , , 11 ];;
gap&gt; Unbind( l[3] ); l;
[ , 2,, 5,, 7,,,, 11 ]
gap&gt; Unbind( l[4] ); l;
[ , 2,,,, 7,,,, 11 ]
</pre>
<p>
Note that <code>IsBound</code> and <code>Unbind</code> are special in that they do not evaluate
their argument, otherwise <code>IsBound</code> would always signal an error when it is
supposed to return <code>false</code> and there would be no way to tell <code>Unbind</code> which
component to remove.
<p>
<p>
<h2><a name="SECT006">21.6 Identical Lists</a></h2>
<p><p>
With the list assignment (see&nbsp;<a href="CHAP021.htm#SECT004">List Assignment</a>) it is
possible  to change a mutable list.
This section describes the semantic consequences of this fact.
(See also&nbsp;<a href="CHAP012.htm#SECT005">Identical Objects</a>.)
<p>
First we define what it means when we say that ``an object is changed''.
You may think that in the following example the second assignment changes
the integer.
<p>
<pre>
i := 3;
i := i + 1;
</pre>
<p>
But in this example it is not the <strong>integer</strong> <code>3</code> which is changed,
by adding one to it.
Instead the <strong>variable</strong> <code>i</code> is changed by assigning the value of <code>i+1</code>,
which happens to be <code>4</code>, to <code>i</code>. The same thing happens in the following
example
<p>
<pre>
l := [ 1, 2 ];
l := [ 1, 2, 3 ];
</pre>
<p>
The second assignment does not change the first list, instead it assigns
a new list to the variable <code>l</code>.  On the other hand, in the following
example the list <strong>is</strong> changed by the second assignment.
<p>
<pre>
l := [ 1, 2 ];
l[3] := 3;
</pre>
<p>
To understand the difference, think of a variable as a name for an
object. The important point is that a list can have several names at the
same time.  An  assignment <code></code><var>var</var><code>:=</code><var>list</var><code>;</code> means in  this
interpretation that <var>var</var> is a name for the object <var>list</var>. At the end of
the following example <code>l2</code> still has the value <code>[ 1, 2 ]</code> as this list
has not been changed and nothing else has been assigned to it.
<p>
<pre>
l1 := [ 1, 2 ];
l2 := l1;
l1 := [ 1, 2, 3 ];
</pre>
<p>
But after the following example the list for which <code>l2</code> is a name has
been changed and thus the value of <code>l2</code> is now <code>[ 1, 2, 3 ]</code>.
<p>
<pre>
l1 := [ 1, 2 ];
l2 := l1;
l1[3] := 3;
</pre>
<p>
We say that two lists are <strong>identical</strong> if changing one of them by a
list assignment also changes the other one.  This is slightly incorrect,
because if <strong>two</strong> lists are identical, there are actually only two names
for <strong>one</strong> list. However, the correct usage would be very awkward and
would only add to the confusion.  Note that two identical lists must be
equal, because there is only one list with two different names. Thus
identity is an equivalence relation that is a refinement of equality.
Identity of objects can be detected using <code>IsIdenticalObj</code>,
see&nbsp;<a href="CHAP012.htm#SECT005">Identical Objects</a>.
<p>
Let us now consider under which circumstances two lists are identical.
<p>
If you enter a list literal then the list denoted by this literal is a
new list that is not identical to any other list. Thus in the following
example <code>l1</code> and <code>l2</code> are not identical, though they are equal of course.
<p>
<pre>
l1 := [ 1, 2 ];
l2 := [ 1, 2 ];
</pre>
<p>
Also in the following example, no lists in the list <code>l</code> are identical.
<p>
<pre>
l := [];
for i in [1..10] do l[i] := [ 1, 2 ]; od;
</pre>
<p>
If you assign a list to a variable no new list is created. Thus the list
value of the variable on the left hand side and the list on the right
hand side of the assignment are identical. So in the following example
<code>l1</code> and <code>l2</code> are identical lists.
<p>
<pre>
l1 := [ 1, 2 ];
l2 := l1;
</pre>
<p>
If you pass a list as an argument, the old list and the argument of the
function are identical. Also if you return a list from a function, the
old list and the value of the function call are identical. So in the
following example <code>l1</code> and <code>l2</code> are identical lists:
<p>
<pre>
l1 := [ 1, 2 ];
f := function ( l ) return l; end;
l2 := f( l1 );
</pre>
<p>
If you change a list it keeps its identity.  Thus if two lists are
identical and you change one of them, you also change the other, and they
are still identical afterwards. On the other hand, two lists that are
not identical will never become identical if you change one of them. So
in the following example both <code>l1</code> and <code>l2</code> are changed, and are still
identical.
<p>
<pre>
l1 := [ 1, 2 ];
l2 := l1;
l1[1] := 2;
</pre>
<p>
<p>
<h2><a name="SECT007">21.7 Duplication of Lists</a></h2>
<p><p>
Here we describe the meaning of <code>ShallowCopy</code> and <code>StructuralCopy</code> for
lists.
For the general definition of these functions,
see&nbsp;<a href="CHAP012.htm#SECT007">Duplication of Objects</a>.
<p>
<a name = "I3"></a>

The subobjects (see&nbsp;<a href="CHAP012.htm#SSEC007.1">ShallowCopy</a>) of a list are exactly its elements.
<p>
This means that for any list <var>list</var>, <code>ShallowCopy</code> returns a mutable
<strong>new</strong> list <var>new</var> that is <strong>not identical</strong> to any other list
(see&nbsp;<a href="CHAP021.htm#SECT006">Identical Lists</a>),
and whose elements are identical to the elements of <var>list</var>.
<p>
<a name = "I4"></a>

Analogously, for a <strong>mutable</strong> list <var>list</var>, <code>StructuralCopy</code> returns a
mutable <strong>new</strong> list <var>scp</var> that is <strong>not identical</strong> to any other list,
and whose elements are structural copies (defined recursively)
of the elements of <var>list</var>;
an element of <var>scp</var> is mutable (and then a <strong>new</strong> list) if and only if
the corresponding element of <var>list</var> is mutable.
<p>
In both cases, modifying the copy <var>new</var> resp.&nbsp;<var>scp</var> by assignments
(see&nbsp;<a href="CHAP021.htm#SECT004">List Assignment</a>) does not modify the original object <var>list</var>.
<p>
<code>ShallowCopy</code> basically executes the following code for lists.
<pre>
new := [];
for i in [ 1 .. Length( list ) ] do
  if IsBound( list[i] ) then
    new[i] := list[i];
  fi;
od;
</pre>
<p>
<pre>
gap&gt; list1 := [ [ 1, 2 ], [ 3, 4 ] ];;  list2 := ShallowCopy( list1 );;
gap&gt; IsIdenticalObj( list1, list2 );
false
gap&gt; IsIdenticalObj( list1[1], list2[1] );
true
gap&gt; list2[1] := 0;;  list1;  list2;
[ [ 1, 2 ], [ 3, 4 ] ]
[ 0, [ 3, 4 ] ]
</pre>
<p>
<code>StructuralCopy</code> basically executes the following code for lists.
<pre>
new := [];
for i in [ 1 .. Length( list ) ] do
  if IsBound( list[i] ) then
    new[i] := StructuralCopy( list[i] );
  fi;
od;
</pre>
<p>
<pre>
gap&gt; list1 := [ [ 1, 2 ], [ 3, 4 ] ];;  list2 := StructuralCopy( list1 );;
gap&gt; IsIdenticalObj( list1, list2 );
false
gap&gt; IsIdenticalObj( list1[1], list2[1] );
false
gap&gt; list2[1][1] := 0;;  list1;  list2;
[ [ 1, 2 ], [ 3, 4 ] ]
[ [ 0, 2 ], [ 3, 4 ] ]
</pre>
<p>
The above code is not entirely correct. If the object <var>list</var> contains a
mutable object twice this object is not copied twice,
as would happen with the above definition, but only once.
This means that the copy <var>new</var> and the object <var>list</var> have exactly the
same structure when viewed as a general graph.
<p>
<pre>
gap&gt; sub := [ 1, 2 ];; list1 := [ sub, sub ];;
gap&gt; list2 := StructuralCopy( list1 );
[ [ 1, 2 ], [ 1, 2 ] ]
gap&gt; list2[1][1] := 0;; list2;
[ [ 0, 2 ], [ 0, 2 ] ]
gap&gt; list1;
[ [ 1, 2 ], [ 1, 2 ] ]
</pre>
<p>
<p>
<h2><a name="SECT008">21.8 Membership Test for Lists</a></h2>
<p><p>
<a name = "I5"></a>

<a name = "SSEC008.1"></a>
<li><code></code><var>obj</var><code> in </code><var>list</var><code></code>
<p>
tests whether there is a positive integer <var>index</var> such that
<code></code><var>list</var><code>[ </code><var>index</var><code> ] = </code><var>obj</var><code></code>.
<p>
If the list <var>list</var> knows that it is strictly sorted (see&nbsp;<a href="CHAP021.htm#SSEC017.4">IsSSortedList</a>),
the membership test is much quicker, because a binary search can be used
instead of the linear search used for arbitrary lists.
<p>
<pre>
gap&gt; 1 in [ 2, 2, 1, 3 ];  1 in [ 4, -1, 0, 3 ];
true
false
gap&gt; s := SSortedList( [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32] );;
gap&gt; 17 in s;  # uses binary search and only 4 comparisons
false
</pre>
<p>
For finding the position of an element in a list,
see&nbsp;<a href="CHAP021.htm#SECT016">Finding Positions in Lists</a>.
<p>
<p>
<h2><a name="SECT009">21.9 Enlarging Internally Represented Lists</a></h2>
<p><p>
Section&nbsp;<a href="CHAP021.htm#SECT004">List Assignment</a> told you (among other things) that it is
possible to assign beyond the logical end of a mutable list,
automatically enlarging the list.
This section tells you how this is done for internally represented lists.
<p>
It would be extremely wasteful to make all lists large enough so that
there is room for all assignments, because some lists may have more than
100000 elements, while most lists have less than 10 elements.
<p>
On the other hand suppose every assignment beyond the end of a list would
be done by allocating new space for the list and copying all entries to
the new space. Then creating a list of 1000 elements by assigning them
in order, would take half a million copy operations and also create a lot
of garbage that the garbage collector would have to reclaim.
<p>
So the following strategy is used.  If a list is created it is created
with exactly the correct size. If a  list is enlarged, because of an
assignment beyond  the end of the list,  it is enlarged  by at least
<code></code><var>length</var><code>/8 + 4</code> entries. Therefore the next assignments beyond the end
of the list do not need to enlarge the list. For example creating a list
of 1000 elements by  assigning them in order,  would now take only 32
enlargements.
<p>
The result of this is of course that the <strong>physical length</strong> of a list
may be larger than the <strong>logical length</strong>,
which is usually called simply the length of the list.
Aside from the implications for the performance you need not be aware
of the physical length.
In fact all you can  ever observe, for  example by calling
<code>Length</code> (see&nbsp;<a href="CHAP021.htm#SSEC017.5">Length</a>), is the logical length.
<p>
Suppose that <code>Length</code> would have to take  the physical length and then
test how many entries at the end of a list are unassigned, to compute the
logical length of the list. That would take too much time. In order to
make <code>Length</code>, and other functions that need to know the logical length,
more efficient, the length of a list is stored along with the list.
<p>
<p>
<h2><a name="SECT010">21.10 Comparisons of Lists</a></h2>
<p><p>
<a name = "I6"></a>

<a name = "SSEC010.1"></a>
<li><code></code><var>list1</var><code> = </code><var>list2</var><code></code>
<br><code>&nbsp;</code><var>list1</var><code> &lt;&gt; </code><var>list2</var><code></code>
<p>
Two lists <var>list1</var> and <var>list2</var> are equal if and only if for
every index <var>i</var>, either both entries <code></code><var>list1</var><code>[</code><var>i</var><code>]</code> and <code></code><var>list2</var><code>[</code><var>i</var><code>]</code>
are unbound, or  both are bound and are equal, i.e., <code></code><var>list1</var><code>[</code><var>i</var><code>] =
</code><var>list2</var><code>[</code><var>i</var><code>]</code> is <code>true</code>.
<p>
<pre>
gap&gt; [ 1, 2, 3 ] = [ 1, 2, 3 ];
true
gap&gt; [ , 2, 3 ] = [ 1, 2, ];
false
gap&gt; [ 1, 2, 3 ] = [ 3, 2, 1 ];
false
</pre>
<p>
This definition will cause problems with lists which are their own entries.
Comparing two such lists for equality may lead to an infinite recursion in
the kernel if the list comparison has to compare the list entries which are
in fact the lists themselves,
and then <font face="Gill Sans,Helvetica,Arial">GAP</font> crashes.
<p>
<a name = "SSEC010.2"></a>
<li><code></code><var>list1</var><code> &lt; </code><var>list2</var><code></code>
<br><code>&nbsp;</code><var>list1</var><code> &lt;= </code><var>list2</var><code></code>
<p>
Lists are ordered <strong>lexicographically</strong>.
Unbound entries are smaller than any bound entry.
That implies the following behaviour.
Let <var>i</var> be the smallest positive integer <var>i</var> such that <var>list1</var> and <var>list2</var>
at position <var>i</var> differ,
i.e., either exactly one of <code></code><var>list1</var><code>[i]</code>, <code></code><var>list2</var><code>[i]</code> is bound or both
entries are bound and differ.
Then <var>list1</var> is less than <var>list2</var> if either <code></code><var>list1</var><code>[</code><var>i</var><code>]</code> is unbound
(and <code></code><var>list2</var><code>[</code><var>i</var><code>]</code> is not)
or both are bound and <code></code><var>list1</var><code>[</code><var>i</var><code>] &lt; </code><var>list2</var><code>[</code><var>i</var><code>]</code> is <code>true</code>.
<p>
<pre>
gap&gt; [ 1, 2, 3, 4 ] &lt; [ 1, 2, 4, 8 ]; # &lt;list1&gt;[3] &lt; &lt;list2&gt;[3]
true
gap&gt; [ 1, 2, 3 ] &lt; [ 1, 2, 3, 4 ];    # &lt;list1&gt;[4] is unbound and therefore very small
true
gap&gt; [ 1, , 3, 4 ] &lt; [ 1, 2, 3 ];     # &lt;list1&gt;[2] is unbound and therefore very small
true
</pre>
<p>
Note that for comparing two lists with <code>&lt;</code> or <code>&lt;=</code>,
the (relevant) list elements must be comparable with <code>&lt;</code>,
which is usually <strong>not</strong> the case for objects in different families,
see&nbsp;<a href="CHAP013.htm#SECT001">Families</a>.
Also for the possibility to compare lists with other objects,
see&nbsp;<a href="CHAP013.htm#SECT001">Families</a>.
<p>
<p>
<h2><a name="SECT011">21.11 Arithmetic for Lists</a></h2>
<p><p>
<a name = "I7"></a>

It is convenient to have arithmetic operations for lists,
in particular because in <font face="Gill Sans,Helvetica,Arial">GAP</font>
row vectors and matrices are special kinds of lists.
However, it is the wide variety of list objects because of which we
prescribe arithmetic operations <strong>not for all</strong> of them.
(Keep in mind that ``list'' means just an object in the category <code>IsList</code>,
see&nbsp;<a href="CHAP021.htm#SSEC001.1">IsList</a>.)
<p>
(Due to the intended generality and flexibility,
the definitions given in the following sections are quite technical.
But for not too complicated cases
such as matrices (see&nbsp;<a href="CHAP024.htm#SECT002">Operators for Matrices</a>)
and row vectors (see&nbsp;<a href="CHAP023.htm#SECT001">Operators for Row Vectors</a>) whose entries aren't lists,
the resulting behaviour should be intuitive.)
<p>
For example, we want to deal with matrices which can be added and
multiplied in the usual way, via the infix operators <code>+</code> and <code>*</code>;
and we want also Lie matrices, with the same additive behaviour but with
the multiplication defined by the Lie bracket.
Both kinds of matrices shall be lists, with the usual access to their rows,
with <code>Length</code> (see&nbsp;<a href="CHAP021.htm#SSEC017.5">Length</a>) returning the number of rows etc.
<p>
For the categories and attributes that control the arithmetic behaviour
of lists, see&nbsp;<a href="CHAP021.htm#SECT012">Filters Controlling the Arithmetic Behaviour of Lists</a>.
<p>
For the definition of return values of additive and multiplicative operations
whose arguments are lists in these filters,
see&nbsp;<a href="CHAP021.htm#SECT013">Additive Arithmetic for Lists</a> and
<a href="CHAP021.htm#SECT014">Multiplicative Arithmetic for Lists</a>, respectively.
It should be emphasized that these sections describe only what the return
values are, and not how they are computed.
<p>
For the mutability status of the return values,
see&nbsp;<a href="CHAP021.htm#SECT015">Mutability Status and List Arithmetic</a>.
(Note that this is not dealt with in the sections about the result values.)
<p>
Further details about the special cases of row vectors and matrices
can be found in&nbsp;<a href="CHAP023.htm#SECT001">Operators for Row Vectors</a> and in&nbsp;<a href="CHAP024.htm#SECT002">Operators for Matrices</a>,
the compression status is dealt with in&nbsp;<a href="CHAP023.htm#SECT002">Row Vectors over Finite Fields</a>
and&nbsp;<a href="CHAP024.htm#SECT013">Matrices over Finite Fields</a>.
<p>
<p>
<h2><a name="SECT012">21.12 Filters Controlling the Arithmetic Behaviour of Lists</a></h2>
<p><p>
The arithmetic behaviour of lists is controlled by their types.
The following categories and attributes are used for that.
<p>
Note that we distinguish additive and multiplicative behaviour.
For example, Lie matrices have the usual additive behaviour but not the
usual multiplicative behaviour.
<p>
<a name = "SSEC012.1"></a>
<li><code>IsGeneralizedRowVector( </code><var>list</var><code> ) C</code>
<p>
For a list <var>list</var>, the value <code>true</code> for <code>IsGeneralizedRowVector</code>
indicates that the additive arithmetic behaviour of <var>list</var> is
as defined in&nbsp;<a href="CHAP021.htm#SECT013">Additive Arithmetic for Lists</a>,
and that the attribute <code>NestingDepthA</code> (see&nbsp;<a href="CHAP021.htm#SSEC012.4">NestingDepthA</a>)
will return a nonzero value when called with <var>list</var>.
<p>
<a name = "SSEC012.2"></a>
<li><code>IsMultiplicativeGeneralizedRowVector( </code><var>list</var><code> ) C</code>
<p>
For a list <var>list</var>, the value <code>true</code> for
<code>IsMultiplicativeGeneralizedRowVector</code> indicates that the multiplicative
arithmetic behaviour of <var>list</var> is as defined
in&nbsp;<a href="CHAP021.htm#SECT014">Multiplicative Arithmetic for Lists</a>,
and that the attribute <code>NestingDepthM</code> (see&nbsp;<a href="CHAP021.htm#SSEC012.5">NestingDepthM</a>)
will return a nonzero value when called with <var>list</var>.
<p>
Note that these filters do <strong>not</strong> enable default methods for addition or
multiplication (cf.&nbsp;<a href="CHAP021.htm#SSEC012.3">IsListDefault</a>).
<p>
<pre>
gap&gt; IsList( "abc" ); IsGeneralizedRowVector( "abc" );
true
false
gap&gt; liemat:= LieObject( [ [ 1, 2 ], [ 3, 4 ] ] );
LieObject( [ [ 1, 2 ], [ 3, 4 ] ] )
gap&gt; IsGeneralizedRowVector( liemat );
true
gap&gt; IsMultiplicativeGeneralizedRowVector( liemat );
false
gap&gt; bas:= CanonicalBasis( FullRowSpace( Rationals, 3 ) );
CanonicalBasis( ( Rationals^3 ) )
gap&gt; IsMultiplicativeGeneralizedRowVector( bas );
true
</pre>
<p>
<a name = "SSEC012.3"></a>
<li><code>IsListDefault( </code><var>list</var><code> ) C</code>
<p>
For a list <var>list</var>, <code>IsListDefault</code> indicates that the default methods for
arithmetic operations of lists, such as pointwise addition and
multiplication as inner product or matrix product,
shall be applicable to <var>list</var>.
<p>
<code>IsListDefault</code> implies <code>IsGeneralizedRowVector</code> and
<code>IsMultiplicativeGeneralizedRowVector</code>.
<p>
All internally represented lists are in this category,
and also all lists in the representations <code>IsGF2VectorRep</code>,
<code>Is8BitVectorRep</code>, <code>IsGF2MatrixRep</code>, and <code>Is8BitMatrixRep</code>
(see&nbsp;<a href="CHAP023.htm#SECT002">Row Vectors over Finite Fields</a> and <a href="CHAP024.htm#SECT013">Matrices over Finite Fields</a>).
Note that the result of an arithmetic operation with lists in
<code>IsListDefault</code> will in general be an internally represented list,
so most ``wrapped list objects'' will not lie in <code>IsListDefault</code>.
<p>
<pre>
gap&gt; v:= [ 1, 2 ];;  m:= [ v, 2*v ];;
gap&gt; IsListDefault( v );  IsListDefault( m );
true
true
gap&gt; IsListDefault( bas );  IsListDefault( liemat );
true
false
</pre>
<p>
<a name = "SSEC012.4"></a>
<li><code>NestingDepthA( </code><var>obj</var><code> ) A</code>
<p>
For a <font face="Gill Sans,Helvetica,Arial">GAP</font> object <var>obj</var>,
<code>NestingDepthA</code> returns the <strong>additive nesting depth</strong> of <var>obj</var>.
This is defined recursively
as the integer 0 if <var>obj</var> is not in <code>IsGeneralizedRowVector</code>,
as the integer 1 if <var>obj</var> is an empty list in <code>IsGeneralizedRowVector</code>,
and as 1 plus the additive nesting depth of the first bound entry in
<var>obj</var> otherwise.
<p>
<a name = "SSEC012.5"></a>
<li><code>NestingDepthM( </code><var>obj</var><code> ) A</code>
<p>
For a <font face="Gill Sans,Helvetica,Arial">GAP</font> object <var>obj</var>,
<code>NestingDepthM</code> returns the <strong>multiplicative nesting depth</strong> of <var>obj</var>.
This is defined recursively as the
integer 0 if <var>obj</var> is not in <code>IsMultiplicativeGeneralizedRowVector</code>,
as the integer 1 if <var>obj</var> is an empty list in
<code>IsMultiplicativeGeneralizedRowVector</code>,
and as 1 plus the multiplicative nesting depth of the first bound entry
in <var>obj</var> otherwise.
<p>
<pre>
gap&gt; NestingDepthA( v );  NestingDepthM( v );
1
1
gap&gt; NestingDepthA( m );  NestingDepthM( m );
2
2
gap&gt; NestingDepthA( liemat );  NestingDepthM( liemat );
2
0
gap&gt; l1:= [ [ 1, 2 ], 3 ];;  l2:= [ 1, [ 2, 3 ] ];;
gap&gt; NestingDepthA( l1 );  NestingDepthM( l1 );
2
2
gap&gt; NestingDepthA( l2 );  NestingDepthM( l2 );
1
1
</pre>
<p>
<p>
<h2><a name="SECT013">21.13 Additive Arithmetic for Lists</a></h2>
<p><p>
In this general context, we define the results of additive operations
only in the following situations.
For unary operations (zero and additive inverse),
the unique argument must be in <code>IsGeneralizedRowVector</code>;
for binary operations (addition and subtraction),
at least one argument must be in <code>IsGeneralizedRowVector</code>,
and the other either is not a list or also in <code>IsGeneralizedRowVector</code>.
<p>
(For non-list <font face="Gill Sans,Helvetica,Arial">GAP</font> objects, defining the results of unary operations is not
an issue here,
and if at least one argument is a list not in <code>IsGeneralizedRowVector</code>,
it shall be left to this argument whether the result in question is defined
and what it is.)
<p>
<strong>Zero</strong>
<p>
The zero (see&nbsp;<a href="CHAP030.htm#SSEC010.3">Zero</a>) of a list <i>x</i> in <code>IsGeneralizedRowVector</code>
is defined as the list whose entry at position <i>i</i> is the zero of <i>x</i>[<i>i</i>]
if this entry is bound, and is unbound otherwise.
<p>
<pre>
gap&gt; Zero( [ 1, 2, 3 ] );  Zero( [ [ 1, 2 ], 3 ] );  Zero( liemat );
[ 0, 0, 0 ]
[ [ 0, 0 ], 0 ]
LieObject( [ [ 0, 0 ], [ 0, 0 ] ] )
</pre>
<p>
<strong>AdditiveInverse</strong>
<p>
The additive inverse (see&nbsp;<a href="CHAP030.htm#SSEC010.9">AdditiveInverse</a>) of a list <i>x</i> in
<code>IsGeneralizedRowVector</code> is defined as the list whose entry at position <i>i</i>
is the additive inverse of <i>x</i>[<i>i</i>] if this entry is bound,
and is unbound otherwise.
<p>
<pre>
gap&gt; AdditiveInverse( [ 1, 2, 3 ] );  AdditiveInverse( [ [ 1, 2 ], 3 ] );
[ -1, -2, -3 ]
[ [ -1, -2 ], -3 ]
</pre>
<p>
<strong>Addition</strong>
<p>
<a name = "I8"></a>

If <i>x</i> and <i>y</i> are in <code>IsGeneralizedRowVector</code> and have the same
additive nesting depth (see&nbsp;<a href="CHAP021.htm#SSEC012.4">NestingDepthA</a>),
the sum <i>x</i> + <i>y</i> is defined <strong>pointwise</strong>, in the sense that the result is a
list whose entry at position <i>i</i> is <i>x</i>[<i>i</i>] + <i>y</i>[<i>i</i>] if these entries are bound,
is a shallow copy (see&nbsp;<a href="CHAP012.htm#SSEC007.1">ShallowCopy</a>) of <i>x</i>[<i>i</i>] or <i>y</i>[<i>i</i>] if the other
argument is not bound at position <i>i</i>,
and is unbound if both <i>x</i> and <i>y</i> are unbound at position <i>i</i>.
<p>
If <i>x</i> is in <code>IsGeneralizedRowVector</code> and <i>y</i> is
in <code>IsGeneralizedRowVector</code> and has lower additive nesting depth,
or is neither a list nor a domain,
the sum <i>x</i> + <i>y</i> is defined as a list whose entry at position <i>i</i> is
<i>x</i>[<i>i</i>] + <i>y</i> if <i>x</i> is bound at position <i>i</i>, and is unbound if not.
The equivalent holds in the reversed case,
where the order of the summands is kept,
as addition is not always commutative.
<p>
<pre>
gap&gt; 1 + [ 1, 2, 3 ];  [ 1, 2, 3 ] + [ 0, 2, 4 ];  [ 1, 2 ] + [ Z(2) ];
[ 2, 3, 4 ]
[ 1, 4, 7 ]
[ 0*Z(2), 2 ]
gap&gt; l1:= [ 1, , 3, 4 ];;             l2:= [ , 2, 3, 4, 5 ];;
gap&gt; l3:= [ [ 1, 2 ], , [ 5, 6 ] ];;  l4:= [ , [ 3, 4 ], [ 5, 6 ] ];;
gap&gt; NestingDepthA( l1 );  NestingDepthA( l2 );
1
1
gap&gt; NestingDepthA( l3 );  NestingDepthA( l4 );
2
2
gap&gt; l1 + l2;
[ 1, 2, 6, 8, 5 ]
gap&gt; l1 + l3;
[ [ 2, 2, 3, 4 ],, [ 6, 6, 3, 4 ] ]
gap&gt; l2 + l4;
[ , [ 3, 6, 3, 4, 5 ], [ 5, 8, 3, 4, 5 ] ]
gap&gt; l3 + l4;
[ [ 1, 2 ], [ 3, 4 ], [ 10, 12 ] ]
gap&gt; l1 + [];
[ 1,, 3, 4 ]
</pre>
<p>
<strong>Subtraction</strong>
<p>
<a name = "I9"></a>

For two <font face="Gill Sans,Helvetica,Arial">GAP</font> objects <i>x</i> and <i>y</i> of which one is in
<code>IsGeneralizedRowVector</code> and the other is also in <code>IsGeneralizedRowVector</code>
or is neither a list nor a domain, <i>x</i> &#8722; <i>y</i> is defined as <i>x</i> + (&#8722;<i>y</i>).
<p>
<pre>
gap&gt; l1 - l2;
[ 1, -2, 0, 0, -5 ]
gap&gt; l1 - l3;
[ [ 0, -2, 3, 4 ],, [ -4, -6, 3, 4 ] ]
gap&gt; l2 - l4;
[ , [ -3, -2, 3, 4, 5 ], [ -5, -4, 3, 4, 5 ] ]
gap&gt; l3 - l4;
[ [ 1, 2 ], [ -3, -4 ], [ 0, 0 ] ]
gap&gt; l1 - [];
[ 1,, 3, 4 ]
</pre>
<p>
<p>
<h2><a name="SECT014">21.14 Multiplicative Arithmetic for Lists</a></h2>
<p><p>
In this general context, we define the results of multiplicative operations
only in the following situations.
For unary operations (one and inverse),
the unique argument must be in <code>IsMultiplicativeGeneralizedRowVector</code>;
for binary operations (multiplication and division),
at least one argument must be in <code>IsMultiplicativeGeneralizedRowVector</code>,
and the other either not a list or also in
<code>IsMultiplicativeGeneralizedRowVector</code>.
<p>
(For non-list <font face="Gill Sans,Helvetica,Arial">GAP</font> objects, defining the results of unary operations is not
an issue here, and if at least one argument is a list not in
<code>IsMultiplicativeGeneralizedRowVector</code>,
it shall be left to this argument whether the result in question is defined
and what it is.)
<p>
<strong>One</strong>
<p>
The one (see&nbsp;<a href="CHAP030.htm#SSEC010.2">One</a>) of a dense list <i>x</i> in
<code>IsMultiplicativeGeneralizedRowVector</code> such that <i>x</i> has even multiplicative
nesting depth and has the same length as each of its rows is defined
as the usual identity matrix on the outer two levels,
that is, an identity matrix of the same dimensions, with diagonal entries
<tt>One</tt>( <i>x</i>[1][1] ) and off-diagonal entries <tt>Zero</tt>( <i>x</i>[1][1] ).
<p>
<pre>
gap&gt; One( [ [ 1, 2 ], [ 3, 4 ] ] );
[ [ 1, 0 ], [ 0, 1 ] ]
gap&gt; One( [ [ [ [ 1 ] ], [ [ 2 ] ] ], [ [ [ 3 ] ], [ [ 4 ] ] ] ] );
[ [ [ [ 1 ] ], [ [ 0 ] ] ], [ [ [ 0 ] ], [ [ 1 ] ] ] ]
</pre>
<p>
<strong>Inverse</strong>
<p>
The inverse (see&nbsp;<a href="CHAP030.htm#SSEC010.8">Inverse</a>) of an invertible square table <i>x</i> in
<code>IsMultiplicativeGeneralizedRowVector</code> whose entries lie in a common field
is defined as the usual inverse <i>y</i>, i.e.,
a square matrix over the same field such that <i>x</i> <i>y</i> and <i>y</i> <i>x</i> is equal to
<tt>One</tt>( <i>x</i> ).
<p>
<pre>
gap&gt; Inverse( [ [ 1, 2 ], [ 3, 4 ] ] );
[ [ -2, 1 ], [ 3/2, -1/2 ] ]
</pre>
<p>
<strong>Multiplication</strong>
<p>
<a name = "I10"></a>

There are three possible computations that might be triggered by a
multiplication involving a list in <code>IsMultiplicativeGeneralizedRowVector</code>.
Namely, <i>x</i> * <i>y</i> might be
<dl compact>
<dt>(I)<dd>
    the inner product <i>x</i>[1] * <i>y</i>[1] + <i>x</i>[2] * <i>y</i>[2] + &#8230;+ <i>x</i>[<i>n</i>] * <i>y</i>[<i>n</i>],
    where summands are omitted for which the entry in <i>x</i> or <i>y</i> is unbound
    (if this leaves no summand then the multiplication is an error),
    or
<dt>(L)<dd>
    the left scalar multiple, i.e., a list whose entry at position <i>i</i> is
    <i>x</i> * <i>y</i>[<i>i</i>] if <i>y</i> is bound at position <i>i</i>, and is unbound if not, or
<dt>(R)<dd>
    the right scalar multiple, i.e., a list whose entry at position <i>i</i> is
    <i>x</i>[<i>i</i>] * <i>y</i> if <i>x</i> is bound at position <i>i</i>, and is unbound if not.
</dl>
<p>
Our aim is to generalize the basic arithmetic of simple row vectors and
matrices, so we first summarize the situations that shall be covered.
<p>
<pre>
    | scl   vec   mat
---------------------
scl |       (L)   (L)
vec | (R)   (I)   (I)
mat | (R)   (R)   (R)
</pre>
<p>
This means for example that the product of a scalar (scl) with a vector (vec)
or a matrix (mat) is computed according to (L).
Note that this is asymmetric.
<p>
Now we can state the general multiplication rules.
<p>
If exactly one argument is in <code>IsMultiplicativeGeneralizedRowVector</code>
then we regard the other argument (which is then neither a list nor a domain)
as a scalar, and specify result (L) or (R), depending on ordering.
<p>
In the remaining cases, both <i>x</i> and <i>y</i> are in
<code>IsMultiplicativeGeneralizedRowVector</code>, and we distinguish the possibilities
by their multiplicative nesting depths.
An argument with <strong>odd</strong> multiplicative nesting depth is regarded as a vector,
and an argument with <strong>even</strong> multiplicative nesting depth is regarded as a
scalar or a matrix.
<p>
So if both arguments have odd multiplicative nesting depth,
we specify result (I).
<p>
If exactly one argument has odd nesting depth,
the other is treated as a scalar if it has lower multiplicative nesting
depth, and as a matrix otherwise.
In the former case, we specify result (L) or (R), depending on ordering;
in the latter case, we specify result (L) or (I), depending on ordering.
<p>
We are left with the case that each argument has even multiplicative
nesting depth.
If the two depths are equal, we treat the computation as a matrix product,
and specify result (R).
Otherwise, we treat the less deeply nested argument as a scalar and the other
as a matrix, and specify result (L) or (R), depending on ordering.
<p>
<pre>
gap&gt; [ (), (2,3), (1,2), (1,2,3), (1,3,2), (1,3) ] * (1,4);
[ (1,4), (1,4)(2,3), (1,2,4), (1,2,3,4), (1,3,2,4), (1,3,4) ]
gap&gt; [ 1, 2, , 4 ] * 2;
[ 2, 4,, 8 ]
gap&gt; [ 1, 2, 3 ] * [ 1, 3, 5, 7 ];
22
gap&gt; m:= [ [ 1, 2 ], 3 ];;  m * m;
[ [ 7, 8 ], [ [ 3, 6 ], 9 ] ]
gap&gt; m * m = [ m[1] * m, m[2] * m ];
true
gap&gt; n:= [ 1, [ 2, 3 ] ];;  n * n;
14
gap&gt; n * n = n[1] * n[1] + n[2] * n[2];
true
</pre>
<p>
<strong>Division</strong>
<p>
<a name = "I11"></a>

For two <font face="Gill Sans,Helvetica,Arial">GAP</font> objects <i>x</i> and <i>y</i> of which one is in
<code>IsMultiplicativeGeneralizedRowVector</code> and the other is also in
<code>IsMultiplicativeGeneralizedRowVector</code> or is neither a list nor a domain,
<i>x</i> / <i>y</i> is defined as <i>x</i> * <i>y</i><sup>&#8722;1</sup>.
<p>
<pre>
gap&gt; [ 1, 2, 3 ] / 2;  [ 1, 2 ] / [ [ 1, 2 ], [ 3, 4 ] ];
[ 1/2, 1, 3/2 ]
[ 1, 0 ]
</pre>
<p>
<strong>mod</strong>
<p>
<a name = "I12"></a>

<a name = "I13"></a>

If <i>x</i> and <i>y</i> are in <code>IsMultiplicativeGeneralizedRowVector</code> and have the
same multiplicative nesting depth (see&nbsp;<a href="CHAP021.htm#SSEC012.5">NestingDepthM</a>),
<i>x</i> <tt>mod</tt> <i>y</i> is defined <strong>pointwise</strong>, in the sense that the result is a
list whose entry at position <i>i</i> is <i>x</i>[<i>i</i>] <tt>mod</tt> <i>y</i>[<i>i</i>] if these entries are
bound,
is a shallow copy (see&nbsp;<a href="CHAP012.htm#SSEC007.1">ShallowCopy</a>) of <i>x</i>[<i>i</i>] or <i>y</i>[<i>i</i>] if the other
argument is not bound at position <i>i</i>,
and is unbound if both <i>x</i> and <i>y</i> are unbound at position <i>i</i>.
<p>
If <i>x</i> is in <code>IsMultiplicativeGeneralizedRowVector</code> and <i>y</i> is in
<code>IsMultiplicativeGeneralizedRowVector</code> and has lower multiplicative
nesting depth or is neither a list nor a domain,
<i>x</i> <tt>mod</tt> <i>y</i> is defined as a list whose entry at position <i>i</i> is
<i>x</i>[<i>i</i>] <tt>mod</tt> <i>y</i> if <i>x</i> is bound at position <i>i</i>, and is unbound if not.
The equivalent holds in the reversed case,
where the order of the arguments is kept.
<p>
<pre>
gap&gt; 4711 mod [ 2, 3,, 5, 7 ];
[ 1, 1,, 1, 0 ]
gap&gt; [ 2, 3, 4, 5, 6 ] mod 3;
[ 2, 0, 1, 2, 0 ]
gap&gt; [ 10, 12, 14, 16 ] mod [ 3, 5, 7 ];
[ 1, 2, 0, 16 ]
</pre>
<p>
<strong>Left Quotient</strong>
<p>
<a name = "I14"></a>

For two <font face="Gill Sans,Helvetica,Arial">GAP</font> objects <i>x</i> and <i>y</i> of which one is in
<code>IsMultiplicativeGeneralizedRowVector</code> and the other is also in
<code>IsMultiplicativeGeneralizedRowVector</code> or is neither a list nor a domain,
<tt>LeftQuotient</tt>( <i>x</i>, <i>y</i> ) is defined as <i>x</i><sup>&#8722;1</sup> * <i>y</i>.
<p>
<pre>
gap&gt; LeftQuotient( [ [ 1, 2 ], [ 3, 4 ] ], [ 1, 2 ] );
[ 0, 1/2 ]
</pre>
<p>
<p>
<h2><a name="SECT015">21.15 Mutability Status and List Arithmetic</a></h2>
<p><p>
Many results of arithmetic operations, when applied to lists,
are again lists, and it is of interest whether their entries are mutable
or not (if applicable).
Note that the mutability status of the result itself is already defined
by the general rule for any result of an arithmetic operation, not
only for lists (see&nbsp;<a href="CHAP012.htm#SECT006">Mutability and Copyability</a>).
<p>
However, we do <strong>not</strong> define exactly the mutability status for each element
on each level of a nested list returned by an arithmetic operation.
(Of course it would be possible to define this recursively,
but since the methods used are in general not recursive,
in particular for efficient multiplication of compressed matrices,
such a general definition would be a burden in these cases.)
Instead we consider, for a list <i>x</i> in <code>IsGeneralizedRowVector</code>,
the sequence <i>x</i> = <i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, &#8230;<i>x</i><sub><i>n</i></sub> where <i>x</i><sub><i>i</i>+1</sub> is the first bound
entry in <i>x</i><sub><i>i</i></sub> if exists (that is, if <i>x</i><sub><i>i</i></sub> is a nonempty list),
and <i>n</i> is the largest <i>i</i> such that <i>x</i><sub><i>i</i></sub> lies in <code>IsGeneralizedRowVector</code>.
The <strong>immutability level</strong> of <i>x</i> is defined as infinity if <i>x</i> is immutable,
and otherwise the number of <i>x</i><sub><i>i</i></sub> which are immutable.
(So the immutability level of a mutable empty list is 0.)
<p>
Thus a fully mutable matrix has immutability level 0,
and a mutable matrix with immutable first row has immutability level 1
(independent of the mutability of other rows).
<p>
The immutability level of the result of any of the binary operations
discussed here is the minimum of the immutability levels of the arguments,
provided that objects of the required mutability status exist in <font face="Gill Sans,Helvetica,Arial">GAP</font>.
<p>
Moreover, the results have a ``homogeneous'' mutability status,
that is, if the first bound entry at nesting depth <i>i</i> is immutable (mutable)
then all entries at nesting depth <i>i</i> are immutable (mutable, provided that
a mutable version of this entry exists in <font face="Gill Sans,Helvetica,Arial">GAP</font>).
<p>
Thus the sum of two mutable matrices whose first rows are mutable
is a matrix all of whose rows are mutable,
and the product of two matrices whose first rows are immutable
is a matrix all of whose rows are immutable,
independent of the mutability status of the other rows of the arguments.
<p>
For example, the sum of a matrix (mutable or immutable, i.e.,
of immutability level one of 0, 1, or 2) and a mutable row vector
(i.e., immutability level 0) is a fully mutable matrix.
The product of two mutable row vectors of integers is an integer,
and since <font face="Gill Sans,Helvetica,Arial">GAP</font> does not support mutable integers, the result is immutable.
<p>
For unary arithmetic operations, there are three operations available,
an attribute that returns an immutable result
(<code>Zero</code>, <code>AdditiveInverse</code>, <code>One</code>, <code>Inverse</code>),
an operation that returns a result that is mutable
(<code>ZeroOp</code>, <code>AdditiveInverseOp</code>, <code>OneOp</code>, <code>InverseOp</code>),
and an operation whose result has the same immutability level as the argument
(<code>ZeroSM</code>, <code>AdditiveInverseSM</code>, <code>OneSM</code>, <code>InverseSM</code>).
The last kind of operations is equivalent to the corresponding infix
operations <code>0 * </code><var>list</var><code></code>, <code>- </code><var>list</var><code></code>, <code></code><var>list</var><code>^0</code>, and <code></code><var>list</var><code>^-1</code>.
(This holds not only for lists, see&nbsp;<a href="CHAP012.htm#SECT006">Mutability and Copyability</a>.)
<p>
<pre>
gap&gt; IsMutable( l1 );  IsMutable( 2 * Immutable( [ 1, 2, 3 ] ) );
true
false
gap&gt; IsMutable( l2 );  IsMutable( l3 );
true
true
</pre>
<p>
An example motivating the mutability rule is the use of syntactic constructs
such as <code></code><var>obj</var><code> * </code><var>list</var><code></code> and <code>- </code><var>list</var><code></code> as an elegant and efficient way to
create mutable lists needed for further manipulations from mutable lists.
In particular one can construct a mutable zero vector of length <var>n</var>
by <code>0 * [ 1 .. </code><var>n</var><code> ]</code>.
The latter can be done also using <code>ListWithIdenticalEntries</code>.
<p>
<a name = "SSEC015.1"></a>
<li><code>ListWithIdenticalEntries( </code><var>n</var><code>, </code><var>obj</var><code> ) F</code>
<p>
is a list <var>list</var> of length <var>n</var> that has the object <var>obj</var> stored at each
of the positions from 1 to <var>n</var>.
Note that all elements of <var>lists</var> are identical, see&nbsp;<a href="CHAP021.htm#SECT006">Identical Lists</a>.
<p>
<pre>
gap&gt; ListWithIdenticalEntries( 10, 0 );
[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
</pre>
<p>
<p>
<h2><a name="SECT016">21.16 Finding Positions in Lists</a></h2>
<p><p>
<a name = "SSEC016.1"></a>
<li><code>Position( </code><var>list</var><code>, </code><var>obj</var><code>[, </code><var>from</var><code>] ) O</code>
<p>
returns the position of the first occurrence <var>obj</var> in <var>list</var>,
or <var>fail</var> if <var>obj</var> is not contained in <var>list</var>.
If a starting index <var>from</var> is given, it
returns the position of the first occurrence starting the search <strong>after</strong>
position <var>from</var>.
<p>
Each call to the two argument version is translated into a call of the
three argument version, with third argument the integer zero <code>0</code>.
(Methods for the two argument version must be installed as methods for
the version with three arguments, the third being described by
<code>IsZeroCyc</code>.)
<p>
<pre>
gap&gt; Position( [ 2, 2, 1, 3 ], 1 );
3
gap&gt; Position( [ 2, 1, 1, 3 ], 1 );
2
gap&gt; Position( [ 2, 1, 1, 3 ], 1, 2 );
3
gap&gt; Position( [ 2, 1, 1, 3 ], 1, 3 );
fail
</pre>
<p>
<a name = "SSEC016.2"></a>
<li><code>Positions( </code><var>list</var><code>, </code><var>obj</var><code> ) F</code>
<a name = "SSEC016.2"></a>
<li><code>PositionsOp( </code><var>list</var><code>, </code><var>obj</var><code> ) O</code>
<p>
returns the positions of <strong>all</strong> occurrences of <var>obj</var> in <var>list</var>.
<p>
<pre>
gap&gt; Positions([1,2,1,2,3,2,2],2);
[ 2, 4, 6, 7 ]
gap&gt; Positions([1,2,1,2,3,2,2],4);
[  ]
</pre>
<p>
<a name = "SSEC016.3"></a>
<li><code>PositionCanonical( </code><var>list</var><code>, </code><var>obj</var><code> ) O</code>
<p>
returns the position of the canonical associate of <var>obj</var> in <var>list</var>.
The definition of this associate depends on <var>list</var>.
For internally represented lists it is defined as the element itself
(and <code>PositionCanonical</code> thus defaults to <code>Position</code>, see&nbsp;<a href="CHAP021.htm#SSEC016.1">Position</a>),
but for example for certain enumerators (see&nbsp;<a href="CHAP021.htm#SECT023">Enumerators</a>) other
canonical associates can be defined.
<p>
For example <code>RightTransversal</code> defines the canonical associate to be the
element in the transversal defining the same coset of a subgroup in a
group.
<p>
<pre>
gap&gt; g:=Group((1,2,3,4),(1,2));;u:=Subgroup(g,[(1,2)(3,4),(1,3)(2,4)]);;
gap&gt; rt:=RightTransversal(g,u);;AsList(rt);
[ (), (3,4), (2,3), (2,3,4), (2,4,3), (2,4) ]
gap&gt; Position(rt,(1,2));
fail
gap&gt; PositionCanonical(rt,(1,2));
2
</pre>
<p>
<a name = "SSEC016.4"></a>
<li><code>PositionNthOccurrence( </code><var>list</var><code>, </code><var>obj</var><code>, </code><var>n</var><code> ) O</code>
<p>
returns the position of the <var>n</var>-th occurrence of <var>obj</var> in <var>list</var> and
returns <code>fail</code> if <var>obj</var> does not occur <var>n</var> times.
<p>
<pre>
gap&gt; PositionNthOccurrence([1,2,3,2,4,2,1],1,1);
1
gap&gt; PositionNthOccurrence([1,2,3,2,4,2,1],1,2);
7
gap&gt; PositionNthOccurrence([1,2,3,2,4,2,1],2,3);
6
gap&gt; PositionNthOccurrence([1,2,3,2,4,2,1],2,4);
fail
</pre>
<p>
<a name = "SSEC016.5"></a>
<li><code>PositionSorted( </code><var>list</var><code>, </code><var>elm</var><code> ) F</code>
<li><code>PositionSorted( </code><var>list</var><code>, </code><var>elm</var><code>, </code><var>func</var><code> ) F</code>
<p>
In the first form <code>PositionSorted</code> returns the position of the element
<var>elm</var> in the sorted list <var>list</var>.
<p>
In the second form <code>PositionSorted</code> returns the position of the element
<var>elm</var> in the list <var>list</var>, which must be sorted with respect to <var>func</var>.
<var>func</var> must be a function of two arguments that returns <code>true</code> if the
first argument is less than the second argument and <code>false</code> otherwise.
<p>
<code>PositionSorted</code> returns <var>pos</var> such that <i>list</i> [<i>pos</i> &#8722;1]  &lt;  <i>elm</i>  and
<i>elm</i>   &#8804; <i>list</i> [<i>pos</i> ].
That means, if <var>elm</var> appears once in <var>list</var>, its position is returned.
If <var>elm</var> appears several times in <var>list</var>, the position of the first
occurrence is returned.
If <var>elm</var> is not an element of <var>list</var>, the index where <var>elm</var> must be
inserted to keep the list sorted is returned.
<p>
<code>PositionSorted</code> uses binary search, whereas <code>Position</code> can in general
use only linear search, see the remark at the beginning
of&nbsp;<a href="CHAP021.htm#SECT019">Sorted Lists and Sets</a>.
For sorting lists, see&nbsp;<a href="CHAP021.htm#SECT018">Sorting Lists</a>,
for testing whether a list is sorted, see&nbsp;<a href="CHAP021.htm#SSEC017.3">IsSortedList</a> and
<a href="CHAP021.htm#SSEC017.4">IsSSortedList</a>.
<p>
Specialized functions for certain kinds of lists must be installed 
as methods for the operation <code>PositionSortedOp</code>.
<p>
we catch plain lists by a function to avoid method selection
<p>
<pre>
gap&gt; PositionSorted( [1,4,5,5,6,7], 0 );
1
gap&gt; PositionSorted( [1,4,5,5,6,7], 2 );
2
gap&gt; PositionSorted( [1,4,5,5,6,7], 4 );
2
gap&gt; PositionSorted( [1,4,5,5,6,7], 5 );
3
gap&gt; PositionSorted( [1,4,5,5,6,7], 8 );
7
</pre>
<p>
<a name = "SSEC016.6"></a>
<li><code>PositionSet( </code><var>list</var><code>, </code><var>obj</var><code> ) F</code>
<li><code>PositionSet( </code><var>list</var><code>, </code><var>obj</var><code>, </code><var>func</var><code> ) F</code>
<p>
<code>PositionSet</code> is a slight variation of <code>PositionSorted</code>.
The only difference to <code>PositionSorted</code> is that <code>PositionSet</code> returns
<code>fail</code> if <var>obj</var> is not in <var>list</var>.
<p>
<pre>
gap&gt; PositionSet( [1,4,5,5,6,7], 0 );
fail
gap&gt; PositionSet( [1,4,5,5,6,7], 2 );
fail
gap&gt; PositionSet( [1,4,5,5,6,7], 4 );
2
gap&gt; PositionSet( [1,4,5,5,6,7], 5 );
3
gap&gt; PositionSet( [1,4,5,5,6,7], 8 );
fail
</pre>
<p>
<a name = "SSEC016.7"></a>
<li><code>PositionProperty( </code><var>list</var><code>, </code><var>func</var><code> ) O</code>
<p>
returns the first position of an element in the list <var>list</var> for which the
property tester function <var>func</var> returns <code>true</code>.
<p>
<pre>
gap&gt; PositionProperty( [10^7..10^8], IsPrime );
20
gap&gt; PositionProperty( [10^5..10^6],
&gt;        n -&gt; not IsPrime(n) and IsPrimePowerInt(n) );
490
</pre>
<code>First</code> (see&nbsp;<a href="CHAP021.htm#SSEC020.20">First</a>) allows you to extract the first element of a list
that satisfies a certain property.
<p>
<a name = "SSEC016.8"></a>
<li><code>PositionBound( </code><var>list</var><code> ) O</code>
<p>
returns the first index for which an element is bound in the list <var>list</var>.
For the empty list it returns <code>fail</code>.
<p>
<pre>
gap&gt; PositionBound([1,2,3]);
1
gap&gt; PositionBound([,1,2,3]);
2
</pre>
<p>
<a name = "SSEC016.9"></a>
<li><code>PositionNot( </code><var>list</var><code>, </code><var>val</var><code>[, </code><var>from-minus-one</var><code>] ) O</code>
<p>
For a list <var>list</var> and an object <var>val</var>, <code>PositionNot</code> returns the smallest
nonnegative integer <i>n</i> such that <i>list</i> [<i>n</i>] is either unbound or
not equal to <var>val</var>.
If a nonnegative integer is given as optional argument <var>from-minus-one</var>
then the first position larger than <var>from-minus-one</var> with this property
is returned.
<p>
<a name = "SSEC016.10"></a>
<li><code>PositionNonZero( </code><var>vec</var><code> ) O</code>
<p>
For a row vector <var>vec</var>, <code>PositionNonZero</code> returns the position of the
first non-zero element of <var>vec</var>, or <code>Length(</code><var>vec</var><code>)+1</code> if all entries of
<var>vec</var> are zero.
<p>
<code>PositionNonZero</code> implements a special case of <code>PositionNot</code>
(see&nbsp;<a href="CHAP021.htm#SSEC016.9">PositionNot</a>).
Namely, the element to be avoided is the zero element,
and the list must be (at least) homogeneous
because otherwise the zero element cannot be specified implicitly.
<p>
<pre>
gap&gt; l:= [ 1, 1, 2, 3, 2 ];;  PositionNot( l, 1 );
3
gap&gt; PositionNot( l, 1, 4 );  PositionNot( l, 2, 5 );
5
6
gap&gt; PositionNonZero( l );  PositionNonZero( [ 2, 3, 4, 5 ] * Z(2) );
1
2
</pre>
<p>
<a name = "SSEC016.11"></a>
<li><code>PositionSublist( </code><var>list</var><code>, </code><var>sub</var><code> ) O</code>
<li><code>PositionSublist( </code><var>list</var><code>, </code><var>sub</var><code>, </code><var>from</var><code> ) O</code>
<p>
returns the smallest index in the list <var>list</var> at which a sublist equal to
<var>sub</var> starts.
If <var>sub</var> does not occur the operation returns <code>fail</code>.
The second version starts searching <strong>after</strong> position <var>from</var>.
<p>
To determine whether <var>sub</var> matches <var>list</var> at a  particular position, use 
<code>IsMatchingSublist</code> instead (see <a href="CHAP021.htm#SSEC017.1">IsMatchingSublist</a>).
<p>
<a name = "SSEC016.12"></a>
<li><code>PositionFirstComponent( </code><var>list</var><code>, </code><var>obj</var><code> ) O</code>
<p>
returns the index <var>i</var> in <var>list</var> such that <i>list</i> [<i>i</i> ][1]=<i>obj</i>  or the 
place where such an entry should be added (cf PositionSorted).
<p>
<p>
<h2><a name="SECT017">21.17 Properties and Attributes for Lists</a></h2>
<p><p>
<a name = "SSEC017.1"></a>
<li><code>IsMatchingSublist( </code><var>list</var><code>, </code><var>sub</var><code> ) O</code>
<li><code>IsMatchingSublist( </code><var>list</var><code>, </code><var>sub</var><code>, </code><var>at</var><code> ) O</code>
<p>
returns <code>true</code> if <var>sub</var> matches a sublist of <var>list</var> from position 1 (or
position <var>at</var>, in the case of the second version), or <code>false</code>, otherwise. 
If <var>sub</var> is empty <code>true</code> is returned. If <var>list</var> is empty but <var>sub</var> is
non-empty <code>false</code> is returned.
<p>
If you actually want to know whether there is an <var>at</var> for which
<code>IsMatchingSublist( </code><var>list</var><code>, </code><var>sub</var><code>, </code><var>at</var><code> )</code> is true, use a construction
like <code>PositionSublist( </code><var>list</var><code>, </code><var>sub</var><code> ) </code><var></var><code> fail</code> instead 
(see <a href="CHAP021.htm#SSEC016.11">PositionSublist</a>); it's more efficient.
<p>
<strong>Note:</strong> A list that contains mutable objects (like lists or records)
<strong>cannot</strong> store attribute values that depend on the values of its entries,
such as whether it is homogeneous, sorted, or strictly sorted,
as changes in any of its entries could change such property values,
like the following example shows.
<pre>
gap&gt; l:=[[1],[2]];
[ [ 1 ], [ 2 ] ]
gap&gt; IsSSortedList(l);
true
gap&gt; l[1][1]:=3;
3
gap&gt; IsSSortedList(l);
false
</pre>
For such lists these property values must be computed anew
each time the property is asked for.
For example, if <var>list</var> is a list of mutable row vectors then the call of
<code>Position</code> (see&nbsp;<a href="CHAP021.htm#SSEC016.1">Position</a>) with <var>list</var> as first argument
cannot take advantage of the fact that <var>list</var> is in fact sorted.
One solution is to call explicitly <code>PositionSorted</code> (see&nbsp;<a href="CHAP021.htm#SSEC016.5">PositionSorted</a>)
in such a situation, another solution is to replace <var>list</var> by an immutable
copy using <code>Immutable</code> (see&nbsp;<a href="CHAP012.htm#SECT006">Mutability and Copyability</a>).
<p>
<a name = "SSEC017.2"></a>
<li><code>IsDuplicateFree( </code><var>obj</var><code> ) P</code>
<a name = "SSEC017.2"></a>
<li><code>IsDuplicateFreeList( </code><var>obj</var><code> ) P</code>
<p>
<code>IsDuplicateFree(</code><var>obj</var><code>);</code> returns <code>true</code> if  <var>obj</var>  is  both  a  list  or
collection, and it is duplicate free; otherwise it returns <code>false</code>.
<code>IsDuplicateFreeList</code> is a synonym for <code>IsDuplicateFree and IsList</code>.
<p>
<a name = "I15"></a>

A list is <strong>duplicate free</strong> if it is dense and does not contain equal
entries in different positions.
Every domain (see&nbsp;<a href="CHAP012.htm#SECT004">Domains</a>) is duplicate free.
<p>
<a name = "SSEC017.3"></a>
<li><code>IsSortedList( </code><var>obj</var><code> ) P</code>
<p>
returns <code>true</code> if <var>obj</var> is a list and it is sorted, or <code>false</code> otherwise.
<p>
<a name = "I16"></a>

A list <var>list</var> is <strong>sorted</strong> if it is dense (see&nbsp;<a href="CHAP021.htm#SSEC001.2">IsDenseList</a>)
and satisfies the relation <i>list</i> [<i>i</i>]  &#8804; <i>list</i> [<i>j</i>] whenever <i>i</i>  &lt;  <i>j</i>.
Note that a sorted list is not necessarily duplicate free
(see&nbsp;<a href="CHAP021.htm#SSEC017.2">IsDuplicateFree</a> and <a href="CHAP021.htm#SSEC017.4">IsSSortedList</a>).
<p>
Many sorted lists are in fact homogeneous (see&nbsp;<a href="CHAP021.htm#SSEC001.3">IsHomogeneousList</a>),
but also non-homogeneous lists may be sorted
(see&nbsp;<a href="CHAP030.htm#SECT011">Comparison Operations for Elements</a>).
<p>
<a name = "SSEC017.4"></a>
<li><code>IsSSortedList( </code><var>obj</var><code> ) P</code>
<a name = "SSEC017.4"></a>
<li><code>IsSet( </code><var>obj</var><code> ) P</code>
<p>
returns <code>true</code> if <var>obj</var> is a list and it is strictly sorted,  or  <code>false</code>
otherwise. <code>IsSSortedList</code> is short  for  ``is  strictly  sorted  list'';
<code>IsSet</code> is just a synonym for <code>IsSSortedList</code>.
<p>
<a name = "I17"></a>

A list <var>list</var> is <strong>strictly sorted</strong> if it is sorted (see&nbsp;<a href="CHAP021.htm#SSEC017.3">IsSortedList</a>)
and satisfies the relation <i>list</i> [<i>i</i>]  &lt; <i>list</i> [<i>j</i>] whenever <i>i</i> &lt;  <i>j</i>.
In particular, such lists are duplicate free (see&nbsp;<a href="CHAP021.htm#SSEC017.2">IsDuplicateFree</a>).
<p>
In sorted lists, membership test and computing of positions can be done
by binary search, see&nbsp;<a href="CHAP021.htm#SECT019">Sorted Lists and Sets</a>.
<p>
(Currently there is little special treatment of lists that are sorted
but not strictly sorted.
In particular, internally represented lists will <strong>not</strong> store that they
are sorted but not strictly sorted.)
<p>
<a name = "SSEC017.5"></a>
<li><code>Length( </code><var>list</var><code> ) A</code>
<p>
returns the <strong>length</strong> of the list <var>list</var>, which is defined to be the index
of the last bound entry in <var>list</var>.
<p>
<a name = "SSEC017.6"></a>
<li><code>ConstantTimeAccessList( </code><var>list</var><code> ) A</code>
<p>
<code>ConstantTimeAccessList</code> returns an immutable list containing the same
elements as the list <var>list</var> (which may have holes) in the same order.
If <var>list</var> is already a constant time access list,
<code>ConstantTimeAccessList</code> returns an immutable copy of <var>list</var> directly.
Otherwise it puts all elements and holes of <var>list</var> into a new list and
makes that list immutable.
<p>
<p>
<h2><a name="SECT018">21.18 Sorting Lists</a></h2>
<p><p>
<a name = "SSEC018.1"></a>
<li><code>Sort( </code><var>list</var><code> ) O</code>
<li><code>Sort( </code><var>list</var><code>, </code><var>func</var><code> ) O</code>
<p>
sorts the list <var>list</var> in increasing order.
In the first form <code>Sort</code> uses the operator <code>&lt;</code> to compare the elements.
(If the list is not homogeneous it is the users responsibility to ensure
that <code>&lt;</code> is defined for all element pairs, see&nbsp;<a href="CHAP030.htm#SECT011">Comparison Operations for Elements</a>)
In the second form <code>Sort</code> uses the function <var>func</var> to compare elements.
<var>func</var> must be a function taking two arguments that returns <code>true</code>
if the first is regarded as strictly smaller than the second,
and <code>false</code> otherwise.
<p>
<code>Sort</code> does not return anything, it just changes the argument <var>list</var>.
Use  <code>ShallowCopy</code> (see <a href="CHAP012.htm#SSEC007.1">ShallowCopy</a>) if you  want to keep  <var>list</var>.  Use
<code>Reversed</code>  (see  <a href="CHAP021.htm#SSEC020.7">Reversed</a>) if you  want to  get a  new  list sorted in
decreasing order.
<p>
It is possible to sort lists that contain multiple elements which compare
equal.    It is not  guaranteed  that those  elements keep their relative
order, i.e., <code>Sort</code> is not stable.
<p>
<pre>
gap&gt; list := [ 5, 4, 6, 1, 7, 5 ];; Sort( list ); list;
[ 1, 4, 5, 5, 6, 7 ]
gap&gt; list := [ [0,6], [1,2], [1,3], [1,5], [0,4], [3,4] ];;
gap&gt; Sort( list, function(v,w) return v*v &lt; w*w; end );
gap&gt; list;  # sorted according to the Euclidian distance from [0,0]
[ [ 1, 2 ], [ 1, 3 ], [ 0, 4 ], [ 3, 4 ], [ 1, 5 ], [ 0, 6 ] ]
gap&gt; list := [ [0,6], [1,3], [3,4], [1,5], [1,2], [0,4], ];;
gap&gt; Sort( list, function(v,w) return v[1] &lt; w[1]; end );
gap&gt; list;  # note the random order of the elements with equal first component
[ [ 0, 6 ], [ 0, 4 ], [ 1, 3 ], [ 1, 5 ], [ 1, 2 ], [ 3, 4 ] ]
</pre>
<p>
<a name = "SSEC018.2"></a>
<li><code>SortParallel( </code><var>list</var><code>, </code><var>list2</var><code> ) O</code>
<li><code>SortParallel( </code><var>list</var><code>, </code><var>list2</var><code>, </code><var>func</var><code> ) O</code>
<p>
sorts the list <var>list1</var> in increasing order just as <code>Sort</code> (see&nbsp;<a href="CHAP021.htm#SSEC018.1">Sort</a>)
does.  In  parallel it applies  the same exchanges  that are
necessary to sort <var>list1</var> to the list <var>list2</var>, which must of  course have
at least as many elements as <var>list1</var> does.
<p>
<pre>
gap&gt; list1 := [ 5, 4, 6, 1, 7, 5 ];;
gap&gt; list2 := [ 2, 3, 5, 7, 8, 9 ];;
gap&gt; SortParallel( list1, list2 );
gap&gt; list1;
[ 1, 4, 5, 5, 6, 7 ]
gap&gt; list2;  # note: [ 7, 3, 2, 9, 5, 8 ] or [ 7, 3, 9, 2, 5, 8 ] are possible results
[ 7, 3, 2, 9, 5, 8 ]
</pre>
<p>
<a name = "SSEC018.3"></a>
<li><code>Sortex( </code><var>list</var><code> ) O</code>
<p>
sorts the list <var>list</var> via the operator<code>&lt;</code> and returns a permutation
that can be applied to <var>list</var> to obtain the sorted list.
(If the list is not homogeneous it is the user's responsibility to ensure
that <code>&lt;</code> is defined for all element pairs,
see&nbsp;<a href="CHAP030.htm#SECT011">Comparison Operations for Elements</a>)
<p>
<code>Permuted</code> (see&nbsp;<a href="CHAP021.htm#SSEC020.16">Permuted</a>) allows you to rearrange a list according to
a given permutation.
<p>
<pre>
gap&gt; list1 := [ 5, 4, 6, 1, 7, 5 ];;
gap&gt; list2 := ShallowCopy( list1 );;
gap&gt; perm := Sortex( list1 );
(1,3,5,6,4)
gap&gt; list1;
[ 1, 4, 5, 5, 6, 7 ]
gap&gt; Permuted( list2, perm );
[ 1, 4, 5, 5, 6, 7 ]
</pre>
<p>
<a name = "SSEC018.4"></a>
<li><code>SortingPerm( </code><var>list</var><code> ) A</code>
<p>
<code>SortingPerm</code> returns the same as <code>Sortex( </code><var>list</var><code> )</code> (see&nbsp;<a href="CHAP021.htm#SSEC018.3">Sortex</a>)
but does <strong>not</strong> change the argument.
<p>
<pre>
gap&gt; list1 := [ 5, 4, 6, 1, 7, 5 ];;
gap&gt; list2 := ShallowCopy( list1 );;
gap&gt; perm := SortingPerm( list1 );
(1,3,5,6,4)
gap&gt; list1;
[ 5, 4, 6, 1, 7, 5 ]
gap&gt; Permuted( list2, perm );
[ 1, 4, 5, 5, 6, 7 ]
</pre>
<p>
Currently <font face="Gill Sans,Helvetica,Arial">GAP</font> uses shellsort.
<p>
<p>
<h2><a name="SECT019">21.19 Sorted Lists and Sets</a></h2>
<p><p>
<a name = "I18"></a>

<a name = "I19"></a>

Searching objects in a list works much quicker if the list is known to be
sorted.
Currently <font face="Gill Sans,Helvetica,Arial">GAP</font> exploits the sortedness of a list automatically only if
the list is <strong>strictly sorted</strong>, which is indicated by the property
<code>IsSSortedList</code>, see&nbsp;<a href="CHAP021.htm#SSEC017.4">IsSSortedList</a>.
<p>
Remember that a list of <strong>mutable</strong> objects cannot store that it is strictly
sorted but has to test it anew whenever it is asked whether it is sorted,
see the remark in&nbsp;<a href="CHAP021.htm#SECT017">Properties and Attributes for Lists</a>.
Therefore <font face="Gill Sans,Helvetica,Arial">GAP</font> cannot take advantage of the sortedness of a list if this
list has mutable entries.
Moreover, if a sorted list <var>list</var> with mutable elements is used as an argument
of a function that <strong>expects</strong> this argument to be sorted,
for example <code>UniteSet</code> or <code>RemoveSet</code> (see&nbsp;<a href="CHAP021.htm#SSEC019.6">UniteSet</a>, <a href="CHAP021.htm#SSEC019.5">RemoveSet</a>),
then it is checked whether <var>list</var> is in fact sorted;
this check can have the effect actually to slow down the computations,
compared to computations with sorted lists of immutable elements
or computations that do not involve functions that do automatically check
sortedness.
<p>
Strictly sorted lists are used to represent <strong>sets</strong> in <font face="Gill Sans,Helvetica,Arial">GAP</font>.
More precisely, a strictly sorted list is called a <strong>proper set</strong>
in the following, in order to avoid confusion with domains (see&nbsp;<a href="CHAP012.htm#SECT004">Domains</a>)
which also represent sets.
<p>
In short proper sets are represented by sorted lists without holes and
duplicates in <font face="Gill Sans,Helvetica,Arial">GAP</font>.
Note that we guarantee this representation, so  you may make use of
the fact that a set is represented by a sorted list in your functions.
<p>
In some contexts (for example see&nbsp;<a href="CHAP017.htm">Combinatorics</a>), we also want to talk
about multisets.
A <strong>multiset</strong> is like a set, except that an element may appear several times
in a multiset.
Such multisets are represented by sorted lists without holes
that may have duplicates.
<p>
This section lists only those functions that are defined exclusively for
proper sets.
Set theoretic functions for general collections, such as <code>Intersection</code>
and <code>Union</code>, are described in Chapter&nbsp;<a href="CHAP028.htm">Collections</a>.
In particular, for the construction of proper sets, see&nbsp;<a href="CHAP028.htm#SSEC002.6">SSortedList</a>
and <a href="CHAP028.htm#SSEC002.9">AsSSortedList</a>.
For finding positions in sorted lists, see&nbsp;<a href="CHAP021.htm#SSEC016.5">PositionSorted</a>.
<p>
<a name = "SSEC019.1"></a>
<li><code></code><var>obj</var><code> in </code><var>list</var><code></code>
<p>
The element test for strictly sorted lists uses binary search.
<p>
The following functions, if not explicitly stated differently,
take two arguments, <var>set</var> and <var>obj</var>, where <var>set</var> must be a proper set,
otherwise an error is signalled;
If the second argument <var>obj</var> is a list that is not a proper set then
<code>Set</code> (see&nbsp;<a href="CHAP028.htm#SSEC002.6">Set</a>) is silently applied to it first (see&nbsp;<a href="CHAP028.htm#SSEC002.6">Set</a>).
<p>
<a name = "SSEC019.2"></a>
<li><code>IsEqualSet( </code><var>list1</var><code>, </code><var>list2</var><code> ) O</code>
<p>
tests whether <var>list1</var> and <var>list2</var> are equal <strong>when viewed as sets</strong>, that
is if every element of <var>list1</var> is an element of <var>list2</var> and vice versa.
Either argument of <code>IsEqualSet</code> may also be a list that is not a proper
set, in which case <code>Set</code> (see&nbsp;<a href="CHAP028.htm#SSEC002.6">Set</a>) is applied to it first.
<p>
If both lists are proper sets then they are of course equal if and only
if they are also equal as lists.
Thus <code>IsEqualSet( </code><var>list1</var><code>, </code><var>list2</var><code> )</code> is equivalent to
<code>Set( </code><var>list1</var><code>  ) = Set( </code><var>list2</var><code> )</code> (see&nbsp;<a href="CHAP028.htm#SSEC002.6">Set</a>),
but the former is more efficient.
<p>
<a name = "I20"></a>

<pre>
gap&gt; IsEqualSet( [2,3,5,7,11], [11,7,5,3,2] );
true
gap&gt; IsEqualSet( [2,3,5,7,11], [2,3,5,7,11,13] );
false
</pre>
<p>
<a name = "SSEC019.3"></a>
<li><code>IsSubsetSet( </code><var>list1</var><code>, </code><var>list2</var><code> ) O</code>
<p>
tests whether every element of <var>list2</var> is contained in <var>list1</var>.
Either argument of <code>IsSubsetSet</code> may also be a list that is not a proper
set, in which case <code>Set</code> (see&nbsp;<a href="CHAP028.htm#SSEC002.6">Set</a>) is applied to it first.
<p>
<a name = "SSEC019.4"></a>
<li><code>AddSet( </code><var>set</var><code>, </code><var>obj</var><code> ) O</code>
<p>
adds the element <var>obj</var> to the proper set <var>set</var>.
If <var>obj</var> is already contained in <var>set</var> then <var>set</var> is not changed.
Otherwise <var>obj</var> is inserted at the correct position such that <var>set</var> is
again a proper set afterwards.
<p>
Note that <var>obj</var> must be in the same family as each element of <var>set</var>.
<p>
<a name = "I21"></a>

<pre>
gap&gt; s := [2,3,7,11];;
gap&gt; AddSet( s, 5 );  s;
[ 2, 3, 5, 7, 11 ]
gap&gt; AddSet( s, 13 );  s;
[ 2, 3, 5, 7, 11, 13 ]
gap&gt; AddSet( s, 3 );  s;
[ 2, 3, 5, 7, 11, 13 ]
</pre>
<p>
<a name = "SSEC019.5"></a>
<li><code>RemoveSet( </code><var>set</var><code>, </code><var>obj</var><code> ) O</code>
<p>
removes the element <var>obj</var> from the proper set <var>set</var>.
If <var>obj</var> is not contained in <var>set</var> then <var>set</var> is not changed.
If <var>obj</var> is an element of <var>set</var> it is removed and all the following
elements in the list are moved one position forward.
<p>
<a name = "I22"></a>

<pre>
gap&gt; s := [ 2, 3, 4, 5, 6, 7 ];;
gap&gt; RemoveSet( s, 6 ); s;
[ 2, 3, 4, 5, 7 ]
gap&gt; RemoveSet( s, 10 ); s;
[ 2, 3, 4, 5, 7 ]
</pre>
<p>
<a name = "SSEC019.6"></a>
<li><code>UniteSet( </code><var>set</var><code>, </code><var>list</var><code> ) O</code>
<p>
unites the proper set <var>set</var> with <var>list</var>.
This is equivalent to adding all elements of <var>list</var> to <var>set</var>
(see&nbsp;<a href="CHAP021.htm#SSEC019.4">AddSet</a>).
<p>
<a name = "I23"></a>

<pre>
gap&gt; set := [ 2, 3, 5, 7, 11 ];;
gap&gt; UniteSet( set, [ 4, 8, 9 ] );  set;
[ 2, 3, 4, 5, 7, 8, 9, 11 ]
gap&gt; UniteSet( set, [ 16, 9, 25, 13, 16 ] );  set;
[ 2, 3, 4, 5, 7, 8, 9, 11, 13, 16, 25 ]
</pre>
<p>
<a name = "SSEC019.7"></a>
<li><code>IntersectSet( </code><var>set</var><code>, </code><var>list</var><code> ) O</code>
<p>
intersects the proper set <var>set</var> with <var>list</var>.
This is equivalent to removing from <var>set</var> all elements of <var>set</var> that are
not contained in <var>list</var>.
<p>
<a name = "I24"></a>

<pre>
gap&gt; set := [ 2, 3, 4, 5, 7, 8, 9, 11, 13, 16 ];;
gap&gt; IntersectSet( set, [ 3, 5, 7, 9, 11, 13, 15, 17 ] );  set;
[ 3, 5, 7, 9, 11, 13 ]
gap&gt; IntersectSet( set, [ 9, 4, 6, 8 ] );  set;
[ 9 ]
</pre>
<p>
<a name = "SSEC019.8"></a>
<li><code>SubtractSet( </code><var>set</var><code>, </code><var>list</var><code> ) O</code>
<p>
subtracts <var>list</var> from the proper set <var>set</var>.
This is equivalent to removing from <var>set</var> all elements of <var>list</var>.
<p>
<a name = "I25"></a>

<pre>
gap&gt; set := [ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 ];;
gap&gt; SubtractSet( set, [ 6, 10 ] );  set;
[ 2, 3, 4, 5, 7, 8, 9, 11 ]
gap&gt; SubtractSet( set, [ 9, 4, 6, 8 ] );  set;
[ 2, 3, 5, 7, 11 ]
</pre>
<p>
There are nondestructive counterparts of the functions <code>UniteSet</code>,
<code>IntersectSet</code>, and <code>SubtractSet</code> available for proper sets.
These are <code>UnionSet</code>, <code>IntersectionSet</code>, and <code>Difference</code>.
The former two are methods for the more general operations <code>Union</code>
and <code>Intersection</code> (see&nbsp;<a href="CHAP028.htm#SSEC004.3">Union</a>, <a href="CHAP028.htm#SSEC004.2">Intersection</a>),
the latter is itself an operation (see&nbsp;<a href="CHAP028.htm#SSEC004.4">Difference</a>).
<p>
The result of <code>IntersectionSet</code> and <code>UnionSet</code> is always a new list,
that is not identical to any other list.
The elements of that list however are identical to the corresponding
elements of the first argument <var>set</var>.
If <var>set</var> is not a proper set it is not specified to which of a number
of equal elements in <var>set</var> the element in the result is identical
(see&nbsp;<a href="CHAP021.htm#SECT006">Identical Lists</a>).
<p>
<p>
<h2><a name="SECT020">21.20 Operations for Lists</a></h2>
<p><p>
Several of the following functions expect the first argument to be either a
list or a collection (see&nbsp;<a href="CHAP028.htm">Collections</a>), with possibly slightly different
meaning for lists and non-list collections.
For these functions, the list case is indicated by an argument named <var>list</var>,
and the collection case by one named <var>C</var>.
<p>
<a name = "SSEC020.1"></a>
<li><code>Concatenation( </code><var>list1</var><code>, </code><var>list2</var><code>, ... ) F</code>
<li><code>Concatenation( </code><var>list</var><code> ) F</code>
<p>
In the first form <code>Concatenation</code> returns the concatenation of the lists
<var>list1</var>, <var>list2</var>, etc.
The <strong>concatenation</strong> is the list that begins with the elements of <var>list1</var>,
followed by the elements of <var>list2</var>, and so on.
Each list may also contain holes, in which case the concatenation also
contains holes at the corresponding positions.
<p>
In the second form <var>list</var> must be a dense list of lists <var>list1</var>, <var>list2</var>,
etc., and <code>Concatenation</code> returns the concatenation of those lists.
<p>
The result is a new mutable list, that is not identical to any other
list.
The elements of that list however are identical to the corresponding
elements of <var>list1</var>, <var>list2</var>, etc. (see&nbsp;<a href="CHAP021.htm#SECT006">Identical Lists</a>).
<p>
Note that <code>Concatenation</code> creates a new list and leaves its arguments
unchanged, while <code>Append</code> (see&nbsp;<a href="CHAP021.htm#SSEC004.7">Append</a>) changes its first argument.
For computing the union of proper sets, <code>Union</code> can be used,
see&nbsp;<a href="CHAP028.htm#SSEC004.3">Union</a> and <a href="CHAP021.htm#SECT019">Sorted Lists and Sets</a>.
<p>
<a name = "I26"></a>

<pre>
gap&gt; Concatenation( [ 1, 2, 3 ], [ 4, 5 ] );
[ 1, 2, 3, 4, 5 ]
gap&gt; Concatenation( [2,3,,5,,7], [11,,13,,,,17,,19] );
[ 2, 3,, 5,, 7, 11,, 13,,,, 17,, 19 ]
gap&gt; Concatenation( [ [1,2,3], [2,3,4], [3,4,5] ] );
[ 1, 2, 3, 2, 3, 4, 3, 4, 5 ]
</pre>
<p>
<a name = "SSEC020.2"></a>
<li><code>Compacted( </code><var>list</var><code> ) O</code>
<p>
returns a new mutable list that contains the elements of <var>list</var>
in the same order but omitting the holes.
<p>
<pre>
gap&gt; l:=[,1,,,3,,,4,[5,,,6],7];;  Compacted( l );
[ 1, 3, 4, [ 5,,, 6 ], 7 ]
</pre>
<p>
<a name = "SSEC020.3"></a>
<li><code>Collected( </code><var>list</var><code> ) O</code>
<p>
returns a new list <var>new</var> that contains for each element <var>elm</var> of the list
<var>list</var> a list of length two, the first element of this is <var>elm</var>
itself and the second element is the number of times <var>elm</var> appears in
<var>list</var>.
The order of those pairs in <var>new</var> corresponds to the ordering of
the elements elm, so that the result is sorted.
<p>
For all pairs of elements in <var>list</var> the comparison via <code>&lt;</code> must be
defined.
<p>
<pre>
gap&gt; Factors( Factorial( 10 ) );
[ 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 5, 5, 7 ]
gap&gt; Collected( last );
[ [ 2, 8 ], [ 3, 4 ], [ 5, 2 ], [ 7, 1 ] ]
gap&gt; Collected( last );
[ [ [ 2, 8 ], 1 ], [ [ 3, 4 ], 1 ], [ [ 5, 2 ], 1 ], [ [ 7, 1 ], 1 ] ]
</pre>
<p>
<a name = "SSEC020.4"></a>
<li><code>DuplicateFreeList( </code><var>list</var><code> ) O</code>
<a name = "SSEC020.4"></a>
<li><code>Unique( </code><var>list</var><code> ) O</code>
<p>
returns a new mutable list whose entries are the elements of the list
<var>list</var> with duplicates removed.
<code>DuplicateFreeList</code> only uses the <code>=</code> comparison and will not sort the
result.
Therefore <code>DuplicateFreeList</code> can be used even if the elements of <var>list</var>
do not lie in the same family.
<code>Unique</code> is an alias for <code>DuplicateFreeList</code>.
<p>
<pre>
gap&gt; l:=[1,Z(3),1,"abc",Group((1,2,3),(1,2)),Z(3),Group((1,2),(2,3))];;
gap&gt; DuplicateFreeList( l );
[ 1, Z(3), "abc", Group([ (1,2,3), (1,2) ]) ]
</pre>
<p>
<a name = "SSEC020.5"></a>
<li><code>AsDuplicateFreeList( </code><var>list</var><code> ) A</code>
<p>
returns the same result as <code>DuplicateFreeList</code> (see&nbsp;<a href="CHAP021.htm#SSEC020.4">DuplicateFreeList</a>),
except that the result is immutable.
<p>
<a name = "SSEC020.6"></a>
<li><code>Flat( </code><var>list</var><code> ) O</code>
<p>
returns the list of all elements that are contained in the list <var>list</var>
or its sublists.
That is, <code>Flat</code> first makes a new empty list <var>new</var>.
Then it loops over the elements <var>elm</var> of <var>list</var>.
If <var>elm</var> is not a list it is added to <var>new</var>,
otherwise <code>Flat</code> appends <code>Flat( </code><var>elm</var><code> )</code> to <var>new</var>.
<p>
<pre>
gap&gt; Flat( [ 1, [ 2, 3 ], [ [ 1, 2 ], 3 ] ] );
[ 1, 2, 3, 1, 2, 3 ]
gap&gt; Flat( [ ] );
[  ]
</pre>
(To reconstruct a matrix from a <code>Flat</code>tened list, the sublist operator can
be used:
<pre>
gap&gt; l:=[9..14];;w:=2;; # w is the length of each row
gap&gt; sub:=[1..w];;List([1..Length(l)/w],i-&gt;l{(i-1)*w+sub});
[ [ 9, 10 ], [ 11, 12 ], [ 13, 14 ] ]
</pre>
)
<p>
<a name = "SSEC020.7"></a>
<li><code>Reversed( </code><var>list</var><code> ) F</code>
<p>
returns a new mutable list, containing the elements of the dense list
<var>list</var> in reversed order.
<p>
The argument list is unchanged.
The result list is a new list, that is not identical to any other list.
The elements of that list however are identical to the corresponding
elements of the argument list (see&nbsp;<a href="CHAP021.htm#SECT006">Identical Lists</a>).
<p>
<code>Reversed</code> implements a special case of list assignment, which can also
be formulated in terms of the <code></code> operator (see&nbsp;<a href="CHAP021.htm#SECT004">List Assignment</a>).
<p>
<pre>
gap&gt; Reversed( [ 1, 4, 9, 5, 6, 7 ] );
[ 7, 6, 5, 9, 4, 1 ]
</pre>
<p>
<a name = "SSEC020.8"></a>
<li><code>IsLexicographicallyLess( </code><var>list1</var><code>, </code><var>list2</var><code> ) F</code>
<p>
Let <var>list1</var> and <var>list2</var> be two dense lists, but not necessarily
homogeneous (see&nbsp;<a href="CHAP021.htm#SSEC001.2">IsDenseList</a>, <a href="CHAP021.htm#SSEC001.3">IsHomogeneousList</a>),
such that for each <i>i</i>, the entries in both lists at position <i>i</i> can be
compared via <code>&lt;</code>.
<code>IsLexicographicallyLess</code> returns <code>true</code> if <var>list1</var> is smaller than
<var>list2</var> w.r.t.&nbsp;lexicographical ordering, and <code>false</code> otherwise.
<p>
<a name = "SSEC020.9"></a>
<li><code>Apply( </code><var>list</var><code>, </code><var>func</var><code> ) F</code>
<p>
<code>Apply</code> applies the function <var>func</var> to every element of the dense and
mutable list <var>list</var>,
and replaces each element entry by the corresponding return value.
<p>
<code>Apply</code> changes its argument.
The nondestructive counterpart of <code>Apply</code> is <code>List</code> (see&nbsp;<a href="CHAP021.htm#SSEC020.17">List</a>).
<p>
<pre>
gap&gt; l:= [ 1, 2, 3 ];;  Apply( l, i -&gt; i^2 );  l;
[ 1, 4, 9 ]
</pre>
<p>
<a name = "SSEC020.10"></a>
<li><code>Perform( </code><var>list</var><code>, </code><var>func</var><code> ) O</code>
<p>
<code>Perform( </code><var>list</var><code>, </code><var>func</var><code> )</code> applies func to every element of
<var>list</var>, discarding any return values. It does not return a value.
<p>
<pre>
gap&gt; l := [1, 2, 3];; Perform(l, 
&gt; function(x) if IsPrimeInt(x) then Print(x,"\n"); fi; end);
2
3
</pre>
<p>
<a name = "SSEC020.11"></a>
<li><code>PermListList( </code><var>list1</var><code>, </code><var>list2</var><code> ) F</code>
<p>
returns a permutation <i>p</i> of <code>[ 1 .. Length( </code><var>list1</var><code> ) ]</code>
such that <code></code><var>list1</var><code>[i^<i>p</i>] = </code><var>list2</var><code>[i]</code>.
It returns <code>fail</code> if there is no such permutation.
<p>
<pre>
gap&gt; list1 := [ 5, 4, 6, 1, 7, 5 ];;
gap&gt; list2 := [ 4, 1, 7, 5, 5, 6 ];;
gap&gt; perm := PermListList(list1, list2);
(1,2,4)(3,5,6)
gap&gt; Permuted( list2, perm );
[ 5, 4, 6, 1, 7, 5 ]
</pre>
<p>
<a name = "SSEC020.12"></a>
<li><code>Maximum( </code><var>obj1</var><code>, </code><var>obj2</var><code> ... ) F</code>
<li><code>Maximum( </code><var>list</var><code> ) F</code>
<p>
In the first form <code>Maximum</code> returns the <strong>maximum</strong> of its arguments,
i.e., one argument <var>obj</var> for which <i>obj</i>   &#8805; <i>obj</i>1 , <i>obj</i>   &#8805; <i>obj</i>2 
etc.
In the second form <code>Maximum</code> takes a homogeneous list <var>list</var> and returns
the maximum of the elements in this list.
<p>
<pre>
gap&gt; Maximum( -123, 700, 123, 0, -1000 );
700
gap&gt; Maximum( [ -123, 700, 123, 0, -1000 ] );
700
gap&gt; Maximum( [1,2], [0,15], [1,5], [2,-11] );  # lists are compared elementwise
[ 2, -11 ]
</pre>
<p>
<a name = "SSEC020.13"></a>
<li><code>Minimum( </code><var>obj1</var><code>, </code><var>obj2</var><code> ... ) F</code>
<li><code>Minimum( </code><var>list</var><code> ) F</code>
<p>
In the first form <code>Minimum</code> returns the <strong>minimum</strong> of its arguments,
i.e., one argument <var>obj</var> for which <i>obj</i>   &#8804; <i>obj</i>1 , <i>obj</i>   &#8804; <i>obj</i>2 
etc.
In the second form <code>Minimum</code> takes a homogeneous list <var>list</var> and returns
the minimum of the elements in this list.
<p>
Note that for both <code>Maximum</code> and <code>Minimum</code> the comparison of the objects
<var>obj1</var>, <var>obj2</var> etc.&nbsp;must be defined;
for that, usually they must lie in the same family (see&nbsp;<a href="CHAP013.htm#SECT001">Families</a>).
<p>
<pre>
gap&gt; Minimum( -123, 700, 123, 0, -1000 );
-1000
gap&gt; Minimum( [ -123, 700, 123, 0, -1000 ] );
-1000
gap&gt; Minimum( [ 1, 2 ], [ 0, 15 ], [ 1, 5 ], [ 2, -11 ] );
[ 0, 15 ]
</pre>
<p>
<a name = "SSEC020.14"></a>
<li><code>MaximumList( </code><var>list</var><code> ) O</code>
<a name = "SSEC020.14"></a>
<li><code>MinimumList( </code><var>list</var><code> ) O</code>
<p>
return the maximum resp.&nbsp;the minimum of the elements in the list <var>list</var>.
They are the operations called by <code>Maximum</code> resp.&nbsp;<code>Minimum</code>.
Methods can be installed for special kinds of lists.
For example, there are special methods to compute the maximum resp.&nbsp;the
minimum of a range (see&nbsp;<a href="CHAP021.htm#SECT022">Ranges</a>).
<p>
<a name = "SSEC020.15"></a>
<li><code>Cartesian( </code><var>list1</var><code>, </code><var>list2</var><code> ... ) F</code>
<li><code>Cartesian( </code><var>list</var><code> ) F</code>
<p>
In the first form <code>Cartesian</code> returns the cartesian product of the lists
<var>list1</var>, <var>list2</var>, etc.
<p>
In the second form <var>list</var> must be a list of lists <var>list1</var>, <var>list2</var>, etc.,
and <code>Cartesian</code> returns the cartesian product of those lists.
<p>
The <strong>cartesian product</strong> is a list <var>cart</var> of lists <var>tup</var>,
such that the first element of <var>tup</var> is an element of <var>list1</var>,
the second element of <var>tup</var> is an element of <var>list2</var>, and so on.
The total number of elements in <var>cart</var> is the product of the lengths
of the argument lists.
In particular <var>cart</var> is empty if and only if at least one of the argument
lists is empty.
Also <var>cart</var> contains duplicates if and only if no argument list is empty
and at least one contains duplicates.
<p>
The last index runs fastest.
That means that the first element <var>tup1</var> of <var>cart</var> contains the first
element from <var>list1</var>,  from <var>list2</var> and so on.
The second element <var>tup2</var> of <var>cart</var> contains the first element from
<var>list1</var>, the first from <var>list2</var>, an so on, but the last element of <var>tup2</var>
is the second element of the last argument list.
This implies that <var>cart</var> is a proper set if and only if all argument
lists are proper sets (see&nbsp;<a href="CHAP021.htm#SECT019">Sorted Lists and Sets</a>).
<p>
The function <code>Tuples</code> (see&nbsp;<a href="CHAP017.htm#SSEC002.7">Tuples</a>) computes the  <var>k</var>-fold cartesian
product of a list.
<p>
<pre>
gap&gt; Cartesian( [1,2], [3,4], [5,6] );
[ [ 1, 3, 5 ], [ 1, 3, 6 ], [ 1, 4, 5 ], [ 1, 4, 6 ], [ 2, 3, 5 ], 
  [ 2, 3, 6 ], [ 2, 4, 5 ], [ 2, 4, 6 ] ]
gap&gt; Cartesian( [1,2,2], [1,1,2] );
[ [ 1, 1 ], [ 1, 1 ], [ 1, 2 ], [ 2, 1 ], [ 2, 1 ], [ 2, 2 ], [ 2, 1 ], 
  [ 2, 1 ], [ 2, 2 ] ]
</pre>
<p>
<a name = "SSEC020.16"></a>
<li><code>Permuted( </code><var>list</var><code>, </code><var>perm</var><code> ) O</code>
<p>
returns a new list <var>new</var> that contains the elements of the
list <var>list</var> permuted according to the permutation <var>perm</var>.
That is <code></code><var>new</var><code>[</code><var>i</var><code> ^ </code><var>perm</var><code>] = </code><var>list</var><code>[</code><var>i</var><code>]</code>.
<p>
<code>Sortex</code> (see&nbsp;<a href="CHAP021.htm#SSEC018.3">Sortex</a>) allows you to compute a permutation that must
be applied to a list in order to get the sorted list.
<p>
<pre>
gap&gt; Permuted( [ 5, 4, 6, 1, 7, 5 ], (1,3,5,6,4) );
[ 1, 4, 5, 5, 6, 7 ]
</pre>
<p>
<a name = "SSEC020.17"></a>
<li><code>List( </code><var>list</var><code> ) F</code>
<li><code>List( </code><var>C</var><code> ) F</code>
<li><code>List( </code><var>list</var><code>, </code><var>func</var><code> ) F</code>
<p>
In the first form, where <var>list</var> is a list (not necessarily dense or
homogeneous), <code>List</code> returns a new mutable list <var>new</var> that contains
the elements (and the holes) of <var>list</var> in the same order;
thus <code>List</code> does the same as <code>ShallowCopy</code> (see&nbsp;<a href="CHAP012.htm#SSEC007.1">ShallowCopy</a>)
in this case.
<p>
In the second form, where <var>C</var> is a collection (see&nbsp;<a href="CHAP028.htm">Collections</a>)
that is not a list,
<code>List</code> returns a new mutable list <var>new</var> such that <code>Length( </code><var>new</var><code> )</code>
is the number of different elements of <var>C</var>, and <var>new</var> contains the
different elements of <var>C</var> in an unspecified order which may change
for repeated calls.
<code></code><var>new</var><code>[</code><var>pos</var><code>]</code> executes in constant time
(see&nbsp;<a href="CHAP021.htm#SSEC001.5">IsConstantTimeAccessList</a>),
and the size of <var>new</var> is proportional to its length.
The generic method for this case is <code>ShallowCopy( Enumerator( </code><var>C</var><code> ) )</code>.
<p>
In the third form, for a dense list <var>list</var> and a function <var>func</var>,
which must take exactly one argument, <code>List</code> returns a new mutable list
<var>new</var> given by <i>new</i> [<i>i</i>] = <i>func</i> ( <i>list</i> [<i>i</i>] ).
<p>
<pre>
gap&gt; List( [1,2,3], i -&gt; i^2 );
[ 1, 4, 9 ]
gap&gt; List( [1..10], IsPrime );
[ false, true, true, false, true, false, true, false, false, false ]
</pre>
<p>
<a name = "SSEC020.18"></a>
<li><code>Filtered( </code><var>list</var><code>, </code><var>func</var><code> ) F</code>
<li><code>Filtered( </code><var>C</var><code>, </code><var>func</var><code> ) F</code>
<p>
returns a new list that contains those elements of the list <var>list</var> or
collection <var>C</var> (see&nbsp;<a href="CHAP028.htm">Collections</a>), respectively,
for which the unary function <var>func</var> returns <code>true</code>.
<p>
If the first argument is a list, the order of the elements in the result
is the same as the order of the corresponding elements of <var>list</var>.
If an element for which <var>func</var> returns <code>true</code> appears several times in
<var>list</var> it will also appear the same number of times in the result.
<var>list</var> may contain holes, they are ignored by <code>Filtered</code>.
<p>
For each element of <var>list</var> resp.&nbsp;<var>C</var>, <var>func</var> must return either <code>true</code> or
<code>false</code>, otherwise an error is signalled.
<p>
The result is a new list that is not identical to any other list.
The elements of that list however are identical to the corresponding
elements of the argument list (see&nbsp;<a href="CHAP021.htm#SECT006">Identical Lists</a>).
<p>
List assignment using the operator <code></code> (see&nbsp;<a href="CHAP021.htm#SECT004">List Assignment</a>) can be
used to extract elements of a list according to indices given in another
list.
<p>
<pre>
gap&gt; Filtered( [1..20], IsPrime );
[ 2, 3, 5, 7, 11, 13, 17, 19 ]
gap&gt; Filtered( [ 1, 3, 4, -4, 4, 7, 10, 6 ], IsPrimePowerInt );
[ 3, 4, 4, 7 ]
gap&gt; Filtered( [ 1, 3, 4, -4, 4, 7, 10, 6 ],
&gt;              n -&gt; IsPrimePowerInt(n) and n mod 2 &lt;&gt; 0 );
[ 3, 7 ]
gap&gt; Filtered( Group( (1,2), (1,2,3) ), x -&gt; Order( x ) = 2 );
[ (2,3), (1,2), (1,3) ]
</pre>
<p>
<a name = "SSEC020.19"></a>
<li><code>Number( </code><var>list</var><code> ) F</code>
<li><code>Number( </code><var>list</var><code>, </code><var>func</var><code> ) F</code>
<li><code>Number( </code><var>C</var><code>, </code><var>func</var><code> ) F</code>
<p>
In the first form, <code>Number</code> returns the number of bound entries in the
list <var>list</var>.
For dense lists <code>Number</code>, <code>Length</code> (see&nbsp;<a href="CHAP021.htm#SSEC017.5">Length</a>),
and <code>Size</code> (see&nbsp;<a href="CHAP028.htm#SSEC003.6">Size</a>) return the same value;
for lists with holes <code>Number</code> returns the number of bound entries,
<code>Length</code> returns the largest index of a bound entry,
and <code>Size</code> signals an error.
<p>
In the last two forms, <code>Number</code> returns the number of elements of the
list <var>list</var> resp.&nbsp;the collection <var>C</var> for which the unary function <var>func</var>
returns <code>true</code>.
If an element for which <var>func</var> returns <code>true</code> appears several times in
<var>list</var> it will also be counted the same number of times.
<p>
For each element of <var>list</var> resp.&nbsp;<var>C</var>, <var>func</var> must return either <code>true</code> or
<code>false</code>, otherwise an error is signalled.
<p>
<code>Filtered</code> (see&nbsp;<a href="CHAP021.htm#SSEC020.18">Filtered</a>) allows you to extract the elements of a list
that have a certain property.
<p>
<pre>
gap&gt; Number( [ 2, 3, 5, 7 ] );
4
gap&gt; Number( [, 2, 3,, 5,, 7,,,, 11 ] );
5
gap&gt; Number( [1..20], IsPrime );
8
gap&gt; Number( [ 1, 3, 4, -4, 4, 7, 10, 6 ], IsPrimePowerInt );
4
gap&gt; Number( [ 1, 3, 4, -4, 4, 7, 10, 6 ],
&gt;            n -&gt; IsPrimePowerInt(n) and n mod 2 &lt;&gt; 0 );
2
gap&gt; Number( Group( (1,2), (1,2,3) ), x -&gt; Order( x ) = 2 );
3
</pre>
<p>
<a name = "SSEC020.20"></a>
<li><code>First( </code><var>list</var><code>, </code><var>func</var><code> ) F</code>
<p>
<code>First</code> returns the first element of the list <var>list</var> for which the unary
function <var>func</var> returns <code>true</code>.
<var>list</var> may contain holes.
<var>func</var> must return either <code>true</code> or <code>false</code> for each element of <var>list</var>,
otherwise an error is signalled.
If <var>func</var> returns <code>false</code> for all elements of <var>list</var> then <code>First</code>
returns <code>fail</code>.
<p>
<code>PositionProperty</code> (see&nbsp;<a href="CHAP021.htm#SSEC016.7">PositionProperty</a>) allows you to find the
position of the first element in a list that satisfies a certain
property.
<p>
<pre>
gap&gt; First( [10^7..10^8], IsPrime );
10000019
gap&gt; First( [10^5..10^6],
&gt;      n -&gt; not IsPrime(n) and IsPrimePowerInt(n) );
100489
gap&gt; First( [ 1 .. 20 ], x -&gt; x &lt; 0 );
fail
gap&gt; First( [ fail ], x -&gt; x = fail );
fail
</pre>
<p>
<a name = "SSEC020.21"></a>
<li><code>ForAll( </code><var>list</var><code>, </code><var>func</var><code> ) F</code>
<li><code>ForAll( </code><var>C</var><code>, </code><var>func</var><code> ) F</code>
<p>
tests whether the unary function <var>func</var> returns <code>true</code> for all elements
in the list <var>list</var> resp.&nbsp;the collection <var>C</var>.
<p>
<pre>
gap&gt; ForAll( [1..20], IsPrime );
false
gap&gt; ForAll( [2,3,4,5,8,9], IsPrimePowerInt );
true
gap&gt; ForAll( [2..14], n -&gt; IsPrimePowerInt(n) or n mod 2 = 0 );
true
gap&gt; ForAll( Group( (1,2), (1,2,3) ), i -&gt; SignPerm(i) = 1 );
false
</pre>
<p>
<a name = "SSEC020.22"></a>
<li><code>ForAny( </code><var>list</var><code>, </code><var>func</var><code> ) F</code>
<li><code>ForAny( </code><var>C</var><code>, </code><var>func</var><code> ) F</code>
<p>
tests whether the unary function <var>func</var> returns <code>true</code> for at least one
element in the list <var>list</var> resp.&nbsp;the collection <var>C</var>.
<p>
<pre>
gap&gt; ForAny( [1..20], IsPrime );
true
gap&gt; ForAny( [2,3,4,5,8,9], IsPrimePowerInt );
true
gap&gt; ForAny( [2..14],
&gt;    n -&gt; IsPrimePowerInt(n) and n mod 5 = 0 and not IsPrime(n) );
false
gap&gt; ForAny( Integers, i -&gt;     i &gt; 0
&gt;                           and ForAll( [0,2..4], j -&gt; IsPrime(i+j) ) );
true
</pre>
<p>
<a name = "SSEC020.23"></a>
<li><code>Product( </code><var>list</var><code>[, </code><var>init</var><code>] ) F</code>
<li><code>Product( </code><var>C</var><code>[, </code><var>init</var><code>] ) F</code>
<li><code>Product( </code><var>list</var><code>, </code><var>func</var><code>[, </code><var>init</var><code>] ) F</code>
<li><code>Product( </code><var>C</var><code>, </code><var>func</var><code>[, </code><var>init</var><code>] ) F</code>
<p>
In the first two forms <code>Product</code> returns the product of the elements of
the dense list <var>list</var> resp.&nbsp;the collection <var>C</var> (see&nbsp;<a href="CHAP028.htm">Collections</a>).
In the last two forms <code>Product</code> applies the function <var>func</var>,
which must be a function taking one argument,
to the elements of the dense list <var>list</var> resp.&nbsp;the collection <var>C</var>,
and returns the product of the results.
In either case <code>Product</code> returns <code>1</code> if the first argument is empty.
<p>
The general rules for arithmetic operations apply
(see&nbsp;<a href="CHAP021.htm#SECT015">Mutability Status and List Arithmetic</a>),
so the result is immutable if and only if all summands are immutable.
<p>
If <var>list</var> or <var>C</var> contains exactly one element then this element (or its
image under <var>func</var> if applicable) itself is returned, not a shallow copy
of this element.
<p>
If an additional initial value <var>init</var> is given,
<code>Product</code> returns the product of <var>init</var> and the elements of the first
argument resp.&nbsp;of their images under the function <var>func</var>.
This is useful for example if the first argument is empty and a different
identity than <code>1</code> is desired, in which case <var>init</var> is returned.
<p>
<pre>
gap&gt; Product( [ 2, 3, 5, 7, 11, 13, 17, 19 ] );
9699690
gap&gt; Product( [1..10], x-&gt;x^2 );
13168189440000
gap&gt; Product( [ (1,2), (1,3), (1,4), (2,3), (2,4), (3,4) ] );
(1,4)(2,3)
gap&gt; Product( GF(8) );
0*Z(2)
</pre>
<p>
<a name = "SSEC020.24"></a>
<li><code>Sum( </code><var>list</var><code>[, </code><var>init</var><code>] ) F</code>
<li><code>Sum( </code><var>C</var><code>[, </code><var>init</var><code>] ) F</code>
<li><code>Sum( </code><var>list</var><code>, </code><var>func</var><code>[, </code><var>init</var><code>] ) F</code>
<li><code>Sum( </code><var>C</var><code>, </code><var>func</var><code>[, </code><var>init</var><code>] ) F</code>
<p>
In the first two forms <code>Sum</code> returns the sum of the elements of the
dense list <var>list</var> resp.&nbsp;the collection <var>C</var> (see&nbsp;<a href="CHAP028.htm">Collections</a>).
In the last two forms <code>Sum</code> applies the function <var>func</var>,
which must be a function taking one argument,
to the elements of the dense list <var>list</var> resp.&nbsp;the collection <var>C</var>,
and returns the sum of the results.
In either case <code>Sum</code> returns <code>0</code> if the first argument is empty.
<p>
The general rules for arithmetic operations apply
(see&nbsp;<a href="CHAP021.htm#SECT015">Mutability Status and List Arithmetic</a>),
so the result is immutable if and only if all summands are immutable.
<p>
If <var>list</var> or <var>C</var> contains exactly one element then this element (or its
image under <var>func</var> if applicable) itself is returned, not a shallow copy
of this element.
<p>
If an additional initial value <var>init</var> is given,
<code>Sum</code> returns the sum of <var>init</var> and the elements of the first argument
resp.&nbsp;of their images under the function <var>func</var>.
This is useful for example if the first argument is empty and a different
zero than <code>0</code> is desired, in which case <var>init</var> is returned.
<p>
<pre>
gap&gt; Sum( [ 2, 3, 5, 7, 11, 13, 17, 19 ] );
77
gap&gt; Sum( [1..10], x-&gt;x^2 );
385
gap&gt; Sum( [ [1,2], [3,4], [5,6] ] );
[ 9, 12 ]
gap&gt; Sum( GF(8) );
0*Z(2)
</pre>
<p>
<a name = "SSEC020.25"></a>
<li><code>Iterated( </code><var>list</var><code>, </code><var>func</var><code> ) O</code>
<p>
returns the result of the iterated application of the function <var>func</var>,
which must take two arguments, to the elements of the list <var>list</var>.
More precisely <code>Iterated</code> returns the result of the following
application,
<i>f</i> (&#8230;<i>f</i> ( <i>f</i> ( <i>list</i> [1], <i>list</i> [2] ), <i>list</i> [3] ), &#8230;, <i>list</i> [<i>n</i> ] ).
<p>
<pre>
gap&gt; Iterated( [ 126, 66, 105 ], Gcd );
3
</pre>
<p>
<a name = "SSEC020.26"></a>
<li><code>ListN( </code><var>list1</var><code>, </code><var>list2</var><code>, ..., </code><var>listn</var><code>, </code><var>f</var><code> ) F</code>
<p>
Applies the <var>n</var>-argument function <var>func</var> to the lists.
That is, <code>ListN</code> returns the list whose <var>i</var>th entry is
<i>f</i> (<i>list</i>1 [<i>i</i> ], <i>list</i>2 [<i>i</i> ], &#8230;, <i>listn</i> [<i>i</i> ]).
<p>
<pre>
gap&gt; ListN( [1,2], [3,4], \+ );
[ 4, 6 ]
</pre>
<p>
<p>
<h2><a name="SECT021">21.21 Advanced List Manipulations</a></h2>
<p><p>
The following functions are generalizations of <code>List</code> (see&nbsp;<a href="CHAP021.htm#SSEC020.17">List</a>),
<code>Set</code> (see&nbsp;<a href="CHAP028.htm#SSEC002.6">Set</a>), <code>Sum</code> (see&nbsp;<a href="CHAP021.htm#SSEC020.24">Sum</a>), and <code>Product</code> (see&nbsp;<a href="CHAP021.htm#SSEC020.23">Product</a>).
<p>
<a name = "SSEC021.1"></a>
<li><code>ListX( </code><var>arg1</var><code>, </code><var>arg2</var><code>, ... </code><var>argn</var><code>, </code><var>func</var><code> ) O</code>
<p>
<code>ListX</code> returns a new list constructed from the arguments.
<p>
Each of the arguments <code></code><var>arg1</var><code>, </code><var>arg2</var><code>, ... </code><var>argn</var><code></code> must be one of the
following:
<p>
<dl compact>
<dt>a list or collection <dd>
    this introduces a new for-loop in the sequence of nested
    for-loops and if-statements;
<p>
<dt>a function returning a list or collection <dd>
    this introduces a new for-loop in the sequence of nested
    for-loops and if-statements, where the loop-range depends on
    the values of the outer loop-variables; or
<p>
<dt>a function returning <code>true</code> or <code>false</code> <dd>
    this introduces a new if-statement in the sequence of nested
    for-loops and if-statements.
</dl>
<p>
The last argument <var>func</var> must be a function,
it is applied to the values of the loop-variables
and the results are collected.
<p>
Thus <code>ListX( </code><var>list</var><code>, </code><var>func</var><code> )</code> is the same as <code>List( </code><var>list</var><code>, </code><var>func</var><code> )</code>,
and <code>ListX( </code><var>list</var><code>, </code><var>func</var><code>, x -&gt; x )</code> is the same as
<code>Filtered( </code><var>list</var><code>, </code><var>func</var><code> )</code>.
<p>
As a more elaborate example, assume <var>arg1</var> is a list or collection,
<var>arg2</var> is a function returning <code>true</code> or <code>false</code>,
<var>arg3</var> is a function returning a list or collection, and
<var>arg4</var> is another function returning <code>true</code> or <code>false</code>,
then
<p>
<code></code><var>result</var><code> := ListX( </code><var>arg1</var><code>, </code><var>arg2</var><code>, </code><var>arg3</var><code>, </code><var>arg4</var><code>, </code><var>func</var><code> );</code>
<p>
is equivalent to
<p>
<code></code><var>result</var><code> := [];</code>
<br><code>for v1 in </code><var>arg1</var><code> do</code>
<br><code>&nbsp;if </code><var>arg2</var><code>( v1 ) then</code>
<br><code>&nbsp;&nbsp;for v2 in </code><var>arg3</var><code>( v1 ) do</code>
<br><code>&nbsp;&nbsp;&nbsp;if </code><var>arg4</var><code>( v1, v2 ) then</code>
<br><code>&nbsp;&nbsp;&nbsp;&nbsp;Add( </code><var>result</var><code>, </code><var>func</var><code>( v1, v2 ) );</code>
<br><code>&nbsp;&nbsp;&nbsp;fi;</code>
<br><code>&nbsp;&nbsp;od;</code>
<br><code>&nbsp;fi;</code>
<br><code>od;</code>
<p>
The following example shows how <code>ListX</code> can be used to compute all pairs
and all strictly sorted pairs of elements in a list.
<pre>
gap&gt; l:= [ 1, 2, 3, 4 ];;
gap&gt; pair:= function( x, y ) return [ x, y ]; end;;
gap&gt; ListX( l, l, pair );
[ [ 1, 1 ], [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 1 ], [ 2, 2 ], [ 2, 3 ], 
  [ 2, 4 ], [ 3, 1 ], [ 3, 2 ], [ 3, 3 ], [ 3, 4 ], [ 4, 1 ], [ 4, 2 ], 
  [ 4, 3 ], [ 4, 4 ] ]
</pre>
In the following example, <code>&lt;</code> is the comparison operation:
<pre>
gap&gt; ListX( l, l, \&lt;, pair );
[ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 3 ], [ 2, 4 ], [ 3, 4 ] ]
</pre>
<p>
<a name = "SSEC021.2"></a>
<li><code>SetX( </code><var>arg1</var><code>, </code><var>arg2</var><code>, ... </code><var>func</var><code> ) O</code>
<p>
The only difference between <code>SetX</code> and <code>ListX</code> is that the result list of
<code>SetX</code> is strictly sorted.
<p>
<a name = "SSEC021.3"></a>
<li><code>SumX( </code><var>arg1</var><code>, </code><var>arg2</var><code>, ... </code><var>func</var><code> ) O</code>
<p>
<code>SumX</code> returns the sum of the elements in the list obtained by
<code>ListX</code> when this is called with the same arguments.
<p>
<a name = "SSEC021.4"></a>
<li><code>ProductX( </code><var>arg1</var><code>, </code><var>arg2</var><code>, ... </code><var>func</var><code> ) O</code>
<p>
<code>ProductX</code> returns the product of the elements in the list obtained by
<code>ListX</code> when this is called with the same arguments.
<p>
<p>
<h2><a name="SECT022">21.22 Ranges</a></h2>
<p><p>
<a name = "I27"></a>

A <strong>range</strong> is a dense list of integers in arithmetic progression (or
degression).
This is a list of integers such that the difference between
consecutive elements is a nonzero constant.  Ranges can be abbreviated
with the syntactic construct <code>[ </code><var>first</var><code>, </code><var>second</var><code> .. </code><var>last</var><code> ]</code> or, if the
difference between consecutive elements is 1, as <code>[ </code><var>first</var><code> .. </code><var>last</var><code> ]</code>.
<p>
If <code></code><var>first</var><code> &gt; </code><var>last</var><code></code>, <code>[</code><var>first</var><code>..</code><var>last</var><code>]</code> is the empty  list,  which  by
definition is also a range; also, if <code></code><var>second</var><code> &gt;  </code><var>first</var><code>  &gt;  </code><var>last</var><code></code>  or
<code></code><var>second</var><code> &lt; </code><var>first</var><code> &lt; </code><var>last</var><code></code>, then <code>[</code><var>first</var><code>,</code><var>second</var><code>..</code><var>last</var><code>]</code> is the
empty list. If <code></code><var>first</var><code>  =  </code><var>last</var><code></code>,  <code>[</code><var>first</var><code>,</code><var>second</var><code>..</code><var>last</var><code>]</code>  is  a
singleton list, which is a range, too. Note that <code></code><var>last</var><code> - </code><var>first</var><code></code>  must
be divisible by the increment <code></code><var>second</var><code> - </code><var>first</var><code></code>, otherwise an error is
signalled.
<p>
Currently, the integers <var>first</var>, <var>second</var> and <var>last</var> and the length of a
range must be small integers, that is at least &#8722;2<sup><i>d</i></sup> and at most 2<sup><i>d</i></sup>&#8722;1 
with <i>d</i>=28 on 32-bit architectures and <i>d</i>=60 on 64-bit architectures.
<p>
Note also that a range is just a special case of a list.
Thus you can access elements in a range (see <a href="CHAP021.htm#SECT003">List Elements</a>), test for
membership etc.
You can even assign to such a range if it is mutable (see&nbsp;<a href="CHAP021.htm#SECT004">List Assignment</a>).
Of course, unless you assign <code></code><var>last</var><code> + </code><var>second</var><code>-</code><var>first</var><code></code> to the entry
<code></code><var>range</var><code>[Length(</code><var>range</var><code>)+1]</code>, the resulting list will no longer be a range.
<p>
<pre>
gap&gt; r := [10..20];
[ 10 .. 20 ]
gap&gt; Length( r );
11
gap&gt; r[3];
12
gap&gt; 17 in r;
true
gap&gt; r[12] := 25;; r;  # r is no longer a range
[ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 25 ]
gap&gt; r := [1,3..17];
[ 1, 3 .. 17 ]
gap&gt; Length( r );
9
gap&gt; r[4];
7
gap&gt; r := [0,-1..-9];
[ 0, -1 .. -9 ]
gap&gt; r[5];
-4
gap&gt; r := [ 1, 4 .. 32 ];
Range: &lt;last&gt;-&lt;first&gt; (31) must be divisible by &lt;inc&gt; (3)
</pre>
<p>
Most often ranges are used in connection with the <code>for</code>-loop (see&nbsp;<a href="CHAP004.htm#SECT019">For</a>).
Here the construct
<p>
<code>for </code><var>var</var><code>  in [</code><var>first</var><code>..</code><var>last</var><code>]  do </code><var>statements</var><code>  od</code>
<p>
replaces the
<p>
<code>for </code><var>var</var><code>  from </code><var>first</var><code>  to </code><var>last</var><code>  do </code><var>statements</var><code>  od</code>
<p>
which is more usual in other programming languages.
<p>
<pre>
gap&gt; s := [];; for i in [10..20] do Add( s, i^2 ); od; s;
[ 100, 121, 144, 169, 196, 225, 256, 289, 324, 361, 400 ]
</pre>
<p>
Note that a range with <code></code><var>last</var><code> &gt;= </code><var>first</var><code></code> is at the same time also a
proper set (see&nbsp;<a href="CHAP021.htm#SECT019">Sorted Lists and Sets</a>),
because it contains no holes or duplicates and is sorted,
and also a row vector (see&nbsp;<a href="CHAP023.htm">Row Vectors</a>),
because it contains no holes and all elements are integers.
<p>
<a name = "SSEC022.1"></a>
<li><code>IsRange( </code><var>obj</var><code> ) C</code>
<p>
tests if the object <var>obj</var> is a range, i.e. is a dense list of integers
that is also a range (see&nbsp;<a href="CHAP021.htm#SECT022">Ranges</a> for a definition of ``range'').
<p>
<pre>
gap&gt; IsRange( [1,2,3] );  IsRange( [7,5,3,1] );
true
true
gap&gt; IsRange( [1,2,4,5] );  IsRange( [1,,3,,5,,7] );
false
false
gap&gt; IsRange( [] );  IsRange( [1] );
true
true
</pre>
<p>
<a name = "SSEC022.2"></a>
<li><code>ConvertToRangeRep( </code><var>list</var><code> ) F</code>
<p>
For some lists the <font face="Gill Sans,Helvetica,Arial">GAP</font> kernel knows that they are in fact ranges.
Those lists are represented internally in a compact way instead of the
ordinary way.
<p>
If <var>list</var> is a range then <code>ConvertToRangeRep</code> changes the representation
of <var>list</var> to this compact representation.
<p>
This is important since this representation needs only 12 bytes for
the entire range while the ordinary representation needs 4 <i>length</i>
bytes.
<p>
Note that a list that is represented in the ordinary way might still be a
range.
It is just that <font face="Gill Sans,Helvetica,Arial">GAP</font> does not know this.
The following rules tell you under which circumstances a range is
represented  in the compact way,
so you can write your program in such a way that you make best use of
this compact representation for ranges.
<p>
Lists created by the syntactic construct
<code>[ </code><var>first</var><code>, </code><var>second</var><code>  .. </code><var>last</var><code> ]</code> are of course known to be ranges and
are represented in the compact way.
<p>
If you call <code>ConvertToRangeRep</code> for a list represented the ordinary way
that is indeed a range, the representation is changed from the ordinary
to the compact representation.
A call of <code>ConvertToRangeRep</code> for a list that is not a range is
ignored.
<p>
If you change a mutable range that is represented in the compact way,
by assignment, <code>Add</code> or <code>Append</code>, the range will be converted to the
ordinary representation, even if the change is such that the resulting
list is still a proper range.
<p>
Suppose you have built a proper range in such a way that it is
represented in the ordinary way and that you now want to convert it to
the compact representation to save space.
Then you should call <code>ConvertToRangeRep</code> with that list as an argument.
You can think of the call to <code>ConvertToRangeRep</code> as a hint to <font face="Gill Sans,Helvetica,Arial">GAP</font>
that this list is a proper range.
<p>
<pre>
gap&gt; r:= [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];
[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]
gap&gt; ConvertToRangeRep( r );  r;
[ 1 .. 10 ]
gap&gt; l:= [ 1, 2, 4, 5 ];;  ConvertToRangeRep( l );  l;
[ 1, 2, 4, 5 ]
</pre>
<p>
<p>
<h2><a name="SECT023">21.23 Enumerators</a></h2>
<p><p>
An <strong>enumerator</strong> is an immutable list that need not store its elements
explicitly but knows, from a set of basic data, how to determine the <i>i</i>-th
element and the position of a given object.
A typical example of this is a vector space over a finite field with <i>q</i>
elements, say, for which it is very easy to enumerate all elements
using <i>q</i>-adic expansions of integers.
<p>
Using this enumeration can be even quicker than a binary search in a sorted
list of vectors:
<p>
<a name = "SSEC023.1"></a>
<li><code>IsQuickPositionList( </code><var>list</var><code> ) F</code>
<p>
This filter indicates that a position test in <var>list</var> is quicker than
about 5 or 6 element comparisons for ``smaller''. If this is the case it
can be beneficial to use <code>Position</code> in <var>list</var> and a bit list than
ordered lists to represent subsets  of <var>list</var>.
<p>
On the one hand, element access to an enumerator may take more time than
element access to an internally represented list containing the same
elements.
On the other hand, an enumerator may save a vast amount of memory.
Take for example a permutation group of size a few millions.
Even for moderate degree it is unlikely that a list of all its elements
will fit into memory whereas it is no problem to construct an enumerator
from a stabilizer chain (see&nbsp;<a href="CHAP041.htm#SECT005">Stabilizer Chains</a>).
<p>
There are situations where one only wants to loop over the elements of a
domain, without using the special facilities of an enumerator,
namely the particular order of elements and the possibility to find the
position of elements.
For such cases, <font face="Gill Sans,Helvetica,Arial">GAP</font> provides iterators (see&nbsp;<a href="CHAP028.htm#SECT007">Iterators</a>).
<p>
The functions <code>Enumerator</code> and <code>EnumeratorSorted</code> (see&nbsp;<a href="CHAP028.htm#SSEC002.2">Enumerator</a> and
<a href="CHAP028.htm#SSEC002.3">EnumeratorSorted</a>) return enumerators of domains.
Most of the special implementations of enumerators in the <font face="Gill Sans,Helvetica,Arial">GAP</font> library
are based on the general interface that is provided by
<code>EnumeratorByFunctions</code> (see&nbsp;<a href="CHAP028.htm#SSEC002.4">EnumeratorByFunctions</a>);
one generic example is <code>EnumeratorByBasis</code> (see&nbsp;<a href="CHAP059.htm#SSEC005.5">EnumeratorByBasis</a>),
which can be used to get an enumerator of a finite dimensional free module.
<p>
Also enumerators for non-domains can be implemented via
<code>EnumeratorByFunctions</code>; for a discussion,
see&nbsp;<a href="../prg/CHAP003.htm#SECT012">Example -- Constructing Enumerators</a> in ``Programming in <font face="Gill Sans,Helvetica,Arial">GAP</font>''.
<p>
<p>
[<a href="../index.htm">Top</a>] [<a href = "chapters.htm">Up</a>] [<a href ="CHAP020.htm">Previous</a>] [<a href ="CHAP022.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<P>
<font face="Gill Sans,Helvetica,Arial">GAP 4 manual<br>September 2006
</font></body></html>