<html><head><title>[ref] 30 Domains and their Elements</title></head>
<body text="#000000" bgcolor="#ffffff">
[<a href="../index.htm">Top</a>] [<a href = "chapters.htm">Up</a>] [<a href ="CHAP029.htm">Previous</a>] [<a href ="CHAP031.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<h1>30 Domains and their Elements</h1><p>
<P>
<H3>Sections</H3>
<oL>
<li> <A HREF="CHAP030.htm#SECT001">Operational Structure of Domains</a>
<li> <A HREF="CHAP030.htm#SECT002">Equality and Comparison of Domains</a>
<li> <A HREF="CHAP030.htm#SECT003">Constructing Domains</a>
<li> <A HREF="CHAP030.htm#SECT004">Changing the Structure</a>
<li> <A HREF="CHAP030.htm#SECT005">Changing the Representation</a>
<li> <A HREF="CHAP030.htm#SECT006">Domain Categories</a>
<li> <A HREF="CHAP030.htm#SECT007">Parents</a>
<li> <A HREF="CHAP030.htm#SECT008">Constructing Subdomains</a>
<li> <A HREF="CHAP030.htm#SECT009">Operations for Domains</a>
<li> <A HREF="CHAP030.htm#SECT010">Attributes and Properties of Elements</a>
<li> <A HREF="CHAP030.htm#SECT011">Comparison Operations for Elements</a>
<li> <A HREF="CHAP030.htm#SECT012">Arithmetic Operations for Elements</a>
<li> <A HREF="CHAP030.htm#SECT013">Relations Between Domains</a>
<li> <A HREF="CHAP030.htm#SECT014">Useful Categories of Elements</a>
<li> <A HREF="CHAP030.htm#SECT015">Useful Categories for all Elements of a Family</a>
</ol><p>
<p>
<strong>Domain</strong> is <font face="Gill Sans,Helvetica,Arial">GAP</font>'s name for structured sets.
The ring of Gaussian integers <i>Z</i>[<i>i</i>] is an example of a domain,
the group <i>D</i><sub>12</sub> of symmetries of a regular hexahedron is another.
<p>
The <font face="Gill Sans,Helvetica,Arial">GAP</font> library predefines some domains.
For example the ring of Gaussian integers is predefined as
<code>GaussianIntegers</code> (see&nbsp;<a href="CHAP058.htm#SECT005">Gaussians</a>) and the field of rationals
is predefined as <code>Rationals</code> (see&nbsp;<a href="CHAP016.htm">Rational Numbers</a>).
Most domains are constructed by functions,
which are called <strong>domain constructors</strong> (see&nbsp;<a href="CHAP030.htm#SECT003">Constructing Domains</a>).
For example the group <i>D</i><sub>12</sub> is constructed by the construction
<code>Group( (1,2,3,4,5,6), (2,6)(3,5) )</code> (see&nbsp;<a href="CHAP037.htm#SSEC002.1">Group</a>)
and the finite field with 16 elements is constructed by
<code>GaloisField( 16 )</code> (see&nbsp;<a href="CHAP057.htm#SSEC003.1">GaloisField</a>).
<p>
The first place where you need domains in <font face="Gill Sans,Helvetica,Arial">GAP</font> is the obvious one.
Sometimes you simply want to deal with a domain.
For example if you want to compute the size of the group <i>D</i><sub>12</sub>,
you had better be able to represent this group in a way that the
<code>Size</code> function can understand.
<p>
The second place where you need domains in <font face="Gill Sans,Helvetica,Arial">GAP</font> is when you want to
be able to specify that an operation or computation takes place in a
certain domain.
For example suppose you want to factor 10 in the ring of Gaussian
integers.
Saying <code>Factors( 10 )</code> will not do, because this will return the
factorization <code>[ 2, 5 ]</code> in the ring of integers.
To allow operations and computations to happen in a specific domain,
<code>Factors</code>, and many other functions as well, accept this domain as
optional first argument.
Thus <code>Factors( GaussianIntegers, 10 )</code> yields the desired result
<code>[ 1+E(4), 1-E(4), 2+E(4), 2-E(4) ]</code>.
(The imaginary unit exp( 2 &#960;<i>i</i>/4 ) is written as <code>E(4)</code> in <font face="Gill Sans,Helvetica,Arial">GAP</font>.)
<p>
The most important facts about domains are stated in Chapter&nbsp;<a href="../tut/CHAP007.htm">Domains</a>
of the <font face="Gill Sans,Helvetica,Arial">GAP</font> Tutorial.
<p>
There are only few <strong>operations</strong> especially for domains
(see&nbsp;<a href="CHAP030.htm#SECT009">Operations for Domains</a>),
operations such as <code>Intersection</code> and <code>Random</code> are defined for the more
general situation of collections (see Chapter&nbsp;<a href="CHAP028.htm">Collections</a>).
<p>
<p>
<h2><a name="SECT001">30.1 Operational Structure of Domains</a></h2>
<p><p>
Domains have an <strong>operational structure</strong>,
that is, a collection of operations under which the domain is closed.
For example, a group is closed under multiplication,
taking the zeroth power of elements, and taking inverses of elements.
The operational structure may be empty,
examples of domains without additional structure are
the underlying relations of general mappings
(see&nbsp;<a href="CHAP031.htm#SECT002">Properties and Attributes of (General) Mappings</a>).
<p>
The operations under which a domain is closed are a subset of
the operations that the elements of a domain admit.
It is possible that the elements admit more operations.
For example, matrices can be multiplied and added.
But addition plays no role in a group of matrices,
and multiplication plays no role in a vector space of matrices.
In particular, a matrix group is not closed under addition.
<p>
Note that the elements of a domain exist independently of this domain,
usually they existed already before the domain was created.
So it makes sense to say that a domain is <strong>generated</strong> by some elements
with respect to certain operations.
<p>
Of course, different sets of operations yield different notions of
generation.
For example, the group generated by some matrices is different from
the ring generated by these matrices, and these two will in general be
different from the vector space generated by the same matrices,
over a suitable field.
<p>
The other way round,
the same set of elements may be obtained by generation w.r.t.&nbsp;different
notions of generation.
For example, one can get the group generated by two elements <i>g</i> and <i>h</i>
also as the monoid generated by the elements <i>g</i>, <i>g</i><sup>&#8722;1</sup>, <i>h</i>, <i>h</i><sup>&#8722;1</sup>;
if both <i>g</i> and <i>h</i> have finite order then of course the group generated
by <i>g</i> and <i>h</i> coincides with the monoid generated by <i>g</i> and <i>h</i>.
<p>
Additionally to the operational structure,
a domain can have properties.
For example, the multiplication of a group is associative,
and the multiplication in a field is commutative.
<p>
Note that associativity and commutativity depend on the set of
elements for which one considers the multiplication,
i.e., it depends on the domain.
For example, the multiplication in a full matrix ring over a field
is not commutative, whereas its restriction to the set of diagonal
matrices is commutative.
<p>
One important difference between the operational structure and the
properties of a domain is that the operational structure is fixed when
the domain is constructed, whereas properties can be discovered later.
For example, take a domain whose operational structure is given by
closure under multiplication.
If it is discovered that the inverses of all its elements
also do (by chance) lie in this domain,
being closed under taking inverses is <strong>not</strong> added to the operational
structure.
But a domain with operational structure of multiplication,
taking the identity, and taking inverses
will be treated as a group as soon as the multiplication is found out to
be associative for this domain.
<p>
The operational structures available in <font face="Gill Sans,Helvetica,Arial">GAP</font> form a hierarchy,
which is explicitly formulated in terms of domain categories,
see&nbsp;<a href="CHAP030.htm#SECT006">Domain Categories</a>.
<p>
<p>
<h2><a name="SECT002">30.2 Equality and Comparison of Domains</a></h2>
<p><p>
<strong>Equality</strong> and <strong>comparison</strong> of domains are defined as follows.
<p>
Two domains are considered <strong>equal</strong> if and only if the sets of their
elements as computed by <code>AsSSortedList</code> (see&nbsp;<a href="CHAP028.htm#SSEC002.9">AsSSortedList</a>) are equal.
Thus, in general <code>=</code> behaves as if each domain operand were replaced by
its set of elements.
Except that <code>=</code> will also sometimes, but not always,
work for infinite domains, for which of course <font face="Gill Sans,Helvetica,Arial">GAP</font> cannot compute
the set of elements.
Note that this implies that domains with different algebraic structure
may well be equal.
As a special case of this, either operand of <code>=</code> may also be a proper set
(see&nbsp;<a href="CHAP021.htm#SECT019">Sorted Lists and Sets</a>),
i.e., a sorted list without holes or duplicates (see <a href="CHAP028.htm#SSEC002.9">AsSSortedList</a>),
and <code>=</code> will return <code>true</code> if and only if this proper set is equal to
the set of elements of the argument that is a domain.
<p>
<strong>No</strong> general <strong>ordering</strong> of arbitrary domains via <code>&lt;</code> is defined in
<font face="Gill Sans,Helvetica,Arial">GAP</font>&nbsp;4.
This is because a well-defined <code>&lt;</code> for domains or, more general, for
collections, would have to be compatible with <code>=</code> and would need to be
transitive and antisymmetric in order to be used to form ordered sets.
In particular, <code>&lt;</code> would have to be independent of the algebraic
structure of its arguments because this holds for <code>=</code>,
and thus there would be hardly a situation where one could implement
an efficient comparison method.
(Note that in the case that two domains are comparable with <code>&lt;</code>,
the result is in general <strong>not</strong> compatible with the set theoretical
subset relation, which can be decided with <code>IsSubset</code>.)
<p>
<p>
<h2><a name="SECT003">30.3 Constructing Domains</a></h2>
<p><p>
For several operational structures (see&nbsp;<a href="CHAP030.htm#SECT001">Operational Structure of Domains</a>),
<font face="Gill Sans,Helvetica,Arial">GAP</font> provides functions to construct domains with this structure.
For example, <code>Group</code> returns groups, <code>VectorSpace</code> returns vector spaces etc.
<p>
<a name = "SSEC003.1"></a>
<li><code></code><var>Struct</var><code>( </code><var>arg1</var><code>, </code><var>arg2</var><code>, ... ) F</code>
<p>
The syntax of these functions may vary, dependent on the structure in
question.
Usually a domain is constructed as the closure of some elements under the
given operations, that is, the domain is given by its <strong>generators</strong>.
For example, a group can be constructed from a list of generating
permutations or matrices or whatever is admissible as group elements,
and a vector space over a given field <i>F</i> can be constructed from <i>F</i> and
a list of appropriate vectors.
<p>
The idea of generation and generators in <font face="Gill Sans,Helvetica,Arial">GAP</font> is that the domain
returned by a function such as <code>Group</code>, <code>Algebra</code>, or <code>FreeLeftModule</code>
<strong>contains</strong> the given generators.
This implies that the generators of a group must know how they are
multiplied and inverted,
the generators of a module must know how they are added and how scalar
multiplication works, and so on.
Thus one cannot use for example permutations as generators of a vector
space.
<p>
The function <var>Struct</var> first checks whether the arguments admit
the construction of a domain with the desired structure.
This is done by calling the operation
<p>
<a name = "SSEC003.2"></a>
<li><code>IsGeneratorsOf</code><var>Struct</var><code>( [</code><var>info</var><code>, ]</code><var>gens</var><code>) O</code>
<p>
where <var>arglist</var> is the list of given generators and <var>info</var> an argument
of <var>Struct</var>, for example the field of scalars in the case that a
vector space shall be constructed.
If the check failed then <var>Struct</var> returns <code>fail</code>,
otherwise it returns the result of <code></code><var>Struct</var><code>ByGenerators</code> (see below).
(So if one wants to omit the check then one should call
<code></code><var>Struct</var><code>ByGenerators</code> directly.)
<p>
<a name = "SSEC003.3"></a>
<li><code>GeneratorsOf</code><var>Struct</var><code>( </code><var>D</var><code>) A</code>
<p>
For a domain <var>D</var> with operational structure corresponding to <var>Struct</var>,
the attribute <code>GeneratorsOf</code><var>Struct</var><code></code> returns a list of corresponding
generators of <var>D</var>.
If these generators were not yet stored in <var>D</var> then <var>D</var> must know <strong>some</strong>
generators if <code>GeneratorsOf</code><var>Struct</var><code></code> shall have a chance to compute the
desired result;
for example, monoid generators of a group can be computed from known
group generators (and vice versa).
Note that several notions of generation may be meaningful for a given
domain, so it makes no sense to ask for ``the generators of a domain''.
Further note that the generators may depend on other information about <var>D</var>.
For example the generators of a vector space depend on the underlying field
of scalars; the vector space generators of a vector space over the field
with four elements need not generate the same vector space when this is
viewed as a space over the field with two elements.
<p>
<a name = "SSEC003.4"></a>
<li><code></code><var>Struct</var><code>ByGenerators( [</code><var>info</var><code>, ]</code><var>gens</var><code> ) O</code>
<p>
Domain construction from generators <var>gens</var> is implemented by operations
<code></code><var>Struct</var><code>ByGenerators</code>,
which are called by the simple functions <var>Struct</var>;
methods can be installed only for the operations.
Note that additional information <var>info</var> may be necessary
to construct the domain;
for example, a vector space needs the underlying field of scalars
in addition to the list of vector space generators.
The <code>GeneratorsOf</code><var>Struct</var><code></code> value of the returned domain need <strong>not</strong>
be equal to <var>gens</var>.
But if a domain <var>D</var> is printed as <code></code><var>Struct</var><code>([</code><var>a</var><code>, </code><var>b</var><code>, ...])</code> and if
there is an attribute <code>GeneratorsOf</code><var>Struct</var><code></code> then the list
<code>GeneratorsOf</code><var>Struct</var><code>( </code><var>D</var><code> )</code> is guaranteed to be equal to
<code>[ </code><var>a</var><code>, </code><var>b</var><code>, ... ]</code>.
<p>
<a name = "SSEC003.5"></a>
<li><code></code><var>Struct</var><code>WithGenerators( [</code><var>info</var><code>, ]</code><var>gens</var><code> ) O</code>
<p>
The only difference between <code></code><var>Struct</var><code>ByGenerators</code> and
<code></code><var>Struct</var><code>WithGenerators</code> is that the latter guarantees that the
<code>GeneratorsOf</code><var>Struct</var><code></code> value of the result is equal to the given
generators <var>gens</var>.
<p>
<a name = "SSEC003.6"></a>
<li><code>Closure</code><var>Struct</var><code>( </code><var>D</var><code>, </code><var>obj</var><code> ) O</code>
<p>
For constructing a domain as the closure of a given domain with an
element or another domain, one can use the operation <code>Closure</code><var>Struct</var><code></code>.
It returns the smallest domain with operational structure corresponding to
<var>Struct</var> that contains <var>D</var> as a subset and <var>obj</var> as an element.
<p>
<p>
<h2><a name="SECT004">30.4 Changing the Structure</a></h2>
<p><p>
The same set of elements can have different operational structures.
For example, it may happen that a monoid <i>M</i> does in fact contain
the inverses of all of its elements;
if <i>M</i> has not been constructed as a group (see&nbsp;<a href="CHAP030.htm#SECT006">Domain Categories</a>)
then it is reasonable to ask for the group that is equal to <i>M</i>.
<p>
<a name = "SSEC004.1"></a>
<li><code>As</code><var>Struct</var><code>( [</code><var>info</var><code>, ]</code><var>D</var><code> ) O</code>
<p>
If <var>D</var> is a domain that is closed under the operational structure
given by <var>Struct</var> then <code>As</code><var>Struct</var><code></code> returns a domain <var>E</var> that consists
of the same elements (that is, <code></code><var>D</var><code> = </code><var>E</var><code></code>) and that has this
operational structure (that is, <code>Is</code><var>Struct</var><code>( </code><var>E</var><code> )</code> is <code>true</code>);
if <var>D</var> is not closed under the structure given by <var>Struct</var> then
<code>As</code><var>Struct</var><code></code> returns <code>fail</code>.
<p>
If additional information besides generators are necessary to define <var>D</var>
then the argument <var>info</var> describes the value of this information for the
desired domain.
For example, if we want to view <var>D</var> as a vector space over the field
with two elements then we may call <code>AsVectorSpace( GF(2), </code><var>D</var><code> )</code>;
this allows us to change the underlying field of scalars,
for example if <var>D</var> is a vector space over the field with four elements.
Again, if <var>D</var> is not equal to a domain with the desired structure and
additional information then <code>fail</code> is returned.
<p>
In the case that no additional information <var>info</var> is related to the
structure given by <var>Struct</var>,
the operation <code>As</code><var>Struct</var><code></code> is in fact an attribute (see&nbsp;<a href="CHAP013.htm#SECT005">Attributes</a>).
<p>
See the index of the <font face="Gill Sans,Helvetica,Arial">GAP</font> Reference Manual for an overview of the available
<code>As</code><var>Struct</var><code></code> functions.
<p>
<p>
<h2><a name="SECT005">30.5 Changing the Representation</a></h2>
<p><p>
Often it is useful to answer questions about a domain via computations in
a different but isomorphic domain.
In the sense that this approach keeps the structure and changes the
underlying set of elements, it can be viewed as a counterpart of keeping the
set of elements and changing its structure (see&nbsp;<a href="CHAP030.htm#SECT004">Changing the Structure</a>).
<p>
One reason for doing so can be that computations with the elements in the
given domain are not very efficient.
For example, if one is given a solvable matrix group
(see Chapter&nbsp;<a href="CHAP042.htm">Matrix Groups</a>) then one can compute an isomorphism to a
polycyclicly presented group <i>G</i>, say (see Chapter&nbsp;<a href="CHAP043.htm">Polycyclic Groups</a>);
the multiplication of two matrices --which is essentially determined by
the dimension of the matrices-- is much more expensive than the
multiplication of two elements in <i>G</i> --which is essentially determined by
the composition length of <i>G</i>.
<p>
<a name = "SSEC005.1"></a>
<li><code>Isomorphism</code><var>Rep</var><code></code><var>Struct</var><code>( </code><var>D</var><code> ) A</code>
<p>
If <var>D</var> is a domain that is closed under the operational structure
given by <var>Struct</var> then <code>Isomorphism</code><var>Rep</var><code></code><var>Struct</var><code></code> returns a mapping <var>hom</var>
from <var>D</var> to a domain <i>E</i> having structure given by <var>Struct</var>,
such that <var>hom</var> respects the structure <var>Struct</var>
and <var>Rep</var> describes the representation of the elements in <i>E</i>.
If no domain <i>E</i> with the required properties exists then <code>fail</code> is
returned.
<p>
For example, <code>IsomorphismPermGroup</code> (see&nbsp;<a href="CHAP041.htm#SSEC002.1">IsomorphismPermGroup</a>) takes a
group as its argument and returns a group homomorphism
(see&nbsp;<a href="CHAP038.htm">Group Homomorphisms</a>) onto an isomorphic permutation group
(see Chapter&nbsp;<a href="CHAP041.htm">Permutation Groups</a>) provided the original
group is finite; for infinite groups, <code>IsomorphismPermGroup</code> returns <code>fail</code>.
Similarly, <code>IsomorphismPcGroup</code> (see&nbsp;<a href="CHAP044.htm#SSEC005.2">IsomorphismPcGroup</a>) returns a group
homomorphism from its argument to a polycyclicly presented group
(see&nbsp;<a href="CHAP044.htm">Pc Groups</a>) if the argument is polycyclic, and <code>fail</code> otherwise.
<p>
See the index of the <font face="Gill Sans,Helvetica,Arial">GAP</font> Reference Manual for an overview of the available
<code>Isomorphism</code><var>Rep</var><code></code><var>Struct</var><code></code> functions.
<p>
<p>
<h2><a name="SECT006">30.6 Domain Categories</a></h2>
<p><p>
As mentioned in&nbsp;<a href="CHAP030.htm#SECT001">Operational Structure of Domains</a>,
the operational structure of a domain is fixed when the domain is
constructed.
For example, if <var>D</var> was constructed by <code>Monoid</code> then <var>D</var> is in general not
regarded as a group in <font face="Gill Sans,Helvetica,Arial">GAP</font>,
even if <var>D</var> is in fact closed under taking inverses.
In this case, <code>IsGroup</code> returns <code>false</code> for <var>D</var>.
The operational structure determines which operations are applicable for
a domain, so for example <code>SylowSubgroup</code> is not defined for <var>D</var>
and therefore will signal an error.
<p>
<a name = "SSEC006.1"></a>
<li><code>Is</code><var>Struct</var><code>( </code><var>D</var><code> )</code>
<p>
The functions <code>Is</code><var>Struct</var><code></code> implement the tests whether a domain <var>D</var> has the
respective operational structure (upon construction).
<code>Is</code><var>Struct</var><code></code> is a filter (see&nbsp;<a href="CHAP013.htm">Types of Objects</a>) that involves certain
categories (see&nbsp;<a href="CHAP013.htm#SECT003">Categories</a>)
and usually also certain properties (see&nbsp;<a href="CHAP013.htm#SECT007">Properties</a>).
For example, <code>IsGroup</code> is equivalent to
<code>IsMagmaWithInverses and IsAssociative</code>,
the first being a category and the second being a property.
<p>
Implications between domain categories describe the hierarchy of
operational structures available in <font face="Gill Sans,Helvetica,Arial">GAP</font>.
Here are some typical examples.
<p>
<ul>
<li>
    <code>IsDomain</code> is implied by each domain category,
<li>
    <code>IsMagma</code> is implied by each category that describes the closure under
    multiplication <code>*</code>,
<li>
    <code>IsAdditiveMagma</code> is implied by each category that describes the closure
    under addition <code>+</code>,
<li>
    <code>IsMagmaWithOne</code> implies <code>IsMagma</code>;
    a <strong>magma-with-one</strong> is a magma such that each element
    (and thus also the magma itself) can be asked for its zeroth power,
<li>
    <code>IsMagmaWithInverses</code> implies <code>IsMagmaWithOne</code>;
    a <strong>magma-with-inverses</strong> is a magma such that each element
    can be asked for its inverse;
    important special cases are <strong>groups</strong>,
    which in addition are associative,
<li>
    a <strong>ring</strong> is a magma that is also an additive group,
<li>
    a <strong>ring-with-one</strong> is a ring that is also a magma-with-one,
<li>
    a <strong>division ring</strong> is a ring-with-one that is also closed under taking
    inverses of nonzero elements,
<li>
    a <strong>field</strong> is a commutative division ring.
</ul>
<p>
Each operational structure <var>Struct</var> has associated with it 
a domain category <code>Is</code><var>Struct</var><code></code>,
and operations <code></code><var>Struct</var><code>ByGenerators</code> for constructing a domain from
generators,
<code>GeneratorsOf</code><var>Struct</var><code></code> for storing and accessing generators w.r.t.&nbsp;this
structure,
<code>Closure</code><var>Struct</var><code></code> for forming the closure,
and <code>As</code><var>Struct</var><code></code> for getting a domain with the desired structure from one
with weaker operational structure and for testing whether a given domain
can be regarded as a domain with <var>Struct</var>.
<p>
The functions applicable to domains with the various structures
are described in the corresponding chapters of the Reference Manual.
For example, functions for rings, fields, groups, and vector spaces
are described in Chapters&nbsp;<a href="CHAP054.htm">Rings</a>, <a href="CHAP056.htm">Fields and Division Rings</a>,
<a href="CHAP037.htm">Groups</a>, and <a href="CHAP059.htm">Vector Spaces</a>, respectively.
More general functions for arbitrary collections can be found in
Chapter&nbsp;<a href="CHAP028.htm">Collections</a>.
<p>
<p>
<h2><a name="SECT007">30.7 Parents</a></h2>
<p><p>
<a name = "SSEC007.1"></a>
<li><code>Parent( </code><var>D</var><code> ) F</code>
<a name = "SSEC007.1"></a>
<li><code>SetParent( </code><var>D</var><code>, </code><var>P</var><code> ) O</code>
<a name = "SSEC007.1"></a>
<li><code>HasParent( </code><var>D</var><code> ) F</code>
<p>
It is possible to assign to a domain <var>D</var> one other domain <var>P</var> containing
<var>D</var> as a subset,
in order to exploit this subset relation between <var>D</var> and <var>P</var>.
Note that <var>P</var> need not have the same operational structure as <var>D</var>,
for example <var>P</var> may be a magma and <var>D</var> a field.
<p>
The assignment is done by calling <code>SetParent</code>,
and <var>P</var> is called the <strong>parent</strong> of <var>D</var>.
If <var>D</var> has already a parent, calls to <code>SetParent</code> will be ignored.
<p>
If <var>D</var> has a parent <var>P</var> --this can be checked with <code>HasParent</code>--
then <var>P</var> can be used to gain information about <var>D</var>.
First, the call of <code>SetParent</code> causes <code>UseSubsetRelation</code>
(see&nbsp;<a href="CHAP030.htm#SSEC013.1">UseSubsetRelation</a>) to be called.
Second, for a domain <var>D</var> with parent, information relative to the parent
can be stored in <var>D</var>;
for example, there is an attribute <code>NormalizerInParent</code> for storing
<code>Normalizer( </code><var>P</var><code>, </code><var>D</var><code> )</code> in the case that <var>D</var> is a group.
(More about such parent dependent attributes can be found in
<a href="../ext/CHAP006.htm#SECT002">In Parent Attributes</a> in ``Extending GAP''.)
Note that because of this relative information,
one cannot change the parent;
that is, one can set the parent only once,
subsequent calls to <code>SetParent</code> for the same domain <var>D</var> are ignored.
Further note that contrary to <code>UseSubsetRelation</code>
(see&nbsp;<a href="CHAP030.htm#SSEC013.1">UseSubsetRelation</a>),
also knowledge about the parent <var>P</var> might be used
that is discovered after the <code>SetParent</code> call.
<p>
A stored parent can be accessed using <code>Parent</code>.
If <var>D</var> has no parent then <code>Parent</code> returns <var>D</var> itself,
and <code>HasParent</code> will return <code>false</code> also after a call to <code>Parent</code>.
So <code>Parent</code> is <strong>not</strong> an attribute,
the underlying attribute to store the parent is <code>ParentAttr</code>.
<p>
Certain functions that return domains with parent already set,
for example <code>Subgroup</code>,
are described in Section&nbsp;<a href="CHAP030.htm#SECT008">Constructing Subdomains</a>.
Whenever a function has this property,
the Reference Manual states this explicitly.
Note that these functions <strong>do not guarantee</strong> a certain parent,
for example <code>DerivedSubgroup</code> (see&nbsp;<a href="CHAP037.htm#SSEC012.3">DerivedSubgroup</a>) for a perfect
group <i>G</i> may return <i>G</i> itself, and if <i>G</i> had already a parent
then this is not replaced by <i>G</i>.
As a rule of thumb, <font face="Gill Sans,Helvetica,Arial">GAP</font> avoids to set a domain as its own parent,
which is consistent with the behaviour of <code>Parent</code>,
at least until a parent is set explicitly with <code>SetParent</code>.
<p>
<pre>
gap&gt; g:= Group( (1,2,3), (1,2) );; h:= Group( (1,2) );;
gap&gt; HasParent( g );  HasParent( h );
false
false
gap&gt; SetParent( h, g );
gap&gt; Parent( g );  Parent( h );
Group([ (1,2,3), (1,2) ])
Group([ (1,2,3), (1,2) ])
gap&gt; HasParent( g );  HasParent( h );
false
true
</pre>
<p>
<p>
<h2><a name="SECT008">30.8 Constructing Subdomains</a></h2>
<p><p>
<a name = "I0"></a>

For many domains <var>D</var>, there are functions that construct certain subsets <var>S</var>
of <var>D</var> as domains with parent (see&nbsp;<a href="CHAP030.htm#SECT007">Parents</a>) already set to <var>D</var>.
For example, if <var>G</var> is a group that contains the elements in the list <var>gens</var>
then <code>Subgroup( </code><var>G</var><code>, </code><var>gens</var><code> )</code> returns a group <var>S</var> that is generated by the
elements in <var>gens</var> and with <code>Parent( </code><var>S</var><code> ) = </code><var>G</var><code></code>.
<p>
<a name = "SSEC008.1"></a>
<li><code>Sub</code><var>struct</var><code>( </code><var>D</var><code>, </code><var>gens</var><code> ) F</code>
<p>
More general, if <var>D</var> is a domain whose algebraic structure is given by the
function <var>Struct</var> (for example <code>Group</code>, <code>Algebra</code>, <code>Field</code>)
then the function <code>Sub</code><var>struct</var><code></code> (for example <code>Subgroup</code>, <code>Subalgebra</code>,
<code>Subfield</code>) returns domains with structure <var>Struct</var> and parent set to
the first argument.
<p>
<a name = "SSEC008.2"></a>
<li><code>Sub</code><var>struct</var><code>NC( </code><var>D</var><code>, </code><var>gens</var><code> ) F</code>
<p>
Each function <code>Sub</code><var>struct</var><code></code> checks that the <var>Struct</var> generated by
<var>gens</var> is in fact a subset of <var>D</var>.
If one wants to omit this check then one can call <code>Sub</code><var>struct</var><code>NC</code> instead;
the suffix <code>NC</code> stands for ``no  check''.
<p>
<a name = "SSEC008.3"></a>
<li><code>AsSub</code><var>struct</var><code>( </code><var>D</var><code>, </code><var>S</var><code> ) F</code>
<p>
first constructs <code>As</code><var>struct</var><code>( [</code><var>info</var><code>, ]</code><var>S</var><code> )</code>,
where <var>info</var> depends on <var>D</var> and <var>S</var>,
and then sets the parent (see&nbsp;<a href="CHAP030.htm#SECT007">Parents</a>) of this new domain to <var>D</var>.
<p>
<a name = "SSEC008.4"></a>
<li><code>IsSub</code><var>struct</var><code>( </code><var>D</var><code>, </code><var>S</var><code> ) F</code>
<p>
There is no real need for functions that check whether a domain <var>S</var> is a
<code>Sub</code><var>struct</var><code></code> of a domain <var>D</var>,
since this is equivalent to the checks whether <var>S</var> is a <var>Struct</var> and <var>S</var>
is a subset of <var>D</var>.
Note that in many cases, only the subset relation is what one really wants
to check, and that appropriate methods for the operation <code>IsSubset</code>
(see&nbsp;<a href="CHAP028.htm#SSEC004.1">IsSubset</a>) are available for many special situations,
such as the test whether a group is contained in another group,
where only generators need to be checked.
<p>
If a function <code>IsSub</code><var>struct</var><code></code> is available in <font face="Gill Sans,Helvetica,Arial">GAP</font> then it is implemented
as first a call to <code>Is</code><var>Struct</var><code></code> for the second argument and then a call to
<code>IsSubset</code> for the two arguments.
<p>
<p>
<h2><a name="SECT009">30.9 Operations for Domains</a></h2>
<p><p>
For the meaning of the attributes <code>Characteristic</code>, <code>One</code>, <code>Zero</code>
in the case of a domain argument,
see&nbsp;<a href="CHAP030.htm#SECT010">Attributes and Properties of Elements</a>.
<p>
<a name = "SSEC009.1"></a>
<li><code>IsGeneralizedDomain( </code><var>D</var><code> ) C</code>
<a name = "SSEC009.1"></a>
<li><code>IsDomain( </code><var>D</var><code> ) C</code>
<p>
For some purposes, it is useful to deal with objects that are similar to
domains but that are not collections in the sense of <font face="Gill Sans,Helvetica,Arial">GAP</font>
because their elements may lie in different families;
such objects are called <strong>generalized domains</strong>.
An instance of generalized domains are ``operation domains'',
for example any <i>G</i>-set for a permutation group <i>G</i>
consisting of some union of points, sets of points, sets of sets of
points etc., under a suitable action.
<p>
<code>IsDomain</code> is a synonym for <code>IsGeneralizedDomain and IsCollection</code>.
<p>
<a name = "SSEC009.2"></a>
<li><code>GeneratorsOfDomain( </code><var>D</var><code> ) A</code>
<p>
For a domain <var>D</var>, <code>GeneratorsOfDomain</code> returns a list containing all
elements of <var>D</var>, perhaps with repetitions.
Note that if the domain <var>D</var> shall be generated by a list of some elements
w.r.t.&nbsp;the empty operational structure
(see&nbsp;<a href="CHAP030.htm#SECT001">Operational Structure of Domains</a>),
the only possible choice of elements is to take all elements of <var>D</var>.
See&nbsp;<a href="CHAP030.htm#SECT003">Constructing Domains</a> and <a href="CHAP030.htm#SECT004">Changing the Structure</a> for the concepts
of other notions of generation.
<p>
<a name = "SSEC009.3"></a>
<li><code>Domain( [</code><var>Fam</var><code>, ]</code><var>generators</var><code> ) F</code>
<a name = "SSEC009.3"></a>
<li><code>DomainByGenerators( </code><var>Fam</var><code>, </code><var>generators</var><code> ) O</code>
<p>
<code>Domain</code> returns the domain consisting of the elements
in the homogeneous list <var>generators</var>.
If <var>generators</var> is empty then a family <var>Fam</var> must be entered as first
argument, and the returned (empty) domain lies in the collections
family of <var>Fam</var>.
<p>
<code>DomainByGenerators</code> is the operation called by <code>Domain</code>.
<p>
<p>
<h2><a name="SECT010">30.10 Attributes and Properties of Elements</a></h2>
<p><p>
The following attributes and properties for elements and domains
correspond to the operational structure.
<p>
<a name = "SSEC010.1"></a>
<li><code>Characteristic( </code><var>obj</var><code> ) A</code>
<p>
<code>Characteristic</code> returns the <strong>characteristic</strong> of <var>obj</var>,
where <var>obj</var> must either be an additive element, a domain or a family.
<p>
For a domain <var>D</var>, the characteristic is defined if <var>D</var> is closed under
addition and has a zero element <code></code><var>z</var><code> = Zero( </code><var>D</var><code> )</code> (see&nbsp;<a href="CHAP030.htm#SSEC010.3">Zero</a>);
in this case, <code>Characteristic( </code><var>D</var><code> )</code> is the smallest positive integer
<var>p</var> such that <code></code><var>p</var><code> * </code><var>x</var><code> = </code><var>z</var><code></code> for all elements <var>x</var> in <var>D</var>,
if such an integer exists, and the integer zero <code>0</code> otherwise.
<p>
If a family has a characteristic then this means
that all domains of elements in this family have this characteristic.
In this case, also each element in the family has this characteristic.
(Note that also the zero element <i>z</i> of a finite field in characteristic
<i>p</i> has characteristic <i>p</i>, although <i>n</i> * <i>z</i> = <i>z</i> for any integer <i>n</i>.)
<p>
<a name = "SSEC010.2"></a>
<li><code>OneImmutable( </code><var>obj</var><code> ) A</code>
<a name = "SSEC010.2"></a>
<li><code>OneAttr( </code><var>obj</var><code> ) AM</code>
<a name = "SSEC010.2"></a>
<li><code>One( </code><var>obj</var><code> ) AM</code>
<a name = "SSEC010.2"></a>
<li><code>Identity( </code><var>obj</var><code> ) AM</code>
<a name = "SSEC010.2"></a>
<li><code>OneMutable( </code><var>obj</var><code> ) O</code>
<a name = "SSEC010.2"></a>
<li><code>OneOp( </code><var>obj</var><code> ) O</code>
<a name = "SSEC010.2"></a>
<li><code>OneSameMutability( </code><var>obj</var><code> ) O</code>
<a name = "SSEC010.2"></a>
<li><code>OneSM( </code><var>obj</var><code> ) O</code>
<p>
<code>OneImmutable</code>, <code>OneMutable</code>, and <code>OneSameMutability</code> return the
multiplicative neutral element of the multiplicative element <var>obj</var>.
<p>
They differ only w.r.t. the mutability of the result.
<code>OneImmutable</code> is an attribute and hence returns an immutable result.
<code>OneMutable</code> is guaranteed to return a new <strong>mutable</strong> object whenever
a mutable version of the required element exists in <font face="Gill Sans,Helvetica,Arial">GAP</font>
(see&nbsp;<a href="CHAP012.htm#SSEC006.1">IsCopyable</a>).
<code>OneSameMutability</code> returns a result that is mutable if <var>obj</var> is mutable
and if a mutable version of the required element exists in <font face="Gill Sans,Helvetica,Arial">GAP</font>;
for lists, it returns a result of the same immutability level as
the argument. For instance, if the argument is a mutable matrix
with immutable rows, it returns a similar object.
<p>
If <var>obj</var> is a multiplicative element then <code>OneSameMutability( </code><var>obj</var><code> )</code>
is equivalent to <code></code><var>obj</var><code>^0</code>.
<p>
<code>OneAttr</code>, <code>One</code> and <code>Identity</code> are synonyms of <code>OneImmutable</code>.
<code>OneSM</code> is a synonym of <code>OneSameMutability</code>.
<code>OneOp</code> is a synonym of <code>OneMutable</code>.
<p>
If <var>obj</var> is a domain or a family then <code>One</code> is defined as the identity
element of all elements in <var>obj</var>, 
provided that all these elements have the same identity.
For example, the family of all cyclotomics has the identity element <code>1</code>,
but a collections family (see&nbsp;<a href="CHAP028.htm#SSEC001.1">CollectionsFamily</a>) may contain
matrices of all dimensions and then it cannot have a unique identity
element.
Note that <code>One</code> is applicable to a domain only if it is a
magma-with-one (see&nbsp;<a href="CHAP033.htm#SSEC001.2">IsMagmaWithOne</a>);
use <code>MultiplicativeNeutralElement</code> (see&nbsp;<a href="CHAP033.htm#SSEC004.10">MultiplicativeNeutralElement</a>)
otherwise.
<p>
The identity of an object need not be distinct from its zero,
so for example a ring consisting of a single element can be regarded as a
ring-with-one (see&nbsp;<a href="CHAP054.htm">Rings</a>).
This is particularly useful in the case of finitely presented algebras,
where any factor of a free algebra-with-one is again an algebra-with-one,
no matter whether or not it is a zero algebra.
<p>
The default method of <code>One</code> for multiplicative elements calls
<code>OneMutable</code> (note that methods for <code>OneMutable</code> must <strong>not</strong> delegate to
<code>One</code>);
so other methods to compute identity elements need to be installed only
for <code>OneOp</code> and (in the case of copyable objects) <code>OneSameMutability</code>.
<p>
For domains, <code>One</code> may call <code>Representative</code> (see&nbsp;<a href="CHAP028.htm#SSEC003.7">Representative</a>),
but <code>Representative</code> is allowed to fetch the identity of a domain <var>D</var>
only if <code>HasOne( </code><var>D</var><code> )</code> is <code>true</code>.
<p>
<a name = "SSEC010.3"></a>
<li><code>ZeroImmutable( </code><var>obj</var><code> ) A</code>
<a name = "SSEC010.3"></a>
<li><code>ZeroAttr( </code><var>obj</var><code> ) AM</code>
<a name = "SSEC010.3"></a>
<li><code>Zero( </code><var>obj</var><code> ) AM</code>
<a name = "SSEC010.3"></a>
<li><code>ZeroMutable( </code><var>obj</var><code> ) O</code>
<a name = "SSEC010.3"></a>
<li><code>ZeroOp( </code><var>obj</var><code> ) O</code>
<a name = "SSEC010.3"></a>
<li><code>ZeroSameMutability( </code><var>obj</var><code> ) O</code>
<a name = "SSEC010.3"></a>
<li><code>ZeroSM( </code><var>obj</var><code> ) O</code>
<p>
<code>ZeroImmutable</code>, <code>ZeroMutable</code>, and <code>ZeroSameMutability</code> all
return the additive neutral element of the additive element <var>obj</var>.
<p>
They differ only w.r.t. the mutability of the result.
<code>ZeroImmutable</code> is an attribute and hence returns an immutable result.
<code>ZeroMutable</code> is guaranteed to return a new <strong>mutable</strong> object whenever
a mutable version of the required element exists in <font face="Gill Sans,Helvetica,Arial">GAP</font>
(see&nbsp;<a href="CHAP012.htm#SSEC006.1">IsCopyable</a>).
<code>ZeroSameMutability</code> returns a result that is mutable if <var>obj</var> is mutable
and if a mutable version of the required element exists in <font face="Gill Sans,Helvetica,Arial">GAP</font>;
for lists, it returns a result of the same immutability level as
the argument. For instance, if the argument is a mutable matrix
with immutable rows, it returns a similar object.
<p>
<code>ZeroSameMutability( </code><var>obj</var><code> )</code> is equivalent to <code>0 * </code><var>obj</var><code></code>.
<p>
<code>ZeroAttr</code> and <code>Zero</code> are synonyms of <code>ZeroImmutable</code>.
<code>ZeroSM</code> is a synonym of <code>ZeroSameMutability</code>.
<code>ZeroOp</code> is a synonym of <code>ZeroMutable</code>.
<p>
If <var>obj</var> is a domain or a family then <code>Zero</code> is defined as the zero
element of all elements in <var>obj</var>,
provided that all these elements have the same zero.
For example, the family of all cyclotomics has the zero element <code>0</code>,
but a collections family (see&nbsp;<a href="CHAP028.htm#SSEC001.1">CollectionsFamily</a>) may contain
matrices of all dimensions and then it cannot have a unique zero element.
Note that <code>Zero</code> is applicable to a domain only if it is an
additive magma-with-zero (see&nbsp;<a href="CHAP053.htm#SSEC001.5">IsAdditiveMagmaWithZero</a>);
use <code>AdditiveNeutralElement</code> (see&nbsp;<a href="CHAP053.htm#SSEC003.5">AdditiveNeutralElement</a>) otherwise.
<p>
The default method of <code>Zero</code> for additive elements calls <code>ZeroMutable</code>
(note that methods for <code>ZeroMutable</code> must <strong>not</strong> delegate to <code>Zero</code>);
so other methods to compute zero elements need to be installed only for
<code>ZeroMutable</code> and (in the case of copyable objects) <code>ZeroSameMutability</code>.
<p>
For domains, <code>Zero</code> may call <code>Representative</code> (see&nbsp;<a href="CHAP028.htm#SSEC003.7">Representative</a>),
but <code>Representative</code> is allowed to fetch the zero of a domain <var>D</var>
only if <code>HasZero( </code><var>D</var><code> )</code> is <code>true</code>.
<p>
<a name = "SSEC010.4"></a>
<li><code>MultiplicativeZeroOp( </code><var>elt</var><code> ) O</code>
<p>
returns the element <i>z</i> in the family <var>F</var> of <var>elt</var> with the 
property that <i>z</i> * <i>m</i> = <i>z</i> = <i>m</i> * <i>z</i> holds for all <i>m</i>  &#8712; <i>F</i>,
if such an element is known.
<p>
Families of elements in the category IsMultiplicativeElementWithZero
often arise from adjoining a new zero to an existing magma. 
See&nbsp;<a href="CHAP033.htm#SSEC002.12">InjectionZeroMagma</a> for details.
<p>
<a name = "SSEC010.5"></a>
<li><code>IsOne( </code><var>elm</var><code> ) P</code>
<p>
is <code>true</code> if <code></code><var>elm</var><code> = One( </code><var>elm</var><code> )</code>, and <code>false</code> otherwise.
<p>
<a name = "SSEC010.6"></a>
<li><code>IsZero( </code><var>elm</var><code> ) P</code>
<p>
is <code>true</code> if <code></code><var>elm</var><code> = Zero( </code><var>elm</var><code> )</code>, and <code>false</code> otherwise.
<p>
<a name = "SSEC010.7"></a>
<li><code>IsIdempotent( </code><var>elt</var><code> ) P</code>
<p>
true iff <var>elt</var> is its own square. 
(Even if IsZero(<var>elt</var>) is also true.)
<p>
<a name = "SSEC010.8"></a>
<li><code>InverseImmutable( </code><var>elm</var><code> ) A</code>
<a name = "SSEC010.8"></a>
<li><code>InverseAttr( </code><var>elm</var><code> ) AM</code>
<a name = "SSEC010.8"></a>
<li><code>Inverse( </code><var>elm</var><code> ) AM</code>
<a name = "SSEC010.8"></a>
<li><code>InverseMutable( </code><var>elm</var><code> ) O</code>
<a name = "SSEC010.8"></a>
<li><code>InverseOp( </code><var>elm</var><code> ) O</code>
<a name = "SSEC010.8"></a>
<li><code>InverseSameMutability( </code><var>elm</var><code> ) O</code>
<a name = "SSEC010.8"></a>
<li><code>InverseSM( </code><var>elm</var><code> ) O</code>
<p>
<code>InverseImmutable</code>, <code>InverseMutable</code>, and <code>InverseSameMutability</code>
all return the multiplicative inverse of an element <var>elm</var>,
that is, an element <var>inv</var> such that
<code></code><var>elm</var><code> * </code><var>inv</var><code> = </code><var>inv</var><code> * </code><var>elm</var><code> = One( </code><var>elm</var><code> )</code> holds;
if <var>elm</var> is not invertible then <code>fail</code> (see&nbsp;<a href="CHAP020.htm#SSEC001.1">Fail</a>) is returned.
<p>
Note that the above definition implies that a (general) mapping
is invertible in the sense of <code>Inverse</code> only if its source equals its
range (see&nbsp;<a href="CHAP031.htm#SECT013">Technical Matters Concerning General Mappings</a>).
For a bijective mapping <i>f</i> whose source and range differ,
<code>InverseGeneralMapping</code> (see&nbsp;<a href="CHAP031.htm#SSEC001.3">InverseGeneralMapping</a>) can be used
to construct a mapping <i>g</i> with the property
that <i>f</i> <tt>*</tt> <i>g</i> is the identity mapping on the source of <i>f</i>
and <i>g</i> <tt>*</tt> <i>f</i> is the identity mapping on the range of <i>f</i>.
<p>
The operations differ only w.r.t. the mutability of the result.
<code>InverseImmutable</code> is an attribute and hence returns an immutable result.
<code>InverseMutable</code> is guaranteed to return a new <strong>mutable</strong> object whenever
a mutable version of the required element exists in <font face="Gill Sans,Helvetica,Arial">GAP</font>.
<code>InverseSameMutability</code> returns a result that is mutable if <var>elm</var> is
mutable and if a mutable version of the required element exists in
<font face="Gill Sans,Helvetica,Arial">GAP</font>; for lists, it returns a result of the same immutability level as
the argument. For instance, if the argument is a mutable matrix
with immutable rows, it returns a similar object.
<p>
<code>InverseSameMutability( </code><var>elm</var><code> )</code> is equivalent to <code></code><var>elm</var><code>^-1</code>.
<p>
<code>InverseAttr</code> and <code>Inverse</code> are synonyms of <code>InverseImmutable</code>.
<code>InverseSM</code> is a synonym of <code>InverseSameMutability</code>.
<code>InverseOp</code> is a synonym of <code>InverseMutable</code>.
<p>
The default method of <code>InverseImmutable</code> calls <code>InverseMutable</code> (note that methods
for <code>InverseMutable</code> must <strong>not</strong> delegate to <code>InverseImmutable</code>);
other methods to compute inverses need to be installed only for
<code>InverseMutable</code> and (in the case of copyable objects)
<code>InverseSameMutability</code>.
<p>
<a name = "SSEC010.9"></a>
<li><code>AdditiveInverseImmutable( </code><var>elm</var><code> ) A</code>
<a name = "SSEC010.9"></a>
<li><code>AdditiveInverseAttr( </code><var>elm</var><code> ) AM</code>
<a name = "SSEC010.9"></a>
<li><code>AdditiveInverse( </code><var>elm</var><code> ) AM</code>
<a name = "SSEC010.9"></a>
<li><code>AdditiveInverseMutable( </code><var>elm</var><code> ) O</code>
<a name = "SSEC010.9"></a>
<li><code>AdditiveInverseOp( </code><var>elm</var><code> ) O</code>
<a name = "SSEC010.9"></a>
<li><code>AdditiveInverseSameMutability( </code><var>elm</var><code> ) O</code>
<a name = "SSEC010.9"></a>
<li><code>AdditiveInverseSM( </code><var>elm</var><code> ) O</code>
<p>
<code>AdditiveInverseImmutable</code>, <code>AdditiveInverseMutable</code>, and 
<code>AdditiveInverseSameMutability</code> all return the
additive inverse of <var>elm</var>.
<p>
They differ only w.r.t. the mutability of the result.
<code>AdditiveInverseImmutable</code> is an attribute and hence returns an
immutable result.  <code>AdditiveInverseMutable</code> is guaranteed to
return a new <strong>mutable</strong> object whenever a mutable version of the
required element exists in <font face="Gill Sans,Helvetica,Arial">GAP</font> (see&nbsp;<a href="CHAP012.htm#SSEC006.1">IsCopyable</a>).
<code>AdditiveInverseSameMutability</code> returns a result that is mutable
if <var>elm</var> is mutable and if a mutable version of the required
element exists in <font face="Gill Sans,Helvetica,Arial">GAP</font>;
for lists, it returns a result of the same immutability level as
the argument. For instance, if the argument is a mutable matrix
with immutable rows, it returns a similar object.
<p>
<code>AdditiveInverseSameMutability( </code><var>elm</var><code> )</code> is equivalent to <code>-</code><var>elm</var><code></code>.
<p>
<code>AdditiveInverseAttr</code> and <code>AdditiveInverse</code> are synonyms of <code>AdditiveInverseImmutable</code>.
<code>AdditiveInverseSM</code> is a synonym of <code>AdditiveInverseSameMutability</code>.
<code>AdditiveInverseOp</code> is a synonym of <code>AdditiveInverseMutable</code>.
<p>
The default method of <code>AdditiveInverse</code> calls <code>AdditiveInverseMutable</code>
(note that methods for <code>AdditiveInverseMutable</code> must <strong>not</strong> delegate to
<code>AdditiveInverse</code>);
so other methods to compute additive inverses need to be installed only
for <code>AdditiveInverseMutable</code> and (in the case of copyable objects)
<code>AdditiveInverseSameMutability</code>.
<p>
<a name = "SSEC010.10"></a>
<li><code>Order( </code><var>elm</var><code> ) A</code>
<p>
is the multiplicative order of <var>elm</var>.
This is the smallest positive integer <var>n</var> such that
<code></code><var>elm</var><code>^</code><var>n</var><code> = One( </code><var>elm</var><code> )</code> if such an integer exists. If the order is
infinite, <code>Order</code> may return the value <code>infinity</code>, but it also might run
into an infinite loop trying to test the order.
<p>
<p>
<h2><a name="SECT011">30.11 Comparison Operations for Elements</a></h2>
<p><p>
Binary comparison operations have been introduced already in <a href="CHAP004.htm#SECT011">Comparisons</a>.
The underlying operations for which methods can be installed are the
following.
<p>
<a name = "SSEC011.1"></a>
<li><code>\=( </code><var>left-expr</var><code>, </code><var>right-expr</var><code> ) O</code>
<a name = "SSEC011.1"></a>
<li><code>\&lt;( </code><var>left-expr</var><code>, </code><var>right-expr</var><code> ) O</code>
<p>
Note that the comparisons via <code>&lt;&gt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code> are delegated to
the operations <code>\=</code> and <code>\&lt;</code>.
<p>
In general, objects in <strong>different</strong> families cannot be compared with <code>&lt;</code>.
For the reason and for exceptions from this rule, see&nbsp;<a href="CHAP004.htm#SECT011">Comparisons</a>.
<p>
For some objects a ``normal form'' is hard to compute and thus equality of
elements of a domain might be expensive to test. Therefore <font face="Gill Sans,Helvetica,Arial">GAP</font>
provides a (slightly technical) property with which an algorithm can test
whether an efficient equality test is available for elements of a certain
kind.
<p>
<a name = "SSEC011.2"></a>
<li><code>CanEasilyCompareElements( </code><var>obj</var><code> ) P</code>
<a name = "SSEC011.2"></a>
<li><code>CanEasilyCompareElementsFamily( </code><var>fam</var><code> ) F</code>
<a name = "SSEC011.2"></a>
<li><code>CanEasilySortElements( </code><var>obj</var><code> ) P</code>
<a name = "SSEC011.2"></a>
<li><code>CanEasilySortElementsFamily( </code><var>fam</var><code> ) F</code>
<p>
<code>CanEasilyCompareElements</code> indicates whether the elements in the family
<var>fam</var> of <var>obj</var> can be easily compared with <code>=</code>.
(In some cases element comparisons are very hard, for example in cases
where no normal forms for the elements exist.)
<p>
The default method for this property is to ask the family of <var>obj</var>,
the default method for the family is to return <code>false</code>.
<p>
The ability to compare elements may depend on the successful computation
of certain information. (For example for finitely presented groups it
might depend on the knowledge of a faithful permutation representation.)
This information might change over time and thus it might not be a good
idea to store a value <code>false</code> too early in a family. Instead the
function <code>CanEasilyCompareElementsFamily</code> should be called for the
family of <var>obj</var> which returns <code>false</code> if the value of
<code>CanEasilyCompareElements</code> is not known for the family without computing
it. (This is in fact what the above mentioned family dispatch does.)
<p>
If a family knows ab initio that it can compare elements this property
should be set as implied filter <strong>and</strong> filter for the family (the 3rd and
4th argument of <code>NewFamily</code> respectively). This guarantees that code
which directly asks the family gets a right answer.
<p>
The property <code>CanEasilySortElements</code> and the function
<code>CanEasilySortElementsFamily</code> behave exactly in the same way, except
that they indicate that objects can be compared via <code>&lt;</code>. This property
implies <code>CanEasilyCompareElements</code>, as the ordering must be total.
<p>
<p>
<h2><a name="SECT012">30.12 Arithmetic Operations for Elements</a></h2>
<p><p>
<strong>Binary</strong> arithmetic operations have been introduced already in
<a href="CHAP004.htm#SECT012">Arithmetic Operators</a>.
The underlying operations for which methods can be installed are the
following.
<p>
<a name = "SSEC012.1"></a>
<li><code>\+( </code><var>left-expr</var><code>, </code><var>right-expr</var><code> ) O</code>
<a name = "SSEC012.1"></a>
<li><code>\*( </code><var>left-expr</var><code>, </code><var>right-expr</var><code> ) O</code>
<a name = "SSEC012.1"></a>
<li><code>\/( </code><var>left-expr</var><code>, </code><var>right-expr</var><code> ) O</code>
<a name = "SSEC012.1"></a>
<li><code>\^( </code><var>left-expr</var><code>, </code><var>right-expr</var><code> ) O</code>
<a name = "SSEC012.1"></a>
<li><code>\mod( </code><var>left-expr</var><code>, </code><var>right-expr</var><code> ) O</code>
<p>
For details about special methods for <code>\mod</code>, consult the index entries
for ``mod''.
<p>
<a name = "SSEC012.2"></a>
<li><code>LeftQuotient( </code><var>elm1</var><code>, </code><var>elm2</var><code> ) O</code>
<p>
returns the product <code></code><var>elm1</var><code>^(-1) * </code><var>elm2</var><code></code>.
For some types of objects (for example permutations) this product can be
evaluated more efficiently than by first inverting <var>elm1</var>
and then forming the product with <var>elm2</var>.
<p>
<a name = "SSEC012.3"></a>
<li><code>Comm( </code><var>elm1</var><code>, </code><var>elm2</var><code> ) O</code>
<p>
returns the <strong>commutator</strong> of <var>elm1</var> and <var>elm2</var>. The commutator is defined
as the product <i>elm</i>1 <sup>&#8722;1</sup> * <i>elm</i>2 <sup>&#8722;1</sup> * <i>elm</i>1  * <i>elm</i>2 .
<p>
<pre>
gap&gt; a:= (1,3)(4,6);; b:= (1,6,5,4,3,2);;
gap&gt; Comm( a, b );
(1,5,3)(2,6,4)
gap&gt; LeftQuotient( a, b );
(1,2)(3,6)(4,5)
</pre>
<p>
<a name = "SSEC012.4"></a>
<li><code>LieBracket( </code><var>elm1</var><code>, </code><var>elm2</var><code> ) O</code>
<p>
returns the element <code></code><var>elm1</var><code> * </code><var>elm2</var><code> - </code><var>elm2</var><code> * </code><var>elm1</var><code></code>.
<p>
The addition <code>\+</code> is assumed to be associative but <strong>not</strong> assumed to be
commutative (see&nbsp;<a href="CHAP053.htm#SSEC003.1">IsAdditivelyCommutative</a>).
The multiplication <code>\*</code> is <strong>not</strong> assumed to be commutative or associative
(see&nbsp;<a href="CHAP033.htm#SSEC004.9">IsCommutative</a>, <a href="CHAP033.htm#SSEC004.7">IsAssociative</a>).
<p>
<a name = "SSEC012.5"></a>
<li><code>Sqrt( </code><var>obj</var><code> ) O</code>
<p>
<code>Sqrt</code> returns a square root of <var>obj</var>, that is, an object <i>x</i> with the
property that <i>x</i> &#183;<i>x</i> = <i>obj</i>  holds.
If such an <i>x</i> is not unique then the choice of <i>x</i> depends on the type
of <var>obj</var>.
For example, <code>ER</code> (see&nbsp;<a href="CHAP018.htm#SSEC004.2">ER</a>) is the <code>Sqrt</code> method for rationals
(see&nbsp;<a href="CHAP016.htm#SSEC001.1">IsRat</a>).
<p>
<p>
<h2><a name="SECT013">30.13 Relations Between Domains</a></h2>
<p><p>
Domains are often constructed relative to other domains.
The probably most usual case is to form a <strong>subset</strong> of a domain,
for example the intersection (see&nbsp;<a href="CHAP028.htm#SSEC004.2">Intersection</a>) of two domains,
or a Sylow subgroup of a given group (see&nbsp;<a href="CHAP037.htm#SSEC013.1">SylowSubgroup</a>).
<p>
In such a situation, the new domain can gain knowledge by exploiting that
several attributes are maintained under taking subsets.
For example, the intersection of an arbitrary domain with a finite domain
is clearly finite, a Sylow subgroup of an abelian group is abelian, too,
and so on.
<p>
Since usually the new domain has access to the knowledge of the old domain(s)
only when it is created (see&nbsp;<a href="CHAP030.htm#SECT008">Constructing Subdomains</a> for the exception),
this is the right moment to take advantage of the subset relation.
<p>
Analogous relations occur when a <strong>factor structure</strong> is created from a domain
and a subset, and when a domain <strong>isomorphic</strong> to a given one is created.
<p>
<a name = "SSEC013.1"></a>
<li><code>UseSubsetRelation( </code><var>super</var><code>, </code><var>sub</var><code> ) O</code>
<p>
Methods for this operation transfer possibly useful information from the
domain <var>super</var> to its subset <var>sub</var>, and vice versa.
<p>
<code>UseSubsetRelation</code> is designed to be called automatically
whenever substructures of domains are constructed.
So the methods must be <strong>cheap</strong>, and the requirements should be as
sharp as possible!
<p>
To achieve that <strong>all</strong> applicable methods are executed, all methods for
this operation except the default method must end with <code>TryNextMethod()</code>.
This default method deals with the information that is available by
the calls of <code>InstallSubsetMaintenance</code> in the <font face="Gill Sans,Helvetica,Arial">GAP</font> library.
<p>
<pre>
gap&gt; g:= Group( (1,2), (3,4), (5,6) );; h:= Group( (1,2), (3,4) );;
gap&gt; IsAbelian( g );  HasIsAbelian( h );
true
false
gap&gt; UseSubsetRelation( g, h );;  HasIsAbelian( h );  IsAbelian( h );
true
true
</pre>
<p>
<a name = "SSEC013.2"></a>
<li><code>UseIsomorphismRelation( </code><var>old</var><code>, </code><var>new</var><code> ) O</code>
<p>
Methods for this operation transfer possibly useful information from the
domain <var>old</var> to the isomorphic domain <var>new</var>.
<p>
<code>UseIsomorphismRelation</code> is designed to be called automatically
whenever isomorphic structures of domains are constructed.
So the methods must be <strong>cheap</strong>, and the requirements should be as
sharp as possible!
<p>
To achieve that <strong>all</strong> applicable methods are executed, all methods for
this operation except the default method must end with <code>TryNextMethod()</code>.
This default method deals with the information that is available by
the calls of <code>InstallIsomorphismMaintenance</code> in the <font face="Gill Sans,Helvetica,Arial">GAP</font> library.
<p>
<pre>
gap&gt; g:= Group( (1,2) );;  h:= Group( [ [ -1 ] ] );;
gap&gt; Size( g );  HasSize( h );
2
false
gap&gt; UseIsomorphismRelation( g, h );;  HasSize( h );  Size( h );
true
2
</pre>
<p>
<a name = "SSEC013.3"></a>
<li><code>UseFactorRelation( </code><var>numer</var><code>, </code><var>denom</var><code>, </code><var>factor</var><code> ) O</code>
<p>
Methods for this operation transfer possibly useful information from the
domain <var>numer</var> or its subset <var>denom</var> to the domain <var>factor</var> that
is isomorphic to the factor of <var>numer</var> by <var>denom</var>, and vice versa.
<var>denom</var> may be <code>fail</code>, for example if <var>factor</var> is just known to be a
factor of <var>numer</var> but <var>denom</var> is not available as a <font face="Gill Sans,Helvetica,Arial">GAP</font> object;
in this case those factor relations are used that are installed without
special requirements for <var>denom</var>.
<p>
<code>UseFactorRelation</code> is designed to be called automatically
whenever factor structures of domains are constructed.
So the methods must be <strong>cheap</strong>, and the requirements should be as
sharp as possible!
<p>
To achieve that <strong>all</strong> applicable methods are executed, all methods for
this operation except the default method must end with <code>TryNextMethod()</code>.
This default method deals with the information that is available by
the calls of <code>InstallFactorMaintenance</code> in the <font face="Gill Sans,Helvetica,Arial">GAP</font> library.
<p>
<pre>
gap&gt; g:= Group( (1,2,3,4), (1,2) );; h:= Group( (1,2,3), (1,2) );;
gap&gt; IsSolvableGroup( g );  HasIsSolvableGroup( h );
true
false
gap&gt; UseFactorRelation( g, Subgroup( g, [ (1,2)(3,4), (1,3)(2,4) ] ), h );;
gap&gt; HasIsSolvableGroup( h );  IsSolvableGroup( h );
true
true
</pre>
<p>
The following functions are used to tell <font face="Gill Sans,Helvetica,Arial">GAP</font> under what conditions
an attribute is maintained under taking subsets,
or forming factor structures or isomorphic domains.
This is used only when a new attribute is created,
see&nbsp;<a href="../prg/CHAP003.htm#SECT003">Creating Attributes and Properties</a> in ``Programming in <font face="Gill Sans,Helvetica,Arial">GAP</font>''.
For the attributes already available, such as <code>IsFinite</code> and <code>IsCommutative</code>,
the maintenances are already notified.
<p>
<a name = "SSEC013.4"></a>
<li><code>InstallSubsetMaintenance( </code><var>opr</var><code>, </code><var>super_req</var><code>, </code><var>sub_req</var><code> ) F</code>
<p>
<var>opr</var> must be a property or an attribute.
The call of <code>InstallSubsetMaintenance</code> has the effect that
for a domain <var>D</var> in the filter <var>super_req</var>, and a domain <var>S</var> in the
filter <var>sub_req</var>,
the call <code>UseSubsetRelation( </code><var>D</var><code>, </code><var>S</var><code> )</code> (see&nbsp;<a href="CHAP030.htm#SSEC013.1">UseSubsetRelation</a>)
sets a known value of <var>opr</var> for <var>D</var> as value of <var>opr</var> also for <var>S</var>.
A typical example for which <code>InstallSubsetMaintenance</code> is applied
is given by <code></code><var>opr</var><code> = IsFinite</code>,
<code></code><var>super_req</var><code> = IsCollection and IsFinite</code>,
and <code></code><var>sub_req</var><code> = IsCollection</code>.
<p>
If <var>opr</var> is a property and the filter <var>super_req</var> lies in the filter
<var>opr</var> then we can use also the following inverse implication.
If <i>D</i> is in the filter whose intersection with <var>opr</var> is <var>super_req</var>
and if <i>S</i> is in the filter <var>sub_req</var>, <i>S</i> is a subset of <i>D</i>, and
the value of <var>opr</var> for <i>S</i> is <code>false</code>
then the value of <var>opr</var> for <i>D</i> is also <code>false</code>.
<p>
<a name = "SSEC013.5"></a>
<li><code>InstallIsomorphismMaintenance( </code><var>opr</var><code>, </code><var>old_req</var><code>, </code><var>new_req</var><code> ) F</code>
<p>
<var>opr</var> must be a property or an attribute.
The call of <code>InstallIsomorphismMaintenance</code> has the effect that
for a domain <var>D</var> in the filter <var>old_req</var>, and a domain <var>E</var> in the
filter <var>new_req</var>,
the call <code>UseIsomorphismRelation( </code><var>D</var><code>, </code><var>E</var><code> )</code>
(see&nbsp;<a href="CHAP030.htm#SSEC013.2">UseIsomorphismRelation</a>)
sets a known value of <var>opr</var> for <var>D</var> as value of <var>opr</var> also for <var>E</var>.
A typical example for which <code>InstallIsomorphismMaintenance</code> is
applied is given by <code></code><var>opr</var><code> = Size</code>,
<code></code><var>old_req</var><code> = IsCollection</code>, and <code></code><var>new_req</var><code> = IsCollection</code>.
<p>
<a name = "SSEC013.6"></a>
<li><code>InstallFactorMaintenance( </code><var>opr</var><code>, </code><var>numer_req</var><code>, </code><var>denom_req</var><code>, </code><var>factor_req</var><code> ) F</code>
<p>
<var>opr</var> must be a property or an attribute.
The call of <code>InstallFactorMaintenance</code> has the effect that
for collections <var>N</var>, <var>D</var>, <var>F</var> in the filters <var>numer_req</var>, <var>denom_req</var>,
and <var>factor_req</var>, respectively,
the call <code>UseFactorRelation( </code><var>N</var><code>, </code><var>D</var><code>, </code><var>F</var><code> )</code>
(see&nbsp;<a href="CHAP030.htm#SSEC013.3">UseFactorRelation</a>)
sets a known value of <var>opr</var> for <var>N</var> as value of <var>opr</var> also for <var>F</var>.
A typical example for which <code>InstallFactorMaintenance</code> is
applied is given by <code></code><var>opr</var><code> = IsFinite</code>,
<code></code><var>numer_req</var><code> = IsCollection and IsFinite</code>, <code></code><var>denom_req</var><code> = IsCollection</code>,
and <code></code><var>factor_req</var><code> = IsCollection</code>.
<p>
For the other direction, if <var>numer_req</var> involves the filter <var>opr</var>
then a known <code>false</code> value of <var>opr</var> for <i>F</i> implies a <code>false</code>
value for <i>D</i> provided that <i>D</i> lies in the filter obtained from
<var>numer_req</var> by removing <var>opr</var>.
<p>
Note that an implication of a factor relation holds in particular for the
case of isomorphisms.
So one need <strong>not</strong> install an isomorphism maintained method when
a factor maintained method is already installed.
For example, <code>UseIsomorphismRelation</code> (see&nbsp;<a href="CHAP030.htm#SSEC013.2">UseIsomorphismRelation</a>)
will transfer a known <code>IsFinite</code> value because of the installed factor
maintained method.
<p>
<p>
<h2><a name="SECT014">30.14 Useful Categories of Elements</a></h2>
<p><p>
This section and the following one are rather technical,
and may be interesting only for those <font face="Gill Sans,Helvetica,Arial">GAP</font> users who want to implement
new kinds of elements.
<p>
It deals with certain categories of elements that are useful mainly for the
design of elements, from the viewpoint that one wants to form certain domains
of these elements.
For example, a domain closed under multiplication <code>*</code> (a so-called magma,
see Chapter&nbsp;<a href="CHAP033.htm">Magmas</a>) makes sense only if its elements can be multiplied,
and the latter is indicated by the category <code>IsMultiplicativeElement</code>
for each element.
Again note that the underlying idea is that a domain is regarded as
<strong>generated</strong> by given elements, and that these elements carry information
about the desired domain.
For general information on categories and their hierarchies,
see&nbsp;<a href="CHAP013.htm#SECT003">Categories</a>.
<p>
<a name = "SSEC014.1"></a>
<li><code>IsExtAElement( </code><var>obj</var><code> ) C</code>
<p>
An <strong>external additive element</strong> is an object that can be added via <code>+</code>
with other elements (not necessarily in the same family, see&nbsp;<a href="CHAP013.htm#SECT001">Families</a>).
<p>
<a name = "SSEC014.2"></a>
<li><code>IsNearAdditiveElement( </code><var>obj</var><code> ) C</code>
<p>
A <strong>near-additive element</strong> is an object that can be added via <code>+</code>
with elements in its family (see&nbsp;<a href="CHAP013.htm#SECT001">Families</a>);
this addition is not necessarily commutative.
<p>
<a name = "SSEC014.3"></a>
<li><code>IsAdditiveElement( </code><var>obj</var><code> ) C</code>
<p>
An <strong>additive element</strong> is an object that can be added via <code>+</code>
with elements in its family (see&nbsp;<a href="CHAP013.htm#SECT001">Families</a>);
this addition is commutative.
<p>
<a name = "SSEC014.4"></a>
<li><code>IsNearAdditiveElementWithZero( </code><var>obj</var><code> ) C</code>
<p>
A <strong>near-additive element-with-zero</strong> is an object that can be added
via <code>+</code> with elements in its family (see&nbsp;<a href="CHAP013.htm#SECT001">Families</a>),
and that is an admissible argument for the operation <code>Zero</code> (see&nbsp;<a href="CHAP030.htm#SSEC010.3">Zero</a>);
this addition is not necessarily commutative.
<p>
<a name = "SSEC014.5"></a>
<li><code>IsAdditiveElementWithZero( </code><var>obj</var><code> ) C</code>
<p>
An <strong>additive element-with-zero</strong> is an object that can be added
via <code>+</code> with elements in its family (see&nbsp;<a href="CHAP013.htm#SECT001">Families</a>),
and that is an admissible argument for the operation <code>Zero</code> (see&nbsp;<a href="CHAP030.htm#SSEC010.3">Zero</a>);
this addition is commutative.
<p>
<a name = "SSEC014.6"></a>
<li><code>IsNearAdditiveElementWithInverse( </code><var>obj</var><code> ) C</code>
<p>
A <strong>near-additive element-with-inverse</strong> is an object that can be
added via <code>+</code> with elements in its family (see&nbsp;<a href="CHAP013.htm#SECT001">Families</a>),
and that is an admissible argument for the operations <code>Zero</code> (see&nbsp;<a href="CHAP030.htm#SSEC010.3">Zero</a>)
and <code>AdditiveInverse</code> (see&nbsp;<a href="CHAP030.htm#SSEC010.9">AdditiveInverse</a>);
this addition is not necessarily commutative.
<p>
<a name = "SSEC014.7"></a>
<li><code>IsAdditiveElementWithInverse( </code><var>obj</var><code> ) C</code>
<p>
An <strong>additive element-with-inverse</strong> is an object that can be
added via <code>+</code> with elements in its family (see&nbsp;<a href="CHAP013.htm#SECT001">Families</a>),
and that is an admissible argument for the operations <code>Zero</code> (see&nbsp;<a href="CHAP030.htm#SSEC010.3">Zero</a>)
and <code>AdditiveInverse</code> (see&nbsp;<a href="CHAP030.htm#SSEC010.9">AdditiveInverse</a>);
this addition is commutative.
<p>
<a name = "SSEC014.8"></a>
<li><code>IsExtLElement( </code><var>obj</var><code> ) C</code>
<p>
An <strong>external left element</strong> is an object that can be multiplied from the
left, via <code>*</code>, with other elements (not necessarily in the same family,
see&nbsp;<a href="CHAP013.htm#SECT001">Families</a>).
<p>
<a name = "SSEC014.9"></a>
<li><code>IsExtRElement( </code><var>obj</var><code> ) C</code>
<p>
An <strong>external right element</strong> is an object that can be multiplied from the
right, via <code>*</code>, with other elements (not necessarily in the same family,
see&nbsp;<a href="CHAP013.htm#SECT001">Families</a>).
<p>
<a name = "SSEC014.10"></a>
<li><code>IsMultiplicativeElement( </code><var>obj</var><code> ) C</code>
<p>
A <strong>multiplicative element</strong> is an object that can be multiplied via <code>*</code>
with elements in its family (see&nbsp;<a href="CHAP013.htm#SECT001">Families</a>).
<p>
<a name = "SSEC014.11"></a>
<li><code>IsMultiplicativeElementWithOne( </code><var>obj</var><code> ) C</code>
<p>
A <strong>multiplicative element-with-one</strong> is an object that can be multiplied
via <code>*</code> with elements in its family (see&nbsp;<a href="CHAP013.htm#SECT001">Families</a>),
and that is an admissible argument for the operation <code>One</code> (see&nbsp;<a href="CHAP030.htm#SSEC010.2">One</a>).
<p>
<a name = "SSEC014.12"></a>
<li><code>IsMultiplicativeElementWithZero( </code><var>elt</var><code> ) C</code>
<p>
Elements in a family which can be the operands of the 
<code>*</code> and the operation MultiplicativeZero.
<p>
<a name = "SSEC014.13"></a>
<li><code>IsMultiplicativeElementWithInverse( </code><var>obj</var><code> ) C</code>
<p>
A <strong>multiplicative element-with-inverse</strong> is an object that can be
multiplied via <code>*</code> with elements in its family (see&nbsp;<a href="CHAP013.htm#SECT001">Families</a>),
and that is an admissible argument for the operations <code>One</code> (see&nbsp;<a href="CHAP030.htm#SSEC010.2">One</a>)
and <code>Inverse</code> (see&nbsp;<a href="CHAP030.htm#SSEC010.8">Inverse</a>). (Note the word ``admissible'': an
object in this category does not necessarily have an inverse, <code>Inverse</code>
may return <code>fail</code>.)
<p>
<a name = "SSEC014.14"></a>
<li><code>IsVector( </code><var>obj</var><code> ) C</code>
<p>
A <strong>vector</strong> is an additive-element-with-inverse that can be multiplied
from the left and right with other objects (not necessarily of the same
type).
Examples are cyclotomics, finite field elements,
and of course row vectors (see below).
<p>
Note that not all lists of ring elements are regarded as vectors,
for example lists of matrices are not vectors.
This is because although the category <code>IsAdditiveElementWithInverse</code> is
implied by the join of its collections category and <code>IsList</code>,
the family of a list entry may not imply <code>IsAdditiveElementWithInverse</code>
for all its elements.
<p>
<a name = "SSEC014.15"></a>
<li><code>IsNearRingElement( </code><var>obj</var><code> ) C</code>
<p>
<code>IsNearRingElement</code> is just a synonym for the join of
<code>IsNearAdditiveElementWithInverse</code> and <code>IsMultiplicativeElement</code>.
<p>
<a name = "SSEC014.16"></a>
<li><code>IsRingElement( </code><var>obj</var><code> ) C</code>
<p>
<code>IsRingElement</code> is just a synonym for the join of
<code>IsAdditiveElementWithInverse</code> and <code>IsMultiplicativeElement</code>.
<p>
<a name = "SSEC014.17"></a>
<li><code>IsNearRingElementWithOne( </code><var>obj</var><code> ) C</code>
<p>
<code>IsNearRingElementWithOne</code> is just a synonym for the join of
<code>IsNearAdditiveElementWithInverse</code> and <code>IsMultiplicativeElementWithOne</code>.
<p>
<a name = "SSEC014.18"></a>
<li><code>IsRingElementWithOne( </code><var>obj</var><code> ) C</code>
<p>
<code>IsRingElementWithOne</code> is just a synonym for the join of
<code>IsAdditiveElementWithInverse</code> and <code>IsMultiplicativeElementWithOne</code>.
<p>
<a name = "SSEC014.19"></a>
<li><code>IsNearRingElementWithInverse( </code><var>obj</var><code> ) C</code>
<p>
<a name = "SSEC014.20"></a>
<li><code>IsRingElementWithInverse( </code><var>obj</var><code> ) C</code>
<a name = "SSEC014.20"></a>
<li><code>IsScalar( </code><var>obj</var><code> ) C</code>
<p>
<code>IsRingElementWithInverse</code> and <code>IsScalar</code> are just synonyms for the join
of
<code>IsAdditiveElementWithInverse</code> and <code>IsMultiplicativeElementWithInverse</code>.
<p>
More special categories of this kind are described in the contexts where
they arise,
they are <code>IsRowVector</code> (see&nbsp;<a href="CHAP023.htm">IsRowVector</a>),
<code>IsMatrix</code> (see&nbsp;<a href="CHAP024.htm#SSEC001.1">IsMatrix</a>),
<code>IsOrdinaryMatrix</code> (see&nbsp;<a href="CHAP024.htm#SSEC001.2">IsOrdinaryMatrix</a>),
and <code>IsLieMatrix</code> (see&nbsp;<a href="CHAP024.htm#SSEC001.3">IsLieMatrix</a>).
<p>
<p>
<h2><a name="SECT015">30.15 Useful Categories for all Elements of a Family</a></h2>
<p><p>
The following categories of elements are to be understood mainly as
categories for all objects in a family,
they are usually used as third argument of <code>NewFamily</code>
(see&nbsp;<a href="../prg/CHAP003.htm#SECT006">Creating Families</a> in ``Programming in <font face="Gill Sans,Helvetica,Arial">GAP</font>'').
The purpose of each of the following categories is then to guarantee that
each collection of its elements automatically lies in its collections
category (see&nbsp;<a href="CHAP028.htm#SSEC001.4">CategoryCollections</a>).
<p>
For example, the multiplication of permutations is associative,
and it is stored in the family of permutations that each permutation lies
in <code>IsAssociativeElement</code>.
As a consequence, each magma consisting of permutations
(more precisely: each collection that lies in the family
<code>CollectionsFamily( PermutationsFamily )</code>, see&nbsp;<a href="CHAP028.htm#SSEC001.1">CollectionsFamily</a>)
automatically lies in <code>CategoryCollections( IsAssociativeElement )</code>.
A magma in this category is always known to be associative, via a logical
implication (see&nbsp;<a href="../prg/CHAP002.htm#SECT007">Logical Implications</a> in ``Programming in <font face="Gill Sans,Helvetica,Arial">GAP</font>'').
<p>
Similarly, if a family knows that all its elements are in the categories
<code>IsJacobianElement</code> and <code>IsZeroSquaredElement</code>,
then each algebra of these elements is automatically known to be a
Lie algebra (see&nbsp;<a href="CHAP060.htm">Algebras</a>).
<p>
<a name = "SSEC015.1"></a>
<li><code>IsAssociativeElement( </code><var>obj</var><code> ) C</code>
<a name = "SSEC015.1"></a>
<li><code>IsAssociativeElementCollection( </code><var>obj</var><code> ) C</code>
<a name = "SSEC015.1"></a>
<li><code>IsAssociativeElementCollColl( </code><var>obj</var><code> ) C</code>
<p>
An element <var>obj</var> in the category <code>IsAssociativeElement</code> knows
that the multiplication of any elements in the family of <var>obj</var>
is associative.
For example, all permutations lie in this category, as well as those
ordinary matrices (see&nbsp;<a href="CHAP024.htm#SSEC001.2">IsOrdinaryMatrix</a>) whose entries are also in
<code>IsAssociativeElement</code>.
<p>
<a name = "SSEC015.2"></a>
<li><code>IsAdditivelyCommutativeElement( </code><var>obj</var><code> ) C</code>
<a name = "SSEC015.2"></a>
<li><code>IsAdditivelyCommutativeElementCollection( </code><var>obj</var><code> ) C</code>
<a name = "SSEC015.2"></a>
<li><code>IsAdditivelyCommutativeElementCollColl( </code><var>obj</var><code> ) C</code>
<a name = "SSEC015.2"></a>
<li><code>IsAdditivelyCommutativeElementFamily( </code><var>obj</var><code> ) C</code>
<p>
An element <var>obj</var> in the category <code>IsAdditivelyCommutativeElement</code> knows
that the addition of any elements in the family of <var>obj</var>
is commutative.
For example, each finite field element and each rational number lies in
this category.
<p>
<a name = "SSEC015.3"></a>
<li><code>IsCommutativeElement( </code><var>obj</var><code> ) C</code>
<a name = "SSEC015.3"></a>
<li><code>IsCommutativeElementCollection( </code><var>obj</var><code> ) C</code>
<a name = "SSEC015.3"></a>
<li><code>IsCommutativeElementCollColl( </code><var>obj</var><code> ) C</code>
<p>
An element <var>obj</var> in the category <code>IsCommutativeElement</code> knows
that the multiplication of any elements in the family of <var>obj</var>
is commutative.
For example, each finite field element and each rational number lies in
this category.
<p>
<a name = "SSEC015.4"></a>
<li><code>IsFiniteOrderElement( </code><var>obj</var><code> ) C</code>
<a name = "SSEC015.4"></a>
<li><code>IsFiniteOrderElementCollection( </code><var>obj</var><code> ) C</code>
<a name = "SSEC015.4"></a>
<li><code>IsFiniteOrderElementCollColl( </code><var>obj</var><code> ) C</code>
<p>
An element <var>obj</var> in the category <code>IsFiniteOrderElement</code> knows
that it has finite multiplicative order.
For example, each finite field element and each permutation lies in
this category.
However the value may be <code>false</code> even if <var>obj</var> has finite order,
but if this was not known when <var>obj</var> was constructed.
<p>
Although it is legal to set this filter for any object with finite order,
this is really useful only in the case that all elements of a family are
known to have finite order.
<p>
<a name = "SSEC015.5"></a>
<li><code>IsJacobianElement( </code><var>obj</var><code> ) C</code>
<a name = "SSEC015.5"></a>
<li><code>IsJacobianElementCollection( </code><var>obj</var><code> ) C</code>
<a name = "SSEC015.5"></a>
<li><code>IsJacobianElementCollColl( </code><var>obj</var><code> ) C</code>
<p>
An element <var>obj</var> in the category <code>IsJacobianElement</code> knows
that the multiplication of any elements in the family <i>F</i> of <var>obj</var>
satisfies the Jacobi identity, that is,
<i>x</i> * <i>y</i> * <i>z</i> + <i>z</i> * <i>x</i> * <i>y</i> + <i>y</i> * <i>z</i> * <i>x</i> is zero
for all <i>x</i>, <i>y</i>, <i>z</i> in <i>F</i>.
<p>
For example, each Lie matrix (see&nbsp;<a href="CHAP024.htm#SSEC001.3">IsLieMatrix</a>) lies in this category.
<p>
<a name = "SSEC015.6"></a>
<li><code>IsZeroSquaredElement( </code><var>obj</var><code> ) C</code>
<a name = "SSEC015.6"></a>
<li><code>IsZeroSquaredElementCollection( </code><var>obj</var><code> ) C</code>
<a name = "SSEC015.6"></a>
<li><code>IsZeroSquaredElementCollColl( </code><var>obj</var><code> ) C</code>
<p>
An element <var>obj</var> in the category <code>IsZeroSquaredElement</code> knows
that <code></code><var>obj</var><code>^2 = Zero( </code><var>obj</var><code> )</code>.
For example, each Lie matrix (see&nbsp;<a href="CHAP024.htm#SSEC001.3">IsLieMatrix</a>) lies in this category.
<p>
Although it is legal to set this filter for any zero squared object,
this is really useful only in the case that all elements of a family are
known to have square zero.
<p>
<p>
[<a href="../index.htm">Top</a>] [<a href = "chapters.htm">Up</a>] [<a href ="CHAP029.htm">Previous</a>] [<a href ="CHAP031.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<P>
<font face="Gill Sans,Helvetica,Arial">GAP 4 manual<br>October 2007
</font></body></html>