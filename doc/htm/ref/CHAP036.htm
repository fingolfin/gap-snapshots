<html><head><title>[ref] 36 Rewriting Systems</title></head>
<body text="#000000" bgcolor="#ffffff">
[<a href="../index.htm">Top</a>] [<a href = "chapters.htm">Up</a>] [<a href ="CHAP035.htm">Previous</a>] [<a href ="CHAP037.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<h1>36 Rewriting Systems</h1><p>
<P>
<H3>Sections</H3>
<oL>
<li> <A HREF="CHAP036.htm#SECT001">Operations on rewriting systems</a>
<li> <A HREF="CHAP036.htm#SECT002">Operations on elements of the algebra</a>
<li> <A HREF="CHAP036.htm#SECT003">Properties of rewriting systems</a>
<li> <A HREF="CHAP036.htm#SECT004">Rewriting in Groups and Monoids</a>
<li> <A HREF="CHAP036.htm#SECT005">Developing rewriting systems</a>
</ol><p>
<p>
Rewriting systems in <font face="Gill Sans,Helvetica,Arial">GAP</font> are a framework for dealing with 
the very general task of rewriting elements of a free (or <strong>term</strong>) algebra
in some normal form.  Although most rewriting systems currently in use
are <strong>string rewriting systems</strong> (where the algebra has only one 
binary operation which is associative) the framework in <font face="Gill Sans,Helvetica,Arial">GAP</font>
is general enough to encompass the task of rewriting algebras of
any signature from groups to semirings.
<p>
Rewriting systems are already implemented in  <font face="Gill Sans,Helvetica,Arial">GAP</font> 
for finitely presented semigroups and for pc groups. The use of these 
particular rewriting systems is described in the corresponding chapters.
We describe here only the general framework of rewriting systems with 
a particular emphasis on material which would be 
helpful for a  developer implementing a rewriting system. 
<p>
We fix some definitions and terminology for the rest of this chapter.
Let <var>T</var> be a term algebra in some signature. 
A <strong>term rewriting system</strong> for <var>T</var> is a set of ordered pairs of 
elements of <var>T</var> of the form <var>(l, r)</var>. Viewed as a set of relations, the 
rewriting system determines a presentation for a quotient algebra <var>A</var> of <var>T</var>. 
<p>
When we take into account the fact that
the relations are expressed as <strong>ordered</strong> pairs, we have a way of 
<strong>reducing</strong> the elements of <var>T</var>. Suppose an element <var>u</var> of <var>T</var> has a 
subword <var>l</var> and <var>(l,r)</var> is a rule of the rewriting system, then
we can replace the subterm <var>l</var> of <var>u</var> by the term <var>r</var> and obtain a new 
word <var>v</var>. We say that we have <strong>rewritten</strong> <var>u</var> as <var>v</var>. 
Note that <var>u</var> and <var>v</var> represent the same 
element of <var>A</var>.
If <var>u</var> can not be rewritten using any rule of the rewriting system
we sat that <var>u</var> is <strong>reduced</strong>. 
<p>
<p>
<h2><a name="SECT001">36.1 Operations on rewriting systems</a></h2>
<p><p>
<a name = "SSEC001.1"></a>
<li><code>IsRewritingSystem( </code><var>obj</var><code> ) C</code>
<p>
This is the category in which all rewriting systems lie.
<p>
<a name = "SSEC001.2"></a>
<li><code>Rules( </code><var>rws</var><code> ) A</code>
<p>
The rules comprising the rewriting system. Note that these may 
change through the life of the rewriting system, however they
will always be a set of defining relations of the algebra
described by the rewriting system.
<p>
<a name = "SSEC001.3"></a>
<li><code>OrderOfRewritingSystem( </code><var>rws</var><code> ) A</code>
<a name = "SSEC001.3"></a>
<li><code>OrderingOfRewritingSystem( </code><var>rws</var><code> ) A</code>
<p>
return the ordering of the rewriting system <var>rws</var>.
<p>
<a name = "SSEC001.4"></a>
<li><code>ReducedForm( </code><var>rws</var><code>, </code><var>u</var><code> ) O</code>
<p>
Given an element <var>u</var> in the free (or term) algebra over which
<var>rws</var> is defined, rewrite <var>u</var> by successive applications of the
rules of <var>rws</var> until no further rewriting is possible, and return
the resulting element of <var>T</var>.
<p>
<a name = "SSEC001.5"></a>
<li><code>IsConfluent( </code><var>rws</var><code> ) P</code>
<li><code>IsConfluent( </code><var>A</var><code> ) P</code>
<p>
return <code>true</code> if and only if the rewriting system <var>rws</var> is confluent. 
A rewriting system is <strong>confluent</strong> if, for every two words 
<var>u</var> and <var>v</var> in the free algebra <var>T</var> which represent the same element 
of the algebra <var>A</var> defined by <var>rws</var>,
<code>ReducedForm(</code><var>rws</var><code>,</code><var>u</var><code>) =  ReducedForm(</code><var>rws</var><code>,</code><var>v</var><code>)</code> as words in the
free algebra <var>T</var>. This element is the <strong>unique normal form</strong>
of the element represented by <var>u</var>.
<p>
In its second
form, if <var>A</var> is an algebra with a canonical rewriting system associated
with it, <code>IsConfluent</code> checks whether that rewriting system is confluent.
<p>
Also see&nbsp;<a href="CHAP044.htm#SSEC004.7">IsConfluent!for pc groups</a>.
<p>
<a name = "SSEC001.6"></a>
<li><code>ConfluentRws( </code><var>rws</var><code> ) A</code>
<p>
Return a new rewriting system defining the same algebra as <var>rws</var> 
which is confluent.
<p>
<a name = "SSEC001.7"></a>
<li><code>IsReduced( </code><var>rws</var><code> ) P</code>
<p>
A rewriting system is reduced if for each rule (<var>l</var>, <var>r</var>), 
<var>l</var> and <var>r</var> are both reduced.
<p>
<a name = "SSEC001.8"></a>
<li><code>ReduceRules( </code><var>rws</var><code> ) O</code>
<p>
Reduce rules and remove redundant rules to make <var>rws</var> reduced.
<p>
<a name = "SSEC001.9"></a>
<li><code>AddRule( </code><var>rws</var><code>, </code><var>rule</var><code> ) O</code>
<p>
Add  <var>rule</var> to a rewriting system <var>rws</var>. 
<p>
<a name = "SSEC001.10"></a>
<li><code>AddRuleReduced( </code><var>rws</var><code>, </code><var>rule</var><code> ) O</code>
<p>
Add <var>rule</var> to rewriting system <var>rws</var>. Performs a reduction operation
on the resulting system, so that if <var>rws</var> is reduced it will remain reduced.
<p>
<a name = "SSEC001.11"></a>
<li><code>MakeConfluent( </code><var>rws</var><code> ) O</code>
<p>
Add rules (and perhaps reduce) in order to make <var>rws</var> confluent
<p>
<a name = "SSEC001.12"></a>
<li><code>GeneratorsOfRws( </code><var>rws</var><code> ) A</code>
<p>
<a name = "SSEC001.13"></a>
<li><code>AddGenerators( </code><var>rws</var><code>, </code><var>gens</var><code> ) O</code>
<p>
<p>
<h2><a name="SECT002">36.2 Operations on elements of the algebra</a></h2>
<p><p>
In this section let <var>u</var> denote an element of the term algebra
<var>T</var> representing <var>[u]</var> in  the quotient algebra <var>A</var>.
<p>
<a name = "SSEC002.1"></a>
<li><code>ReducedProduct( </code><var>rws</var><code>, </code><var>u</var><code>, </code><var>v</var><code> ) O</code>
<p>
The result is  <var>w</var> where <var>[w]</var> = <var>[u]</var><var>[v]</var> in <var>A</var> and
<var>w</var> is  in reduced form.
<p>
The remaining operations are defined similarly when they 
are defined (as determined by the  signature  of the term algebra).
<a name = "SSEC002.2"></a>
<li><code>ReducedSum( </code><var>rws</var><code>, </code><var>left</var><code>, </code><var>right</var><code> ) O</code>
<p>
<a name = "SSEC002.3"></a>
<li><code>ReducedOne( </code><var>rws</var><code> ) O</code>
<p>
<a name = "SSEC002.4"></a>
<li><code>ReducedAdditiveInverse( </code><var>rws</var><code>, </code><var>obj</var><code> ) O</code>
<p>
<a name = "SSEC002.5"></a>
<li><code>ReducedComm( </code><var>rws</var><code>, </code><var>left</var><code>, </code><var>right</var><code> ) O</code>
<p>
<a name = "SSEC002.6"></a>
<li><code>ReducedConjugate( </code><var>rws</var><code>, </code><var>left</var><code>, </code><var>right</var><code> ) O</code>
<p>
<a name = "SSEC002.7"></a>
<li><code>ReducedDifference( </code><var>rws</var><code>, </code><var>left</var><code>, </code><var>right</var><code> ) O</code>
<p>
<a name = "SSEC002.8"></a>
<li><code>ReducedInverse( </code><var>rws</var><code>, </code><var>obj</var><code> ) O</code>
<p>
<a name = "SSEC002.9"></a>
<li><code>ReducedLeftQuotient( </code><var>rws</var><code>, </code><var>left</var><code>, </code><var>right</var><code> ) O</code>
<p>
<a name = "SSEC002.10"></a>
<li><code>ReducedPower( </code><var>rws</var><code>, </code><var>obj</var><code>, </code><var>pow</var><code> ) O</code>
<p>
<a name = "SSEC002.11"></a>
<li><code>ReducedQuotient( </code><var>rws</var><code>, </code><var>left</var><code>, </code><var>right</var><code> ) O</code>
<p>
<a name = "SSEC002.12"></a>
<li><code>ReducedScalarProduct( </code><var>rws</var><code>, </code><var>left</var><code>, </code><var>right</var><code> ) O</code>
<p>
<a name = "SSEC002.13"></a>
<li><code>ReducedZero( </code><var>rws</var><code> ) O</code>
<p>
<p>
<h2><a name="SECT003">36.3 Properties of rewriting systems</a></h2>
<p><p>
The following properties may be used to identify the 
type of term algebra over which the rewriting system is defined.
<p>
<a name = "SSEC003.1"></a>
<li><code>IsBuiltFromAdditiveMagmaWithInverses( </code><var>obj</var><code> ) P</code>
<p>
<a name = "SSEC003.2"></a>
<li><code>IsBuiltFromMagma( </code><var>obj</var><code> ) P</code>
<p>
<a name = "SSEC003.3"></a>
<li><code>IsBuiltFromMagmaWithOne( </code><var>obj</var><code> ) P</code>
<p>
<a name = "SSEC003.4"></a>
<li><code>IsBuiltFromMagmaWithInverses( </code><var>obj</var><code> ) P</code>
<p>
<a name = "SSEC003.5"></a>
<li><code>IsBuiltFromSemigroup( </code><var>obj</var><code> ) P</code>
<p>
<a name = "SSEC003.6"></a>
<li><code>IsBuiltFromGroup( </code><var>obj</var><code> ) P</code>
<p>
<p>
<h2><a name="SECT004">36.4 Rewriting in Groups and Monoids</a></h2>
<p><p>
One application of rewriting is to reduce words in finitely presented groups
and monoids. The rewriting system still has to be built for a finitely
presented monoid (using <code>IsomorphismFpMonoid</code> for conversion). Rewriting
then can take place for words in the underlying free monoid. (These can be
obtained from monoid elements with the command <code>UnderlyingElement</code>.)
<p>
<pre>
gap&gt; f:=FreeGroup(3);;
gap&gt; rels:=[f.1*f.2^2/f.3,f.2*f.3^2/f.1,f.3*f.1^2/f.2];;
gap&gt; g:=f/rels;
&lt;fp group on the generators [ f1, f2, f3 ]&gt;
gap&gt; mhom:=IsomorphismFpMonoid(g);
MappingByFunction( &lt;fp group on the generators 
[ f1, f2, f3 ]&gt;, &lt;fp monoid on the generators 
[ f1^-1, f1, f2^-1, f2, f3^-1, f3 
 ]&gt;, function( x ) ... end, function( x ) ... end )
gap&gt; mon:=Image(mhom);
&lt;fp monoid on the generators [ f1^-1, f1, f2^-1, f2, f3^-1, f3 ]&gt;
gap&gt; k:=KnuthBendixRewritingSystem(mon);
Knuth Bendix Rewriting System for Monoid( [ f1^-1, f1, f2^-1, f2, f3^-1, f3 
 ], ... ) with rules 
[ [ f1^-1*f1, &lt;identity ...&gt; ], [ f1*f1^-1, &lt;identity ...&gt; ], 
  [ f2^-1*f2, &lt;identity ...&gt; ], [ f2*f2^-1, &lt;identity ...&gt; ], 
  [ f3^-1*f3, &lt;identity ...&gt; ], [ f3*f3^-1, &lt;identity ...&gt; ], 
  [ f1*f2^2*f3^-1, &lt;identity ...&gt; ], [ f2*f3^2*f1^-1, &lt;identity ...&gt; ], 
  [ f3*f1^2*f2^-1, &lt;identity ...&gt; ] ]
gap&gt; MakeConfluent(k);
gap&gt; a:=Product(GeneratorsOfMonoid(mon));
f1^-1*f1*f2^-1*f2*f3^-1*f3
gap&gt; ReducedForm(k,UnderlyingElement(a));
&lt;identity ...&gt;
</pre>
<p>
To rewrite a word in the finitely presented group, one has to convert it to
a word in the monoid first, rewrite in the underlying free monoid and
convert back (by forming first again an element of the fp monoid) to the
finitely presented group.
<p>
<pre>
gap&gt; r:=PseudoRandom(g);;
gap&gt; Length(r);
3704
gap&gt; red:=ReducedForm(k,UnderlyingElement(melm));
f1^-1^3*f2^-1*f1^2
gap&gt; melm:=ElementOfFpMonoid(FamilyObj(One(mon)),red);
f1^-1^3*f2^-1*f1^2
gap&gt; gpelm:=PreImagesRepresentative(mhom,melm);
f1^-3*f2^-1*f1^2
gap&gt; r=gpelm;
true
gap&gt; CategoriesOfObject(red);
[ "IsExtLElement", "IsExtRElement", "IsMultiplicativeElement", 
  "IsMultiplicativeElementWithOne", "IsAssociativeElement", "IsWord" ]
gap&gt; CategoriesOfObject(melm);
[ "IsExtLElement", "IsExtRElement", "IsMultiplicativeElement", 
  "IsMultiplicativeElementWithOne", "IsAssociativeElement", 
  "IsElementOfFpMonoid" ]
gap&gt; CategoriesOfObject(gpelm);
[ "IsExtLElement", "IsExtRElement", "IsMultiplicativeElement", 
  "IsMultiplicativeElementWithOne", "IsMultiplicativeElementWithInverse", 
  "IsAssociativeElement", "IsElementOfFpGroup" ]
</pre>
<p>
Note, that the elements <code>red</code> (free monoid) <code>melm</code> (fp monoid) and <code>gpelm</code>
(group) differ, though they are displayed identically.
<p>
Under Unix, it is possible to use the <code>kbmag</code> package to replace the
built-in rewriting by this packages efficient C implementation. You can do
this (after loading the <code>kbmag</code> package) by assigning the variable <code>KB_REW</code>
to <code>KBMAG_REW</code>.  Assignment to <code>GAPKB_REW</code> reverts to the built-in
implementation. (See section&nbsp;<a href="CHAP051.htm#SSEC005.2">KB_REW</a>.)
<pre>
gap&gt; LoadPackage("kbmag");
true
gap&gt; KB_REW:=KBMAG_REW;;
</pre>
<p>
<p>
<h2><a name="SECT005">36.5 Developing rewriting systems</a></h2>
<p><p>
The key point to note about rewriting systems is that they have 
properties such as <code>IsConfluent</code> and attributes such as <code>Rules</code>, however
they are rarely stored, but rather computed afresh each time they
are asked for, from data stored in the private members of the rewriting
system object.  This is because a rewriting system often evolves
through a session, starting with some rules which define the
algebra <var>A</var> as relations, and then adding more rules to make
the system confluent.
For example, in the case of Knuth-Bendix rewriting systems
(see Chapter&nbsp;<a href="CHAP051.htm">Finitely Presented Semigroups and Monoids</a>), the function
<code>CreateKnuthBendixRewritingSystem</code> creating the
rewriting system (in <code>kbsemi.gi</code>) uses
<p>
<pre>
kbrws := Objectify(NewType(rwsfam, 
  IsMutable and IsKnuthBendixRewritingSystem and 
  IsKnuthBendixRewritingSystemRep), 
  rec(family:= fam,
  reduced:=false,
  tzrules:=List(relwco,i-&gt;
   [LetterRepAssocWord(i[1]),LetterRepAssocWord(i[2])]),
  pairs2check:=CantorList(Length(r)),
  ordering:=wordord,
  freefam:=freefam));
</pre>
<p>
In particular, since we don't use the filter <code>IsAttributeStoringRep</code>
in the <code>Objectify</code>, whenever <code>IsConfluent</code> is called, the appropriate
method to determine confluence is called. 
<p>
<p>
[<a href="../index.htm">Top</a>] [<a href = "chapters.htm">Up</a>] [<a href ="CHAP035.htm">Previous</a>] [<a href ="CHAP037.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<P>
<font face="Gill Sans,Helvetica,Arial">GAP 4 manual<br>March 2004
</font></body></html>