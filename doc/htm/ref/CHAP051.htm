<html><head><title>[ref] 51 Finitely Presented Semigroups and Monoids</title></head>
<body text="#000000" bgcolor="#ffffff">
[<a href="../index.htm">Top</a>] [<a href = "chapters.htm">Up</a>] [<a href ="CHAP050.htm">Previous</a>] [<a href ="CHAP052.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<h1>51 Finitely Presented Semigroups and Monoids</h1><p>
<P>
<H3>Sections</H3>
<oL>
<li> <A HREF="CHAP051.htm#SECT001">Creating Finitely Presented Semigroups</a>
<li> <A HREF="CHAP051.htm#SECT002">Comparison of Elements of Finitely Presented Semigroups</a>
<li> <A HREF="CHAP051.htm#SECT003">Preimages in the Free Semigroup</a>
<li> <A HREF="CHAP051.htm#SECT004">Finitely presented monoids</a>
<li> <A HREF="CHAP051.htm#SECT005">Rewriting Systems and the Knuth-Bendix Procedure</a>
<li> <A HREF="CHAP051.htm#SECT006">Todd-Coxeter Procedure</a>
</ol><p>
<p>
A <strong>finitely presented semigroup</strong> (resp. <strong>finitely presented monoid</strong>)
is a quotient of a free semigroup (resp. free monoid) on a finite 
number of generators over a finitely generated congruence on
the free semigroup (resp. free monoid).
<p>
Finitely presented semigroups are obtained by factoring a free semigroup 
by a set of relations (a generating set for the congruence), ie, a set of
pairs of words in the free semigroup.
<p>
<pre>
gap&gt; f:=FreeSemigroup("a","b");;
gap&gt; x:=GeneratorsOfSemigroup(f);;
gap&gt; s:=f/[ [x[1]*x[2],x[2]*x[1]] ];
&lt;fp semigroup on the generators [ a, b ]&gt;
gap&gt; GeneratorsOfSemigroup(s);
[ a, b ]
gap&gt; RelationsOfFpSemigroup(s);
[ [ a*b, b*a ] ]
</pre>
<p>
Finitely presented monoids are obtained by factoring a free monoid by
a set of relations, i.e. a set of pairs of words in the free monoid. 
<p>
<pre>
gap&gt; f:=FreeMonoid("a","b");;
gap&gt; x:=GeneratorsOfMonoid(f);
[ a, b ]
gap&gt; e:=Identity(f);
&lt;identity ...&gt;
gap&gt; m:=f/[ [x[1]*x[2],e] ];
&lt;fp monoid on the generators [ a, b ]&gt;
gap&gt; RelationsOfFpMonoid(m);
[ [ a*b, &lt;identity ...&gt; ] ]
</pre>
<p>
Notice that for <font face="Gill Sans,Helvetica,Arial">GAP</font> a finitely presented monoid is not a finitely 
presented semigroup.
<p>
<pre>
gap&gt; IsFpSemigroup(m);
false
</pre>
<p>
However, one can build a finitely presented semigroup isomorphic
to that finitely presented monoid (see <a href="CHAP051.htm#SSEC001.3">IsomorphismFpSemigroup</a>).
<p>
Also note that is not possible to refer to the generators by their names.
These names are not variables, but just display figures.
So, if one wants to access the generators by their names, one first has to 
introduce the respective variables and to assign the generators to them.
<p>
<pre>
gap&gt; f:=FreeSemigroup("a","b");;
gap&gt; x:=GeneratorsOfSemigroup(f);;
gap&gt; s:=f/[ [x[1]*x[2],x[2]*x[1]] ];;
gap&gt; a;
Variable: 'a' must have a value

gap&gt; a:=GeneratorsOfSemigroup(s)[1];
a
gap&gt; b:=GeneratorsOfSemigroup(s)[2];
b
gap&gt; a in f;
false
gap&gt; a in s;
true
</pre>
<p>
The generators of the free semigroup (resp. free monoid) are different 
from the generators of the finitely presented semigroup (resp. finitely
presented monoid) (even though they are displayed by the same names). 
This means that words in the generators of the free semigroup (resp.
free monoid) are not elements of the finitely presented semigroup (resp. 
finitely presented monoid). Conversely elements of the finitely presented 
semigroup (resp. finitely presented monoid) are not words of the free
semigroup (resp. free monoid).
<p>
Calculations comparing elements of an finitely presented semigroup
may run into problems: there are finitely presented semigroups for 
which no algorithm exists (it is known that no such algorithm can exist) 
that will tell for two arbitrary words in the generators whether the 
corresponding elements in the finitely presented semigroup are equal.  
Therefore the methods used by <font face="Gill Sans,Helvetica,Arial">GAP</font> to compute in finitely presented 
semigroups may run into warning errors, run out of memory or run forever. 
If the finitely presented semigroup is (by theory) known to be 
finite the algorithms are guaranteed to terminate (if there is sufficient 
memory available), but the time needed for the calculation cannot be 
bounded a priori. The same can be said for monoids.
(See <a href="CHAP051.htm#SECT005">Rewriting Systems and the Knuth-Bendix Procedure</a>.)
<p>
<pre>
gap&gt; a*b=a^5;
false
gap&gt; a^5*b^2*a=a^6*b^2;
true
</pre>
<p>
Note than elements of a finitely presented semigroup (or monoid) are not 
printed in a unique way:
<p>
<pre>
gap&gt; a^5*b^2*a;
a^5*b^2*a
gap&gt; a^6*b^2;
a^6*b^2
</pre>
<p>
<a name = ""></a>
<li><code>IsSubsemigroupFpSemigroup( </code><var>t</var><code> ) A</code>
<p>
	true if <var>t</var> is a finitely presented semigroup or a 
	subsemigroup of a finitely presented semigroup
	(generally speaking, such a subsemigroup can be constructed
	with <code>Semigroup(</code><var>gens</var><code>)</code>, where <var>gens</var> is a list of elements
	of a finitely presented semigroup).
<p>
<a name = ""></a>
<li><code>IsSubmonoidFpMonoid( </code><var>t</var><code> ) A</code>
<p>
	true if <var>t</var> is a finitely presented monoid or a 
	submonoid of a finitely presented monoid 
	(generally speaking, such a semigroup can be constructed
	with <code>Monoid(</code><var>gens</var><code>)</code>, where <var>gens</var> is a list of elements
	of a finitely presented monoid).
<p>
	A submonoid of a monoid has the same identity as the monoid.
<p>
<a name = ""></a>
<li><code>IsFpSemigroup( </code><var>s</var><code> ) P</code>
<p>
is a synonym for <code>IsSubsemigroupFpSemigroup(</code><var>s</var><code>)</code> and 
<code>IsWholeFamily(</code><var>s</var><code>)</code> (this is because a subsemigroup
of a finitely presented semigroup is not necessarily finitely presented).
<p>
<a name = ""></a>
<li><code>IsFpMonoid( </code><var>m</var><code> ) P</code>
<p>
is a synonym for <code>IsSubmonoidFpMonoid(</code><var>m</var><code>)</code> and 
<code>IsWholeFamily(</code><var>m</var><code>)</code> (this is because a submonoid 
of a finitely presented monoid is not necessarily finitely presented).
<p>
<a name = ""></a>
<li><code>IsElementOfFpSemigroup( </code><var>elm</var><code> ) C</code>
<p>
	returns true if <var>elm</var> is an element of a finitely presented semigroup. 
<p>
<a name = ""></a>
<li><code>IsElementOfFpMonoid( </code><var>elm</var><code> ) C</code>
<p>
	returns true if <var>elm</var> is an element of a finitely presented monoid. 
<p>
<a name = ""></a>
<li><code>FpGrpMonSmgOfFpGrpMonSmgElement( </code><var>elm</var><code> ) O</code>
<p>
	returns the finitely presented group, monoid or semigroup to which 
	<var>elm</var> belongs
<p>
<pre>
gap&gt; f := FreeSemigroup("a","b");;
gap&gt; a := GeneratorsOfSemigroup( f )[ 1 ];;
gap&gt; b := GeneratorsOfSemigroup( f )[ 2 ];;
gap&gt; s := f / [ [ a^2 , a*b ] ];;
gap&gt; IsFpSemigroup( s );
true
gap&gt; t := Semigroup( [ GeneratorsOfSemigroup( s )[ 1 ] ]);
&lt;semigroup with 1 generator&gt;
gap&gt; IsSubsemigroupFpSemigroup( t );
true
gap&gt; IsElementOfFpSemigroup( GeneratorsOfSemigroup( t )[ 1 ] );
true
</pre>
<p>
<p>
<h2><a name="SECT001">51.1 Creating Finitely Presented Semigroups</a></h2>
<p><p>
<a name = "SSEC001.1"></a>
<li><code></code><var>F</var><code>/</code><var>rels</var><code></code>
<p>
creates a finitely presented semigroup given by the presentation
&#9001;<i>gens</i>  | <i>rels</i> &#9002; where <var>gens</var> are the generators of the free
semigroup <var>F</var>, and the relations <var>rels</var> are entered as pairs of words in the
generators of  the free semigroup. 
<p>
<pre>
gap&gt; f:=FreeSemigroup(3);;
gap&gt; s:=GeneratorsOfSemigroup(f);;
gap&gt; f/[ [s[1]*s[2]*s[1],s[1]] , [s[2]^4,s[1]] ];
&lt;fp semigroup on the generators [ s1, s2, s3 ]&gt;
</pre>
<p>
One may also call the following functions to construct finitely
presented semigroups:
<a name = "SSEC001.2"></a>
<li><code>FactorFreeSemigroupByRelations( </code><var>f</var><code>, </code><var>rels</var><code> ) F</code>
<p>
for a free semigroup <var>f</var> and <var>rels</var> is a list of
pairs of elements of <var>f</var>. Returns the finitely presented semigroup 
which is the quotient of <var>f</var> by the least congruence on <var>f</var> generated by
the pairs in <var>rels</var>.
<p>
<pre>
gap&gt; FactorFreeSemigroupByRelations(f,[[s[1]*s[2]*s[1],s[1]],[s[2]^4,s[1]]]);
&lt;fp semigroup on the generators [ s1, s2, s3 ]&gt;
</pre>
<p>
Finally, if one has a finitely presented group or a finitely presented 
monoid, to find an isomorphic finitely presented semigroup use
<a name = "SSEC001.3"></a>
<li><code>IsomorphismFpSemigroup( </code><var>s</var><code> ) A</code>
<p>
for a semigroup <var>s</var> returns an isomorphism from <var>s</var> to a 
finitely presented semigroup 
<p>
<pre>
gap&gt; f := FreeGroup(2);;
gap&gt; g := f/[f.1^4,f.2^5];
&lt;fp group on the generators [ f1, f2 ]&gt;
gap&gt; phi := IsomorphismFpSemigroup(g);
MappingByFunction( &lt;fp group on the generators 
[ f1, f2 ]&gt;, &lt;fp semigroup on the generators 
[ &lt;identity ...&gt;, f1^-1, f1, f2^-1, f2 
 ]&gt;, function( x ) ... end, function( x ) ... end )
gap&gt; s := Range(phi);
&lt;fp semigroup on the generators [ &lt;identity ...&gt;, f1^-1, f1, f2^-1, f2 ]&gt;
</pre>
<p>
<p>
<h2><a name="SECT002">51.2 Comparison of Elements of Finitely Presented Semigroups</a></h2>
<p><p>
<a name = "SSEC002.1"></a>
<li><code></code><var>a</var><code> = </code><var>b</var><code></code>
<p>
Two elements of a finitely presented semigroup are equal if they are equal in
the semigroup. Nevertheless they may be represented as different words in the
generators. Because of the fundamental problems mentioned in the
introduction to this chapter such a test may take a very long time and cannot be
guaranteed to finish (see <a href="CHAP051.htm#SECT005">Rewriting Systems and the Knuth-Bendix Procedure</a>).
<p>
<p>
<h2><a name="SECT003">51.3 Preimages in the Free Semigroup</a></h2>
<p><p>
<a name = "SSEC003.1"></a>
<li><code>FreeSemigroupOfFpSemigroup( </code><var>s</var><code> ) A</code>
<p>
	returns the underlying free semigroup for the finitely presented 
	semigroup <var>s</var>, ie, the free semigroup over which <var>s</var> is defined 
	as a quotient
	(this is the free semigroup generated by the free generators provided 
	by <code>FreeGeneratorsOfFpSemigroup(</code><var>s</var><code>)</code>).
<p>
<a name = "SSEC003.2"></a>
<li><code>FreeGeneratorsOfFpSemigroup( </code><var>s</var><code> ) A</code>
<p>
returns the underlying free generators corresponding to the 
	generators of the finitely presented semigroup <var>s</var>.  
<p>
<a name = "SSEC003.3"></a>
<li><code>RelationsOfFpSemigroup( </code><var>s</var><code> ) A</code>
<p>
returns the relations of the finitely presented semigroup <var>s</var> as
pairs of words in the free generators provided by
<code>FreeGeneratorsOfFpSemigroup(</code><var>s</var><code>)</code>.
<p>
<pre>
gap&gt; f := FreeSemigroup( "a" , "b" );;
gap&gt; a := GeneratorsOfSemigroup( f )[ 1 ];;
gap&gt; b := GeneratorsOfSemigroup( f )[ 2 ];;
gap&gt; s := f / [ [ a^3 , a ] , [ b^3 , b ] , [ a*b , b*a ] ];
&lt;fp semigroup on the generators [ a, b ]&gt;
gap&gt; Size( s );
8
gap&gt; fs := FreeSemigroupOfFpSemigroup( s );;
gap&gt; f = fs;
true
gap&gt; FreeGeneratorsOfFpSemigroup( s );
[ a, b ]
gap&gt; RelationsOfFpSemigroup( s );
[ [ a^3, a ], [ b^3, b ], [ a*b, b*a ] ]
</pre>
<p>
Elements of a finitely presented semigroup are not words, but are represented
using a word from the free semigroup as representative. 
<p>
<a name = "SSEC003.4"></a>
<li><code>UnderlyingElement( </code><var>elm</var><code> ) O</code>
<p>
for an element <var>elm</var> of a finitely presented semigroup, it 
returns the word from the free semigroup that is used as a
representative for <var>elm</var>.
<p>
<pre>
gap&gt; w := GeneratorsOfSemigroup(s)[1] * GeneratorsOfSemigroup(s)[2];
a*b
gap&gt; IsWord (w );
false
gap&gt; ue := UnderlyingElement( w );
a*b
gap&gt; IsWord( ue );
true
</pre>
<p>
<a name = "SSEC003.5"></a>
<li><code>ElementOfFpSemigroup( </code><var>fam</var><code>, </code><var>w</var><code> ) O</code>
<p>
for a family <var>fam</var> of elements of a finitely presented semigroup and 
a word <var>w</var> in the free generators underlying this finitely presented
semigroup, this operation creates the element of the finitely 
presented semigroup with the representative <var>w</var> in the free semigroup.
<p>
<pre>
gap&gt; fam := FamilyObj( GeneratorsOfSemigroup(s)[1] );;
gap&gt; ge := ElementOfFpSemigroup( fam, a*b );
a*b
gap&gt; ge in f;
false
gap&gt; ge in s;
true
</pre>
<p>
<p>
<h2><a name="SECT004">51.4 Finitely presented monoids</a></h2>
<p><p>
<a name = "SSEC004.1"></a>
<li><code></code><var>F</var><code>/</code><var>rels</var><code></code>
<p>
creates a finitely presented monoid given by the monoid presentation 
&#9001;<i>gens</i>  | <i>rels</i> &#9002; where <var>gens</var> are the generators of 
the free monoid <var>F</var>, and the relations <var>rel</var> are entered as pairs of 
words in both the identity and the generators of the free monoid.
<p>
<pre>
gap&gt; f := FreeMonoid( 3 );
&lt;free monoid on the generators [ m1, m2, m3 ]&gt;
gap&gt; x := GeneratorsOfMonoid( f );
[ m1, m2, m3 ]
gap&gt; e:= Identity ( f );
&lt;identity ...&gt;
gap&gt; m := f/[ [x[1]^3,e] , [x[1]*x[2],x[2] ]];
&lt;fp monoid on the generators [ m1, m2, m3 ]&gt;
</pre>
<p>
The functionality available for finitely presented monoids is essentially
the same as that available for finitely presented semigroups,
and thus the previous sections apply (with the obvious changes)
to finitely presented monoids.
<p>
<p>
<h2><a name="SECT005">51.5 Rewriting Systems and the Knuth-Bendix Procedure</a></h2>
<p><p>
If a finitely presented semigroup has a confluent rewriting system then 
it has a solvable word problem, that is, there is an algorithm to decide 
when two words in the free underlying semigroup represent the same element 
of the finitely presented semigroup. 
Indeed, once we have a confluent rewriting system, it is possible to 
successfully test that two words represent the same element in the 
semigroup, by reducing both words using the rewriting system rules. 
This is, at the moment, the method that <font face="Gill Sans,Helvetica,Arial">GAP</font> uses to check equality
in finitely presented semigroups and monoids.
<p>
<a name = "SSEC005.1"></a>
<li><code>ReducedConfluentRewritingSystem( </code><var>S</var><code> ) A</code>
<li><code>ReducedConfluentRewritingSystem( </code><var>S</var><code> , </code><var>ordering</var><code> ) A</code>
<p>
in the first form returns a reduced confluent rewriting system 
of the finitely presented semigroup or monoid <var>S</var> with respect 
to the length plus lexicographic ordering on words (also
called the shortlex ordering; for the definition see for example
Sims <a href="biblio.htm#Sims94"><cite>Sims94</cite></a>).
<p>
In the second form it returns a reduced confluent rewriting system of
the finitely presented semigroup or monoid <var>S</var> with respect to the 
reduction ordering <var>ordering</var> (see <a href="CHAP029.htm">Orderings</a>). 
<p>
Notice that this might not terminate. In particular, if the semigroup or 
monoid <var>S</var> does not have a solvable word problem then it this will
certainly never end.
Also, in this case, the object returned is an immutable 
rewriting system, because once we have a confluent
rewriting system for a finitely presented semigroup or monoid we do 
not want to allow it to change (as it was most probably very time 
consuming to get it in the first place). Furthermore, this is also
an attribute storing object (see <a href="CHAP013.htm#SECT004">Representation</a>).
<p>
<pre>
gap&gt; f := FreeSemigroup( "a" , "b" );;
gap&gt; a := GeneratorsOfSemigroup( f )[ 1 ];;
gap&gt; b := GeneratorsOfSemigroup( f )[ 2 ];;
gap&gt; g := f /  [ [ a^2 , a*b ] , [ a^4 , b] ];;
gap&gt; rws := ReducedConfluentRewritingSystem(g);
Rewriting System for Semigroup( [ a, b ] ) with rules 
[ [ a*b, a^2 ], [ a^4, b ], [ b*a, a^2 ], [ b^2, a^2 ] ]
</pre>
<p>
The creation of a reduced confluent rewriting system for a semigroup
or for a monoid, in <font face="Gill Sans,Helvetica,Arial">GAP</font>, uses the Knuth-Bendix procedure for strings, 
which manipulates a rewriting system of the semigroup or monoid and attempts 
to make it confluent (See <a href="CHAP036.htm">Rewriting Systems</a>. See also Sims <a href="biblio.htm#Sims94"><cite>Sims94</cite></a>). 
(Since the word problem for semigroups/monoids is not solvable in general, 
Knuth-Bendix procedure cannot always terminate). 
<p>
In order to apply this procedure we will build a rewriting system
for the semigroup or monoid, which we will call a  <strong>Knuth-Bendix Rewriting 
System</strong> (we need to define this because we need the rewriting system
to store some information needed for the implementation of the
Knuth-Bendix procedure). 
<p>
Actually, Knuth-Bendix Rewriting Systems do not only serve this purpose.
Indeed these  are objects which are mutable and which can be manipulated 
(see <a href="CHAP036.htm">rewriting systems</a>).
<p>
Note that the implemented version of the Knuth-Bendix procedure, in <font face="Gill Sans,Helvetica,Arial">GAP</font>
returns, if it terminates, a confluent rewriting system which is reduced.
Also, a reduction ordering has to be specified when building a rewriting
system. If none is specified, the shortlex ordering is assumed
(note that the procedure may terminate with a certain ordering and
not with another one).
<p>
On Unix systems it is possible to replace the built-in Knuth-Bendix by other
routines, for example the package <code>kbmag</code> offers such a possibility.
<p>
<a name = "SSEC005.2"></a>
<li><code>KB_REW V</code>
<a name = "SSEC005.2"></a>
<li><code>GAPKB_REW V</code>
<p>
KB_REW is a global record variable whose components contain functions
used for Knuth-Bendix. By default <code>KB_REW</code> is assigned to
<code>GAPKB_REW</code>, which contains the KB functions provided by
the GAP library.
<p>
<a name = "SSEC005.3"></a>
<li><code>KnuthBendixRewritingSystem(</code><var>s</var><code>,</code><var>wordord</var><code>)</code>
<li><code>KnuthBendixRewritingSystem(</code><var>m</var><code>,</code><var>wordord</var><code>)</code>
<p>
in the first form, for a semigroup <i>s</i> and a reduction ordering
for the underlying free semigroup, it returns the Knuth-Bendix 
rewriting system of the finitely presented semigroup <var>s</var> using the 
reduction ordering <var>wordord</var>.
In the second form, for a monoid <i>m</i> and a reduction ordering
for the underlying free semigroup, it returns the Knuth-Bendix 
rewriting system of the finitely presented semigroup <var>s</var> using the 
reduction ordering <var>wordord</var>.
<p>
<a name = "SSEC005.4"></a>
<li><code>SemigroupOfRewritingSystem( </code><var>rws</var><code> ) A</code>
<p>
returns the semigroup over which <var>rws</var> is
a rewriting system
<p>
<a name = "SSEC005.5"></a>
<li><code>MonoidOfRewritingSystem( </code><var>rws</var><code> ) A</code>
<p>
returns the monoid over which <var>rws</var> is a rewriting system
<p>
<a name = "SSEC005.6"></a>
<li><code>FreeSemigroupOfRewritingSystem( </code><var>rws</var><code> ) A</code>
<p>
returns the free semigroup over which <var>rws</var> is
a rewriting system
<p>
<a name = "SSEC005.7"></a>
<li><code>FreeMonoidOfRewritingSystem( </code><var>rws</var><code> ) A</code>
<p>
returns the free monoid over which <var>rws</var> is
a rewriting system
<p>
<pre>
gap&gt; f1 := FreeSemigroupOfRewritingSystem(rws);
&lt;free semigroup on the generators [ a, b ]&gt;
gap&gt; f1=f;
true
gap&gt; g1 := SemigroupOfRewritingSystem(rws);
&lt;fp semigroup on the generators [ a, b ]&gt;
gap&gt; g1=g;
true
</pre>
<p>
As mentioned before, having a confluent rewriting system, one can decide
whether two words represent the same element of a finitely 
presented semigroup (or finitely presented monoid). 
<p>
<pre>
gap&gt; a := GeneratorsOfSemigroup( g )[ 1 ];
a
gap&gt; b := GeneratorsOfSemigroup( g )[ 2 ];
b
gap&gt; a*b*a=a^3;
true
gap&gt; ReducedForm(rws,UnderlyingElement(a*b*a));
a^3
gap&gt; ReducedForm(rws,UnderlyingElement(a^3));
a^3
</pre>
<p>
<p>
<h2><a name="SECT006">51.6 Todd-Coxeter Procedure</a></h2>
<p><p>
This procedure gives a standard way of finding a transformation
representation of a finitely presented semigroup. Usually
one does not explicitly call this procedure but uses
IsomorphismTransformationSemigroup 
or HomomorphismTransformationSemigroup 
(see <a href="CHAP049.htm#SSEC001.3">IsomorphismTransformationSemigroup</a>).
<p>
<a name = "SSEC006.1"></a>
<li><code>CosetTableOfFpSemigroup( </code><var>r</var><code> ) A</code>
<p>
<var>r</var> is a right congruence of an fp-semigroup <var>S</var>.
This attribute is the coset table of FP semigroup 
<var>S</var> on a right congruence <var>r</var>.
Given a right congruence <var>r</var> we represent <var>S</var> as a set of 
transformations of the congruence classes of <var>r</var>.
<p>
The images   of the cosets under the   generators are compiled in  a list
<var>table</var> such that  <var>table[i][s]</var> contains  the image  of  coset <var>s</var> under
generator <var>i</var>.   
<p>
<p>
[<a href="../index.htm">Top</a>] [<a href = "chapters.htm">Up</a>] [<a href ="CHAP050.htm">Previous</a>] [<a href ="CHAP052.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<P>
<font face="Gill Sans,Helvetica,Arial">GAP 4 manual<br>August 2005
</font></body></html>