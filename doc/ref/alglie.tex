% This file was created automatically from alglie.msk.
% DO NOT EDIT!
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%A  alglie.msk                  GAP documentation             Willem de Graaf
%%
%A  @(#)$Id: alglie.msk,v 1.41 2003/10/28 04:55:03 gap Exp $
%%
%Y  (C) 1998 School Math and Comp. Sci., University of St.  Andrews, Scotland
%Y  Copyright (C) 2002 The GAP Group
%%
\Chapter{Lie Algebras}

A Lie algebra $L$ is an algebra such that 
$xx=0$ and $x(yz)+y(zx)+z(xy)=0$ for all $x,y,z\in L$. A common way of
creating a Lie algebra is by taking an associative
algebra together with the commutator as product. Therefore
the product of two elements $x,y$ of a Lie algebra is usually denoted by 
$[x,y]$, but in {\GAP} this denotes the list of the elements $x$ and $y$;
hence the product of elements is made by the usual `*'.
This gives no problems when dealing with Lie algebras given by a 
table of structure constants. However, for matrix Lie algebras 
the situation is not so easy as `*' denotes the ordinary (associative)
matrix multiplication. In \GAP this problem is solved by wrapping 
elements of a matrix Lie algebra up as LieObjects, and then define 
the `*' for LieObjects to be the commutator (see "ref:lie objects");


%%  The algorithms for Lie algebras are due to Willem de Graaf.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Lie objects}

Let $x$ be a ring element, then `LieObject(x)' wraps $x$ up into an
object that contains the same data (namely $x$). The multiplication
`*' for Lie objects is formed by taking the commutator. More exactly,
if $l_1$ and $l_2$ are the Lie objects corresponding to
the ring elements $r_1$ and $r_2$, then $l_1 * l_2$ is equal to the
Lie object corresponding to $r_1 * r_2 - r_2 * r_2$. Two rules
for Lie objects are worth noting:
\beginlist%unordered
\item{--}
  An element is *not* equal to its Lie element.

\item{--}
  If we take the Lie object of an ordinary (associative) matrix
  then this is again a matrix;
  it is therefore a collection (of its rows) and a list.
  But it is *not* a collection of collections of its entries,
  and its family is *not* a collections family.
\endlist


\>LieObject( <obj> ) A

Let <obj> be a ring element. Then `LieObject( <obj> )' is the
corresponding Lie object. If <obj> lies in the family <F>,
then `LieObject( <obj> )' lies in the family LieFamily( <F> )
(see~"LieFamily").



\beginexample
gap> m:= [ [ 1, 0 ], [ 0, 1 ] ];;
gap> lo:= LieObject( m );
LieObject( [ [ 1, 0 ], [ 0, 1 ] ] )
gap> m*m;
[ [ 1, 0 ], [ 0, 1 ] ]
gap> lo*lo;
LieObject( [ [ 0, 0 ], [ 0, 0 ] ] )
\endexample

\>IsLieObject( <obj> ) C
\>IsLieObjectCollection( <obj> ) C

An object lies in `IsLieObject' if and only if it lies in a family
constructed by `LieFamily'.



\beginexample
gap> m:= [ [ 1, 0 ], [ 0, 1 ] ];;
gap> lo:= LieObject( m );
LieObject( [ [ 1, 0 ], [ 0, 1 ] ] )
gap> IsLieObject( m );
false
gap> IsLieObject( lo );
true
\endexample

\>LieFamily( <Fam> ) A

is a family $F$ in bijection with the family <Fam>,
but with the Lie bracket as infix multiplication.
That is, for $x$, $y$ in <Fam>, the product of the images in $F$ will be
the image of $x \* y - y \* x$.

The standard type of objects in a Lie family <F> is `<F>!.packedType'.

\indextt{Embedding!for Lie algebras}
The bijection from <Fam> to $F$ is given by `Embedding( <Fam>, $F$ )';
this bijection respects addition and additive inverses.



\>UnderlyingFamily( <Fam> ) A

If <Fam> is a Lie family then `UnderlyingFamily( <Fam> )'
is a family $F$ such that `<Fam> = LieFamily( $F$ )'.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Constructing Lie algebras}

In this section we describe functions that create Lie algebras. Creating
and working with subalgebras goes exactly in the same way as for general
algebras; so for that we refer to Chapter "ref:algebras".

\>LieAlgebraByStructureConstants( <R>, <sctable> ) F
\>LieAlgebraByStructureConstants( <R>, <sctable>, <name> ) F
\>LieAlgebraByStructureConstants( <R>, <sctable>, <name1>, <name2>, ... ) F

`LieAlgebraByStructureConstants' does the same as
`AlgebraByStructureConstants', except that the result is assumed to be
a Lie algebra. Note that the function does not check whether
<sctable> satisfies the Jacobi identity. (So if one creates a Lie
algebra this way with a table that does not satisfy the Jacobi identity,
errors may occur later on.)



\beginexample
gap> T:= EmptySCTable( 2, 0, "antisymmetric" );;
gap> SetEntrySCTable( T, 1, 2, [ 1/2, 1 ] );
gap> L:= LieAlgebraByStructureConstants( Rationals, T );
<Lie algebra of dimension 2 over Rationals>
\endexample

\>LieAlgebra( <L> ) F
\>LieAlgebra( <F>, <gens> ) F
\>LieAlgebra( <F>, <gens>, <zero> ) F
\>LieAlgebra( <F>, <gens>, "basis" ) F
\>LieAlgebra( <F>, <gens>, <zero>, "basis" ) F

For an associative algebra <L>, `LieAlgebra( <L> )' is the Lie algebra
isomorphic to <L> as a vector space but with the Lie bracket as product.

`LieAlgebra( <F>, <gens> )' is the Lie algebra over the division ring
<F>, generated *as Lie algebra* by the Lie objects corresponding to the
vectors in the list <gens>.

*Note* that the algebra returned by `LieAlgebra' does not contain the
vectors in <gens>. The elements in <gens> are wrapped up as Lie objects
(see "ref:lie objects").
This allows one to create Lie algebras from ring elements with respect to
the Lie bracket as product.  But of course the product in the Lie
algebra is the usual `\*'.

If there are three arguments, a division ring <F> and a list <gens>
and an element <zero>,
then `LieAlgebra( <F>, <gens>, <zero> )' is the corresponding <F>-Lie
algebra with zero element the Lie object corresponding to <zero>.

If the last argument is the string `\"basis\"' then the vectors in
<gens> are known to form a basis of the algebra (as an <F>-vector space).

*Note* that even if each element in <gens> is already a Lie element,
i.e., is of the form `LieElement( <elm> )' for an object <elm>,
the elements of the result lie in the Lie family of the family that
contains <gens> as a subset.



\beginexample
gap> A:= FullMatrixAlgebra( GF( 7 ), 4 );;
gap> L:= LieAlgebra( A );
<Lie algebra of dimension 16 over GF(7)>
gap> mats:= [ [[ 1, 0 ], [ 0, -1 ]], [[ 0, 1 ], [ 0, 0 ]], [[ 0, 0 ], [ 1, 0]] ];;
gap> L:= LieAlgebra( Rationals, mats );
<Lie algebra over Rationals, with 3 generators>
\endexample

\>FreeLieAlgebra( <R>, <rank> ) F
\>FreeLieAlgebra( <R>, <rank>, <name> ) F
\>FreeLieAlgebra( <R>, <name1>, <name2>, ... ) F

Returns a free Lie algebra of rank <rank> over the ring <R>. 
`FreeLieAlgebra( <R>, <name1>, <name2>,...)' returns a free Lie algebra
over <R> with generators named <name1>, <name2>, and so on.
The elements of a free Lie algebra are written on the Hall-Lyndon
basis.



\beginexample
gap> L:= FreeLieAlgebra( Rationals, "x", "y", "z" );
<Lie algebra over Rationals, with 3 generators>
gap> g:= GeneratorsOfAlgebra( L );; x:= g[1];; y:=g[2];; z:= g[3];;
gap> z*(y*(x*(z*y)));
(-1)*((x*(y*z))*(y*z))+(-1)*((x*((y*z)*z))*y)+(-1)*(((x*z)*(y*z))*y)
\endexample

\>FullMatrixLieAlgebra( <R>, <n> ) F
\>MatrixLieAlgebra( <R>, <n> ) F
\>MatLieAlgebra( <R>, <n> ) F

is the full matrix Lie algebra $<R>^{<n> \times <n>}$, for a ring <R> and a 
nonnegative integer <n>.



\beginexample
gap> FullMatrixLieAlgebra( GF(9), 10 );
<Lie algebra over GF(3^2), with 19 generators>
\endexample

\>RightDerivations( <B> ) A
\>LeftDerivations( <B> ) A
\>Derivations( <B> ) A

These functions all return
the matrix Lie algebra of derivations of the algebra $A$ with basis
<B>.

`RightDerivations( <B> )' returns the algebra of derivations represented
by their right action on the algebra $A$. This means that
with respect to the basis $B$ of $A$, the derivation $D$ is described
by the matrix $[ d_{i,j} ]$
which means that $D$ maps the $i$-th basis element $b_i$ to 
$\sum_{j=1}^n d_{ij} b_j$.

`LeftDerivations( <B> )' returns the Lie algebra of derivations represented
by theor left action on the algebra $A$. So the matrices contained in the
algebra output by `LeftDerivations( <B> )' are the transposes of the 
matrices contained in the output of `RightDerivations( <B> )'.

`Derivations' is just a synonym for `RightDerivations'.



\beginexample
gap> A:= OctaveAlgebra( Rationals );
<algebra of dimension 8 over Rationals>
gap> L:= Derivations( Basis( A ) );
<Lie algebra of dimension 14 over Rationals>
\endexample

\>SimpleLieAlgebra( <type>, <n>, <F> ) F


This function constructs the simple Lie algebra of type <type> and
of rank <n> over the field <F>.

<type> must be one of A, B, C, D, E, F, G,
H, K, S, W. For the types A to G, <n> must be a positive integer.
The last four types only exist over fields of characteristic $p>0$.
If the type is H, then <n> must be a list of positive integers of 
even length.
If the type is K, then <n> must be a list of positive integers of odd 
length.
For the other types, S and W, <n> must be a list of positive integers
of any length. In some cases the Lie algebra returned by this function
is not simple. Examples are the Lie algebras of type $A_n$ over a field
of characteristic $p>0$ where $p$ divides $n+1$, and the Lie algebras
of type $K_n$ where $n$ is a list of length 1.

If <type> is one of A, B, C, D, E, F, G, and <F> is a field of characteristic
zero, then the basis of the returned Lie algebra is a Chevalley basis. 



\beginexample
gap> SimpleLieAlgebra( "E", 6, Rationals );
<Lie algebra of dimension 78 over Rationals>
gap> SimpleLieAlgebra( "A", 6, GF(5) );
<Lie algebra of dimension 48 over GF(5)>
gap> SimpleLieAlgebra( "W", [1,2], GF(5) );
<Lie algebra of dimension 250 over GF(5)>
gap> SimpleLieAlgebra( "H", [1,2], GF(5) );
<Lie algebra of dimension 123 over GF(5)>
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Distinguished Subalgebras}

Here we describe functions that calculate well-known subalgebras
and ideals of a Lie algebra (such as the centre, the centralizer of a
subalgebra, etc.).

\>LieCentre( <L> ) A
\>LieCenter( <L> ) A

The *Lie* centre of the Lie algebra <L> is the kernel of the adjoint
mapping, that is, the set $\{ a \in L; \forall x\in L:a x = 0 \}$.

In characteristic 2 this may differ from the usual centre (that is
the set of all $a\in L$ such that $ax=xa$ for all $x\in L$). 
Therefore, this operation is named `LieCentre' and not `Centre'. 




\beginexample
gap> L:= FullMatrixLieAlgebra( GF(3), 3 );
<Lie algebra over GF(3), with 5 generators>
gap> LieCentre( L );
<two-sided ideal in <Lie algebra of dimension 9 over GF(3)>, (dimension 1)>
\endexample


\>LieCentralizer( <L>, <S> ) O

is the annihilator of <S> in the Lie algebra <L>, that is, the set
$\{ a \in L; \forall s\in S:a\*s = 0\}$.
Here <S> may be a subspace or a subalgebra of <L>.



\beginexample
gap> L:= SimpleLieAlgebra( "G", 2, Rationals );
<Lie algebra of dimension 14 over Rationals>
gap> b:= BasisVectors( Basis( L ) );;
gap> LieCentralizer( L, Subalgebra( L, [ b[1], b[2] ] ) );
<Lie algebra of dimension 1 over Rationals>
\endexample



\>LieNormalizer( <L>, <U> ) O

is the normalizer of the subspace <U> in the Lie algebra <L>,
that is, the set $N_L(U) = \{ x \in L; [x,U] \subset U \}$.



\beginexample
gap> L:= SimpleLieAlgebra( "G", 2, Rationals );
<Lie algebra of dimension 14 over Rationals>
gap> b:= BasisVectors( Basis( L ) );;
gap> LieNormalizer( L, Subalgebra( L, [ b[1], b[2] ] ) );
<Lie algebra of dimension 8 over Rationals>
\endexample

\>LieDerivedSubalgebra( <L> ) A

is the (Lie) derived subalgebra of the Lie algebra <L>.  



\beginexample
gap>  L:= FullMatrixLieAlgebra( GF( 3 ), 3 );
<Lie algebra over GF(3), with 5 generators>
gap> LieDerivedSubalgebra( L );
<Lie algebra of dimension 8 over GF(3)>
\endexample


\>LieNilRadical( <L> ) A

This function calculates the (Lie) nil radical of the Lie algebra
<L>.



In the following two examples we temporarily increase the line length limit
from its default value 80 to 81 in order to make the long output expressions
fit each into one line.

\beginexample
gap> mats:= [ [[1,0],[0,0]], [[0,1],[0,0]], [[0,0],[0,1]] ];;
gap> L:= LieAlgebra( Rationals, mats );;
gap> SizeScreen([ 81, ]);;
gap> LieNilRadical( L );
<two-sided ideal in <Lie algebra of dimension 3 over Rationals>, (dimension 2)>
gap> SizeScreen([ 80, ]);;
\endexample



\>LieSolvableRadical( <L> ) A

Returns the (Lie) solvable radical of the Lie algebra <L>.



\beginexample
gap> L:= FullMatrixLieAlgebra( Rationals, 3 );;
gap> SizeScreen([ 81, ]);;
gap> LieSolvableRadical( L );
<two-sided ideal in <Lie algebra of dimension 9 over Rationals>, (dimension 1)>
gap> SizeScreen([ 80, ]);;
\endexample


\>CartanSubalgebra( <L> ) A

A Cartan subalgebra of a Lie algebra <L> is defined as a nilpotent
subalgebra of <L> equal to its own Lie normalizer in <L>.



\beginexample
gap> L:= SimpleLieAlgebra( "G", 2, Rationals );;
gap> CartanSubalgebra( L );
<Lie algebra of dimension 2 over Rationals>
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Series of Ideals}


\>LieDerivedSeries( <L> ) A

is the (Lie) derived series of the Lie algebra <L>.  



\beginexample
gap> mats:= [ [[1,0],[0,0]], [[0,1],[0,0]], [[0,0],[0,1]] ];;
gap> L:= LieAlgebra( Rationals, mats );;
gap> LieDerivedSeries( L );
[ <Lie algebra of dimension 3 over Rationals>, 
  <Lie algebra of dimension 1 over Rationals>, 
  <Lie algebra of dimension 0 over Rationals> ]
\endexample

\>LieLowerCentralSeries( <L> ) A

is the (Lie) lower central series of the Lie algebra <L>.  



\beginexample
gap> mats:= [ [[ 1, 0 ], [ 0, 0 ]], [[0,1],[0,0]], [[0,0],[0,1]] ];;
gap> L:=LieAlgebra( Rationals, mats );;
gap> LieLowerCentralSeries( L );
[ <Lie algebra of dimension 3 over Rationals>, 
  <Lie algebra of dimension 1 over Rationals> ]
\endexample


\>LieUpperCentralSeries( <L> ) A

is the (Lie) upper central series of the Lie algebra <L>.



\beginexample
gap> mats:= [ [[ 1, 0 ], [ 0, 0 ]], [[0,1],[0,0]], [[0,0],[0,1]] ];;
gap> L:=LieAlgebra( Rationals, mats );;
gap> LieUpperCentralSeries( L );
[ <two-sided ideal in <Lie algebra of dimension 3 over Rationals>, 
      (dimension 1)>, <Lie algebra over Rationals, with 0 generators> ]
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Properties of a Lie Algebra}


\>IsLieAbelian( <L> ) P

is `true' if <L> is a Lie algebra such that each product of elements in
<L> is zero, and `false' otherwise.



\beginexample
gap>  T:= EmptySCTable( 5, 0, "antisymmetric" );;
gap>  L:= LieAlgebraByStructureConstants( Rationals, T );
<Lie algebra of dimension 5 over Rationals>
gap> IsLieAbelian( L );
true
\endexample



\>IsLieNilpotent( <L> ) P

A Lie algebra <L> is defined to be (Lie) {\it nilpotent} when its
(Lie) lower central
series reaches the trivial subalgebra.



\beginexample
gap> T:= EmptySCTable( 5, 0, "antisymmetric" );;
gap> L:= LieAlgebraByStructureConstants( Rationals, T );
<Lie algebra of dimension 5 over Rationals>
gap> IsLieNilpotent( L );
true
\endexample



\>IsLieSolvable( <L> ) P

A Lie algebra <L> is defined to be (Lie) {\it solvable} when its
(Lie) derived series reaches the trivial subalgebra.



\beginexample
gap> T:= EmptySCTable( 5, 0, "antisymmetric" );;
gap> L:= LieAlgebraByStructureConstants( Rationals, T );
<Lie algebra of dimension 5 over Rationals>
gap> IsLieSolvable( L );
true
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Direct Sum Decompositions}

In this section we describe two functions that calculate a direct sum
decomposition of a Lie algebra; the so-called Levi decomposition
and the decomposition into a direct sum of ideals. 

\>LeviMalcevDecomposition( <L> )!{for Lie algebras} A

A Levi-Malcev subalgebra of the algebra <L> is a semisimple subalgebra
complementary to the radical of <L>. This function returns
a list with two components. The first component is a Levi-Malcev 
subalgebra, the second the radical. This function is implemented for 
associative and Lie algebras. 



\beginexample
gap> L:= FullMatrixLieAlgebra( Rationals, 5 );;
gap> LeviMalcevDecomposition( L );
[ <Lie algebra of dimension 24 over Rationals>, 
  <two-sided ideal in <Lie algebra of dimension 25 over Rationals>, 
      (dimension 1)> ]
\endexample


\>DirectSumDecomposition( <L> )!{for Lie algebras} A

This function calculates a list of ideals of the algebra <L> such
that <L> is equal to their direct sum. Currently this is only implemented
for semisimple associative algebras, and Lie algebras (semisimple or not).



\beginexample
gap> L:= FullMatrixLieAlgebra( Rationals, 5 );;
gap> DirectSumDecomposition( L );
[ <two-sided ideal in 
      <two-sided ideal in <Lie algebra of dimension 25 over Rationals>, 
          (dimension 1)>, (dimension 1)>, 
  <two-sided ideal in <two-sided ideal in 
          <Lie algebra of dimension 25 over Rationals>, (dimension 24)>, 
      (dimension 24)> ]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\Section{Semisimple Lie Algebras and Root Systems}

This section contains some functions for dealing with
semisimple Lie algebras and their root systems.

\>SemiSimpleType( <L> ) A

Let <L> be a semisimple Lie algebra, i.e., a direct sum of simple
Lie algebras. Then `SemiSimpleType' returns the type of <L>, i.e.,
a string containing the types of the simple summands of <L>.




\beginexample
gap> L:= SimpleLieAlgebra( "E", 8, Rationals );;
gap> b:= BasisVectors( Basis( L ) );;
gap> K:= LieCentralizer( L, Subalgebra( L, [ b[61]+b[79]+b[101]+b[102] ] ) );
<Lie algebra of dimension 102 over Rationals>
gap> lev:= LeviMalcevDecomposition(K);;
gap> SemiSimpleType( lev[1] );
"B3 A1"
\endexample

\>ChevalleyBasis( <L> ) A

Here <L> must be a semisimple Lie algebra with a split Cartan subalgebra.
Then `ChevalleyBasis( <L> )' returns a list consisting of three sublists.
Together these sublists form a Chevalley basis of <L>. The first
list contains the positive root vectors, the second list contains the
negative root vectors, and the third list the Cartan elements of the
Chevalley basis.



\beginexample
gap> L:= SimpleLieAlgebra( "G", 2, Rationals );
<Lie algebra of dimension 14 over Rationals>
gap> ChevalleyBasis( L );
[ [ v.1, v.2, v.3, v.4, v.5, v.6 ], [ v.7, v.8, v.9, v.10, v.11, v.12 ], 
  [ v.13, v.14 ] ]
\endexample


\>IsRootSystem( <obj> ) C

Category of root systems.


\>IsRootSystemFromLieAlgebra( <obj> ) C

Category of root systems that come from (semisimple) Lie algebras.
They often have special attributes such as `UnderlyingLieAlgebra',
`PositiveRootVectors', `NegativeRootVectors', `CanonicalGenerators'.


\>RootSystem( <L> ) A

`RootSystem' calculates the root system of the semisimple Lie algebra
<L> with a split Cartan subalgebra.



\beginexample
gap> L:= SimpleLieAlgebra( "G", 2, Rationals );
<Lie algebra of dimension 14 over Rationals>
gap> R:= RootSystem( L );
<root system of rank 2>
gap> IsRootSystem( R );
true
gap> IsRootSystemFromLieAlgebra( R );
true
\endexample

\>UnderlyingLieAlgebra( <R> ) A

Here <R> is a root system coming from a semisimple Lie algebra <L>.
This function returns <L>.




\>PositiveRoots( <R> ) A

The list of positive roots of the root system <R>.


\>NegativeRoots( <R> ) A

The list of negative roots of the root system <R>.


\>PositiveRootVectors( <R> ) A

A list of positive root vectors of the root system <R> that comes
from a Lie algebra <L>. This is a list in bijection with the list
`PositiveRoots( <L> )'. The root vector is a non-zero element of the
root space (in <L>) of the corresponding root.


\>NegativeRootVectors( <R> ) A

A list of negative root vectors of the root system <R> that comes
from a Lie algebra <L>. This is a list in bijection with the list
`NegativeRoots( <L> )'. The root vector is a non-zero element of the
root space (in <L>) of the corresponding root.


\>SimpleSystem( <R> ) A

A list of simple roots of the root system <R>.


\>CartanMatrix( <R> ) A

The Cartan matrix of the root system <R>, relative to the simple 
roots in `SimpleSystem( <R> )'.


\>BilinearFormMat( <R> ) A

The matrix of the bilinear form of the root system <R>. If we denote this
matrix by $B$, then we have $B(i,j)= (\alpha_i,\alpha_j)$, where
the $\alpha_i$ are the simple roots of <R>.


\>CanonicalGenerators( <R> ) A

Here <R> must be a root system coming from a semisimple Lie algebra <L>.
This function returns $3l$ generators of <L>, $x_1, \ldots, x_l,y_1,
\ldots, y_l,h_1,\ldots, h_l$, where $x_i$ lies in the root space 
corresponding to the $i$-th simple root of the root system of <L>,
$y_i$ lies in the root space corresponding to $-$ the $i$-th simple root,
and the $h_i$ are elements of the Cartan subalgebra. These elements
satisfy the relations $h_i*h_j=0$, $x_i*y_j=\delta_{ij}h_i$,
$h_j*x_i = c_{ij} x_i$,  $h_j*y_i= -c_{ij} y_i$, where $c_{ij}$
is the entry of the Cartan matrix on position $ij$.

Also if $a$ is a root of the root system <R> (so $a$ is a list of 
numbers), then we have the relation $h_i*x = a[i] x$, where $x$ is
a root vector corresponding to $a$.



\beginexample
gap> L:= SimpleLieAlgebra( "G", 2, Rationals );;
gap> R:= RootSystem( L );;
gap> UnderlyingLieAlgebra( R );
<Lie algebra of dimension 14 over Rationals>
gap> PositiveRoots( R );
[ [ 2, -1 ], [ -3, 2 ], [ -1, 1 ], [ 1, 0 ], [ 3, -1 ], [ 0, 1 ] ]
gap> x:= PositiveRootVectors( R );
[ v.1, v.2, v.3, v.4, v.5, v.6 ]
gap> g:=CanonicalGenerators( R );
[ [ v.1, v.2 ], [ v.7, v.8 ], [ v.13, v.14 ] ]
gap> g[3][1]*x[1];
(2)*v.1
gap> g[3][2]*x[1];
(-1)*v.1
gap> # i.e., x[1] is the root vector belonging to the root [ 2, -1 ]
gap> BilinearFormMat( R );
[ [ 1/12, -1/8 ], [ -1/8, 1/4 ] ]
\endexample

The next few sections deal with the Weyl group of a root system. 
A Weyl group is represented by its action on the weight lattice. 
A *weight* is by definition a linear function $\lambda : H\to F$
(where $F$ is the ground field), such that the values $\lambda(h_i)$ are
all integers (where the $h_i$ are the Cartan elements of the 
`CanonicalGenerators'). On the other hand each weight is determined by
these values. Therefore we represent a weight by a vector of integers;
the $i$-th entry of this vector is the value $\lambda(h_i)$.
Now the elements of the Weyl group are represented by matrices, and
if `g' is an element of a Weyl group and `w' a weight, then `w*g'
gives the result of applying `g' to `w'.  Another way of applying the
$i$-th simple reflection to a weight is by using the function
`ApplySimpleReflection' (see below).

A Weyl group is generated by the simple reflections. So 
`GeneratorsOfGroup( W )' for a Weyl group `W' gives a list of matrices
and the $i$-th entry of this list is the simple reflection corresponding
to the $i$-th simple root of the corresponding root system.


\>IsWeylGroup( <G> ) P

A Weyl group is a group generated by reflections, with the attribute
`SparseCartanMatrix' set.


\>SparseCartanMatrix( <W> ) A

This is a sparse form of the Cartan matrix of the
corresponding root system. If we denote the Cartan matrix by `C',
then the sparse Cartan matrix of <W> is a list (of length equal to the
length of the Cartan matrix), where the `i'-th entry is a list
consisting of elements `[ j, C[i][j] ]', where `j' is such that
`C[i][j]' is non-zero.



\>WeylGroup( <R> ) A

The Weyl group of the root system <R>. It is generated by the simple
reflections. A simple reflection is represented by a matrix, and the
result of letting a simple reflection `m' act on a weight `w' is obtained
by `w*m'.




\beginexample
gap> L:= SimpleLieAlgebra( "F", 4, Rationals );;
gap> R:= RootSystem( L );;
gap> W:= WeylGroup( R );
<matrix group with 4 generators>
gap> IsWeylGroup( W );
true
gap> SparseCartanMatrix( W );
[ [ [ 1, 2 ], [ 3, -1 ] ], [ [ 2, 2 ], [ 4, -1 ] ], 
  [ [ 1, -1 ], [ 3, 2 ], [ 4, -1 ] ], [ [ 2, -1 ], [ 3, -2 ], [ 4, 2 ] ] ]
gap> g:= GeneratorsOfGroup( W );;
gap> [ 1, 1, 1, 1 ]*g[2];
[ 1, -1, 1, 2 ]
\endexample

\>ApplySimpleReflection( <SC>, <i>, <wt> ) O

Here <SC> is the sparse Cartan matrix of a Weyl group. This
function applies the <i>-th simple reflection to the weight
<wt>, thus changing <wt>.



\beginexample
gap> L:= SimpleLieAlgebra( "F", 4, Rationals );;
gap> W:= WeylGroup( RootSystem( L ) );;
gap> C:= SparseCartanMatrix( W );;
gap> w:= [ 1, 1, 1, 1 ];;
gap> ApplySimpleReflection( C, 2, w );
gap> w;
[ 1, -1, 1, 2 ]
\endexample

\>LongestWeylWordPerm( <W> ) A

Let $g_0$ be the longest element in the Weyl group <W>, and let
$\{\alpha_1,\ldots, \alpha_l\}$ be a simple system of the corresponding
root system. Then $g_0$ maps $\alpha_i$ to $-\alpha_{\sigma(i)}$, where
$\sigma$ is a permutation of $(1,\ldots ,l)$. This function returns
that permutation.



\beginexample
gap> L:= SimpleLieAlgebra( "E", 6, Rationals );;
gap> W:= WeylGroup( RootSystem( L ) );;
gap> LongestWeylWordPerm( W );
(1,6)(3,5)
\endexample

\>ConjugateDominantWeight( <W>, <wt> ) O
\>ConjugateDominantWeightWithWord( <W>, <wt> ) O

Here <W> is a Weyl group and <wt> a weight (i.e., a list of integers).
This function returns the unique dominant weight conjugate to <wt>
under <W>.

`ConjugateDominantWegihtWithWord( <W>, <wt> )' returns a list of two
elements. The first of these is the dominant weight conjugate do <wt>.
The second element is a list of indices of simple reflections that
have to be applied to <wt> in order to get the dominant weight conjugate
to it.



\beginexample
gap> L:= SimpleLieAlgebra( "E", 6, Rationals );;
gap> W:= WeylGroup( RootSystem( L ) );;
gap> C:= SparseCartanMatrix( W );;
gap> w:= [ 1, -1, 2, -2, 3, -3 ];;
gap> ConjugateDominantWeight( W, w );
[ 2, 1, 0, 0, 0, 0 ]
gap> c:= ConjugateDominantWeightWithWord( W, w );
[ [ 2, 1, 0, 0, 0, 0 ], [ 2, 4, 2, 3, 6, 5, 4, 2, 3, 1 ] ]
gap> for i in [1..Length(c[2])] do
> ApplySimpleReflection( C, c[2][i], w );
> od;
gap> w;
[ 2, 1, 0, 0, 0, 0 ]
\endexample


\>WeylOrbitIterator( <W>, <wt> ) O

Returns an iterator for the orbit of the weight <wt> under the
action of the Weyl group <W>.



\beginexample
gap> L:= SimpleLieAlgebra( "E", 6, Rationals );;
gap> W:= WeylGroup( RootSystem( L ) );;
gap> orb:= WeylOrbitIterator( W, [ 1, 1, 1, 1, 1, 1 ] );
<iterator>
gap> NextIterator( orb );
[ 1, 1, 1, 1, 1, 1 ]
gap> NextIterator( orb );
[ -1, -1, -1, -1, -1, -1 ]
gap> orb:= WeylOrbitIterator( W, [ 1, 1, 1, 1, 1, 1 ] );
<iterator>
gap> k:= 0;
0
gap> while not IsDoneIterator( orb ) do
> w:= NextIterator( orb ); k:= k+1;
> od;
gap> k;  # this is the size of the Weyl group of E6
51840
\endexample



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Restricted Lie algebras}

A Lie algebra $L$ over a field of characteristic $p>0$ is called
restricted if there is a map $x\mapsto x^p$ from $L$ into $L$ 
(called a $p$-map) such that
${\rm ad} x^p=({\rm ad} x)^p$, $(\alpha x)^p=\alpha^p x^p$ and
$(x+y)^p=x^p+y^p+\sum_{i=1}^{p-1} s_i(x,y)$, where $s_i: L\times L\to L$
are certain Lie polynomials in two variables. Using these relations
we can calculate $y^p$ for all $y\in L$, once we know $x^p$ for $x$ in a
basis of $L$. Therefore a $p$-map is represented in \GAP~ by a list 
containing the images of the basis vectors of a basis $B$ of $L$. For this
reason this list is an attribute of the basis $B$. 

\>IsRestrictedLieAlgebra( <L> ) P

Test whether <L> is restricted.



\beginexample
gap> L:= SimpleLieAlgebra( "W", [2], GF(5));
<Lie algebra of dimension 25 over GF(5)>
gap> IsRestrictedLieAlgebra( L );
false
gap> L:= SimpleLieAlgebra( "W", [1], GF(5));
<Lie algebra of dimension 5 over GF(5)>
gap> IsRestrictedLieAlgebra( L );
true
\endexample

\>PthPowerImages( <B> ) A

Here `B' is a basis of a restricted Lie algebra. This function returns
the list of the images of the basis vectors of `B' under the $p$-map.



\beginexample
gap> L:= SimpleLieAlgebra( "W", [1], GF(11) );
<Lie algebra of dimension 11 over GF(11)>
gap> B:= Basis( L );
CanonicalBasis( <Lie algebra of dimension 11 over GF(11)> )
gap> PthPowerImages( B );
[ 0*v.1, v.2, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1 ]
\endexample

\>PthPowerImage( <B>, <x> ) O

<B> is a basis of a restricted Lie algebra $L$.
This function calculates for an element <x> of $L$ the image of <x>
under the $p$-map.



\beginexample
gap> L:= SimpleLieAlgebra( "W", [1], GF(11) );;
gap> B:= Basis( L );;
gap> x:= B[1]+B[11];
v.1+v.11
gap> PthPowerImage( B, x );
v.1+v.11
\endexample

\>JenningsLieAlgebra( <G> ) A

Let <G> be a nontrivial $p$-group,
and let $<G> = G_1\supset G_2\supset \cdots \supset G_m=1$
be its Jennings series (see~"JenningsSeries").
Then the quotients $G_i/G_{i+1}$ are elementary abelian $p$-groups,
i.e., they can be viewed as vector spaces over $`GF'(p)$.
Now the Jennings-Lie algebra $L$ of <G> is the direct sum of those vector
spaces. The Lie bracket on $L$ is induced by the commutator in <G>. 
Furthermore, the map $g\mapsto g^p$ in <G> induces a $p$-map in $L$
making $L$ into a restricted Lie algebra. In the canonical basis of $L$
this $p$-map is added as an attribute. A Lie algebra created by
`JenningsLieAlgebra' is naturally graded. The attribute
`Grading' is set.


\>PCentralLieAlgebra( <G> ) A

Here <G> is a nontrivial $p$-group. `PCentralLieAlgebra( <G> )'
does the same as `JenningsLieAlgebra( <G> )' except that the
$p$-central series is used instead of the Jennings series
(see~"PCentralSeries"). This function also returns a graded
Lie algebra. However, it is not necessarily restricted.



\beginexample
gap> G:= SmallGroup( 3^6, 123 );
<pc group of size 729 with 6 generators>
gap> L:= JenningsLieAlgebra( G );
<Lie algebra of dimension 6 over GF(3)>
gap> HasPthPowerImages( Basis( L ) );
true
gap> PthPowerImages( Basis( L ) );
[ v.6, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1 ]
gap> g:= Grading( L );
rec( min_degree := 1, max_degree := 3, source := Integers, 
  hom_components := function( d ) ... end )
gap> List( [1,2,3], g.hom_components );
[ <vector space over GF(3), with 3 generators>, 
  <vector space over GF(3), with 2 generators>, 
  <vector space over GF(3), with 1 generators> ]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{The Adjoint Representation}

In this section we show functions for calculating with the adjoint
representation of a Lie algebra (and the corresponding trace form,
called the Killing form) (see also "ref:adjointbasis" and 
"ref:indicesofadjointbasis").

\>AdjointMatrix( <B>, <x> ) O

is the matrix of the adjoint representation of the element <x> w.r.t.
the basis <B>. The adjoint map is the left multiplication by <x>.
The $i$-th column of the resulting matrix represents the image of the
the $i$-th basis vector of <B> under left multiplication by <x>. 



\beginexample
gap> L:= SimpleLieAlgebra( "A", 1, Rationals );;
gap> AdjointMatrix( Basis( L ), Basis( L )[1] );
[ [ 0, 0, -2 ], [ 0, 0, 0 ], [ 0, 1, 0 ] ]
\endexample


\>AdjointAssociativeAlgebra( <L>, <K> ) A

is the associative matrix algebra (with 1) generated by the 
matrices of the adjoint representation of the subalgebra <K> on the Lie 
algebra <L>.



\beginexample
gap> L:= SimpleLieAlgebra( "A", 1, Rationals );;
gap> AdjointAssociativeAlgebra( L, L );
<algebra of dimension 9 over Rationals>
gap> AdjointAssociativeAlgebra( L, CartanSubalgebra( L ) );
<algebra of dimension 3 over Rationals>
\endexample


\>KillingMatrix( <B> ) A

is the matrix of the Killing form $\kappa$ with respect to the basis <B>,
i.e., the matrix $(\kappa(b_i,b_j))$ where $b_1,b_2\ldots $ are the
basis vectors of <B>.



\beginexample
gap> L:= SimpleLieAlgebra( "A", 1, Rationals );;
gap> KillingMatrix( Basis( L ) );
[ [ 0, 4, 0 ], [ 4, 0, 0 ], [ 0, 0, 8 ] ]
\endexample

\>KappaPerp( <L>, <U> ) O

is the orthogonal complement of the subspace <U> of the Lie algebra <L>
with respect to the Killing form $\kappa$, that is,
the set $U^{\perp} = \{ x \in L; \kappa (x,y)=0 \hbox{ for all } 
y\in L \}$.

$U^{\perp}$ is a subspace of <L>, and if <U> is an ideal of <L> then
$U^{\perp}$ is a subalgebra of <L>.



\beginexample
gap> L:= SimpleLieAlgebra( "A", 1, Rationals );;
gap> b:= BasisVectors( Basis( L ) );;
gap> V:= VectorSpace( Rationals, [b[1],b[2]] );;
gap> KappaPerp( L, V );
<vector space of dimension 1 over Rationals>
\endexample


\>IsNilpotentElement( <L>, <x> ) O

<x> is nilpotent in <L> if its adjoint matrix is a nilpotent matrix.




\beginexample
gap> L:= SimpleLieAlgebra( "A", 1, Rationals );;
gap> IsNilpotentElement( L, Basis( L )[1] );
true
\endexample

\>NonNilpotentElement( <L> ) A

A non-nilpotent element of a Lie algebra <L> is an element $x$ such that
$ad x$ is not nilpotent.
If <L> is not nilpotent, then by Engel's theorem non nilpotent elements
exist in <L>.
In this case this function returns a non nilpotent element of <L>,
otherwise (if <L> is nilpotent) `fail' is returned.



\beginexample
gap> L:= SimpleLieAlgebra( "G", 2, Rationals );;
gap> NonNilpotentElement( L );
v.13
gap> IsNilpotentElement( L, last );
false
\endexample


\>FindSl2( <L>, <x> ) O

This function tries to find a subalgebra $S$ of the Lie algebra <L> with
$S$ isomorphic to $sl_2$ and such that the nilpotent element <x> of <L>
is contained in $S$.
If such an algebra exists then it is returned,
otherwise `fail' is returned.



\beginexample
gap> L:= SimpleLieAlgebra( "G", 2, Rationals );;
gap> b:= BasisVectors( Basis( L ) );;
gap> IsNilpotentElement( L, b[1] );
true
gap> FindSl2( L, b[1] );
<Lie algebra of dimension 3 over Rationals>
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Universal Enveloping Algebras}

\>UniversalEnvelopingAlgebra( <L> ) A
\>UniversalEnvelopingAlgebra( <L>, <B> ) O

Returns the universal enveloping algebra of the Lie algebra <L>.
The elements of this algebra are written on a Poincare-Birkhoff-Witt
basis.

In the second form <B> must be a basis of <L>. If this second argument
is given, then an isomorphic copy of the universal enveloping algebra
is returned, generated by the images (in the universal enveloping
algebra) of the elements of <B>.



\beginexample
gap> L:= SimpleLieAlgebra( "A", 1, Rationals );;
gap> UL:= UniversalEnvelopingAlgebra( L );
<algebra-with-one of dimension infinity over Rationals>
gap> g:= GeneratorsOfAlgebraWithOne( UL );
[ [(1)*x.1], [(1)*x.2], [(1)*x.3] ]
gap> g[3]^2*g[2]^2*g[1]^2;
[(-4)*x.1*x.2*x.3^3+(1)*x.1^2*x.2^2*x.3^2+(2)*x.3^3+(2)*x.3^4]
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Finitely Presented Lie Algebras}

Finitely presented Lie algebras can be constructed from free Lie algebras
by using the `/' constructor, i.e., `FL/[r1...rk]' is the quotient of
the free Lie algebra `FL' by the ideal generated by the elements
`r1...rk' of `FL'. If the finitely presented Lie algebra `K' happens to be
finite dimensional then an isomorphic structure constants Lie algebra
can be constructed by `NiceAlgebraMonomorphism(K)', which returns a surjective
homomorphism. The structure constants Lie algebra can then be accessed by 
calling `Range' for this map. Also limited computations with elements of the 
finitely presented Lie algebra are possible.

\beginexample
gap> L:= FreeLieAlgebra( Rationals, "s", "t" );
<Lie algebra over Rationals, with 2 generators>
gap> gL:= GeneratorsOfAlgebra( L );; s:= gL[1];; t:= gL[2];;
gap> K:= L/[ s*(s*t), t*(t*(s*t)), s*(t*(s*t))-t*(s*t) ];
<Lie algebra over Rationals, with 2 generators>
gap> h:= NiceAlgebraMonomorphism( K );
[ [(1)*s], [(1)*t] ] -> [ v.1, v.2 ]
gap> U:= Range( h );
<Lie algebra of dimension 3 over Rationals>
gap> IsLieNilpotent( U );
true
gap> gK:= GeneratorsOfAlgebra( K );
[ [(1)*s], [(1)*t] ]
gap> gK[1]*(gK[2]*gK[1]) = Zero( K );
true
\endexample

\>FpLieAlgebraByCartanMatrix( C ) F


Here <C> must be a Cartan matrix. The function returns the 
finitely-presented Lie algebra over the field of rational numbers 
defined by this Cartan matrix. By Serre's theorem, this Lie algebra is a 
semisimple Lie algebra, and its root system has Cartan matrix <C>.




\beginexample
gap> C:= [ [ 2, -1 ], [ -3, 2 ] ];;
gap> K:= FpLieAlgebraByCartanMatrix( C );
<Lie algebra over Rationals, with 6 generators>
gap> h:= NiceAlgebraMonomorphism( K );
[ [(1)*x1], [(1)*x2], [(1)*x3], [(1)*x4], [(1)*x5], [(1)*x6] ] -> 
[ v.1, v.2, v.3, v.4, v.5, v.6 ]
gap> SemiSimpleType( Range( h ) );
"G2"
\endexample

\>NilpotentQuotientOfFpLieAlgebra( <FpL>, <max> ) F
\>NilpotentQuotientOfFpLieAlgebra( <FpL>, <max>, <weights> ) F


Here <FpL> is a finitely presented Lie algebra. Let $K$ be the
quotient of <FpL> by the <max>+1-th term of its lower central series.
This function calculates a surjective homomorphism of <FpL> onto $K$.
When called with the third argument <weights>, the $k$-th generator of
<FpL> gets assigned the $k$-th element of the list <weights>. In that
case a quotient is calculated of <FpL> by the ideal generated by all 
elements of weight <max>+1. If the list <weights> only consists of
$1$'s then the two calls are equivalent. The default value of 
<weights> is a list (of length equal to the number of generators of
<FpL>) consisting of $1$'s.

If the relators of <FpL> are homogeneous, then the resulting 
algebra is naturally graded. 



\beginexample
gap> L:= FreeLieAlgebra( Rationals, "x", "y" );;
gap> g:= GeneratorsOfAlgebra(L);; x:= g[1]; y:= g[2];
(1)*x
(1)*y
gap> rr:=[((y*x)*x)*x-6*(y*x)*y, 3*((((y*x)*x)*x)*x)*x-20*(((y*x)*x)*x)*y ];
[ (-1)*(x*(x*(x*y)))+(6)*((x*y)*y), 
  (-3)*(x*(x*(x*(x*(x*y)))))+(20)*(x*(x*((x*y)*y)))+(-20)*((x*(x*y))*(x*y)) ]
gap> K:= L/rr;
<Lie algebra over Rationals, with 2 generators>
gap> h:=NilpotentQuotientOfFpLieAlgebra(K, 50, [1,2] );
[ [(1)*x], [(1)*y] ] -> [ v.1, v.2 ]
gap> L:= Range( h );
<Lie algebra of dimension 50 over Rationals>
gap> Grading( L );
rec( min_degree := 1, max_degree := 50, source := Integers, 
  hom_components := function( d ) ... end )
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Modules over Lie Algebras and Their Cohomology}

Representations of Lie algebras are dealt with in the same way as 
representations of ordinary algebras (see "Representations of Algebras").
In this section we mainly deal with modules over general Lie algebras
and their cohomology. The next section is devoted to modules over
semisimple Lie algebras.

\>FaithfulModule( <A> )!{for Lie algebras} A

returns a faithful finite-dimensional left-module over the algebra <A>.
This is only implemented for associative algebras, and for Lie algebras
of characteristic $0$. (It may also work for certain Lie algebras
of characteristic $p>0$.)



\beginexample
gap> T:= EmptySCTable( 3, 0, "antisymmetric" );;
gap> SetEntrySCTable( T, 1, 2, [ 1, 3 ]);
gap> L:= LieAlgebraByStructureConstants( Rationals, T );
<Lie algebra of dimension 3 over Rationals>
gap> V:= FaithfulModule( L );
<left-module over <Lie algebra of dimension 3 over Rationals>>
gap> vv:= BasisVectors( Basis( V ) );
[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ]
gap> x:= Basis( L )[3];
v.3
gap> List( vv, v -> x^v );
[ [ 0, 0, 0 ], [ 1, 0, 0 ], [ 0, 0, 0 ] ]
\endexample


An $s$-cochain of a module $V$ over a Lie algebra $L$, is an $s$-linear
map
$$
c: L\times\cdots\times L \to V  \hbox{ ($s$ factors $L$)}
$$
that is skew-symmetric (meaning that if any of the arguments are
interchanged, $c$ changes to $-c$).

Let $\{x_1,\ldots,x_n\}$ be a basis of $L$. Then any $s$-cochain is 
determined by the values $c( x_{i_1},\ldots, x_{i_s} )$, where
$1\le i_1 \< i_2 \< \cdots \< i_s \le \dim L$.
Now this value again is a linear combination of basis elements of $V$:
$c( x_{i_1},\ldots, x_{i_s} ) = \sum \lambda^k_{i_1,\ldots, i_s} v_k$.
Denote the dimension of $V$ by $r$.
Then we represent an $s$-cocycle by a list of $r$ lists.
The $j$-th of those lists consists of entries of the form
$$
[ [i_1,i_2,\ldots,i_s], \lambda^j_{i_1,\ldots, i_s} ]
$$
where the coefficient on the second position is non-zero.
(We only store those entries for which this coefficient is non-zero.)
It follows that every $s$-tuple $(i_1,\ldots,i_s)$ gives rise to $r$ 
basis elements.

So the zero cochain is represented by a list of the form
$[ [ ], [ ], \ldots , [ ] ]$. Furthermore, if $V$ is, e.g., 
$4$-dimensional, then the $2$-cochain represented by

\begintt
[ [ [ [1,2], 2] ], [ ], [ [ [1,2], 1/2 ] ], [ ] ]
\endtt

maps the pair $(x_1,x_2)$ to $2v_1+1/2 v_3$ (where $v_1$ is the first
basis element of $V$, and $v_3$ the third), and all other pairs to zero.

By definition, $0$-cochains are constant maps $c( x ) = v_c\in V$ for all
$x \in L$. So $0$-cochains have a different representation: they are just
represented by the list $[ v_c ]$.

Cochains are constructed using the function `Cochain' (see~"Cochain"),
if <c> is a cochain, then its corresponding list is returned by
`ExtRepOfObj( <c> )'.



\>IsCochain( <obj> ) C
\>IsCochainCollection( <obj> ) C

Categories of cochains and of collections of cochains.



\>Cochain( <V>, <s>, <obj> ) O

Constructs a <s>-cochain given by the data in <obj>, with respect to
the Lie algebra module <V>. If <s> is non-zero, then <obj> must be
a list.



\beginexample
gap> L:= SimpleLieAlgebra( "A", 1, Rationals );;
gap> V:= AdjointModule( L );
<3-dimensional left-module over <Lie algebra of dimension 3 over Rationals>>
gap> c1:= Cochain( V, 2, [ [ [ [ 1, 3 ], -1 ] ], [ ], [ [ [ 2, 3 ], 1/2 ] ] ]);
<2-cochain>
gap> ExtRepOfObj( c1 );
[ [ [ [ 1, 3 ], -1 ] ], [  ], [ [ [ 2, 3 ], 1/2 ] ] ]
gap> c2:= Cochain( V, 0, Basis( V )[1] );
<0-cochain>
gap> ExtRepOfObj( c2 );
v.1
gap> IsCochain( c2 );
true
\endexample

\>CochainSpace( <V>, <s> ) O

Returns the space of all <s>-cochains with respect to <V>.



\beginexample
gap> L:= SimpleLieAlgebra( "A", 1, Rationals );;
gap> V:= AdjointModule( L );;
gap> C:=CochainSpace( V, 2 );
<vector space of dimension 9 over Rationals>
gap> BasisVectors( Basis( C ) );
[ <2-cochain>, <2-cochain>, <2-cochain>, <2-cochain>, <2-cochain>, 
  <2-cochain>, <2-cochain>, <2-cochain>, <2-cochain> ]
gap> ExtRepOfObj( last[1] );
[ [ [ [ 1, 2 ], 1 ] ], [  ], [  ] ]
\endexample

\>ValueCochain( <c>, <y1>, <y2>, ..., <ys> ) F

Here <c> is an <s>-cochain. This function returns the value of
<c> when applied to the <s> elements <y1> to <ys> (that lie in the
Lie algebra acting on the module corresponding to <c>). It is also
possible to call this function with two arguments: first <c> and then
the list containing `<y1>,...,<ys>'.



\beginexample
gap> L:= SimpleLieAlgebra( "A", 1, Rationals );;
gap> V:= AdjointModule( L );;
gap> C:= CochainSpace( V, 2 );;
gap> c:= Basis( C )[1];
<2-cochain>
gap>  ValueCochain( c, Basis(L)[2], Basis(L)[1] );
(-1)*v.1
\endexample

\>LieCoboundaryOperator( <c> ) V

This is a function that takes an <s>-cochain, and returns an <s+1>-cochain.
The coboundary operator is applied.



\beginexample
gap> L:= SimpleLieAlgebra( "A", 1, Rationals );;
gap> V:= AdjointModule( L );;
gap> C:= CochainSpace( V, 2 );;
gap> c:= Basis( C )[1];;
gap> c1:= LieCoboundaryOperator( c );
<3-cochain>
gap> c2:= LieCoboundaryOperator( c1 );
<4-cochain>
\endexample

\>Cocycles( <V>, <s> ) O

is the space of all <s>-cocycles with respect to the Lie algebra module
<V>. That is the kernel of the coboundary operator when  restricted to
the space of <s>-cochains.



\>Coboundaries( <V>, <s> ) O

is the space of all <s>-coboundaries with respect to the Lie algebra
module <V>. That is the image of the coboundary operator, when applied
to the space of <s-1>-cochains. By definition the space of all
0-coboundaries is zero.



\beginexample
gap> T:= EmptySCTable( 3, 0, "antisymmetric" );;
gap> SetEntrySCTable( T, 1, 2, [ 1, 3 ] );
gap> L:= LieAlgebraByStructureConstants( Rationals, T );;
gap> V:= FaithfulModule( L );
<left-module over <Lie algebra of dimension 3 over Rationals>>
gap> Cocycles( V, 2 );
<vector space of dimension 7 over Rationals>
gap> Coboundaries( V, 2 );
<vector space over Rationals, with 9 generators>
gap> Dimension( last );
5
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Modules over Semisimple Lie Algebras}

This section contains functions for calculating information on
representations of semisimple Lie algebras. First we have some functions
for calculating some combinatorial data (set of dominant weights, 
the dominant character, the decomposition of a tensor product, the dimension
of a highest-weight module). Then 
there is a function for creating an admissible lattice in the universal
enveloping algebra of a semisimple Lie algebra. Finally we have a function
for constructing a highest-weight module over a semisimple Lie algebra.

\>DominantWeights( <R>, <maxw> ) O

Returns a list consisting of two lists. The first of these contains
the dominant weights (written on the basis of fundamental weights)
of the irreducible highest-weight module over the Lie algebra with
root system <R>. The $i$-th element of the second list is the
level of the $i$-th dominant weight. (Where level is defined as follows.
For a weight $\mu$ we write $\mu=\lambda-\sum_i k_i \alpha_i$, where
the $\alpha_i$ are the simple roots, and $\lambda$ the highest weight.
Then the level of $\mu$ is $\sum_i k_i$.


\>DominantCharacter( <L>, <maxw> ) O
\>DominantCharacter( <R>, <maxw> ) O

For a highest weight <maxw> and a semisimple Lie algebra <L>, this
returns the dominant weights of the highest-weight module over <L>,
with highest weight <maxw>. The output is a list of two lists, the
first list contains the dominant weights; the second list contains
their multiplicities.

The first argument can also be a root system, in which case 
the dominant character of the highest-weight module over the
corresponding semisimple Lie algebra is returned. 


\>DecomposeTensorProduct( <L>, <w1>, <w2> ) O

Here <L> is a semisimple Lie algebra and <w1>, <w2> are dominant
weights. Let $V_i$ be the irreducible highest-weight module over <L>
with highest weight $w_i$ for $i=1,2$. Let $W=V_1\otimes V_2$. Then in
general $W$ is a reducible <L>-module. Now this function
returns a list of two lists. The first of these is the list of highest
weights of the irreducible modules occurring in the decomposition of
$W$ as a direct sum of irreducible modules. The second list contains
the multiplicities of these weights (i.e., the number of copies of
the irreducible module with the corresponding highest weight that occur
in $W$). The algorithm uses Klimyk's formula (see~\cite{Klimyk68} or
\cite{Klimyk66} for the original Russian version).


\>DimensionOfHighestWeightModule( <L>, <w> ) O

Here <L> is a semisimple Lie algebra, and <w> a dominant weight.
This function returns the dimension of the highest-weight module
over <L> with highest weight <w>. The algorithm
uses Weyl's dimension formula.



\beginexample
gap> L:= SimpleLieAlgebra( "F", 4, Rationals );;
gap> R:= RootSystem( L );;
gap> DominantWeights( R, [ 1, 1, 0, 0 ] );
[ [ [ 1, 1, 0, 0 ], [ 2, 0, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 1, 0, 0 ], 
      [ 1, 0, 0, 0 ], [ 0, 0, 0, 0 ] ], [ 0, 3, 4, 8, 11, 19 ] ]
gap> DominantCharacter( L, [ 1, 1, 0, 0 ] );
[ [ [ 1, 1, 0, 0 ], [ 2, 0, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 1, 0, 0 ], 
      [ 1, 0, 0, 0 ], [ 0, 0, 0, 0 ] ], [ 1, 1, 4, 6, 14, 21 ] ]
gap> DecomposeTensorProduct( L, [ 1, 0, 0, 0 ], [ 0, 0, 1, 0 ] );
[ [ [ 1, 0, 1, 0 ], [ 1, 0, 0, 0 ], [ 0, 0, 0, 1 ], [ 0, 1, 0, 0 ], 
      [ 2, 0, 0, 0 ], [ 0, 0, 1, 0 ], [ 1, 1, 0, 0 ] ], 
  [ 1, 1, 1, 1, 1, 1, 1 ] ]
gap> DimensionOfHighestWeightModule( L, [ 1, 2, 3, 4 ] );
79316832731136
\endexample

Let $L$ be a semisimple Lie algebra over a field of characteristic $0$,
and let $R$ be its root system. For a positive root $\alpha$ we let
$x_{\alpha}$ and $y_{\alpha}$ be positive and negative root vectors
respectively, both from a fixed Chevalley basis of $L$. Furthermore,
$h_1,\ldots, h_l$ are the Cartan elements from the same Chevalley
basis. Also we set
$$
x_{\alpha}^{(n)} = {x_{\alpha}^n \over n!}, \qquad
y_{\alpha}^{(n)} = {y_{\alpha}^n \over n!}\.
$$
Furthermore, let $\alpha_1,\ldots, \alpha_s$ denote the positive roots
of $R$. For multi-indices $N=(n_1,\ldots, n_s)$, $M=(m_1,\ldots, m_s)$
and $K=(k_1,\ldots, k_s)$ (where $n_i,m_i,k_i\geq 0$) set
$$
\matrix{
x^N &=& x_{\alpha_1}^{(n_1)}\cdots x_{\alpha_s}^{(n_s)},\cr
y^M &=& y_{\alpha_1}^{(m_1)}\cdots y_{\alpha_s}^{(m_s)},\cr
h^K &=& {h_1\choose k_1}\cdots {h_l\choose k_l}\cr
}
$$
Then by a theorem of Kostant, the $x_{\alpha}^{(n)}$ and
$y_{\alpha}^{(n)}$ generate a subring of the universal enveloping algebra
$U(L)$ spanned (as a free $Z$-module) by the elements
$$
y^Mh^Kx^N
$$
(see, e.g., \cite{Hum72} or \cite{Hum78}, Section 26)
So by the Poincare-Birkhoff-Witt theorem
this subring is a lattice in $U(L)$. Furthermore, this lattice is
invariant under the $x_{\alpha}^{(n)}$ and $y_{\alpha}^{(n)}$.
Therefore, it is called an admissible lattice in $U(L)$.

The next functions enable us to construct the generators of such an
admissible lattice.


\>IsUEALatticeElement( <obj> ) C
\>IsUEALatticeElementCollection( <obj> ) C
\>IsUEALatticeElementFamily( <fam> ) C

is the category of elements of an admissible lattice in the universal
enveloping algebra of a semisimple Lie algebra `L'.


\>LatticeGeneratorsInUEA( <L> ) A

Here <L> must be a semisimple Lie algebra of characteristic $0$.
This function returns a list of generators of an admissible lattice
in the universal enveloping algebra of <L>, relative to
the Chevalley basis contained in `ChevalleyBasis( <L> )'.
First are listed the negative root vectors (denoted by $y_1,\ldots, y_s$),
then the positive root vectors (denoted by $x_1,\ldots, x_s$). At the
end of the list there are the Cartan elements. They are printed as
`( hi/1 )', which means
$$
{h_i\choose 1}\.
$$
In general the printed form `( hi/ k )' means 
$$
{h_i\choose k}\.
$$

Also $y_i^{(m)}$ is printed as `yi^(m)', which means that entering
`yi^m' at the {\GAP} prompt results in the output `m!*yi^(m)'.

Products of lattice generators are collected using the following order:
first come the $y_i^{(m_i)}$ (in the same order as the positive roots),
then
the ${h_i\choose k_i},$ and then the $x_i^{(n_i)}$ (in the same order as
the positive roots).


\>ObjByExtRep( <F>, <descr> ) O

creates an object in the family <F> which has the external
representation <descr>.


 
  An UEALattice element is represented by a list of the form

      [ m1, c1, m2, c2,.....]

  where the c1,c2 etc. are coefficients, and the m1, m2 etc. monomials.
  A monomial is a list of the form [ ind1, e1, ind2, e2, ....]
  where ind1, ind2 are indices, and e1, e2 etc. are exponents. Let
  N be the number of positive roots of the underlying Lie algebra. The
  indices lie between 1 and $\dim L$. If an index lies between 1 and N,
  then it represents a negative root vector (corresponding to the root
  `NegativeRoots( R )[ind]', where R is the root system of L). This leads
  to a factor `yind1^(e1)' in the printed form of the monomial (which equals
  z^e1/e1!, where z is a basis element of L). If an index
  lies between N+1 and 2N, then it represents a positive root vector.
  Finally, if ind lies between 2N+1 and 2N+rank, then it represents
  an element of the Cartan subalgebra. This is printed as ( h_1/ e_1 ),
  meaning h_1 choose e_1 (h_1,...,h_rank are the canonical Cartan
  generators).

  The zero element is represented by the empty list, the identity
  element by the list [ [  ], 1 ].

\beginexample
gap> L:= SimpleLieAlgebra( "G", 2, Rationals );;
gap> g:=LatticeGeneratorsInUEA( L );
[ y1, y2, y3, y4, y5, y6, x1, x2, x3, x4, x5, x6, ( h13/1 ), ( h14/1 ) ]
gap> IsUEALatticeElement( g[1] );
true
gap> g[1]^3;
6*y1^(3)
gap> q:= g[7]*g[1]^2;
-2*y1+2*y1*( h13/1 )+2*y1^(2)*x1
gap> ExtRepOfObj( q );
[ [ 1, 1 ], -2, [ 1, 1, 13, 1 ], 2, [ 1, 2, 7, 1 ], 2 ]
\endexample

\>IsWeightRepElement( <obj> ) C
\>IsWeightRepElementCollection( <obj> ) C
\>IsWeightRepElementFamily( <fam> ) C

Is a category of vectors, that is used to construct elements of
highest-weight modules (by `HighestWeightModule').

WeightRepElements are represented by a list of the form
`[ v1, c1, v2, c2, ....]', where the `v<i>' are basis vectors, and
the `c<i>' coefficients. Furthermore a basis vector `v' is a weight vector.
It is represented by a list of
form `[ <k>, <mon>, <wt> ]', where <k> is an integer (the basis vectors
are numbered from $1$ to $\dim V$, where $V$ is the highest weight
module), <mon> is an UEALatticeElement (which means that the result of
applying <mon> to a highest weight vector is `v') and <wt> is the weight
of <v>. A WeightRepElement is printed as `<mon>*v0', where `v0'
denotes a fixed highest weight vector.

If <v> is a WeightRepElement, then `ExtRepOfObj( <v> )' returns
the corresponding list, and if <list> is such a list and <fam> a
WeightRepElementFamily, then `ObjByExtRep( <list>, <fam> )' returns
the corresponding WeightRepElement.


\>HighestWeightModule( <L>, <wt> ) F

returns the highest weight module with highest weight <wt> of the
semisimple Lie algebra <L> of characteristic $0$.

Note that the elements of such a module lie in the category
`IsLeftAlgebraModuleElement' (and in particular they do not lie
in the category `IsWeightRepElement'). However, if `v' is an element
of such a module, then `ExtRepOfObj( v )' is a WeightRepElement.



Note that for the following examples of this chapter we increase the line
length limit from its default value 80 to 81 in order to make some long
output expressions fit into the lines.

\beginexample
gap> SizeScreen([ 81, ]);;
gap> K1:= SimpleLieAlgebra( "G", 2, Rationals );;
gap> K2:= SimpleLieAlgebra( "B", 2, Rationals );;
gap> L:= DirectSumOfAlgebras( K1, K2 );
<Lie algebra of dimension 24 over Rationals>
gap> V:= HighestWeightModule( L, [ 0, 1, 1, 1 ] );
<224-dimensional left-module over <Lie algebra of dimension 24 over Rationals>>
gap> vv:= GeneratorsOfLeftModule( V );;
gap> vv[100];
y5*y7*y10*v0
gap> e:= ExtRepOfObj( vv[100] );
y5*y7*y10*v0
gap> ExtRepOfObj( e );
[ [ 100, y5*y7*y10, [ -3, 2, -1, 1 ] ], 1 ]
gap> Basis(L)[17]^vv[100];
-1*y5*y7*y8*v0-1*y5*y9*v0
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Tensor Products and Exterior and Symmetric Powers}

\>TensorProductOfAlgebraModules( <list> ) O
\>TensorProductOfAlgebraModules( <V>, <W> ) O

Here the elements of <list> must be algebra modules. 
The tensor product is returned as an algebra module. 



\beginexample
gap> L:= SimpleLieAlgebra("G",2,Rationals);;
gap> V:= HighestWeightModule( L, [ 1, 0 ] );;
gap> W:= TensorProductOfAlgebraModules( [ V, V, V ] );
<343-dimensional left-module over <Lie algebra of dimension 14 over Rationals>>
gap> w:= Basis(W)[1];
1*(1*v0<x>1*v0<x>1*v0)
gap> Basis(L)[1]^w;
<0-tensor>
gap> Basis(L)[7]^w;
1*(1*v0<x>1*v0<x>y1*v0)+1*(1*v0<x>y1*v0<x>1*v0)+1*(y1*v0<x>1*v0<x>1*v0)
\endexample

\>ExteriorPowerOfAlgebraModule( <V>, <k> ) O

Here <V> must be an algebra module, defined over a Lie algebra. 
This function returns the <k>-th exterior power of <V> as an 
algebra module.




\beginexample
gap> L:= SimpleLieAlgebra("G",2,Rationals);;
gap> V:= HighestWeightModule( L, [ 1, 0 ] );;
gap> W:= ExteriorPowerOfAlgebraModule( V, 3 );
<35-dimensional left-module over <Lie algebra of dimension 14 over Rationals>>
gap> w:= Basis(W)[1];
1*(1*v0/\y1*v0/\y3*v0)
gap> Basis(L)[10]^w;
1*(1*v0/\y1*v0/\y6*v0)+1*(1*v0/\y3*v0/\y5*v0)+1*(y1*v0/\y3*v0/\y4*v0)
\endexample

\>SymmetricPowerOfAlgebraModule( <V>, <k> ) O

Here <V> must be an algebra module. This function returns the <k>-th
symmetric power of <V> (as an algebra module).



\beginexample
gap> L:= SimpleLieAlgebra("G",2,Rationals);;
gap> V:= HighestWeightModule( L, [ 1, 0 ] );;
gap> W:= SymmetricPowerOfAlgebraModule( V, 3 );
<84-dimensional left-module over <Lie algebra of dimension 14 over Rationals>>
gap> w:= Basis(W)[1];
1*(1*v0.1*v0.1*v0)
gap> Basis(L)[2]^w;
<0-symmetric element>
gap> Basis(L)[7]^w;
3*(1*v0.1*v0.y1*v0)
\endexample

\>DirectSumOfAlgebraModules( <list> )!{for Lie algebras} O
\>DirectSumOfAlgebraModules( <V>, <W> )!{for Lie algebras} O

Here <list> must be a list of algebra modules. This function returns the
direct sum of the elements in the list (as an algebra module).
The modules must be defined over the same algebras.

In the second form is short for `DirectSumOfAlgebraModules( [ <V>, <W> ] )'



\beginexample
gap> L:= SimpleLieAlgebra( "C", 3, Rationals );;
gap> V:= HighestWeightModule( L, [ 1, 1, 0 ] );
<64-dimensional left-module over <Lie algebra of dimension 21 over Rationals>>
gap> W:= HighestWeightModule( L, [ 0, 0, 2 ] );
<84-dimensional left-module over <Lie algebra of dimension 21 over Rationals>>
gap> U:= DirectSumOfAlgebraModules( V, W );
<148-dimensional left-module over <Lie algebra of dimension 21 over Rationals>>
gap> SizeScreen([ 80, ]);;
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%E
