% This file was created automatically from language.msk.
% DO NOT EDIT!
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%W  language.msk           GAP documentation                Martin Schoenert
%%
%H  @(#)$Id: language.msk,v 1.37.2.1 2004/01/28 16:50:48 stefan Exp $
%%
%Y  Copyright 1990-1992, Lehrstuhl D fuer Mathematik, RWTH Aachen, Germany
%%
%%  This file describes the {\GAP} programming language.
%%
\Chapter{The Programming Language}

This chapter describes the {\GAP} programming language.  It should allow
you in principle to predict the result of each and every input. In order
to know what we are talking about, we first have to look more closely at
the process of interpretation and the various representations of data
involved.

%%  The {\GAP} language and its interpreter in the kernel were designed by 
%%  Martin Sch{\"o}nert.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Language Overview}

First we have the input to {\GAP}, given as a string of characters. How
those characters enter {\GAP} is operating system dependent, e.g., they
might be entered at a terminal, pasted with a mouse into a window, or
read from a file. The mechanism does not matter. This representation of
expressions by characters is called the *external representation* of the
expression. Every expression has at least one external representation
that can be entered to get exactly this expression.

The input, i.e., the external representation, is transformed in a process
called *reading* to an internal representation.  At this point the input
is analyzed and inputs  that are not legal external representations,
according to the rules given below, are rejected as errors. Those rules
are usually called the *syntax* of a programming language.

The internal representation created by reading is called either an
*expression* or a *statement*.  Later we will distinguish between those
two terms.  However for now we will use them interchangeably.
The exact form of the internal representation does not matter.
It could be a string of characters equal to the external representation,
in which case the reading would only need to check for errors.
It could be a series of machine instructions for the processor on which
{\GAP} is running, in which case the reading would more appropriately
be called compilation.
It is in fact a tree-like structure.

After the input has been read it is again transformed in a process called
*evaluation* or *execution*. Later we will distinguish between those two
terms too, but for the moment we will use them interchangeably. The name
hints at the nature of this process, it replaces an expression with the
value of the expression. This works recursively, i.e., to evaluate an
expression first the subexpressions are evaluated and then the value of
the expression is computed from those values according to rules given below.
Those rules are usually called the *semantics* of a programming language.

The result of the evaluation is, not surprisingly, called a *value*.
% The
% set of values  is of course a  much smaller set than the  set of
% expressions; for every value there may be several expressions that will
% evaluate to  this value.
Again the form in which such a  value is
represented internally does not  matter. It is  in fact a tree-like
structure again.

The last process is called *printing*. It takes the value produced by
the evaluation and creates an external representation, i.e., a string of
characters again. What you do with this external representation is up to
you. You can look at it, paste it with the mouse into another window, or
write it to a file.

Lets look at an example to make this more clear. Suppose you type in the
following string of 8 characters

\begintt
1 + 2 * 3;
\endtt

{\GAP} takes  this external representation  and creates  a tree-like
internal representation, which we can picture as follows

\begintt
  +
 / \
1   *
   / \
  2   3
\endtt

This expression is then evaluated. To do this {\GAP} first evaluates the
right subexpression `2*3'.  Again, to do this {\GAP} first evaluates its
subexpressions 2 and 3. However they are so simple that they are their
own value, we say that they are self-evaluating. After this has been
done, the rule for `*' tells us that the value is the product of the
values of the two subexpressions, which in this case is clearly 6.
Combining this with the value of the left operand of the `+', which is
self-evaluating, too, gives us the value of the whole expression 7. This
is then printed, i.e., converted into the external representation
consisting of the single character `7'.

In this fashion we can predict the result of every input when we know the
syntactic rules that govern the process of reading and the semantic rules
that tell us for every expression how its value is computed in terms of
the values of the subexpressions. The syntactic rules are given in
sections "Lexical Structure",  "Symbols", "Whitespaces", "Keywords",
"Identifiers", and "The Syntax in BNF", the semantic rules are given in
sections "Expressions", "Variables", "Function Calls", "Comparisons",
"Arithmetic Operators",  "Statements", "Assignments", "Procedure Calls",
"If", "While", "Repeat", "For", "Function", and the chapters describing
the individual data types.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Lexical Structure}

The input of {\GAP} consists of sequences of the following characters.

Digits, uppercase and lowercase letters, <space>, <tab>, <newline>, and
the special characters

\begintt
"    `    (    )    *    +    ,    _    #
.    /    :    ;    <    =    >    ~    &
[    \    ]    ^    _    {    }    ! 
\endtt

Other characters will be signalled as illegal.  Inside strings
(see section~"Symbols" and chapter~"Strings and Characters") and
comments (see~"Whitespaces") the full character set supported by
the computer is allowed.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Symbols}

The process of reading, i.e., of assembling the input into expressions,
has a subprocess, called *scanning*, that assembles the characters into
symbols.  A *symbol* is a sequence of characters that form a lexical
unit. The set of symbols consists of keywords, identifiers, strings,
integers, and operator and delimiter symbols.

A *keyword* is a reserved word consisting entirely of lowercase letters
(see "Keywords"). An *identifier* is a sequence of letters and digits that
contains at least one letter and is not a keyword (see "Identifiers").
An integer is a sequence of digits (see "Integers").  A *string* is a
sequence of  arbitrary characters  enclosed in double quotes (see
"Strings and Characters").

Operator and delimiter symbols are

\begintt
+    -    *    /    ^    ~   !.
=    <>   <    <=   >    >=  ![
:=   .    ..   ->   ,    ;   !{
[    ]    {    }    (    )    :
\endtt

Note also that during the process of scanning all whitespace is removed
(see "Whitespaces").

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Whitespaces}

\index{space}
\index{blank}\index{tabulator}\index{newline}\index{comments}
The  characters <space>, <tab>,  <newline>, and  <return> are called
*whitespace characters*.  Whitespace is used  as necessary to separate
lexical symbols, such as integers, identifiers, or keywords. For example
`Thorondor' is a single identifier, while `Th or ondor' is the keyword
`or' between the two identifiers `Th' and `ondor'. Whitespace may occur
between any two symbols, but not within a symbol. Two or more adjacent
whitespace characters are equivalent to a single whitespace.
Apart from the role as separator of symbols,
whitespace characters are  otherwise insignificant.
Whitespace characters may also occur inside a string,
where they are significant.
Whitespace characters should also be used freely for improved readability.

A *comment* starts with the  character `\#', which is sometimes called
sharp or hatch, and continues to the end of the line on which the comment
character appears. The whole comment, including `\#' and the <newline>
character is treated as a single  whitespace. Inside a string, the
comment character `\#' loses its role and is just an ordinary character.

For example, the following statement

\begintt
if i<0 then a:=-i;else a:=i;fi;
\endtt

is equivalent to

\begintt
if i < 0 then   # if i is negative
  a := -i;      #   take its additive inverse
else            # otherwise
  a := i;       #   take itself
fi;
\endtt

(which by the way shows that it is possible to write superfluous
comments). However the first statement is *not* equivalent to

\begintt
ifi<0thena:=-i;elsea:=i;fi;
\endtt

since the keyword `if' must be separated from the identifier `i' by a
whitespace, and similarly `then' and `a', and `else' and `a' must be
separated.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Keywords}

*Keywords* are reserved words that are used to denote special operations
or are part of statements. They must not be used as identifiers. The
keywords are

\begintt
and     do       elif   else    end     fi
for     function if     in      local   mod
not     od       or     repeat  return  then
until   while    quit   QUIT    break   rec 
continue
\endtt

Note that (almost) all keywords are written in lowercase and that they
are case sensitive. For example only `else' is a keyword; `Else',
`eLsE', `ELSE' and so forth are ordinary identifiers. Keywords must
not contain whitespace, for example `el if' is not the same as `elif'.

Note: A number of tokens that appear to be normal identifiers
representing functions or literals of various kinds are actually
implemented as keywords for technical reasons. The only consequence of
this is that those identifiers cannot be re-assigned, and do not
actually have function objects bound to them, which could be assigned
to other variables or passed to functions. These keywords are:

\begintt
false 	true	IsBound	Unbind	TryNextMethod	
Info	Assert	SaveWorkspace   fail
\endtt


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Identifiers}

An *identifier* is used to refer to  a variable (see "Variables").  An
identifier consists of letters, digits, and underscores `\_', and must
contain at least one letter or underscore.  An identifier is terminated
by the first character not in this class. Examples of valid identifiers
are

\begintt
a           foo         aLongIdentifier
hello       Hello       HELLO
x100        100x       _100
some_people_prefer_underscores_to_separate_words
WePreferMixedCaseToSeparateWords
\endtt

Note that case is significant, so the three identifiers in the second
line are distinguished.

The backslash `\\' can be used to include other characters in identifiers;
a backslash followed by a character is equivalent  to the character,
except that this escape sequence is considered to be an ordinary letter.
For example
\begintt
G\(2\,5\)
\endtt
is an identifier, not a call to a function `G'.

An identifier that starts with a backslash is never a keyword, so for
example `\\*' and `\\mod' are identifiers.

The length of identifiers is not limited,  however only the first 1023
characters are significant. The escape sequence `\\'<newline> is ignored,
making it possible to split long identifiers over multiple lines.

\>IsValidIdentifier( <str> ) F

returns `true'  if  the  string  <str>  would  form  a  valid  identifier
consisting of letters,  digits  and  underscores;  otherwise  it  returns
`false'. It does not check whether <str> contains characters escaped by a
backslash `\\'.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Expressions}

\index{evaluation}
An *expression* is a construct that evaluates to a value.  Syntactic
constructs that are executed to produce a side effect and return no value
are called *statements* (see "Statements"). Expressions appear as right
hand sides of assignments (see "Assignments"), as actual arguments in
function calls (see "Function Calls"), and in statements.

Note that an expression is not the same as a value. For example `1 + 11'
is an  expression, whose value is  the  integer 12.  The external
representation of this integer is the character sequence `12', i.e., this
sequence is output if the integer is printed. This sequence is another
expression whose value is the integer 12.  The process of finding the
value of an expression is done by the interpreter and is called the
*evaluation* of the expression.

Variables, function calls, and integer, permutation, string, function,
list, and record literals (see "Variables", "Function Calls", "Integers",
"Permutations",  "Strings  and  Characters",  "Function"s,  "Lists",
"Records"), are the simplest cases of expressions.

Expressions, for example the simple expressions mentioned above, can be
combined with the operators to form more complex expressions. Of course
those expressions can then be combined further with the operators to form
even more complex expressions. The *operators* fall into three classes.
\index{operators}
The *comparisons* are `=', `\<>', `\<', `\<=', `>',  `>=', and `in' (see
"Comparisons" and "Membership Test for Collections").
The *arithmetic operators* are `+', `-', `*',
`/', `mod', and `^' (see~"Arithmetic Operators").
The *logical operators* are `not', `and', and `or'
(see~"Operations for Booleans").

The following example shows a very simple expression with value 4 and a
more complex expression.

\beginexample
gap> 2 * 2;
4
gap> 2 * 2 + 9 = Fibonacci(7) and Fibonacci(13) in Primes;
true
\endexample

For the precedence of operators, see~"Comparisons".

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Variables}

\index{scope}\index{bound}
A *variable* is a location in a {\GAP} program that points to a value.
We say the variable is *bound* to this value. If a variable is evaluated
it evaluates to this value.

Initially an ordinary variable is not bound to any value. The variable
can be bound to a value by *assigning* this value to the variable (see
"Assignments"). Because of this we sometimes say that a variable that is
not bound to any value has no assigned value. Assignment is in fact the
only way by which a variable, which is not an argument of a function, can
be bound to a value. After a variable has been bound to a  value an
assignment can also be used to bind the variable to another value.

A special class of variables is the class of *arguments* of functions.
They behave similarly to other variables,
except they are bound to the value of the
actual arguments upon a function call (see "Function Calls").

Each variable has a name that is also called its *identifier*. This is
because in a given scope an identifier identifies a unique variable (see
"Identifiers"). A *scope* is a lexical part of a program text. There is
the *global scope* that encloses the entire program text, and there are
local scopes that range from the `function' keyword, denoting the
beginning of a function definition, to the corresponding `end' keyword.
A *local scope* introduces new variables, whose identifiers are given in
the formal argument list and the `local' declaration of the function (see
"Function"). Usage of an identifier in a program text refers to the
variable in the innermost scope that has this identifier as its name.
Because this mapping from identifiers to variables is done when the
program is read, not when it is executed, {\GAP} is said to have *lexical
scoping*.  The following example shows how one identifier refers to
different variables at different points in the program text.

\begintt
g := 0;      # global variable g
x := function ( a, b, c )
  local  y;
  g := c;     # c refers to argument c of function x
  y := function ( y )
    local d, e, f;
    d := y;   # y refers to argument y of function y
    e := b;   # b refers to argument b of function x
    f := g;   # g refers to global variable g
    return d + e + f;
  end;
  return y( a ); # y refers to local y of function x
end;
\endtt

It is important to note that the concept of a variable in {\GAP} is quite
different from the concept of a variable in programming languages like
PASCAL.

In those languages a variable denotes a block of memory. The
value of the variable is stored in this block. So in those languages two
variables can have the same value, but they can never have identical
values, because they denote different blocks of memory.  Note that
PASCAL has the concept of a reference argument. It seems as if such an
argument and the variable used in the actual function call have the same
value, since changing the argument's value also changes the value of the
variable used in the actual function call.  But this is not so; the
reference argument is actually a pointer to the variable used in the
actual function call, and it is the compiler that inserts enough magic to
make the pointer invisible.  In order for this to work the compiler
needs enough information to compute the amount of memory needed for each
variable in a program, which is readily available in the declarations
PASCAL requires for every variable.

In {\GAP} on the other hand each variable just points to a value,
and different variables can share the same value.

\>Unbind( <ident> ) F

deletes the identifier <ident>. If there is no other variable pointing to
the same value as <ident> was, this value will be removed by the next
garbage collection. Therefore `Unbind' can be used to get rid of unwanted
large objects.

For records and lists `Unbind' can be used to delete components or entries,
respectively (see Chapters~"Records" and "Lists").


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{More About Global Variables}

The vast majority of variables in {\GAP} are defined at the outer
level (the global scope). They are used to access functions and
other objects created either in the {\GAP} library or in the user's
code. Certain special facilities are provided for manipulating these
variables which are not available for other types of variable (such as 
local variables or function arguments).

First, such variables may be marked *read-only*. In which case
attempts to change them will fail. Most of the global variables
defined in the {\GAP} library are so marked.

\>IsReadOnlyGlobal( <name> ) F

returns `true' if the global variable named by the string <name> is 
read-only and `false' otherwise (the default). 

\>MakeReadOnlyGlobal( <name> ) F

marks the global variable named by the string <name> as read-only. 

A warning is given if <name> has no value bound to it or if it is
already read-only.

\>MakeReadWriteGlobal( <name> )  F

marks the global variable named by the string <name> as read-write.

A warning is given if <name> is already read-write.

%notest
\beginexample
gap> xx := 17;
17
gap> IsReadOnlyGlobal("xx");
false
gap> xx := 15;
15
gap> MakeReadOnlyGlobal("xx");
gap> xx := 16;
Variable: 'xx' is read only
not in any function
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you can 'return;' after making it writable to continue
brk> quit;
gap> IsReadOnlyGlobal("xx");
true
gap> MakeReadWriteGlobal("xx");
gap> xx := 16;
16
gap> IsReadOnlyGlobal("xx");
false
\endexample

A group of functions are also supplied for accessing and altering the
values assigned to global variables. Use of these functions differs
from the use of assignment, `Unbind' and `IsBound' statements, in two
ways.
First, these functions always affect global variables, even if 
local variables of the same names exist.
Second, the variable names are passed as strings,
rather than being written directly into the statements. 

\>ValueGlobal( <name> ) F
 
returns the value currently bound to the global variable named by the 
string <name>. An error is raised if no value is currently bound.

\>IsBoundGlobal( <name> ) F

returns `true' if a value currently bound
to the global variable named by the string <name> and `false' otherwise.

\>UnbindGlobal( <name> ) F

removes any value currently bound
to the global variable named by the string <name>. Nothing is returned.

A warning is given if <name> was not bound. The global variable named
by <name> must be writable, otherwise an error is raised.

\>BindGlobal( <name>, <val> )  F

sets the global variable named by the
string <name> to the value <val>, provided it is writable, and makes
it read-only. If <name> already has a value, a warning message is
printed.  

This is intended to be the normal way to create and set ``official''
global variables (such as Operations and Categories).  

Caution should be exercised in using these functions, especially
`BindGlobal' and `UnbindGlobal' as unexpected changes in global
variables can be very confusing for the user.

\beginexample
gap> xx := 16;
16
gap> IsReadOnlyGlobal("xx");
false
gap> ValueGlobal("xx");
16
gap> IsBoundGlobal("xx");
true
gap> BindGlobal("xx",17);
#W BIND_GLOBAL: variable `xx' already has a value
gap> xx;
17
gap> IsReadOnlyGlobal("xx");
true
\endexample

Finally, there are a group of functions dealing with the *global
namespace*.

\>NamesGVars() F

This function returns an immutable (see~"Mutability and Copyability") sorted
(see~"Sorted Lists and Sets") list of all the global
variable names known to the system.  This includes names of variables
which were bound but have now been unbound and some other names which
have never been bound but have become known to the system by various
routes.

\>NamesSystemGVars() F

This function returns an immutable sorted list of all the global
variable names created by the {\GAP} library when {\GAP} was started.

\>NamesUserGVars() F

This function returns an immutable sorted list of the global variable
names created since the library was read, to which a value is
currently bound.

\>TemporaryGlobalVarName( [<prefix>] ) F

returns a string  that can be used
as the  name  of a global  variable  that is not bound   at the time when
`TemporaryGlobalVarName()'  is called.    The optional  argument <prefix> can
specify a string with which the name of the global variable starts.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Function Calls}

\>`<function-var>()'{function call}
\>`<function-var>( <arg-expr>[, <arg-expr>, ...] )'{function call!with arguments}

The function call has the effect of calling the function <function-var>.
The precise semantics are as follows.

First {\GAP} evaluates the <function-var>.
Usually <function-var> is a variable,
and {\GAP} does nothing more than taking the value of this variable.
It is allowed though that <function-var> is a more complex expression,
such as a reference to an element of a list (see Chapter~"Lists")
`<list-var>[<int-expr>]',
or to a component of a record (see Chapter~"Records") `<record-var>.<ident>'.
In any case {\GAP} tests whether the value is a function.
If it is not, {\GAP} signals an error.

\index{functions!with a variable number of arguments}
\indextt{arg!special function argument}
Next {\GAP} checks that the number of actual arguments <arg-expr>s agrees
with the number of *formal arguments* as given in the function definition.
If they do not agree {\GAP} signals an error. An exception is the case
when there is exactly one formal argument with the name `arg', in which
case any number of actual arguments is allowed (see~"function" for
examples).

Now {\GAP} allocates for each formal argument and for each *formal local*
(that is, the identifiers in the `local' declaration) a new variable.
Remember that a variable is a location in a {\GAP} program
that points to a value. Thus for  each formal argument and for each
formal local such a location is allocated.

Next the arguments <arg-expr>s are evaluated, and the values are assigned
to the newly created variables corresponding to the formal arguments. Of
course the first value is assigned to the new variable corresponding to
the first formal argument, the second  value  is assigned to the new
variable corresponding  to  the second  formal argument, and  so on.
However, {\GAP} does not make any guarantee about the order in which the
arguments are evaluated. They might be evaluated left to right, right to
left, or in any other order, but each argument is evaluated once. An
exception again occurs if the function has only one formal argument with
the name `arg'. In this case the values of all the actual arguments are
stored in  a list and this  list is assigned to the  new variable
corresponding to the formal argument `arg'.

The new variables corresponding to the formal locals are initially not
bound to any  value.  So trying  to evaluate those  variables before
something has been assigned to them will signal an error.

Now the body of the function, which is a statement, is executed. If the
identifier of one of the formal arguments or formal locals appears in the
body of the function it refers to the new variable that was allocated for
this formal argument or formal local, and evaluates to the value of this
variable.

If during the execution of the body of the function a `return' statement
with an expression (see "Return") is executed, execution of the body is
terminated and the value of the function call is the value of the
expression of the `return'. If during the execution of the body a
`return' statement without an expression is executed, execution of the
body is terminated and the function call does not produce a value, in
which case we call this call a procedure call (see "Procedure Calls").
If the execution of the body completes without execution of a `return'
statement, the function call again produces no value, and again we talk
about a procedure call.

\beginexample
gap> Fibonacci( 11 );
89
\endexample

The above example shows a call to the function `Fibonacci' with actual
argument `11', the following one shows a call to the operation
`RightCosets' where the second actual argument is another function call.

%notest
\beginexample
gap> RightCosets( G, Intersection( U, V ) );;
\endexample

\>`<function-var>( <arg-expr>[, <arg-expr>, ...][ : [ <option-expr> [,<option-expr>, ....]]])'{function call!with options}

As well as passing arguments to a function, providing the mathematical 
input to its calculation, it is sometimes useful to supply ``hints''
suggesting to {\GAP} how the desired result may be computed more
quickly, or specifying a level of tolerance for random errors in a
Monte Carlo algorithm.

Such hints may be supplied to a function-call *and to all subsidiary
functions called from that call* using the options mechanism. Options
are separated from the actual arguments by a colon `:' and have much
the same syntax as the components of a record expression. The one
exception to this is that a component name may appear without a value,
in which case the value `true' is silently inserted.

The following example shows a call to `Size' passing the options `hard'
(with the value `true') and `tcselection' (with the string ``external''
as value).

%notest
\beginexample
gap> Size( fpgrp : hard, tcselection := "external" );
\endexample

Options supplied with function calls in this way are passed down using 
the global options stack described in chapter "ref:Options Stack", so that
the call above is exactly equivalent to

%notest
\beginexample
gap> PushOptions( rec( hard := true, tcselection := "external") );
gap> Size( fpgrp );
gap> PopOptions( );
\endexample

*Note* that any option may be passed with any function, whether or not 
it has any actual meaning for that function, or any function called by 
it. The system provides no safeguard against misspelled option names.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Comparisons}

\>`<left-expr> = <right-expr>'{equality test}
\>`<left-expr> \<> <right-expr>'{inequality test}

The operator `=' tests for equality of its two operands and evaluates to
`true' if they are equal and to `false' otherwise. Likewise `\<>' tests
for inequality of its two operands. Note that any two objects can be
compared, i.e., `=' and `\<>' will never signal an error. For each type
of objects the definition of equality is given in the respective chapter.
Objects in different families (see~"Families") are never equal,
i.e., `=' evaluates in this case to `false', and `\<>' evaluates to `true'.

\>`<left-expr> \< <right-expr>'{smaller test}
\>`<left-expr> >  <right-expr>'{larger test}
\>`<left-expr> \<= <right-expr>'{smaller or equal}
\>`<left-expr> >= <right-expr>'{larger or equal}

`\<' denotes less than, `\<=' less than or equal, `>' greater than, and
`>=' greater than or equal of its two operands.
For each kind of objects the definition of the ordering is given in the
respective chapter.

Only for the following kinds of objects, an ordering via `\<' of objects
in *different* families (see~"Families") is supported.
Rationals (see~"IsRat") are smallest,
next are cyclotomics (see~"IsCyclotomic"),
followed by finite field elements (see~"IsFFE");
finite field elements in different characteristics are compared
via their characteristics,
next are permutations (see~"IsPerm"),
followed by the boolean values `true', `false', and `fail'
(see~"IsBool"),
characters (such as `{'}a{'}', see~"IsChar"),
and lists (see~"IsList") are largest;
note that two lists can be compared with `\<' if and only if their
elements are again objects that can be compared with `\<'.

For other objects, {\GAP} does *not* provide an ordering via `\<'.
The reason for this is that a total ordering of all {\GAP} objects
would be hard to maintain when new kinds of objects are introduced,
and such a total ordering is hardly used in its full generality.

However, for objects in the filters listed above, the ordering via `\<'
has turned out to be useful.
For example, one can form *sorted lists* containing integers and nested
lists of integers, and then search in them using `PositionSorted'
(see~"Finding Positions in Lists").

Of course it would in principle be possible to define an ordering
via `\<' also for certain other objects,
by installing appropriate methods for the operation `\\\<'.
But this may lead to problems at least as soon as one loads {\GAP} code
in which the same is done, under the assumption that one is completely
free to define an ordering via `\<' for other objects than the ones
for which the ``official'' {\GAP} provides already an ordering via `\<'.



Comparison operators, including the operator `in'
(see~"Membership Test for Lists"),
are not associative,
Hence it is not allowed to write `<a> = <b> \<> <c> = <d>',
you must use `(<a> = <b>) \<> (<c> = <d>)' instead.
The comparison operators have  higher precedence than the logical operators
\index{operators!precedence}
(see~"Operations for Booleans"), but lower precedence than the arithmetic
operators (see~"Arithmetic Operators").
Thus, for instance, `<a> * <b> = <c> and <d>' is interpreted as
`((<a> * <b>) = <c>) and <d>)'.

The following example shows a comparison where the left operand is an
expression.

\beginexample
gap> 2 * 2 + 9 = Fibonacci(7);
true
\endexample

For the underlying operations of the operators introduced above,
see~"Comparison Operations for Elements".

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Arithmetic Operators}

\index{precedence}\index{associativity}\index{operators!arithmetic}
\indextt{+}\indextt{-}\indextt{\*}\indextt{/}\indextt{\^{}}
\indextt{mod!arithmetic operators}
\index{modulo}\index{modulo!arithmetic operators}

\>`+ <right-expr>'{positive number}
\>`- <right-expr>'{negative number}
\>`<left-expr> + <right-expr>'{addition}
\>`<left-expr> - <right-expr>'{subtraction}
\>`<left-expr> * <right-expr>'{multiplication}
\>`<left-expr> / <right-expr>'{division}
\>`<left-expr> mod <right-expr>'{mod}@{`mod'}
\>`<left-expr> ^ <right-expr>'{power}

The arithmetic operators are `+', `-', `*', `/', `mod', and `^'.
The meanings (semantics) of those operators generally depend on the types
of the operands involved, and, except for `mod', they are defined in the 
various chapters describing the types. However basically the meanings are
as follows.

`<a> + <b>' denotes the addition of additive elements <a> and <b>.

`<a> - <b>' denotes the addition of <a> and the additive inverse of <b>.

`<a> * <b>' denotes the multiplication of multiplicative elements <a> and
<b>.

`<a> / <b>' denotes the multiplication of <a> with the multiplicative
inverse of <b>.

\index{mod!rationals}
`<a> mod <b>', for integer or rational left operand <a> and for non-zero
integer right operand <b>, is defined as follows.
If <a> and <b> are both integers, `<a> mod <b>' is the integer <r> in the
integer range `0 .. |<b>| - 1' satisfying `<a> = <r> + <b><q>',
for some integer <q> (where the operations occurring have their usual meaning
over the integers, of course).

\index{modular remainder}\index{modular inverse}
\index{coprime}\index{relatively prime}
If <a> is a rational number and <b> is a non-zero integer, and `<a> = <m>
/ <n>' where <m> and <n> are coprime integers  with  <n>  positive,  then
`<a> mod <b>' is the integer <r> in the integer range `0 ..  |<b>|  -  1'
such that <m> is congruent to `<r><n>' modulo <b>, and <r> is called the
``modular remainder'' of <a> modulo <b>. Also,  `1  /  <n>  mod  <b>'  is
called the ``modular inverse'' of <n> modulo <b>. (A pair of integers  is
said to be *coprime* (or *relatively prime*) if their gcd is 1.)

With the above definition, `4 / 6 mod 32' equals `2 / 3 mod 32' and hence
exists (and is equal to 22), despite the  fact  that  6  has  no  inverse
modulo 32.

*Note.*
For rational <a>, `<a> mod <b>'  could have been defined to be the
non-negative rational <c> less than `|<b>|' such that `<a> - <c>' is a
multiple of <b>. However this definition is seldom useful and *not* the
one chosen for {\GAP}.

`+' and `-' can also be used as unary operations.
The unary `+' is ignored. The unary `-' returns the additive inverse of
its operand; over the integers it is equivalent to multiplication by `-1'.

`^' denotes powering of a multiplicative element if the right operand  is
an integer, and is also used to denote the action of a group element on a
point of a set if the right operand is a group element.

\index{operators!precedence}
The *precedence* of those operators is as follows. The powering operator
`^' has the highest precedence, followed by the unary operators `+' and
`-', which are followed by the multiplicative operators `*', `/', and
`mod', and the additive binary operators `+' and `-' have the lowest
precedence.  That means that the expression `-2 ^ -2 * 3 + 1' is
interpreted as `(-(2 ^ (-2)) * 3) + 1'. If in doubt use parentheses
to clarify your intention.

\index{operators!associativity}
The *associativity* of the arithmetic operators is as follows.
`^' is not associative, i.e., it is illegal to write `2^3^4',
use parentheses to clarify whether you mean `(2^3)^4' or `2^(3^4)'.
The unary operators `+' and `-' are right associative,
because they are written to the left of their operands.
`*', `/', `mod', `+', and `-' are all left associative,
i.e., `1-2-3' is interpreted as `(1-2)-3' not as `1-(2-3)'.
Again, if in doubt use parentheses to clarify your intentions.

The arithmetic operators have higher precedence than the comparison
operators (see~"Comparisons" and~"Membership Test for Collections")
and the logical operators (see
"Operations for Booleans"). Thus, for example, `<a> * <b> = <c> and
<d>' is interpreted, `((<a> * <b>) = <c>) and <d>'.

\beginexample
gap> 2 * 2 + 9;  # a very simple arithmetic expression
13
\endexample

For other arithmetic operations, and for the underlying operations of
the operators introduced above, see~"Arithmetic Operations for Elements".

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Statements}

\index{execution}
Assignments (see "Assignments"), Procedure calls (see "Procedure Calls"),
`if' statements (see "If"), `while' (see "While"), `repeat'  (see
"Repeat") and `for' loops (see "For"), and the `return' statement (see
"Return") are called *statements*. They can be entered interactively or be
part of a function definition. Every statement must be terminated by a
semicolon.

Statements, unlike expressions, have no value. They are executed only to
produce an effect. For example an assignment has the effect of assigning
a  value to a variable, a `for' loop  has the effect of executing a
statement sequence for all elements in a list and so on. We will talk
about *evaluation* of expressions but about *execution* of statements to
emphasize this difference.

Using expressions as statements is treated as syntax error.

%notest
\beginexample
gap> i := 7;;
gap> if i <> 0 then k = 16/i; fi;
Syntax error: := expected
if i <> 0 then k = 16/i; fi;
                 ^
gap> 
\endexample

As you can see from the example this warning does in particular address
those users who are used to languages where `=' instead of `:=' denotes
assignment.

Empty statements are permitted and have no effect.

A sequence of one or more statements is a *statement sequence*, and may
occur everywhere instead of a single statement. There is nothing like
PASCAL's BEGIN-END, instead each construct is terminated by a keyword.
The simplest statement sequence is a single semicolon, which can be
used as an empty statement sequence. In fact an empty statement
sequence as in `for i in [1..2] do od' is also permitted and is
silently translated into the sequence containing just a semicolon.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Assignments}

\>`<var> := <expr>;'{assignment!variable}

The *assignment* has the effect of assigning the value of the expressions
<expr> to the variable <var>.

The variable <var> may be an ordinary variable (see "Variables"), a list
element selection `<list-var>[<int-expr>]' (see "List Assignment") or a
record component  selection  `<record-var>.<ident>'  (see  "Record
Assignment"). Since a list element or a record component may itself be a
list or a record the left hand side of an assignment may be arbitrarily
complex.

Note that variables do not have a type. Thus any value may be assigned
to any variable.  For example a variable with an integer value may be
assigned a permutation or a list or anything else.

\beginexample
gap> data:= rec( numbers:= [ 1, 2, 3 ] );
rec( numbers := [ 1, 2, 3 ] )
gap> data.string:= "string";; data;
rec( numbers := [ 1, 2, 3 ], string := "string" )
gap> data.numbers[2]:= 4;; data;
rec( numbers := [ 1, 4, 3 ], string := "string" )
\endexample

If the expression <expr> is a function call then this function must
return a value.  If the function does not return a value an error is
signalled and you enter a break loop (see "Break Loops").  As usual you
can leave the break  loop  with `quit;'.  If you enter  `return
<return-expr>;' the value of the expression <return-expr> is assigned to
the variable, and execution continues after the assignment.

%notest
\beginexample
gap> f1:= function( x ) Print( "value: ", x, "\n" ); end;;
gap> f2:= function( x ) return f1( x ); end;;
gap> f2( 4 );
value: 4
Function Calls: <func> must return a value at
return f1( x );
 called from
<function>( <arguments> ) called from read-eval-loop
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you can supply one by 'return <value>;' to continue
brk> return "hello";
"hello"
\endexample

In the above example, the function `f2' calls `f1' with argument `4',
and since `f1' does not return a value (but only prints a line ``{`value:
<x>'}''), the `return' statement of `f2'
cannot be executed.
The error message says that it is possible to return an appropriate value,
and the returned string `"hello"' is used by `f2' instead of the missing
return value of `f1'.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Procedure Calls}

\>`<procedure-var>();'{procedure call}
\>`<procedure-var>( <arg-expr> [,<arg-expr>, ...] );'{procedure call with arguments}

The *procedure call* has  the  effect  of calling  the procedure
<procedure-var>.  A procedure call is done exactly like a function call
(see "Function Calls"). The distinction between functions and procedures
is only for the sake of the discussion, {\GAP} does not distinguish
between them.
So we state the following conventions.

A *function* does return a value but does not produce a side effect. As
a convention the name of a function is a noun, denoting what the function
returns, e.g., `Length', `Concatenation' and `Order'.

A *procedure* is a function that does not return a value but produces
some  effect. Procedures are called  only for  this effect. As  a
convention the name of a procedure is a verb, denoting what the procedure
does, e.g., `Print', `Append' and `Sort'.

%notest
\beginexample
gap> Read( "myfile.g" );   # a call to the procedure Read
gap> l := [ 1, 2 ];;
gap> Append( l, [3,4,5] );  # a call to the procedure Append
\endexample

There are a few exceptions of {\GAP} functions that do both return
a value and produce some effect.
An example is `Sortex' which sorts a list and returns the corresponding
permutation of the entries (see~"Sortex").

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{If}

\indextt{fi}\indextt{then}\indextt{else}\indextt{elif}
\>`if <bool-expr1> then <statements1> \{ elif <bool-expr2> then <statements2> \}[ else <statements3> ] fi;'{if statement}@{`if' statement}

The `if' statement allows one to execute statements depending on the
value of some boolean expression. The execution is done as follows.

First the expression <bool-expr1> following the `if' is evaluated. If it
evaluates to `true' the statement sequence <statements1> after the first
`then' is executed, and the execution of the `if' statement is complete.

Otherwise the expressions <bool-expr2> following the `elif' are evaluated
in turn. There may be any number of `elif' parts, possibly none at all.
As soon as an expression evaluates to `true' the corresponding statement
sequence <statements2> is executed and execution of the `if' statement is
complete.

If the `if' expression and all, if any, `elif' expressions evaluate to
`false' and there is an `else' part, which is optional, its statement
sequence <statements3> is executed  and the  execution of  the `if'
statement is complete. If there is no `else' part the `if' statement is
complete without executing any statement sequence.

Since the `if' statement is terminated by the `fi' keyword there is no
question where an `else' part belongs,
i.e., {\GAP} has no ``dangling else''.
In

\){\kernttindent}if <expr1> then if <expr2> then <stats1> else <stats2> fi; fi;

the `else' part belongs to the second  `if' statement, whereas in

\){\kernttindent}if <expr1> then if <expr2> then <stats1> fi; else <stats2> fi;

the `else' part belongs to the first `if' statement.

Since an `if' statement is not an expression it is not possible to write

\begintt
abs := if x > 0 then x; else -x; fi;
\endtt

which would, even if legal syntax, be  meaningless, since the `if'
statement does not produce a value that could be assigned to `abs'.

If one of the expressions <bool-expr1>, <bool-expr2> is evaluated
and its value is neither `true' nor `false' an error is signalled
and a break loop (see "Break Loops") is entered. As usual you
can leave  the break loop with `quit;'.  If you enter `return true;',
execution of the `if' statement continues as if the expression whose
evaluation  failed had evaluated to `true'.   Likewise, if you enter
`return false;', execution of the `if' statement continues as if the
expression whose evaluation failed had evaluated to `false'.

\beginexample
gap> i := 10;;
gap> if 0 < i then
>    s := 1;
>  elif i < 0 then
>    s := -1;
>  else
>    s := 0;
>  fi;
gap> s;  # the sign of i
1
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{While}

\atindex{loop!while}{@loop!\noexpand`while'}

\>`while <bool-expr> do <statements> od;'{while loop}@{`while' loop}

The `while' loop executes the statement sequence <statements> while the
condition <bool-expr> evaluates to `true'.

First <bool-expr> is evaluated. If it evaluates to `false' execution of
the `while' loop terminates and the statement immediately following the
`while' loop is executed next. Otherwise if it evaluates to `true' the
<statements> are executed and the whole process begins again.

The difference between the `while'  loop and the `repeat until' loop
(see "Repeat") is that the <statements> in the `repeat until' loop are
executed at least once, while the <statements> in the `while' loop are
not executed at all if <bool-expr> is `false' at the first iteration.

If <bool-expr> does not evaluate to `true' or `false' an error is
signalled and a break loop (see "Break Loops") is entered. As usual you
can leave the break loop with `quit;'.  If you enter `return false;',
execution continues with the next statement immediately following the
`while' loop.  If you enter `return true;', execution continues at
<statements>, after which the next evaluation of <bool-expr> may cause
another error.

The following example shows a `while' loop that sums up the squares
$1^2, 2^2, \ldots$ until the sum exceeds 200.

\beginexample
gap> i := 0;; s := 0;;
gap> while s <= 200 do
>    i := i + 1; s := s + i^2;
>  od;
gap> s;
204
\endexample

A `while' loop may be left prematurely using `break', see "Break".

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Repeat}

\atindex{loop!repeat}{@loop!\noexpand`repeat'}\indextt{until}

\>`repeat <statements> until <bool-expr>;'{repeat loop}@{`repeat' loop}

The `repeat' loop executes the statement sequence <statements> until the
condition <bool-expr> evaluates to `true'.

First <statements> are executed.  Then <bool-expr> is evaluated. If it
evaluates  to `true' the `repeat'  loop terminates and the statement
immediately following the `repeat' loop is executed next. Otherwise if
it evaluates to `false' the whole process begins again with the execution
of the <statements>.

The difference between the `while' loop (see "While") and the `repeat
until' loop is that the <statements> in the `repeat until' loop are
executed at least once, while the <statements> in the `while' loop are
not executed at all if <bool-expr> is `false' at the first iteration.

If <bool-expr> does not evaluate to `true'  or `false' an error is
signalled and a break loop (see "Break Loops") is entered. As usual you
can leave the break loop with `quit;'.  If you enter `return true;',
execution continues with the next statement  immediately following the
`repeat' loop.  If you enter `return  false;', execution continues at
<statements>, after which the next evaluation of <bool-expr> may cause
another error.

The `repeat' loop in the following example has the same purpose as the
`while' loop in the preceding example, namely to sum up the squares
$1^2, 2^2, \ldots$ until the sum exceeds 200.

\beginexample
gap> i := 0;; s := 0;;
gap> repeat
>    i := i + 1; s := s + i^2;
>  until s > 200;
gap> s;
204
\endexample

A `repeat' loop may be left prematurely using `break', see "Break".


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{For}

\atindex{loop!for}{@loop!\noexpand`for'}\indextt{do}\indextt{od}

\>`for <simple-var> in <list-expr> do <statements> od;'{for loop}@{`for' loop}

The `for' loop executes  the statement sequence <statements> for every
element of the list <list-expr>.

The statement sequence <statements> is first executed with <simple-var>
bound to the first element of the list <list-expr>, then with <simple-var>
bound to the second element of <list-expr> and so on. <simple-var> must be a
simple variable,  it  must not   be  a list   element  selection
`<list-var>[<int-expr>]'   or    a  record  component selection
`<record-var>.<ident>'.

The execution of the `for' loop over a list is exactly equivalent to
the following `while' loop.

\)\kernttindent{<loop-list> := <list>;}
\)\kernttindent{<loop-index> := 1;}
\)\kernttindent{while <loop-index> \<= Length(<loop-list>) do}
\)\kernttindent{  <variable> := <loop-list>[<loop-index>];}
\)\kernttindent{  <statements>}
\)\kernttindent{  <loop-index> := <loop-index> + 1;}
\)\kernttindent{od;}

with the  exception  that <loop-list> and <loop-index> are different
variables for each `for' loop,
i.e., these variables of different `for' loops do not interfere with
each other.

The list <list-expr> is very often a range (see~"Ranges").

\>`for <variable> in [<from>..<to>] do <statements> od;'{loop over range}

corresponds to the more common

\)\kernttindent{for <variable> from <from> to <to> do <statements> od;}

in other programming languages.

\beginexample
gap> s := 0;;
gap> for i in [1..100] do
>    s := s + i;
> od;
gap> s;
5050
\endexample

Note in the following example how the modification of the *list* in the
loop body causes the loop body also to be executed for the new values.

\beginexample
gap> l := [ 1, 2, 3, 4, 5, 6 ];;
gap> for i in l do
>    Print( i, " " );
>    if i mod 2 = 0 then Add( l, 3 * i / 2 ); fi;
> od; Print( "\n" );
1 2 3 4 5 6 3 6 9 9 
gap> l;
[ 1, 2, 3, 4, 5, 6, 3, 6, 9, 9 ]
\endexample

Note in the following example that the modification of the *variable*
that holds the list has no influence on the loop.

\beginexample
gap> l := [ 1, 2, 3, 4, 5, 6 ];;
gap> for i in l do
>    Print( i, " " );
>    l := [];
> od; Print( "\n" );
1 2 3 4 5 6 
gap> l;
[  ]
\endexample

\>`for <variable> in <iterator> do <statements> od;'{loop over iterator}

It is also possible to have a `for'-loop run over an iterator
(see~"Iterators"). In this case
the `for'-loop is equivalent to

\)\kernttindent{while not IsDoneIterator(<iterator>) do}
\)\kernttindent{  <variable> := NextIterator(<iterator>)}
\)\kernttindent{  <statements>}
\)\kernttindent{od;}

\>`for <variable> in <object> do <statements> od;'{loop over object}

Finally, if an object <object> which is not a list or an iterator appears in a
`for'-loop, then {\GAP} will attempt to evaluate the function call
`Iterator(<object>)'. If this is successful then the loop is taken to
run over the iterator returned.

\beginexample
gap> g := Group((1,2,3,4,5),(1,2)(3,4)(5,6));
Group([ (1,2,3,4,5), (1,2)(3,4)(5,6) ])
gap> count := 0;; sumord := 0;;
gap> for x in g do
> count := count + 1; sumord := sumord + Order(x); od;
gap> count;
120
gap> sumord;
471
\endexample

The effect of

\){\kernttindent}for <variable> in <domain> do

should thus normally be the same as 

\){\kernttindent}for <variable> in AsList(<domain>) do

but may use much less storage, as the iterator may be more compact than
a list of all the elements.

See "Iterators" for details about iterators.

A `for' loop may be left prematurely using `break', see "Break". This
combines especially well with a loop over an iterator, as a way of
searching through a domain for an element with some useful property.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Break}

\index{loops!leaving}
\>`break;'{break statement}@{`break' statement}

The statement `break;' causes an immediate exit from the innermost
loop enclosing it. It is an error to use this statement other than
inside a loop.

\beginexample
gap> g := Group((1,2,3,4,5),(1,2)(3,4)(5,6));
Group([ (1,2,3,4,5), (1,2)(3,4)(5,6) ])
gap> for x in g do
> if Order(x) = 3 then
> break;
> fi; od;
gap> x;
(1,4,3)(2,6,5)
gap> break;
A break statement can only appear inside a loop
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Continue}\null

\index{loops!restarting}
\>`continue;'{continue statement}@{`continue' statement}

The statement `continue;' causes the rest of the current iteration of
the innermost loop enclosing it to be skipped. It is an error to use
this statement other than inside a loop.

\beginexample
gap> g := Group((1,2,3),(1,2));
Group([ (1,2,3), (1,2) ])
gap> for x in g do
> if Order(x) = 3 then
> continue;
> fi; Print(x,"\n"); od;
()
(2,3)
(1,3)
(1,2)
gap> continue;
A continue statement can only appear inside a loop
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Function}\nolabel

\index{functions!definition of}\indextt{end}\indextt{local}
\index{recursion}\index{functions!recursive}
\index{environment}\index{body}
\>function( [ <arg-ident> \{, <arg-ident>\} ] )
\){    [local  <loc-ident> \{, <loc-ident>\} ; ]}
\){    <statements>}
\){end}

A function is in fact a literal and not a statement. Such a function
literal can be assigned to a variable or to a list element or a record
component. Later this function can be called as described in "Function
Calls".

The following is an example of a function definition.  It is a function
to compute values of the Fibonacci sequence (see "Fibonacci").

\beginexample
gap> fib := function ( n )
>     local f1, f2, f3, i;
>     f1 := 1; f2 := 1;
>     for i in [3..n] do
>       f3 := f1 + f2;
>       f1 := f2;
>       f2 := f3;
>     od;
>     return f2;
>   end;;
gap> List( [1..10], fib );
[ 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 ]
\endexample

Because for each of the formal arguments <arg-ident> and for each of the
formal locals <loc-ident> a new variable is allocated when the function
is called (see "Function Calls"), it is possible that a function calls
itself. This is usually called *recursion*. The following is a recursive
function that computes values of the Fibonacci sequence

\beginexample
gap> fib := function ( n )
>     if n < 3 then
>       return 1;
>     else
>       return fib(n-1) + fib(n-2);
>     fi;
>   end;;
gap> List( [1..10], fib );
[ 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 ]
\endexample

Note that the recursive version needs `2 * fib(<n>)-1' steps to compute
`fib(<n>)', while the iterative version  of `fib' needs only `<n>-2'
steps.  Both are not optimal however, the library function `Fibonacci'
only needs about `Log(<n>)' steps.

\index{functions!with a variable number of arguments}
\indextt{arg!special function argument}
As noted in Section~"Function  Calls",  the  case  where  a  function  is
defined with exactly one formal argument with the name `arg', is special.
It provides a way of defining  a  function  with  a  variable  number  of
arguments; the values of all the actual arguments are stored  in  a  list
and this list is assigned to the new variable corresponding to the formal
argument `arg'. There are  two  typical  scenarios  for  wanting  such  a
possibility:  having  optional  arguments  and  having  any   number   of
arguments.

The  following  example  shows  one  way  that  the  function  `Position'
(see~"ref:Position") might be encoded  and  demonstrates  the  ``optional
argument'' scenario.

\beginexample
gap> position := function ( arg )    
>     local list, obj, pos;
>     list := arg[1];
>     obj  := arg[2];
>     if 2 = Length(arg) then
>       pos := 0;
>     else
>       pos := arg[3];
>     fi;
>     repeat
>       pos := pos + 1;
>       if pos > Length(list) then
>         return fail;
>       fi;
>     until list[pos] = obj;
>     return pos;
>    end;
function( arg ) ... end
gap> position([1, 4, 2], 4);
2
gap> position([1, 4, 2], 3);
fail
gap> position([1, 4, 2], 4, 2);
fail
\endexample

The following  example  demonstrates  the  ``any  number  of  arguments''
scenario.

\beginexample
gap> sum := function ( arg )
>     local total, x;
>     total := 0;
>     for x in arg do
>       total := total + x;
>     od;
>     return total;
>    end;
function( arg ) ... end
gap> sum(1, 2, 3);
6
gap> sum(1, 2, 3, 4);
10
gap> sum();
0
\endexample

The user  should  compare  the  above  with  the  {\GAP}  function  `Sum'
(see~"Sum") which, for example, may take a list argument  and  optionally
an initial element (which zero should the sum of an empty list return?).

Note that if a function <f> is defined as above with  the  single  formal
argument   `arg'   then   `NumberArgumentsFunction(<f>)'   returns   $-1$
(see~"NumberArgumentsFunction").

The argument `arg' when used as the single argument name of some function
<f> tells {\GAP} that when it encounters <f> that it should form  a  list
out of the arguments of <f>. What if one wishes to do  the  ``opposite'':
tell {\GAP} that a list should be ``unwrapped''  and  passed  as  several
arguments to a function. The function `CallFuncList' (see~"CallFuncList")
is provided for this purpose.

Also see Chapter~"Functions".

\index{functions!definition by arrow notation}
\>`<arg-ident> -> <expr>'{arrow notation for functions}

This is a shorthand for

\)\kernttindent{function ( <arg-ident> ) return <expr>; end.}

<arg-ident> must be a single identifier, i.e., it is not possible to
write functions of several arguments this way. Also `arg' is not treated
specially, so it is also impossible to write functions that take a
variable number of arguments this way.

The following is an example of a typical use of such a function

\beginexample
gap> Sum( List( [1..100], x -> x^2 ) );
338350
\endexample

When the definition of a function <fun1> is evaluated inside another
function <fun2>,
{\GAP} binds all the identifiers inside the function <fun1> that
are identifiers of an argument or a local of <fun2> to the corresponding
variable. This set of bindings is called the environment of the function
<fun1>. When <fun1> is called, its body is executed in this environment.
The following implementation of a simple stack uses this. Values can be
pushed onto the stack and then later be popped off again.  The
interesting thing here is that the functions `push' and `pop' in the
record returned by `Stack' access the local variable `stack' of `Stack'.
When `Stack' is called, a new variable for the identifier `stack' is
created.  When the function definitions of `push' and `pop' are then
evaluated (as part of the `return' statement) each reference to `stack'
is bound to this new variable. Note also that the two stacks `A' and `B'
do not interfere, because each call of `Stack' creates a new variable for
`stack'.

\beginexample
gap> Stack := function ()
>     local  stack;
>     stack := [];
>     return rec(
>       push := function ( value )
>         Add( stack, value );
>       end,
>       pop := function ()
>         local  value;
>         value := stack[Length(stack)];
>         Unbind( stack[Length(stack)] );
>         return value;
>       end
>     );
>  end;;
gap> A := Stack();;
gap> B := Stack();;
gap> A.push( 1 ); A.push( 2 ); A.push( 3 );
gap> B.push( 4 ); B.push( 5 ); B.push( 6 );
gap> A.pop(); A.pop(); A.pop();
3
2
1
gap> B.pop(); B.pop(); B.pop();
6
5
4
\endexample

This feature should be used rarely, since its implementation in {\GAP} is
not very efficient.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Return}

\>`return;'{return!no value}@{`return'!no value}

In this form `return' terminates the call of the innermost function that
is currently executing, and control returns to the calling function. An
error is signalled if no function is currently executing. No value is
returned by the function.

\>`return <expr>;'{return!with value}@{`return'!with value}

In this form `return' terminates the call of the innermost function that
is currently executing, and returns the value of the expression <expr>.
Control returns to the calling function. An error is signalled if no
function is currently executing.

Both statements can also be used in break loops (see "Break Loops").
`return;' has the effect that the computation continues where it was
interrupted by an error or the user hitting <ctr>-`C'.  `return <expr>;'
can be used to continue execution after an error. What happens with the
value <expr> depends on the particular error.

For examples of `return' statements, see the functions `fib' and `Stack'
in Chapter~"Functions".

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{The Syntax in BNF}

\atindex{BNF}{@BNF}

This section contains the definition of the {\GAP} syntax in
Backus-Naur form. A few recent additions to the syntax may be missing
from this definition. Also, the actual rules for identifier names
implemented by the system, are somewhat more permissive than those
given below (see section "Identifiers").

A  BNF is a set of rules, whose left side  is the name of  a  syntactical
construct.  Those  names  are enclosed in angle  brackets and  written in
<italics>.  The right side of each rule contains a possible form for that
syntactic  construct.   Each  right  side  may  contain  names  of  other
syntactic  constructs,  again  enclosed in angle brackets and written  in
<italics>,  or character  sequences that  must  occur literally; they are
written in `typewriter style'.

Furthermore  each righthand side  can contain  the  following metasymbols
written in *boldface*.  If the right  hand  side contains forms separated
by a pipe symbol  ($|$)  this means  that one  of the possible forms can
occur.  If a part of a form  is enclosed  in square brackets  ([ ])  this
means that this part is optional, i.e.  might be present or  missing.  If
part  of the form is enclosed  in curly braces  (`\{  \}')  this means that
the part may occur arbitrarily often, or possibly be missing.

%display{tex}
\vfill\eject% new page
\vbox{\settabs
\+<Permutation> &:= &`(' <Expr> $\{$`,' <Expr> $\}$ `)'
                $\{$ `(' <Expr> $\{$`,' <Expr> $\}$ `)' $\}$\cr
\+<Ident>       &:=  &`a'$|$...$|$`z'$|$`A'$|$...$|$`Z'$|$`_'
$\{$`a'$|$...$|$`z'$|$`A'$|$...$|$`Z'$|$`0'$|$...$|$`9'$|$`_'$\}$\cr
\+<Var>         &:=  &<Ident>\cr
\+              &$|$ &<Var> `.' <Ident>\cr
\+              &$|$ &<Var> `.' `(' <Expr> `)'\cr
\+              &$|$ &<Var> `[' <Expr> `]'\cr
\+              &$|$ &<Var> `$\{$ <Expr> $\}$'\cr
\+              &$|$ &<Var> `(' [ <Expr> $\{$ ,<Expr> $\}$ ] `)'\cr
\+              &$|$ &<Var> `!.' <Ident>\cr
\+              &$|$ &<Var> `!.' `(' <Expr> `)'\cr
\+              &$|$ &<Var> `![' <Expr> `]'\cr
\+<List>        &:=  &`[' [ <Expr> ] $\{$`,' [ <Expr> ] $\}$ `]'\cr
\+              &$|$ &`[' <Expr> [, <Expr> ] `..' <Expr> `]'\cr
\+              &$|$ &<List> `{' <List> `}'\cr
\+<Record>      &:=  &`rec(' [ <Ident> `:=' <Expr>
                         $\{$`,' <Ident> `:=' <Expr> $\}$ ] `)'\cr
\+<Permutation> &:=  &`(' <Expr> $\{$`,' <Expr> $\}$ `)'
                    $\{$ `(' <Expr> $\{$`,' <Expr> $\}$ `)' $\}$\cr
\+<Function>    &:=  &`function (' [ <Ident> $\{$`,' <Ident> $\}$ ] `)'\cr
\+              &    &    [ `local'  <Ident> $\{$`,' <Ident> $\}$ `;' ]\cr
\+              &    &    <Statements>\cr
\+              &    &`end'\cr
\+              &$|$ & <Ident> `->' <Expr>\cr
\+<Char>        &:=  &\pif <any character> \pif\cr
\+<String>      &:=  &`"' $\{$ <any character> $\}$ `"'\cr
\+<Int>         &:=  &`0'$|$`1'$|$...$|$`9'
                    $\{$`0'$|$`1'$|$...$|$`9'$\}$\cr
\+<Atom>        &:=  &<Int>\cr
\+              &$|$ &<Var>\cr
\+              &$|$ &`(' <Expr> `)'\cr
\+              &$|$ &<Permutation>\cr
\+              &$|$ &<Char>\cr
\+              &$|$ &<String>\cr
\+              &$|$ &<Function>\cr
\+              &$|$ &<List>\cr
\+              &$|$ &<Record>\cr
\+              &$|$ &$\{$ `not' $\}$ `true'\cr
\+              &$|$ &$\{$ `not' $\}$ `false'\cr
\+<Factor>      &:=  &$\{$`+'$|$`-'$\}$ <Atom>
                [ `^' $\{$`+'$|$`-'$\}$ <Atom> ]\cr
\+<Term>        &:=  &<Factor> $\{$ `*'$|$`/'$|$`mod' <Factor> $\}$\cr
\+<Arith>       &:=  &<Term> $\{$ `+'$|$`-' <Term> $\}$\cr
\+<Rel>         &:=  &$\{$ `not' $\}$ <Arith>
                [ `='$|$`\<>'$|$`\<'$|$`>'$|$`\<='$|$`>='$|$`in' <Arith> ]\cr
\+<And>         &:=  &<Rel> $\{$ `and' <Rel> $\}$\cr
\+<Logical>     &:=  &<And> $\{$ `or' <And> $\}$\cr
\+<Expr>        &:=  &<Logical>\cr
\+              &$|$ &<Var>\cr
\+<Statement>   &:=  &<Expr>\cr
\+              &$|$ &<Var> `:=' <Expr>\cr
\+              &$|$ &`if'   <Expr>  `then' <Statements>\cr
\+              &    &$\{$ `elif' <Expr>  `then' &<Statements> $\}$\cr
\+              &    &[ `else'&<Statements>  ] `fi'\cr
\+              &$|$ &`for' <Var> `in' <Expr> `do' <Statements> `od'\cr
\+              &$|$ &`while' <Expr>  `do' <Statements>  `od'\cr
\+              &$|$ &`repeat' <Statements>  `until' <Expr>\cr
\+              &$|$ &`return' [ <Expr> ]\cr
\+              &$|$ &`break'\cr
\+              &$|$ &`quit'\cr
\+              &$|$ &`QUIT'\cr
\+              &$|$ &\cr
\+<Statements>  &:=  &$\{$ <Statement> `;' $\}$\cr
\+              &$|$ &`;'\cr
\+              &$|$ &\cr
}
%display{html}
%<table><tr><td width=80>
%&lt;Permutation&#62; </td><td width=11>
%:= </td><td width=350>
%`(' &lt;Expr&#62; {`,' &lt;Expr&#62; } `)'
%                { `(' &lt;Expr&#62; {`,' &lt;Expr&#62; } `)' }</td></table>
%
%<table><tr><td width=80>
%&lt;Ident&#62;       </td><td width=11>
%:=  </td><td width=350>
%`a'<font face=symbol>|</font
%>...<font face=symbol>|</font
%>`z'<font face=symbol>|</font
%>`A'<font face=symbol>|</font
%>...<font face=symbol>|</font
%>`Z'<font face=symbol>|</font
%>`_'
%{`a'<font face=symbol>|</font
%>...<font face=symbol>|</font
%>`z'<font face=symbol>|</font
%>`A'<font face=symbol>|</font
%>...<font face=symbol>|</font
%>`Z'<font face=symbol>|</font
%>`0'<font face=symbol>|</font
%>...<font face=symbol>|</font
%>`9'<font face=symbol>|</font
%>`_'}</td></table>
%
%<table><tr><td width=80>
%&lt;Var&#62;         </td><td width=11>
%:=  </td><td width=350>
%&lt;Ident&#62;</td></table>
%
%<table><tr><td width=80>
%              </td><td width=11>
%<font face=symbol>|</font
%> </td><td width=350>
%&lt;Var&#62; `.' &lt;Ident&#62;</td></table>
%
%<table><tr><td width=80>
%              </td><td width=11>
%<font face=symbol>|</font
%> </td><td width=350>
%&lt;Var&#62; `.' `(' &lt;Expr&#62; `)'</td></table>
%
%<table><tr><td width=80>
%              </td><td width=11>
%<font face=symbol>|</font
%> </td><td width=350>
%&lt;Var&#62; `[' &lt;Expr&#62; `]'</td></table>
%
%<table><tr><td width=80>
%              </td><td width=11>
%<font face=symbol>|</font
%> </td><td width=350>
%&lt;Var&#62; `{ &lt;Expr&#62; }'</td></table>
%
%<table><tr><td width=80>
%              </td><td width=11>
%<font face=symbol>|</font
%> </td><td width=350>
%&lt;Var&#62; `(' [ &lt;Expr&#62; { ,&lt;Expr&#62; } ] `)'</td></table>
%
%<table><tr><td width=80>
%              </td><td width=11>
%<font face=symbol>|</font
%> </td><td width=350>
%&lt;Var&#62; `!.' &lt;Ident&#62;</td></table>
%
%<table><tr><td width=80>
%              </td><td width=11>
%<font face=symbol>|</font
%> </td><td width=350>
%&lt;Var&#62; `!.' `(' &lt;Expr&#62; `)'</td></table>
%
%<table><tr><td width=80>
%              </td><td width=11>
%<font face=symbol>|</font
%> </td><td width=350>
%&lt;Var&#62; `![' &lt;Expr&#62; `]'</td></table>
%
%<table><tr><td width=80>
%&lt;List&#62;        </td><td width=11>
%:=  </td><td width=350>
%`[' [ &lt;Expr&#62; ] {`,' [ &lt;Expr&#62; ] } `]'</td></table>
%
%<table><tr><td width=80>
%              </td><td width=11>
%<font face=symbol>|</font
%> </td><td width=350>
%`[' &lt;Expr&#62; [, &lt;Expr&#62; ] `..' &lt;Expr&#62; `]'</td></table>
%
%<table><tr><td width=80>
%              </td><td width=11>
%<font face=symbol>|</font
%> </td><td width=350>
%&lt;List&#62; `' &lt;List&#62; `'</td></table>
%
%<table><tr><td width=80>
%&lt;Record&#62;      </td><td width=11>
%:=  </td><td width=350>
%`rec(' [ &lt;Ident&#62; `:=' &lt;Expr&#62;
%                         {`,' &lt;Ident&#62; `:=' &lt;Expr&#62; } ] `)'</td></table>
%
%<table><tr><td width=80>
%&lt;Permutation&#62; </td><td width=11>
%:=  </td><td width=350>
%`(' &lt;Expr&#62; {`,' &lt;Expr&#62; } `)'
%                    { `(' &lt;Expr&#62; {`,' &lt;Expr&#62; } `)' }</td></table>
%
%<table><tr><td width=80>
%&lt;Function&#62;    </td><td width=11>
%:=  </td><td width=350>
%`function (' [ &lt;Ident&#62; {`,' &lt;Ident&#62; } ] `)'</td></table>
%
%<table><tr><td width=80>
%              </td><td width=11>
%    </td><td width=350>
%    [ `local'  &lt;Ident&#62; {`,' &lt;Ident&#62; } `;' ]</td></table>
%
%<table><tr><td width=80>
%              </td><td width=11>
%    </td><td width=350>
%    &lt;Statements&#62;</td></table>
%
%<table><tr><td width=80>
%              </td><td width=11>
%    </td><td width=350>
%`end'</td></table>
%
%<table><tr><td width=80>
%              </td><td width=11>
%<font face=symbol>|</font
%> </td><td width=350>
% &lt;Ident&#62; `-&#62;' &lt;Expr&#62;</td></table>
%
%<table><tr><td width=80>
%&lt;Char&#62;        </td><td width=11>
%:=  </td><td width=350>
%'&lt;any character&#62; '</td></table>
%
%<table><tr><td width=80>
%&lt;String&#62;      </td><td width=11>
%:=  </td><td width=350>
%`"' { &lt;any character&#62; } `"'</td></table>
%
%<table><tr><td width=80>
%&lt;Int&#62;         </td><td width=11>
%:=  </td><td width=350>
%`0'<font face=symbol>|</font
%>`1'<font face=symbol>|</font
%>...<font face=symbol>|</font
%>`9'
%                    {`0'<font face=symbol>|</font
%>`1'<font face=symbol>|</font
%>...<font face=symbol>|</font
%>`9'}</td></table>
%
%<table><tr><td width=80>
%&lt;Atom&#62;        </td><td width=11>
%:=  </td><td width=350>
%&lt;Int&#62;</td></table>
%
%<table><tr><td width=80>
%              </td><td width=11>
%<font face=symbol>|</font
%> </td><td width=350>
%&lt;Var&#62;</td></table>
%
%<table><tr><td width=80>
%              </td><td width=11>
%<font face=symbol>|</font
%> </td><td width=350>
%`(' &lt;Expr&#62; `)'</td></table>
%
%<table><tr><td width=80>
%              </td><td width=11>
%<font face=symbol>|</font
%> </td><td width=350>
%&lt;Permutation&#62;</td></table>
%
%<table><tr><td width=80>
%              </td><td width=11>
%<font face=symbol>|</font
%> </td><td width=350>
%&lt;Char&#62;</td></table>
%
%<table><tr><td width=80>
%              </td><td width=11>
%<font face=symbol>|</font
%> </td><td width=350>
%&lt;String&#62;</td></table>
%
%<table><tr><td width=80>
%              </td><td width=11>
%<font face=symbol>|</font
%> </td><td width=350>
%&lt;Function&#62;</td></table>
%
%<table><tr><td width=80>
%              </td><td width=11>
%<font face=symbol>|</font
%> </td><td width=350>
%&lt;List&#62;</td></table>
%
%<table><tr><td width=80>
%              </td><td width=11>
%<font face=symbol>|</font
%> </td><td width=350>
%&lt;Record&#62;</td></table>
%
%<table><tr><td width=80>
%              </td><td width=11>
%<font face=symbol>|</font
%> </td><td width=350>
%{ `not' } `true'</td></table>
%
%<table><tr><td width=80>
%              </td><td width=11>
%<font face=symbol>|</font
%> </td><td width=350>
%{ `not' } `false'</td></table>
%
%<table><tr><td width=80>
%&lt;Factor&#62;      </td><td width=11>
%:=  </td><td width=350>
%{`+'<font face=symbol>|</font
%>`-'} &lt;Atom&#62;
%                [ `^' {`+'<font face=symbol>|</font
%>`-'} &lt;Atom&#62; ]</td></table>
%
%<table><tr><td width=80>
%&lt;Term&#62;        </td><td width=11>
%:=  </td><td width=350>
%&lt;Factor&#62; { `*'<font face=symbol>|</font
%>`/'<font face=symbol>|</font
%>`mod' &lt;Factor&#62; }</td></table>
%
%<table><tr><td width=80>
%&lt;Arith&#62;       </td><td width=11>
%:=  </td><td width=350>
%&lt;Term&#62; { `+'<font face=symbol>|</font
%>`-' &lt;Term&#62; }</td></table>
%
%<table><tr><td width=80>
%&lt;Rel&#62;         </td><td width=11>
%:=  </td><td width=350>
%{ `not' } &lt;Arith&#62;
%                [ `='<font face=symbol>|</font
%>`\&lt;&#62;'<font face=symbol>|</font
%>`\&lt;'<font face=symbol>|</font
%>`&#62;'<font face=symbol>|</font
%>`\&lt;='<font face=symbol>|</font
%>`&#62;='<font face=symbol>|</font
%>`in' &lt;Arith&#62; ]</td></table>
%
%<table><tr><td width=80>
%&lt;And&#62;         </td><td width=11>
%:=  </td><td width=350>
%&lt;Rel&#62; { `and' &lt;Rel&#62; }</td></table>
%
%<table><tr><td width=80>
%&lt;Logical&#62;     </td><td width=11>
%:=  </td><td width=350>
%&lt;And&#62; { `or' &lt;And&#62; }</td></table>
%
%<table><tr><td width=80>
%&lt;Expr&#62;        </td><td width=11>
%:=  </td><td width=350>
%&lt;Logical&#62;</td></table>
%
%<table><tr><td width=80>
%              </td><td width=11>
%<font face=symbol>|</font
%> </td><td width=350>
%&lt;Var&#62;</td></table>
%
%<table><tr><td width=80>
%&lt;Statement&#62;   </td><td width=11>
%:=  </td><td width=350>
%&lt;Expr&#62;</td></table>
%
%<table><tr><td width=80>
%              </td><td width=11>
%<font face=symbol>|</font
%> </td><td width=350>
%&lt;Var&#62; `:=' &lt;Expr&#62;</td></table>
%
%<table><tr><td width=80>
%              </td><td width=11>
%<font face=symbol>|</font
%> </td><td width=350>
%`if'   &lt;Expr&#62;  `then' &lt;Statements&#62;</td></table>
%
%<table><tr><td width=80>
%              </td><td width=11>
%    </td><td width=150>
%{ `elif' &lt;Expr&#62;  `then' </td><td width=350>
%&lt;Statements&#62; }</td></table>
%
%<table><tr><td width=80>
%              </td><td width=11>
%    </td><td width=150>
%[ `else'</td><td width=350>
%&lt;Statements&#62;  ] `fi'</td></table>
%
%<table><tr><td width=80>
%              </td><td width=11>
%<font face=symbol>|</font
%> </td><td width=350>
%`for' &lt;Var&#62; `in' &lt;Expr&#62; `do' &lt;Statements&#62; `od'</td></table>
%
%<table><tr><td width=80>
%              </td><td width=11>
%<font face=symbol>|</font
%> </td><td width=350>
%`while' &lt;Expr&#62;  `do' &lt;Statements&#62;  `od'</td></table>
%
%<table><tr><td width=80>
%              </td><td width=11>
%<font face=symbol>|</font
%> </td><td width=350>
%`repeat' &lt;Statements&#62;  `until' &lt;Expr&#62;</td></table>
%
%<table><tr><td width=80>
%              </td><td width=11>
%<font face=symbol>|</font
%> </td><td width=350>
%`return' [ &lt;Expr&#62; ]</td></table>
%
%<table><tr><td width=80>
%              </td><td width=11>
%<font face=symbol>|</font
%> </td><td width=350>
%`break'</td></table>
%
%<table><tr><td width=80>
%              </td><td width=11>
%<font face=symbol>|</font
%> </td><td width=350>
%`quit'</td></table>
%
%<table><tr><td width=80>
%              </td><td width=11>
%<font face=symbol>|</font
%> </td><td width=350>
%`QUIT'</td></table>
%
%<table><tr><td width=80>
%              </td><td width=11>
%<font face=symbol>|</font
%> </td><td width=350>
%</td></table>
%
%<table><tr><td width=80>
%&lt;Statements&#62;  </td><td width=11>
%:=  </td><td width=350>
%{ &lt;Statement&#62; `;' }</td></table>
%
%<table><tr><td width=80>
%              </td><td width=11>
%<font face=symbol>|</font
%> </td><td width=350>
%`;'</td></table>
%
%<table><tr><td width=80>
%              </td><td width=11>
%<font face=symbol>|</font
%> </td><td width=350>
%</td></table>
%display{text}
%Not yet available
%enddisplay

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                                                       
%E
