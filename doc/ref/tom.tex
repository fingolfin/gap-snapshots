% This file was created automatically from tom.msk.
% DO NOT EDIT!
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%W  tom.msk                     GAP documentation              Goetz Pfeiffer
%W                                                            Thomas Merkwitz
%%
%H  @(#)$Id: tom.msk,v 1.23.2.2 2005/05/09 07:09:59 gap Exp $
%%
%Y  (C) 1999 School Math and Comp. Sci., University of St.  Andrews, Scotland
%Y  Copyright (C) 2002 The GAP Group
%%
%%  This file describes the functions dealing with tables of marks.
%%  The corresponding {\GAP} code is contained in the files `lib/tom.g[di]'
%%  and `pkg/tomlib/gap/tmadmin.tm[di]'.
%%
\Chapter{Tables of Marks}

The concept of a *table of marks* was introduced by W.~Burnside in his
book ``Theory of Groups of Finite  Order'', see~\cite{Bur55}.
Therefore a table of marks is sometimes called a *Burnside matrix*.

The table of marks of a finite group $G$ is a matrix whose rows and
columns are labelled by the conjugacy classes of subgroups of $G$
and where for two subgroups $A$ and $B$ the $(A, B)$--entry is
the number of fixed points of $B$ in the transitive action of $G$
on the cosets of $A$ in $G$.
So the table of marks characterizes the set of all permutation
representations of $G$.

Moreover, the table of marks gives a compact description of the subgroup
lattice of $G$, since from the numbers of fixed points the numbers of
conjugates of a subgroup $B$ contained in a subgroup $A$ can be derived.

A table of marks of a given group $G$ can be constructed from the
subgroup lattice of $G$ (see~"Constructing Tables of Marks").
For several groups, the table of marks can be restored from the {\GAP}
library of tables of marks (see~"The Library of Tables of Marks").

Given the table of marks of $G$, one can display it
(see~"Printing Tables of Marks")
and derive information about $G$ and its Burnside ring from it
(see~"Attributes of Tables of Marks", "Properties of Tables of Marks",
"Other Operations for Tables of Marks").
Moreover, tables of marks in {\GAP} provide an easy access to the classes
of subgroups of their underlying groups
(see~"Accessing Subgroups via Tables of Marks").



%%  The code for tables of marks has been designed and implemented by G{\"o}tz
%%  Pfeiffer and Thomas Merkwitz.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{More about Tables of Marks}

Let $G$ be a finite group with $n$ conjugacy classes of subgroups
$C_1, C_2, \ldots, C_n$ and representatives $H_i \in  C_i$,
$1 \leq i \leq n$.
The *table of marks* of $G$ is defined to be the $n \times n$ matrix
$M = (m_{ij})$ where the *mark* $m_{ij}$ is the number of fixed points
of the subgroup $H_j$ in the action of $G$ on the right cosets of $H_i$
in $G$.

Since $H_j$ can only have fixed points if it is contained in a point
stablizer the matrix $M$ is lower triangular if the classes $C_i$ are
sorted according to the condition that if $H_i$ is contained in a
conjugate of $H_j$ then $i \leq j$.

Moreover, the diagonal entries $m_{ii}$ are nonzero since $m_{ii}$ equals
the index of $H_i$ in its normalizer in $G$.  Hence $M$ is invertible.
Since any transitive action of $G$ is equivalent to an action on the
cosets of a subgroup of $G$, one sees that the table of marks completely
characterizes the set of all permutation representations of $G$.

The marks $m_{ij}$ have further meanings.
If $H_1$ is the trivial subgroup of $G$ then each mark $m_{i1}$ in the
first column of $M$ is equal to the index of $H_i$ in $G$
since the trivial subgroup fixes all cosets of $H_i$.
If $H_n = G$ then each $m_{nj}$ in the last row of $M$ is equal to $1$
since there is only one coset of $G$ in $G$.
In general, $m_{ij}$ equals the number of conjugates of $H_i$ containing
$H_j$, multiplied by the index of $H_i$ in its normalizer in $G$.
Moreover, the number $c_{ij}$ of conjugates of $H_j$ which are contained
in $H_i$ can be derived from the marks $m_{ij}$ via the formula
$$
c_{ij} = \frac{m_{ij} m_{j1}}{m_{i1} m_{jj}}\.
$$

Both the marks $m_{ij}$  and the numbers of subgroups $c_{ij}$ are needed
for the functions described in this chapter.

A brief survey of properties of tables of marks and a description of
algorithms for the interactive construction of tables of marks using
{\GAP} can be found in~\cite{Pfe97}.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Table of Marks Objects in GAP}

A table of marks of a group $G$ in {\GAP} is represented by an immutable
(see~"Mutability and Copyability") object <tom> in the category
`IsTableOfMarks' (see~"IsTableOfMarks"), with defining attributes
`SubsTom' (see~"SubsTom") and `MarksTom' (see~"MarksTom").
These two attributes encode the matrix of marks in a compressed form.
The `SubsTom' value of <tom> is a list where for each conjugacy class of
subgroups the class numbers of its subgroups are stored.
These are exactly the positions in the corresponding row of the matrix of
marks which have nonzero entries.
The marks themselves are stored via the `MarksTom' value of <tom>,
which is a list that contains for each entry in `SubsTom( <tom> )' the
corresponding nonzero value of the table of marks.

It is possible to create table of marks objects that do not store a
group, moreover one can create a table of marks object from a matrix of
marks (see~"TableOfMarks").
So it may happen that a table of marks object in {\GAP} is in fact *not*
the table of marks of a group.
To some extent, the consistency of a table of marks object can be checked
(see~"Other Operations for Tables of Marks"),
but {\GAP} knows no general way to prove or disprove that a given matrix
of nonnegative  integers is the matrix of marks for a group.
Many functions for tables of marks work well without access to the group
--this is one of the arguments why tables of marks are so useful--,
but for example normalizers (see~"NormalizerTom")
and derived subgroups (see~"DerivedSubgroupTom") of subgroups
are in general not uniquely determined by the matrix of marks.

{\GAP} tables of marks are assumed to be in lower triangular form,
that is, if a subgroup from the conjugacy class corresponding to the
$i$-th row is contained in a subgroup from the class corresponding to the
$j$-th row j then $i \leq j$.

The `MarksTom' information can be computed from the values of the
attributes `NrSubsTom', `LengthsTom', `OrdersTom', and `SubsTom'
(see~"NrSubsTom", "LengthsTom", "OrdersTom").
`NrSubsTom' stores a list containing for each entry in the `SubsTom'
value the corresponding number of conjugates that are contained
in a subgroup, `LengthsTom' a list containing for each conjugacy class
of subgroups its length, and `OrdersTom' a list containing for each
class of subgroups their order.
So the `MarksTom' value of <tom> may be missing provided that the values
of `NrSubsTom', `LengthsTom', and `OrdersTom' are stored in <tom>.

Additional information about a table of marks is needed by some
functions.
The class numbers of normalizers in $G$ and the number of the derived
subgroup of $G$ can be stored via appropriate attributes
(see~"NormalizersTom", "DerivedSubgroupTom").

If <tom> stores its group $G$ and a bijection from the rows and columns
of the matrix of marks of <tom> to the classes of subgroups of $G$ then
clearly normalizers, derived subgroup etc.~can be computed from this
information.
But in general a table of marks need not have access to $G$,
for example <tom> might have been constructed from a generic table of
marks (see~"Generic Construction of Tables of Marks"),
or as table of marks of a factor group from a given table of marks
(see~"FactorGroupTom").
Access to the group $G$ is provided by the attribute `UnderlyingGroup'
(see~"UnderlyingGroup!for tables of marks") if this value is set.
Access to the relevant information about conjugacy classes of subgroups
of $G$ --compatible with the ordering of rows and columns of the marks in
<tom>-- is signalled by the filter `IsTableOfMarksWithGens'
(see~"Accessing Subgroups via Tables of Marks").


Several examples in this chapter require
the {\GAP} Library of Tables of Marks to be available.
If it is not yet loaded then we load it now.

\beginexample
gap> LoadPackage( "tomlib" );
true
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Constructing Tables of Marks}

\>TableOfMarks( <G> ) A
\>TableOfMarks( <string> ) A
\>TableOfMarks( <matrix> ) A

In the first form, <G> must be a finite group, and `TableOfMarks'
constructs the table of marks of <G>.
This computation requires the knowledge of the complete subgroup lattice
of <G> (see~"LatticeSubgroups").
If the lattice is not yet stored then it will be constructed.
This may take a while if <G> is large.
The result has the `IsTableOfMarksWithGens' value `true'
(see~"Accessing Subgroups via Tables of Marks").

In the second form, <string> must be a string, and `TableOfMarks' gets
the table of marks with name <string> from the {\GAP} library
(see "The Library of Tables of Marks").
If no table of marks with this name is contained in the library then
`fail' is returned.

In the third form, <matrix> must be a matrix or a list of rows describing
a lower triangular matrix where the part above the diagonal is omitted.
For such an argument <matrix>, `TableOfMarks' returns
a table of marks object (see~"Table of Marks Objects in GAP")
for which <matrix> is the matrix of marks.
Note that not every matrix
(containing only nonnegative integers and having lower triangular shape)
describes a table of marks of a group.
Necessary conditions are checked with `IsInternallyConsistent'
(see~"Other Operations for Tables of Marks"), and `fail' is returned if
<matrix> is proved not to describe a matrix of marks;
but if `TableOfMarks' returns a table of marks object created from a
matrix then it may still happen that this object does not describe the
table of marks of a group.

For an overview of operations for table of marks objects,
see the introduction to the Chapter~"Tables of Marks".


\beginexample
gap> tom:= TableOfMarks( AlternatingGroup( 5 ) );
TableOfMarks( Alt( [ 1 .. 5 ] ) )
gap> TableOfMarks( "J5" );
fail
gap> a5:= TableOfMarks( "A5" );
TableOfMarks( "A5" )
gap> mat:=
> [ [ 60, 0, 0, 0, 0, 0, 0, 0, 0 ], [ 30, 2, 0, 0, 0, 0, 0, 0, 0 ], 
>   [ 20, 0, 2, 0, 0, 0, 0, 0, 0 ], [ 15, 3, 0, 3, 0, 0, 0, 0, 0 ], 
>   [ 12, 0, 0, 0, 2, 0, 0, 0, 0 ], [ 10, 2, 1, 0, 0, 1, 0, 0, 0 ], 
>   [ 6, 2, 0, 0, 1, 0, 1, 0, 0 ], [ 5, 1, 2, 1, 0, 0, 0, 1, 0 ], 
>   [ 1, 1, 1, 1, 1, 1, 1, 1, 1 ] ];;
gap> TableOfMarks( mat );
TableOfMarks( <9 classes> )
\endexample

The following `TableOfMarks' methods for a group are installed.
\beginlist%unordered
\item{--}
    If the group is known to be cyclic then `TableOfMarks' constructs the
    table of marks essentially without the group, instead the knowledge
    about the structure of cyclic groups is used.
\item{--}
    If the lattice of subgroups is already stored in the group then
    `TableOfMarks' computes the table of marks from the lattice
    (see~"TableOfMarksByLattice").
\item{--}
    If the group is known to be solvable then `TableOfMarks' takes the
    lattice of subgroups (see~"LatticeSubgroups") of the group
    --which means that the lattice is computed if it is not yet stored--
    and then computes the table of marks from it.
    This method is also accessible via the global function
    `TableOfMarksByLattice' (see~"TableOfMarksByLattice").
\item{--}
    If the group doesn't know its lattice of subgroups or its conjugacy
    classes of subgroups then the table of marks and the conjugacy
    classes of subgroups are computed at the same time by the cyclic
    extension method.
    Only the table of marks is stored because the conjugacy classes of
    subgroups or the lattice of subgroups can be easily read off
    (see~"LatticeSubgroupsByTom").
\endlist

Conversely, the lattice of subgroups of a group with known table of marks
can be computed using the table of marks, via the function
`LatticeSubgroupsByTom'.
This is also installed as a method for `LatticeSubgroups'.



\>TableOfMarksByLattice( <G> ) F

`TableOfMarksByLattice' computes the table of marks of the group <G> from
the lattice of subgroups of <G>.
This lattice is computed via `LatticeSubgroups' (see~"LatticeSubgroups")
if it is not yet stored in <G>.
The function `TableOfMarksByLattice' is installed as a method for
`TableOfMarks' for solvable groups and groups with stored subgroup
lattice, and is available as a global variable only in order to provide
explicit access to this method.


\>LatticeSubgroupsByTom( <G> ) F

`LatticeSubgroupsByTom' computes the lattice of subgroups of <G> from the
table of marks of <G>, using `RepresentativeTom'
(see~"RepresentativeTom").




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Printing Tables of Marks}

\indextt{ViewObj!for tables of marks}
The default `ViewObj' (see~"ViewObj") method for tables of  marks  prints
the string `\"TableOfMarks\"', followed by --if  known--  the  identifier
(see~"Identifier!for tables of marks") or the group of the table of marks
enclosed in brackets; if neither group nor identifier are known then just
the number of conjugacy classes of subgroups is printed instead.

\indextt{PrintObj!for tables of marks}
The default `PrintObj' (see~"PrintObj") method for tables of marks
does the same as `ViewObj',
except that the group is is `Print'-ed instead of `View'-ed.

\indextt{Display!for tables of marks}
The default `Display' (see~"Display") method for a table of marks <tom>
produces a formatted output of the marks in <tom>.
Each line of output begins with the number of the corresponding class of
subgroups.
This number is repeated if the output spreads over several pages.
The number of columns printed at one time depends on the actual
line length, which can be accessed and changed by the function
`SizeScreen' (see~"SizeScreen").

The optional second argument <arec> of `Display' can be used to change
the default style for displaying a character as shown above.
<arec> must be a record, its relevant components are the following.

\beginitems
`classes' &
    a list of class numbers to select only the rows and columns of the
    matrix that correspond to this list for printing,

`form' &
    one of the strings `\"subgroups\"', `\"supergroups\"';
    in the former case, at position $(i,j)$ of the matrix the number of
    conjugates of $H_j$ contained in $H_i$ is printed,
    and in the latter case, at position $(i,j)$ the number of conjugates
    of $H_i$ which contain $H_j$ is printed.
\enditems



\beginexample
gap> tom:= TableOfMarks( "A5" );;
gap> Display( tom );
1:  60
2:  30 2
3:  20 . 2
4:  15 3 . 3
5:  12 . . . 2
6:  10 2 1 . . 1
7:   6 2 . . 1 . 1
8:   5 1 2 1 . . . 1
9:   1 1 1 1 1 1 1 1 1

gap> Display( tom, rec( classes:= [ 1, 2, 3, 4, 8 ] ) );
1:  60
2:  30 2
3:  20 . 2
4:  15 3 . 3
8:   5 1 2 1 1

gap> Display( tom, rec( form:= "subgroups" ) );
1:  1
2:  1  1
3:  1  .  1
4:  1  3  . 1
5:  1  .  . . 1
6:  1  3  1 . .  1
7:  1  5  . . 1  . 1
8:  1  3  4 1 .  . . 1
9:  1 15 10 5 6 10 6 5 1

gap> Display( tom, rec( form:= "supergroups" ) );
1:   1
2:  15 1
3:  10 . 1
4:   5 1 . 1
5:   6 . . . 1
6:  10 2 1 . . 1
7:   6 2 . . 1 . 1
8:   5 1 2 1 . . . 1
9:   1 1 1 1 1 1 1 1 1

\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Sorting Tables of Marks}

\>SortedTom( <tom>, <perm> ) O

`SortedTom' returns a table of marks where the rows and columns of the
table of marks <tom> are reordered according to the permutation <perm>.

*Note* that in each table of marks in {\GAP},
the matrix of marks is assumed to have lower triangular shape
(see~"Table of Marks Objects in GAP").
If the permutation <perm> does *not* have this property then the
functions for tables of marks might return wrong results when applied to
the output of `SortedTom'.

The returned table of marks has only those attribute values stored that
are known for <tom> and listed in `TableOfMarksComponents'
(see~"TableOfMarksComponents").


\beginexample
gap> tom:= TableOfMarksCyclic( 6 );;  Display( tom );
1:  6
2:  3 3
3:  2 . 2
4:  1 1 1 1

gap> sorted:= SortedTom( tom, (2,3) );;  Display( sorted );
1:  6
2:  2 2
3:  3 . 3
4:  1 1 1 1

gap> wrong:= SortedTom( tom, (1,2) );;  Display( wrong );
1:  3
2:  . 6
3:  . 2 2
4:  1 1 1 1

\endexample

\>PermutationTom( <tom> ) A

For the table of marks <tom> of the group $G$ stored as `UnderlyingGroup'
value of <tom> (see~"UnderlyingGroup!for tables of marks"),
`PermutationTom' is a permutation $\pi$ such that the $i$-th conjugacy
class of subgroups of $G$ belongs to the $i^\pi$-th column and row of
marks in <tom>.

This attribute value is bound only if <tom> was obtained from another
table of marks by permuting with `SortedTom' (see~"SortedTom"),
and there is no default method to compute its value.

The attribute is necessary because the original and the sorted table of
marks have the same identifier and the same group,
and information computed from the group may depend on the ordering of
marks, for example the fusion from the ordinary character table of $G$
into <tom>.


\beginexample
gap> MarksTom( tom )[2];
[ 3, 3 ]
gap> MarksTom( sorted )[2];
[ 2, 2 ]
gap> HasPermutationTom( sorted );
true
gap> PermutationTom( sorted );
(2,3)
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Technical Details about Tables of Marks}

\>`InfoTom' V

is the info class for computations concerning tables of marks.


\>IsTableOfMarks( <obj> ) C

Each table of marks belongs to this category.


\>`TableOfMarksFamily' V

Each table of marks belongs to this family.


\>`TableOfMarksComponents' V

The list `TableOfMarksComponents' is used when a table of marks object is
created from a record via `ConvertToTableOfMarks'
(see~"ConvertToTableOfMarks").
`TableOfMarksComponents' contains at position $2i-1$ a name of an
attribute and at position $2i$ the corresponding attribute getter
function.


\>ConvertToTableOfMarks( <record> ) F

`ConvertToTableOfMarks' converts a record with components from
`TableOfMarksComponents' into a table of marks object with the
corresponding attributes.


\beginexample
gap> record:= rec( MarksTom:= [ [ 4 ], [ 2, 2 ], [ 1, 1, 1 ] ],
>  SubsTom:= [ [ 1 ], [ 1, 2 ], [ 1, 2, 3 ] ] );;
gap> ConvertToTableOfMarks( record );;
gap> record;
TableOfMarks( <3 classes> )
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Attributes of Tables of Marks}

\>MarksTom( <tom> ) A
\>SubsTom( <tom> ) A

The matrix of marks (see~"More about Tables of Marks") of the table of
marks <tom> is stored in a compressed form where zeros are omitted,
using the attributes `MarksTom' and `SubsTom'.
If $M$ is the square matrix of marks of <tom> (see~"MatTom") then the
`SubsTom' value of <tom> is a list that contains at position $i$ the list
of all positions of nonzero entries of the $i$-th row of $M$, and the
`MarksTom' value of <tom> is a list that contains at position $i$ the
list of the corresponding marks.

`MarksTom' and `SubsTom' are defining attributes of tables of marks
(see~"Table of Marks Objects in GAP").
There is no default method for computing the `SubsTom' value,
and the default `MarksTom' method needs the values of `NrSubsTom' and
`OrdersTom' (see~"NrSubsTom", "OrdersTom").


\beginexample
gap> a5:= TableOfMarks( "A5" );
TableOfMarks( "A5" )
gap> MarksTom( a5 );
[ [ 60 ], [ 30, 2 ], [ 20, 2 ], [ 15, 3, 3 ], [ 12, 2 ], [ 10, 2, 1, 1 ], 
  [ 6, 2, 1, 1 ], [ 5, 1, 2, 1, 1 ], [ 1, 1, 1, 1, 1, 1, 1, 1, 1 ] ]
gap> SubsTom( a5 );
[ [ 1 ], [ 1, 2 ], [ 1, 3 ], [ 1, 2, 4 ], [ 1, 5 ], [ 1, 2, 3, 6 ], 
  [ 1, 2, 5, 7 ], [ 1, 2, 3, 4, 8 ], [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ] ]
\endexample

\>NrSubsTom( <tom> ) A
\>OrdersTom( <tom> ) A

Instead of storing the marks (see~"MarksTom") of the table of marks <tom>
one can use a matrix which contains at position $(i,j)$ the number of
subgroups of conjugacy class $j$ that are contained in one member of the
conjugacy class $i$.
These values are stored in the `NrSubsTom' value in the same way as
the marks in the `MarksTom' value.

`OrdersTom' returns a list that contains at position $i$ the order of a
representative of the $i$-th conjugacy class of subgroups of <tom>.

One can compute the `NrSubsTom' and `OrdersTom' values from the
`MarksTom' value of <tom> and vice versa.


\beginexample
gap> NrSubsTom( a5 );
[ [ 1 ], [ 1, 1 ], [ 1, 1 ], [ 1, 3, 1 ], [ 1, 1 ], [ 1, 3, 1, 1 ], 
  [ 1, 5, 1, 1 ], [ 1, 3, 4, 1, 1 ], [ 1, 15, 10, 5, 6, 10, 6, 5, 1 ] ]
gap> OrdersTom( a5 );
[ 1, 2, 3, 4, 5, 6, 10, 12, 60 ]
\endexample

\>LengthsTom( <tom> ) A

For a table of marks <tom>, `LengthsTom' returns a list of the lengths of
the conjugacy classes of subgroups.


\beginexample
gap> LengthsTom( a5 );
[ 1, 15, 10, 5, 6, 10, 6, 5, 1 ]
\endexample

\>ClassTypesTom( <tom> ) A

`ClassTypesTom' distinguishes isomorphism types of the classes of
subgroups of the table of marks <tom> as far as this is possible
from the `SubsTom' and `MarksTom' values of <tom>.

Two subgroups are clearly not isomorphic if they have different orders.
Moreover, isomorphic subgroups must contain the same number of subgroups
of each type.

Each type is represented by a positive integer.
`ClassTypesTom' returns the list which contains for each class of
subgroups its corresponding type.


\beginexample
gap> a6:= TableOfMarks( "A6" );;
gap> ClassTypesTom( a6 );
[ 1, 2, 3, 3, 4, 5, 6, 6, 7, 7, 8, 9, 10, 11, 11, 12, 13, 13, 14, 15, 15, 16 ]
\endexample

\>ClassNamesTom( <tom> ) A

`ClassNamesTom' constructs generic names for the conjugacy classes of
subgroups of the table of marks <tom>.
In general, the generic name of a class of non--cyclic subgroups consists
of three parts and has the form `\"(<o>)_{<t>}<l>\"',
where <o> indicates the order of the subgroup,
<t> is a number that distinguishes different types of subgroups of the
same order, and <l> is a letter that distinguishes classes of subgroups
of the same type and order.
The type of a subgroup is determined by the numbers of its subgroups of
other types (see~"ClassTypesTom").
This is slightly weaker than isomorphism.

The letter is omitted if there is only one class of subgroups of that
order and type,
and the type is omitted if there is only one class of that order.
Moreover, the braces `{}'  around the type are omitted if the type number
has only one digit.

For classes of cyclic subgroups, the parentheses round the order and the
type are omitted.
Hence the most general form of their generic names is `\"<o>,<l>\"'.
Again, the letter is omitted if there is only one class of cyclic
subgroups of that order.


\beginexample
gap> ClassNamesTom( a6 );
[ "1", "2", "3a", "3b", "5", "4", "(4)_2a", "(4)_2b", "(6)a", "(6)b", "(8)", 
  "(9)", "(10)", "(12)a", "(12)b", "(18)", "(24)a", "(24)b", "(36)", "(60)a", 
  "(60)b", "(360)" ]
\endexample

\>FusionsTom( <tom> ) AM

For a table of marks <tom>, `FusionsTom' is a list of fusions into  other
tables of marks. Each fusion is a list of length  two,  the  first  entry
being the `Identifier' (see~"Identifier!for tables of  marks")  value  of
the image table, the second entry being the list of images of  the  class
positions of <tom> in the image table.

This attribute is mainly used for tables of marks in the {\GAP} library
(see~"The Library of Tables of Marks").


\beginexample
gap> fus:= FusionsTom( a6 );;
gap> fus[1];
[ "L3(4)", [ 1, 2, 3, 3, 14, 5, 9, 7, 15, 15, 24, 26, 27, 32, 33, 50, 57, 55, 
      63, 73, 77, 90 ] ]
\endexample

\>UnderlyingGroup( <tom> )!{for tables of marks} A

`UnderlyingGroup' is used to access an underlying group that is stored on
the table of marks <tom>.
There is no default method to compute an underlying group if it is not
stored.


\beginexample
gap> UnderlyingGroup( a6 );
Group([ (1,2)(3,4), (1,2,4,5)(3,6) ])
\endexample

\>IdempotentsTom( <tom> ) A
\>IdempotentsTomInfo( <tom> ) A

`IdempotentsTom' encodes the idempotents of the integral Burnside ring
described by the table of marks <tom>.
The return value is a list $l$ of positive integers such that each row
vector describing a primitive idempotent has value $1$ at all positions
with the same entry in $l$, and $0$ at all other positions.

According to A.~Dress~\cite{Dre69} (see also~\cite{Pfe97}),
these idempotents correspond to the classes of perfect subgroups,
and each such idempotent is the characteristic function of all those
subgroups that arise by cyclic extension from the corresponding perfect
subgroup (see~"CyclicExtensionsTom").

`IdempotentsTomInfo' returns a record with components `fixpointvectors'
and `primidems', both bound to lists.
The $i$-th entry of the `fixpointvectors' list is the $0-1$-vector
describing the $i$-th primitive idempotent,
and the $i$-th entry of `primidems' is the decomposition of this
idempotent in the rows of <tom>.


\beginexample
gap> IdempotentsTom( a5 );
[ 1, 1, 1, 1, 1, 1, 1, 1, 9 ]
gap> IdempotentsTomInfo( a5 );
rec( 
  primidems := [ [ 1, -2, -1, 0, 0, 1, 1, 1 ], [ -1, 2, 1, 0, 0, -1, -1, -1, 
          1 ] ], 
  fixpointvectors := [ [ 1, 1, 1, 1, 1, 1, 1, 1, 0 ], [ 0, 0, 0, 0, 0, 0, 0, 
          0, 1 ] ] )
\endexample

\>Identifier( <tom> )!{for tables of marks} A

The identifier of a table of marks <tom> is a string.
It is used for printing the table of marks
(see~"Printing Tables of Marks")
and in fusions between tables of marks (see~"FusionsTom").

If <tom> is a table of marks from the {\GAP} library of tables of marks
(see~"The Library of Tables of Marks") then it has an identifier,
and if <tom> was constructed from a group with `Name' value (see~"Name")
then this name is chosen as `Identifier' value.
There is no default method to compute an identifier in all other cases.


\beginexample
gap> Identifier( a5 );
"A5"
\endexample

\>MatTom( <tom> ) A

`MatTom' returns the square matrix of marks
(see~"More about Tables of Marks") of the table of marks <tom> which is
stored in a compressed form using the attributes `MarksTom' and `SubsTom'
(see~"MarksTom").
This may need substantially more space than the values of `MarksTom' and
`SubsTom'.


\beginexample
gap> MatTom( a5 );
[ [ 60, 0, 0, 0, 0, 0, 0, 0, 0 ], [ 30, 2, 0, 0, 0, 0, 0, 0, 0 ], 
  [ 20, 0, 2, 0, 0, 0, 0, 0, 0 ], [ 15, 3, 0, 3, 0, 0, 0, 0, 0 ], 
  [ 12, 0, 0, 0, 2, 0, 0, 0, 0 ], [ 10, 2, 1, 0, 0, 1, 0, 0, 0 ], 
  [ 6, 2, 0, 0, 1, 0, 1, 0, 0 ], [ 5, 1, 2, 1, 0, 0, 0, 1, 0 ], 
  [ 1, 1, 1, 1, 1, 1, 1, 1, 1 ] ]
\endexample

\>MoebiusTom( <tom> ) A

`MoebiusTom' computes the M{\accent127 o}bius values both of the subgroup
lattice of the group $G$ with table of marks <tom> and of the poset of
conjugacy classes of subgroups of $G$.
It returns a record where the component
`mu' contains the M{\accent127 o}bius values of the subgroup lattice,
and the component `nu' contains the M{\accent127 o}bius values of the
poset.

Moreover, according to an observation of Isaacs et al.~(see~\cite{HIO89},
\cite{Pah93}), the values on the subgroup lattice often can be derived
from those of the poset of conjugacy classes.
These ``expected values'' are returned in the component `ex',
and the list of numbers of those subgroups where the expected value does
not coincide with the actual value are returned in the component `hyp'.
For the computation of these values, the position of the derived subgroup
of $G$ is needed (see~"DerivedSubgroupTom").
If it is not uniquely determined then the result does not have the
components `ex' and `hyp'.


\beginexample
gap> MoebiusTom( a5 );
rec( mu := [ -60, 4, 2,,, -1, -1, -1, 1 ], nu := [ -1, 2, 1,,, -1, -1, -1, 1 ]
    , ex := [ -60, 4, 2,,, -1, -1, -1, 1 ], hyp := [  ] )
gap> tom:= TableOfMarks( "M12" );;
gap> moebius:= MoebiusTom( tom );;
gap> moebius.hyp;
[ 1, 2, 4, 16, 39, 45, 105 ]
gap> moebius.mu[1];  moebius.ex[1];
95040
190080
\endexample

\>WeightsTom( <tom> ) A

`WeightsTom' extracts the *weights* from the table of marks <tom>,
i.e., the diagonal entries of the matrix of marks (see~"MarksTom"),
indicating the index of a subgroup in its normalizer.


\beginexample
gap> wt:= WeightsTom( a5 );
[ 60, 2, 2, 3, 2, 1, 1, 1, 1 ]
\endexample
This information may be used to obtain the numbers of conjugate
supergroups from the marks.
\beginexample
gap> marks:= MarksTom( a5 );;
gap> List( [ 1 .. 9 ], x -> marks[x] / wt[x] );
[ [ 1 ], [ 15, 1 ], [ 10, 1 ], [ 5, 1, 1 ], [ 6, 1 ], [ 10, 2, 1, 1 ], 
  [ 6, 2, 1, 1 ], [ 5, 1, 2, 1, 1 ], [ 1, 1, 1, 1, 1, 1, 1, 1, 1 ] ]
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Properties of Tables of Marks}

For a table of marks <tom> of a group $G$, the following properties
have the same meaning as the corresponding properties for $G$.
Additionally, if a positive integer <sub> is given as the second argument
then the value of the corresponding property for the <sub>-th class of
subgroups of <tom> is returned.

\>IsAbelianTom( <tom>[, <sub>] )
\>IsCyclicTom( <tom>[, <sub>] )
\>IsNilpotentTom( <tom>[, <sub>] )
\>IsPerfectTom( <tom>[, <sub>] )
\>IsSolvableTom( <tom>[, <sub>] )



\beginexample
gap> tom:= TableOfMarks( "A5" );;
gap> IsAbelianTom( tom );  IsPerfectTom( tom );
false
true
gap> IsAbelianTom( tom, 3 );  IsNilpotentTom( tom, 7 );
true
false
gap> IsPerfectTom( tom, 7 );  IsSolvableTom( tom, 7 );
false
true
gap> for i in [ 1 .. 6 ] do
> Print( i, ": ", IsCyclicTom(a5, i), "  " );
> od;  Print( "\n" );
1: true  2: true  3: true  4: false  5: true  6: false  
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Other Operations for Tables of Marks}

\>IsInternallyConsistent( <tom> )!{for tables of marks} O

For a table of marks <tom>, `IsInternallyConsistent'
decomposes all tensor products of rows of <tom>.
It returns `true' if all decomposition numbers are nonnegative integers,
and `false' otherwise.
This provides a strong consistency check for a table of marks.



\>DerivedSubgroupTom( <tom>, <sub> ) O
\>DerivedSubgroupsTom( <tom> ) F

For a table of marks <tom> and a positive integer <sub>,
`DerivedSubgroupTom' returns either a positive integer $i$ or a list $l$
of positive integers.
In the former case, the result means that the derived subgroups of the
subgroups in the <sub>-th class of <tom> lie in the $i$-th class.
In the latter case, the class of the derived subgroups could not be
uniquely determined, and the position of the class of derived subgroups
is an entry of $l$.

Values computed with `DerivedSubgroupTom' are stored using the attribute
`DerivedSubgroupsTomPossible' (see~"DerivedSubgroupsTomPossible").

`DerivedSubgroupsTom' is just the list of `DerivedSubgroupTom' values for
all values of <sub>.


\>DerivedSubgroupsTomPossible( <tom> ) AM
\>DerivedSubgroupsTomUnique( <tom> ) A

Let <tom> be a table of marks.
The value of the attribute `DerivedSubgroupsTomPossible' is a list
in which the value at position $i$ --if bound-- is a positive integer or
a list; the meaning of the entry is the same as in `DerivedSubgroupTom'
(see~"DerivedSubgroupTom").

If the value of the attribute `DerivedSubgroupsTomUnique' is known for
<tom> then it is a list of positive integers, the value at position $i$
being the position of the class of derived subgroups of the $i$-th class
of subgroups in <tom>.
The derived subgroups are in general not uniquely determined by the table
of marks if no `UnderlyingGroup' value is stored,
so there is no default method for `DerivedSubgroupsTomUnique'.
But in some cases the derived subgroups are explicitly set when the table
of marks is constructed.
The `DerivedSubgroupsTomUnique' value is automatically set when the last
missing unique value is entered in the `DerivedSubgroupsTomPossible' list
by `DerivedSubgroupTom'.


\beginexample
gap> a5:= TableOfMarks( "A5" );
TableOfMarks( "A5" )
gap> DerivedSubgroupTom( a5, 2 );
1
gap> DerivedSubgroupsTom( a5 );
[ 1, 1, 1, 1, 1, 3, 5, 4, 9 ]
\endexample

\>NormalizerTom( <tom>, <sub> ) O
\>NormalizersTom( <tom> ) A

Let <tom> be the table of marks of a group $G$, say.
`NormalizerTom' tries to find the conjugacy class of the normalizer $N$
in $G$ of a subgroup $U$ in the <sub>-th class of <tom>.
The return value is either the list of class numbers of those subgroups
that have the right size and contain the subgroup and all subgroups that
clearly contain it as a normal subgroup, or the class number of the
normalizer if it is uniquely determined by these conditions.
If <tom> knows the subgroup lattice of $G$ (see~"IsTableOfMarksWithGens")
then all normalizers are uniquely determined.
`NormalizerTom' should never return an empty list.

`NormalizersTom' returns the list of positions of the classes of
normalizers of subgroups in <tom>.
In addition to the criteria for a single class of subgroup used by
`NormalizerTom', the approximations of normalizers for several classes
are used and thus `NormalizersTom' may return better approximations
than `NormalizerTom'.


\beginexample
gap> NormalizerTom( a5, 4 );
8
gap> NormalizersTom( a5 );
[ 9, 4, 6, 8, 7, 6, 7, 8, 9 ]
\endexample
The example shows that a subgroup with class number 4 in $A_5$
(which is a Kleinian four group)
is normalized by a subgroup in class 8.
This class contains the subgroups of $A_5$ which are isomorphic to $A_4$.

\>ContainedTom( <tom>, <sub1>, <sub2> ) O

`ContainedTom' returns the number of subgroups in class <sub1> of the
table of marks <tom> that are contained in one fixed member of the class
<sub2>.


\>ContainingTom( <tom>, <sub1>, <sub2> ) O

`ContainingTom' returns the number of subgroups in class <sub2> of the
table of marks <tom> that contain one fixed member of the class <sub1>.


\beginexample
gap> ContainedTom( a5, 3, 5 );  ContainedTom( a5, 3, 8 );
0
4
gap> ContainingTom( a5, 3, 5 );  ContainingTom( a5, 3, 8 );
0
2
\endexample

\>CyclicExtensionsTom( <tom> ) A
\>CyclicExtensionsTom( <tom>, <p> ) O
\>CyclicExtensionsTom( <tom>, <list> ) O

According to A.~Dress~\cite{Dre69}, two columns of the table of marks
<tom> are equal modulo the prime <p> if and only if the corresponding
subgroups are connected by a chain of normal extensions of order <p>.

In the second form, `CyclicExtensionsTom' returns the classes of this
equivalence relation.
In the third form, <list> must be a list of primes, and the return value
is the list of classes of the relation obtained by considering chains of
normal extensions of prime order where all primes are in <list>.
In the first form, the result is the same as in the third form,
with second argument the set of prime divisors of the size of the group
of <tom>.

(This information is not used by `NormalizerTom' (see~"NormalizerTom")
although it might give additional restrictions in the search of
normalizers.)


\beginexample
gap> CyclicExtensionsTom( a5, 2 );
[ [ 1, 2, 4 ], [ 3, 6 ], [ 5, 7 ], [ 8 ], [ 9 ] ]
\endexample

\>DecomposedFixedPointVector( <tom>, <fix> ) O

Let <tom> be the table of marks of the group $G$, say,
and let <fix> be a vector of fixed point numbers w.r.t.~an action of $G$,
i.e., a vector which contains for each class of subgroups the number of
fixed points under the given action.
`DecomposedFixedPointVector' returns the decomposition of <fix> into rows
of the table of marks.
This decomposition  corresponds to a decomposition of the action into
transitive constituents.
Trailing zeros in <fix> may be omitted.


\beginexample
gap> DecomposedFixedPointVector( a5, [ 16, 4, 1, 0, 1, 1, 1 ] );
[ 0, 0, 0, 0, 0, 1, 1 ]
\endexample
The vector <fix> may be any vector of integers.
The resulting decomposition, however, will not be integral, in general.
\beginexample
gap> DecomposedFixedPointVector( a5, [ 0, 0, 0, 0, 1, 1 ] );
[ 2/5, -1, -1/2, 0, 1/2, 1 ]
\endexample

\>EulerianFunctionByTom( <tom>, <n>[, <sub>] ) O

In the first form `EulerianFunctionByTom' computes the Eulerian
function (see~"EulerianFunction") of the underlying group $G$ of the
table of marks <tom>,
that is, the number of <n>-tuples of elements in $G$ that generate $G$.
In the second form `EulerianFunctionByTom' computes the Eulerian function
of each subgroup in the <sub>-th class of subgroups of <tom>.

For a group $G$ whose table of marks is known, `EulerianFunctionByTom'
is installed as a method for `EulerianFunction' (see~"EulerianFunction").


\beginexample
gap> EulerianFunctionByTom( a5, 2 );
2280
gap> EulerianFunctionByTom( a5, 3 );
200160
gap> EulerianFunctionByTom( a5, 2, 3 );
8
\endexample

\>IntersectionsTom( <tom>, <sub1>, <sub2> ) O

The intersections of the groups in the <sub1>-th conjugacy class of
subgroups of the table of marks <tom> with the groups in the <sub2>-th
conjugacy classes of subgroups of <tom> are determined up to conjugacy by
the decomposition of the tensor product of their rows of marks.
`IntersectionsTom' returns a list $l$ that describes this decomposition.
The $i$-th entry in $l$ is the multiplicity of groups in the
$i$-th conjugacy class as an intersection.


\beginexample
gap> IntersectionsTom( a5, 8, 8 );
[ 0, 0, 1, 0, 0, 0, 0, 1 ]
\endexample
Any two subgroups of class number 8 ($A_4$) of $A_5$ are either equal and
their intersection has again class number 8, or their intersection has
class number $3$, and is a cyclic subgroup of order 3.

\>FactorGroupTom( <tom>, <n> ) O

For a table of marks <tom> of the group $G$, say,
and the normal subgroup $N$ of $G$ corresponding to the <n>-th class of
subgroups of <tom>,
`FactorGroupTom' returns the table of marks of the factor
group $G / N$.


\beginexample
gap> s4:= TableOfMarks( SymmetricGroup( 4 ) );
TableOfMarks( Sym( [ 1 .. 4 ] ) )
gap> LengthsTom( s4 );
[ 1, 3, 6, 4, 1, 3, 3, 4, 3, 1, 1 ]
gap> OrdersTom( s4 );
[ 1, 2, 2, 3, 4, 4, 4, 6, 8, 12, 24 ]
gap> s3:= FactorGroupTom( s4, 5 );
TableOfMarks( Group([ f1, f2 ]) )
gap> Display( s3 );
1:  6
2:  3 1
3:  2 . 2
4:  1 1 1 1

\endexample

\>MaximalSubgroupsTom( <tom> ) A
\>MaximalSubgroupsTom( <tom>, <sub> ) O

In the first form `MaximalSubgroupsTom' returns a list of length two,
the first entry being the list of positions of the classes of maximal
subgroups of the whole group of the table of marks <tom>,
the second entry being the list of class lengths of these groups.
In the second form the same information for the <sub>-th class of
subgroups is returned.


\>MinimalSupergroupsTom( <tom>, <sub> ) O

For a table of marks <tom>, `MinimalSupergroupsTom' returns a list of
length two, the first entry being the list of positions of the classes
containing the minimal supergroups of the groups in the <sub>-th class
of subgroups of <tom>,
the second entry being the list of class lengths of these groups.


\beginexample
gap> MaximalSubgroupsTom( s4 );
[ [ 10, 9, 8 ], [ 1, 3, 4 ] ]
gap> MaximalSubgroupsTom( s4, 10 );
[ [ 5, 4 ], [ 1, 4 ] ]
gap> MinimalSupergroupsTom( s4, 5 );
[ [ 9, 10 ], [ 3, 1 ] ]
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Standard Generators of Groups}

An $s$-tuple of *standard generators* of a given group $G$ is a vector
$(g_1, g_2, \ldots, g_s)$ of elements $g_i \in G$ satisfying certain
conditions (depending on the isomorphism type of $G$) such that
\beginlist%ordered
\item{1.}
    $\langle g_1, g_2, \ldots, g_s \rangle = G$ and
\item{2.}
    the vector is unique up to automorphisms of $G$,
    i.e., for two vectors $(g_1, g_2, \ldots, g_s)$ and
    $(h_1, h_2, \ldots, h_s)$ of standard generators,
    the map $g_i \mapsto h_i$ extends to an automorphism of $G$.
\endlist
For details about standard generators, see~\cite{Wil96}.



\>StandardGeneratorsInfo( <G> )!{for groups} A

When called with the group <G>,
`StandardGeneratorsInfo' returns a list of records with at least one of
the components `script' and `description'.
Each such record defines *standard generators* of groups isomorphic
to <G>, the $i$-th record is referred to as the $i$-th set of
standard generators for such groups.
The value of `script' is a dense list of lists, each encoding a command
that has one of the following forms.
\beginitems
A *definition* $[ i, n, k ]$ or $[ i, n ]$ &
    means to search for an element of order $n$,
    and to take its $k$-th power as candidate for the $i$-th standard
    generator (the default for $k$ is $1$),

a *relation* $[ i_1, k_1, i_2, k_2, \ldots, i_m, k_m, n ]$ with $m > 1$ &
    means a check whether the element
    $g_{i_1}^{k_1} g_{i_2}^{k_2} \cdots g_{i_m}^{k_m}$ has order $n$;
    if $g_j$ occurs then of course the $j$-th generator must have been
    defined before,

a *relation* $[ [ i_1, i_2, \ldots, i_m ], <slp>, n ]$ &
    means a check whether the result of the straight line program <slp>
    (see~"Straight Line Programs") applied to the candidates
    $g_{i_1}, g_{i_2}, \ldots, g_{i_m}$ has order $n$,
    where the candidates $g_j$ for the $j$-th standard generators
    must have been defined before,

a *condition* $[ [ i_1, k_1, i_2, k_2, \ldots, i_m, k_m ], f, v ]$ &
    means a check whether the {\GAP} function in the global list
    `StandardGeneratorsFunctions' (see "StandardGeneratorsFunctions")
    that is followed by the list $f$ of strings returns the value $v$
    when it is called with $G$ and
    $g_{i_1}^{k_1} g_{i_2}^{k_2} \cdots g_{i_m}^{k_m}$.
\enditems
Optional components of the returned records are
\beginitems
`generators' &
    a string of names of the standard generators,

`description' &
    a string describing the `script' information in human readable form,
    in terms of the `generators' value,

`classnames' &
    a list of strings, the $i$-th entry being the name of the conjugacy
    class containing the $i$-th standard generator,
    according to the {\ATLAS} character table of the group
    (see~"ClassNames"), and

`ATLAS' &
    a boolean; `true' means that the standard generators coincide with
    those defined in Rob Wilson's {\ATLAS} of Group Representations
    (see~\cite{AGR}), and `false' means that this property is not
    guaranteed.
\enditems

There is no default method for an arbitrary isomorphism type,
since in general the definition of standard generators is not obvious.

The function `StandardGeneratorsOfGroup'
(see~"StandardGeneratorsOfGroup")
can be used to find standard generators of a given group isomorphic
to <G>.

The `generators' and `description' values, if not known, can be computed
by `HumanReadableDefinition' (see~"HumanReadableDefinition").


\beginexample
gap> StandardGeneratorsInfo( TableOfMarks( "L3(3)" ) );
[ rec( generators := "a, b", 
      description := "||a||=2, ||b||=3, ||C(b)||=9, ||ab||=13, ||ababb||=4", 
      script := [ [ 1, 2 ], [ 2, 3 ], [ [ 2, 1 ], [ "||C(",, ")||" ], 9 ], 
          [ 1, 1, 2, 1, 13 ], [ 1, 1, 2, 1, 1, 1, 2, 1, 2, 1, 4 ] ], 
      ATLAS := true ) ]
\endexample
%T  replace by an example for isom. type as soon as this is implemented!

\>HumanReadableDefinition( <info> ) F
\>ScriptFromString( <string> ) F

Let <info> be a record that is valid as value of `StandardGeneratorsInfo'
(see~"StandardGeneratorsInfo!for groups").
`HumanReadableDefinition' returns a string that describes the definition
of standard generators given by the `script' component of <info> in
human readable form.
The names of the generators are taken from the `generators' component
(default names `\"a\"', `\"b\"' etc.~are computed if necessary),
and the result is stored in the `description' component.

`ScriptFromString' does the converse of `HumanReadableDefinition', i.e.,
it takes a string <string> as returned by `HumanReadableDefinition',
and returns a corresponding `script' list.

If ``condition'' lines occur in the script
(see~"StandardGeneratorsInfo!for groups")
then the functions that occur must be contained in
`StandardGeneratorsFunctions' (see~"StandardGeneratorsFunctions").


\beginexample
gap> scr:= ScriptFromString( "||a||=2, ||b||=3, ||C(b)||=9, ||ab||=13, ||ababb||=4" );
[ [ 1, 2 ], [ 2, 3 ], [ [ 2, 1 ], [ "||C(",, ")||" ], 9 ], [ 1, 1, 2, 1, 13 ], 
  [ 1, 1, 2, 1, 1, 1, 2, 1, 2, 1, 4 ] ]
gap> info:= rec( script:= scr );
rec( script := [ [ 1, 2 ], [ 2, 3 ], [ [ 2, 1 ], [ "||C(",, ")||" ], 9 ], 
      [ 1, 1, 2, 1, 13 ], [ 1, 1, 2, 1, 1, 1, 2, 1, 2, 1, 4 ] ] )
gap> HumanReadableDefinition( info );
"||a||=2, ||b||=3, ||C(b)||=9, ||ab||=13, ||ababb||=4"
gap> info;
rec( script := [ [ 1, 2 ], [ 2, 3 ], [ [ 2, 1 ], [ "||C(",, ")||" ], 9 ], 
      [ 1, 1, 2, 1, 13 ], [ 1, 1, 2, 1, 1, 1, 2, 1, 2, 1, 4 ] ], 
  generators := "a, b", 
  description := "||a||=2, ||b||=3, ||C(b)||=9, ||ab||=13, ||ababb||=4" )
\endexample

\>`StandardGeneratorsFunctions' V

`StandardGeneratorsFunctions' is a list of even length.
At position $2i-1$, a function of two arguments is stored,
which are expected to be a group and a group element.
At position $2i$ a list of strings is stored such that first inserting a
generator name in all holes and then forming the concatenation yields
a string that describes the function at the previous position;
this string must contain the generator enclosed in round brackets `('
and `)'.

This list is used by the functions `StandardGeneratorsInfo'
(see~"StandardGeneratorsInfo!for groups"), `HumanReadableDefinition', and
`ScriptFromString' (see~"HumanReadableDefinition").
Note that the lists at even positions must be pairwise different.


\beginexample
gap> StandardGeneratorsFunctions{ [ 1, 2 ] };
[ function( G, g ) ... end, [ "||C(",, ")||" ] ]
\endexample

\>IsStandardGeneratorsOfGroup( <info>, <G>, <gens> ) F

Let <info> be a record that is valid as value of `StandardGeneratorsInfo'
(see~"StandardGeneratorsInfo!for groups"), <G> a group, and <gens> a list
of generators for <G>.
In this case, `IsStandardGeneratorsOfGroup' returns `true' if <gens>
satisfies the conditions of the `script' component of <info>,
and `false' otherwise.

Note that the result `true' means that <gens> is a list of standard
generators for <G> only if <G> has the isomorphism type for which <info>
describes standard generators.


\>StandardGeneratorsOfGroup( <info>, <G>[, <randfunc>] ) F

Let <info> be a record that is valid as value of `StandardGeneratorsInfo'
(see~"StandardGeneratorsInfo!for groups"),
and <G> a group of the isomorphism type for which <info> describes
standard generators.
In this case, `StandardGeneratorsOfGroup' returns a list of standard
generators (see~Section~"Standard Generators of Groups") of <G>.

The optional argument <randfunc> must be a function that returns an
element of <G> when called with <G>; the default is `PseudoRandom'.

In each call to `StandardGeneratorsOfGroup',
the `script' component of <info> is scanned line by line.
<randfunc> is used to find an element of the prescribed order
whenever a definition line is met,
and for the relation and condition lines in the `script' list,
the current generator candidates are checked;
if a condition is not fulfilled, all candidates are thrown away,
and the procedure starts again with the first line.
When the conditions are fulfilled after processing the last line
of the `script' list, the standard generators are returned.


Note that if <G> has the wrong isomorphism type then
`StandardGeneratorsOfGroup' returns a list of elements in <G>
that satisfy the conditions of the `script' component of <info>
if such elements exist, and does not terminate otherwise.
In the former case, obviously the returned elements need not be standard
generators of <G>.


\beginexample
gap> a5:= AlternatingGroup( 5 );
Alt( [ 1 .. 5 ] )
gap> info:= StandardGeneratorsInfo( TableOfMarks( "A5" ) )[1];
rec( generators := "a, b", description := "||a||=2, ||b||=3, ||ab||=5", 
  script := [ [ 1, 2 ], [ 2, 3 ], [ 1, 1, 2, 1, 5 ] ], ATLAS := true )
gap> IsStandardGeneratorsOfGroup( info, a5, [ (1,3)(2,4), (3,4,5) ] );
true
gap> IsStandardGeneratorsOfGroup( info, a5, [ (1,3)(2,4), (1,2,3) ] );
false
gap> s5:= SymmetricGroup( 5 );;
gap> RepresentativeAction( s5, [ (1,3)(2,4), (3,4,5) ], 
>        StandardGeneratorsOfGroup( info, a5 ), OnPairs ) <> fail;
true
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Accessing Subgroups via Tables of Marks}

Let <tom> be the table of marks of the group $G$,
and assume that <tom> has access to $G$ via the `UnderlyingGroup' value
(see~"UnderlyingGroup!for tables of marks").
Then it makes sense to use <tom> and its ordering of conjugacy classes of
subgroups of $G$ for storing information for constructing representatives
of these classes.
The group $G$ is in general not sufficient for this,
<tom> needs more information;
this is available if and only if the `IsTableOfMarksWithGens' value of
<tom> is `true' (see~"IsTableOfMarksWithGens").
In this case, `RepresentativeTom' (see~"RepresentativeTom") can be used
to get a subgroup of the $i$-th class, for all $i$.

{\GAP} provides two different possibilities to store generators of the
representatives of classes of subgroups.
The first is implemented by the attribute `GeneratorsSubgroupsTom'
(see~"GeneratorsSubgroupsTom"), which uses explicit generators.
The second, more general, possibility is implemented by the attributes
`StraightLineProgramsTom' (see~"StraightLineProgramsTom") and
`StandardGeneratorsInfo' (see~"StandardGeneratorsInfo!for tables of marks").
The `StraightLineProgramsTom' value encodes the generators as 
straight line programs (see~"Straight Line Programs") that evaluate to
the generators in question when applied to standard generators of $G$.
This means that on the one hand, standard generators of $G$ must be known
in order to use `StraightLineProgramsTom'.
On the other hand, the straight line programs allow one to compute easily
generators not only of a subgroup $U$ of $G$ but also generators of the
image of $U$ in any representation of $G$, provided that one knows
standard generators of the image of $G$ under this representation
(see~"RepresentativeTomByGenerators" for details and an example).



\>GeneratorsSubgroupsTom( <tom> ) A

Let <tom> be a table of marks with `IsTableOfMarksWithGens' value `true'.
Then `GeneratorsSubgroupsTom' returns a list of length two,
the first entry being a list $l$ of elements of the group stored as
`UnderlyingGroup' value of <tom>,
the second entry being a list that contains at position $i$ a list of
positions in $l$ of generators of a representative of a subgroup in class
$i$.

The `GeneratorsSubgroupsTom' value is known for all tables of marks that
have been computed with `TableOfMarks' (see~"TableOfMarks") from a group,
and there is a method to compute the value for a table of marks that
admits `RepresentativeTom' (see~"RepresentativeTom").


\>StraightLineProgramsTom( <tom> ) A

For a table of marks <tom> with `IsTableOfMarksWithGens' value `true',
`StraightLineProgramsTom' returns a list that contains at position $i$
either a list of straight line programs or a straight line program
(see~"Straight Line Programs"), encoding the generators of
a representative of the $i$-th conjugacy class of subgroups of
`UnderlyingGroup( <tom> )';
in the former case, each straight line program returns a generator,
in the latter case, the program returns the list of generators.

There is no default method to compute the `StraightLineProgramsTom' value
of a table of marks if they are not yet stored.
The value is known for all tables of marks that belong to the
{\GAP} library of tables of marks (see~"The Library of Tables of Marks").


\>IsTableOfMarksWithGens( <tom> ) F

This filter shall express the union of the filters
`IsTableOfMarks and HasStraightLineProgramsTom' and
`IsTableOfMarks and HasGeneratorsSubgroupsTom'.
If a table of marks <tom> has this filter set then <tom> can be asked to
compute information that is in general not uniquely determined by a table
of marks,
for example the positions of derived subgroups or normalizers of
subgroups (see~"DerivedSubgroupTom", "NormalizerTom").


\beginexample
gap> a5:= TableOfMarks( "A5" );;  IsTableOfMarksWithGens( a5 );
true
gap> HasGeneratorsSubgroupsTom( a5 );  HasStraightLineProgramsTom( a5 );
false
true
gap> alt5:= TableOfMarks( AlternatingGroup( 5 ) );;
gap> IsTableOfMarksWithGens( alt5 );
true
gap> HasGeneratorsSubgroupsTom( alt5 );  HasStraightLineProgramsTom( alt5 );
true
false
gap> progs:= StraightLineProgramsTom( a5 );;
gap> OrdersTom( a5 );
[ 1, 2, 3, 4, 5, 6, 10, 12, 60 ]
gap> IsCyclicTom( a5, 4 );
false
gap> Length( progs[4] );
2
gap> progs[4][1];
<straight line program>
gap> Display( progs[4][1] );  # first generator of an el. ab group of order 4
# input:
r:= [ g1, g2 ];
# program:
r[3]:= r[2]*r[1];
r[4]:= r[3]*r[2]^-1*r[1]*r[3]*r[2]^-1*r[1]*r[2];
# return value:
r[4]
gap> x:= [ [ Z(2)^0, 0*Z(2) ], [ Z(2^2), Z(2)^0 ] ];;
gap> y:= [ [ Z(2^2), Z(2)^0 ], [ 0*Z(2), Z(2^2)^2 ] ];;
gap> res1:= ResultOfStraightLineProgram( progs[4][1], [ x, y ] );
[ [ Z(2)^0, 0*Z(2) ], [ Z(2^2)^2, Z(2)^0 ] ]
gap> res2:= ResultOfStraightLineProgram( progs[4][2], [ x, y ] );
[ [ Z(2)^0, 0*Z(2) ], [ Z(2^2), Z(2)^0 ] ]
gap> w:= y*x;;
gap> res1 = w*y^-1*x*w*y^-1*x*y;
true
gap> subgrp:= Group( res1, res2 );;  Size( subgrp );  IsCyclic( subgrp );
4
false
\endexample

\>RepresentativeTom( <tom>, <sub> ) O
\>RepresentativeTomByGenerators( <tom>, <sub>, <gens> ) O
\>RepresentativeTomByGeneratorsNC( <tom>, <sub>, <gens> ) O

Let <tom> be a table of marks with `IsTableOfMarksWithGens' value `true'
(see~"IsTableOfMarksWithGens"), and <sub> a positive integer.
`RepresentativeTom' returns a representative of the <sub>-th conjugacy
class of subgroups of <tom>.

`RepresentativeTomByGenerators' and `RepresentativeTomByGeneratorsNC'
return a representative of the <sub>-th conjugacy class of subgroups of
<tom>, as a subgroup of the group generated by <gens>.
This means that the standard generators of <tom> are replaced by <gens>.

`RepresentativeTomByGenerators' checks whether mapping the standard
generators of <tom> to <gens> extends to a group isomorphism,
and returns `fail' if not.
`RepresentativeTomByGeneratorsNC' omits all checks.
So `RepresentativeTomByGenerators' is thought mainly for debugging
purposes;
note that when several representatives are constructed, it is cheaper to
construct (and check) the isomorphism once, and to map the groups
returned by `RepresentativeTom' under this isomorphism.
The idea behind `RepresentativeTomByGeneratorsNC', however, is to avoid
the overhead of using isomorphisms when <gens> are known to be standard
generators.


\beginexample
gap> RepresentativeTom( a5, 4 );
Group([ (2,3)(4,5), (2,4)(3,5) ])
\endexample

\>StandardGeneratorsInfo( <tom> )!{for tables of marks} A

For a table of marks <tom>, a stored  value  of  `StandardGeneratorsInfo'
equals  the  value  of  this   attribute   for   the   underlying   group
(see~"UnderlyingGroup!for     tables     of     marks")     of     <tom>,
cf.~Section~"Standard Generators of Groups".

In this case, the `GeneratorsOfGroup' value of the underlying group $G$
of <tom> is assumed to be in fact a list of standard generators for $G$;
So one should be careful when setting the `StandardGeneratorsInfo' value
by hand.

There is no default method to compute the `StandardGeneratorsInfo' value
of a table of marks if it is not yet stored.


\beginexample
gap> std:= StandardGeneratorsInfo( a5 );
[ rec( generators := "a, b", description := "||a||=2, ||b||=3, ||ab||=5", 
      script := [ [ 1, 2 ], [ 2, 3 ], [ 1, 1, 2, 1, 5 ] ], ATLAS := true ) ]
gap> # Now find standard generators of an isomorphic group.
gap> g:= SL(2,4);;
gap> repeat
>   x:= PseudoRandom( g );
> until Order( x ) = 2;
gap> repeat
>   y:= PseudoRandom( g );
> until Order( y ) = 3 and Order( x*y ) = 5;
gap> # Compute a representative w.r.t. these generators.
gap> RepresentativeTomByGenerators( a5, 4, [ x, y ] );
Group([ [ [ Z(2)^0, Z(2^2)^2 ], [ 0*Z(2), Z(2)^0 ] ], 
  [ [ Z(2)^0, Z(2^2) ], [ 0*Z(2), Z(2)^0 ] ] ])
gap> # Show that the new generators are really good.
gap> grp:= UnderlyingGroup( a5 );;
gap> iso:= GroupGeneralMappingByImages( grp, g,
>              GeneratorsOfGroup( grp ), [ x, y ] );;
gap> IsGroupHomomorphism( iso );
true
gap> IsBijective( iso );
true
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{The Interface between Tables of Marks and Character Tables}

The following examples require the {\GAP} Character Table Library
to be available.
If it is not yet loaded then we load it now.

\beginexample
gap> LoadPackage( "ctbllib" );
true
\endexample


\>FusionCharTableTom( <tbl>, <tom> ) O
\>PossibleFusionsCharTableTom( <tbl>, <tom>[, <options>] ) O

Let <tbl> be the ordinary character table of the group $G$, say,
and <tom> the table of marks of $G$.
`FusionCharTableTom' determines the fusion of the classes of elements
from <tbl> to the classes of cyclic subgroups on <tom>, that is,
a list that contains at position $i$ the position of the class of cyclic
subgroups in <tom> that are generated by elements in the $i$-th conjugacy
class of elements in <tbl>.

Three cases are handled differently.
\beginlist%ordered
\item{1.}
     The fusion is explicitly stored on <tbl>.
     Then nothing has to be done.
     This happens only if both <tbl> and <tom> are tables from the {\GAP}
     library (see~"The Library of Tables of Marks" and the manual of
     the {\GAP} Character Table Library).
\item{2.}
     The `UnderlyingGroup' values of <tbl> and <tom> are known and
     equal.
     Then the group is used to compute the fusion.
\item{3.}
     There is neither fusion nor group information available.
     In this case only necessary conditions can be checked,
     and if they are not sufficient to detemine the fusion uniquely then
     `fail' is returned by `FusionCharTableTom'.
\endlist

`PossibleFusionsCharTableTom' computes the list of possible fusions from
<tbl> to <tom>, according to the criteria that have been checked.
So if `FusionCharTableTom' returns a unique fusion then the list returned
by `PossibleFusionsCharTableTom' for the same arguments contains exactly
this fusion,
and if `FusionCharTableTom' returns `fail' then the length of this list
is different from $1$.

The optional argument <options> must be a record that may have the
following components.
\beginitems
`fusionmap' &
     a parametrized map which is an approximation of the desired map,

`quick' &
     a Boolean;
     if `true' then as soon as only one possibility remains
     this possibility is returned immediately;
     the default value is `false'.
\enditems


\beginexample
gap> a5c:= CharacterTable( "A5" );;
gap> fus:= FusionCharTableTom( a5c, a5 );
[ 1, 2, 3, 5, 5 ]
\endexample

\>PermCharsTom( <fus>, <tom> ) O
\>PermCharsTom( <tbl>, <tom> ) O

`PermCharsTom' returns the list of transitive permutation characters
from the table of marks <tom>.
In the first form, <fus> must be the fusion map from the ordinary
character table of the group of <tom> to <tom>
(see~"FusionCharTableTom").
In the second form, <tbl> must be the character table of the group of
which <tom> is the table of marks.
If the fusion map is not uniquely determined (see~"FusionCharTableTom")
then `fail' is returned.

If the fusion map <fus> is given as first argument then each transitive
permutation character is represented by its values list.
If the character table <tbl> is given then the permutation characters are
class function objects (see Chapter~"Class Functions").


\beginexample
gap> PermCharsTom( a5c, a5 );
[ Character( CharacterTable( "A5" ), [ 60, 0, 0, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 30, 2, 0, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 20, 0, 2, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 15, 3, 0, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 12, 0, 0, 2, 2 ] ), 
  Character( CharacterTable( "A5" ), [ 10, 2, 1, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 6, 2, 0, 1, 1 ] ), 
  Character( CharacterTable( "A5" ), [ 5, 1, 2, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 1, 1, 1, 1, 1 ] ) ]
gap> PermCharsTom( fus, a5 )[1];
[ 60, 0, 0, 0, 0 ]
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Generic Construction of Tables of Marks}

The following three operations construct a table of marks only from the
data given, i.e., without underlying group.



\>TableOfMarksCyclic( <n> ) O

`TableOfMarksCyclic' returns the table of marks of the cyclic group
of order <n>.

A cyclic group of order <n> has as its subgroups for each divisor $d$
of <n> a cyclic subgroup of order $d$.


\>TableOfMarksDihedral( <n> ) O

`TableOfMarksDihedral' returns the table of marks of the dihedral group
of order <m>.

For each divisor $d$ of <m>, a dihedral group of order $m = 2n$ contains
subgroups of order $d$ according to the following rule.
If $d$ is odd and divides $n$ then there is only one cyclic subgroup of
order $d$.
If $d$ is even and divides $n$ then there are a cyclic subgroup of order
$d$ and two classes of dihedral subgroups of order $d$
(which are cyclic, too, in the case $d = 2$, see the example below).
Otherwise (i.e., if $d$ does not divide $n$) there is just one class of
dihedral subgroups of order $d$.


\>TableOfMarksFrobenius( <p>, <q> ) O

`TableOfMarksFrobenius' computes the table of marks of a Frobenius group
of order $p q$, where $p$ is a prime and $q$ divides $p-1$.



\beginexample
gap> Display( TableOfMarksCyclic( 6 ) );
1:  6
2:  3 3
3:  2 . 2
4:  1 1 1 1

gap> Display( TableOfMarksDihedral( 12 ) );
 1:  12
 2:   6 6
 3:   6 . 2
 4:   6 . . 2
 5:   4 . . . 4
 6:   3 3 1 1 . 1
 7:   2 2 . . 2 . 2
 8:   2 . 2 . 2 . . 2
 9:   2 . . 2 2 . . . 2
10:   1 1 1 1 1 1 1 1 1 1

gap> Display( TableOfMarksFrobenius( 5, 4 ) );
1:  20
2:  10 2
3:   5 1 1
4:   4 . . 4
5:   2 2 . 2 2
6:   1 1 1 1 1 1

\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{The Library of Tables of Marks}

The {\GAP} package `TomLib' provides access to several hundred tables of
marks of almost simple groups and their maximal subgroups.
If this package is installed then the tables from this database can be
accessed via `TableOfMarks' with argument a string (see~"TableOfMarks").
If also the {\GAP} Character Table Library is installed and contains the
ordinary character table of the group for which one wants to fetch the table
of marks then one can also call `TableOfMarks' with argument the character
table.

A list of all names of tables of marks in the database can be obtained via
`AllLibTomNames'.

\beginexample
gap> names:= AllLibTomNames();;
gap> "A5" in names;
true
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%E

