% This file was created automatically from groups.msk.
% DO NOT EDIT!
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%A  groups.msk                  GAP documentation            Alexander Hulpke
%%
%A  @(#)$Id: groups.msk,v 1.99.2.14 2006/09/16 19:02:49 jjm Exp $
%%
%Y  (C) 1998 School Math and Comp. Sci., University of St  Andrews, Scotland
%Y  Copyright (C) 2002 The GAP Group
%%
\Chapter{Groups}

This chapter explains how to create groups and defines operations for
groups, that is operations whose definition does not depend on the
representation used.
However methods for these operations in most cases will make use of the
representation.

If not otherwise specified, in all examples in this chapter the group `g'
will be the symmetric group $S_4$ acting on the letters $\{1,\ldots,4\}$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Group Elements}

Groups in {\GAP} are written multiplicatively.
The elements from which a group can be generated must permit
multiplication and multiplicative inversion
(see~"Useful Categories of Elements").

\beginexample
gap> a:=(1,2,3);;b:=(2,3,4);;
gap> One(a);
()
gap> Inverse(b);
(2,4,3)
gap> a*b;
(1,3)(2,4)
gap> Order(a*b);
2
gap> Order( [ [ 1, 1 ], [ 0, 1 ] ] );
infinity
\endexample

The next example may run into an infinite loop
because the given matrix in fact has infinite order.

%notest
\beginexample
gap> Order( [ [ 1, 1 ], [ 0, 1 ] ] * Indeterminate( Rationals ) );
#I  Order: warning, order of <mat> might be infinite
\endexample

\index{order! of a group}
Since groups are domains, the recommended command to compute the order
of a group is `Size' (see~"Size").
For convenience, group orders can also be computed with `Order'.

The operation `Comm' (see~"Comm") can be used to compute the commutator of
two elements, the operation `LeftQuotient' (see~"LeftQuotient") computes the
product $x^{-1}y$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Creating Groups}

When groups are created from generators,
this means that the generators must be elements that can be multiplied
and inverted (see also~"Constructing Domains").
For creating a free group on a set of symbols, see~"FreeGroup".

\>Group( <gen>, ... ) F
\>Group( <gens> ) F
\>Group( <gens>, <id> ) F

`Group( <gen>, ... )' is the group generated by the arguments <gen>, ...

If the only  argument <gens> is a list  that is not  a matrix then
`Group( <gens> )' is the group generated by the elements of that list.

If there  are two arguments,   a list <gens>  and  an element <id>, then
`Group( <gens>, <id> )'  is the group generated  by the elements of
<gens>, with identity <id>.

Note that the value of the attribute `GeneratorsOfGroup' need not be
equal to the list <gens> of generators entered as argument.
Use `GroupWithGenerators' (see~"GroupWithGenerators") if you want to be
sure that the argument <gens> is stored as value of `GeneratorsOfGroup'.


\beginexample
gap> g:=Group((1,2,3,4),(1,2));
Group([ (1,2,3,4), (1,2) ])
\endexample

\>GroupWithGenerators( <gens> ) O
\>GroupWithGenerators( <gens>, <id> ) O

`GroupWithGenerators' returns the group $G$ generated by the list <gens>.
If a second argument <id> is present then this is stored as the identity
element of the group.
The value of the attribute `GeneratorsOfGroup' of $G$ is equal to <gens>.


\>GeneratorsOfGroup( <G> ) A

returns a list of generators of the group <G>.
If <G> has been created by the command `GroupWithGenerators'
(see~"GroupWithGenerators"), with argument <gens>, then
the list returned by `GeneratorsOfGroup' will be equal to <gens>.


\beginexample
gap> g:=GroupWithGenerators([(1,2,3,4),(1,2)]);
Group([ (1,2,3,4), (1,2) ])
gap> GeneratorsOfGroup(g);
[ (1,2,3,4), (1,2) ]
\endexample
While in this example {\GAP} displays the group via the generating set
stored in the attribute `GeneratorsOfGroup', the methods installed for
`View' (see~"View") will in general display only some information about the
group which may even be just the fact that it is a group.

\>AsGroup( <D> ) A

if the elements of the collection <D> form a group the command returns
this group, otherwise it returns `fail'.


\beginexample
gap> AsGroup([(1,2)]);
fail
gap> AsGroup([(),(1,2)]);
Group([ (1,2) ])
\endexample

\>ConjugateGroup( <G>, <obj> ) O

returns the conjugate group of <G>, obtained by applying the conjugating
element <obj>.
To form a conjugate (group) by any object acting via `^', one can use
the infix operator `^'.


\beginexample
gap> ConjugateGroup(g,(1,5));
Group([ (2,3,4,5), (2,5) ])
\endexample

\>IsGroup( <obj> ) C

A group is a magma-with-inverses (see~"IsMagmaWithInverses")
and associative (see~"IsAssociative") multiplication.

`IsGroup' tests whether the object <obj> fulfills these conditions,
it does *not* test whether <obj> is a set of elements that forms a group
under multiplication;
use `AsGroup' (see~"AsGroup") if you want to perform such a test.
(See~"Categories" for details about categories.)


\beginexample
gap> IsGroup(g);
true
\endexample

\>`InfoGroup' V

is the info class for the generic group theoretic functions
(see~"Info Functions").



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Subgroups}

For the general concept of parents and subdomains,
see~"Parents" and~"Constructing Subdomains".
More functions that construct certain subgroups can be found
in the sections~"Normal Structure", "Specific and Parametrized Subgroups",
"Sylow Subgroups and Hall Subgroups",
and~"Subgroups characterized by prime powers".

\>Subgroup( <G>, <gens> ) F
\>SubgroupNC( <G>, <gens> ) F

creates the subgroup <U> of <G> generated by <gens>. The `Parent' of <U>
will be <G>.
The `NC' version does not check, whether the elements in <gens> actually
lie in <G>.


\beginexample
gap> u:=Subgroup(g,[(1,2,3),(1,2)]);
Group([ (1,2,3), (1,2) ])
\endexample

\>Index( <G>, <U> ) O
\>IndexNC( <G>, <U> ) O

For a subgroup <U> of the group <G>, `Index' returns the index
$[<G>:<U>] = {|<G>| \over |<U>|}$ of <U> in <G>.
The `NC' version does not test whether <U> is contained in <G>.


\beginexample
gap> Index(g,u);
4
\endexample


\>IndexInWholeGroup( <G> ) A

If the family of elements of <G> itself forms a group <P>, this
attribute returns the index of <G> in <P>.


\>AsSubgroup( <G>, <U> ) O

creates a subgroup of <G> which contains the same elements as <U>


\beginexample
gap> v:=AsSubgroup(g,Group((1,2,3),(1,4)));
Group([ (1,2,3), (1,4) ])
gap> Parent(v);
Group([ (1,2,3,4), (1,2) ])
\endexample

\>IsSubgroup( <G>, <U> ) F

`IsSubgroup' returns `true' if <U> is a group that is a subset of the
domain <G>.
This is actually checked by calling `IsGroup( <U> )' and
`IsSubset( <G>, <U> )';
note that special methods for `IsSubset' (see~"IsSubset") are available
that test only generators of <U> if <G> is closed under the group
operations.
So in most cases,
for example whenever one knows already that <U> is a group,
it is better to call only `IsSubset'.


\beginexample
gap> IsSubgroup(g,u);
true
gap> v:=Group((1,2,3),(1,2));
Group([ (1,2,3), (1,2) ])
gap> u=v;
true
gap> IsSubgroup(g,v);
true
\endexample

\>IsNormal( <G>, <U> ) O

returns `true' if the group <G> normalizes the group <U>
and `false' otherwise.

A group <G> *normalizes* a group <U> if and only if for every $g \in <G>$
and $u \in <U>$ the element $u^g$ is a member of <U>.
Note that <U> need not be a subgroup of <G>.


\beginexample
gap> IsNormal(g,u);
false
\endexample

\>IsCharacteristicSubgroup( <G>, <N> ) O

tests whether <N> is invariant under all automorphisms of <G>.

\beginexample
gap> IsCharacteristicSubgroup(g,u);
false
\endexample

\>ConjugateSubgroup( <G>, <g> ) O


\>ConjugateSubgroups( <G>, <U> ) O

returns a list of all images of the group <U> under conjugation action
by <G>.



\>IsSubnormal( <G>, <U> ) O

A subgroup <U> of the group <G> is subnormal if it is contained in a
subnormal series of <G>.


\beginexample
gap> IsSubnormal(g,Group((1,2,3)));
false
gap> IsSubnormal(g,Group((1,2)(3,4)));
true
\endexample

If a group <U> is created as a subgroup of another group <G>, <G>
becomes the parent of <U>. There is no `universal' parent group,
parent-child chains can be arbitrary long. {\GAP} stores the result of some
operations (such as `Normalizer') with the parent as an attribute.


\>SubgroupByProperty( <G>, <prop> ) F

creates a subgroup of <G> consisting of those elements fulfilling
<prop> (which is a tester function).
No test is done whether the property actually defines a subgroup.

Note that currently very little functionality beyond an element test
exists for groups created this way.


\>SubgroupShell( <G> ) F

creates a subgroup of <G> which at this point is not yet specified
further (but will be later, for example by assigning a generating set).


\beginexample
gap> u:=SubgroupByProperty(g,i->3^i=3);
<subgrp of Group([ (1,2,3,4), (1,2) ]) by property>
gap> (1,3) in u; (1,4) in u; (1,5) in u;
false
true
false
gap> GeneratorsOfGroup(u);
[ (1,2), (1,4,2) ]
gap> u:=SubgroupShell(g);
<group>
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Closures of (Sub)groups}

\>ClosureGroup( <G>, <obj> ) O

creates the group generated by the elements of <G> and <obj>.
<obj> can be either an element or a collection of elements,
in particular another group.


\beginexample
gap> g:=SmallGroup(24,12);;u:=Subgroup(g,[g.3,g.4]);
Group([ f3, f4 ])
gap> ClosureGroup(u,g.2);
Group([ f2, f3, f4 ])
gap> ClosureGroup(u,[g.1,g.2]);
Group([ f1, f2, f3, f4 ])
gap> ClosureGroup(u,Group(g.2*g.1));
Group([ f1*f2^2, f3, f4 ])
\endexample

\>ClosureGroupAddElm( <G>, <elm> ) F
\>ClosureGroupCompare( <G>, <elm> ) F
\>ClosureGroupIntest( <G>, <elm> ) F

These three functions together with `ClosureGroupDefault' implement the
main methods for `ClosureGroup' (see~"ClosureGroup").
In the ordering given, they just add <elm> to the generators, remove
duplicates and identity elements, and test whether <elm> is already
contained in <G>.



\>ClosureGroupDefault( <G>, <elm> ) F

This functions returns the closure of the group <G> with the element
<elm>.
If <G> has the attribute `AsSSortedList' then also the result has this
attribute.
This is used to implement the default method for `Enumerator'
(see~"Enumerator") and `EnumeratorSorted' (see~"EnumeratorSorted").



\>ClosureSubgroup( <G>, <obj> ) F
\>ClosureSubgroupNC( <G>, <obj> ) F

For a group <G> that stores a parent group (see~"Parents"),
`ClosureSubgroup' calls `ClosureGroup' (see~"ClosureGroup") with the same
arguments;
if the result is a subgroup of the parent of <G> then the parent of <G>
is set as parent of the result, otherwise an error is raised.
The check whether the result is contained in the parent of <G> is omitted
by the `NC' version. As a wrong parent might imply wrong properties this
version should be used with care.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Expressing Group Elements as Words in Generators}

\index{factorization}
\index{words!in generators}

Using homomorphisms (see chapter~"Group Homomorphisms") is is possible to
express group elements as words in given generators: Create a free group
(see~"FreeGroup") on the correct number of generators and create a
homomorphism from this free group onto the group <G> in whose generators you
want to factorize. Then the preimage of an element of <G> is a word in the
free generators, that will map on this element again.

\>EpimorphismFromFreeGroup( <G> ) A

For a  group <G> with a known generating set, this attribute returns a
homomorphism from a free group that maps the free generators to the
groups generators.

The option ``names'' can be used to prescribe a (print) name
for the free generators.



The following example shows how to decompose elements of $S_4$ in the
generators `(1,2,3,4)' and `(1,2)':

\beginexample
gap> g:=Group((1,2,3,4),(1,2));
Group([ (1,2,3,4), (1,2) ])
gap> hom:=EpimorphismFromFreeGroup(g:names:=["x","y"]);
[ x, y ] -> [ (1,2,3,4), (1,2) ]
gap> PreImagesRepresentative(hom,(1,4));
y^-1*x^-2*y^-1*x^-1*y^-1*x
\endexample

The following example stems from a real request to the {\GAP} Forum. In
September 2000 a {\GAP} user working with puzzles wanted to express the
permutation `(1,2)' as a word as short as possible in particular generators
of the symmetric group $S_{16}$.

\beginexample
gap> perms := [ (1,2,3,7,11,10,9,5), (2,3,4,8,12,11,10,6),
>   (5,6,7,11,15,14,13,9), (6,7,8,12,16,15,14,10) ];;
gap> puzzle := Group( perms );;Size( puzzle );
20922789888000
gap> hom:=EpimorphismFromFreeGroup(puzzle:names:=["a", "b", "c", "d"]);;
gap> word := PreImagesRepresentative( hom, (1,2) );
a^-1*c*b*c^-1*a*b^-1*a^-2*c^-1*a*b^-1*c*b
gap> Length( word );
13
\endexample

% randomization effect is now gone.

\>Factorization( <G>, <elm> ) F

returns a factorization of <elm> as word in the generators of <G> given in
the attribute `GeneratorsOfGroup'. The component `<G>!.factFreeMap'
will contain a map <map> from the group <G> to the free group in which
the word is expressed. The attribute `MappingGeneratorsImages' of this
map gives a list of generators and corresponding letters.

The algorithm used computes all elements of the group to ensure a short
word is found. Therefore this function should *not* be used when the
group <G> has more than a few thousand elements. Because of this, one
should not call this function within algorithms, but use
homomorphisms instead.


\beginexample
gap> G:=SymmetricGroup( 6 );;
gap> r:=(3,4);; s:=(1,2,3,4,5,6);;
gap> # create a subgroup to force the system to use the generators r and s.
gap> H:= Subgroup(G, [ r, s ] );
Group([ (3,4), (1,2,3,4,5,6) ])
gap> Factorization( H, (1,2,3) );
x2*x1*x2*x1*x2^-2
gap> s*r*s*r*s^-2;
(1,2,3)
gap> MappingGeneratorsImages(EpimorphismFromFreeGroup(H));
[ [ x1, x2 ], [ (3,4), (1,2,3,4,5,6) ] ]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Structure Descriptions}

\>StructureDescription( <G> ) A

The method for `StructureDescription' exhibits the structure of the
given group to some extend using the strategy outlined below. The idea
is to return a possibly short string which gives some insight in the
structure of the considered group and can be computed reasonably quickly.

Note that non-isomorphic groups can have the same `StructureDescription',
since the structure description might not exhibit the structure of the
considered group in all detail. However, isomorphic groups in different
representation will always obtain the same structure description.

The `StructureDescription' is a string of the following form:

\begintt
  StructureDescription(<G>) ::=
     1                                 ; trivial group 
   || C<size>                           ; cyclic group
   || A<degree>                         ; alternating group
   || S<degree>                         ; symmetric group
   || D<size>                           ; dihedral group
   || Q<size>                           ; quaternion group
   || QD<size>                          ; quasidihedral group
   || PSL(<n>,<q>)                      ; projective special linear group
   || SL(<n>,<q>)                       ; special linear group
   || GL(<n>,<q>)                       ; general linear group
   || PSU(<n>,<q>)                      ; proj. special unitary group
   || O(2<n>+1,<q>)                     ; orthogonal group, type B
   || O+(2<n>,<q>)                      ; orthogonal group, type D
   || O-(2<n>,<q>)                      ; orthogonal group, type 2D
   || PSp(2<n>,<q>)                     ; proj. special symplectic group
   || Sz(<q>)                           ; Suzuki group
   || Ree(<q>)                          ; Ree group (type 2F or 2G)
   || E(6,<q>) || E(7,<q>) || E(8,<q>)    ; Lie group of exceptional type
   || 2E(6,<q>) || F(4,<q>) || G(2,<q>)
   || 3D(4,<q>)                         ; Steinberg triality group
   || M11 || M12 || M22 || M23 || M24
   || J1 || J2 || J3 || J4 || Co1 || Co2
   || Co3 || Fi22 || Fi23 || Fi24' || Suz
   || HS || McL || He || HN || Th || B
   || M || ON || Ly || Ru                  ; sporadic simple group
   || 2F(4,2)'                          ; Tits group
   || PerfectGroup(<size>,<id>)         ; the indicated group from the
                                       ; library of perfect groups
   || A x B                             ; direct product
   || N : H                             ; semidirect product
   || C(G) . G/C(G) = G' . G/G'         ; non-split extension
                                       ; (equal alternatives and
                                       ; trivial extensions omitted)
   || Phi(G) . G/Phi(G)                 ; non-split extension:
                                       ; Frattini subgroup and
                                       ; Frattini factor group
\endtt

Note that the method chooses *one* possible way of building up
the given group from smaller pieces (others are possible too).

The option ``short'' is recognized -- if this option is set, an
abbreviated output format is used (e.g. `"6x3"' instead of `"C6 x C3"').

If the `Name' attribute is not bound, but `StructureDescription' is,
`View' prints the value of the attribute `StructureDescription'.
The `Print'ed representation of a group is not affected by computing
a `StructureDescription'.

The strategy is

\beginlist
  \item{1.} Lookup in precomputed list, if the order of <G> is not
            larger than 100 and not equal to 64.

  \item{2.} If <G> is abelian: decompose it into cyclic factors
            in ``elementary divisors style'',
            e.g. `"C2 x C3 x C3"' is `"C6 x C3"'.

  \item{3.} Recognize alternating groups, symmetric groups,
            dihedral groups, quasidihedral groups, quaternion groups,
            PSL's, SL's, GL's and simple groups not listed so far
            as basic building blocks.

  \item{4.} Decompose into a direct product of irreducible factors.

  \item{5.} Recognize semidirect products ($N$:$H$), where $N$ is normal.
            Select a pair $N$, $H$ with the following preferences: 
            \beginlist
              \item{1.}  $H$ is abelian

              \item{2.}  $N$ is abelian

              \item{2a.} $N$ has many abelian invariants

              \item{3.}  $N$ is a direct product

              \item{3a.} $N$ has many direct factors

              \item{4.}  $\phi: H \rightarrow$ Aut($N$), 
                         $h \mapsto (n \mapsto n^h)$ is injective.
            \endlist

  \item{6.} Fall back to non-splitting extensions:
            If the centre or the commutator factor group is non-trivial,
            write <G> as Z(<G>).<G>/Z(<G>) resp. <G>'.<G>/<G>'.
            Otherwise if the Frattini subgroup is non-trivial,
            write <G> as $\Phi$(<G>).<G>/$\Phi$(<G>).

  \item{7.} If no decomposition is found (maybe this is not the case for
            any finite group) try to identify <G> in the perfect groups
            library.
            If also this fails return a string describing this situation.
\endlist



\beginexample
gap> l := AllSmallGroups(12);;
gap> List(l,StructureDescription);; l;
[ C3 : C4, C12, A4, D12, C6 x C2 ]
gap> List(AllSmallGroups(40),G->StructureDescription(G:short));
[ "5:8", "40", "5:8", "5:Q8", "4xD10", "D40", "2x(5:4)", "(10x2):2", "20x2",
  "5xD8", "5xQ8", "2x(5:4)", "2^2xD10", "10x2^2" ]
gap> List(AllTransitiveGroups(DegreeAction,6),G->StructureDescription(G:short));
[ "6", "S3", "D12", "A4", "3xS3", "2xA4", "S4", "S4", "S3xS3", "(3^2):4",
  "2xS4", "A5", "(S3xS3):2", "S5", "A6", "S6" ]
gap> StructureDescription(PSL(4,2));
"A8"
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Cosets}

\index{right cosets}

\index{coset}
\>RightCoset( <U>, <g> ) O

returns the right coset of <U> with representative <g>, which is the set
of all elements of the form $ug$ for all $u\in<U>$.  <g> must be an
element of a larger group <G> which contains <U>. 
For element operations such as `in' a right coset behaves like a set of
group elements.

Right cosets are
external orbits for the action of <U> which acts via `OnLeftInverse'. Of
course the action of a larger group <G> on right cosets is via `OnRight'.

\beginexample
gap> u:=Group((1,2,3), (1,2));;
gap> c:=RightCoset(u,(2,3,4));
RightCoset(Group( [ (1,2,3), (1,2) ] ),(2,3,4))
gap> ActingDomain(c);
Group([ (1,2,3), (1,2) ])
gap> Representative(c);
(2,3,4)
gap> Size(c);
6
gap> AsList(c);
[ (2,3,4), (1,4,2), (1,3)(2,4), (2,4), (1,4,2,3), (1,3,4,2) ]
\endexample

\>RightCosets( <G>, <U> ) F
\>RightCosetsNC( <G>, <U> ) O

computes a duplicate free list of right cosets $Ug$ for $g\in<G>$. A set
of representatives for the elements in this list forms a right
transversal of <U> in <G>. (By inverting the representatives one obtains
a list of representatives of the left cosets of $U$.) The NC version
does not check whether <U> is a subgroup of <G>.

\beginexample
gap> RightCosets(g,u);
[ RightCoset(Group( [ (1,2,3), (1,2) ] ),()), 
  RightCoset(Group( [ (1,2,3), (1,2) ] ),(1,3)(2,4)), 
  RightCoset(Group( [ (1,2,3), (1,2) ] ),(1,4)(2,3)), 
  RightCoset(Group( [ (1,2,3), (1,2) ] ),(1,2)(3,4)) ]
\endexample

\>CanonicalRightCosetElement( U, g ) O


returns a ``canonical'' representative of the coset <Ug> which is
independent of the given representative <g>. This can be used to compare
cosets by comparing their canonical representatives. The representative
chosen to be the ``canonical'' one is representation dependent and only
guaranteed to remain the same within one {\GAP} session.


\beginexample
gap> CanonicalRightCosetElement(u,(2,4,3));
(3,4)
\endexample

\>IsRightCoset( <obj> ) C

The category of right cosets.


\index{left cosets}
{\GAP} does not provide left cosets as a separate data type, but as the left
coset $gU$ consists of exactly the inverses of the elements of the right
coset $Ug^{-1}$ calculations with left cosets can be emulated using right
cosets by inverting the representatives.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Transversals}

\>RightTransversal( <G>, <U> ) O

A right transversal $t$ is a list of representatives for the set
$<U> {\setminus} <G>$ of right
cosets (consisting of cosets $Ug$) of $U$ in $G$.

The object returned by `RightTransversal' is not a plain list, but an
object that behaves like an immutable list of length $[<G>{:}<U>]$,
except if <U> is the trivial subgroup of <G>
in which case `RightTransversal' may return the sorted plain list of
coset representatives.

The operation `PositionCanonical(<t>,<g>)', called for a transversal <t>
and an element <g> of <G>, will return the position of the
representative in <t> that lies in the same coset of <U> as the element
<g> does. (In comparison, `Position' will return `fail' if the element
is not equal to the representative.) Functions that implement group
actions such as `Action' or `Permutation' (see Chapter~"Group
Actions") use `PositionCanonical', therefore it is possible to
``act'' on a right transversal to implement the action on the cosets.
This is often much more efficient than acting on cosets.


\beginexample
gap> g:=Group((1,2,3,4),(1,2));;
gap> u:=Subgroup(g,[(1,2,3),(1,2)]);;
gap> rt:=RightTransversal(g,u);
RightTransversal(Group([ (1,2,3,4), (1,2) ]),Group([ (1,2,3), (1,2) ]))
gap> Length(rt);
4
gap> Position(rt,(1,2,3));
fail
\endexample

Note that the elements of a right transversal are not necessarily
``canonical'' in the sense of `CanonicalRightCosetElement'
(see~"CanonicalRightCosetElement"), but we may compute a list of
canonical coset representatives by calling that function.

\beginexample
gap> List(RightTransversal(g,u),i->CanonicalRightCosetElement(u,i));
[ (), (2,3,4), (1,2,3,4), (3,4) ]
\endexample

The operation `PositionCanonical' is described in
section~"PositionCanonical".

\beginexample
gap> PositionCanonical(rt,(1,2,3));
1
gap> rt[1];
()
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Double Cosets}

\>DoubleCoset( <U>, <g>, <V> ) O

The groups <U> and <V> must be subgroups of a common supergroup <G> of
which <g> is an element. This command constructs the double coset <UgV>
which is the set of all elements of the form $ugv$ for any $u\in<U>$,
$v\in<V>$.  For element operations such as `in', a double coset behaves
like a set of group elements. The double coset stores <U> in the
attribute `LeftActingGroup', <g> as `Representative', and <V> as
`RightActingGroup'.

\>RepresentativesContainedRightCosets( <D> ) A

A double coset <UgV> can be considered as an union of right cosets
$<U>h_i$.  (it is the union of the orbit of $<Ug>$ under right
multiplication by $V$.) For a double coset <D>=<UgV> this returns a set
of representatives $h_i$ such that $<D>=\bigcup_{h_i}<U>h_i$. The
representatives returned are canonical for <U> (see
"CanonicalRightCosetElement") and form a set.

\beginexample
gap> u:=Subgroup(g,[(1,2,3),(1,2)]);;v:=Subgroup(g,[(3,4)]);;
gap> c:=DoubleCoset(u,(2,4),v);
DoubleCoset(Group( [ (1,2,3), (1,2) ] ),(2,4),Group( [ (3,4) ] ))
gap> (1,2,3) in c;
false
gap> (2,3,4) in c;
true
gap> LeftActingGroup(c);
Group([ (1,2,3), (1,2) ])
gap> RightActingGroup(c);
Group([ (3,4) ])
gap> RepresentativesContainedRightCosets(c);
[ (2,3,4) ]
\endexample

\>DoubleCosets( <G>, <U>, <V> )!{operation} O
\>DoubleCosetsNC( <G>, <U>, <V> )!{operation} O

computes a duplicate free list of all double cosets <UgV> for $<g>\in<G>$.
<U> and <V> must be subgroups of the group <G>.
The NC version does not check whether <U> and <V> are both subgroups
of <G>.


\beginexample
gap> dc:=DoubleCosets(g,u,v);
[ DoubleCoset(Group( [ (1,2,3), (1,2) ] ),(),Group( [ (3,4) ] )), 
  DoubleCoset(Group( [ (1,2,3), (1,2) ] ),(1,3)(2,4),Group( [ (3,4) ] )), 
  DoubleCoset(Group( [ (1,2,3), (1,2) ] ),(1,4)(2,3),Group( [ (3,4) ] )) ]
gap> List(dc,Representative);
[ (), (1,3)(2,4), (1,4)(2,3) ]
\endexample

\>IsDoubleCoset( <obj> ) C

The category of double cosets.

\>DoubleCosetRepsAndSizes( <G>, <U>, <V> ) O

returns a list of double coset representatives and their sizes, the
entries are lists of the form $[<rep>,<size>]$. This operation is faster
that `DoubleCosetsNC' because no double coset objects have to be
created.

\beginexample
gap> dc:=DoubleCosetRepsAndSizes(g,u,v);
[ [ (), 12 ], [ (1,3)(2,4), 6 ], [ (1,4)(2,3), 6 ] ]
\endexample

\>`InfoCoset' V

The information function for coset and double coset operations is
`InfoCoset'.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Conjugacy Classes}

\>ConjugacyClass( <G>, <g> ) O

creates the conjugacy class in $G$ with representative $g$.
This class is an external set, so functions such as
`Representative' (which returns <g>),
`ActingDomain' (which returns <G>),
`StabilizerOfExternalSet' (which returns the centralizer of <g>)
and `AsList' work for it.

A conjugacy class is an external orbit ("ExternalOrbit") of group
elements with the group acting by conjugation on it. Thus element tests
or operation representatives can be computed.  The attribute
`Centralizer' gives the centralizer of the representative (which is the
same result as `StabilizerOfExternalSet'). (This is a slight abuse of
notation: This is *not* the centralizer of the class as a *set* which
would be the standard behaviour of `Centralizer'.)


\>ConjugacyClasses( <G> )!{attribute} A

returns the conjugacy classes of elements of <G> as a list of
`ConjugacyClass'es of <G> (see~`ConjugacyClass'
("ConjugacyClass") for details). It is guaranteed that the class of the
identity is in the first position, the further arrangement depends on
the method chosen (and might be different for equal but not identical
groups).

For very small groups (of size up to 500) the classes will be computed
by the conjugation action of <G> on itself
(see~"ConjugacyClassesByOrbits"). This can be deliberately switched off
using the ``{`noaction'}'' option shown below.

For solvable groups, the default method to compute the classes is by
homomorphic lift
(see section~"Conjugacy Classes in Solvable Groups").

For other groups the method of \cite{HulpkeClasses} is employed.

`ConjugacyClasses' supports the following options that can be used to
modify this strategy:
\beginitems
`random'&The classes are computed by  random search. See
`ConjugacyClassesByRandomSearch' ("ConjugacyClassesByRandomSearch")
below.

`action'&The classes are computed by action of <G> on itself See
`ConjugacyClassesByOrbits' ("ConjugacyClassesByOrbits")
below.

`noaction'&Even for small groups
`ConjugacyClassesByOrbits' ("ConjugacyClassesByOrbits")
is not used as a default. This can be useful if the elements of the
group use a lot of memory.
\enditems


\beginexample
gap> g:=SymmetricGroup(4);;
gap> cl:=ConjugacyClasses(g);
[ ()^G, (1,2)^G, (1,2)(3,4)^G, (1,2,3)^G, (1,2,3,4)^G ]
gap> Representative(cl[3]);Centralizer(cl[3]);
(1,2)(3,4)
Group([ (1,2), (1,3)(2,4), (3,4) ])
gap> Size(Centralizer(cl[5]));
4
gap> Size(cl[2]);
6
\endexample

In general, you will not need to have to influence the method, but simply
call `ConjugacyClasses' -- GAP will try to select a suitable method on its
own. The method specifications are provided here mainly for expert use. 

\>ConjugacyClassesByRandomSearch( <G> ) F

computes the classes of the group <G> by random search.
This works very efficiently for almost simple groups.

This function is also accessible via the option `random' to
`ConjugacyClass'.

\>ConjugacyClassesByOrbits( <G> ) F

computes the classes of the group <G> as orbits of <G> on its elements.
This can be quick but unsurprisingly may also take a lot of memory if
<G> becomes larger. All the classes will store their element list and
thus a membership test will be quick as well.

This function is also accessible via the option `action' to
`ConjugacyClass'.


Typically, for small groups (roughly of order up to $10^3$) the computation
of classes as orbits under the action is fastest; memory restrictions (and
the increasing cost of eliminating duplicates) make this less efficient for
larger groups.

Calculation by random search has the smallest memory requirement, but in
generally performs worse, the more classes are there.

The folowing example shows the effect of this for a small group with many
classes:

% this example is time and load-status dependent. No point in testing
\begintt
gap> h:=Group((4,5)(6,7,8),(1,2,3)(5,6,9));;ConjugacyClasses(h:noaction);;time;
110
gap> h:=Group((4,5)(6,7,8),(1,2,3)(5,6,9));;ConjugacyClasses(h:random);;time;
300
gap> h:=Group((4,5)(6,7,8),(1,2,3)(5,6,9));;ConjugacyClasses(h:action);;time;
30
\endtt

\>NrConjugacyClasses( <G> ) A

returns the number of conjugacy classes of <G>.


\beginexample
gap> g:=Group((1,2,3,4),(1,2));;
gap> NrConjugacyClasses(g);
5
\endexample

\>RationalClass( <G>, <g> ) O

creates the rational class in $G$ with representative $g$.
A rational class consists of all elements that are conjugate to
$g$ or to a power $g^i$ where $i$ is coprime to the order of $g$. Thus a
rational class can be interpreted as a conjugacy class of cyclic
subgroups.  A rational class is an external set ("IsExternalSet") of
group elements with the group acting by conjugation on it, but not an
external orbit.


\>RationalClasses( <G> ) A

returns a list of the rational classes of the group <G>. (See
"RationalClass".)


\beginexample
gap> RationalClasses(DerivedSubgroup(g));
[ RationalClass( AlternatingGroup( [ 1 .. 4 ] ), () ), 
  RationalClass( AlternatingGroup( [ 1 .. 4 ] ), (1,2)(3,4) ), 
  RationalClass( AlternatingGroup( [ 1 .. 4 ] ), (1,2,3) ) ]
\endexample
\>GaloisGroup( <ratcl> )!{of rational class of a group} A

Suppose that <ratcl> is a rational class of a group <G> with
representative <g>.
The exponents $i$  for which $<g>^i$ lies  already in the ordinary
conjugacy  class of  <g>, form a  subgroup of the *prime residue class
group* $P_n$ (see "PrimitiveRootMod"), the so-called *Galois group*  of
the rational class. The prime residue class group $P_n$ is obtained in
{\GAP}  as `Units( Integers mod <n> )', the  unit group of a residue
class ring. The Galois group of a rational class <rcl> is stored in the
attribute `GaloisGroup(<rcl>)' as a subgroup of this group.


\>IsConjugate( <G>, <x>, <y> ) O
\>IsConjugate( <G>, <U>, <V> ) O

tests whether the elements <x> and <y> or the subgroups <U> and <V> are
conjugate under the action of <G>. (They do not need to be contained in
<G>.) This command is only a shortcut to
`RepresentativeAction'.


\beginexample
gap> IsConjugate(g,Group((1,2,3,4),(1,3)),Group((1,3,2,4),(1,2)));
true
\endexample

`RepresentativeAction' (see~"RepresentativeAction") can be used to
obtain conjugating elements.
\beginexample
gap> RepresentativeAction(g,(1,2),(3,4));
(1,3)(2,4)
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Normal Structure}

For the operations `Centralizer' and `Centre', see Chapter~"Magmas".
\index{normalizer}
\>Normalizer( <G>, <U> ) O
\>Normalizer( <G>, <g> ) O

Computes the normalizer $N_G(U)$, that is the stabilizer of $U$ under
the conjugation action of $G$.
The second form computes $N_G(\langle g\rangle)$.


\beginexample
gap> Normalizer(g,Subgroup(g,[(1,2,3)]));
Group([ (1,2,3), (2,3) ])
\endexample

\>Core( <S>, <U> ) O

If <S> and <U> are groups of elements in the same family, this
operation
returns the core of <U> in <S>, that is the intersection of all
<S>-conjugates of <U>.


\beginexample
gap> g:=Group((1,2,3,4),(1,2));;
gap> Core(g,Subgroup(g,[(1,2,3,4)]));
Group(())
\endexample

\>PCore( <G>, <p> ) F

\atindex{O_p(G)!see PCore}{@$O_p(G)$!see \noexpand`PCore'}
The *$p$-core* of <G> is the largest normal $p$-subgroup of <G>. It is the
core of a $p$-Sylow subgroup of <G>.


\beginexample
gap> PCore(g,2);
Group([ (1,4)(2,3), (1,2)(3,4) ])
\endexample

\>NormalClosure( <G>, <U> ) O

The normal closure of <U> in <G> is the smallest normal subgroup of <G>
which contains <U>.


\beginexample
gap> NormalClosure(g,Subgroup(g,[(1,2,3)]));
Group([ (1,2,3), (2,3,4) ])
\endexample

\>NormalIntersection( <G>, <U> ) O

computes the intersection of <G> and <U>, assuming that <G> is normalized
by <U>. This works faster than `Intersection', but will not produce the
intersection if <G> is not normalized by <U>.

\beginexample
gap> NormalIntersection(Group((1,2)(3,4),(1,3)(2,4)),Group((1,2,3,4)));
Group([ (1,3)(2,4) ])
\endexample

\>Complementclasses( <G>, <N> ) O

Let <N> be a normal subgroup of <G>. This command returns a set of
representatives for the conjugacy classes of complements of <N> in <G>.
Complements are subgroups <U> of <G> which intersect trivially with <N>
and together with <N> generate <G>.

At the moment only methods for a solvable <N> are available.

\beginexample
gap> Complementclasses(g,Group((1,2)(3,4),(1,3)(2,4)));
[ Group([ (3,4), (2,4,3) ]) ]
\endexample

\>`InfoComplement' V

Info class for the complement routines.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Specific and Parametrized Subgroups}

The Centre of a group (the subgroup of those elements that commute with all
other elements of the group) can be computed by the operation `Centre'
(see~"Centre").

\>TrivialSubgroup( <G> ) A


\beginexample
gap> TrivialSubgroup(g);
Group(())
\endexample

\>CommutatorSubgroup( <G>, <H> ) O

If <G> and <H> are two groups of elements in the same family, this
operation returns the group generated by all commutators
$[ g, h ] = g^{-1} h^{-1} g h$ (see~"Comm") of elements $g \in <G>$ and
$h \in <H>$, that is the group
$\left\langle [ g, h ] \mid g \in <G>, h \in <H> \right\rangle$.


\beginexample
gap> CommutatorSubgroup(Group((1,2,3),(1,2)),Group((2,3,4),(3,4)));
Group([ (1,4)(2,3), (1,3,4) ])
gap> Size(last);
12
\endexample

\>DerivedSubgroup( <G> ) A

The derived subgroup $G'$ of $G$ is the subgroup generated by all
commutators of pairs of elements of $G$. It is normal in $G$ and the
factor group $G/G'$ is the largest abelian factor group of $G$.


\beginexample
gap> DerivedSubgroup(g);
Group([ (1,3,2), (2,4,3) ])
\endexample

\>CommutatorLength( <G> ) A

returns the minimal number $n$ such that each element
in the derived subgroup (see~"DerivedSubgroup") of the group <G> can be
written as a product of (at most) $n$ commutators of elements in <G>.


\beginexample
gap> CommutatorLength( g );
1
\endexample

\>FittingSubgroup( <G> ) A

The Fitting subgroup of a group <G> is its largest nilpotent normal
subgroup.


\beginexample
gap> FittingSubgroup(g);
Group([ (1,2)(3,4), (1,4)(2,3) ])
\endexample

\>FrattiniSubgroup( <G> ) A

The Frattini subgroup of a group <G> is the intersection of all maximal
subgroups of <G>.


\beginexample
gap> FrattiniSubgroup(g);
Group(())
\endexample

\>PrefrattiniSubgroup( <G> ) A

returns a Prefrattini subgroup of the finite solvable group <G>.
A factor $M/N$ of $G$ is called a Frattini factor if $M/N \leq
\phi(G/N)$ holds.  The group $P$ is a Prefrattini subgroup of $G$ if $P$
covers each Frattini chief factor  of $G$, and  if for each  maximal
subgroup  of $G$ there exists a conjugate maximal subgroup, which
contains $P$.   In a finite solvable group $G$ the Prefrattini subgroups
form a characteristic conjugacy class of subgroups and the intersection
of all these subgroups is the Frattini subgroup of $G$.


\beginexample
gap> G := SmallGroup( 60, 7 );
<pc group of size 60 with 4 generators>
gap> P := PrefrattiniSubgroup(G);
Group([ f2 ])
gap> Size(P);
2
gap> IsNilpotent(P);
true
gap> Core(G,P);
Group([  ])
gap> FrattiniSubgroup(G);
Group([  ])
\endexample

\>PerfectResiduum( <G> ) A

is the smallest normal subgroup of <G> that has a solvable factor group.


\beginexample
gap> PerfectResiduum(Group((1,2,3,4,5),(1,2)));
Group([ (1,3,2), (2,4,3), (3,5,4) ])
\endexample

\>RadicalGroup( <G> ) A

is the radical of <G>, i.e., the largest solvable normal subgroup of <G>.


\beginexample
gap> RadicalGroup(SL(2,5));
<group of 2x2 matrices of size 2 in characteristic 5>
gap> Size(last);
2
\endexample

\>Socle( <G> ) A

The socle of the group <G> is the subgroup generated by
all minimal normal subgroups.


\beginexample
gap> Socle(g);
Group([ (1,4)(2,3), (1,2)(3,4) ])
\endexample

\>SupersolvableResiduum( <G> ) A

is the supersolvable residuum of the group <G>, that is,
its smallest normal subgroup $N$ such that the factor group $<G> / N$ is
supersolvable.


\beginexample
gap> SupersolvableResiduum(g);
Group([ (1,3)(2,4), (1,4)(2,3) ])
\endexample

\>PRump( <G>, <p> ) F

The *$p$-rump* of a group $G$ is the subgroup $G' G^p$ for a prime $p$.



*@example missing!@*


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Sylow Subgroups and Hall Subgroups}

\>SylowSubgroup( <G>, <p> ) F

returns a Sylow $p$ subgroup of the finite group <G>.
This is a $p$-subgroup of <G> whose index in <G> is coprime to $p$.
`SylowSubgroup' computes Sylow subgroups via the operation
`SylowSubgroupOp'.


\beginexample
gap> g:=SymmetricGroup(4);;
gap> SylowSubgroup(g,2);
Group([ (1,2), (3,4), (1,3)(2,4) ])
\endexample

With respect to the following {\GAP} functions,
please note that by theorems of P.~Hall,
a group $G$ is solvable if and only if one of the following conditions holds.
\beginlist%ordered
\item{1.}
    For each prime $p$ dividing the order of $G$,
    there exists a $p$-complement (see~"SylowComplement").
\item{2.}
    For each set $P$ of primes dividing the order of $G$,
    there exists a $P$-Hall subgroup (see~"HallSubgroup").
\item{3.}
    $G$ has a Sylow system (see~"SylowSystem").
\item{4.}
    $G$ has a complement system (see~"ComplementSystem").
\endlist

\>SylowComplement( <G>, <p> ) F

returns a $p$-Sylow complement of the finite group <G>. This is a
subgroup <U> of order coprime to $p$ such that the index $[G:U]$ is a
$p$-power.
At the moment methods exist only if <G> is solvable and {\GAP} will
issue an error if <G> is not solvable.


\beginexample
gap> SylowComplement(g,3);
Group([ (3,4), (1,4)(2,3), (1,3)(2,4) ])
\endexample

\>HallSubgroup( <G>, <P> ) F

computes a $P$-Hall subgroup for a set $P$ of primes.
This is a subgroup the order of which is only divisible by primes in $P$
and whose index is coprime to all primes in $P$.
The function computes Hall subgroups via the operation `HallSubgroupOp'.
At the moment methods exist only if <G> is solvable and {\GAP} will
issue an error if <G> is not solvable.


\beginexample
gap> h:=SmallGroup(60,10);;
gap> u:=HallSubgroup(h,[2,3]);
Group([ f1, f2, f3 ])
gap> Size(u);
12
\endexample

\>SylowSystem( <G> ) A

A Sylow system of a group <G> is a set of Sylow subgroups of <G> such
that every pair of Sylow subgroups from this set commutes as subgroups.
Sylow systems exist only for solvable groups. The operation returns
`fail' if the group <G> is not solvable.


\beginexample
gap> h:=SmallGroup(60,10);;
gap> SylowSystem(h);
[ Group([ f1, f2 ]), Group([ f3 ]), Group([ f4 ]) ]
gap> List(last,Size);
[ 4, 3, 5 ]
\endexample

\>ComplementSystem( <G> ) A

A complement system of a group <G> is a set of Hall-$p'$-subgroups of
<G>, where $p'$ runs through the subsets of prime factors of $|<G>|$
that omit exactly one prime.
Every pair of subgroups from this set commutes as subgroups.
Complement systems exist only for solvable groups, therefore
`ComplementSystem' returns `fail' if the group <G> is not solvable.


\beginexample
gap> ComplementSystem(h);
[ Group([ f3, f4 ]), Group([ f1, f2, f4 ]), Group([ f1, f2, f3 ]) ]
gap> List(last,Size);
[ 15, 20, 12 ]
\endexample

\>HallSystem( <G> ) A

returns a list containing one Hall-$P$ subgroup for each set $P$ of primes
which occur in the order of <G>.
Hall systems exist only for solvable groups. The operation returns
`fail' if the group <G> is not solvable.


\beginexample
gap> HallSystem(h);
[ Group([  ]), Group([ f1, f2 ]), Group([ f1, f2, f3 ]), 
  Group([ f1, f2, f3, f4 ]), Group([ f1, f2, f4 ]), Group([ f3 ]), 
  Group([ f3, f4 ]), Group([ f4 ]) ]
gap> List(last,Size);
[ 1, 4, 12, 60, 20, 3, 15, 5 ]
\endexample

%%  The methods for Sylow subgroups in polycyclic groups and for Hall
%%  Systems are due to Bettina Eick.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Subgroups characterized by prime powers}

\>Omega( <G>, <p>[, <n>] ) F

For a <p>-group <G>, one defines
$\Omega_{<n>}(<G>) = \{ g\in <G> \mid g^{<p>^{<n>}} = 1 \}$.
The default value for <n> is `1'.

*@At the moment methods exist only for abelian <G> and <n>=1.@*


\beginexample
gap> h:=SmallGroup(16,10);
<pc group of size 16 with 4 generators>
gap> Omega(h,2);
Group([ f4, f2, f3 ])
\endexample

\>Agemo( <G>, <p>[, <n>] ) F

For a <p>-group <G>, one defines
$\mho_{<n>}(G) = \langle g^{<p>^{<n>}} \mid g\in <G> \rangle$.
The default value for <n> is `1'.


\beginexample
gap> Agemo(h,2);Agemo(h,2,2);
Group([ f4 ])
Group([  ])
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Group Properties}

Some properties of groups can be defined not only for groups but also for
other structures.
For example, nilpotency and solvability make sense also for algebras.
Note that these names refer to different definitions for groups and
algebras, contrary to the situation with finiteness or commutativity.
In such cases, the name of the function for groups got a suffix `Group'
to distinguish different meanings for different structures.

\>IsCyclic( <G> ) P

A group is *cyclic* if it can be generated by one element.
For a cyclic group, one can compute a generating set consisting of only
one element using `MinimalGeneratingSet' (see~"MinimalGeneratingSet").


\>IsElementaryAbelian( <G> ) P

A group <G> is elementary abelian if it is commutative and if there is a
prime $p$ such that the order of each element in <G> divides $p$.


\>IsNilpotentGroup( <G> ) P

A group is *nilpotent* if the lower central series
(see~"LowerCentralSeriesOfGroup" for a definition) reaches the trivial
subgroup in a finite number of steps.


\>NilpotencyClassOfGroup( <G> ) A

The nilpotency class of a nilpotent group <G> is the number of steps in
the lower central series of <G> (see "LowerCentralSeriesOfGroup");

If <G> is not nilpotent an error is issued.


\>IsPerfectGroup( <G> ) P

A group is *perfect* if it equals its derived subgroup
(see~"DerivedSubgroup").


\>IsSolvableGroup( <G> ) P

A group is *solvable* if the derived series (see~"DerivedSeriesOfGroup"
for a definition)
reaches the trivial subgroup in a finite number of steps.

For finite groups this is the same as being polycyclic
(see~"IsPolycyclicGroup"),
and each polycyclic group is solvable,
but there are infinite solvable groups that are not polycyclic.


\>IsPolycyclicGroup( <G> ) P

A group is polycyclic if it has a subnormal series with cyclic factors.
For finite groups this is the same as if the group is solvable
(see~"IsSolvableGroup").


\>IsSupersolvableGroup( <G> ) P

A finite group is *supersolvable* if it has a normal series with cyclic
factors.


\>IsMonomialGroup( <G> ) P

A finite group is *monomial* if every irreducible complex character is
induced from a linear character of a subgroup.



\>IsSimpleGroup( <G> ) P

A group is *simple* if it is nontrivial and has no nontrivial normal
subgroups.


\>IsomorphismTypeInfoFiniteSimpleGroup( <G> ) F

For a finite simple group <G>, `IsomorphismTypeInfoFiniteSimpleGroup'
returns a record with components `series', `name' and possibly `parameter',
describing the isomorphism type of <G>.
The component `name' is a string that gives name(s) for <G>,
and `series' is a string that describes the following series.

(If different characterizations of <G> are possible only one is given by
`series' and `parameter', while `name' may give several names.)
\beginlist
\item{`"A"'} Alternating groups, `parameter' gives the natural degree.

\item{`"L"'} Linear groups (Chevalley type $A$),
             `parameter' is a list [<n>,<q>] that indicates $L(n,q)$.

\item{`"2A"'} Twisted Chevalley type ${}^2A$,
              `parameter' is a list [<n>,<q>] that indicates ${}^2A(n,q)$.

\item{`"B"'} Chevalley type $B$,
             `parameter' is a list [<n>,<q>] that indicates $B(n,q)$.

\item{`"2B"'} Twisted Chevalley type ${}^2B$,
              `parameter' is a value <q> that indicates ${}^2B(2,q)$.

\item{`"C"'} Chevalley type $C$,
             `parameter' is a list [<n>,<q>] that indicates $C(n,q)$.

\item{`"D"'} Chevalley type $D$,
             `parameter' is a list [<n>,<q>] that indicates $D(n,q)$.

\item{`"2D"'} Twisted Chevalley type ${}^2D$,
              `parameter' is a list [<n>,<q>] that indicates ${}^2D(n,q)$.

\item{`"3D"'} Twisted Chevalley type ${}^3D$,
              `parameter' is a value <q> that indicates ${}^3D(4,q)$.

\item{`"E"'} Exceptional Chevalley type $E$,
             `parameter' is a list [<n>,<q>] that indicates $E_n(q)$.
             The value of <n> is 6,7 or 8.

\item{`"2E"'} Twisted exceptional Chevalley type $E_6$,
              `parameter' is a value <q> that indicates ${}^2E_6(q)$.

\item{`"F"'} Exceptional Chevalley type $F$,
             `parameter' is a value <q> that indicates $F(4,q)$.

\item{`"2F"'} Twisted exceptional Chevalley type ${}^2F$ (Ree groups),
              `parameter' is a value <q> that indicates ${}^2F(4,q)$.

\item{`"G"'} Exceptional Chevalley type $G$,
             `parameter' is a value <q> that indicates $G(2,q)$.

\item{`"2G"'} Twisted exceptional Chevalley type ${}^2G$ (Ree groups),
              `parameter' is a value <q> that indicates ${}^2G(2,q)$.

\item{`"Spor"'} Sporadic groups, `name' gives the name.

\item{`"Z"'} Cyclic groups of prime size, `parameter' gives the size.
\endlist

An equal sign in the name denotes different naming schemes for the same
group, a tilde sign abstract isomorphisms between groups constructed in a
different way.


\beginexample
gap> IsomorphismTypeInfoFiniteSimpleGroup(Group((4,5)(6,7),(1,2,4)(3,5,6)));
rec( series := "L", parameter := [ 2, 7 ], 
  name := "A(1,7) = L(2,7) ~ B(1,7) = O(3,7) ~ C(1,7) = S(2,7) ~ 2A(1,7) = U(2\
,7) ~ A(2,2) = L(3,2)" )
\endexample

\>IsFinitelyGeneratedGroup( <G> ) P

tests whether the group <G> can be generated by a finite number of
generators. (This property is mainly used to obtain finiteness
conditions.)

Note that this is a pure existence statement. Even if a group is known
to be generated by a finite number of elements, it can be very hard or
even impossible to obtain such a generating set if it is not known.


\>IsSubsetLocallyFiniteGroup( <U> ) P

A group is called locally finite if every finitely generated subgroup is
finite. This property checks whether the group <U> is a subset of a
locally finite group. This is used to check whether finite generation
will imply finiteness, as it does for example for permutation groups.



\atindex{p-group}{@$p$-group}
\>IsPGroup( <G> ) P

A *$p$-group* is a finite group whose order (see~"Size") is of the form
$p^n$ for a prime integer $p$ and a nonnegative integer $n$.
`IsPGroup' returns `true' if <G> is a $p$-group, and `false' otherwise.


\>PrimePGroup( <G> ) A

If <G> is a nontrivial $p$-group (see~"IsPGroup"), `PrimePGroup' returns
the prime integer $p$;
if <G> is trivial then `PrimePGroup' returns `fail'.
Otherwise an error is issued.


\>PClassPGroup( <G> ) A

The $p$-class of a $p$-group <G> (see~"IsPGroup")
is the length of the lower $p$-central series (see~"PCentralSeries")
of <G>.
If <G> is not a $p$-group then an error is issued.


\>RankPGroup( <G> ) A

For a $p$-group <G> (see~"IsPGroup"), `RankPGroup' returns the *rank* of
<G>, which is defined as the minimal size of a generating system of <G>.
If <G> is not a $p$-group then an error is issued.


\beginexample
gap> h:=Group((1,2,3,4),(1,3));;
gap> PClassPGroup(h);
2
gap> RankPGroup(h);
2
\endexample

Note that the following functions, although they are mathematical
properties, are not properties in the sense of {\GAP} (see~"Attributes" and
"Properties"), as they depend on a parameter.

\>IsPSolvable( <G>, <p> ) F

A group is $p$-solvable if every chief factor is either not divisible
by $p$ or solvable.

*@Currently no method is installed!@*



\>IsPNilpotent( <G>, <p> ) F

A group is $p$-nilpotent if it possesses a normal $p$-complement.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Numerical Group Attributes}

\>AbelianInvariants( <G> )!{for groups} A

returns the abelian invariants (also sometimes called primary
decomposition) of the commutator factor group of the
group <G>. These are given as a list of prime-powers or zeroes and
describe the
structure of $G/G'$ as a direct product of cyclic groups of prime power
(or infinite) order.

(See "IndependentGeneratorsOfAbelianGroup" to obtain actual generators).


\beginexample
gap> g:=Group((1,2,3,4),(1,2),(5,6));;
gap> AbelianInvariants(g);
[ 2, 2 ]
\endexample

\>Exponent( <G> ) A

The exponent $e$ of a group <G> is the lcm of the orders of its
elements, that is, $e$ is the smallest integer such that $g^e=1$ for all
$g\in G$


\beginexample
gap> Exponent(g);
12
\endexample

Again the
following are mathematical attributes, but not {\GAP} `Attributes' as
they are depending on a parameter:

\>EulerianFunction( <G>, <n> ) O

returns the  number  of <n>-tuples $(g_1, g_2,  \ldots g_n)$ of elements
of the group <G>  that  generate the  whole group <G>.
The elements of an <n>-tuple need not be different. If the Library of 
Tables of Marks (see Chapter "Tables of Marks") covers the group <G>,
you may also use `EulerianFunctionByTom' (see "EulerianFunctionByTom").


\beginexample
gap> EulerianFunction(g,2);
432
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Subgroup Series}

In group theory many subgroup series are considered,
and {\GAP} provides commands to compute them.
In the following sections, there is always a series
$G = U_1 > U_2 > \cdots > U_m = \langle 1 \rangle$ of subgroups considered.
A series also may stop without reaching $G$ or $\langle1\rangle$.

A series is called *subnormal* if every $U_{i+1}$ is normal in $U_i$.

A series is called *normal* if every $U_i$ is normal in $G$.

A series of normal subgroups is called *central* if $U_i/U_{i+1}$ is
central in $G/U_{i+1}$.

We call a series *refinable* if intermediate subgroups can be added to
the series without destroying the properties of the series.

Unless explicitly declared otherwise, all subgroup series are descending.
That is they are stored in decreasing order.


\>ChiefSeries( <G> ) A

is a series of normal subgroups of <G> which cannot be refined further.
That is there is no normal subgroup $N$ of <G> with $U_i > N > U_{i+1}$.
This attribute returns *one* chief series (of potentially many
possibilities).


\beginexample
gap> g:=Group((1,2,3,4),(1,2));;
gap> ChiefSeries(g);
[ Group([ (1,2,3,4), (1,2) ]), Group([ (2,4,3), (1,4)(2,3), (1,3)(2,4) ]), 
  Group([ (1,4)(2,3), (1,3)(2,4) ]), Group(()) ]
\endexample

\>ChiefSeriesThrough( <G>, <l> ) O

is a chief series of the group <G> going through the normal subgroups in
the list <l>. <l> must be a list of normal subgroups of <G> contained in
each other, sorted by descending size.  This attribute returns *one*
chief series (of potentially many possibilities).



\>ChiefSeriesUnderAction( <H>, <G> ) O

returns a series of normal subgroups of <G> which are invariant under
<H> such that the series cannot be refined any further. <G> must be
a subgroup of <H>.
This attribute returns *one* such series (of potentially many
possibilities).



\>SubnormalSeries( <G>, <U> ) O

If <U> is a subgroup of <G> this operation returns a subnormal series
that descends from <G> to a subnormal subgroup <V>$\ge$<U>. If <U> is
subnormal, <V>=<U>.

\beginexample
gap> s:=SubnormalSeries(g,Group((1,2)(3,4)));
[ Group([ (1,2,3,4), (1,2) ]), Group([ (1,2)(3,4), (1,4)(2,3) ]), 
  Group([ (1,2)(3,4) ]) ]
\endexample

\>CompositionSeries( <G> ) A

A composition series is a subnormal series which cannot be refined.
This attribute returns *one* composition series (of potentially many
possibilities).



\>DisplayCompositionSeries( <G> ) F

Displays a composition series of <G> in a nice way, identifying the
simple factors.


\beginexample
gap> CompositionSeries(g);
[ Group([ (3,4), (2,4,3), (1,4)(2,3), (1,3)(2,4) ]), 
  Group([ (2,4,3), (1,4)(2,3), (1,3)(2,4) ]), 
  Group([ (1,4)(2,3), (1,3)(2,4) ]), Group([ (1,3)(2,4) ]), Group(()) ]
gap> DisplayCompositionSeries(Group((1,2,3,4,5,6,7),(1,2)));
G (2 gens, size 5040)
 || Z(2)
S (5 gens, size 2520)
 || A(7)
1 (0 gens, size 1)
\endexample

\>DerivedSeriesOfGroup( <G> ) A

The derived series of a group is obtained by $U_{i+1}=U_i'$. It stops
if $U_i$ is perfect.


\>DerivedLength( <G> ) A

The derived length of a group is the number of steps in the derived
series. (As there is always the group, it is the series length minus 1.)


\beginexample
gap> List(DerivedSeriesOfGroup(g),Size);
[ 24, 12, 4, 1 ]
gap> DerivedLength(g);
3
\endexample

\>ElementaryAbelianSeries( <G> ) A
\>ElementaryAbelianSeriesLargeSteps( <G> ) A
\>ElementaryAbelianSeries( [<G>, <NT1>, <NT2>, ...] ) A

returns a series of normal subgroups of $G$ such that all factors are
elementary abelian. If the group is not solvable (and thus no such series
exists) it returns `fail'.

The variant `ElementaryAbelianSeriesLargeSteps' tries to make the steps
in this series large (by eliminating intermediate subgroups if possible)
at a small additional cost.

In the third variant, an elementary abelian series through the given
series of normal subgroups is constructed.


\beginexample
gap> List(ElementaryAbelianSeries(g),Size);
[ 24, 12, 4, 1 ]
\endexample

\>InvariantElementaryAbelianSeries( <G>, <morph>[, <N> [, <fine>]] ) O

For a (solvable) group <G> and a list of automorphisms <morph> of <G>,
this command finds a normal series of <G> with elementary abelian
factors such that every group in this series is invariant under every
automorphism in <morph>.

If a normal subgroup <N> of <G> which is invariant under <morph> is
given, this series is chosen to contain <N>. No tests are performed to
check the validity of the arguments.

The series obtained will be constructed to prefer large steps unless
<fine> is given as `true'.


\beginexample
gap> g:=Group((1,2,3,4),(1,3));
Group([ (1,2,3,4), (1,3) ])
gap> hom:=GroupHomomorphismByImages(g,g,GeneratorsOfGroup(g),
> [(1,4,3,2),(1,4)(2,3)]);
[ (1,2,3,4), (1,3) ] -> [ (1,4,3,2), (1,4)(2,3) ]
gap> InvariantElementaryAbelianSeries(g,[hom]);
[ Group([ (1,2,3,4), (1,3) ]), Group([ (1,3)(2,4) ]), Group(()) ]
\endexample

\>LowerCentralSeriesOfGroup( <G> ) A

The lower central series of a group <G> is defined as $U_{i+1}:=[G,U_i]$.
It is a central series of normal subgroups.
The name derives from the fact that $U_i$ is contained in the $i$-th
step subgroup of any central series.



\>UpperCentralSeriesOfGroup( <G> ) A

The upper central series of a group <G> is defined as an ending series
$U_i/U_{i+1}:=Z(G/U_{i+1})$.
It is a central series of normal subgroups.
The name derives from the fact that $U_i$ contains every $i$-th step
subgroup of a central series.



\>PCentralSeries( <G>, <p> ) F

The $p$-central series of $G$ is defined by $U_1:=G$,
$U_i:=[G,U_{i-1}]U_{i-1}^p$.



\>JenningsSeries( <G> ) A

For a $p$-group <G>, this function returns its Jennings series.
This series is defined by setting
$G_1=G$ and for $i\geq 0$, $G_{i+1}=[G_i,G]G_j^p$, where $j$ is the
smallest integer $\geq i/p$.



\>DimensionsLoewyFactors( <G> ) A

This operation computes the dimensions of the factors of the Loewy
series of <G>. (See \cite{Hup82}, p. 157 for the slightly complicated
definition of the Loewy Series.)

The dimensions are computed via the `JenningsSeries' without computing
the Loewy series itself.


\beginexample
gap> G:= SmallGroup( 3^6, 100 );
<pc group of size 729 with 6 generators>
gap> JenningsSeries( G );
[ <pc group of size 729 with 6 generators>, Group([ f3, f4, f5, f6 ]), 
  Group([ f4, f5, f6 ]), Group([ f5, f6 ]), Group([ f5, f6 ]), 
  Group([ f5, f6 ]), Group([ f6 ]), Group([ f6 ]), Group([ f6 ]), 
  Group([ <identity> of ... ]) ]
gap> DimensionsLoewyFactors(G);
[ 1, 2, 4, 5, 7, 8, 10, 11, 13, 14, 16, 17, 19, 20, 22, 23, 25, 26, 27, 27, 
  27, 27, 27, 27, 27, 27, 27, 26, 25, 23, 22, 20, 19, 17, 16, 14, 13, 11, 10, 
  8, 7, 5, 4, 2, 1 ]
\endexample

\>AscendingChain( <G>, <U> ) F

This function computes an ascending chain of subgroups from <U> to <G>.
This chain is given as a list whose first entry is <U> and the last entry
is <G>. The function tries to make the links in this chain small.

The option `refineIndex' can be used to give a bound for refinements of
steps to avoid {\GAP} trying to enforce too small steps.



\>IntermediateGroup( <G>, <U> ) F

This routine tries to find a subgroup <E> of <G>, such that $G>E>U$. If
$U$ is
maximal, it returns `fail'. This is done by finding minimal blocks for
the operation of <G> on the right cosets of <U>.



\>IntermediateSubgroups( <G>, <U> ) O

returns a list of all subgroups of <G> that properly contain <U>; that
is all subgroups between <G> and <U>. It returns a record with
components `subgroups' which is a list of these subgroups as well as a
component `inclusions' which lists all maximality inclusions among these
subgroups.
A maximality inclusion is given as a list `[<i>,<j>]' indicating that
subgroup number <i> is a maximal subgroup of subgroup number <j>, the
numbers 0 and 1+length(`subgroups') are used to denote <U> and <G>
respectively.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Factor Groups}

\>NaturalHomomorphismByNormalSubgroup( <G>, <N> ) F
\>NaturalHomomorphismByNormalSubgroupNC( <G>, <N> ) F

returns a homomorphism from <G> to another group whose kernel is <N>.
{\GAP} will try to select the image group as to make computations in it
as efficient as possible. As the factor group $<G>/<N>$ can be identified
with the image of <G> this permits efficient computations in the factor
group. The homomorphism returned is not necessarily surjective, so
`ImagesSource' should be used instead of `Range' to get a group
isomorphic to the factor group.
The `NC' variant does not check whether <N> is normal in <G>.


\>FactorGroup( <G>, <N> ) F
\>FactorGroupNC( <G>, <N> ) O

returns the image of the `NaturalHomomorphismByNormalSubgroup(<G>,<N>)'.
The `NC' version does not test whether <N> is normal in <G>.


\beginexample
gap> g:=Group((1,2,3,4),(1,2));;n:=Subgroup(g,[(1,2)(3,4),(1,3)(2,4)]);;
gap> hom:=NaturalHomomorphismByNormalSubgroup(g,n);
[ (1,2,3,4), (1,2) ] -> [ f1*f2, f1 ]
gap> Size(ImagesSource(hom));
6
gap> FactorGroup(g,n);
Group([ f1, f2 ])
\endexample
\>CommutatorFactorGroup( <G> ) A

computes the commutator factor group $<G>/<G>^{\prime}$ of the group <G>.


\beginexample
gap> CommutatorFactorGroup(g);
Group([ f1 ])
\endexample

\>MaximalAbelianQuotient( <grp> ) A

returns an epimorphism from <grp> onto the maximal abelian quotient of
<grp>. The kernel of this epimorphism is the derived subgroup.


\>HasAbelianFactorGroup( <G>, <N> ) O

tests whether $G/N$ is abelian (without explicitly
constructing the factor group).


\>HasElementaryAbelianFactorGroup( <G>, <N> ) O

tests whether $G/N$ is elementary abelian (without explicitly
constructing the factor group).


\beginexample
gap> HasAbelianFactorGroup(g,n);
false
gap> HasAbelianFactorGroup(DerivedSubgroup(g),n);
true
\endexample

\>CentralizerModulo( <G>, <N>, <elm> ) O

Computes the full preimage of the centralizer $C_{G/N}(elm\cdot N)$ in
<G> (without necessarily constructing the factor group).


\beginexample
gap> CentralizerModulo(g,n,(1,2));
Group([ (3,4), (1,3)(2,4), (1,4)(2,3) ])
\endexample

%%  The code for factor groups is due to Alexander Hulpke and Heiko Thei{\ss}en.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Sets of Subgroups}

\>ConjugacyClassSubgroups( <G>, <U> ) O

generates the conjugacy class of subgroups of <G> with representative
<U>.  This class is an external set, so functions such as `Representative',
(which returns <U>), `ActingDomain' (which returns <G>),
`StabilizerOfExternalSet' (which returns the normalizer of <U>), and
`AsList' work for it.

(The use the `[]'
list access to select elements of the class is considered obsolescent
and will be removed in future versions. Use `ClassElementLattice'
instead.)

\beginexample
gap> g:=Group((1,2,3,4),(1,2));;IsNaturalSymmetricGroup(g);;
gap> cl:=ConjugacyClassSubgroups(g,Subgroup(g,[(1,2)]));
Group( [ (1,2) ] )^G
gap> Size(cl);
6
gap> ClassElementLattice(cl,4);
Group([ (2,3) ])
\endexample

\>IsConjugacyClassSubgroupsRep( <obj> ) R
\>IsConjugacyClassSubgroupsByStabilizerRep( <obj> ) R

Is the representation {\GAP} uses for conjugacy classes of subgroups. It
can be used to check whether an object is a class of subgroups.
The second representation `IsConjugacyClassSubgroupsByStabilizerRep' in
addition is an external orbit by stabilizer and will compute its
elements via a transversal of the stabilizer.


\>ConjugacyClassesSubgroups( <G> ) A

This attribute returns a list of all conjugacy classes of subgroups of
the group <G>.
It also is applicable for lattices of subgroups (see~"LatticeSubgroups").
The order in which the classes are listed depends on the method chosen by
{\GAP}.
For each class of subgroups, a representative can be accessed using
`Representative' (see~"Representative").


\beginexample
gap> ConjugacyClassesSubgroups(g);
[ Group( () )^G, Group( [ (1,3)(2,4) ] )^G, Group( [ (3,4) ] )^G, 
  Group( [ (2,4,3) ] )^G, Group( [ (1,4)(2,3), (1,3)(2,4) ] )^G, 
  Group( [ (1,2)(3,4), (3,4) ] )^G, Group( [ (1,2)(3,4), (1,3,2,4) ] )^G, 
  Group( [ (3,4), (2,4,3) ] )^G, Group( [ (1,3)(2,4), (1,4)(2,3), (1,2) ] )^G,
  Group( [ (1,3)(2,4), (1,4)(2,3), (2,4,3) ] )^G, 
  Group( [ (1,3)(2,4), (1,4)(2,3), (2,4,3), (1,2) ] )^G ]
\endexample

\>ConjugacyClassesMaximalSubgroups( <G> ) A

returns the conjugacy classes of maximal subgroups of <G>.
Representatives of the classes can be computed directly by
`MaximalSubgroupClassReps' (see "MaximalSubgroupClassReps").


\beginexample
gap> ConjugacyClassesMaximalSubgroups(g);
[ AlternatingGroup( [ 1 .. 4 ] )^G, Group( [ (1,2,3), (1,2) ] )^G, 
  Group( [ (1,2), (3,4), (1,3)(2,4) ] )^G ]
\endexample

\>MaximalSubgroupClassReps( <G> ) A

returns a list of conjugacy representatives of the maximal subgroups
of <G>.


\beginexample
gap> MaximalSubgroupClassReps(g);
[ Alt( [ 1 .. 4 ] ), Group([ (1,2,3), (1,2) ]), 
  Group([ (1,2), (3,4), (1,3)(2,4) ]) ]
\endexample

\>MaximalSubgroups( <G> ) A

returns a list of all maximal subgroups of <G>. This may take up much
space, therefore the command should be avoided if possible. See
"ConjugacyClassesMaximalSubgroups".


\beginexample
gap> MaximalSubgroups(Group((1,2,3),(1,2)));
[ Group([ (1,2,3) ]), Group([ (2,3) ]), Group([ (1,2) ]), Group([ (1,3) ]) ]
\endexample

\>NormalSubgroups( <G> ) A

returns a list of all normal subgroups of <G>.


\beginexample
gap> g:=SymmetricGroup(4);;NormalSubgroups(g);
[ Group(()), Group([ (1,4)(2,3), (1,3)(2,4) ]), 
  Group([ (2,4,3), (1,4)(2,3), (1,3)(2,4) ]), Sym( [ 1 .. 4 ] ) ]
\endexample
The algorithm used for the computation of normal subgroups of permutation
groups and pc groups is described in \cite{Hulpke98}.

\>MaximalNormalSubgroups( <G> ) A

is a list containing those proper normal subgroups of the group <G>
that are maximal among the proper normal subgroups.


\beginexample
gap> MaximalNormalSubgroups( g );
[ Group([ (2,4,3), (1,4)(2,3), (1,3)(2,4) ]) ]
\endexample

\>MinimalNormalSubgroups( <G> ) A

is a list containing those nontrivial normal subgroups of the group <G>
that are minimal among the nontrivial normal subgroups.


\beginexample
gap> MinimalNormalSubgroups( g );
[ Group([ (1,2)(3,4), (1,3)(2,4) ]) ]
\endexample

%%  Bettina Eick designed and wrote the code for maximal subgroups of a solvable
%%  group. The code for normal subgroups \cite{Hulpke98} and for subgroups of a
%%  solvable group is due to Alexander Hulpke.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Subgroup Lattice}

The {\GAP} package \package{XGAP} permits a graphical display of the lattice
of subgroups in a nice way.

\>LatticeSubgroups( <G> ) A

computes the lattice of subgroups of the group <G>.  This lattice has
the conjugacy classes of subgroups as attribute
`ConjugacyClassesSubgroups' (see~"ConjugacyClassesSubgroups") and
permits one to test maximality/minimality relations.


\beginexample
gap> g:=SymmetricGroup(4);;
gap> l:=LatticeSubgroups(g);
<subgroup lattice of Sym( [ 1 .. 4 ] ), 11 classes, 30 subgroups>
gap> ConjugacyClassesSubgroups(l);
[ Group( () )^G, Group( [ (1,3)(2,4) ] )^G, Group( [ (3,4) ] )^G, 
  Group( [ (2,4,3) ] )^G, Group( [ (1,4)(2,3), (1,3)(2,4) ] )^G, 
  Group( [ (1,2)(3,4), (3,4) ] )^G, Group( [ (1,2)(3,4), (1,3,2,4) ] )^G,
  Group( [ (3,4), (2,4,3) ] )^G, Group( [ (1,3)(2,4), (1,4)(2,3), (1,2) ] )^G,
  Group( [ (1,3)(2,4), (1,4)(2,3), (2,4,3) ] )^G, 
  Group( [ (1,3)(2,4), (1,4)(2,3), (2,4,3), (1,2) ] )^G ]
\endexample
\>ClassElementLattice( <C>, <n> ) O

For a class <C> of subgroups, obtained by a lattice computation, this
operation returns the <n>-th conjugate subgroup in the class.

*Because of other
methods installed, `AsList(C)' can give a different arrangement
of the class elements!*


\>MaximalSubgroupsLattice( <lat> ) A

For a lattice <lat> of subgroups this attribute contains the maximal
subgroup relations among the subgroups of the lattice. It is a list,
corresponding to the `ConjugacyClassesSubgroups' of the lattice, each entry
giving a list of the maximal subgroups of the representative of this class.
Every maximal subgroup is indicated by a list of the form [<cls>,<nr>] which
means that the <nr>st subgroup in class number <cls> is a maximal subgroup
of the representative. 

The number <nr> corresponds to access via `ClassElementLattice'
and *not* necessarily the `AsList' arrangement!
See also "MinimalSupergroupsLattice".

\beginexample
gap> MaximalSubgroupsLattice(l);
[ [  ], [ [ 1, 1 ] ], [ [ 1, 1 ] ], [ [ 1, 1 ] ], 
  [ [ 2, 1 ], [ 2, 2 ], [ 2, 3 ] ], [ [ 3, 1 ], [ 3, 6 ], [ 2, 3 ] ], 
  [ [ 2, 3 ] ], [ [ 4, 1 ], [ 3, 1 ], [ 3, 2 ], [ 3, 3 ] ],
  [ [ 7, 1 ], [ 6, 1 ], [ 5, 1 ] ], 
  [ [ 5, 1 ], [ 4, 1 ], [ 4, 2 ], [ 4, 3 ], [ 4, 4 ] ], 
  [ [ 10, 1 ], [ 9, 1 ], [ 9, 2 ], [ 9, 3 ], [ 8, 1 ], [ 8, 2 ], [ 8, 3 ], 
      [ 8, 4 ] ] ]
gap> last[6];
[ [ 3, 1 ], [ 3, 6 ], [ 2, 3 ] ]
gap> u1:=Representative(ConjugacyClassesSubgroups(l)[6]);
Group([ (1,2)(3,4), (3,4) ])
gap> u2:=ClassElementLattice(ConjugacyClassesSubgroups(l)[3],1);;
gap> u3:=ClassElementLattice(ConjugacyClassesSubgroups(l)[3],6);;
gap> u4:=ClassElementLattice(ConjugacyClassesSubgroups(l)[2],3);;
gap> IsSubgroup(u1,u2);IsSubgroup(u1,u3);IsSubgroup(u1,u4);
true
true
true
\endexample

\>MinimalSupergroupsLattice( <lat> ) A

For a lattice <lat> of subgroups this attribute contains the minimal
supergroup relations among the subgroups of the lattice. It is a list,
corresponding to the `ConjugacyClassesSubgroups' of the lattice, each entry
giving a list of the minimal supergroups of the representative of this
class. Every minimal supergroup is indicated by a list of the
form [<cls>,<nr>] which means that the <nr>st subgroup in class number
<cls> is a minimal supergroup
of the representative.

The number <nr> corresponds to access via `ClassElementLattice'
and *not* necessarily the `AsList' arrangement!
See also "MaximalSubgroupsLattice".

\beginexample
gap> MinimalSupergroupsLattice(l);
[ [ [ 2, 1 ], [ 2, 2 ], [ 2, 3 ], [ 3, 1 ], [ 3, 2 ], [ 3, 3 ], [ 3, 4 ], 
      [ 3, 5 ], [ 3, 6 ], [ 4, 1 ], [ 4, 2 ], [ 4, 3 ], [ 4, 4 ] ], 
  [ [ 5, 1 ], [ 6, 2 ], [ 7, 2 ] ], [ [ 6, 1 ], [ 8, 1 ], [ 8, 3 ] ], 
  [ [ 8, 1 ], [ 10, 1 ] ], [ [ 9, 1 ], [ 9, 2 ], [ 9, 3 ], [ 10, 1 ] ],
  [ [ 9, 1 ] ], [ [ 9, 1 ] ], [ [ 11, 1 ] ], [ [ 11, 1 ] ], [ [ 11, 1 ] ], 
  [  ] ]
gap> last[3];
[ [ 6, 1 ], [ 8, 1 ], [ 8, 3 ] ]
gap> u5:=ClassElementLattice(ConjugacyClassesSubgroups(l)[8],1);
Group([ (3,4), (2,4,3) ])
gap> u6:=ClassElementLattice(ConjugacyClassesSubgroups(l)[8],3);
Group([ (1,3), (1,3,4) ])
gap> IsSubgroup(u5,u2);
true
gap> IsSubgroup(u6,u2);
true
\endexample

\>RepresentativesPerfectSubgroups( <G> ) A
\>RepresentativesSimpleSubgroups( <G> ) A

returns a list of conjugacy representatives of perfect (respectively
simple) subgroups of <G>.
This uses the library of perfect groups (see "PerfectGroup"), thus it
will issue an error if the library is insufficient to determine all
perfect subgroups.


\beginexample
gap> m11:=TransitiveGroup(11,6);
M(11)
gap> r:=RepresentativesPerfectSubgroups(m11);
[ Group([ (3,5,8)(4,11,7)(6,9,10), (2,3)(4,10)(5,9)(8,11) ]),
  Group([ (1,2,4)(5,11,8)(6,9,7), (2,3)(4,10)(5,9)(8,11) ]),
  Group([ (3,4,10)(5,11,6)(7,9,8), (1,4,9)(3,6,10)(7,11,8) ]),
  Group([ (1,2,5)(3,11,10)(6,7,8), (2,3)(4,10)(5,9)(8,11) ]), M(11),
  Group(()) ]
gap> List(r,Size);
[ 60, 60, 360, 660, 7920, 1 ]
\endexample

\>ConjugacyClassesPerfectSubgroups( <G> ) A

returns a list of the conjugacy classes of perfect subgroups of <G>.
(see "RepresentativesPerfectSubgroups".)


\beginexample
gap> ConjugacyClassesPerfectSubgroups(m11);
[ Group( [ ( 3, 5, 8)( 4,11, 7)( 6, 9,10), ( 2, 3)( 4,10)( 5, 9)( 8,11) ] )^G,
  Group( [ ( 1, 2, 4)( 5,11, 8)( 6, 9, 7), ( 2, 3)( 4,10)( 5, 9)( 8,11) ] )^G,
  Group( [ ( 3, 4,10)( 5,11, 6)( 7, 9, 8), ( 1, 4, 9)( 3, 6,10)( 7,11, 8)
     ] )^G,
  Group( [ ( 1, 2, 5)( 3,11,10)( 6, 7, 8), ( 2, 3)( 4,10)( 5, 9)( 8,11) ] )^G,
  M(11)^G, Group( () )^G ]
\endexample

\>Zuppos( <G> ) A

The *Zuppos* of a group are the cyclic subgroups of prime power order.
(The name ``Zuppo'' derives from the German abbreviation for ``zyklische
Untergruppen von Primzahlpotenzordnung''.) This attribute
gives generators of all such subgroups of a group <G>. That is all elements
of <G> of prime power order up to the equivalence that they generate the
same cyclic subgroup.


\>`InfoLattice' V

is the information class used by the cyclic extension methods for
subgroup lattice calculations.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Specific Methods for Subgroup Lattice Computations}

\>LatticeByCyclicExtension( <G>[, <func>[, <noperf>]] ) F

computes the lattice of <G> using the cyclic extension algorithm. If the
function <func> is given, the algorithm will discard all subgroups not
fulfilling <func> (and will also not extend them), returning a partial
lattice. This can be useful to compute only subgroups with certain
properties. Note however that this will *not* necessarily yield all
subgroups that fulfill <func>, but the subgroups whose subgroups are used
for the construction must also fulfill <func> as well.
(In fact the filter <func> will simply discard subgroups in the cyclic
extension algorithm. Therefore the trivial subgroup will always be
included.) Also note, that for such a partial lattice
maximality/minimality inclusion relations cannot be computed.

The cyclic extension algorithm requires the perfect subgroups of <G>.
However {\GAP} cannot analyze the function <func> for its implication
but can only apply it. If it is known that <func> implies solvability,
the computation of the perfect subgroups can be avoided by giving a
third parameter <noperf> set to `true'. 


\beginexample
gap> g:=WreathProduct(Group((1,2,3),(1,2)),Group((1,2,3,4)));;
gap> l:=LatticeByCyclicExtension(g,function(G)
> return Size(G) in [1,2,3,6];end);
<subgroup lattice of <permutation group of size 5184 with 9 generators>, 
47 classes, 2628 subgroups, restricted under further condition l!.func>
\endexample

The total number of classes in this example is much bigger, as the
following example shows:
\beginexample
gap> LatticeSubgroups(g);
<subgroup lattice of <permutation group of size 5184 with 9 generators>, 
566 classes, 27134 subgroups>
\endexample

\>InvariantSubgroupsElementaryAbelianGroup( <G>, <homs>[, <dims>] ) F

Let <G> be an elementary abelian group (that is a vector space) and <homs>
a set of automorphisms of <G>. Then this function computes all subspaces of
<G> which are invariant under all automorphisms in <homs>. When considering
<G> as a module for the algebra generated by <homs>, these are all
submodules.
If <homs> is empty, it computes all subspaces. 
If the optional parameter <dims> is given, only subspaces of this
dimension are computed.


\beginexample
gap> g:=Group((1,2,3),(4,5,6),(7,8,9));
Group([ (1,2,3), (4,5,6), (7,8,9) ])
gap> hom:=GroupHomomorphismByImages(g,g,[(1,2,3),(4,5,6),(7,8,9)],
> [(7,8,9),(1,2,3),(4,5,6)]);
[ (1,2,3), (4,5,6), (7,8,9) ] -> [ (7,8,9), (1,2,3), (4,5,6) ]
gap> u:=InvariantSubgroupsElementaryAbelianGroup(g,[hom]);
[ Group(()), Group([ (1,2,3)(4,5,6)(7,8,9) ]), 
  Group([ (1,3,2)(7,8,9), (1,3,2)(4,5,6) ]), 
  Group([ (7,8,9), (4,5,6), (1,2,3) ]) ]
\endexample

\>SubgroupsSolvableGroup( <G>[, <opt>] ) F

This function (implementing the algorithm published in \cite{Hulpke99})
computes subgroups of a solvable group <G>, using the homomorphism
principle. It returns a list of representatives up to <G>-conjugacy.

The optional argument <opt> is a record, which may
be used to put restrictions on the subgroups computed. The following record
components of <opt> are recognized and have the following effects:
\beginitems
`actions'&must be a list of automorphisms of <G>. If given, only groups
which are invariant under all these automorphisms are computed. The
algorithm must know the normalizer in <G> of the group generated by
`actions' (defined formally by embedding in the semidirect product of
<G> with <actions>). This can be given in the component `funcnorm' and
will be computed if this component is not given.

`normal'&if set to `true' only normal subgroups are guaranteed to be
returned (though some of the returned subgroups might still be not
normal).

`consider'&a function to restrict the groups computed. This must be a
function of five parameters, <C>,<A>,<N>,<B>,<M>, that are interpreted
as follows: The arguments are subgroups of a factor $F$ of $G$ in the
relation $F\ge C>A>N>B>M$. $N$ and $M$ are normal subgroups. <C> is the
full preimage of the normalizer of <A>/<N> in <F>/<N>. When computing
modulo <M> and looking for subgroups <U> such that $U\cap N=B$ and
$\langle U,N\rangle=A$, this function is called. If it returns `false'
all potential groups <U> (and therefore all groups later arising from
them) are disregarded. This can be used for example to compute only
subgroups of certain sizes. 

(*This is just a restriction to speed up computations. The function may
still return (invariant) subgroups which don't fulfill this condition!*)
This parameter is used to permit calculations of some subgroups if the
set of all subgroups would be too large to handle.

The actual groups <C>, <A>, <N> and <B> which are passed to this
function are not necessarily subgroups of <G> but might be subgroups of
a proper factor group <F>=<G>/<H>. Therefore the `consider' function may
not relate the parameter groups to <G>.

`retnorm'&if set to `true' the function not only returns a list <subs>
of subgroups but also a corresponding list <norms> of normalizers in the
form [<subs>,<norms>].

`series'&is an elementary abelian series of <G> which will be used for
the computation.

`groups'&is a list of groups to seed the calculation. Only subgroups of
these groups are constructed.
\enditems


\beginexample
gap> g:=Group((1,2,3),(1,2),(4,5,6),(4,5),(7,8,9),(7,8));
Group([ (1,2,3), (1,2), (4,5,6), (4,5), (7,8,9), (7,8) ])
gap> hom:=GroupHomomorphismByImages(g,g,
> [(1,2,3),(1,2),(4,5,6),(4,5),(7,8,9),(7,8)],
> [(4,5,6),(4,5),(7,8,9),(7,8),(1,2,3),(1,2)]);
[ (1,2,3), (1,2), (4,5,6), (4,5), (7,8,9), (7,8) ] -> 
[ (4,5,6), (4,5), (7,8,9), (7,8), (1,2,3), (1,2) ]
gap> l:=SubgroupsSolvableGroup(g,rec(actions:=[hom]));;
gap> List(l,Size);
[ 1, 3, 9, 27, 54, 2, 6, 18, 108, 4, 216, 8 ]
gap> Length(ConjugacyClassesSubgroups(g)); # to compare
162
\endexample

\>SizeConsiderFunction( <size> ) F

This function returns a function <consider> of four arguments that can be
used in `SubgroupsSolvableGroup' (see "SubgroupsSolvableGroup") for
the option `consider' to compute subgroups whose sizes are divisible by
<size>.


\beginexample
gap> l:=SubgroupsSolvableGroup(g,rec(actions:=[hom],
> consider:=SizeConsiderFunction(6)));;
gap> List(l,Size);
[ 1, 3, 9, 27, 54, 6, 18, 108, 216 ]
\endexample
This example shows that in general the `consider' function does not provide
a perfect filter. It is guaranteed that all subgroups fulfilling the
condition are returned, but not all subgroups returned necessarily fulfill
the condition.

\>ExactSizeConsiderFunction( <size> ) F

This function returns a function <consider> of four arguments that can be
used in `SubgroupsSolvableGroup' (see "SubgroupsSolvableGroup") for
the option `consider' to compute subgroups whose sizes are exactly
<size>.


\beginexample
gap> l:=SubgroupsSolvableGroup(g,rec(actions:=[hom],
> consider:=ExactSizeConsiderFunction(6)));;
gap> List(l,Size);
[ 1, 3, 9, 27, 54, 6, 108, 216 ]
\endexample
Again, the `consider' function does not provide
a perfect filter. It is guaranteed that all subgroups fulfilling the
condition are returned, but not all subgroups returned necessarily fulfill
the condition.

\>`InfoPcSubgroup' V

Information function for the subgroup lattice functions using pcgs.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Special Generating Sets}

\>GeneratorsSmallest( <G> ) A

returns a ``smallest'' generating set for the group <G>. This is the
lexicographically (using {\GAP}s order of group elements) smallest list
$l$ of elements of <G> such that $G=\langle l\rangle$ and
$l_i\not\in\langle l_1,\ldots,l_{i-1}\rangle$ (in particular $l_1$ is
not the one of the group).  The comparison of two groups via
lexicographic comparison of their sorted element lists yields the same
relation as lexicographic comparison of their smallest generating sets.


\beginexample
gap> g:=SymmetricGroup(4);;
gap> GeneratorsSmallest(g);
[ (3,4), (2,3), (1,2) ]
\endexample
\>LargestElementGroup( <G> ) A

returns the largest element of <G> with respect to the ordering `\<' of
the elements family.



\>MinimalGeneratingSet( <G> ) A

returns a generating set of <G> of minimal possible length.


\beginexample
gap> MinimalGeneratingSet(g);
[ (2,4,3), (1,4,2,3) ]
\endexample

\>SmallGeneratingSet( <G> ) A

returns a generating set of <G> which has few elements. As neither
irredundancy, nor minimal length is proven it runs much faster than
`MinimalGeneratingSet'. It can be used whenever a short generating set is
desired which not necessarily needs to be optimal.


\beginexample
gap> SmallGeneratingSet(g);
[ (1,2), (1,2,3,4) ]
\endexample

\>IndependentGeneratorsOfAbelianGroup( <A> ) A

returns a set of generators <g> of prime-power order of the abelian
group <A> such that <A> is the direct product of the cyclic groups
generated by the $g_i$.


\beginexample
gap> g:=AbelianGroup(IsPermGroup,[15,14,22,78]);;
gap> List(IndependentGeneratorsOfAbelianGroup(g),Order);
[ 2, 2, 2, 3, 3, 5, 7, 11, 13 ]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{1-Cohomology}

\index{one cohomology}
\index{cohomology}
\index{cocycles}

Let $G$ be a finite group and  $M$ an elementary abelian normal $p$-subgroup
of $G$.  Then the group  of 1-cocycles $Z^1(  G/M, M  )$ is
defined as
$$
Z^1(G/M, M) = \{ \gamma: G/M \rightarrow M \mid \forall g_1, g_2\in G :
                                 \gamma(g_1 M . g_2 M ) 
                                   = \gamma(g_1 M)^{g_2} . \gamma(g_2 M) \}
$$
and is a $GF(p)$-vector space.

The group of 1-coboundaries $B^1( G/M, M )$ is defined as
$$
B^1(G/M, M) = \{ \gamma : G/M \rightarrow M \mid \exists m\in M
                                 \forall g\in G : 
                                  \gamma(gM) = (m^{-1})^g . m \}
$$
It also is a $GF(p)$-vector space.

Let $\alpha$ be the isomorphism of $M$ into a row vector space ${\cal W}$
and $(g_1,\ldots,g_l)$  representatives for  a  generating set  of $G/M$.
Then  there exists a  monomorphism   $\beta$ of $Z^1( G/M, M )$  in   the
$l$-fold direct sum of ${\cal W}$, such that $\beta( \gamma ) = ( \alpha(
\gamma(g_1 M) ),\ldots, \alpha( \gamma(g_l M) ) )$  for  every $\gamma\in
Z^1( G/M, M )$.

\>OneCocycles( <G>, <M> ) O
\>OneCocycles( <gens>, <M> ) O
\>OneCocycles( <G>, <mpcgs> ) O
\>OneCocycles( <gens>, <mpcgs> ) O

Computes the group of 1-Cocycles $Z^1(<G>/<M>,<M>)$. The normal subgroup
<M> may be given by a (Modulo)Pcgs <mpcgs>. In this case the whole
calculation is performed modulo the normal subgroup defined by the
`DenominatorOfModuloPcgs(<mpcgs>)' (see~"Polycyclic Generating
Systems").  Similarly the group <G> may instead be specified by a set of
elements <gens> that are representatives for a generating system for
the factor group <G>/<M>. If this is done the 1-Cocycles are computed
with respect to these generators (otherwise the routines try to select
suitable generators themselves).

\>OneCoboundaries( <G>, <M> ) O

computes the group of 1-coboundaries. Syntax of input and output
otherwise is the same as with `OneCocycles' except that entries that
refer to cocycles are not computed.


The operations `OneCocycles' and `OneCoboundaries' return a record with
(at least) the components:

\beginitems
`generators'&
Is a list of representatives for a generating set of $G/M$. Cocycles are
represented with respect to these generators.

`oneCocycles'&
A space of row vectors over GF($p$), representing $Z^1$. The vectors are
represented in dimension $a\cdot b$ where $a$ is the length of `generators'
and $p^b$ the size of $M$.

`oneCoboundaries'&
A space of row vectors that represents $B^1$.

`cocycleToList'&
is a function to convert a cocycle (a row vector in `oneCocycles') to
a corresponding list of elements of $M$.

`listToCocycle'&
is a function to convert a list of elements of $M$ to a cocycle.

`isSplitExtension'&
indicates whether $G$ splits over $M$.
The following components are only bound if the extension splits. Note that
if $M$ is given by a modulo pcgs all subgroups are given as subgroups of $G$
by generators corresponding to `generators' and thus may not contain the
denominator of the modulo pcgs. In this case taking the closure with this
denominator will give the full preimage of the complement in the factor
group.

`complement'&
One complement to $M$ in $G$.

`cocycleToComplement(<cyc>)'&
is a function that takes a cocycle from `oneCocycles' and returns the
corresponding complement to $M$ in $G$ (with respect to the fixed complement
`complement').

`complementToCocycle(<U>)'&
is a function that takes a complement and returns the corresponding cocycle.

\enditems

If the factor <G>/<M> is given by a (modulo) pcgs <gens> then special
methods are used that compute a presentation for the factor implicitly from
the pcgs.

Note that the groups of 1-cocycles and 1-coboundaries are not `Group's in
the sense of {\GAP} but vector spaces.

\beginexample
gap> g:=Group((1,2,3,4),(1,2));;
gap> n:=Group((1,2)(3,4),(1,3)(2,4));;
gap> oc:=OneCocycles(g,n);
rec( oneCoboundaries := <vector space over GF(2), with 2 generators>, 
  oneCocycles := <vector space over GF(2), with 2 generators>, 
  generators := [ (3,4), (2,4,3) ], isSplitExtension := true, 
  complement := Group([ (3,4), (2,4,3) ]), 
  cocycleToList := function( c ) ... end, 
  listToCocycle := function( L ) ... end, 
  cocycleToComplement := function( c ) ... end, 
  factorGens := [ (3,4), (2,4,3) ], 
  complementToCocycle := function( K ) ... end )
gap> oc.cocycleToList([ 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0 ]);
[ (1,2)(3,4), (1,2)(3,4) ]
gap> oc.listToCocycle([(),(1,3)(2,4)]);
[ 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2) ]
gap> oc.cocycleToComplement([ 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0 ]);
Group([ (1,2), (1,2,3) ])
gap> oc.cocycleToComplement([ 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2) ]);
Group([ (3,4), (1,3,4) ])
gap> oc.complementToCocycle(Group((1,2,4),(1,4)));
[ 0*Z(2), Z(2)^0, Z(2)^0, Z(2)^0 ]
\endexample

The factor group $H^1(G/M,M)=Z^1(G/M,M)/B^1(G/M,M)$ is called the first
cohomology group. Currently there is no function which explicitly computes
this group. The easiest way to represent it is as a vector space complement to
$B^1$ in $Z^1$.

{}

If the only purpose of the calculation of $H^1$ is the determination of
complements it might be desirable to stop calculations once it is known that
the extension cannot split.  This can be achieved via the more technical
function `OCOneCocycles'.
\>OCOneCocycles( <ocr>, <onlySplit> ) O

is the more technical function to compute 1-cocycles. It takes an record
<ocr> as first argument which must contain at least the components
`group' for $G$ and `modulePcgs' for a (modulo) pcgs of <M>. This record
will also be returned with components as described under `OneCocycles'
(with the exception of `isSplitExtension' which is indicated by the
existence of a `complement')
but components such as `oneCoboundaries' will only be
computed if not already present.

If <onlySplit> is `true', `OneCocyclesOC' returns `false' as soon as
possible if the extension does not split.



\>ComplementclassesEA( <G>, <N> ) O

computes `Complementclasses' to an elementary abelian normal subgroup
<N> via 1-Cohomology. Normally, a user program should call
`Complementclasses' (see~"Complementclasses") instead, which also works
for a solvable (not necessarily elementary abelian) <N>.


\>`InfoCoh' V

The info class for the cohomology calculations is `InfoCoh'.


%%  The computation of the 1-Cohomology follows \cite{CNW90} and was implemented
%%  by Frank Celler and Alexander Hulpke.

% \Section{AutomorphisGroups and Testing Isomorphism}
%T Is dealt with in section on group homomorphisms!


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Schur Covers and Multipliers}

\atindex{Darstellungsgruppe!see EpimorphismSchurCover}%
{@Darstellungsgruppe!see \noexpand`EpimorphismSchurCover'}

\>EpimorphismSchurCover( <G>[, <pl>] ) O

returns an epimorphism <epi> from a group <D> onto <G>. The group <D> is
one (of possibly several) Schur covers of <G>.
The group <D> can be obtained as the `Source' of <epi>. the kernel of
<epi> is the schur multiplier of <G>.
If <pl> is given as a list of primes, only the multiplier part for these
primes is realized.
At the moment, <D> is represented as a finitely presented group.

\>SchurCover( <G> ) O

returns one (of possibly several) Schur covers of <G>.

At the moment this cover is represented as a finitely presented group
and `IsomorphismPermGroup' would be needed to convert it to a
permutation group.

If also the relation to <G> is needed, `EpimorphismSchurCover' should be
used.


\beginexample
gap> g:=Group((1,2,3,4),(1,2));;
gap> epi:=EpimorphismSchurCover(g);
[ f1, f2, f3 ] -> [ (3,4), (2,4,3), (1,4)(2,3) ]
gap> Size(Source(epi));
48
\endexample

If the group becomes bigger, Schur Cover calculations might become
unfeasible.

There is another operation
which only returns the structure of the Multiplier.
% , and which should work
% for larger groups as well.

\>AbelianInvariantsMultiplier( <G> ) A

\index{Multiplier}\atindex{Schur multiplier}{@Schur multiplier}
returns a list of the abelian invariants of the Schur multiplier of <G>.

\beginexample
gap> AbelianInvariantsMultiplier(g);
[ 2 ]
\endexample
%beginexample
% gap> AbelianInvariantsMultiplier(g);
% [ 2 ]
% gap> AbelianInvariantsMultiplier(MathieuGroup(22));
% [ 4, 3 ]
%endexample

Note that the following example will take some time.

%notest
\beginexample
gap> AbelianInvariantsMultiplier(PSU(6,2));
[ 2, 2, 3 ]
\endexample

At the moment, this operation will not give any information about how to
extend the multiplier to a Schur Cover.

Additional attributes and properties of a group can be derived
from computing its Schur Cover. For example, if $G$ is a
finitely presented group, the
derived subgroup a Schur Cover of $G$ is invariant and isomorphic to
the NonabelianExteriorSquare of $G$ \cite{BJR87}.

\>Epicentre( <G> ) A
\>ExteriorCentre( <G> ) A

There are various ways of describing the epicentre of a group. It is
the smallest normal subgroup $N$ of $G$ such that $G/N$ is a central
quotient of a group. It is also equal to the Exterior Center of $G$
\cite{Ellis98}.


\>NonabelianExteriorSquare( <G> ) O

Computes the Nonabelian Exterior Square $G\wedge G$ of a group $G$ 
which for a finitely presented group is the derived subgroup of 
any Schur Cover of $G$ \cite{BJR87}.


\>EpimorphismNonabelianExteriorSquare( <G> ) O

Computes the mapping $G\wedge G \to G$. The kernel of this
mapping is equal to the Schur Multiplicator of $G$.


\>IsCentralFactor( <G> ) P

This method 
determines if there exists a group $H$ such that <G> is isomormorphic 
to the quotient $H/Z(H)$. A group with this property is called in 
literature *capable*.
A group being capable is 
equivalent to the Epicentre of $G$ being trivial \cite{BFS79}.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Tests for the Availability of Methods}

The following filters and operations indicate capabilities of {\GAP}.
They can be used in the method selection or algorithms to check whether
it is feasible to compute certain operations for a given group.
In general, they return `true' if good algorithms for the given arguments
are available in {\GAP}.
An answer `false' indicates that no method for this group may exist,
or that the existing methods might run into problems.

Typical examples when this might happen is with finitely presented
groups, for which many of the methods cannot be guaranteed to succeed in
all situations.

The willingness of {\GAP} to perform certain operations may change,
depending on which further information is known about the arguments.
Therefore the filters used are not implemented as properties but as
``other filters'' (see~"Properties" and~"Other Filters").



\>CanEasilyTestMembership( <grp> ) F

This filter indicates whether a group can test membership of
elements in <grp> (via the operation `in') in reasonable time.
It is used by the method selection to decide whether an algorithm
that relies on membership tests may be used.


\>CanComputeSize( <dom> ) F

This filter indicates whether the size of the domain <dom> (which might
be `infinity') can be computed.

\>CanComputeSizeAnySubgroup( <grp> ) F

This filter indicates whether <grp> can easily compute the size of any
subgroup. (This is for example advantageous if one can test that a
stabilizer index equals the length of the orbit computed so far to stop
early.)


\>CanComputeIndex( <G>, <H> ) F

This filter indicates whether the index $[G:H]$ (which might
be `infinity') can be computed. It assumes that $H\le G$. (see
"CanComputeIsSubset")

\>CanComputeIsSubset( <A>, <B> ) O

This filter indicates that {\GAP} can test (via `IsSubset') whether <B>
is a subset of <A>.

\>KnowsHowToDecompose( <G> ) P
\>KnowsHowToDecompose( <G>, <gens> ) O

Tests whether the group <G> can decompose elements in the generators
<gens>. If <gens> is not given it tests, whether it can decompose in the
generators given in `GeneratorsOfGroup'.

This property can be used for example to check whether a
`GroupHomomorphismByImages' can be reasonably defined from this group.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%E

