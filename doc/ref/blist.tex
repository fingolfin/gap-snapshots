% This file was created automatically from blist.msk.
% DO NOT EDIT!
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%A  blist.msk                  GAP documentation             Martin Schoenert
%%
%A  @(#)$Id: blist.msk,v 1.9 2002/04/15 10:02:27 sal Exp $
%%
%Y  (C) 1998 School Math and Comp. Sci., University of St.  Andrews, Scotland
%Y  Copyright (C) 2002 The GAP Group
%%
\Chapter{Boolean Lists}

This chapter describes boolean lists.   A *boolean list*  is a list  that
has no holes and contains only the boolean values `true'  and `false'
(see Chapter~"Booleans").
In function names we call boolean lists *blist* for brevity.

\>IsBlist( <obj> ) C

A boolean list (``blist'') is a list that has no holes and contains only
`true' and `false'. If a list is known to be a boolean list by a test
with `IsBlist' it is stored in a compact form. See "More about Boolean
Lists".


\beginexample
gap> IsBlist( [ true, true, false, false ] );
true
gap> IsBlist( [] );
true
gap> IsBlist( [false,,true] );  # has holes
false
gap> IsBlist( [1,1,0,0] );      # contains not only boolean values
false
gap> IsBlist( 17 );             # is not even a list
false
\endexample

Boolean lists are lists and all operations for lists are therefore
applicable to boolean lists.

Boolean lists can be used  in various ways, but  maybe the most important
application is their use for the description of *subsets* of finite sets.
Suppose <set>  is a finite set,  represented  as  a list.   Then a subset
<sub>  of <set> is represented  by a boolean  list   <blist>  of the same
length as <set> such that `<blist>[<i>]' is `true'  if `<set>[<i>]' is in
<sub> and `false' otherwise.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Boolean Lists Representing Subsets}

\>BlistList( <list>, <sub> ) F

returns a new boolean list that describes the list <sub> as a sublist of
the dense list <list>.
That is `BlistList' returns a boolean list <blist> of the same length as
<list> such that `<blist>[<i>]' is `true' if `<list>[<i>]' is in
<sub> and `false' otherwise.

<list> need not be a proper set (see~"Sorted Lists and Sets"),
even though in this case `BlistList' is most efficient.
In particular <list> may contain duplicates.
<sub> need not be a proper sublist of <list>,
i.e., <sub> may contain elements that are not in <list>.
Those elements of course have no influence on the result of `BlistList'.


\beginexample
gap> BlistList( [1..10], [2,3,5,7] );
[ false, true, true, false, true, false, true, false, false, false ]
gap> BlistList( [1,2,3,4,5,2,8,6,4,10], [4,8,9,16] );
[ false, false, false, true, false, false, true, false, true, false ]
\endexample

See also~"UniteBlistList".

\>ListBlist( <list>, <blist> ) O

returns the sublist <sub> of the list <list>, which must have no holes,
represented  by the boolean  list <blist>, which  must have the same
length   as  <list>.   <sub> contains  the  element `<list>[<i>]' if
`<blist>[<i>]'     is  `true' and   does    not contain   the element
if `<blist>[<i>]'  is `false'.  The  order of  the elements  in <sub> is
the same as the order of the corresponding elements in <list>.


\beginexample
gap> ListBlist([1..8],[false,true,true,true,true,false,true,true]);
[ 2, 3, 4, 5, 7, 8 ]
gap> ListBlist( [1,2,3,4,5,2,8,6,4,10],
> [false,false,false,true,false,false,true,false,true,false] );
[ 4, 8, 4 ]
\endexample

\>SizeBlist( <blist> ) F

returns  the number of  entries of  the boolean  list <blist> that are
`true'.   This  is the size  of  the subset represented  by  the boolean
list <blist>.


\beginexample
gap> SizeBlist( [ false, true, false, true, false ] );
2
\endexample

\>IsSubsetBlist( <blist1>, <blist2> ) F

returns `true' if  the boolean list  <blist2> is a subset of  the boolean
list <list1>, which  must have equal  length, and `false' otherwise.
<blist2> is  a subset of  <blist1>  if `<blist1>[<i>]   =
<blist1>[<i>] or <blist2>[<i>]' for all <i>.


\beginexample
gap> blist1 := [ true, true, false, false ];;
gap> blist2 := [ true, false, true, false ];;
gap> IsSubsetBlist( blist1, blist2 );
false
gap> blist2 := [ true, false, false, false ];;
gap> IsSubsetBlist( blist1, blist2 );
true
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Set Operations via Boolean Lists}

\>UnionBlist( <blist1>, <blist2>[, ...] ) F
\>UnionBlist( <list> ) F

In the  first form `UnionBlist'  returns the union  of the  boolean
lists <blist1>, <blist2>, etc., which must have equal length.  The
*union* is a new boolean list such that `<union>[<i>] = <blist1>[<i>] or
<blist2>[<i>] or ...'.

The second form takes the union of all blists (which
as for the first form must have equal length) in the list <list>.

\>IntersectionBlist( <blist1>, <blist2>[, ...] ) F
\>IntersectionBlist( <list> ) F

In the first  form `IntersectionBlist'  returns  the intersection  of
the boolean  lists <blist1>, <blist2>,  etc., which  must  have equal
length.  The  *intersection*  is a  new blist such  that
`<inter>[<i>] = <blist1>[<i>] and <blist2>[<i>] and ...'.

In  the  second form <list>   must be a  list of  boolean lists
<blist1>, <blist2>, etc., which   must have equal  length,  and
`IntersectionBlist' returns the intersection of those boolean lists.

\>DifferenceBlist( <blist1>, <blist2> ) F

returns the  asymmetric  set  difference (exclusive or) of the   two
boolean  lists <blist1> and <blist2>, which  must have equal length.
The *asymmetric set difference* is a new boolean list such that
`<union>[<i>] = <blist1>[<i>] and not <blist2>[<i>]'.

\beginexample
gap> blist1 := [ true, true, false, false ];;
gap> blist2 := [ true, false, true, false ];;
gap> UnionBlist( blist1, blist2 );
[ true, true, true, false ]
gap> IntersectionBlist( blist1, blist2 );
[ true, false, false, false ]
gap> DifferenceBlist( blist1, blist2 );
[ false, true, false, false ]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Function that Modify Boolean Lists}

\>UniteBlist( <blist1>, <blist2> ) F

`UniteBlist'   unites the boolean list  <blist1>   with the boolean
list <blist2>,   which must  have the  same  length.    This is
equivalent  to assigning `<blist1>[<i>] := <blist1>[<i>] or
<blist2>[<i>]' for all <i>.  `UniteBlist' returns nothing, it is only
called to change <blist1>.


\beginexample
gap> blist1 := [ true, true, false, false ];;
gap> blist2 := [ true, false, true, false ];;
gap> UniteBlist( blist1, blist2 );
gap> blist1;
[ true, true, true, false ]
\endexample

\>UniteBlistList( <list>, <blist>, <sub> ) F

works like `UniteBlist(<blist>,BlistList(<list>,<sub>))'. As no
intermediate blist is created, the performance is better than the
separate function calls.



The  function  `UnionBlist'   (see "UnionBlist") is   the  nondestructive
counterpart to the procedure `UniteBlist'.

\>IntersectBlist( <blist1>, <blist2> ) F

intersects the  boolean list  <blist1> with the  boolean list <blist2>,
which must have the same  length.  This is  equivalent to assigning
`<blist1>[<i>]:= <blist1>[<i>] and <blist2>[<i>]' for all <i>.
`IntersectBlist' returns nothing, it is only called to change <blist1>.


\beginexample
gap> blist1 := [ true, true, false, false ];;
gap> blist2 := [ true, false, true, false ];;
gap> IntersectBlist( blist1, blist2 );
gap> blist1;
[ true, false, false, false ]
\endexample

The  function `IntersectionBlist'    (see  "IntersectionBlist")   is  the
nondestructive counterpart to the procedure `IntersectBlist'.

\>SubtractBlist( <blist1>, <blist2> ) F

subtracts the boolean list <blist2> from the boolean list <blist1>,
which must have equal length.   This is equivalent to assigning
`<blist1>[<i>] := <blist1>[<i>]  and  not <blist2>[<i>]'  for all
<i>.  `SubtractBlist' returns nothing, it is only called to change
<blist1>.


\beginexample
gap> blist1 := [ true, true, false, false ];;
gap> blist2 := [ true, false, true, false ];;
gap> SubtractBlist( blist1, blist2 );
gap> blist1;
[ false, true, false, false ]
\endexample

The function   `DifferenceBlist'    (see   "DifferenceBlist")    is   the
nondestructive counterpart to the procedure `SubtractBlist'.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{More about Boolean Lists}

We defined a boolean list as a list that has no holes and contains only
`true' and `false'.
There is a special internal representation for boolean lists that needs
only 1 bit for each entry.
This bit is set if the entry is `true' and reset if the entry is `false'.
This representation is of course much more compact than the ordinary
representation of lists, which needs (at least) 32 bits per entry.

%T Add a note about internal representation of plain lists (preferably in
%T the chapter ``Lists''),
%T in order to allow a user to estimate the space needed for
%T computations with lists;
%T then add cross-references from and to the other available list
%T representations!

Not every boolean list is represented in this compact representation. It
would be too much work to test every time a list is changed, whether this
list has become a boolean list.  This section tells you under which
circumstances a   boolean list is represented  in  the compact
representation, so you can write your functions in such a way that you make
best use of the compact representation.

The  results of `BlistList',  `UnionBlist',  `IntersectionBlist' and
`DifferenceBlist' are known to be boolean lists by construction, and thus
are represented in the compact representation upon creation.

If an argument of `IsBlist', `IsSubsetBlist', `ListBlist', `UnionBlist',
`IntersectionBlist', `DifferenceBlist',  `UniteBlist', `IntersectBlist' and
`SubtractBlist' is a list represented in the ordinary representation, it is
tested to see if it is in fact a boolean list. If it is not, `IsBlist'
returns `false' and the other functions signal an error. If it is,  the
representation of the list  is changed to  the compact representation.

If you change a  boolean list that is  represented in  the compact
representation by assignment (see "List Assignment") or `Add' (see "Add")
in such a way that the list remains a boolean list  it will remain
represented in the compact representation.  Note that changing a list
that is not represented in the compact representation, whether it is a
boolean list or not, in such a way that the resulting list becomes a
boolean list, will never change the representation of the list.
