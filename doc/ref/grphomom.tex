% This file was created automatically from grphomom.msk.
% DO NOT EDIT!
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%A  grphomom.msk                GAP documentation            Alexander Hulpke
%%
%A  @(#)$Id: grphomom.msk,v 1.43.2.1 2005/05/03 14:50:38 gap Exp $
%%
%Y  (C) 1998 School Math and Comp. Sci., University of St.  Andrews, Scotland
%Y  Copyright (C) 2002 The GAP Group
%%
\Chapter{Group Homomorphisms}

A group homomorphism is a mapping from one group to another that respects
multiplication and inverses. They are implemented as a special class of
mappings, so in particular all operations for mappings, such as `Image',
`PreImage', `PreImagesRepresentative',
`KernelOfMultiplicativeGeneralMapping', `Source', `Range', `IsInjective' and
`IsSurjective'  (see chapter~"Mappings", in particular section~"Mappings
that Respect Multiplication") are applicable to them.

Homomorphisms can be used to transfer calculations into isomorphic groups in
another representation, for which better algorithms are available.
Section~"Nice Monomorphisms" explains a technique how to enforce this
automatically.

Homomorphisms are also used to represent group automorphisms, and section
"Group Automorphisms" explains explains {\GAP\pif}s facilities to work
with automorphism groups.

The penultimate section of this chapter, "Searching for Homomorphisms", explains
how to make {\GAP} to search for all homomorphisms between two groups which
fulfill certain specifications.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Creating Group Homomorphisms}

The most important way of creating group homomorphisms is to give images for
a set of group generators and to extend it to the group generated by them
by the homomorphism property.

\>GroupHomomorphismByImages( <G>, <H>, <gens>, <imgs> ) F

`GroupHomomorphismByImages' returns the group homomorphism with
source <G> and range <H> that is defined by mapping the list <gens> of
generators of <G> to the list <imgs> of images in <H>.

If <gens> does not generate <G> or if the mapping of the generators does
not extend to a homomorphism
(i.e., if mapping the generators describes only a multi-valued mapping)
then `fail' is returned.

This test can be quite expensive. If one is certain that the mapping of
the generators extends to a homomorphism,
one can avoid the checks by calling `GroupHomomorphismByImagesNC'.
(There also is the possibility to
construct potentially multi-valued mappings with
`GroupGeneralMappingByImages' and to test with `IsMapping' that
they are indeed homomorphisms.)


\>GroupHomomorphismByImagesNC( <G>, <H>, <gensG>, <gensH> ) O

`GroupHomomorphismByImagesNC' creates a homomorphism as
`GroupHomomorphismByImages' does, however it does not test whether
<gens> generates <G> and that the mapping of
<gens> to <imgs> indeed defines a group homomorphism.
Because these tests can be expensive it can be substantially faster than
`GroupHomomorphismByImages'.
Results are unpredictable if the conditions do not hold.

(For creating a possibly multi-valued mapping from <G> to <H> that
respects multiplication and inverses,
`GroupGeneralMappingByImages' can be used.)



\beginexample
gap> gens:=[(1,2,3,4),(1,2)];
[ (1,2,3,4), (1,2) ]
gap> g:=Group(gens);
Group([ (1,2,3,4), (1,2) ])
gap> h:=Group((1,2,3),(1,2));
Group([ (1,2,3), (1,2) ])
gap> hom:=GroupHomomorphismByImages(g,h,gens,[(1,2),(1,3)]);
[ (1,2,3,4), (1,2) ] -> [ (1,2), (1,3) ]
gap> Image(hom,(1,4));
(2,3)
gap> map:=GroupHomomorphismByImages(g,h,gens,[(1,2,3),(1,2)]);
fail
\endexample

\>GroupGeneralMappingByImages( <G>, <H>, <gensG>, <gensH> ) O

returns a generalized mapping defined by extending the mapping from
<gensG> to <gensH> homomorphically.
(`GroupHomomorphismByImages' creates a `GroupGeneralMappingByImages' and
tests whether it `IsMapping'.)

\beginexample
gap> map:=GroupGeneralMappingByImages(g,h,gens,[(1,2,3),(1,2)]);
[ (1,2,3,4), (1,2) ] -> [ (1,2,3), (1,2) ]
gap> IsMapping(map);
false
\endexample

*A second* way to create homomorphisms is to give functions that compute image
and preimage. (A similar case are homomorphisms that are induced by
conjugation. Special constructors for such mappings are described in
section~"Group Automorphisms").

\>GroupHomomorphismByFunction( <S>, <R>, <fun> ) F
\>GroupHomomorphismByFunction( <S>, <R>, <fun>, <invfun> ) F
\>GroupHomomorphismByFunction( <S>, <R>, <fun>, `false', <prefun> ) F

`GroupHomomorphismByFunction' returns a group homomorphism <hom> with
source <S> and range <R>, such that each element <s> of <S> is mapped to
the element `<fun>( <s> )', where <fun> is a {\GAP} function.

If the argument <invfun> is bound then <hom> is a bijection between <S>
and <R>, and the preimage of each element <r> of <R> is given by
`<invfun>( <r> )', where <invfun> is a {\GAP}  function.

In the third variant, a function <prefun> is given that can be used to
compute a single preimage. In this case, the third entry must be
`false'.

No test is performed on whether the functions actually give an
homomorphism between both groups because this would require testing the
full multiplication table.

`GroupHomomorphismByFunction' creates a mapping which
`IsSPGeneralMapping'.


\beginexample
gap> hom:=GroupHomomorphismByFunction(g,h,
> function(x) if SignPerm(x)=-1 then return (1,2); else return ();fi;end);
MappingByFunction( Group([ (1,2,3,4), (1,2) ]), Group([ (1,2,3), (1,2) 
 ]), function( x ) ... end )
gap> ImagesSource(hom);
Group([ (1,2), (1,2) ])
gap> Image(hom,(1,2,3,4));
(1,2)
\endexample

*The third* class are epimorphisms from a group onto its factor
group. Such homomorphisms can be constructed by
`NaturalHomomorphismByNormalSubgroup'
(see~"NaturalHomomorphismByNormalSubgroup").

*The fourth* class is homomorphisms in a permutation group that are induced by
an action on a set. Such homomorphisms are described in the context of group
actions, see chapter~"Group Actions" and in particular
section~"ActionHomomorphism".

\>AsGroupGeneralMappingByImages( <map> ) A

 If <map> is a mapping from one group to another this attribute returns
 a group general mapping that which implements the same abstract
 mapping. (Some operations can be performed more effective in this
 representation, see
 also~"IsGroupGeneralMappingByAsGroupGeneralMappingByImages".)

\beginexample
gap> AsGroupGeneralMappingByImages(hom);
[ (1,2,3,4), (1,2) ] -> [ (1,2), (1,2) ]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operations for Group Homomorphisms}
\index{kernel!group homomorphism}

Group homomorphisms are mappings, so all the operations and properties for
mappings described in chapter~"Mappings" are applicable to them. (However
often much better methods, than for general mappings are available.)

Group homomorphisms will map groups to groups by just mapping the set of
generators.

`KernelOfMultiplicativeGeneralMapping' can be used to compute the kernel
of a group homomorphism.

\beginexample
gap> hom:=GroupHomomorphismByImages(g,h,gens,[(1,2),(1,3)]);;
gap> Kernel(hom);
Group([ (1,4)(2,3), (1,2)(3,4) ])
\endexample

Homomorphisms can map between groups in different representations and are
also used to get isomorphic groups in a different representation.

\beginexample
gap> m1:=[[0,-1],[1,0]];;m2:=[[0,-1],[1,1]];;
gap> sl2z:=Group(m1,m2);; # SL(2,Integers) as matrix group
gap> F:=FreeGroup(2);;
gap> psl2z:=F/[F.1^2,F.2^3]; #PSL(2,Z) as FP group
<fp group on the generators [ f1, f2 ]>
gap> phom:=GroupHomomorphismByImagesNC(sl2z,psl2z,[m1,m2],
> GeneratorsOfGroup(psl2z)); # the non NC-version would be expensive
[ [ [ 0, -1 ], [ 1, 0 ] ], [ [ 0, -1 ], [ 1, 1 ] ] ] -> [ f1, f2 ]
gap> Kernel(phom); # the diagonal matrices
Group([ [ [ -1, 0 ], [ 0, -1 ] ], [ [ -1, 0 ], [ 0, -1 ] ] ])
gap> p1:=(1,2)(3,4);;p2:=(2,4,5);;a5:=Group(p1,p2);;
gap> ahom:=GroupHomomorphismByImages(psl2z,a5,
> GeneratorsOfGroup(psl2z),[p1,p2]); # here homomorphism test is cheap.
[ f1, f2 ] -> [ (1,2)(3,4), (2,4,5) ]
gap> u:=PreImage(ahom,Group((1,2,3),(1,2)(4,5)));
Group(<fp, no generators known>)
gap> Index(psl2z,u);
10
gap> isofp:=IsomorphismFpGroup(u);; Image(isofp);
<fp group of size infinity on the generators [ F1, F2, F3, F4 ]>
gap> RelatorsOfFpGroup(Image(isofp));
[ F1^2, F4^2, F3^3 ]
gap> up:=PreImage(phom,u);;
gap> List(GeneratorsOfGroup(up),TraceMat);
[ -2, -2, 0, -4, 1, 0 ]
\endexample

\index{Inverse!group homomorphism}

For an automorphism <aut>, `Inverse' returns the inverse automorphism
$<aut>^{-1}$. However if <hom> is a bijective homomorphism between
different groups, or if <hom> is injective and considered to be a bijection
to its image, the operation `InverseGeneralMapping' should be used instead.
(See~"Inverse" for a further discussion of this problem.)

\beginexample
gap> iso:=IsomorphismPcGroup(g);
Pcgs([ (3,4), (2,4,3), (1,4)(2,3), (1,3)(2,4) ]) -> [ f1, f2, f3, f4 ]
gap> Inverse(iso);
#I  The mapping must be bijective and have source=range
#I  You might want to use `InverseGeneralMapping'
fail
gap> InverseGeneralMapping(iso);
[ f1, f2, f3, f4 ] -> Pcgs([ (3,4), (2,4,3), (1,4)(2,3), (1,3)(2,4) ])
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Efficiency of Homomorphisms}

{\GAP} permits to create homomorphisms between arbitrary groups.  This
section considers the efficiency of the implementation and shows ways how to
choose suitable representations. For permutation groups (see~"Permutation
Groups") or Pc groups (see~"Pc Groups") this is normally nothing to worry
about, unless the groups get extremely large. For other groups however
certain calculations might be expensive and some precaution might be needed
to avoid unnecessarily expensive calculations.

In short, it is always worth to tell a mapping that it is a homomorphism
(this can be done by `SetIsMapping') (or to create it directly with
`GroupHomomorphismByImagesNC').

The basic operations required are to compute image and preimage of elements
and to test whether a mapping is a homomorphism. Their cost
will differ depending on the type of the mapping.
\bigskip

*Mappings given on generators (`GroupHomomorphismByImages',
`GroupGeneralMappingByImages')*

Computing images requires to express an element of the source as word in the
generators. If it cannot be done effectively (this is determined by
`KnowsHowToDecompose', see~"KnowsHowToDecompose" which returns `true' for
example for arbitrary permutation groups, for Pc groups or for finitely
presented groups with the images of the free generators) the span of the
generators has to be computed elementwise which can be very expensive and
memory consuming.

Computing preimages adheres to the same rules with swapped r\^oles of
generators and their images.

The test whether a mapping is a homomorphism requires
the computation of a presentation for the source and evaluation of its
relators in the images of its generators. For larger groups this can be
expensive and `GroupHomomorphismByImagesNC' should be used if the mapping is
known to be a homomorphism.
\bigskip

*Action homomorphisms (`ActionHomomorphism')*

The calculation of images is determined by the acting function used and
-- for large domains -- is often dominated by the search for the position of
an image in a list of the domain elements. This can be improved by sorting
this list if an efficient method for `\<'  to compare elements of the domain
is available.

Once the images of a generating set are computed, computing preimages (which is
done via the `AsGroupGeneralMappingByImages') and computing the kernel
bahaves the same as for a `GroupHomomorphismByImages' in a permutation
group.

{\GAP} will always assume that the acting function provided implements a proper
group action and thus that the mapping is indeed a homomorphism.
\bigskip

*Mappings given by functions (`GroupHomomorphismByFunction',
`GroupGeneralMappingByFunctions')*

Computing images is wholly determined by the function that performs the
image calculation. If no function to compute preimages is given, computing
preimages requires mapping every element of the source to find an element
that maps to the requested image. This is time and memory consuming.

Testing whether a `GroupGeneralMappingByFunctions' is a homomorphism would
require mapping all products of elements and thus should be avoided.
\bigskip

*Other operations*

To compute the kernel of a homomorphism (unless the mapping is known to be
injective) requires the capability to compute a
presentation of the image and to evaluate the relators of this presentation
in preimages of the presentations generators.

The calculation of the `Image' (respectively `ImagesSource') requires to map
a generating set of the source, testing surjectivity is a comparison for
equality with the range.

Testing injectivity is a test for triviality of the kernel.

The comparison of mappings is based on a lexicographic comparison of a
sorted element list of the source. For groups this can be simplified:

\>ImagesSmallestGenerators( <map> ) A

 returns the list of images of `GeneratorsSmallest(Source(<map>))'. This
 list can be used to compare group homomorphisms.  (The standard
 comparison is to compare the image lists on the set of elements of the
 source. If however x and y have the same images under a and b,
 certainly all their products have. Therefore it is sufficient to test
 this on the images of the smallest generators.)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Homomorphism for very large groups}

Some homomorphisms (notably particular actions) transfer known information
about the source group (such as a stabilizer chain) to the image group if
this is substantially cheaper than to compute the information in the image
group anew. In most cases this is no problem and in fact speeds up further
calculations notably.

For a huge source group, however this can be time consuming or take a large
amount of extra memory for storage. In this case it can be helpful to avoid
as much automatism as possible.

The following list of tricks might be useful in such a case. (However you
will lose much automatic deduction. So please restrict the use of these to
cases where the standard approach does not work.)
\beginitems
-&
Compute only images (or the `PreImageRepresentative') of group elements. Do
not compute the images of (sub)groups or the full preimage of a subgroup.

-&
Create action homomorphisms as ``surjective'' (see `ActionHomomorphism')
(otherwise the range is set to be the full symmetric group)
However do not compute  Range or Image, but only the images of a
generator set.

-&
If you suspect an action homomorphism to do too much internally, replace the
action function with a function that does the same; i.e. replace `OnPoints'
by
\begintt
function(p,g) return p^g;end;
\endtt
The action will be the same, but as the action function is not `OnPoints',
the extra processing for special cases is not triggered.
\enditems

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Nice Monomorphisms}

{\GAP} contains very efficient algorithms for some special representations
of groups (for example pc groups or permutation groups) while for other
representations only slow generic methods are available. In this case it
can be worthwhile to do all calculations rather in an isomorphic image of
the group, which is in a ``better'' representation. The way to achieve this
in {\GAP} is via *nice monomorphisms*.

For this mechanism to work, of course there must be effective methods to
evaluate the `NiceMonomorphism' on elements and to take preimages under it.
As by definition no good algorithms exist for the source group,
normally this can only be achieved by using an `ActionHomomorphism' or a
`GroupHomomorphismByFunction' (see also
section~"Efficiency of Homomorphisms").

\>IsHandledByNiceMonomorphism( <obj> ) P

If this property is `true', high-valued methods that translate all
calculations in <obj> in the image under the `NiceMonomorphism' become
available for <obj>.

\>NiceMonomorphism( <obj> ) A

is a homomorphism that is defined (at least) on the whole of <obj> and
whose restriction to <obj> is injective. The concrete morphism (and also
the image group) will depend on the representation of <obj>.

\>NiceObject( <obj> ) A

The `NiceObject' of <obj> is the image of <obj> under its
`NiceMonomorphism'.


A typical example are finite matrix groups, which use a faithful action on
vectors to translate all calculations in a permutation group.
\beginexample
gap> gl:=GL(3,2);
SL(3,2)
gap> IsHandledByNiceMonomorphism(gl);
true
gap> NiceObject(gl);
Group([ (5,7)(6,8), (2,3,5)(4,7,6) ])
gap> Image(NiceMonomorphism(gl),Z(2)*[[1,0,0],[0,1,1],[1,0,1]]);
(2,6)(3,4,7,8)
\endexample

\>IsCanonicalNiceMonomorphism( <nhom> ) P

A `NiceMonomorphism' <nhom> is canonical if the image set will only
depend on the set of group elements but not on the generating set and
`\<' comparison of group elements translates through the nice
monomorphism. This
implies that equal objects will always have equal `NiceObject's.
In some situations however this condition would be expensive to
achieve, therefore it is not guaranteed for every nice monomorphism.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Group Automorphisms}

Group automorphisms are bijective homomorphism from a group onto itself.
An important subclass are automorphisms which are induced by conjugation of
the group itself or a supergroup.

\>ConjugatorIsomorphism( <G>, <g> ) O

Let <G> be a group, and <g> an element in the same family as the elements
of <G>.
`ConjugatorIsomorphism' returns the isomorphism from <G> to `<G>^<g>'
defined by $<h> \mapsto <h>^{<g>}$ for all $<h> \in <G>$.

If <g> normalizes <G> then `ConjugatorIsomorphism' does the same as
`ConjugatorAutomorphismNC' (see~"ConjugatorAutomorphism").


\>ConjugatorAutomorphism( <G>, <g> ) F
\>ConjugatorAutomorphismNC( <G>, <g> ) O

Let <G> be a group, and <g> an element in the same family as the elements
of <G> such that <g> normalizes <G>.
`ConjugatorAutomorphism' returns the automorphism of <G>
defined by $<h> \mapsto <h>^{<g>}$ for all $<h> \in <G>$.

If conjugation by <g> does *not* leave <G> invariant,
`ConjugatorAutomorphism' returns `fail';
in this case,
the isomorphism from <G> to `<G>^<g>' induced by conjugation with <g>
can be constructed
with `ConjugatorIsomorphism' (see~"ConjugatorIsomorphism").

`ConjugatorAutomorphismNC' does the same as `ConjugatorAutomorphism',
except that the check is omitted whether <g> normalizes <G>.


\>InnerAutomorphism( <G>, <g> ) F
\>InnerAutomorphismNC( <G>, <g> ) O

Let <G> be a group, and $<g> \in <G>$.
`InnerAutomorphism' returns the automorphism of <G>
defined by $<h> \mapsto <h>^{<g>}$ for all $<h> \in <G>$.

If <g> is *not* an element of <G>,
`InnerAutomorphism' returns `fail';
in this case,
the isomorphism from <G> to `<G>^<g>' induced by conjugation with <g>
can be constructed
with `ConjugatorIsomorphism' (see~"ConjugatorIsomorphism")
or with `ConjugatorAutomorphism' (see~"ConjugatorAutomorphism").

`InnerAutomorphismNC' does the same as `InnerAutomorphism',
except that the check is omitted whether $<g> \in <G>$.


\>IsConjugatorIsomorphism( <hom> ) P
\>IsConjugatorAutomorphism( <hom> ) P
\>IsInnerAutomorphism( <hom> ) P

Let <hom> be a group general mapping (see~"IsGroupGeneralMapping")
with source $G$, say.
`IsConjugatorIsomorphism' returns `true' if <hom> is induced by
conjugation of $G$ by an element $g$ that lies in $G$ or in a group into
which $G$ is naturally embedded in the sense described below,
and `false' otherwise.
Natural embeddings are dealt with in the case that $G$ is
a permutation group (see Chapter~"Permutation Groups"),
a matrix group (see Chapter~"Matrix Groups"),
a finitely presented group (see Chapter~"Finitely Presented Groups"), or
a group given w.r.t.~a polycyclic presentation (see Chapter~"Pc Groups").
In all other cases, `IsConjugatorIsomorphism' may return `false'
if <hom> is induced by conjugation but is not an inner automorphism.

If `IsConjugatorIsomorphism' returns `true' for <hom> then
an element $g$ that induces <hom> can be accessed as value of
the attribute `ConjugatorOfConjugatorIsomorphism'
(see~"ConjugatorOfConjugatorIsomorphism").

`IsConjugatorAutomorphism' returns `true' if <hom> is an automorphism
(see~"IsEndoGeneralMapping") that is regarded as a conjugator isomorphism
by `IsConjugatorIsomorphism', and `false' otherwise.

`IsInnerAutomorphism' returns `true' if <hom> is a conjugator
automorphism such that an element $g$ inducing <hom> can be chosen in
$G$, and `false' otherwise.


\>ConjugatorOfConjugatorIsomorphism( <hom> ) A

For a conjugator isomorphism <hom> (see~"ConjugatorIsomorphism"),
`ConjugatorOfConjugatorIsomorphism' returns an element $g$ such that
mapping under <hom> is induced by conjugation with $g$.

To avoid problems with `IsInnerAutomorphism',
it is guaranteed that the conjugator is taken from the source of <hom>
if possible.



\beginexample
gap> hgens:=[(1,2,3),(1,2,4)];;h:=Group(hgens);;
gap> hom:=GroupHomomorphismByImages(h,h,hgens,[(1,2,3),(2,3,4)]);;
gap> IsInnerAutomorphism(hom);
true
gap> ConjugatorOfConjugatorIsomorphism(hom);
(1,2,3)
gap> hom:=GroupHomomorphismByImages(h,h,hgens,[(1,3,2),(1,4,2)]);
[ (1,2,3), (1,2,4) ] -> [ (1,3,2), (1,4,2) ]
gap> IsInnerAutomorphism(hom);
false
gap> IsConjugatorAutomorphism(hom);
true
gap> ConjugatorOfConjugatorIsomorphism(hom);
(1,2)
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Groups of Automorphisms}

Group automorphism can be multiplied and inverted and thus it is possible
to form groups of automorphisms.

\>IsGroupOfAutomorphisms( <G> ) P

indicates whether <G> consists of automorphisms of another group <H>.
The group <H> can be obtained from <G> via the attribute
`AutomorphismDomain'.

\>AutomorphismDomain( <G> ) A

If <G> consists of automorphisms of <H>, this attribute returns <H>.


\>AutomorphismGroup( <obj> ) A

returns the full automorphism group of the object <obj>. The
automorphisms act on the domain by the caret operator `^'.
The automorphism group often stores a ``NiceMonomorphism'' (see
"NiceMonomorphism") to a permutation group, obtained by the action on a
subset of <obj>.


\>IsAutomorphismGroup( <G> ) P

indicates whether <G> is the full automorphism group of another group
<H>, this group is given as `AutomorphismDomain' of <G>.


\beginexample
gap> g:=Group((1,2,3,4),(1,3));
Group([ (1,2,3,4), (1,3) ])
gap> au:=AutomorphismGroup(g);
<group of size 8 with 3 generators>
gap> GeneratorsOfGroup(au);
[ ^(1,2,3,4), ^(1,3), [ (1,2,3,4), (2,4) ] -> [ (1,2,3,4), (1,2)(3,4) ] ]
gap> NiceObject(au);
Group([ (1,4)(2,6), (2,6)(3,5), (1,2,4,6) ])
\endexample

\>InnerAutomorphismsAutomorphismGroup( <autgroup> ) A

For an automorphism group <autgroup> of a group this attribute stores
the subgroup of inner automorphisms (automorphisms induced by conjugation)
of the original group.

\beginexample
gap> InnerAutomorphismsAutomorphismGroup(au);
<group with 2 generators>
\endexample

\>InducedAutomorphism( <epi>, <aut> ) O

Let <aut> be an automorphism of a group <G> and `<epi>: <G> -> <H>' an
homomorphism such that `ker <epi>' is fixed under <aut>.
Let <U> be the image of <epi>. This command returns the automorphism of
<U> induced by <aut> via <epi>, that is the automorphism of <U> which maps
`<g>^<epi>' to `(<g>^<aut>)^<epi>', for <g> $\in$ <G>.


\beginexample
gap> g:=Group((1,2,3,4),(1,2));
Group([ (1,2,3,4), (1,2) ])
gap> n:=Subgroup(g,[(1,2)(3,4),(1,3)(2,4)]);
Group([ (1,2)(3,4), (1,3)(2,4) ])
gap> epi:=NaturalHomomorphismByNormalSubgroup(g,n);
[ (1,2,3,4), (1,2) ] -> [ f1*f2, f1 ]
gap> aut:=InnerAutomorphism(g,(1,2,3));
^(1,2,3)
gap> InducedAutomorphism(epi,aut);
^f2
\endexample

%%  The code for automorphism groups was designed and implemented by Bettina
%%  Eick and Alexander Hulpke.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Calculating with Group Automorphisms}

Usually the best way to calculate in a group of automorphisms is to go
translate all calculations to an isomorphic group in a representation, for
which better algorithms are available, say a permutation group. This
translation can be done automatically using a `NiceMonomorphism'
(see~"NiceMonomorphism".)

Once a group knows to be a group of automorphisms (this can be achieved
by testing or setting the property `IsGroupOfAutomorphisms'
(see~"IsGroupOfAutomorphisms"),
{\GAP} will try itself to find such a nice monomorphism once calculations in
the automorphism group are done.

Note that nice homomorphisms inherit down to subgroups, but cannot
necessarily be extended from a subgroup to the whole group. Thus when
working with a group of automorphisms, it can be beneficial to 
enforce calculation of the nice monomorphism for the whole
group (for example by explicitly calling `Random(G)' and ignoring
the result -- it will be stored internally) at the start of the calculation.
Otherwise {\GAP} might first calculate a nice monomorphism for the subgroup,
only to be forced to calculate a new nice monomorphism for the whole group
later on.

\>AssignNiceMonomorphismAutomorphismGroup( <autgrp>, <group> ) F


computes a nice monomorphism for <autgroup> acting on <group> and stores
it as `NiceMonomorphism' in <autgrp>.

If the centre of `AutomorphismDomain' of <autgrp> is trivial, the
operation will first try to represent all automorphisms by conjugation
(in <group> or a natural parent of <group>).

If this fails the operation tries to find a small subset of <group> on
which the action will be faithful.

The operation sets the attribute `NiceMonomorphism' and does not return
a value.



If a good domain for a faithful permutation action is known already, a
homomorphism for the action on it can be created using
`NiceMonomorphismAutomGroup'. It might be stored by `SetNiceMonomorphism'
(see "NiceMonomorphism").

\>NiceMonomorphismAutomGroup( <autgrp>, <elms>, <elmsgens> ) F

This function creates a monomorphism for an automorphism group
<autgrp> of a group by permuting the group elements in the list <elms>.
This list must be chosen to yield a faithful representation. <elmsgens>
is a list of generators which are a subset of <elms>. (They can differ
from the groups original generators.) It does not yet assign it as
`NiceMonomorphism'.


Another nice way of representing automorphisms as permutations has been
described in \cite{Sims97}. It it not yet available in {\GAP}, a description
however can be found in section~"ext:Stabilizer Chains for Automorphisms Acting
on Enumerators" of ``Extending {\GAP}''.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Searching for Homomorphisms}

\index{homomorphisms!find all}

\>IsomorphismGroups( <G>, <H> ) F

computes an isomorphism between the groups <G> and <H>
if they are isomorphic and returns `fail' otherwise.

With the existing methods the amount of time needed grows with
the size of a generating system of <G>. (Thus in particular for
$p$-groups calculations can be slow.) If you do only need to know
whether groups are isomorphic, you might want to consider `IdSmallGroup'
(see~"IdSmallGroup") or the random isomorphism test
(see~"RandomIsomorphismTest").


\index{isomorphisms!find all}
\beginexample
gap> g:=Group((1,2,3,4),(1,3));;
gap> h:=Group((1,4,6,7)(2,3,5,8), (1,5)(2,6)(3,4)(7,8));;
gap> IsomorphismGroups(g,h);
[ (1,2,3,4), (1,3) ] -> [ (1,4,6,7)(2,3,5,8), (1,2)(3,7)(4,8)(5,6) ]
gap> IsomorphismGroups(g,Group((1,2,3,4),(1,2)));
fail
\endexample

\>GQuotients( <F>, <G> ) O

computes all epimorphisms from <F> onto <G> up to automorphisms of <G>.
This classifies all factor groups of <F> which are isomorphic to <G>.

With the existing methods the amount of time needed grows with
the size of a generating system of <G>. (Thus in particular for
$p$-groups calculations can be slow.)

If the `findall' option is set to `false', the algorithm will stop once
one homomorphism has been found (this can be faster and might be
sufficient if not all homomorphisms are needed).


\index{epimorphisms!find all}
\index{projections!find all}
\beginexample
gap> g:=Group((1,2,3,4),(1,2));
Group([ (1,2,3,4), (1,2) ])
gap> h:=Group((1,2,3),(1,2));
Group([ (1,2,3), (1,2) ])
gap> quo:=GQuotients(g,h);
[ [ (1,4,2,3), (1,2,4) ] -> [ (2,3), (1,2,3) ] ]
\endexample

\>IsomorphicSubgroups( <G>, <H> ) O

computes all monomorphisms from <H> into <G> up to <G>-conjugacy of the
image groups.  This classifies all <G>-classes of subgroups of <G> which
are isomorphic to <H>.

With the existing methods, the amount of time needed grows with
the size of a generating system of <G>. (Thus in particular for
$p$-groups calculations can be slow.) A main use of
`IsomorphicSubgroups' therefore is to find nonsolvable subgroups
(which often can be generated by 2 elements).

(To find $p$-subgroups it is often faster to compute the subgroup
lattice of the sylow subgroup and to use `IdGroup' to identify the type of
the subgroups.)

If the `findall' option is set to `false', the algorithm will stop once
one homomorphism has been found (this can be faster and might be
sufficient if not all homomorphisms are needed).


\index{embeddings!find all}
\index{monomorphisms!find all}
\beginexample
gap> g:=Group((1,2,3,4),(1,2));
Group([ (1,2,3,4), (1,2) ])
gap> h:=Group((3,4),(1,2));;
gap> emb:=IsomorphicSubgroups(g,h);
[ [ (3,4), (1,2) ] -> [ (3,4), (1,2) ], 
  [ (3,4), (1,2) ] -> [ (1,3)(2,4), (1,2)(3,4) ] ]
\endexample

\>MorClassLoop( <range>, <classes>, <params>, <action> ) F

This function loops over element tuples taken from <classes> and checks
these for properties such as generating a given group, or fulfilling
relations.  This can be used to find small generating sets or all types
of Morphisms.
The element tuples are used only up to up to inner automorphisms as
all images can be obtained easily from them by conjugation while
running through all of them usually would take too long.

<range> is a group from which these elements are taken.
The classes are given in a list <classes> which  is a list of records
with components
\beginitems
`classes'&A list of conjugacy classes
`representative'&One element in the union of these classes
`size'&The sum of the sizes of these classes
\enditems

<params> is a record containing optional components:
\beginitems
`gens'& generators that are to be mapped (for testing morphisms). The length
of this list determines the length of element tuples considered.

`from'& a preimage group (that contains <gens>)

`to'& image group (which might be smaller than `range')
 
`free'& free generators, a list of the same length than the
 generators `gens'.

`rels'& some relations that hold among the generators `gens'. They are given
as a list [<word>,<order>] where <word> is a word in the free generators
`free'.

`dom'& a set of elements on which automorphisms act faithfully (used to do
element tests in partial automorphism groups).

`aut'& Subgroup of already known automorphisms.
\enditems

<action> is a number whose bit-representation indicates the requirements
which are enforced on the element tuples found:
\beginlist
\item{1}   homomorphism

\item{2}   injective

\item{4}   surjective

\item{8}   find all (otherwise stops after the first find)
\endlist
If the search is for homomorphisms, the function returns homomorphisms
obtained by mapping the given generators `gens' instead of element tuples.



The ``Morpheus'' algorithm used to find homomorphisms is described in
section V.5 of \cite{Hulpke96}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Representations for Group Homomorphisms}

The different representations of group homomorphisms are used to indicate
from what type of group to what type of group they map and thus determine
which methods are used to compute images and preimages.

The information in this section is mainly relevant for implementing new
methods and not for using homomorphisms.

\>IsGroupGeneralMappingByImages( <map> ) R

Representation for mappings from one group to another that are defined
by extending a mapping of group generators homomorphically.
Instead of record components, the attribute `MappingGeneratorImages' is
used to store generators and their images.

\>IsGroupGeneralMappingByAsGroupGeneralMappingByImages( <map> ) R

Representation for mappings that delegate work on a
`GroupHomomorphismByImages'.

\>IsPreimagesByAsGroupGeneralMappingByImages( <map> ) R

Representation for mappings that delegate work for preimages to a
GroupHomomorphismByImages.

\>IsPermGroupGeneralMappingByImages( <map> ) R
\>IsPermGroupHomomorphismByImages( <map> ) R

is the representation for mappings that map from a perm group

\>IsToPermGroupGeneralMappingByImages( <map> ) R
\>IsToPermGroupHomomorphismByImages( <map> ) R

is the representation for mappings that map to a perm group

\>IsGroupGeneralMappingByPcgs( <map> ) R

is the representations for mappings that map a pcgs to images and thus
may use exponents to decompose generators.

\>IsPcGroupGeneralMappingByImages( <map> ) R
\>IsPcGroupHomomorphismByImages( <map> ) R

is the representation for mappings from a pc group

\>IsToPcGroupGeneralMappingByImages( <map> ) R
\>IsToPcGroupHomomorphismByImages( <map> ) R

is the representation for mappings to a pc group

\>IsFromFpGroupGeneralMappingByImages( <map> ) R
\>IsFromFpGroupHomomorphismByImages( <map> ) R

is the representation of mappings from an fp group.

\>IsFromFpGroupStdGensGeneralMappingByImages( <map> ) R
\>IsFromFpGroupStdGensHomomorphismByImages( <map> ) R

is the representation of mappings from an fp group that give images of
the standard generators.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%E

