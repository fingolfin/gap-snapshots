#I  file="lib/read5.g"

#F  file="lib/rvecempt.gi" crc=-119755004
RANK_FILTER_LIST  := [ 1985, 1, 49450153, 28, 49450153, 28, 49450153, 28, 
  52247917, 19, 49450153, 28, 49450153, 28, 8126465, 2, 8126465, 2, 49450153, 
  28, 49450153, 28, 49450153, 28, 49450153, 28, 49450153, 28, 32505602, 3, 
  49450153, 28, 49450153, 28, 32505602, 3, 17, 18, 49450153, 28, 49450153, 
  28, 17, 18, 49450153, 28, 49450153, 28 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/rvecempt.gi", -119755004 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/rvecempt.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/rvecempt.gi");
elif COM_RESULT = 3  then
Revision.rvecempt_gi:="@(#)$Id: rvecempt.gi,v 4.10 2002/04/15 10:05:15 sal Exp $";
DeclareRepresentation("IsEmptyRowVectorRep",IsPositionalObjectRep and IsConstantTimeAccessList,[]);
InstallMethod(EmptyRowVector,"for a family",true,[IsFamily],0,COM_FUN(1));
InstallMethod(ViewObj,"for an empty row vector",true,[IsRowVector and IsEmpty and IsEmptyRowVectorRep],0,COM_FUN(2));
InstallMethod(Length,"for an empty row vector",true,[IsRowVector and IsEmpty and IsEmptyRowVectorRep],0,COM_FUN(3));
InstallMethod(IsBound\[\],"for an empty row vector, and a positive integer",true,[IsRowVector and IsEmpty and IsEmptyRowVectorRep,IsPosInt],0,COM_FUN(4));
InstallMethod(ShallowCopy,"for an empty row vector",true,[IsRowVector and IsEmpty and IsEmptyRowVectorRep],0,COM_FUN(5));
InstallMethod(\=,"for an empty row vector, and a collection in the same family",IsIdenticalObj,[IsRowVector and IsEmpty and IsEmptyRowVectorRep,IsCollection],0,COM_FUN(6));
InstallMethod(\=,"for a collection, and an empty row vector in the same family",IsIdenticalObj,[IsCollection,IsRowVector and IsEmpty and IsEmptyRowVectorRep],0,COM_FUN(7));
InstallMethod(\+,"for two empty row vectors in the same family",IsIdenticalObj,[IsRowVector and IsEmpty and IsEmptyRowVectorRep,IsRowVector and IsEmpty and IsEmptyRowVectorRep],0,COM_FUN(8));
InstallMethod(AdditiveInverseOp,"for empty row vector",true,[IsRowVector and IsEmpty and IsEmptyRowVectorRep],0,IdFunc);
InstallMethod(ZeroOp,"for empty row vector",true,[IsRowVector and IsEmpty and IsEmptyRowVectorRep],0,IdFunc);
InstallMethod(\*,"for multiplicative element, and empty row vector",IsElmsColls,[IsMultiplicativeElement,IsRowVector and IsEmpty and IsEmptyRowVectorRep],0,COM_FUN(9));
InstallMethod(\*,"for empty row vector, and multiplicative element",IsCollsElms,[IsRowVector and IsEmpty and IsEmptyRowVectorRep,IsMultiplicativeElement],0,COM_FUN(10));
InstallMethod(\*,"for integer, and empty row vector",true,[IsInt,IsRowVector and IsEmpty and IsEmptyRowVectorRep],0,COM_FUN(11));
InstallMethod(\*,"for empty row vector, and integer",true,[IsRowVector and IsEmpty and IsEmptyRowVectorRep,IsInt],0,COM_FUN(12));
InstallMethod(\*,"for two empty row vectors in the same family",IsIdenticalObj,[IsRowVector and IsEmpty and IsEmptyRowVectorRep,IsRowVector and IsEmpty and IsEmptyRowVectorRep],0,COM_FUN(13));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/rvecempt.gi"

#F  file="lib/ratfun1.gi" crc=-58322937
RANK_FILTER_LIST  := [  ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/ratfun1.gi", -58322937 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/ratfun1.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/ratfun1.gi");
elif COM_RESULT = 3  then
Revision.ratfun1_gi:="@(#)$Id: ratfun1.gi,v 4.17 2002/06/24 18:53:42 gap Exp $";
LAUR_POL_BY_EXTREP:=COM_FUN(1);
EXTREP_POLYNOMIAL_LAURENT:=COM_FUN(2);
UNIVARTEST_RATFUN:=COM_FUN(3);
EXTREP_COEFFS_LAURENT:=COM_FUN(4);
UNIV_FUNC_BY_EXTREP:=COM_FUN(5);
MONOM_REV_LEX:=COM_FUN(6);
ZIPPED_SUM_LISTS_LIB:=COM_FUN(7);
ZIPPED_PRODUCT_LISTS:=COM_FUN(8);
BindGlobal("ZippedListQuotient",COM_FUN(9));
ADDITIVE_INV_RATFUN:=COM_FUN(10);
ADDITIVE_INV_POLYNOMIAL:=COM_FUN(11);
SMALLER_RATFUN:=COM_FUN(12);
SUM_COEF_POLYNOMIAL:=COM_FUN(13);
QUOTIENT_POLYNOMIALS_EXT:=COM_FUN(14);
SUM_LAURPOLS:=COM_FUN(15);
DIFF_LAURPOLS:=COM_FUN(16);
PRODUCT_LAURPOLS:=COM_FUN(17);
GCD_COEFFS:=COM_FUN(18);
QUOTREM_LAURPOLS_LISTS:=COM_FUN(19);
ADDCOEFFS_GENERIC_3:=COM_FUN(20);
PRODUCT_COEFFS_GENERIC_LISTS:=COM_FUN(21);
REMOVE_OUTER_COEFFS_GENERIC:=COM_FUN(22);
PRODUCT_UNIVFUNCS:=COM_FUN(23);
QUOT_UNIVFUNCS:=COM_FUN(24);
SUM_UNIVFUNCS:=COM_FUN(25);
DIFF_UNIVFUNCS:=COM_FUN(26);
SPECIALIZED_EXTREP_POL:=COM_FUN(27);
TRY_GCD_CANCEL_EXTREP_POL:=COM_FUN(28);
DEGREE_INDET_EXTREP_POL:=COM_FUN(29);
LEAD_COEF_POL_IND_EXTREP:=COM_FUN(30);
POL_COEFFS_POL_EXTREP:=COM_FUN(31);
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/ratfun1.gi"

#F  file="lib/matrix.gi" crc=-125581020
RANK_FILTER_LIST  := [ 49099328, 20, 58412696, 30, 58412696, 30, 58412696, 
  30, 41942876, 3, 58412696, 30, 58412696, 30, 19077395, 31, 63198130, 7, 
  19077395, 31, 41951068, 17, 19077395, 31, 58412696, 30, 19077395, 31, 8193, 
  2, 19077395, 31, 19077395, 31, 19077395, 31, 31628240, 40, 58412696, 30, 
  25270276, 47, 58412696, 30, 58412696, 30, 52247917, 19, 25270276, 47, 
  24644793, 32, 52247917, 19, 25270276, 47, 24644793, 32, 52247917, 19, 
  25270276, 47, 24644793, 32, 52247917, 19, 25270276, 47, 24644793, 32, 
  52247917, 19, 24644793, 32, 37706768, 43, 64969216, 43, 58412696, 30, 
  58412696, 30, 58412696, 30, 58412696, 30, 31628240, 40, 4365792, 40, 
  58412696, 30, 41942876, 3, 58412696, 30, 58412696, 30, 41942876, 3, 
  41942876, 3, 41942876, 3, 24644794, 34, 64969217, 45, 58412696, 30, 
  58412696, 30, 58412696, 30, 57619825, 30, 58412697, 32, 35414261, 27, 
  56456811, 17, 56456811, 17, 57619825, 30, 58412696, 30, 58412696, 30, 
  52120310, 32, 8193, 2, 58412697, 32, 24644793, 32, 24644794, 34, 24644793, 
  32, 24644794, 34, 24644793, 32, 25270276, 47, 58412696, 30, 25270276, 47, 
  58412696, 30, 25270276, 47, 58412696, 30, 25270276, 47, 58412696, 30, 
  25270276, 47, 58412696, 30, 64969216, 43, 58412697, 32, 58412696, 30, 
  58412697, 32, 58412696, 30, 58412696, 30, 58412697, 32, 8193, 2, 8193, 2, 
  8193, 2, 58412696, 30, 8193, 2, 58412696, 30, 58412696, 30, 17, 18, 
  58412696, 30, 58412696, 30, 24644794, 34, 65077941, 14, 24644793, 32, 
  65077940, 12, 58412696, 30, 58412696, 30, 58412697, 32, 41951068, 17, 
  58412696, 30, 52247917, 19, 58412696, 30, 58412696, 30, 4063233, 1, 
  58412696, 30, 58412696, 30 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/matrix.gi", -125581020 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/matrix.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/matrix.gi");
elif COM_RESULT = 3  then
Revision.matrix_gi:="@(#)$Id: matrix.gi,v 4.159.2.2 2004/09/24 10:42:27 stefan Exp $";
InstallMethod(Zero,[IsRectangularTable and IsAdditiveElementWithZeroCollColl],ZERO_ATTR_MAT);
InstallGlobalFunction(PrintArray,COM_FUN(1));
InstallMethod(Display,"for a matrix",[IsMatrix],PrintArray);
InstallMethod(IsGeneralizedCartanMatrix,"for a matrix",[IsMatrix],COM_FUN(2));
InstallMethod(IsDiagonalMat,"for a matrix",[IsMatrix],COM_FUN(3));
InstallOtherMethod(IsDiagonalMat,[IsEmpty],ReturnTrue);
InstallMethod(IsUpperTriangularMat,"for a matrix",[IsMatrix],COM_FUN(4));
InstallMethod(IsLowerTriangularMat,"for a matrix",[IsMatrix],COM_FUN(5));
InstallGlobalFunction(DiagonalOfMat,COM_FUN(6));
DeclareRepresentation("IsNullMapMatrix",IsMatrix,[]);
BindGlobal("NullMapMatrix",Objectify(NewType(ListsFamily,IsNullMapMatrix),[]));
InstallMethod(Length,"for null map matrix",[IsNullMapMatrix],COM_FUN(7));
InstallMethod(\*,"for vector and null map matrix",[IsVector,IsNullMapMatrix],COM_FUN(8));
InstallOtherMethod(\*,"for empty list and null map matrix",[IsList and IsEmpty,IsNullMapMatrix],COM_FUN(9));
InstallMethod(\*,"for matrix and null map matrix",[IsMatrix,IsNullMapMatrix],COM_FUN(10));
InstallOtherMethod(\*,"for list and null map matrix",[IsList,IsNullMapMatrix],COM_FUN(11));
InstallMethod(ViewObj,"for null map matrix",[IsNullMapMatrix],COM_FUN(12));
InstallMethod(PrintObj,"for null map matrix",[IsNullMapMatrix],COM_FUN(13));
Matrix_OrderPolynomialInner:=COM_FUN(14);
Matrix_OrderPolynomialSameField:=COM_FUN(15);
Matrix_CharacteristicPolynomialSameField:=COM_FUN(16);
Matrix_MinimalPolynomialSameField:=COM_FUN(17);
InstallMethod(Display,"for matrix of FFEs",[IsFFECollColl and IsMatrix],COM_FUN(18));
InstallMethod(CharacteristicPolynomial,"supply field and indeterminate 1",[IsMatrix],COM_FUN(19));
InstallMethod(CharacteristicPolynomial,"supply indeterminate 1",[IsField,IsMatrix],COM_FUN(20));
InstallMethod(CharacteristicPolynomial,"supply field",[IsMatrix,IsPosInt],COM_FUN(21));
InstallMethod(CharacteristicPolynomial,"spinning over field",IsElmsCollsX,[IsField,IsOrdinaryMatrix,IsPosInt],COM_FUN(22));
InstallMethod(CharacteristicPolynomialMatrixNC,"spinning over field",IsElmsCollsX,[IsField,IsOrdinaryMatrix,IsPosInt],Matrix_CharacteristicPolynomialSameField);
InstallMethod(MinimalPolynomial,"spinning over field",IsElmsCollsX,[IsField,IsOrdinaryMatrix,IsPosInt],COM_FUN(23));
InstallMethod(MinimalPolynomialMatrixNC,"spinning over field",IsElmsCollsX,[IsField,IsOrdinaryMatrix,IsPosInt],Matrix_MinimalPolynomialSameField);
OrderMatLimit:=1000;
InstallOtherMethod(Order,"generic method for ordinary matrices",[IsOrdinaryMatrix],COM_FUN(24));
InstallGlobalFunction(OrderMatTrial,COM_FUN(25));
InstallMethod(Order,"for a matrix of cyclotomics, with Minkowski kernel",[IsOrdinaryMatrix and IsCyclotomicCollColl],COM_FUN(26));
InstallMethod(Order,"ordinary matrix of finite field elements",true,[IsOrdinaryMatrix and IsFFECollColl],0,COM_FUN(27));
InstallMethod(IsZero,"method for a matrix",[IsMatrix],COM_FUN(28));
InstallMethod(BaseMatDestructive,"generic method for matrices",[IsMatrix],COM_FUN(29));
InstallMethod(BaseMat,"generic method for matrices",[IsMatrix],COM_FUN(30));
InstallMethod(DefaultFieldOfMatrix,"default method for a matrix (return `fail')",[IsMatrix],ReturnFail);
InstallMethod(DefaultFieldOfMatrix,"method for a matrix over a finite field",[IsMatrix and IsFFECollColl],COM_FUN(31));
InstallMethod(DefaultFieldOfMatrix,"method for a matrix over the cyclotomics",[IsMatrix and IsCyclotomicCollColl],COM_FUN(32));
InstallMethod(DepthOfUpperTriangularMatrix,[IsMatrix],COM_FUN(33));
InstallOtherMethod(SumIntersectionMat,[IsEmpty,IsMatrix],COM_FUN(34));
InstallOtherMethod(SumIntersectionMat,[IsMatrix,IsEmpty],COM_FUN(35));
InstallOtherMethod(SumIntersectionMat,IsIdenticalObj,[IsEmpty,IsEmpty],COM_FUN(36));
InstallMethod(DeterminantMatDestructive,"fraction-free method",[IsOrdinaryMatrix and IsMutable],COM_FUN(37));
InstallMethod(DeterminantMatDestructive,"non fraction free",[IsOrdinaryMatrix and IsFFECollColl and IsMutable],COM_FUN(38));
InstallMethod(DeterminantMat,"for matrices",[IsMatrix],COM_FUN(39));
InstallMethod(DeterminantMatDivFree,"Division-free method",[IsMatrix],COM_FUN(40));
InstallMethod(DimensionsMat,[IsMatrix],COM_FUN(41));
InstallMethod(DiagonalizeMat,"method for general Euclidean Ring",true,[IsEuclideanRing,IsMatrix and IsMutable],0,COM_FUN(42));
InstallOtherMethod(EuclideanDegree,"laurent,ring",IsCollsElms,[IsPolynomialRing,IsLaurentPolynomial],0,COM_FUN(43));
InstallOtherMethod(EuclideanDegree,"laurent",true,[IsLaurentPolynomial],0,DegreeOfLaurentPolynomial);
InstallGlobalFunction(ElementaryDivisorsMatDestructive,COM_FUN(44));
InstallMethod(ElementaryDivisorsMat,"generic method for euclidean rings",[IsEuclideanRing,IsMatrix],COM_FUN(45));
InstallOtherMethod(ElementaryDivisorsMat,"compatibility method for integers",[IsMatrix],COM_FUN(46));
InstallGlobalFunction(MutableCopyMat,COM_FUN(47));
InstallMethod(MutableTransposedMat,"generic method",[IsRectangularTable and IsMatrix],COM_FUN(48));
InstallOtherMethod(MutableTransposedMat,"for arbitrary lists of lists",[IsList],COM_FUN(49));
InstallMethod(MutableTransposedMatDestructive,"generic method",[IsMatrix and IsMutable],COM_FUN(50));
InstallMethod(NullspaceMat,"generic method for ordinary matrices",[IsOrdinaryMatrix],COM_FUN(51));
InstallMethod(NullspaceMatDestructive,"generic method for ordinary matrices",[IsOrdinaryMatrix and IsMutable],COM_FUN(52));
InstallMethod(TriangulizedNullspaceMat,"generic method for ordinary matrices",[IsOrdinaryMatrix],COM_FUN(53));
InstallMethod(TriangulizedNullspaceMatDestructive,"generic method for ordinary matrices",[IsOrdinaryMatrix and IsMutable],COM_FUN(54));
InstallMethod(TriangulizedNullspaceMatNT,"generic method",[IsOrdinaryMatrix],COM_FUN(55));
InstallMethod(GeneralisedEigenvalues,"for a matrix",[IsField,IsMatrix],COM_FUN(56));
InstallMethod(GeneralisedEigenspaces,"for a matrix",[IsField,IsMatrix],COM_FUN(57));
InstallMethod(Eigenvalues,"for a matrix",[IsField,IsMatrix],COM_FUN(58));
InstallMethod(Eigenspaces,"for a matrix",[IsField,IsMatrix],COM_FUN(59));
InstallMethod(Eigenvectors,"for a matrix",[IsField,IsMatrix],COM_FUN(60));
InstallMethod(ProjectiveOrder,"ordinary matrix of finite field elements",[IsOrdinaryMatrix and IsFFECollColl],COM_FUN(61));
InstallMethod(RankMatDestructive,"generic method for mutable matrices",[IsMatrix and IsMutable],COM_FUN(62));
InstallMethod(RankMat,"generic method for matrices",[IsMatrix],COM_FUN(63));
InstallMethod(SemiEchelonMatDestructive,"generic method for matrices",[IsMatrix and IsMutable],COM_FUN(64));
InstallMethod(SemiEchelonMat,"generic method for matrices",[IsMatrix],COM_FUN(65));
InstallMethod(SemiEchelonMatTransformation,"generic method for matrices",[IsMatrix],COM_FUN(66));
InstallMethod(SemiEchelonMatTransformationDestructive,"generic method for matrices",[IsMatrix and IsMutable],COM_FUN(67));
InstallGlobalFunction(SemiEchelonMatsNoCo,COM_FUN(68));
InstallMethod(SemiEchelonMats,"for list of matrices",[IsList],COM_FUN(69));
InstallMethod(SemiEchelonMatsDestructive,"for list of matrices",[IsList],COM_FUN(70));
InstallOtherMethod(TransposedMat,"generic method for matrices and lists",[IsList],MutableTransposedMat);
InstallMethod(TransposedMatDestructive,"generic method for matrices",[IsMatrix],MutableTransposedMatDestructive);
InstallOtherMethod(TransposedMatDestructive,"method for empty matrices",[IsList],COM_FUN(71));
InstallMethod(IsMonomialMatrix,"generic method for matrices",[IsMatrix],COM_FUN(72));
InstallMethod(InverseMatMod,"generic method for matrix and integer",IsCollCollsElms,[IsMatrix,IsInt],COM_FUN(73));
InstallMethod(KroneckerProduct,"generic method for matrices",IsIdenticalObj,[IsMatrix,IsMatrix],COM_FUN(74));
InstallMethod(SolutionMatDestructive,"generic method",IsCollsElms,[IsOrdinaryMatrix and IsMutable,IsRowVector and IsMutable],COM_FUN(75));
InstallMethod(SolutionMat,"generic method for ordinary matrix and vector",IsCollsElms,[IsOrdinaryMatrix,IsRowVector],COM_FUN(76));
InstallMethod(SumIntersectionMat,IsIdenticalObj,[IsMatrix,IsMatrix],COM_FUN(77));
InstallMethod(TriangulizeMat,"generic method for mutable matrices",[IsMatrix and IsMutable],COM_FUN(78));
InstallOtherMethod(TriangulizeMat,"for an empty list",[IsList and IsEmpty],COM_FUN(79));
InstallMethod(UpperSubdiagonal,[IsMatrix,IsPosInt],COM_FUN(80));
InstallGlobalFunction(BaseFixedSpace,COM_FUN(81));
InstallGlobalFunction(BaseSteinitzVectors,COM_FUN(82));
InstallGlobalFunction(BlownUpMat,COM_FUN(83));
InstallGlobalFunction(BlownUpVector,COM_FUN(84));
InstallGlobalFunction(IdentityMat,COM_FUN(85));
InstallGlobalFunction(NullMat,COM_FUN(86));
InstallGlobalFunction(NullspaceModQ,COM_FUN(87));
InstallGlobalFunction(BasisNullspaceModN,COM_FUN(88));
InstallGlobalFunction(PermutationMat,COM_FUN(89));
InstallGlobalFunction(DiagonalMat,COM_FUN(90));
InstallGlobalFunction(ReflectionMat,COM_FUN(91));
InstallGlobalFunction(RandomInvertibleMat,COM_FUN(92));
InstallGlobalFunction(RandomMat,COM_FUN(93));
InstallGlobalFunction(RandomUnimodularMat,COM_FUN(94));
InstallGlobalFunction(SimultaneousEigenvalues,COM_FUN(95));
InstallGlobalFunction(FlatBlockMat,COM_FUN(96));
InstallGlobalFunction(DirectSumMat,COM_FUN(97));
InstallGlobalFunction(TraceMat,COM_FUN(98));
InstallOtherMethod(Trace,"generic method for matrices",[IsMatrix],TraceMat);
InstallMethod(JordanDecomposition,"method for matrices",[IsMatrix],COM_FUN(99));
InstallGlobalFunction(OnSubspacesByCanonicalBasis,COM_FUN(100));
InstallMethod(FieldOfMatrixList,"generic: form field",[IsListOrCollection],COM_FUN(101));
InstallMethod(LaTeXObj,"matrix",[IsMatrix],COM_FUN(102));
InstallMethod(BaseOrthogonalSpaceMat,"for a matrix",[IsMatrix],COM_FUN(103));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/matrix.gi"

#F  file="lib/matint.gi" crc=19769948
RANK_FILTER_LIST  := [ 58412696, 30, 8193, 2, 41942876, 3, 58412696, 30, 
  8193, 2, 41942876, 3, 58412697, 32, 41942876, 3, 58412696, 30, 8193, 2, 
  41942876, 3, 58412696, 30, 8193, 2, 41942876, 3, 58412696, 30, 8193, 2, 
  41942876, 3, 58412696, 30, 8193, 2, 41942876, 3, 48733699, 39, 58412697, 
  32, 4365792, 40, 41942876, 3, 4365792, 40, 4365792, 40, 41942876, 3, 1, 0, 
  1, 0, 41942876, 3, 4365792, 40, 4365792, 40, 4365792, 40, 41951068, 17, 
  4365792, 40, 4365792, 40, 40093620, 27, 41942876, 3, 1, 0, 4365792, 40, 
  40093620, 27, 40085428, 20, 41951068, 17 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/matint.gi", 19769948 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/matint.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/matint.gi");
elif COM_RESULT = 3  then
Revision.matint_gi:="$Id: matint.gi,v 4.28.2.3 2004/03/17 11:49:50 gap Exp $";
BindGlobal("MATINTsplit",COM_FUN(1));
BindGlobal("MATINTrgcd",COM_FUN(2));
BindGlobal("MATINTmgcdex",COM_FUN(3));
BindGlobal("MATINTbezout",COM_FUN(4));
InstallGlobalFunction(SNFofREF,COM_FUN(5));
BindGlobal("BITLISTS_NFIM",[[false,false,false,false,false],[true,false,false,false,false],[false,true,false,false,false],[true,true,false,false,false],[false,false,true,false,false],[true,false,true,false,false],[false,true,true,false,false],[true,true,true,false,false],[false,false,false,true,false],[true,false,false,true,false],[false,true,false,true,false],[true,true,false,true,false],[false,false,true,true,false],[true,false,true,true,false],[false,true,true,true,false],[true,true,true,true,false],[false,false,false,false,true],[true,false,false,false,true],[false,true,false,false,true],[true,true,false,false,true],[false,false,true,false,true],[true,false,true,false,true],[false,true,true,false,true],[true,true,true,false,true],[false,false,false,true,true],[true,false,false,true,true],[false,true,false,true,true],[true,true,false,true,true],[false,false,true,true,true],[true,false,true,true,true],[false,true,true,true,true],[true,true,true,true,true]]);
BindGlobal("DoNFIM",COM_FUN(6));
InstallGlobalFunction(NormalFormIntMat,COM_FUN(7));
InstallMethod(TriangulizedIntegerMat,"dispatch",true,[IsMatrix],0,COM_FUN(8));
InstallOtherMethod(TriangulizedIntegerMat,"empty matrix",true,[IsList],0,COM_FUN(9));
InstallOtherMethod(TriangulizedIntegerMat,"empty",true,[IsEmpty],0,Immutable);
InstallMethod(TriangulizedIntegerMatTransform,"dispatch",true,[IsMatrix],0,COM_FUN(10));
InstallOtherMethod(TriangulizedIntegerMatTransform,"empty matrix",true,[IsList\
],0,COM_FUN(11));
InstallOtherMethod(TriangulizedIntegerMatTransform,"empty",true,[IsEmpty],0,COM_FUN(12));
InstallMethod(TriangulizeIntegerMat,"dispatch",true,[IsMatrix and IsMutable],0,COM_FUN(13));
InstallOtherMethod(TriangulizeIntegerMat,"empty",true,[IsEmpty],0,Immutable);
InstallMethod(HermiteNormalFormIntegerMat,"dispatch",true,[IsMatrix],0,COM_FUN(14));
InstallOtherMethod(HermiteNormalFormIntegerMat,"empty matrix",true,[IsList],0,COM_FUN(15));
InstallOtherMethod(HermiteNormalFormIntegerMat,"empty",true,[IsEmpty],0,Immutable);
InstallMethod(HermiteNormalFormIntegerMatTransform,"dispatch",true,[IsMatrix],\
0,COM_FUN(16));
InstallOtherMethod(HermiteNormalFormIntegerMatTransform,"empty matrix",true,[IsList],0,COM_FUN(17));
InstallOtherMethod(HermiteNormalFormIntegerMatTransform,"empty",true,[IsEmpty],0,COM_FUN(18));
InstallMethod(SmithNormalFormIntegerMat,"dispatch",true,[IsMatrix],0,COM_FUN(19));
InstallOtherMethod(SmithNormalFormIntegerMat,"empty matrix",true,[IsList],0,COM_FUN(20));
InstallOtherMethod(SmithNormalFormIntegerMat,"empty",true,[IsEmpty],0,Immutable);
InstallMethod(SmithNormalFormIntegerMatTransforms,"dispatch",true,[IsMatrix],0,COM_FUN(21));
InstallOtherMethod(SmithNormalFormIntegerMatTransforms,"empty matrix",true,[IsList],0,COM_FUN(22));
InstallOtherMethod(SmithNormalFormIntegerMatTransforms,"empty",true,[IsEmpty],0,COM_FUN(23));
InstallGlobalFunction(DiagonalizeIntMat,COM_FUN(24));
InstallMethod(DiagonalizeMat,"over the integers",[IsIntegers,IsMatrix and IsMutable],COM_FUN(25));
InstallMethod(BaseIntMat,"use HNF",true,[IsMatrix and IsCyclotomicCollColl],0,COM_FUN(26));
InstallOtherMethod(BaseIntMat,"empty",true,[IsEmpty],0,Immutable);
InstallMethod(BaseIntersectionIntMats,"use HNF",true,[IsMatrix and IsCyclotomicCollColl,IsMatrix and IsCyclotomicCollColl],0,COM_FUN(27));
InstallOtherMethod(BaseIntersectionIntMats,"emptyL",true,[IsEmpty,IsObject],0,COM_FUN(28));
InstallOtherMethod(BaseIntersectionIntMats,"emptyR",true,[IsObject,IsEmpty],0,COM_FUN(29));
InstallMethod(ComplementIntMat,"use HNF and SNF",true,[IsMatrix and IsCyclotomicCollColl,IsMatrix and IsCyclotomicCollColl],0,COM_FUN(30));
InstallOtherMethod(ComplementIntMat,"empty submodule",true,[IsMatrix and IsCyclotomicCollColl,IsList and IsEmpty],0,COM_FUN(31));
InstallMethod(NullspaceIntMat,"use HNF",true,[IsMatrix and IsCyclotomicCollColl],0,COM_FUN(32));
InstallMethod(SolutionIntMat,"use HNF",true,[IsMatrix and IsCyclotomicCollColl,IsList and IsCyclotomicCollection],0,COM_FUN(33));
InstallOtherMethod(SolutionIntMat,"empty",true,[IsEmpty,IsObject],0,COM_FUN(34));
InstallMethod(SolutionNullspaceIntMat,"use HNF",true,[IsMatrix and IsCyclotomicCollColl,IsList and IsCyclotomicCollection],0,COM_FUN(35));
InstallGlobalFunction(DeterminantIntMat,COM_FUN(36));
InstallMethod(AbelianInvariantsOfList,[IsCyclotomicCollection],COM_FUN(37));
InstallOtherMethod(AbelianInvariantsOfList,[IsList and IsEmpty],COM_FUN(38));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/matint.gi"

#F  file="lib/matblock.gi" crc=82739808
RANK_FILTER_LIST  := [ 62800541, 34, 62800541, 34, 52247917, 19, 62800541, 
  34, 58412696, 30, 62800541, 34, 62800541, 34, 62800541, 34, 62800541, 34, 
  62800541, 34, 3694085, 3, 3694085, 3, 62800541, 34, 62800541, 34, 62800541, 
  34, 62800541, 34, 62800541, 34, 65077940, 12, 65077940, 12, 62800541, 34, 
  62800541, 34, 64918210, 8, 64918210, 8, 62800541, 34, 62800541, 34, 17, 18, 
  17, 18, 62800541, 34, 8753637, 45, 257, 15, 257, 15, 8753637, 45, 62800541, 
  34, 7388169, 4, 7388169, 4, 62800541, 34, 62800541, 34, 62800541, 34, 
  62800541, 34, 62800541, 34, 62800541, 34 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/matblock.gi", 82739808 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/matblock.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/matblock.gi");
elif COM_RESULT = 3  then
Revision.matblock_gi:="@(#)$Id: matblock.gi,v 4.16 2002/04/15 10:05:00 sal Exp $";
DeclareRepresentation("IsBlockMatrixRep",IsComponentObjectRep,["blocks","zero","nrb","ncb","rpb","cpb"]);
InstallGlobalFunction(BlockMatrix,COM_FUN(1));
InstallMethod(Length,"for an ordinary block matrix",[IsOrdinaryMatrix and IsBlockMatrixRep],COM_FUN(2));
InstallMethod(\[\],"for an ordinary block matrix and a positive integer",[IsOrdinaryMatrix and IsBlockMatrixRep,IsPosInt],COM_FUN(3));
InstallMethod(TransposedMat,"for an ordinary block matrix",[IsOrdinaryMatrix and IsBlockMatrixRep],COM_FUN(4));
InstallMethod(MatrixByBlockMatrix,[IsMatrix],COM_FUN(5));
InstallGlobalFunction(AsBlockMatrix,COM_FUN(6));
InstallMethod(\=,"for two ordinary block matrices",IsIdenticalObj,[IsOrdinaryMatrix and IsBlockMatrixRep,IsOrdinaryMatrix and IsBlockMatrixRep],COM_FUN(7));
InstallMethod(\+,"for two ordinary block matrices",IsIdenticalObj,[IsOrdinaryMatrix and IsBlockMatrixRep,IsOrdinaryMatrix and IsBlockMatrixRep],COM_FUN(8));
InstallOtherMethod(\+,"for an ordinary block matrix, and a grv",IsIdenticalObj,[IsOrdinaryMatrix and IsBlockMatrixRep,IsGeneralizedRowVector],COM_FUN(9));
InstallOtherMethod(\+,"for a grv, and an ordinary block matrix",IsIdenticalObj,[IsGeneralizedRowVector,IsOrdinaryMatrix and IsBlockMatrixRep],COM_FUN(10));
InstallMethod(AdditiveInverseOp,"for an ordinary block matrix",[IsOrdinaryMatrix and IsBlockMatrixRep],COM_FUN(11));
InstallMethod(\*,"for two ordinary block matrices",IsIdenticalObj,[IsOrdinaryMatrix and IsBlockMatrixRep,IsOrdinaryMatrix and IsBlockMatrixRep],6,COM_FUN(12));
InstallMethod(\*,"for ordinary block matrix and vector",IsCollsElms,[IsOrdinaryMatrix and IsBlockMatrixRep,IsRowVector],COM_FUN(13));
InstallMethod(\*,"for vector and ordinary block matrix",IsElmsColls,[IsRowVector,IsOrdinaryMatrix and IsBlockMatrixRep],COM_FUN(14));
InstallMethod(\*,"for ordinary block matrix and ring element",IsCollCollsElms,[IsOrdinaryMatrix and IsBlockMatrixRep,IsRingElement],COM_FUN(15));
InstallMethod(\*,"for ring element and ordinary block matrix",IsElmsCollColls,[IsRingElement,IsOrdinaryMatrix and IsBlockMatrixRep],COM_FUN(16));
InstallMethod(\*,"for ordinary block matrix and integer",[IsOrdinaryMatrix and IsBlockMatrixRep,IsInt],COM_FUN(17));
InstallMethod(\*,"for integer and ordinary block matrix",[IsInt,IsOrdinaryMatrix and IsBlockMatrixRep],COM_FUN(18));
InstallMethod(\*,"for ordinary block matrix of integers and ffe",[IsOrdinaryMatrix and IsBlockMatrixRep and IsCyclotomicCollColl,IsFFE],COM_FUN(19));
InstallMethod(\*,"for ffe and ordinary block matrix of integers",[IsFFE,IsOrdinaryMatrix and IsBlockMatrixRep and IsCyclotomicCollColl],COM_FUN(20));
InstallOtherMethod(\*,"for an ordinary block matrix, and a mgrv",IsIdenticalObj,[IsOrdinaryMatrix and IsBlockMatrixRep,IsMultiplicativeGeneralizedRowVector],COM_FUN(21));
InstallOtherMethod(\*,"for a mgrv, and an ordinary block matrix",IsIdenticalObj,[IsMultiplicativeGeneralizedRowVector,IsOrdinaryMatrix and IsBlockMatrixRep],COM_FUN(22));
InstallOtherMethod(OneOp,"for an ordinary block matrix",[IsOrdinaryMatrix and IsBlockMatrixRep],3,COM_FUN(23));
InstallOtherMethod(InverseOp,"for an ordinary block matrix",[IsOrdinaryMatrix and IsBlockMatrixRep],COM_FUN(24));
InstallMethod(ViewObj,"for an ordinary block matrix",[IsOrdinaryMatrix and IsBlockMatrixRep],COM_FUN(25));
InstallMethod(PrintObj,"for an ordinary block matrix",[IsOrdinaryMatrix and IsBlockMatrixRep],COM_FUN(26));
InstallMethod(DimensionsMat,"for an ordinary block matrix",[IsOrdinaryMatrix and IsBlockMatrixRep],COM_FUN(27));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/matblock.gi"

#F  file="lib/tuples.gi" crc=78113398
RANK_FILTER_LIST  := [ 8126465, 2, 41951068, 17, 8193, 2, 30393586, 4, 8193, 
  2, 67108280, 15, 67108280, 15, 67108280, 15, 67108280, 15, 67108280, 15, 
  67108280, 15, 67108280, 15, 30393586, 4, 8193, 2, 9203578, 17, 52247917, 
  19, 9203578, 17, 67108280, 15, 67108280, 15, 67108280, 15, 67108280, 15, 
  67108280, 15, 17, 18, 67108280, 15, 67108280, 15, 67108280, 15, 67108280, 
  15, 67108280, 15, 66059509, 5, 66059509, 5, 67108280, 15, 67108280, 15, 
  66059509, 5, 66059509, 5, 67108280, 15, 67108280, 15, 1, 0, 1, 0, 67108280, 
  15, 67108280, 15, 1, 0, 1, 0, 67108280, 15 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/tuples.gi", 78113398 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/tuples.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/tuples.gi");
elif COM_RESULT = 3  then
Revision.tuples_gi:="@(#)$Id: tuples.gi,v 4.29 2002/04/15 10:05:25 sal Exp $";
DeclareInfoClass("InfoTuples");
DeclareRepresentation("IsDefaultTupleRep",IsPositionalObjectRep and IsTuple,[]);
BindGlobal("EmptyTuplesFamily",NewFamily("TuplesFamily([])",IsTuple,IsTuple));
EmptyTuplesFamily!.defaultTupleType:=NewType(EmptyTuplesFamily,IsDefaultTupleRep);
SetComponentsOfTuplesFamily(EmptyTuplesFamily,[]);
InstallValue(TUPLES_FAMILIES,[[EmptyTuplesFamily]]);
InstallMethod(TuplesFamily,"for a collection (of families)",COM_FUN(1),[IsCollection],COM_FUN(2));
InstallOtherMethod(TuplesFamily,"for an empty list",[IsList and IsEmpty],COM_FUN(3));
InstallMethod(Tuple,"for a list",[IsList],COM_FUN(4));
InstallOtherMethod(Tuple,"for a tuples family, and a list",[IsTupleFamily,IsList],COM_FUN(5));
InstallMethod(PrintObj,"for a tuple",[IsTuple],COM_FUN(6));
InstallMethod(ViewObj,"for a tuple (call `PrintObj')",[IsTuple],PrintObj);
InstallMethod(\<,"for two tuples",IsIdenticalObj,[IsTuple,IsTuple],COM_FUN(7));
InstallMethod(\=,"for two tuples",IsIdenticalObj,[IsTuple,IsTuple],COM_FUN(8));
InstallMethod(CanEasilyCompareElements,"for tuple",[IsTuple],COM_FUN(9));
InstallMethod(TupleNC,"for a tuples family, and a list",[IsTupleFamily,IsList],COM_FUN(10));
InstallMethod(\[\],"for a tuple in default representation, and a positive integer",[IsDefaultTupleRep,IsPosInt],COM_FUN(11));
InstallMethod(Length,"for a tuple in default representation",[IsDefaultTupleRep],COM_FUN(12));
InstallMethod(InverseOp,"for a tuple",[IsTuple],COM_FUN(13));
InstallMethod(OneOp,"for a tuple",[IsTuple],COM_FUN(14));
InstallMethod(\*,"for two tuples",[IsTuple,IsTuple],COM_FUN(15));
InstallMethod(\^,"for tuple, and integer",[IsTuple,IsInt],COM_FUN(16));
InstallMethod(AdditiveInverseOp,"for a tuple",[IsTuple],COM_FUN(17));
InstallMethod(ZeroOp,"for a tuple",[IsTuple],COM_FUN(18));
InstallMethod(\+,"for two tuples",[IsTuple,IsTuple],COM_FUN(19));
InstallOtherMethod(\+,"for a tuple, and a default list",[IsTuple,IsListDefault],SUM_SCL_LIST_DEFAULT);
InstallOtherMethod(\+,"for a default list, and a tuple",[IsListDefault,IsTuple],SUM_LIST_SCL_DEFAULT);
InstallOtherMethod(\*,"for a tuple, and a default list",[IsTuple,IsListDefault],PROD_SCL_LIST_DEFAULT);
InstallOtherMethod(\*,"for a default list, and a tuple",[IsListDefault,IsTuple],PROD_LIST_SCL_DEFAULT);
InstallOtherMethod(\+,"for a tuple, and a non-list",[IsTuple,IsObject],COM_FUN(20));
InstallOtherMethod(\+,"for a non-list, and a tuple",[IsObject,IsTuple],COM_FUN(21));
InstallOtherMethod(\*,"for a tuple, and a non-list",[IsTuple,IsObject],COM_FUN(22));
InstallOtherMethod(\*,"for a non-list, and a tuple",[IsObject,IsTuple],COM_FUN(23));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/tuples.gi"

#F  file="lib/domain.gi" crc=-113678274
RANK_FILTER_LIST  := [ 8134657, 5, 9017489, 5, 9017489, 5, 8134657, 5, 
  9017489, 5, 9017489, 5, 8134657, 5, 9017489, 5, 9017489, 5, 8134657, 5, 
  9017489, 5, 9017489, 5, 1985, 1, 41951068, 17, 1985, 1, 8134657, 5, 
  8126465, 2, 9264497, 8, 9017489, 5, 10002545, 8, 9079985, 8, 24342324, 6, 
  24342324, 6, 9017489, 5, 1, 0, 9017489, 5, 9263505, 6, 24342324, 6, 
  42571231, 10, 9017489, 5, 24105743, 6, 9017489, 5, 9017489, 5, 8112546, 4, 
  9017489, 5, 9017489, 5, 8112546, 4 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/domain.gi", -113678274 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/domain.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/domain.gi");
elif COM_RESULT = 3  then
Revision.domain_gi:="@(#)$Id: domain.gi,v 4.49 2003/04/15 15:45:37 gap Exp $";
InstallMethod(\=,"for a list and a domain",IsIdenticalObj,[IsCollection and IsList,IsDomain],COM_FUN(1));
InstallMethod(\=,"for a domain and a list",IsIdenticalObj,[IsDomain,IsCollection and IsList],COM_FUN(2));
InstallMethod(\=,"for two domains",IsIdenticalObj,[IsDomain,IsDomain],COM_FUN(3));
InstallMethod(\<,"for a list and a domain",IsIdenticalObj,[IsCollection and IsList,IsDomain],COM_FUN(4));
InstallMethod(\<,"for a domain and a list",IsIdenticalObj,[IsDomain,IsCollection and IsList],COM_FUN(5));
InstallMethod(SetParent,"method that calls 'UseSubsetRelation'",IsIdenticalObj,[IsDomain,IsDomain],COM_FUN(6));
InstallGlobalFunction(Domain,COM_FUN(7));
InstallMethod(DomainByGenerators,"for family and empty list",[IsFamily,IsList and IsEmpty],COM_FUN(8));
InstallMethod(DomainByGenerators,"for family and list & collection",[IsFamily,IsCollection and IsList],COM_FUN(9));
InstallOtherMethod(DomainByGenerators,"for a collection",[IsCollection],COM_FUN(10));
InstallImmediateMethod(GeneratorsOfDomain,IsDomain and HasAsList and IsAttributeStoringRep,0,AsList);
InstallMethod(GeneratorsOfDomain,"for a domain (delegate to `AsList')",[IsDomain],AsList);
InstallImmediateMethod(AsList,IsDomain and HasAsSSortedList and IsAttributeStoringRep,0,AsSSortedList);
InstallImmediateMethod(Enumerator,IsDomain and HasEnumeratorSorted and IsAttributeStoringRep,0,EnumeratorSorted);
InstallMethod(AsList,"for a domain with stored domain generators",[IsDomain and HasGeneratorsOfDomain],COM_FUN(11));
InstallMethod(Enumerator,"for a domain with stored domain generators",[IsDomain and HasGeneratorsOfDomain],COM_FUN(12));
InstallMethod(EnumeratorSorted,"for a domain",[IsDomain],COM_FUN(13));
InstallMethod(\in,"for a domain, and an element",IsElmsColls,[IsObject,IsDomain],COM_FUN(14));
InstallMethod(Representative,"for a domain with known elements list",[IsDomain and HasAsList],RepresentativeFromGenerators(AsList));
InstallMethod(Representative,"for a domain with known domain generators",[IsDomain and HasGeneratorsOfDomain],RepresentativeFromGenerators(GeneratorsOfDomain));
InstallMethod(Size,"for a trivial domain",[IsDomain and IsTrivial],COM_FUN(15));
InstallMethod(IsSubset,"test whether domain is parent of the other",IsIdenticalObj,[IsDomain,IsDomain and HasParent],SUM_FLAGS,COM_FUN(16));
InstallMethod(CanComputeIsSubset,"default for domains: no unless identical",[IsDomain,IsDomain],COM_FUN(17));
InstallMethod(Intersection2,"whole family and domain",IsIdenticalObj,[IsCollection and IsWholeFamily,IsDomain],SUM_FLAGS,COM_FUN(18));
InstallMethod(Intersection2,"domain and whole family",IsIdenticalObj,[IsDomain,IsCollection and IsWholeFamily],SUM_FLAGS,COM_FUN(19));
InstallGlobalFunction(InstallAccessToGenerators,COM_FUN(20));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/domain.gi"

#F  file="lib/mapping.gi" crc=90855095
RANK_FILTER_LIST  := [ 1985, 1, 49346896, 7, 33547271, 11, 49346896, 7, 
  49346896, 7, 49346896, 7, 55637722, 8, 55637722, 8, 55637722, 8, 55637722, 
  8, 49346896, 7, 49346896, 7, 49346896, 7, 49346896, 7, 33547271, 11, 
  49346896, 7, 49346896, 7, 49346896, 7, 49346896, 7, 49346896, 7, 57352313, 
  17, 57352313, 17, 49346896, 7, 49346896, 7, 49346896, 7, 49346896, 7, 
  49346896, 7, 1, 0, 49346896, 7, 49346896, 7, 49346896, 7, 49346896, 7, 
  5814748, 10, 46186203, 9, 1, 0, 64997052, 11, 49346896, 7, 1, 0, 33547271, 
  11, 1, 0, 45410419, 8, 1, 0, 28177528, 9, 1, 0, 49346896, 7, 8126465, 2, 
  49346896, 7, 41951068, 17, 49346896, 7, 48444861, 9, 48034737, 8, 1, 0, 
  45410419, 8, 1, 0, 49346896, 7, 1, 0, 64997052, 11, 1, 0, 49346896, 7, 1, 
  0, 28177528, 9, 1, 0, 49346896, 7, 8126465, 2, 49346896, 7, 41951068, 17, 
  49346896, 7, 46186203, 9, 48034737, 8, 1, 0, 45410419, 8, 1, 0, 49346896, 
  7, 33336613, 22, 49346896, 7, 48415432, 22, 49346896, 7, 1108864, 22, 
  24072117, 16, 1108864, 22, 24072117, 16, 1107872, 20, 1107872, 20, 1107872, 
  20, 1107872, 20, 1107872, 20, 1107872, 20, 67108280, 15, 1107872, 20, 
  1107872, 20, 40162743, 11 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/mapping.gi", 90855095 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/mapping.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/mapping.gi");
elif COM_RESULT = 3  then
Revision.mapping_gi:="@(#)$Id: mapping.gi,v 4.67 2003/03/20 12:07:33 gap Exp $";
InstallMethod(FamiliesOfGeneralMappingsAndRanges,"for a family (return empty list)",true,[IsFamily],0,COM_FUN(1));
InstallGlobalFunction(GeneralMappingsFamily,COM_FUN(2));
InstallMethod(PrintObj,"for a general mapping",true,[IsGeneralMapping],0,COM_FUN(3));
InstallMethod(PrintObj,"for a mapping",true,[IsMapping],0,COM_FUN(4));
InstallOtherMethod(IsOne,"for general mapping",true,[IsGeneralMapping],0,COM_FUN(5));
InstallOtherMethod(IsZero,"for general mapping",true,[IsGeneralMapping],0,COM_FUN(6));
InstallOtherMethod(IsEndoGeneralMapping,"for general mapping",true,[IsGeneralMapping],0,COM_FUN(7));
InstallGlobalFunction(Image,COM_FUN(8));
InstallGlobalFunction(Images,COM_FUN(9));
InstallGlobalFunction(PreImage,COM_FUN(10));
InstallGlobalFunction(PreImages,COM_FUN(11));
InstallGlobalFunction(CompositionMapping,COM_FUN(12));
InstallImmediateMethod(IsInjective,IsGeneralMapping and HasInverseGeneralMapping,0,COM_FUN(13));
InstallImmediateMethod(IsSingleValued,IsGeneralMapping and HasInverseGeneralMapping,0,COM_FUN(14));
InstallImmediateMethod(IsSurjective,IsGeneralMapping and HasInverseGeneralMapping,0,COM_FUN(15));
InstallImmediateMethod(IsTotal,IsGeneralMapping and HasInverseGeneralMapping,0,COM_FUN(16));
InstallMethod(IsTotal,"for a general mapping",true,[IsGeneralMapping],0,COM_FUN(17));
InstallMethod(IsSurjective,"for a general mapping",true,[IsGeneralMapping],0,COM_FUN(18));
InstallMethod(IsSingleValued,"for a general mapping",true,[IsGeneralMapping],0,COM_FUN(19));
InstallMethod(IsInjective,"for a general mapping",true,[IsGeneralMapping],0,COM_FUN(20));
InstallMethod(IsInjective,"for a mapping",true,[IsGeneralMapping and IsTotal and IsSingleValued],0,COM_FUN(21));
InstallMethod(\=,"for two general mappings",IsIdenticalObj,[IsGeneralMapping,IsGeneralMapping],0,COM_FUN(22));
InstallMethod(\<,"for two general mappings",IsIdenticalObj,[IsGeneralMapping,IsGeneralMapping],0,COM_FUN(23));
InstallOtherMethod(\+,"for general mapping and zero mapping",IsIdenticalObj,[IsGeneralMapping,IsGeneralMapping and IsZero],0,COM_FUN(24));
InstallOtherMethod(\+,"for zero mapping and general mapping",IsIdenticalObj,[IsGeneralMapping and IsZero,IsGeneralMapping],0,COM_FUN(25));
InstallMethod(\*,"for two general mappings",FamSource2EqFamRange1,[IsGeneralMapping,IsGeneralMapping],0,COM_FUN(26));
InstallMethod(\^,"for two general mappings",FamSourceRgtEqFamsLft,[IsGeneralMapping,IsGeneralMapping],0,COM_FUN(27));
InstallOtherMethod(\^,"for element in the source, and general mapping",FamElmEqFamSource,[IsObject,IsGeneralMapping],0,COM_FUN(28));
InstallOtherMethod(OneOp,"for a general mapping",true,[IsGeneralMapping],0,COM_FUN(29));
InstallOtherMethod(ZeroOp,"for a general mapping",true,[IsGeneralMapping],0,COM_FUN(30));
InstallMethod(InverseOp,"for a general mapping",true,[IsGeneralMapping],0,COM_FUN(31));
InstallMethod(\*,"for zero and total general mapping",FamElmEqFamRange,[IsRingElement and IsZero,IsGeneralMapping and IsTotal],0,COM_FUN(32));
InstallOtherMethod(\/,"for element, and inj. & surj. general mapping",FamElmEqFamRange,[IsObject,IsGeneralMapping and IsInjective and IsSurjective],0,COM_FUN(33));
InstallOtherMethod(ImageElm,"for general mapping, and element",FamSourceEqFamElm,[IsGeneralMapping,IsObject],0,COM_FUN(34));
InstallMethod(ImageElm,"for mapping, and element",FamSourceEqFamElm,[IsGeneralMapping and IsTotal and IsSingleValued,IsObject],0,ImagesRepresentative);
InstallMethod(ImagesElm,"for non s.p. general mapping, and element",FamSourceEqFamElm,[IsNonSPGeneralMapping,IsObject],0,COM_FUN(35));
InstallMethod(ImagesElm,"for constant time access general mapping, and element",FamSourceEqFamElm,[IsGeneralMapping and IsConstantTimeAccessGeneralMapping,IsObject],0,COM_FUN(36));
InstallMethod(ImagesSet,"for general mapping, and finite collection",CollFamSourceEqFamElms,[IsGeneralMapping,IsCollection],0,COM_FUN(37));
InstallMethod(ImagesSet,"for general mapping, and empty list",true,[IsGeneralMapping,IsList and IsEmpty],0,COM_FUN(38));
InstallMethod(ImagesSource,"for general mapping",true,[IsGeneralMapping],0,COM_FUN(39));
InstallMethod(ImagesSource,"for surjective general mapping (delegate to `Range')",true,[IsGeneralMapping and IsSurjective],SUM_FLAGS,Range);
InstallMethod(ImagesRepresentative,"for s.p. general mapping, and element",FamSourceEqFamElm,[IsSPGeneralMapping,IsObject],0,COM_FUN(40));
InstallMethod(ImagesRepresentative,"for non s.p. general mapping, and element",FamSourceEqFamElm,[IsNonSPGeneralMapping,IsObject],0,COM_FUN(41));
InstallOtherMethod(PreImageElm,"for general mapping, and element",FamRangeEqFamElm,[IsGeneralMapping,IsObject],0,COM_FUN(42));
InstallMethod(PreImageElm,"for inj. & surj. general mapping, and element",FamRangeEqFamElm,[IsGeneralMapping and IsInjective and IsSurjective,IsObject],0,PreImagesRepresentative);
InstallMethod(PreImagesElm,"for general mapping with finite source, and element",FamRangeEqFamElm,[IsGeneralMapping,IsObject],0,COM_FUN(43));
InstallMethod(PreImagesElm,"for constant time access general mapping, and element",FamRangeEqFamElm,[IsGeneralMapping and IsConstantTimeAccessGeneralMapping,IsObject],0,COM_FUN(44));
InstallMethod(PreImagesSet,"for general mapping, and finite collection",CollFamRangeEqFamElms,[IsGeneralMapping,IsCollection],0,COM_FUN(45));
InstallMethod(PreImagesSet,"for general mapping, and empty list",true,[IsGeneralMapping,IsList and IsEmpty],0,COM_FUN(46));
InstallMethod(PreImagesRange,"for general mapping",true,[IsGeneralMapping],0,COM_FUN(47));
InstallMethod(PreImagesRange,"for total general mapping (delegate to `Source')",true,[IsGeneralMapping and IsTotal],SUM_FLAGS,Source);
InstallMethod(PreImagesRepresentative,"for s.p. general mapping, and element",FamRangeEqFamElm,[IsSPGeneralMapping,IsObject],0,COM_FUN(48));
InstallMethod(PreImagesRepresentative,"for total non-s.p. general mapping, and element",FamRangeEqFamElm,[IsNonSPGeneralMapping,IsObject],0,COM_FUN(49));
InstallGlobalFunction(GeneralMappingByElements,COM_FUN(50));
InstallMethod(UnderlyingRelation,"for a general mapping",true,[IsGeneralMapping],0,COM_FUN(51));
InstallMethod(SetUnderlyingGeneralMapping,"for an underlying relation and a general mapping",true,[IsDomain and IsTupleCollection and HasAsList and IsAttributeStoringRep,IsGeneralMapping],0,COM_FUN(52));
InstallMethod(SetUnderlyingGeneralMapping,"for an underlying relation and a general mapping",true,[IsDomain and IsTupleCollection and HasGeneratorsOfDomain and IsAttributeStoringRep,IsGeneralMapping],0,COM_FUN(53));
InstallMethod(SetAsList,"for an underlying relation and a list of tuples",IsIdenticalObj,[IsDomain and IsTupleCollection and HasUnderlyingGeneralMapping and IsAttributeStoringRep,IsTupleCollection],0,COM_FUN(54));
InstallMethod(SetGeneratorsOfDomain,"for an underlying relation and a list of tuples",IsIdenticalObj,[IsDomain and IsTupleCollection and HasUnderlyingGeneralMapping and IsAttributeStoringRep,IsTupleCollection],0,COM_FUN(55));
InstallMethod(\=,"for two underlying relations of general mappings",IsIdenticalObj,[IsDomain and IsTupleCollection and HasUnderlyingGeneralMapping,IsDomain and IsTupleCollection and HasUnderlyingGeneralMapping],0,COM_FUN(56));
InstallMethod(\<,"for two underlying relations of general mappings",IsIdenticalObj,[IsDomain and IsTupleCollection and HasUnderlyingGeneralMapping,IsDomain and IsTupleCollection and HasUnderlyingGeneralMapping],0,COM_FUN(57));
InstallMethod(IsFinite,"for an underlying relation of a general mapping",true,[IsDomain and IsTupleCollection and HasUnderlyingGeneralMapping],0,COM_FUN(58));
InstallMethod(Enumerator,"for an underlying relation of a general mapping",true,[IsDomain and IsTupleCollection and HasUnderlyingGeneralMapping],0,COM_FUN(59));
InstallMethod(\in,"for an element and an underlying relation of a general mapping",IsElmsColls,[IsTuple,IsDomain and IsTupleCollection and HasUnderlyingGeneralMapping],0,COM_FUN(60));
InstallMethod(Size,"for an underlying relation of a general mapping",true,[IsDomain and IsTupleCollection and HasUnderlyingGeneralMapping],0,COM_FUN(61));
InstallMethod(IsGeneratorsOfMagmaWithInverses,"for a collection of general mappings",true,[IsGeneralMappingCollection],0,COM_FUN(62));
InstallGlobalFunction(CopyMappingAttributes,COM_FUN(63));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/mapping.gi"

#F  file="lib/mapprep.gi" crc=-93012272
RANK_FILTER_LIST  := [ 645171, 10, 645171, 10, 49346896, 7, 49346896, 7, 
  50331409, 10, 50331409, 10, 50331409, 10, 50331409, 10, 50331409, 10, 1, 0, 
  50331409, 10, 8126465, 2, 50331409, 10, 1, 0, 50331409, 10, 1, 0, 50331409, 
  10, 8126465, 2, 50331409, 10, 1, 0, 62078109, 16, 62078109, 16, 851633, 16, 
  851633, 16, 50331409, 10, 50331409, 10, 36814309, 14, 1, 0, 36814309, 14, 
  1, 0, 36814309, 14, 1, 0, 36814309, 14, 1, 0, 6520698, 19, 1, 0, 6520698, 
  19, 1, 0, 6520698, 19, 1, 0, 6520698, 19, 36814309, 14, 36814309, 14, 
  6520698, 19, 6520698, 19, 10631579, 10, 49346896, 7, 56686403, 9, 56686403, 
  9, 56686403, 9, 56686403, 9, 56686403, 9, 56686403, 9, 56686403, 9, 
  56686403, 9, 40886778, 13, 1, 0, 56686403, 9, 1, 0, 56686403, 9, 8126465, 
  2, 56686403, 9, 1, 0, 5227680, 13, 1, 0, 56686403, 9, 1, 0, 56686403, 9, 
  8126465, 2, 7339508, 9, 1, 0, 56686403, 9, 56686403, 9, 8126465, 2, 
  14259685, 17, 17, 18, 14259685, 17, 1, 0, 14259685, 17, 1, 0, 14259685, 17, 
  8126465, 2, 14259685, 17, 14259685, 17, 1, 0, 14259685, 17, 1, 0, 14259685, 
  17, 1, 0, 14259685, 17, 8126465, 2, 14259685, 17, 1, 0, 14259685, 17, 
  14259685, 17, 49346896, 7, 14259685, 17, 14259685, 17, 49346896, 7, 
  8126465, 2, 65935670, 14, 57352313, 17, 52247917, 19, 57352313, 17, 
  57352313, 17, 1, 0, 57352313, 17, 1, 0, 57352313, 17, 8126465, 2, 57352313, 
  17, 1, 0, 57352313, 17, 1, 0, 57352313, 17, 8126465, 2, 57352313, 17, 1, 0, 
  57352313, 17, 57352313, 17, 49346896, 7, 57352313, 17, 57352313, 17, 
  51545386, 11, 57352313, 17, 57352313, 17 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/mapprep.gi", -93012272 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/mapprep.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/mapprep.gi");
elif COM_RESULT = 3  then
Revision.mapprep_gi:="@(#)$Id: mapprep.gi,v 4.40 2002/05/16 13:39:29 stefan Exp $";
DeclareRepresentation("IsDefaultGeneralMappingRep",IsGeneralMapping and HasSource and HasRange,[]);
InstallGlobalFunction(TypeOfDefaultGeneralMapping,COM_FUN(1));
InstallMethod(Range,"for default general mapping",true,[IsGeneralMapping and IsDefaultGeneralMappingRep],GETTER_FLAGS+1,COM_FUN(2));
InstallMethod(Source,"for default general mapping",true,[IsGeneralMapping and IsDefaultGeneralMappingRep],GETTER_FLAGS+1,COM_FUN(3));
InstallGlobalFunction(ConstituentsCompositionMapping,COM_FUN(4));
InstallMethod(CompositionMapping2,"for two general mappings",FamSource1EqFamRange2,[IsGeneralMapping,IsGeneralMapping],0,COM_FUN(5));
InstallMethod(IsInjective,"for a composition mapping",true,[IsCompositionMappingRep],0,COM_FUN(6));
InstallMethod(IsSingleValued,"for a composition mapping",true,[IsCompositionMappingRep],0,COM_FUN(7));
InstallMethod(IsSurjective,"for a composition mapping",true,[IsCompositionMappingRep],0,COM_FUN(8));
InstallMethod(IsTotal,"for a composition mapping",true,[IsCompositionMappingRep],0,COM_FUN(9));
InstallMethod(ImagesElm,"for a composition mapping, and an element",FamSourceEqFamElm,[IsCompositionMappingRep,IsObject],0,COM_FUN(10));
InstallMethod(ImagesSet,"for a composition mapping, and an collection",CollFamSourceEqFamElms,[IsCompositionMappingRep,IsCollection],0,COM_FUN(11));
InstallMethod(ImagesRepresentative,"for a composition mapping, and an element",FamSourceEqFamElm,[IsCompositionMappingRep,IsObject],0,COM_FUN(12));
InstallMethod(PreImagesElm,"for a composition mapping, and an element",FamRangeEqFamElm,[IsCompositionMappingRep,IsObject],0,COM_FUN(13));
InstallMethod(PreImagesSet,"for a composition mapping, and an collection",CollFamRangeEqFamElms,[IsCompositionMappingRep,IsCollection],0,COM_FUN(14));
InstallMethod(PreImagesRepresentative,"for a composition mapping, and an element",FamRangeEqFamElm,[IsCompositionMappingRep,IsObject],0,COM_FUN(15));
InstallMethod(KernelOfAdditiveGeneralMapping,"for a composition mapping that resp. add. and add.inv.",true,[IsGeneralMapping and IsCompositionMappingRep and RespectsAddition and RespectsAdditiveInverses],0,COM_FUN(16));
InstallMethod(CoKernelOfAdditiveGeneralMapping,"for a composition mapping that resp. add. and add.inv.",true,[IsGeneralMapping and IsCompositionMappingRep and RespectsAddition and RespectsAdditiveInverses],0,COM_FUN(17));
InstallMethod(KernelOfMultiplicativeGeneralMapping,"for a composition mapping that resp. mult. and inv.",true,[IsGeneralMapping and IsCompositionMappingRep and RespectsMultiplication and RespectsInverses],0,COM_FUN(18));
InstallMethod(CoKernelOfMultiplicativeGeneralMapping,"for a composition mapping that resp. mult. and inv.",true,[IsGeneralMapping and IsCompositionMappingRep and RespectsMultiplication and RespectsInverses],0,COM_FUN(19));
InstallMethod(ViewObj,"for a composition mapping",true,[IsCompositionMappingRep],100,COM_FUN(20));
InstallMethod(PrintObj,"for a composition mapping",true,[IsCompositionMappingRep],100,COM_FUN(21));
DeclareRepresentation("IsMappingByFunctionRep",IsMapping and IsAttributeStoringRep,["fun"]);
DeclareRepresentation("IsMappingByFunctionWithInverseRep",IsMappingByFunctionRep and IsBijective,["fun","invFun"]);
DeclareRepresentation("IsNonSPMappingByFunctionRep",IsNonSPGeneralMapping and IsMappingByFunctionRep,[]);
DeclareRepresentation("IsNonSPMappingByFunctionWithInverseRep",IsMappingByFunctionWithInverseRep and IsNonSPMappingByFunctionRep,["fun","invFun"]);
DeclareRepresentation("IsSPMappingByFunctionRep",IsSPGeneralMapping and IsMappingByFunctionRep,[]);
DeclareRepresentation("IsSPMappingByFunctionWithInverseRep",IsMappingByFunctionWithInverseRep and IsSPMappingByFunctionRep,["fun","invFun"]);
InstallGlobalFunction(MappingByFunction,COM_FUN(22));
InstallMethod(ImageElm,"for mapping by function",FamSourceEqFamElm,[IsMappingByFunctionRep,IsObject],0,COM_FUN(23));
InstallMethod(ImagesElm,"for mapping by function",FamSourceEqFamElm,[IsMappingByFunctionRep,IsObject],0,COM_FUN(24));
InstallMethod(ImagesRepresentative,"for mapping by function",FamSourceEqFamElm,[IsMappingByFunctionRep,IsObject],0,COM_FUN(25));
InstallMethod(PreImagesRepresentative,"for mapping by function",FamRangeEqFamElm,[IsMappingByFunctionRep,IsObject],0,COM_FUN(26));
InstallMethod(PreImageElm,"for mapping by function",FamRangeEqFamElm,[IsMappingByFunctionWithInverseRep,IsObject],0,COM_FUN(27));
InstallMethod(PreImagesElm,"for mapping by function",FamRangeEqFamElm,[IsMappingByFunctionWithInverseRep,IsObject],0,COM_FUN(28));
InstallMethod(PreImagesRepresentative,"for mapping by function with inverse",FamRangeEqFamElm,[IsMappingByFunctionWithInverseRep,IsObject],0,COM_FUN(29));
InstallMethod(InverseGeneralMapping,"for mapping by function",true,[IsMappingByFunctionWithInverseRep],0,COM_FUN(30));
InstallMethod(ViewObj,"for mapping by function",true,[IsMappingByFunctionRep],0,COM_FUN(31));
InstallMethod(PrintObj,"for mapping by function",true,[IsMappingByFunctionRep],0,COM_FUN(32));
InstallMethod(ViewObj,"for mapping by function with inverse",true,[IsMappingByFunctionWithInverseRep],0,COM_FUN(33));
InstallMethod(PrintObj,"for mapping by function with inverse",true,[IsMappingByFunctionWithInverseRep],0,COM_FUN(34));
DeclareRepresentation("IsInverseGeneralMappingRep",IsNonSPGeneralMapping,[]);
InstallImmediateMethod(InverseGeneralMapping,IsGeneralMapping and HasInverse and IsAttributeStoringRep,0,COM_FUN(35));
InstallMethod(InverseGeneralMapping,"for a general mapping",true,[IsGeneralMapping],0,COM_FUN(36));
InstallMethod(IsSingleValued,"for an inverse mapping",true,[IsGeneralMapping and IsInverseGeneralMappingRep],0,COM_FUN(37));
InstallMethod(IsInjective,"for an inverse mapping",true,[IsGeneralMapping and IsInverseGeneralMappingRep],0,COM_FUN(38));
InstallMethod(IsSurjective,"for an inverse mapping",true,[IsGeneralMapping and IsInverseGeneralMappingRep],0,COM_FUN(39));
InstallMethod(IsTotal,"for an inverse mapping",true,[IsGeneralMapping and IsInverseGeneralMappingRep],0,COM_FUN(40));
InstallMethod(CoKernelOfAdditiveGeneralMapping,"for an inverse mapping",true,[IsGeneralMapping and IsInverseGeneralMappingRep],0,COM_FUN(41));
InstallMethod(KernelOfAdditiveGeneralMapping,"for an inverse mapping",true,[IsGeneralMapping and IsInverseGeneralMappingRep],0,COM_FUN(42));
InstallMethod(CoKernelOfMultiplicativeGeneralMapping,"for an inverse mapping",true,[IsGeneralMapping and IsInverseGeneralMappingRep],0,COM_FUN(43));
InstallMethod(KernelOfMultiplicativeGeneralMapping,"for an inverse mapping",true,[IsGeneralMapping and IsInverseGeneralMappingRep],0,COM_FUN(44));
InstallMethod(ImageElm,"for an inverse mapping and an element",FamSourceEqFamElm,[IsMapping and IsInverseGeneralMappingRep,IsObject],0,COM_FUN(45));
InstallMethod(ImagesElm,"for an inverse mapping and an element",FamSourceEqFamElm,[IsGeneralMapping and IsInverseGeneralMappingRep,IsObject],0,COM_FUN(46));
InstallMethod(ImagesSet,"for an inverse mapping and a collection",CollFamSourceEqFamElms,[IsGeneralMapping and IsInverseGeneralMappingRep,IsCollection],0,COM_FUN(47));
InstallMethod(ImagesRepresentative,"for an inverse mapping and an element",FamSourceEqFamElm,[IsGeneralMapping and IsInverseGeneralMappingRep,IsObject],0,COM_FUN(48));
InstallMethod(PreImageElm,"for an inj. & surj. inverse mapping, and an element",FamRangeEqFamElm,[IsGeneralMapping and IsInverseGeneralMappingRep and IsInjective and IsSurjective,IsObject],0,COM_FUN(49));
InstallMethod(PreImagesElm,"for an inverse mapping and an element",FamRangeEqFamElm,[IsGeneralMapping and IsInverseGeneralMappingRep,IsObject],0,COM_FUN(50));
InstallMethod(PreImagesSet,"for an inverse mapping and a collection",CollFamRangeEqFamElms,[IsGeneralMapping and IsInverseGeneralMappingRep,IsCollection],0,COM_FUN(51));
InstallMethod(PreImagesRepresentative,"for an inverse mapping and an element",FamRangeEqFamElm,[IsInverseGeneralMappingRep,IsObject],0,COM_FUN(52));
InstallMethod(ViewObj,"for an inverse mapping",true,[IsGeneralMapping and IsInverseGeneralMappingRep],100,COM_FUN(53));
InstallMethod(PrintObj,"for an inverse mapping",true,[IsGeneralMapping and IsInverseGeneralMappingRep],100,COM_FUN(54));
BindGlobal("ImmediateImplicationsIdentityMapping",COM_FUN(55));
InstallMethod(IdentityMapping,"for a collection",true,[IsCollection],0,COM_FUN(56));
InstallMethod(\^,"for identity mapping and integer",true,[IsGeneralMapping and IsOne,IsInt],SUM_FLAGS,COM_FUN(57));
InstallMethod(ImageElm,"for identity mapping and object",FamSourceEqFamElm,[IsGeneralMapping and IsOne,IsObject],SUM_FLAGS,COM_FUN(58));
InstallMethod(ImagesElm,"for identity mapping and object",FamSourceEqFamElm,[IsGeneralMapping and IsOne,IsObject],SUM_FLAGS,COM_FUN(59));
InstallMethod(ImagesSet,"for identity mapping and collection",CollFamSourceEqFamElms,[IsGeneralMapping and IsOne,IsCollection],SUM_FLAGS,COM_FUN(60));
InstallMethod(ImagesSource,"for identity mapping",true,[IsGeneralMapping and IsOne],SUM_FLAGS,COM_FUN(61));
InstallMethod(ImagesRepresentative,"for identity mapping and object",FamSourceEqFamElm,[IsGeneralMapping and IsOne,IsObject],SUM_FLAGS,COM_FUN(62));
InstallMethod(PreImageElm,"for identity mapping and object",FamRangeEqFamElm,[IsGeneralMapping and IsOne,IsObject],SUM_FLAGS,COM_FUN(63));
InstallMethod(PreImagesElm,"for identity mapping and object",FamRangeEqFamElm,[IsGeneralMapping and IsOne,IsObject],SUM_FLAGS,COM_FUN(64));
InstallMethod(PreImagesSet,"for identity mapping and collection",CollFamRangeEqFamElms,[IsGeneralMapping and IsOne,IsCollection],SUM_FLAGS,COM_FUN(65));
InstallMethod(PreImagesRepresentative,"for identity mapping and object",FamRangeEqFamElm,[IsGeneralMapping and IsOne,IsObject],SUM_FLAGS,COM_FUN(66));
InstallMethod(ViewObj,"for identity mapping",true,[IsGeneralMapping and IsOne],SUM_FLAGS,COM_FUN(67));
InstallMethod(PrintObj,"for identity mapping",true,[IsGeneralMapping and IsOne],SUM_FLAGS,COM_FUN(68));
InstallMethod(CompositionMapping2,"for general mapping and identity mapping",FamSource1EqFamRange2,[IsGeneralMapping,IsGeneralMapping and IsOne],SUM_FLAGS+1,COM_FUN(69));
InstallMethod(CompositionMapping2,"for identity mapping and general mapping",FamSource1EqFamRange2,[IsGeneralMapping and IsOne,IsGeneralMapping],SUM_FLAGS+1,COM_FUN(70));
BindGlobal("ImmediateImplicationsZeroMapping",COM_FUN(71));
InstallMethod(ZeroMapping,"for collection and additive-magma-with-zero",true,[IsCollection,IsAdditiveMagmaWithZero],0,COM_FUN(72));
InstallMethod(\^,"for zero mapping and positive integer",true,[IsGeneralMapping and IsZero,IsPosInt],SUM_FLAGS,COM_FUN(73));
InstallMethod(ImagesSource,"for zero mapping",true,[IsGeneralMapping and IsZero],SUM_FLAGS,COM_FUN(74));
InstallMethod(ImageElm,"for zero mapping and object",FamSourceEqFamElm,[IsGeneralMapping and IsZero,IsObject],SUM_FLAGS,COM_FUN(75));
InstallMethod(ImagesElm,"for zero mapping and object",FamSourceEqFamElm,[IsGeneralMapping and IsZero,IsObject],SUM_FLAGS,COM_FUN(76));
InstallMethod(ImagesSet,"for zero mapping and collection",CollFamSourceEqFamElms,[IsGeneralMapping and IsZero,IsCollection],SUM_FLAGS,COM_FUN(77));
InstallMethod(ImagesRepresentative,"for zero mapping and object",FamSourceEqFamElm,[IsGeneralMapping and IsZero,IsObject],SUM_FLAGS,COM_FUN(78));
InstallMethod(PreImagesElm,"for zero mapping and object",FamRangeEqFamElm,[IsGeneralMapping and IsZero,IsObject],SUM_FLAGS,COM_FUN(79));
InstallMethod(PreImagesSet,"for zero mapping and collection",CollFamRangeEqFamElms,[IsGeneralMapping and IsZero,IsCollection],SUM_FLAGS,COM_FUN(80));
InstallMethod(PreImagesRepresentative,"for zero mapping and object",FamRangeEqFamElm,[IsGeneralMapping and IsZero,IsObject],SUM_FLAGS,COM_FUN(81));
InstallMethod(ViewObj,"for zero mapping",true,[IsGeneralMapping and IsZero],SUM_FLAGS,COM_FUN(82));
InstallMethod(PrintObj,"for zero mapping",true,[IsGeneralMapping and IsZero],SUM_FLAGS,COM_FUN(83));
InstallMethod(CompositionMapping2,"for general mapping and zero mapping",FamSource1EqFamRange2,[IsGeneralMapping,IsGeneralMapping and IsZero],SUM_FLAGS,COM_FUN(84));
InstallMethod(CompositionMapping2,"for zero mapping and single-valued gen. mapping that resp. zero",FamSource1EqFamRange2,[IsGeneralMapping and IsZero,IsGeneralMapping and IsSingleValued and RespectsZero],SUM_FLAGS,COM_FUN(85));
InstallMethod(IsInjective,"for zero mapping",true,[IsGeneralMapping and IsZero],0,COM_FUN(86));
InstallMethod(IsSurjective,"for zero mapping",true,[IsGeneralMapping and IsZero],0,COM_FUN(87));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/mapprep.gi"

#F  file="lib/mapphomo.gi" crc=52552515
RANK_FILTER_LIST  := [ 49346896, 7, 49346896, 7, 49346896, 7, 7743158, 11, 
  64465261, 13, 7743158, 11, 35273178, 13, 44568071, 13, 44568071, 13, 
  43255912, 14, 1, 0, 43255912, 14, 53660808, 18, 15757352, 20, 53660808, 18, 
  43255912, 14, 1, 0, 43255912, 14, 53660808, 18, 15757352, 20, 53660808, 18, 
  49346896, 7, 49346896, 7, 49346896, 7, 34340434, 11, 50891665, 13, 
  42345851, 21, 34340434, 11, 21700542, 13, 11746701, 13, 11746701, 13, 
  10434542, 14, 1, 0, 10434542, 14, 28566055, 16, 10434542, 14, 1, 0, 
  10434542, 14, 28566055, 16, 49346896, 7, 44486016, 15, 44486016, 15, 
  20581084, 16, 65147699, 22, 20581084, 16, 65147699, 22, 49346896, 7, 
  33810934, 18, 33646191, 34, 46086225, 20, 27354165, 36, 33810934, 18, 
  33646191, 34, 46086225, 20, 27354165, 36, 36707004, 9, 36707004, 9, 
  22998847, 11, 22998847, 11, 35273178, 13, 35273178, 13, 4989212, 15, 
  4989212, 15, 6862160, 11, 6862160, 11, 21700542, 13, 21700542, 13, 
  66215688, 15, 66215688, 15, 52507531, 17, 52507531, 17, 64781862, 19, 
  64781862, 19, 9253351, 17, 9253351, 17, 62654073, 19, 62654073, 19, 
  7819525, 21, 7819525, 21 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/mapphomo.gi", 52552515 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/mapphomo.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/mapphomo.gi");
elif COM_RESULT = 3  then
Revision.mapphomo_gi:="@(#)$Id: mapphomo.gi,v 4.30 2003/08/23 18:59:19 gap Exp $";
InstallMethod(RespectsMultiplication,"method for a general mapping",[IsGeneralMapping],COM_FUN(1));
InstallMethod(RespectsOne,"method for a general mapping",[IsGeneralMapping],COM_FUN(2));
InstallMethod(RespectsInverses,"method for a general mapping",[IsGeneralMapping],COM_FUN(3));
InstallMethod(KernelOfMultiplicativeGeneralMapping,"method for a finite general mapping",[IsGeneralMapping and RespectsMultiplication and RespectsOne],COM_FUN(4));
InstallMethod(KernelOfMultiplicativeGeneralMapping,"method for an injective gen. mapping that respects mult. and one",[IsGeneralMapping and RespectsMultiplication and RespectsOne and IsInjective],SUM_FLAGS,COM_FUN(5));
InstallMethod(CoKernelOfMultiplicativeGeneralMapping,"method for a finite general mapping",[IsGeneralMapping and RespectsMultiplication and RespectsOne],COM_FUN(6));
InstallMethod(CoKernelOfMultiplicativeGeneralMapping,"method for a single-valued gen. mapping that respects mult. and one",[IsGeneralMapping and RespectsMultiplication and RespectsOne and IsSingleValued],SUM_FLAGS,COM_FUN(7));
InstallMethod(IsSingleValued,"method for a gen. mapping that respects mult. and inverses",[IsGeneralMapping and RespectsMultiplication and RespectsInverses],COM_FUN(8));
InstallMethod(IsInjective,"method for a gen. mapping that respects mult. and one",[IsGeneralMapping and RespectsMultiplication and RespectsInverses],COM_FUN(9));
InstallMethod(ImagesElm,"method for s.p. general mapping respecting mult. & inv., and element",FamSourceEqFamElm,[IsSPGeneralMapping and RespectsMultiplication and RespectsInverses,IsObject],COM_FUN(10));
InstallMethod(ImagesSet,"method for s.p. general mapping respecting mult. & inv., and group",CollFamSourceEqFamElms,[IsSPGeneralMapping and RespectsMultiplication and RespectsInverses,IsGroup],COM_FUN(11));
InstallMethod(ImagesSet,"method for injective s.p. mapping respecting mult. & inv., and group",CollFamSourceEqFamElms,[IsSPGeneralMapping and IsMapping and IsInjective and RespectsMultiplication and RespectsInverses,IsGroup],COM_FUN(12));
InstallMethod(PreImagesElm,"method for s.p. general mapping respecting mult. & inv., and element",FamRangeEqFamElm,[IsSPGeneralMapping and RespectsMultiplication and RespectsInverses,IsObject],COM_FUN(13));
InstallMethod(PreImagesSet,"method for s.p. general mapping respecting mult. & inv., and group",CollFamRangeEqFamElms,[IsSPGeneralMapping and RespectsMultiplication and RespectsInverses,IsGroup],COM_FUN(14));
InstallMethod(PreImagesSet,"method for injective s.p. mapping respecting mult. & inv., and group",CollFamRangeEqFamElms,[IsSPGeneralMapping and IsMapping and IsInjective and RespectsMultiplication and RespectsInverses,IsGroup],COM_FUN(15));
InstallMethod(RespectsAddition,"method for a general mapping",[IsGeneralMapping],COM_FUN(16));
InstallMethod(RespectsZero,"method for a general mapping",[IsGeneralMapping],COM_FUN(17));
InstallMethod(RespectsAdditiveInverses,"method for a general mapping",[IsGeneralMapping],COM_FUN(18));
InstallMethod(KernelOfAdditiveGeneralMapping,"method for a finite general mapping",[IsGeneralMapping and RespectsAddition and RespectsZero],COM_FUN(19));
InstallMethod(KernelOfAdditiveGeneralMapping,"method for an injective gen. mapping that respects add. and zero",[IsGeneralMapping and RespectsAddition and RespectsZero and IsInjective],SUM_FLAGS,COM_FUN(20));
InstallMethod(KernelOfAdditiveGeneralMapping,"method for zero mapping",[IsGeneralMapping and RespectsAddition and RespectsZero and IsZero],SUM_FLAGS,Source);
InstallMethod(CoKernelOfAdditiveGeneralMapping,"method for a finite general mapping",[IsGeneralMapping and RespectsAddition and RespectsZero],COM_FUN(21));
InstallMethod(CoKernelOfAdditiveGeneralMapping,"method for a single-valued gen. mapping that respects add. and zero",[IsGeneralMapping and RespectsAddition and RespectsZero and IsSingleValued],SUM_FLAGS,COM_FUN(22));
InstallMethod(IsSingleValued,"method for a gen. mapping that respects add. and add. inverses",[IsGeneralMapping and RespectsAddition and RespectsAdditiveInverses],COM_FUN(23));
InstallMethod(IsInjective,"method for a gen. mapping that respects add. and add. inverses",[IsGeneralMapping and RespectsAddition and RespectsAdditiveInverses],COM_FUN(24));
InstallMethod(ImagesElm,"method for s.p. gen. mapping respecting add. & add.inv., and element",FamSourceEqFamElm,[IsSPGeneralMapping and RespectsAddition and RespectsAdditiveInverses,IsObject],COM_FUN(25));
InstallMethod(ImagesSet,"method for s.p. gen. mapping resp. add. & add.inv., and add. group",CollFamSourceEqFamElms,[IsSPGeneralMapping and RespectsAddition and RespectsAdditiveInverses,IsAdditiveGroup],COM_FUN(26));
InstallMethod(PreImagesElm,"method for s.p. gen. mapping respecting add. & add.inv., and element",FamRangeEqFamElm,[IsSPGeneralMapping and RespectsAddition and RespectsAdditiveInverses,IsObject],COM_FUN(27));
InstallMethod(PreImagesSet,"method for s.p. gen. mapping resp. add. & add.inv., and add. group",CollFamRangeEqFamElms,[IsSPGeneralMapping and RespectsAddition and RespectsAdditiveInverses,IsAdditiveGroup],COM_FUN(28));
InstallMethod(RespectsScalarMultiplication,"method for a general mapping",[IsGeneralMapping],COM_FUN(29));
InstallMethod(KernelOfAdditiveGeneralMapping,"method for a finite linear mapping",[IsGeneralMapping and RespectsAddition and RespectsZero and RespectsScalarMultiplication],COM_FUN(30));
InstallMethod(CoKernelOfAdditiveGeneralMapping,"method for a finite linear mapping",[IsGeneralMapping and RespectsAddition and RespectsZero and RespectsScalarMultiplication],COM_FUN(31));
InstallMethod(ImagesSet,"method for linear mapping and left module",CollFamSourceEqFamElms,[IsSPGeneralMapping and RespectsAddition and RespectsAdditiveInverses and RespectsScalarMultiplication,IsLeftModule],COM_FUN(32));
InstallMethod(PreImagesSet,"method for linear mapping and left module",CollFamRangeEqFamElms,[IsSPGeneralMapping and RespectsAddition and RespectsAdditiveInverses and RespectsScalarMultiplication,IsLeftModule],COM_FUN(33));
InstallMethod(IsFieldHomomorphism,"method for a general mapping",[IsGeneralMapping],COM_FUN(34));
InstallMethod(ImagesSet,"method for algebra hom. and FLMLOR",CollFamSourceEqFamElms,[IsSPGeneralMapping and RespectsAddition and RespectsAdditiveInverses and RespectsScalarMultiplication and RespectsMultipli\
cation,IsFLMLOR],COM_FUN(35));
InstallMethod(ImagesSet,"method for algebra-with-one hom. and FLMLOR-with-one",CollFamSourceEqFamElms,[IsSPGeneralMapping and RespectsAddition and RespectsAdditiveInverses and RespectsScalarMultiplication and RespectsMultiplication and RespectsOne,IsFLMLORWithOne],COM_FUN(36));
InstallMethod(PreImagesSet,"method for algebra hom. and FLMLOR",CollFamRangeEqFamElms,[IsSPGeneralMapping and RespectsAddition and RespectsAdditiveInverses and RespectsScalarMultiplication and RespectsMultipli\
cation,IsFLMLOR],COM_FUN(37));
InstallMethod(PreImagesSet,"method for algebra-with-one hom. and FLMLOR-with-one",CollFamRangeEqFamElms,[IsSPGeneralMapping and RespectsAddition and RespectsAdditiveInverses and RespectsScalarMultiplication and RespectsMultiplication and RespectsOne,IsFLMLORWithOne],COM_FUN(38));
InstallEqMethodForMappingsFromGenerators(IsObject,AsList,IsObject,"");
InstallEqMethodForMappingsFromGenerators(IsMagma,GeneratorsOfMagma,RespectsMultiplication," that respect mult.");
InstallEqMethodForMappingsFromGenerators(IsMagmaWithOne,GeneratorsOfMagmaWithOne,RespectsMultiplication and RespectsOne," that respect mult. and one");
InstallEqMethodForMappingsFromGenerators(IsMagmaWithInverses,GeneratorsOfMagmaWithInverses,RespectsMultiplication and RespectsInverses," that respect mult. and inv.");
InstallEqMethodForMappingsFromGenerators(IsAdditiveMagma,GeneratorsOfAdditiveMagma,RespectsAddition," that respect add.");
InstallEqMethodForMappingsFromGenerators(IsAdditiveMagmaWithZero,GeneratorsOfAdditiveMagmaWithZero,RespectsAddition and RespectsZero," that respect add. and zero");
InstallEqMethodForMappingsFromGenerators(IsAdditiveGroup,GeneratorsOfAdditiveGroup,RespectsAddition and RespectsAdditiveInverses," that respect add. and add. inv.");
InstallEqMethodForMappingsFromGenerators(IsRing,GeneratorsOfRing,RespectsMultiplication and RespectsAddition and RespectsAdditiveInverses," that respect mult.,add.,add.inv.");
InstallEqMethodForMappingsFromGenerators(IsRingWithOne,GeneratorsOfRingWithOne,RespectsMultiplication and RespectsOne and RespectsAddition and RespectsAdditiveInverses," that respect mult.,one,add.,add.inv.");
InstallEqMethodForMappingsFromGenerators(IsLeftModule,GeneratorsOfLeftModule,RespectsAddition and RespectsAdditiveInverses and RespectsScalarMultiplication," that respect add.,add.inv.,scal. mult.");
InstallEqMethodForMappingsFromGenerators(IsLeftOperatorRing,GeneratorsOfLeftOperatorRing,RespectsAddition and RespectsAdditiveInverses and RespectsMultiplication and RespectsScalarMultiplication," that respect add.,add.inv.,mult.,scal. mult.");
InstallEqMethodForMappingsFromGenerators(IsLeftOperatorRingWithOne,GeneratorsOfLeftOperatorRingWithOne,RespectsAddition and RespectsAdditiveInverses and RespectsMultiplication and RespectsOne and RespectsScalarMultiplication," that respect add.,add.inv.,mult.,one,scal. mult.");
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/mapphomo.gi"

#F  file="lib/relation.gi" crc=-13112907
RANK_FILTER_LIST  := [ 49541247, 9, 49541247, 9, 49541247, 9, 49541247, 9, 
  49541247, 9, 49541247, 9, 49541247, 9, 49541247, 9, 49541247, 9, 49541247, 
  9, 49541247, 9, 10452003, 11, 49541247, 9, 11792316, 12, 11792316, 12, 
  11792316, 12, 11792316, 12, 11792316, 12, 11792316, 12, 11792316, 12, 
  11792316, 12, 11792316, 12, 11792316, 12, 11792316, 12, 52247917, 19, 
  11792316, 12, 52247917, 19, 49541247, 9, 11792316, 12, 11792316, 12, 8193, 
  2, 11792316, 12, 11792316, 12, 11792316, 12, 11792316, 12, 11792316, 12, 
  24247466, 6, 11792316, 12, 11792316, 12, 24247466, 6, 11792316, 12, 513, 8, 
  513, 8, 11792316, 12, 11792316, 12, 4063233, 1, 4063233, 1, 11792316, 12, 
  11792316, 12, 11792316, 12, 11792316, 12, 11792316, 12, 52247917, 19, 
  11792316, 12, 4063233, 1, 11792316, 12, 11792316, 12, 7665924, 21, 
  11792316, 12, 11792316, 12, 11792316, 12, 45668567, 21, 45668567, 21, 
  45668567, 21, 45668567, 21, 45668567, 21, 45668567, 21, 45668567, 21, 
  45668567, 21, 8193, 2, 18307812, 22, 45668567, 21, 1, 0, 45668567, 21, 1, 
  0, 18307812, 22, 1, 0, 18307812, 22, 1, 0, 45668567, 21, 45668567, 21, 
  45668567, 21, 8126465, 2, 45668567, 21, 1, 0, 45668567, 21, 1, 0, 24771859, 
  6, 1, 0, 24771859, 6, 24771859, 6, 24771859, 6, 24771859, 6, 24771859, 6, 
  24771859, 6 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/relation.gi", -13112907 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/relation.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/relation.gi");
elif COM_RESULT = 3  then
Revision.relation_gi:="@(#)$Id: relation.gi,v 4.53 2002/05/29 12:32:09 gap Exp $";
DeclareRepresentation("IsBinaryRelationDefaultRep",IsAttributeStoringRep,[]);
DeclareRepresentation("IsBinaryRelationOnPointsRep",IsAttributeStoringRep,[]);
DeclareRepresentation("IsEquivalenceRelationDefaultRep",IsAttributeStoringRep,[]);
DeclareRepresentation("IsEquivalenceClassDefaultRep",IsAttributeStoringRep and IsComponentObjectRep,rec());
InstallGlobalFunction(IdentityBinaryRelation,COM_FUN(1));
InstallGlobalFunction(EmptyBinaryRelation,COM_FUN(2));
InstallGlobalFunction(BinaryRelationByElements,COM_FUN(3));
InstallMethod(IsReflexiveBinaryRelation,"reflexive test binary relation",true,[IsBinaryRelation],0,COM_FUN(4));
InstallMethod(IsSymmetricBinaryRelation,"symmetric test binary relation",true,[IsBinaryRelation],0,COM_FUN(5));
InstallMethod(IsTransitiveBinaryRelation,"transitive test binary relation",true,[IsBinaryRelation],0,COM_FUN(6));
InstallMethod(IsAntisymmetricBinaryRelation,"test for Antisymmetry of a binary relation",true,[IsBinaryRelation],0,COM_FUN(7));
InstallMethod(IsPreOrderBinaryRelation,"test for whether a binary relation is a preorder",true,[IsBinaryRelation],0,COM_FUN(8));
InstallMethod(IsPartialOrderBinaryRelation,"test for whether a binary relation is a partial order",true,[IsBinaryRelation],0,COM_FUN(9));
InstallMethod(IsLatticeOrderBinaryRelation,"test for whether a binary relation is a lattice order",true,[IsBinaryRelation],0,COM_FUN(10));
InstallMethod(IsEquivalenceRelation,"test for equivalence relation",true,[IsBinaryRelation],0,COM_FUN(11));
InstallMethod(ReflexiveClosureBinaryRelation,"for binary relation",true,[IsBinaryRelation],0,COM_FUN(12));
InstallMethod(SymmetricClosureBinaryRelation,"for binary relation",true,[IsBinaryRelation],0,COM_FUN(13));
InstallMethod(TransitiveClosureBinaryRelation,"for binary relation",true,[IsBinaryRelation],0,COM_FUN(14));
InstallMethod(HasseDiagramBinaryRelation,"for binary relation",true,[IsBinaryRelation and IsPartialOrderBinaryRelation],0,COM_FUN(15));
InstallGlobalFunction(PartialOrderByOrderingFunction,COM_FUN(16));
InstallMethod(StronglyConnectedComponents,"for general binary relations",true,[IsBinaryRelation],0,COM_FUN(17));
DeclareSynonym("ImagesListOfBinaryRelation",Successors);
DeclareSynonym("BinaryRelationByListOfImages",BinaryRelationOnPoints);
DeclareSynonym("BinaryRelationByListOfImagesNC",BinaryRelationOnPointsNC);
InstallGlobalFunction(BinaryRelationOnPointsNC,COM_FUN(18));
InstallGlobalFunction(BinaryRelationOnPoints,COM_FUN(19));
InstallGlobalFunction(AsBinaryRelationOnPoints,COM_FUN(20));
InstallGlobalFunction(RandomBinaryRelationOnPoints,COM_FUN(21));
InstallMethod(IsReflexiveBinaryRelation,"for binary relations on points",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(22));
InstallMethod(IsSymmetricBinaryRelation,"for binary relations on points",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(23));
InstallMethod(IsTransitiveBinaryRelation,"for binary relations on points",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(24));
InstallMethod(IsAntisymmetricBinaryRelation,"for binary relations on points",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(25));
InstallMethod(IsPreOrderBinaryRelation,"for binary relations on points",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(26));
InstallMethod(IsPartialOrderBinaryRelation,"for binary relations on points",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(27));
InstallMethod(IsEquivalenceRelation,"for binary relations on points",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(28));
InstallMethod(ReflexiveClosureBinaryRelation,"for binary relations on points",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(29));
InstallMethod(SymmetricClosureBinaryRelation,"for binary relations on points",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(30));
InstallMethod(TransitiveClosureBinaryRelation,"for binary relations on points",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(31));
InstallMethod(ImagesElm,"for binary relations over [1..n] with images list",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep,IsPosInt],0,COM_FUN(32));
InstallMethod(PreImagesElm,"for binary rels over [1..n] with images list",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep,IsPosInt],0,COM_FUN(33));
InstallMethod(Successors,"for a generic relation",true,[IsBinaryRelation],0,COM_FUN(34));
InstallMethod(\=,"for binary relss over [1..n] with images list",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep,IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(35));
InstallMethod(\in,"for binary rels over [1..n] with images list",true,[IsList,IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(36));
InstallMethod(\<,"for binary rels over [1..n] with images list",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep,IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(37));
InstallMethod(\*,"for binary relations on points",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep,IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(38));
InstallOtherMethod(\*,"for transformation and binary relation on points",true,[IsTransformation,IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(39));
InstallOtherMethod(\*,"for binary relation on points and transformation",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep,IsTransformation],0,COM_FUN(40));
InstallOtherMethod(\*,"for binary relation on points and permutation",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep,IsPerm],0,COM_FUN(41));
InstallOtherMethod(\*,"for permutation and binary relation on points",true,[IsPerm,IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(42));
InstallOtherMethod(\*,"for binary relation on points and list",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep,IsListOrCollection],0,COM_FUN(43));
InstallOtherMethod(\*,"for list and binary relation on points",true,[IsListOrCollection,IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(44));
InstallMethod(\+,"for binary relations on points",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep,IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(45));
InstallMethod(\-,"for binary relations on points",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep,IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(46));
InstallMethod(\^,"for binary relation on points and a positive int",true,[IsPosInt,IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(47));
InstallMethod(POW,"for binary relation on points and a set of integers",true,[IsListOrCollection,IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(48));
InstallMethod(POW,"for binary relation on points and Zero",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep,IsZeroCyc],0,COM_FUN(49));
InstallMethod(InverseOp,"for binary relation on points and a set of integers",\
true,[IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(50));
InstallMethod(One,"for binary relation on points and a set of integers",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(51));
InstallMethod(PrintObj,"for a binary relation on  n points",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(52));
InstallGlobalFunction(EquivalenceRelationByPartition,COM_FUN(53));
InstallGlobalFunction(EquivalenceRelationByPartitionNC,COM_FUN(54));
InstallGlobalFunction(EquivalenceRelationByRelation,COM_FUN(55));
InstallGlobalFunction(EquivalenceRelationByProperty,COM_FUN(56));
InstallGlobalFunction(EquivalenceRelationByPairsNC,COM_FUN(57));
InstallGlobalFunction(EquivalenceRelationByPairs,COM_FUN(58));
InstallMethod(EquivalenceRelationPartition,"compute the partition for an arbitrary equiv rel",true,[IsEquivalenceRelation],0,COM_FUN(59));
InstallMethod(JoinEquivalenceRelations,"join of two equivalence relations",true,[IsEquivalenceRelation,IsEquivalenceRelation],0,COM_FUN(60));
InstallMethod(MeetEquivalenceRelations,"meet of two equivalence relations",true,[IsEquivalenceRelation,IsEquivalenceRelation],0,COM_FUN(61));
InstallMethod(GeneratorsOfEquivalenceRelationPartition,"generators for an equivalence with a partition",true,[IsEquivalenceRelation],0,COM_FUN(62));
InstallMethod(\=,"for eqivalence relations",IsIdenticalObj,[IsEquivalenceRelation,IsEquivalenceRelation],0,COM_FUN(63));
InstallMethod(\in,"for eq relation with partition",true,[IsList,IsEquivalenceRelation and HasEquivalenceRelationPartition],1,COM_FUN(64));
InstallMethod(ImagesRepresentative,"equivalence relations",FamSourceEqFamElm,[IsEquivalenceRelation,IsObject],0,COM_FUN(65));
InstallMethod(PreImagesRepresentative,"equivalence relations",FamRangeEqFamElm,[IsEquivalenceRelation,IsObject],0,COM_FUN(66));
InstallMethod(ImagesElm,"for equivalence relation with partition and element",FamSourceEqFamElm,[IsEquivalenceRelation and HasEquivalenceRelationPartition,IsObject],0,COM_FUN(67));
InstallMethod(PreImagesElm,"equivalence relations with parition and element",FamRangeEqFamElm,[IsEquivalenceRelation and HasEquivalenceRelationPartition,IsObject],0,COM_FUN(68));
InstallMethod(PrintObj,"for an equivalence relation",true,[IsEquivalenceRelation],0,COM_FUN(69));
InstallMethod(EquivalenceClasses,"wraparound to call 2-argument version",true,[IsEquivalenceRelation],0,COM_FUN(70));
InstallOtherMethod(EquivalenceClasses,"for a generic equivalence relation",true,[IsEquivalenceRelation,IsCollection],0,COM_FUN(71));
InstallMethod(EquivalenceClassOfElementNC,"no check",true,[IsEquivalenceRelation,IsObject],0,COM_FUN(72));
InstallMethod(EquivalenceClassOfElement,"with checking",true,[IsEquivalenceRelation,IsObject],0,COM_FUN(73));
InstallMethod(PrintObj,"for an eq. class",true,[IsEquivalenceClass],0,COM_FUN(74));
InstallMethod(\in,"for element and equivalence class",true,[IsObject,IsEquivalenceClass],0,COM_FUN(75));
InstallMethod(Enumerator,"for equivalence classes",true,[IsEquivalenceClass],0,COM_FUN(76));
InstallMethod(\=,"for two equivalence classes",IsIdenticalObj,[IsEquivalenceClass,IsEquivalenceClass],0,COM_FUN(77));
InstallMethod(\<,"for two equivalence classes",IsIdenticalObj,[IsEquivalenceClass,IsEquivalenceClass],0,COM_FUN(78));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/relation.gi"

#F  file="lib/magma.gi" crc=-114721587
RANK_FILTER_LIST  := [ 63962867, 11, 30407970, 12, 9344737, 14, 6107341, 17, 
  63962867, 11, 30407970, 12, 9344737, 14, 6107341, 17, 9344737, 14, 6107341, 
  17, 63962867, 11, 42127042, 14, 21063809, 16, 17825453, 19, 63962867, 11, 
  8572100, 13, 5427047, 15, 53660808, 18, 63962867, 11, 32505602, 3, 
  17706552, 13, 32505602, 3, 63962867, 11, 63962867, 11, 17706552, 13, 
  63962867, 11, 63962867, 11, 1, 0, 1, 0, 63962867, 11, 17706552, 13, 
  63962867, 11, 8126465, 2, 1985, 1, 8193, 2, 8126465, 2, 1985, 1, 8193, 2, 
  8115305, 4, 1985, 1, 67105912, 7, 60816854, 13, 63962867, 11, 9344737, 14, 
  6107341, 17, 9344722, 18, 6107326, 18, 27262917, 14, 6107341, 17, 6107326, 
  18, 8387799, 17, 57579458, 17, 30407970, 12, 9344737, 14, 6107341, 17, 
  7903780, 16, 8796229, 14, 63962867, 11, 43881020, 14, 63962867, 11, 1025, 
  1, 63962867, 11, 60816854, 14, 8796229, 15, 60816854, 14, 27261717, 47, 
  63963859, 13, 63962867, 11, 63962867, 11, 60816854, 14, 60816854, 14, 
  41942696, 17, 41942696, 17, 63962867, 11, 63962867, 11, 60816854, 14, 
  60816854, 14, 41942696, 17, 41942696, 17, 63962867, 11, 8126465, 2, 
  9017489, 5, 8126465, 2 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/magma.gi", -114721587 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/magma.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/magma.gi");
elif COM_RESULT = 3  then
Revision.magma_gi:="@(#)$Id: magma.gi,v 4.59 2002/09/02 16:10:11 gap Exp $";
InstallMethod(PrintObj,"for a magma",true,[IsMagma],0,COM_FUN(1));
InstallMethod(PrintObj,"for a magma with generators",true,[IsMagma and HasGeneratorsOfMagma],0,COM_FUN(2));
InstallMethod(PrintObj,"for a magma-with-one with generators",true,[IsMagmaWithOne and HasGeneratorsOfMagmaWithOne],0,COM_FUN(3));
InstallMethod(PrintObj,"for a magma-with-inverses with generators",true,[IsMagmaWithInverses and HasGeneratorsOfMagmaWithInverses],0,COM_FUN(4));
InstallMethod(ViewObj,"for a magma",true,[IsMagma],0,COM_FUN(5));
InstallMethod(ViewObj,"for a magma with generators",true,[IsMagma and HasGeneratorsOfMagma],0,COM_FUN(6));
InstallMethod(ViewObj,"for a magma-with-one with generators",true,[IsMagmaWithOne and HasGeneratorsOfMagmaWithOne],0,COM_FUN(7));
InstallMethod(ViewObj,"for a magma-with-inverses with generators",true,[IsMagmaWithInverses and HasGeneratorsOfMagmaWithInverses],0,COM_FUN(8));
InstallImmediateMethod(IsTrivial,IsMagmaWithOne and HasGeneratorsOfMagmaWithOne,0,COM_FUN(9));
InstallImmediateMethod(IsTrivial,IsMagmaWithInverses and HasGeneratorsOfMagmaWithInverses,0,COM_FUN(10));
InstallMethod(IsAssociative,"for a magma",true,[IsMagma],0,COM_FUN(11));
InstallImmediateMethod(IsCommutative,IsMagma and IsAssociative and HasGeneratorsOfMagma,0,COM_FUN(12));
InstallImmediateMethod(IsCommutative,IsMagmaWithOne and IsAssociative and HasGeneratorsOfMagmaWithOne,0,COM_FUN(13));
InstallImmediateMethod(IsCommutative,IsMagmaWithInverses and IsAssociative and HasGeneratorsOfMagmaWithInverses,0,COM_FUN(14));
InstallMethod(IsCommutative,"for a magma",true,[IsMagma],0,IsCommutativeFromGenerators(GeneratorsOfDomain));
InstallMethod(IsCommutative,"for an associative magma",true,[IsMagma and IsAssociative],0,IsCommutativeFromGenerators(GeneratorsOfMagma));
InstallMethod(IsCommutative,"for an associative magma with one",true,[IsMagmaWithOne and IsAssociative],0,IsCommutativeFromGenerators(GeneratorsOfMagmaWithOne));
InstallMethod(IsCommutative,"for an associative magma with inverses",true,[IsMagmaWithInverses and IsAssociative],0,IsCommutativeFromGenerators(GeneratorsOfMagmaWithInverses));
InstallMethod(CentralizerOp,"for a magma, and a mult. element",IsCollsElms,[IsMagma,IsMultiplicativeElement],0,COM_FUN(15));
InstallMethod(CentralizerOp,"for a commutative magma, and a mult. element",IsCollsElms,[IsMagma and IsCommutative,IsMultiplicativeElement],SUM_FLAGS,COM_FUN(16));
InstallMethod(CentralizerOp,"for two magmas",IsIdenticalObj,[IsMagma,IsMagma],0,COM_FUN(17));
InstallMethod(CentralizerOp,"for two magmas, the first being commutative",IsIdenticalObj,[IsMagma and IsCommutative,IsMagma],SUM_FLAGS,COM_FUN(18));
InstallOtherMethod(CentralizerOp,"dummy to ignore optional third argument",true,[IsMagma,IsObject,IsObject],0,COM_FUN(19));
InstallMethod(Centre,"for a magma",[IsMagma],COM_FUN(20));
InstallMethod(Centre,"for a commutative magma",true,[IsMagma and IsCommutative],SUM_FLAGS,IdFunc);
InstallMethod(Idempotents,"for finite magmas",true,[IsMagma],0,COM_FUN(21));
InstallGlobalFunction(Magma,COM_FUN(22));
InstallGlobalFunction(Submagma,COM_FUN(23));
InstallGlobalFunction(SubmagmaNC,COM_FUN(24));
InstallGlobalFunction(MagmaWithOne,COM_FUN(25));
InstallGlobalFunction(SubmagmaWithOne,COM_FUN(26));
InstallGlobalFunction(SubmagmaWithOneNC,COM_FUN(27));
InstallGlobalFunction(MagmaWithInverses,COM_FUN(28));
InstallGlobalFunction(SubmagmaWithInverses,COM_FUN(29));
InstallGlobalFunction(SubmagmaWithInversesNC,COM_FUN(30));
InstallMethod(MagmaByGenerators,"for collection",true,[IsCollection],0,COM_FUN(31));
InstallOtherMethod(MagmaByGenerators,"for family and list",true,[IsFamily,IsList],0,COM_FUN(32));
InstallMethod(MagmaWithOneByGenerators,"for collection",true,[IsCollection],0,COM_FUN(33));
InstallOtherMethod(MagmaWithOneByGenerators,"for family and list",true,[IsFamily,IsList],0,COM_FUN(34));
MakeMagmaWithInversesByFiniteGenerators:=COM_FUN(35);
InstallMethod(MagmaWithInversesByGenerators,"for collection",true,[IsCollection and IsFinite],0,COM_FUN(36));
InstallOtherMethod(MagmaWithInversesByGenerators,"for family and list",true,[IsFamily,IsList and IsFinite],0,COM_FUN(37));
InstallMethod(TrivialSubmagmaWithOne,"for magma-with-one",true,[IsMagmaWithOne],0,COM_FUN(38));
InstallMethod(GeneratorsOfMagma,"generic method for a magma (take domain generators)",true,[IsMagma],0,GeneratorsOfDomain);
InstallMethod(GeneratorsOfMagma,"for a magma-with-one with known generators",true,[IsMagmaWithOne and HasGeneratorsOfMagmaWithOne],0,COM_FUN(39));
InstallMethod(GeneratorsOfMagma,"for a magma-with-inverses with known generators",true,[IsMagmaWithInverses and HasGeneratorsOfMagmaWithInverses],0,COM_FUN(40));
InstallMethod(GeneratorsOfMagma,"for a magma-with-one with generators, all elms. of finite order",true,[IsMagmaWithOne and HasGeneratorsOfMagmaWithOne and IsFiniteOrderElementCollection],0,COM_FUN(41));
InstallMethod(GeneratorsOfMagma,"for a magma-with-inv. with gens., all elms. of finite order",true,[IsMagmaWithInverses and HasGeneratorsOfMagmaWithInverses and IsFiniteOrderElementCollection],0,COM_FUN(42));
InstallMethod(GeneratorsOfMagmaWithOne,"for a magma-with-one with known magma generators (take them)",true,[IsMagmaWithOne and HasGeneratorsOfMagma],0,GeneratorsOfMagma);
InstallMethod(GeneratorsOfMagmaWithOne,"for a magma-with-inverses with generators",true,[IsMagmaWithInverses and HasGeneratorsOfMagmaWithInverses],0,COM_FUN(43));
InstallMethod(GeneratorsOfMagmaWithOne,"for a magma-with-inv. with gens., all elms. of finite order",true,[IsMagmaWithInverses and HasGeneratorsOfMagmaWithInverses and IsFiniteOrderElementCollection],0,GeneratorsOfMagmaWithInverses);
InstallMethod(GeneratorsOfMagmaWithInverses,"for a magma-with-inverses with known magma generators (take them)",true,[IsMagmaWithInverses and HasGeneratorsOfMagma],0,GeneratorsOfMagma);
InstallMethod(GeneratorsOfMagmaWithInverses,"for a magma-with-inverses with known magma-with-one gen.s (take them)",true,[IsMagmaWithInverses and HasGeneratorsOfMagmaWithOne],0,GeneratorsOfMagmaWithOne);
InstallMethod(Representative,"for magma with generators",true,[IsMagma and HasGeneratorsOfMagma],0,RepresentativeFromGenerators(GeneratorsOfMagma));
InstallMethod(Representative,"for magma-with-one with generators",true,[IsMagmaWithOne and HasGeneratorsOfMagmaWithOne],0,RepresentativeFromGenerators(GeneratorsOfMagmaWithOne));
InstallMethod(Representative,"for magma-with-inverses with generators",true,[IsMagmaWithInverses and HasGeneratorsOfMagmaWithInverses],0,RepresentativeFromGenerators(GeneratorsOfMagmaWithInverses));
InstallMethod(Representative,"for magma-with-one with known one",true,[IsMagmaWithOne and HasOne],SUM_FLAGS,One);
InstallMethod(Representative,"for magma-with-one with stored parent",[IsMagmaWithOne and HasParentAttr],COM_FUN(44));
InstallMethod(MultiplicativeNeutralElement,"for a magma",true,[IsMagma],0,COM_FUN(45));
InstallTrueMethod(HasMultiplicativeNeutralElement,IsMagmaWithOne);
InstallMethod(MultiplicativeNeutralElement,"for a magma-with-one",true,[HasMultiplicativeNeutralElement and IsMagmaWithOne],GETTER_FLAGS+1,One);
InstallMethod(SetMultiplicativeNeutralElement,"for a magma-with-one",true,[IsMagma,IsBool],0,COM_FUN(46));
InstallOtherMethod(One,"for a magma",true,[IsMagma],0,COM_FUN(47));
InstallOtherMethod(One,"partial method for a magma-with-one (ask family)",true,[IsMagmaWithOne],100,COM_FUN(48));
InstallOtherMethod(One,"for a magma-with-one that has a parent",true,[IsMagmaWithOne and HasParent],SUM_FLAGS,COM_FUN(49));
InstallOtherMethod(One,"for a magma-with-one",true,[IsMagmaWithOne],0,COM_FUN(50));
BindGlobal("EnumeratorOfTrivialMagmaWithOne",COM_FUN(51));
InstallMethod(Enumerator,"for trivial magma-with-one",true,[IsMagmaWithOne and IsTrivial],0,EnumeratorOfTrivialMagmaWithOne);
BindGlobal("ClosureMagmaDefault",COM_FUN(52));
BindGlobal("EnumeratorOfMagma",COM_FUN(53));
InstallMethod(Enumerator,"generic method for a magma",true,[IsMagma and IsAttributeStoringRep],0,EnumeratorOfMagma);
InstallMethod(IsCentral,"for two magmas",IsIdenticalObj,[IsMagma,IsMagma],0,IsCentralFromGenerators(GeneratorsOfMagma,GeneratorsOfMagma));
InstallMethod(IsCentral,"for two magmas-with-one",IsIdenticalObj,[IsMagmaWithOne,IsMagmaWithOne],0,IsCentralFromGenerators(GeneratorsOfMagmaWithOne,GeneratorsOfMagmaWithOne));
InstallMethod(IsCentral,"for two magmas-with-inverses",IsIdenticalObj,[IsMagmaWithInverses,IsMagmaWithInverses],0,IsCentralFromGenerators(GeneratorsOfMagmaWithInverses,GeneratorsOfMagmaWithInverses));
InstallMethod(IsSubset,"for two magmas",IsIdenticalObj,[IsMagma,IsMagma],0,COM_FUN(54));
InstallMethod(IsSubset,"for two magmas with one",IsIdenticalObj,[IsMagmaWithOne,IsMagmaWithOne],0,COM_FUN(55));
InstallMethod(IsSubset,"for two magmas with inverses",IsIdenticalObj,[IsMagmaWithInverses,IsMagmaWithInverses],0,COM_FUN(56));
InstallMethod(AsMagma,"for a magma (return the argument)",true,[IsMagma],100,IdFunc);
InstallMethod(AsMagma,"generic method for collections",true,[IsCollection],0,COM_FUN(57));
InstallMethod(AsSubmagma,"generic method for a domain and a collection",IsIdenticalObj,[IsDomain,IsCollection],0,COM_FUN(58));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/magma.gi"

#F  file="lib/mgmideal.gi" crc=88540656
RANK_FILTER_LIST  := [ 8126135, 13, 30670429, 14, 13302118, 13, 12205490, 14, 
  27270024, 15, 22196288, 16, 8126135, 13, 30670429, 14, 13302118, 13, 
  12205490, 14, 27270024, 15, 22196288, 16, 63962867, 11, 8126465, 2, 
  63962867, 11, 8126465, 2, 63962867, 11, 8126465, 2, 9017489, 5, 8126465, 2, 
  27271016, 17, 12205490, 14, 30670429, 14 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/mgmideal.gi", 88540656 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/mgmideal.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/mgmideal.gi");
elif COM_RESULT = 3  then
Revision.mgmideal_gi:="@(#)$Id: mgmideal.gi,v 4.8 2002/04/15 10:05:03 sal Exp $";
InstallMethod(PrintObj,"for a left magma ideal",true,[IsLeftMagmaIdeal],0,COM_FUN(1));
InstallMethod(PrintObj,"for a left magma ideal with known generators",true,[IsLeftMagmaIdeal and HasGeneratorsOfLeftMagmaIdeal],0,COM_FUN(2));
InstallMethod(PrintObj,"for a right magma ideal",true,[IsRightMagmaIdeal],0,COM_FUN(3));
InstallMethod(PrintObj,"for a right magma ideal with known generators",true,[IsRightMagmaIdeal and HasGeneratorsOfRightMagmaIdeal],0,COM_FUN(4));
InstallMethod(PrintObj,"for a magma ideal",true,[IsMagmaIdeal],0,COM_FUN(5));
InstallMethod(PrintObj,"for a magma ideal with known generators",true,[IsMagmaIdeal and HasGeneratorsOfMagmaIdeal],0,COM_FUN(6));
InstallMethod(ViewObj,"for a LeftMagmaIdeal",true,[IsLeftMagmaIdeal],0,COM_FUN(7));
InstallMethod(ViewObj,"for a LeftMagmaIdeal with generators",true,[IsLeftMagmaIdeal and HasGeneratorsOfLeftMagmaIdeal],0,COM_FUN(8));
InstallMethod(ViewObj,"for a RightMagmaIdeal",true,[IsRightMagmaIdeal],0,COM_FUN(9));
InstallMethod(ViewObj,"for a RightMagmaIdeal with generators",true,[IsRightMagmaIdeal and HasGeneratorsOfRightMagmaIdeal],0,COM_FUN(10));
InstallMethod(ViewObj,"for a MagmaIdeal",true,[IsMagmaIdeal],0,COM_FUN(11));
InstallMethod(ViewObj,"for a MagmaIdeal with generators",true,[IsMagmaIdeal and HasGeneratorsOfMagmaIdeal],0,COM_FUN(12));
InstallMethod(LeftMagmaIdealByGenerators,"for a collection of magma elements",IsIdenticalObj,[IsMagma,IsCollection],0,COM_FUN(13));
InstallMethod(RightMagmaIdealByGenerators,"for a collection of magma elements",IsIdenticalObj,[IsMagma,IsCollection],0,COM_FUN(14));
InstallMethod(MagmaIdealByGenerators,"for a collection of magma elements",IsIdenticalObj,[IsMagma,IsCollection],0,COM_FUN(15));
InstallMethod(AsLeftMagmaIdeal,"generic method for a domain and a collection",IsIdenticalObj,[IsDomain,IsCollection],0,COM_FUN(16));
BindGlobal("EnumeratorOfMagmaIdeal",COM_FUN(17));
InstallMethod(Enumerator,"generic method for a magma ideal",true,[IsMagma and IsAttributeStoringRep and IsMagmaIdeal],0,EnumeratorOfMagmaIdeal);
InstallMethod(AsSSortedList,"for a right magma ideal",true,[IsRightMagmaIdeal and HasGeneratorsOfRightMagmaIdeal],0,COM_FUN(18));
InstallMethod(AsSSortedList,"for a left magma ideal",true,[IsLeftMagmaIdeal and HasGeneratorsOfLeftMagmaIdeal],0,COM_FUN(19));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/mgmideal.gi"

#F  file="lib/mgmhom.gi" crc=31481831
RANK_FILTER_LIST  := [  ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/mgmhom.gi", 31481831 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/mgmhom.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/mgmhom.gi");
elif COM_RESULT = 3  then
Revision.mgmhom_gi:="@(#)$Id: mgmhom.gi,v 4.3 2002/04/15 10:05:03 sal Exp $";
InstallGlobalFunction(MagmaHomomorphismByFunctionNC,COM_FUN(1));
InstallGlobalFunction(MagmaIsomorphismByFunctionsNC,COM_FUN(2));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/mgmhom.gi"

#F  file="lib/mgmadj.gi" crc=-15449892
RANK_FILTER_LIST  := [ 23379699, 14, 32505602, 3, 63962867, 11, 32505602, 3, 
  42127042, 14, 32505602, 3, 16776332, 7, 33553908, 6, 63962867, 11, 
  63962867, 11, 23379699, 14, 33553908, 6, 33553908, 6, 33553908, 6, 
  33553908, 6, 33553908, 6, 33553908, 6, 33553908, 6 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/mgmadj.gi", -15449892 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/mgmadj.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/mgmadj.gi");
elif COM_RESULT = 3  then
Revision.mgmadj_gi:="@(#)$Id: mgmadj.gi,v 4.8 2002/04/15 10:05:03 sal Exp $";
InstallMethod(IsMultiplicativeZero,"generic method for an element and a magma with multiplicative zero",IsCollsElms,[IsMagma and HasMultiplicativeZero,IsMultiplicativeElement],0,COM_FUN(1));
InstallMethod(IsMultiplicativeZero,"generic method for an element and a magma",IsCollsElms,[IsMagma,IsMultiplicativeElement],0,COM_FUN(2));
InstallMethod(IsMultiplicativeZero,"generic method for an element of a semigroup, given generators",IsCollsElms,[IsSemigroup and HasGeneratorsOfSemigroup,IsMultiplicativeElement],0,COM_FUN(3));
DeclareRepresentation("IsMagmaWithMultiplicativeZeroAdjoinedElementRep",IsComponentObjectRep and IsMultiplicativeElementWithZero,["IsTheZero","UnderlyingElement"]);
InstallMethod(OneOp,"for an element of a magma with zero adjoined",true,[IsMultiplicativeElementWithOne and IsMagmaWithMultiplicativeZeroAdjoinedElementRep],0,COM_FUN(4));
InstallMethod(MultiplicativeZeroOp,"for an element of a magma with zero adjoined",true,[IsMagmaWithMultiplicativeZeroAdjoinedElementRep],0,COM_FUN(5));
InstallOtherMethod(MultiplicativeZero,"for a magma",true,[IsMagma],0,COM_FUN(6));
InstallMethod(InjectionZeroMagma,"method for a magma",true,[IsMagma],0,COM_FUN(7));
InstallMethod(Size,"method for a magma with a zero adjoined",true,[IsMagma and HasMultiplicativeZero],0,COM_FUN(8));
InstallMethod(\*,"for two elements of a magma with zero adjoined",IsIdenticalObj,[IsMagmaWithMultiplicativeZeroAdjoinedElementRep,IsMagmaWithMultiplicativeZeroAdjoinedElementRep],0,COM_FUN(9));
InstallMethod(\=,"for two elements of a magma with zero adjoined",IsIdenticalObj,[IsMagmaWithMultiplicativeZeroAdjoinedElementRep,IsMagmaWithMultiplicativeZeroAdjoinedElementRep],0,COM_FUN(10));
InstallMethod(\<,"for elements of magmas with 0 adjoined",IsIdenticalObj,[IsMagmaWithMultiplicativeZeroAdjoinedElementRep,IsMagmaWithMultiplicativeZeroAdjoinedElementRep],0,COM_FUN(11));
InstallMethod(PrintObj,"for elements of magmas with 0 adjoined",true,[IsMagmaWithMultiplicativeZeroAdjoinedElementRep],0,COM_FUN(12));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/mgmadj.gi"

#F  file="lib/mgmcong.gi" crc=-97637533
RANK_FILTER_LIST  := [ 38993006, 22, 51576323, 27, 43515245, 22, 56098562, 
  27, 39845139, 26, 52428456, 27, 38993006, 22, 51576323, 27, 43515245, 22, 
  56098562, 27, 39845139, 26, 52428456, 27, 63962867, 11, 8193, 2, 63962867, 
  11, 41951068, 17, 63962867, 11, 8193, 2, 63962867, 11, 41951068, 17, 
  63962867, 11, 8193, 2, 63962867, 11, 41951068, 17, 39845139, 26, 25165675, 
  10, 25165675, 10, 8388099, 11, 38993006, 22, 43515245, 22, 39845139, 26, 
  39845139, 26, 39845139, 26, 39845139, 26, 39845139, 26, 1, 0, 25165675, 10, 
  25165675, 10, 39845139, 26, 1, 0, 38993006, 22, 1, 0, 43515245, 22, 1, 0, 
  39845139, 26, 1, 0, 38993006, 22, 1, 0, 43515245, 22, 1, 0, 39845139, 26, 
  1, 0, 38993006, 22, 1, 0, 43515245, 22, 1, 0 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/mgmcong.gi", -97637533 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/mgmcong.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/mgmcong.gi");
elif COM_RESULT = 3  then
Revision.mgmcong_gi:="@(#)$Id: mgmcong.gi,v 4.19 2002/04/15 10:05:03 sal Exp $";
InstallMethod(PrintObj,"for a left magma congruence",true,[IsLeftMagmaCongruence],0,COM_FUN(1));
InstallMethod(PrintObj,"for a left magma congruence with known generating pairs",true,[IsLeftMagmaCongruence and HasGeneratingPairsOfMagmaCongruence],0,COM_FUN(2));
InstallMethod(PrintObj,"for a right magma congruence",true,[IsRightMagmaCongruence],0,COM_FUN(3));
InstallMethod(PrintObj,"for a right magma congruence with known generating pairs",true,[IsRightMagmaCongruence and HasGeneratingPairsOfMagmaCongruence],0,COM_FUN(4));
InstallMethod(PrintObj,"for a magma congruence",true,[IsMagmaCongruence],0,COM_FUN(5));
InstallMethod(PrintObj,"for a magma Congruence with known generating pairs",true,[IsMagmaCongruence and HasGeneratingPairsOfMagmaCongruence],0,COM_FUN(6));
InstallMethod(ViewObj,"for a LeftMagmaCongruence",true,[IsLeftMagmaCongruence],0,COM_FUN(7));
InstallMethod(ViewObj,"for a LeftMagmaCongruence with known generating pairs",true,[IsLeftMagmaCongruence and HasGeneratingPairsOfMagmaCongruence],0,COM_FUN(8));
InstallMethod(ViewObj,"for a RightMagmaCongruence",true,[IsRightMagmaCongruence],0,COM_FUN(9));
InstallMethod(ViewObj,"for a RightMagmaCongruence with generators",true,[IsRightMagmaCongruence and HasGeneratingPairsOfMagmaCongruence],0,COM_FUN(10));
InstallMethod(ViewObj,"for a magma congruence",true,[IsMagmaCongruence],0,COM_FUN(11));
InstallMethod(ViewObj,"for a magma congruence with generating pairs",true,[IsMagmaCongruence and HasGeneratingPairsOfMagmaCongruence],0,COM_FUN(12));
InstallGlobalFunction(LR2MagmaCongruenceByGeneratingPairsCAT,COM_FUN(13));
InstallGlobalFunction(LR2MagmaCongruenceByPartitionNCCAT,COM_FUN(14));
InstallMethod(LeftMagmaCongruenceByGeneratingPairs,"for a magma and a list of pairs of its elements",IsElmsColls,[IsMagma,IsList],0,COM_FUN(15));
InstallMethod(LeftMagmaCongruenceByGeneratingPairs,"for a magma and an empty list",true,[IsMagma,IsList and IsEmpty],0,COM_FUN(16));
InstallMethod(RightMagmaCongruenceByGeneratingPairs,"for a magma and a list of pairs of its elements",IsElmsColls,[IsMagma,IsList],0,COM_FUN(17));
InstallMethod(RightMagmaCongruenceByGeneratingPairs,"for a magma and an empty list",true,[IsMagma,IsList and IsEmpty],0,COM_FUN(18));
InstallMethod(MagmaCongruenceByGeneratingPairs,"for a magma and a list of pairs of its elements",IsElmsColls,[IsMagma,IsList],0,COM_FUN(19));
InstallMethod(MagmaCongruenceByGeneratingPairs,"for a magma and an empty list",true,[IsMagma,IsList and IsEmpty],0,COM_FUN(20));
InstallMethod(EquivalenceClasses,"for magma congruences",true,[IsMagmaCongruence],0,COM_FUN(21));
InstallMethod(\*,"for two magma congruence classes",IsIdenticalObj,[IsCongruenceClass,IsCongruenceClass],0,COM_FUN(22));
InstallOtherMethod(One,"One(<congruence class>)",true,[IsCongruenceClass and IsMultiplicativeElementWithOne],0,COM_FUN(23));
BindGlobal("MagmaCongruencePartition",COM_FUN(24));
InstallMethod(EquivalenceRelationPartition,"for a left congruence on a magma",true,[IsLeftMagmaCongruence],0,COM_FUN(25));
InstallMethod(EquivalenceRelationPartition,"for a right congruence on a magma",true,[IsRightMagmaCongruence],0,COM_FUN(26));
InstallMethod(EquivalenceRelationPartition,"for a congruence on a magma",true,[IsMagmaCongruence],0,COM_FUN(27));
InstallMethod(JoinMagmaCongruences,"for magma congruences",true,[IsMagmaCongruence,IsMagmaCongruence],0,COM_FUN(28));
InstallMethod(MeetMagmaCongruences,"for magma congruences",true,[IsMagmaCongruence,IsMagmaCongruence],0,COM_FUN(29));
InstallMethod(\in,"for a magma congruence class",true,[IsObject,IsCongruenceClass],0,COM_FUN(30));
InstallMethod(Enumerator,"for a magma congruence class",true,[IsCongruenceClass],0,COM_FUN(31));
InstallMethod(EquivalenceClassOfElementNC,"for magma congruence with no check",true,[IsMagmaCongruence,IsObject],0,COM_FUN(32));
InstallMethod(EquivalenceClassOfElementNC,"for magma congruence with no check",true,[IsLeftMagmaCongruence,IsObject],0,COM_FUN(33));
InstallMethod(EquivalenceClassOfElementNC,"for magma congruence with no check",true,[IsRightMagmaCongruence,IsObject],0,COM_FUN(34));
InstallMethod(EquivalenceClassOfElement,"for magma congruence with checking",t\
rue,[IsMagmaCongruence,IsObject],0,COM_FUN(35));
InstallMethod(EquivalenceClassOfElement,"for left magma congruence with checki\
ng",true,[IsLeftMagmaCongruence,IsObject],0,COM_FUN(36));
InstallMethod(EquivalenceClassOfElement,"for right magma congruence with check\
ing",true,[IsRightMagmaCongruence,IsObject],0,COM_FUN(37));
InstallMethod(ImagesElm,"for magma congruence and element",FamSourceEqFamElm,[IsMagmaCongruence,IsObject],0,COM_FUN(38));
InstallMethod(ImagesElm,"for magma congruence and element",FamSourceEqFamElm,[IsLeftMagmaCongruence,IsObject],0,COM_FUN(39));
InstallMethod(ImagesElm,"for magma congruence and element",FamSourceEqFamElm,[IsRightMagmaCongruence,IsObject],0,COM_FUN(40));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/mgmcong.gi"

#F  file="lib/semigrp.gi" crc=2109193
RANK_FILTER_LIST  := [ 8560940, 15, 8560940, 15, 8572100, 13, 42127042, 14, 
  8572100, 13, 42127042, 14, 8572100, 13, 8126465, 2, 8572100, 13, 8126465, 
  2, 9017489, 5, 8126465, 2, 42127042, 14, 42127042, 14, 58745145, 14, 
  8572100, 13, 53660808, 21, 42125842, 22, 42127042, 14, 58745145, 14, 
  8572100, 13, 8560940, 15, 8572100, 13, 8572100, 13, 8572100, 13, 8193, 2, 
  8572100, 13, 41951068, 17, 8572100, 13, 14977290, 32, 8572100, 13, 8193, 2, 
  8572100, 13, 41951068, 17, 8572100, 13, 41942876, 3, 8572100, 13, 8193, 2, 
  8572100, 13, 14977290, 32, 8572100, 13, 62947299, 4, 8572100, 13 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/semigrp.gi", 2109193 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/semigrp.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/semigrp.gi");
elif COM_RESULT = 3  then
Revision.semigrp_gi:="@(#)$Id: semigrp.gi,v 4.45 2003/06/04 20:06:35 gap Exp $";
InstallMethod(CayleyGraphSemigroup,"for generic finite semigroups",[IsSemigroup and IsFinite],COM_FUN(1));
InstallMethod(CayleyGraphDualSemigroup,"for generic finite semigroups",[IsSemigroup and IsFinite],COM_FUN(2));
InstallMethod(PrintObj,"for a semigroup",[IsSemigroup],COM_FUN(3));
InstallMethod(PrintObj,"for a semigroup with known generators",[IsSemigroup and HasGeneratorsOfMagma],COM_FUN(4));
InstallMethod(ViewObj,"for a semigroup",[IsSemigroup],COM_FUN(5));
InstallMethod(ViewObj,"for a semigroup with generators",[IsSemigroup and HasGeneratorsOfMagma],COM_FUN(6));
InstallMethod(DisplaySemigroup,"for finite semigroups",[IsSemigroup],COM_FUN(7));
InstallMethod(SemigroupByGenerators,"for a collection",[IsCollection],COM_FUN(8));
InstallMethod(AsSemigroup,"for a semigroup",[IsSemigroup],100,IdFunc);
InstallMethod(AsSemigroup,"generic method for collections",[IsCollection],COM_FUN(9));
InstallGlobalFunction(Semigroup,COM_FUN(10));
InstallMethod(AsSubsemigroup,"generic method for a domain and a collection",IsIdenticalObj,[IsDomain,IsCollection],COM_FUN(11));
InstallMethod(Enumerator,"for a generic semigroup",[IsSemigroup and HasGeneratorsOfSemigroup],COM_FUN(12));
InstallTrueMethod(IsSimpleSemigroup,IsGroup);
InstallTrueMethod(IsSimpleSemigroup,IsSemigroup and IsTrivial);
InstallMethod(IsSimpleSemigroup,"for semigroup with generators",[IsSemigroup and HasGeneratorsOfSemigroup],COM_FUN(13));
InstallMethod(IsSimpleSemigroup,"for a semigroup with a MultiplicativeNeutralElement",[IsSemigroup and HasMultiplicativeNeutralElement],COM_FUN(14));
InstallMethod(IsSimpleSemigroup,"for a semigroup",[IsSemigroup],COM_FUN(15));
InstallTrueMethod(IsZeroSimpleSemigroup,IsZeroGroup);
InstallMethod(IsZeroSimpleSemigroup,"for a ZeroGroup",[IsGroup],ReturnFalse);
InstallMethod(IsZeroSimpleSemigroup,"for a trivial semigroup",[IsSemigroup and IsTrivial],ReturnFalse);
InstallMethod(IsZeroSimpleSemigroup,"for a semigroup with generators",[IsSemigroup and HasGeneratorsOfSemigroup],COM_FUN(16));
InstallMethod(IsZeroSimpleSemigroup,"for a semigroup with a MultiplicativeNeutralElement",[IsSemigroup and HasMultiplicativeNeutralElement],COM_FUN(17));
InstallMethod(IsZeroSimpleSemigroup,"for a semigroup",[IsSemigroup],COM_FUN(18));
InstallMethod(ANonReesCongruenceOfSemigroup,"for a semigroup",[IsSemigroup and IsFinite],COM_FUN(19));
RedispatchOnCondition(ANonReesCongruenceOfSemigroup,true,[IsSemigroup],[IsFinite],0);
InstallMethod(IsReesCongruenceSemigroup,"for a (possibly infinite) semigroup",[IsSemigroup],COM_FUN(20));
InstallMethod(HomomorphismFactorSemigroupByClosure,"for a semigroup and generating pairs of a congruence",IsElmsColls,[IsSemigroup,IsList],COM_FUN(21));
InstallMethod(HomomorphismFactorSemigroupByClosure,"for a semigroup and empty list",[IsSemigroup,IsList and IsEmpty],COM_FUN(22));
InstallMethod(FactorSemigroup,"for a semigroup and a congruence",[IsSemigroup,IsSemigroupCongruence],COM_FUN(23));
InstallMethod(FactorSemigroupByClosure,"for a semigroup and generating pairs of a congruence",IsElmsColls,[IsSemigroup,IsList],COM_FUN(24));
InstallMethod(FactorSemigroupByClosure,"for a semigroup and empty list",[IsSemigroup,IsEmpty and IsList],COM_FUN(25));
InstallOtherMethod(\/,"for a semigroup and an empty list",[IsSemigroup,IsEmpty],FactorSemigroupByClosure);
InstallOtherMethod(\/,"for semigroup and list of pairs",IsElmsColls,[IsSemigroup,IsList],FactorSemigroupByClosure);
InstallOtherMethod(\/,"for a semigroup and a congruence",[IsSemigroup,IsSemigroupCongruence],FactorSemigroup);
InstallMethod(IsRegularSemigroupElement,"for generic semigroup",IsCollsElms,[IsSemigroup,IsAssociativeElement],COM_FUN(26));
InstallMethod(IsRegularSemigroup,"for generic semigroup",[IsSemigroup],COM_FUN(27));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/semigrp.gi"

#F  file="lib/semicong.gi" crc=129261989
RANK_FILTER_LIST  := [ 8572100, 13, 8193, 2, 8572100, 13, 41951068, 17, 
  8572100, 13, 8193, 2, 8572100, 13, 41951068, 17, 8572100, 13, 8193, 2, 
  8572100, 13, 41951068, 17, 38993006, 22, 43515245, 22, 39845139, 26, 
  14977290, 32, 16776287, 24, 29359604, 29, 67108025, 24, 12582463, 29, 
  14977290, 32, 27559647, 33, 16776287, 24, 29359604, 29, 67108025, 24, 
  12582463, 29, 14977290, 32, 27559647, 33 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/semicong.gi", 129261989 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/semicong.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/semicong.gi");
elif COM_RESULT = 3  then
Revision.semicong_gi:="@(#)$Id: semicong.gi,v 4.16 2002/04/15 10:05:21 sal Exp $";
InstallMethod(LeftSemigroupCongruenceByGeneratingPairs,"for a Semigroup  and a list of pairs of its elements",IsElmsColls,[IsSemigroup,IsList],0,COM_FUN(1));
InstallMethod(LeftSemigroupCongruenceByGeneratingPairs,"for a Semigroup and an empty list",true,[IsSemigroup,IsList and IsEmpty],0,COM_FUN(2));
InstallMethod(RightSemigroupCongruenceByGeneratingPairs,"for a Semigroup and a list of pairs of its elements",IsElmsColls,[IsSemigroup,IsList],0,COM_FUN(3));
InstallMethod(RightSemigroupCongruenceByGeneratingPairs,"for a Semigroup and an empty list",true,[IsSemigroup,IsList and IsEmpty],0,COM_FUN(4));
InstallMethod(SemigroupCongruenceByGeneratingPairs,"for a semigroup and a list of pairs of its elements",IsElmsColls,[IsSemigroup,IsList],0,COM_FUN(5));
InstallMethod(SemigroupCongruenceByGeneratingPairs,"for a semigroup and an empty list",true,[IsSemigroup,IsList and IsEmpty],0,COM_FUN(6));
InstallMethod(IsLeftSemigroupCongruence,"test whether a left magma congruence is a semigroup a congruence",true,[IsLeftMagmaCongruence],0,COM_FUN(7));
InstallMethod(IsRightSemigroupCongruence,"test whether a right magma congruence is a semigroup a congruence",true,[IsRightMagmaCongruence],0,COM_FUN(8));
InstallMethod(IsSemigroupCongruence,"test whether a magma congruence is a semigroup a congruence",true,[IsMagmaCongruence],0,COM_FUN(9));
InstallMethod(IsReesCongruence,"for a semigroup congruence",true,[IsSemigroupCongruence],0,COM_FUN(10));
InstallMethod(PrintObj,"for a left semigroup congruence",true,[IsLeftSemigroupCongruence],0,COM_FUN(11));
InstallMethod(PrintObj,"for a left semigroup congruence with known generating pairs",true,[IsLeftSemigroupCongruence and HasGeneratingPairsOfMagmaCongruence],0,COM_FUN(12));
InstallMethod(PrintObj,"for a right semigroup congruence",true,[IsRightSemigroupCongruence],0,COM_FUN(13));
InstallMethod(PrintObj,"for a right semigroup congruence with known generating pairs",true,[IsRightSemigroupCongruence and HasGeneratingPairsOfMagmaCongruence],0,COM_FUN(14));
InstallMethod(PrintObj,"for a semigroup congruence",true,[IsSemigroupCongruence],0,COM_FUN(15));
InstallMethod(PrintObj,"for a semigroup Congruence with known generating pairs",true,[IsSemigroupCongruence and HasGeneratingPairsOfMagmaCongruence],0,COM_FUN(16));
InstallMethod(ViewObj,"for a LeftSemigroupCongruence",true,[IsLeftSemigroupCongruence],0,COM_FUN(17));
InstallMethod(ViewObj,"for a LeftSemigroupCongruence with known generating pairs",true,[IsLeftSemigroupCongruence and HasGeneratingPairsOfMagmaCongruence],0,COM_FUN(18));
InstallMethod(ViewObj,"for a RightSemigrouCongruence",true,[IsRightSemigroupCongruence],0,COM_FUN(19));
InstallMethod(ViewObj,"for a RightSemigroupCongruence with generators",true,[IsRightSemigroupCongruence and HasGeneratingPairsOfMagmaCongruence],0,COM_FUN(20));
InstallMethod(ViewObj,"for a semigroup congruence",true,[IsSemigroupCongruence],0,COM_FUN(21));
InstallMethod(ViewObj,"for a semigroup Congruence with known generating pairs",true,[IsSemigroupCongruence and HasGeneratingPairsOfMagmaCongruence],0,COM_FUN(22));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/semicong.gi"

#F  file="lib/smgideal.gi" crc=6652758
RANK_FILTER_LIST  := [ 53215715, 16, 11109854, 16, 5553514, 19, 60457611, 16, 
  4378415, 16, 39817540, 18, 5052420, 17, 5052420, 17, 67087563, 18, 5052420, 
  17, 67087563, 18 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/smgideal.gi", 6652758 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/smgideal.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/smgideal.gi");
elif COM_RESULT = 3  then
Revision.smgideal_gi:="@(#)$Id: smgideal.gi,v 4.14 2003/04/14 16:21:57 gap Exp $";
InstallImmediateMethod(IsLeftSemigroupIdeal,IsLeftMagmaIdeal and HasLeftActingDomain and IsAttributeStoringRep,0,COM_FUN(1));
InstallImmediateMethod(IsRightSemigroupIdeal,IsRightMagmaIdeal and HasRightActingDomain and IsAttributeStoringRep,0,COM_FUN(2));
InstallImmediateMethod(IsSemigroupIdeal,IsMagmaIdeal and HasActingDomain and IsAttributeStoringRep,0,COM_FUN(3));
BindGlobal("RightSemigroupIdealEnumeratorDataGetElement",COM_FUN(4));
BindGlobal("LeftSemigroupIdealEnumeratorDataGetElement",COM_FUN(5));
BindGlobal("SemigroupIdealEnumeratorDataGetElement",COM_FUN(6));
BindGlobal("ElementNumber_SemigroupIdealEnumerator",COM_FUN(7));
BindGlobal("NumberElement_SemigroupIdealEnumerator",COM_FUN(8));
InstallGlobalFunction(IsBound_RightSemigroupIdealEnumerator,COM_FUN(9));
InstallGlobalFunction(IsBound_LeftSemigroupIdealEnumerator,COM_FUN(10));
BindGlobal("IsBound_SemigroupIdealEnumerator",COM_FUN(11));
BindGlobal("Length_SemigroupIdealEnumerator",COM_FUN(12));
BindGlobal("Membership_SemigroupIdealEnumerator",COM_FUN(13));
InstallGlobalFunction(EnumeratorOfSemigroupIdeal,COM_FUN(14));
InstallMethod(Enumerator,"for a right semigroup ideal",[IsRightSemigroupIdeal and HasGeneratorsOfRightMagmaIdeal],COM_FUN(15));
InstallMethod(Enumerator,"for a left semigroup ideal",[IsLeftSemigroupIdeal and HasGeneratorsOfLeftMagmaIdeal],COM_FUN(16));
InstallMethod(Enumerator,"for a semigroup ideal",[IsSemigroupIdeal and HasGeneratorsOfMagmaIdeal],COM_FUN(17));
InstallMethod(ReesCongruenceOfSemigroupIdeal,"for a two sided semigroup congruence",[IsMagmaIdeal and IsSemigroupIdeal],COM_FUN(18));
InstallMethod(PrintObj,"for a semigroup ideal",[IsMagmaIdeal and IsSemigroupIdeal],COM_FUN(19));
InstallMethod(PrintObj,"for a semigroup ideal with known generators",[IsMagmaIdeal and IsSemigroupIdeal and HasGeneratorsOfMagmaIdeal],COM_FUN(20));
InstallMethod(ViewObj,"for a semigroup ideal",[IsMagmaIdeal and IsSemigroupIdeal],COM_FUN(21));
InstallMethod(ViewObj,"for a semigroup ideal with known generators",[IsMagmaIdeal and IsSemigroupIdeal and HasGeneratorsOfMagmaIdeal],COM_FUN(22));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/smgideal.gi"

#F  file="lib/monoid.gi" crc=-46178486
RANK_FILTER_LIST  := [ 5427047, 16, 21063809, 17, 5427047, 16, 21063809, 17, 
  8126465, 2, 8126465, 2, 50331304, 4, 41942876, 3, 50331304, 4, 21064801, 
  19, 5427047, 16, 8126465, 2, 9017489, 5, 8126465, 2, 5427047, 16 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/monoid.gi", -46178486 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/monoid.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/monoid.gi");
elif COM_RESULT = 3  then
Revision.monoid_gi:="@(#)$Id: monoid.gi,v 4.29 2002/04/15 10:05:04 sal Exp $";
InstallMethod(PrintObj,"for monoid",true,[IsMonoid],0,COM_FUN(1));
InstallMethod(PrintObj,"for monoid with known generators",true,[IsMonoid and HasGeneratorsOfMonoid],0,COM_FUN(2));
InstallMethod(ViewObj,"for a monoid",true,[IsMonoid],0,COM_FUN(3));
InstallMethod(ViewObj,"for a monoid with generators",true,[IsMonoid and HasGeneratorsOfMagmaWithOne],0,COM_FUN(4));
InstallOtherMethod(MonoidByGenerators,"for a collection",true,[IsCollection],0,COM_FUN(5));
InstallOtherMethod(MonoidByGenerators,"for collection and identity",IsCollsElms,[IsCollection,IsMultiplicativeElementWithOne],0,COM_FUN(6));
InstallOtherMethod(MonoidByGenerators,"for empty collection and identity",true,[IsEmpty,IsMultiplicativeElementWithOne],0,COM_FUN(7));
InstallImmediateMethod(GeneratorsOfSemigroup,IsMonoid and HasGeneratorsOfMonoid and IsAttributeStoringRep,0,COM_FUN(8));
InstallMethod(AsMonoid,"for a monoid",true,[IsMonoid],100,IdFunc);
InstallMethod(AsMonoid,"generic method for a collection",true,[IsCollection],0,COM_FUN(9));
InstallMethod(AsSubmonoid,"generic method for a domain and a collection",IsIdenticalObj,[IsDomain,IsCollection],0,COM_FUN(10));
InstallMethod(IsCommutative,"for associative magma-with-one",true,[IsMagmaWithOne and IsAssociative],0,IsCommutativeFromGenerators(GeneratorsOfMagmaWithOne));
InstallGlobalFunction(Monoid,COM_FUN(11));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/monoid.gi"

#F  file="lib/grp.gi" crc=-69262211
RANK_FILTER_LIST  := [ 17825453, 22, 17825453, 22, 53660808, 21, 53660808, 
  21, 53660808, 21, 53660808, 21, 36461010, 27, 20434032, 29, 53660808, 21, 
  3068353, 25, 53650608, 26, 53660808, 21, 53660808, 21, 53660808, 21, 
  53662730, 23, 53660808, 21, 53660808, 21, 53660808, 21, 53660808, 21, 
  53660808, 21, 8126465, 2, 53660808, 21, 53660808, 21, 53660808, 21, 
  53650608, 26, 53660808, 21, 53650608, 26, 53660808, 21, 53660808, 21, 
  53660808, 21, 67105912, 7, 53650608, 26, 53660808, 21, 8193, 2, 53660808, 
  21, 38678017, 30, 20105671, 49, 53660808, 21, 53660808, 21, 53660808, 21, 
  53660808, 21, 53660808, 21, 53661170, 24, 53660808, 21, 7404493, 29, 
  53660808, 21, 52247917, 19, 52247917, 19, 53660808, 21, 53660808, 21, 
  3066431, 23, 53660808, 21, 53660808, 21, 53650608, 26, 53650608, 26, 
  53650608, 26, 53650608, 26, 53660808, 21, 53660808, 21, 52247917, 19, 
  52247917, 19, 53660808, 21, 53660808, 21, 53660808, 21, 53660808, 21, 
  65767820, 5, 37278516, 22, 65767820, 5, 53647849, 23, 65767820, 5, 
  53660808, 21, 53660808, 21, 53647849, 23, 53660808, 21, 53660808, 21, 
  8126465, 2, 53660808, 21, 41951068, 17, 53660808, 21, 53660808, 21, 
  53660808, 21, 65767820, 5, 53660808, 21, 65767820, 5, 1640183, 22, 
  65767820, 5, 53660808, 21, 65767820, 5, 53660808, 21, 53660808, 21, 
  53660808, 21, 53660808, 21, 53660808, 21, 53660808, 21, 53660808, 21, 
  53660808, 21, 53660808, 21, 53660808, 21, 53660808, 21, 65767820, 5, 
  65767820, 5, 53660808, 21, 53660808, 21, 53660808, 21, 53660808, 21, 
  53660808, 21, 53660808, 21, 53660808, 21, 53660808, 21, 52247917, 19, 8088, 
  9, 8088, 9, 8088, 9, 53660808, 21, 53660808, 21, 53660808, 21, 53660808, 
  21, 53660808, 21, 53660808, 21, 53660808, 21, 65767820, 5, 53660808, 21, 
  53660808, 21, 53660808, 21, 52247917, 19, 53660808, 21, 20434032, 29, 
  20434032, 29, 53660808, 21, 52247917, 19, 53660808, 21, 52247917, 19, 
  53660808, 21, 53660808, 21, 53660808, 21, 53660808, 21, 53660808, 21, 
  52247917, 19, 36461010, 27, 52247917, 19, 53660808, 21, 53660808, 21, 
  53660808, 21, 53660808, 21, 53660808, 21, 53660808, 21, 53660808, 21, 
  53660808, 21, 53661800, 23, 53660808, 21, 53660808, 21, 1, 0, 53660808, 21, 
  53660808, 21, 53660808, 21, 17825453, 22, 53660808, 21, 17825453, 22, 
  17827375, 24, 53660808, 21, 67108760, 5, 8126465, 2, 8126465, 2, 65767820, 
  5, 41951068, 17, 65767820, 5, 8126465, 2, 8126465, 2, 65767820, 5, 
  41951068, 17, 65767820, 5, 53660808, 21, 8193, 2, 4063233, 1, 20105926, 22, 
  20105926, 22, 1, 0, 20105926, 22, 20105926, 22, 32505602, 3, 32505602, 3, 
  52247917, 19, 53660808, 21, 52247917, 19, 53660808, 21, 53660808, 21, 
  36873077, 27, 53650608, 26, 15871142, 227, 17825453, 22, 53660808, 21, 
  53660808, 21, 53660808, 21, 17, 18, 32769, 4, 45271600, 30, 17, 18, 32769, 
  4, 36137368, 31, 17, 18, 32769, 4, 53660808, 21, 8193, 2, 53660808, 21, 
  41942876, 3, 53660808, 21, 17825453, 22, 53660808, 21, 53660808, 21, 
  53660808, 21, 53660808, 21, 18041977, 22, 18041977, 22, 59744076, 6, 
  17825453, 22, 53660808, 21 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grp.gi", -69262211 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grp.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grp.gi");
elif COM_RESULT = 3  then
Revision.grp_gi:="@(#)$Id: grp.gi,v 4.204.2.2 2004/03/04 21:51:40 gap Exp $";
InstallImmediateMethod(IsFinitelyGeneratedGroup,IsGroup and HasGeneratorsOfGroup,0,COM_FUN(1));
InstallImmediateMethod(IsCyclic,IsGroup and HasGeneratorsOfGroup,0,COM_FUN(2));
InstallMethod(IsCyclic,"generic method for groups",[IsGroup],COM_FUN(3));
InstallOtherMethod(GeneratorOfCyclicGroup,"generic method for groups",true,[IsGroup],0,COM_FUN(4));
InstallMethod(IsElementaryAbelian,"generic method for groups",[IsGroup],COM_FUN(5));
InstallMethod(IsPGroup,"generic method (check order of the group or of generators)",[IsGroup],COM_FUN(6));
InstallMethod(IsPGroup,"for nilpotent groups",[IsGroup and IsNilpotentGroup],COM_FUN(7));
InstallMethod(PrimePGroup,"generic method, check the group order",[IsPGroup],COM_FUN(8));
InstallMethod(IsNilpotentGroup,"generic method for groups",[IsGroup],COM_FUN(9));
InstallImmediateMethod(IsPerfectGroup,IsGroup and IsSolvableGroup and HasSize,0,COM_FUN(10));
InstallMethod(IsPerfectGroup,"method for finite groups",[IsGroup and IsFinite],COM_FUN(11));
InstallMethod(IsPerfectGroup,"generic method for groups",[IsGroup],COM_FUN(12));
InstallMethod(IsSporadicSimpleGroup,"for a group",[IsGroup],COM_FUN(13));
InstallMethod(IsSimpleGroup,"generic method for groups",[IsGroup],COM_FUN(14));
InstallImmediateMethod(IsSolvableGroup,IsGroup and HasSize,10,COM_FUN(15));
InstallMethod(IsSolvableGroup,"generic method for groups",[IsGroup],COM_FUN(16));
InstallMethod(IsSupersolvableGroup,"generic method for groups",[IsGroup],COM_FUN(17));
InstallMethod(IsTrivial,[IsGroup],COM_FUN(18));
InstallMethod(AbelianInvariants,"generic method for groups",[IsGroup],COM_FUN(19));
InstallMethod(AsGroup,[IsGroup],100,IdFunc);
InstallMethod(AsGroup,"generic method for collections",[IsCollection],COM_FUN(20));
InstallMethod(ChiefSeries,"method for a group (delegate to `ChiefSeriesUnderAction'",[IsGroup],COM_FUN(21));
InstallMethod(CommutatorFactorGroup,"generic method for groups",[IsGroup],COM_FUN(22));
InstallMethod(MaximalAbelianQuotient,"not fp group",true,[IsGroup],0,COM_FUN(23));
InstallMethod(CompositionSeries,"using DerivedSubgroup",[IsGroup and IsFinite],COM_FUN(24));
InstallMethod(DerivedLength,"generic method for groups",[IsGroup],COM_FUN(25));
InstallMethod(HirschLength,"generic method for finite groups",[IsGroup and IsFinite],COM_FUN(26));
InstallMethod(DerivedSeriesOfGroup,"generic method for groups",[IsGroup],COM_FUN(27));
InstallMethod(DerivedSubgroup,"generic method for groups",[IsGroup],COM_FUN(28));
InstallMethod(DimensionsLoewyFactors,"for a group (that must be a finite p-group)",[IsGroup],COM_FUN(29));
InstallOtherMethod(ElementaryAbelianSeries,"method for lists",[IsList and IsFinite],COM_FUN(30));
InstallMethod(ElementaryAbelianSeries,"generic method for groups",[IsGroup and IsFinite],COM_FUN(31));
DoEASLS:=COM_FUN(32);
InstallMethod(ElementaryAbelianSeriesLargeSteps,"remove spurious factors",[IsGroup],DoEASLS);
InstallOtherMethod(ElementaryAbelianSeriesLargeSteps,"remove spurious factors",[IsList],DoEASLS);
InstallMethod(Exponent,"generic method for groups",[IsGroup],COM_FUN(33));
InstallMethod(Exponent,"method for abelian groups with generators",[IsGroup and IsAbelian and HasGeneratorsOfGroup],COM_FUN(34));
InstallMethod(FittingSubgroup,[IsGroup and IsTrivial],0,IdFunc);
InstallMethod(FittingSubgroup,"generic method for groups",[IsGroup],COM_FUN(35));
InstallMethod(FrattiniSubgroup,"generic method for groups",[IsGroup],0,COM_FUN(36));
InstallMethod(JenningsSeries,"generic method for groups",[IsGroup],COM_FUN(37));
InstallMethod(LowerCentralSeriesOfGroup,"generic method for groups",[IsGroup],COM_FUN(38));
InstallMethod(NilpotencyClassOfGroup,"generic",[IsGroup],0,COM_FUN(39));
InstallImmediateMethod(NrConjugacyClasses,IsGroup and HasConjugacyClasses and IsAttributeStoringRep,0,COM_FUN(40));
InstallMethod(NrConjugacyClasses,"generic method for groups",[IsGroup],COM_FUN(41));
InstallGlobalFunction(Omega,COM_FUN(42));
InstallMethod(IndependentGeneratorsOfAbelianGroup,"finite abelian group",true,[IsGroup and IsAbelian],0,COM_FUN(43));
InstallMethod(OmegaOp,"method for a p-group (abelian)",[IsGroup,IsPosInt,IsPosInt],COM_FUN(44));
InstallMethod(ComputedOmegas,[IsGroup],0,COM_FUN(45));
InstallMethod(RadicalGroup,"for a group",[IsGroup],COM_FUN(46));
InstallMethod(RadicalGroup,"solvable group is its own radical",[IsGroup and IsSolvableGroup],100,IdFunc);
InstallMethod(GeneratorsSmallest,"generic method for groups",[IsGroup],COM_FUN(47));
InstallMethod(LargestElementGroup,"use `EnumeratorSorted'",true,[IsGroup],COM_FUN(48));
InstallGlobalFunction(SupersolvableResiduumDefault,COM_FUN(49));
InstallMethod(SupersolvableResiduum,"method for finite groups (call `SupersolvableResiduumDefault')",[IsGroup and IsFinite],COM_FUN(50));
InstallMethod(ComplementSystem,"generic method for finite groups",[IsGroup and IsFinite],COM_FUN(51));
InstallMethod(SylowSystem,"generic method for finite groups",[IsGroup and IsFinite],COM_FUN(52));
InstallMethod(HallSystem,"generic method for finite groups",[IsGroup and IsFinite],COM_FUN(53));
InstallMethod(UpperCentralSeriesOfGroup,"generic method for groups",[IsGroup],COM_FUN(54));
InstallGlobalFunction(Agemo,COM_FUN(55));
InstallMethod(AgemoOp,"generic method for groups",[IsGroup,IsPosInt,IsPosInt],COM_FUN(56));
InstallMethod(ComputedAgemos,[IsGroup],0,COM_FUN(57));
InstallGlobalFunction(AgemoAbove,COM_FUN(58));
InstallMethod(AsSubgroup,"generic method for groups",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(59));
InstallGlobalFunction(ClosureGroupDefault,COM_FUN(60));
InstallGlobalFunction(ClosureGroupAddElm,COM_FUN(61));
InstallGlobalFunction(ClosureGroupCompare,COM_FUN(62));
InstallGlobalFunction(ClosureGroupIntest,COM_FUN(63));
InstallMethod(ClosureGroup,"generic method for group and element",IsCollsElms,[IsGroup,IsMultiplicativeElementWithInverse],COM_FUN(64));
InstallMethod(ClosureGroup,"groups with cheap membership test",IsCollsElms,[IsGroup and CanEasilyTestMembership,IsMultiplicativeElementWithInverse],ClosureGroupIntest);
InstallMethod(ClosureGroup,"method for group that contains the whole family",IsCollsElms,[IsGroup and IsWholeFamily,IsMultiplicativeElementWithInverse],SUM_FLAGS,COM_FUN(65));
InstallMethod(ClosureGroup,"generic method for two groups",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(66));
InstallMethod(ClosureGroup,"for two groups, the bigger conatining the whole family",IsIdenticalObj,[IsGroup and IsWholeFamily,IsGroup],SUM_FLAGS,COM_FUN(67));
InstallMethod(ClosureGroup,"for group and element list",IsIdenticalObj,[IsGroup,IsCollection],COM_FUN(68));
InstallMethod(ClosureGroup,"for group and empty element list",[IsGroup,IsList and IsEmpty],COM_FUN(69));
InstallGlobalFunction(ClosureSubgroupNC,COM_FUN(70));
InstallGlobalFunction(ClosureSubgroup,COM_FUN(71));
InstallMethod(CommutatorSubgroup,"generic method for two groups",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(72));
InstallOtherMethod(\^,"generic method for groups and element",IsCollsElms,[IsGroup,IsMultiplicativeElementWithInverse],ConjugateGroup);
InstallMethod(ConjugateGroup,"<G>, <g>",IsCollsElms,[IsGroup,IsMultiplicativeElementWithInverse],COM_FUN(73));
InstallMethod(ConjugateSubgroup,"for group with parent, and group element",IsCollsElms,[IsGroup and HasParent,IsMultiplicativeElementWithInverse],COM_FUN(74));
InstallOtherMethod(ConjugateSubgroup,"for group without parent",IsCollsElms,[IsGroup,IsMultiplicativeElementWithInverse],ConjugateGroup);
InstallMethod(CoreOp,"generic method for two groups",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(75));
InstallGlobalFunction(FactorGroup,COM_FUN(76));
InstallMethod(FactorGroupNC,"generic method for two groups",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(77));
InstallOtherMethod(\/,"generic method for two groups",IsIdenticalObj,[IsGroup,IsGroup],FactorGroup);
InstallMethod(IndexOp,"generic method for two groups",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(78));
InstallMethod(IndexNC,"generic method for two groups",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(79));
InstallMethod(IsConjugate,"group elements",IsCollsElmsElms,[IsGroup,IsMultiplicativeElementWithInverse,IsMultiplicativeElementWithInverse],COM_FUN(80));
InstallMethod(IsConjugate,"subgroups",IsFamFamFam,[IsGroup,IsGroup,IsGroup],COM_FUN(81));
InstallMethod(IsNormalOp,"generic method for two groups",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(82));
InstallMethod(IsCharacteristicSubgroup,"generic method for two groups",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(83));
InstallMethod(IsPNilpotentOp,"generic method for a (finite) group and a prime integer",[IsGroup,IsPosInt],COM_FUN(84));
InstallGlobalFunction(IsSubgroup,COM_FUN(85));
DeclareRepresentation("IsRightTransversalRep",IsAttributeStoringRep and IsRightTransversal,["group","subgroup"]);
InstallMethod(PrintObj,"for right transversal",[IsList and IsRightTransversalRep],COM_FUN(86));
InstallMethod(ViewObj,"for right transversal",[IsList and IsRightTransversalRep],COM_FUN(87));
InstallMethod(Length,"for right transversal",[IsList and IsRightTransversalRep],COM_FUN(88));
InstallMethod(NormalClosureOp,"generic method for two groups",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(89));
InstallMethod(NormalIntersection,"generic method for two groups",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(90));
InstallMethod(NormalizerOp,"generic method for two groups",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(91));
InstallMethod(NormalizerOp,"generic method for group and Element",IsCollsElms,[IsGroup,IsMultiplicativeElementWithInverse],COM_FUN(92));
InstallMethod(NrConjugacyClassesInSupergroup,"generic method for two groups",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(93));
InstallMethod(PCentralSeriesOp,"generic method for group and prime",[IsGroup,IsPosInt],COM_FUN(94));
InstallOtherMethod(PCentralSeries,"pGroup",[IsGroup],COM_FUN(95));
InstallMethod(PClassPGroup,"generic method for group",[IsPGroup],COM_FUN(96));
InstallMethod(RankPGroup,"generic method for group",[IsPGroup],COM_FUN(97));
InstallMethod(PRumpOp,"generic method for group and prime",[IsGroup,IsPosInt],COM_FUN(98));
InstallMethod(PCoreOp,"generic method for group and prime",[IsGroup,IsPosInt],COM_FUN(99));
InstallMethod(SubnormalSeriesOp,"generic method for two groups",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(100));
InstallMethod(IsSubnormal,"generic method for two groups",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(101));
InstallMethod(SylowSubgroupOp,"generic method for group and prime",[IsGroup,IsPosInt],COM_FUN(102));
InstallMethod(SylowSubgroupOp,"method for a nilpotent group, and a prime",[IsGroup and IsNilpotentGroup,IsPosInt],COM_FUN(103));
InstallMethod(\=,"generic method for two groups",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(104));
InstallMethod(IsCentral,"generic method for two groups",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(105));
InstallMethod(IsSubset,"generic method for two groups",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(106));
InstallMethod(Intersection2,"generic method for two groups",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(107));
EnumeratorOfGroup:=COM_FUN(108);
InstallMethod(Enumerator,"generic method for a group",[IsGroup and IsAttributeStoringRep],EnumeratorOfGroup);
InstallMethod(AsSSortedListNonstored,"generic method for groups",true,[IsGroup],0,EnumeratorOfGroup);
InstallMethod(CentralizerOp,"generic method for group and object",IsCollsElms,[IsGroup,IsObject],COM_FUN(109));
InstallMethod(CentralizerOp,"generic method for two groups",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(110));
InstallGlobalFunction(IsomorphismTypeInfoFiniteSimpleGroup,COM_FUN(111));
InstallMethod(PrintObj,"for a group",[IsGroup],COM_FUN(112));
InstallMethod(PrintObj,"for a group with generators",[IsGroup and HasGeneratorsOfGroup],COM_FUN(113));
InstallMethod(ViewObj,"for a group",[IsGroup],COM_FUN(114));
InstallMethod(ViewObj,"for a group with generators",[IsGroup and HasGeneratorsOfMagmaWithInverses],COM_FUN(115));
InstallMethod(ViewObj,"for a group with generators and size",[IsGroup and HasGeneratorsOfMagmaWithInverses and HasSize],COM_FUN(116));
InstallMethod(GroupString,"for a group",[IsGroup,IsString],COM_FUN(117));
InstallMethod(GroupWithGenerators,"generic method for collection",[IsCollection],COM_FUN(118));
InstallMethod(GroupWithGenerators,"generic method for collection and identity element",IsCollsElms,[IsCollection,IsMultiplicativeElementWithInverse],COM_FUN(119));
InstallMethod(GroupWithGenerators,"method for empty list and element",[IsList and IsEmpty,IsMultiplicativeElementWithInverse],COM_FUN(120));
InstallMethod(GroupByGenerators,"delegate to `GroupWithGenerators'",[IsCollection],GroupWithGenerators);
InstallMethod(GroupByGenerators,"delegate to `GroupWithGenerators'",IsCollsElms,[IsCollection,IsMultiplicativeElementWithInverse],GroupWithGenerators);
InstallMethod(GroupByGenerators,"delegate to `GroupWithGenerators'",[IsList and IsEmpty,IsMultiplicativeElementWithInverse],GroupWithGenerators);
InstallMethod(IsCommutative,"generic method for groups",[IsGroup],IsCommutativeFromGenerators(GeneratorsOfGroup));
InstallMethod(IsGeneratorsOfMagmaWithInverses,"for an empty list",[IsList],COM_FUN(121));
InstallMethod(IsGeneratorsOfMagmaWithInverses,"for a list or collection",[IsListOrCollection],COM_FUN(122));
InstallGlobalFunction(Group,COM_FUN(123));
InstallGlobalFunction(SubgroupByProperty,COM_FUN(124));
InstallMethod(PrintObj,"subgroup by property",[IsGroup and HasElementTestFunction],0,COM_FUN(125));
InstallMethod(ViewObj,"subgroup by property",[IsGroup and HasElementTestFunction],0,COM_FUN(126));
InstallMethod(\in,"subgroup by property",[IsObject,IsGroup and HasElementTestFunction],0,COM_FUN(127));
InstallMethod(GeneratorsOfGroup,"Schreier generators",[IsGroup and HasElementTestFunction],0,COM_FUN(128));
InstallGlobalFunction(SubgroupShell,COM_FUN(129));
InstallMethod(PrimePowerComponents,"generic method",[IsMultiplicativeElement],COM_FUN(130));
InstallMethod(PrimePowerComponent,"generic method",[IsMultiplicativeElement,IsPosInt],COM_FUN(131));
InstallMethod(\.,"group generators",true,[IsGroup,IsPosInt],COM_FUN(132));
InstallGlobalFunction(NormalSubgroupsAbove,COM_FUN(133));
InstallMethod(NormalSubgroups,"generic class union",true,[IsGroup],COM_FUN(134));
InstallMethod(MaximalNormalSubgroups,"generic search",[IsGroup],COM_FUN(135));
InstallMethod(MinimalNormalSubgroups,"generic search in NormalSubgroups",[IsGroup and IsFinite and HasNormalSubgroups],COM_FUN(136));
InstallMethod(MinimalNormalSubgroups,"compute from conjugacy classes",[IsGroup and IsFinite],COM_FUN(137));
InstallMethod(MinimalNormalSubgroups,"handled by nice monomorphism",true,[IsGroup and IsHandledByNiceMonomorphism and IsFinite],0,COM_FUN(138));
InstallMethod(SmallGeneratingSet,"generators subset",[IsGroup and HasGeneratorsOfGroup],COM_FUN(139));
InstallMethod(\<,"groups by smallest generating sets",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(140));
InstallGlobalFunction(PowerMapOfGroupWithInvariants,COM_FUN(141));
InstallMethod(PowerMapOfGroup,"method for a group",[IsGroup,IsInt,IsHomogeneousList],COM_FUN(142));
InstallMethod(PowerMapOfGroup,"method for a permutation group",[IsGroup and IsPermCollection,IsInt,IsHomogeneousList],COM_FUN(143));
InstallMethod(PowerMapOfGroup,"method for a matrix group",[IsGroup and IsRingElementCollCollColl,IsInt,IsHomogeneousList],COM_FUN(144));
InstallMethod(KnowsHowToDecompose,"generic: just groups of order < 1000",IsIdenticalObj,[IsGroup,IsList],COM_FUN(145));
InstallOtherMethod(KnowsHowToDecompose,"trivial group",true,[IsGroup,IsEmpty],COM_FUN(146));
InstallMethod(KnowsHowToDecompose,"group: use GeneratorsOfGroup",[IsGroup],COM_FUN(147));
InstallGlobalFunction(HasAbelianFactorGroup,COM_FUN(148));
InstallGlobalFunction(HasElementaryAbelianFactorGroup,COM_FUN(149));
BindGlobal("Group_InitPseudoRandom",COM_FUN(150));
InstallGlobalFunction(Group_PseudoRandom,COM_FUN(151));
InstallMethod(PseudoRandom,"product replacement",[IsGroup and HasGeneratorsOfGroup],Group_PseudoRandom);
InstallMethod(ConjugateSubgroups,"generic",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(152));
InstallTrueMethod(CanComputeSize,HasSize);
InstallMethod(CanComputeIndex,"by default impossible unless identical",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(153));
InstallMethod(CanComputeIndex,"if sizes can be computed",IsIdenticalObj,[IsGroup and CanComputeSize,IsGroup and CanComputeSize],COM_FUN(154));
InstallMethod(CanComputeIsSubset,"if membership test works",IsIdenticalObj,[IsDomain and CanEasilyTestMembership,IsGroup and HasGeneratorsOfGroup],ReturnTrue);
InstallSubsetMaintenance(CanComputeSizeAnySubgroup,IsGroup and CanComputeSizeAnySubgroup,IsGroup);
InstallGlobalFunction(Factorization,COM_FUN(155));
InstallOtherMethod(Order,"for a group",[IsGroup],Size);
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grp.gi"

#F  file="lib/addmagma.gi" crc=62805062
RANK_FILTER_LIST  := [ 36196406, 12, 42262477, 13, 10958933, 15, 52830339, 
  17, 36196406, 12, 42262477, 13, 10958933, 15, 52830339, 17, 10958933, 15, 
  52830339, 17, 65935670, 14, 8126465, 2, 1985, 1, 8193, 2, 8126465, 2, 1985, 
  1, 8193, 2, 8126465, 2, 1985, 1, 8193, 2, 4893854, 17, 40699189, 19, 
  10958933, 15, 52830339, 17, 52830339, 17, 42262477, 13, 10958933, 15, 
  52830339, 17, 19152722, 18, 13915045, 15, 36196406, 12, 36196406, 12, 
  65935670, 14, 13915045, 15, 65935670, 14, 32380533, 19, 36197398, 14, 
  36196406, 12, 36196406, 12, 65935670, 14, 65935670, 14, 28566055, 16, 
  28566055, 16, 28566055, 16, 30505985, 3, 28566055, 16, 28566055, 16 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/addmagma.gi", 62805062 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/addmagma.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/addmagma.gi");
elif COM_RESULT = 3  then
Revision.addmagma_gi:="@(#)$Id: addmagma.gi,v 4.24 2002/09/03 15:24:14 gap Exp $";
InstallMethod(PrintObj,"for an add. magma",[IsAdditiveMagma],COM_FUN(1));
InstallMethod(PrintObj,"for an add. magma with generators",[IsAdditiveMagma and HasGeneratorsOfAdditiveMagma],COM_FUN(2));
InstallMethod(PrintObj,"for an add. magma-with-zero with generators",[IsAdditiveMagmaWithZero and HasGeneratorsOfAdditiveMagmaWithZero],COM_FUN(3));
InstallMethod(PrintObj,"for an add. magma-with-inverses with generators",[IsAdditiveGroup and HasGeneratorsOfAdditiveGroup],COM_FUN(4));
InstallMethod(ViewObj,"for an add. magma",[IsAdditiveMagma],COM_FUN(5));
InstallMethod(ViewObj,"for an add. magma with generators",[IsAdditiveMagma and HasGeneratorsOfAdditiveMagma],COM_FUN(6));
InstallMethod(ViewObj,"for an add. magma-with-zero with generators",[IsAdditiveMagmaWithZero and HasGeneratorsOfAdditiveMagmaWithZero],COM_FUN(7));
InstallMethod(ViewObj,"for an add. magma-with-inverses with generators",[IsAdditiveGroup and HasGeneratorsOfAdditiveGroup],COM_FUN(8));
InstallImmediateMethod(IsTrivial,IsAdditiveMagmaWithZero and HasGeneratorsOfAdditiveMagmaWithZero,0,COM_FUN(9));
InstallImmediateMethod(IsTrivial,IsAdditiveGroup and HasGeneratorsOfAdditiveGroup,0,COM_FUN(10));
InstallGlobalFunction(AdditiveMagma,COM_FUN(11));
InstallGlobalFunction(SubadditiveMagma,COM_FUN(12));
InstallGlobalFunction(SubadditiveMagmaNC,COM_FUN(13));
InstallGlobalFunction(AdditiveMagmaWithZero,COM_FUN(14));
InstallGlobalFunction(SubadditiveMagmaWithZero,COM_FUN(15));
InstallGlobalFunction(SubadditiveMagmaWithZeroNC,COM_FUN(16));
InstallGlobalFunction(AdditiveGroup,COM_FUN(17));
InstallGlobalFunction(SubadditiveGroup,COM_FUN(18));
InstallGlobalFunction(SubadditiveGroupNC,COM_FUN(19));
InstallMethod(TrivialSubadditiveMagmaWithZero,"for add.-magma-with-zero",[IsAdditiveMagmaWithZero],COM_FUN(20));
InstallMethod(AdditiveMagmaByGenerators,"for collection",[IsCollection],COM_FUN(21));
InstallOtherMethod(AdditiveMagmaByGenerators,"for family and list",[IsFamily,IsList],COM_FUN(22));
InstallMethod(AdditiveMagmaWithZeroByGenerators,"for collection",[IsCollection],COM_FUN(23));
InstallOtherMethod(AdditiveMagmaWithZeroByGenerators,"for family and list",[IsFamily,IsList],COM_FUN(24));
InstallMethod(AdditiveGroupByGenerators,"for collection",[IsCollection],COM_FUN(25));
InstallOtherMethod(AdditiveGroupByGenerators,"for family and list",[IsFamily,IsList],COM_FUN(26));
InstallImmediateMethod(GeneratorsOfAdditiveMagmaWithZero,IsAdditiveMagmaWithZero and HasGeneratorsOfAdditiveMagma and IsAttributeStoringRep,0,COM_FUN(27));
InstallImmediateMethod(GeneratorsOfAdditiveGroup,IsAdditiveGroup and HasGeneratorsOfAdditiveMagmaWithZero and IsAttributeStoringRep,0,COM_FUN(28));
InstallMethod(GeneratorsOfAdditiveMagma,[IsAdditiveMagmaWithZero and HasGeneratorsOfAdditiveMagmaWithZero],COM_FUN(29));
InstallMethod(GeneratorsOfAdditiveMagma,[IsAdditiveGroup and HasGeneratorsOfAdditiveGroup],COM_FUN(30));
InstallMethod(GeneratorsOfAdditiveMagmaWithZero,[IsAdditiveGroup and HasGeneratorsOfAdditiveGroup],COM_FUN(31));
InstallMethod(Representative,"for additive magma with known generators",[IsAdditiveMagma and HasGeneratorsOfAdditiveMagma],RepresentativeFromGenerators(GeneratorsOfAdditiveMagma));
InstallMethod(Representative,"for additive-magma-with-zero with known generators",[IsAdditiveMagmaWithZero and HasGeneratorsOfAdditiveMagmaWithZero],RepresentativeFromGenerators(GeneratorsOfAdditiveMagmaWithZero));
InstallMethod(Representative,"for additive-magma-with-inverses with known generators",[IsAdditiveGroup and HasGeneratorsOfAdditiveGroup],RepresentativeFromGenerators(GeneratorsOfAdditiveGroup));
InstallMethod(Representative,"for additive-magma-with-zero with known zero",[IsAdditiveMagmaWithZero and HasZero],SUM_FLAGS,Zero);
InstallMethod(Representative,"for additive-magma-with-zero with stored parent",[IsAdditiveMagmaWithZero and HasParentAttr],COM_FUN(32));
InstallMethod(AdditiveNeutralElement,[IsAdditiveMagma],COM_FUN(33));
InstallOtherMethod(Zero,"for additive magma",[IsAdditiveMagma],COM_FUN(34));
InstallOtherMethod(Zero,"for additive magma with zero (look at family)",[IsAdditiveMagmaWithZero],SUM_FLAGS,COM_FUN(35));
InstallOtherMethod(Zero,"for an add. magma-with-zero with parent (ask the parent)",[IsAdditiveMagmaWithZero and HasParent],COM_FUN(36));
InstallOtherMethod(Zero,"for additive magma with zero",[IsAdditiveMagmaWithZero],COM_FUN(37));
EnumeratorOfTrivialAdditiveMagmaWithZero:=COM_FUN(38);
InstallMethod(Enumerator,"for trivial add. magma-with-zero",[IsAdditiveMagmaWithZero and IsTrivial],EnumeratorOfTrivialAdditiveMagmaWithZero);
BindGlobal("ClosureAdditiveMagmaDefault",COM_FUN(39));
BindGlobal("EnumeratorOfAdditiveMagma",COM_FUN(40));
InstallMethod(Enumerator,"generic method for an add. magma",[IsAdditiveMagma and IsAttributeStoringRep],EnumeratorOfAdditiveMagma);
InstallMethod(IsSubset,"for two additive magmas",IsIdenticalObj,[IsAdditiveMagma,IsAdditiveMagma],COM_FUN(41));
InstallMethod(IsSubset,"for two additive magmas with zero",IsIdenticalObj,[IsAdditiveMagmaWithZero,IsAdditiveMagmaWithZero],COM_FUN(42));
InstallMethod(IsSubset,"for two additive magmas with inverses",IsIdenticalObj,[IsAdditiveGroup,IsAdditiveGroup],COM_FUN(43));
InstallMethod(ClosureAdditiveGroup,"for add. group and element",IsCollsElms,[IsAdditiveGroup,IsAdditiveElement],COM_FUN(44));
InstallOtherMethod(ClosureAdditiveGroup,"for two add. groups",IsIdenticalObj,[IsAdditiveGroup,IsAdditiveGroup],COM_FUN(45));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/addmagma.gi"

#F  file="lib/addcoset.gi" crc=28663516
RANK_FILTER_LIST  := [ 28566055, 16, 30505985, 3, 59899185, 14, 59899185, 14, 
  28566055, 16, 30505985, 3, 30505985, 3, 28566055, 16, 59899395, 12, 
  30505985, 3, 30505985, 3, 59899395, 12, 59899395, 12, 59899395, 12, 
  59899395, 12, 59899395, 12, 59899395, 12, 59899395, 12, 59899395, 12, 
  28566055, 16, 28566055, 16, 59899395, 12, 30505985, 3, 59899395, 12, 
  59899395, 12, 59899395, 12, 59899395, 12, 59899395, 12 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/addcoset.gi", 28663516 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/addcoset.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/addcoset.gi");
elif COM_RESULT = 3  then
Revision.addcoset_gi:="@(#)$Id: addcoset.gi,v 4.7 2002/04/15 10:04:22 sal Exp $";
DeclareRepresentation("IsAdditiveCosetDefaultRep",IsPositionalObjectRep,[1,2]);
InstallMethod(AdditiveCoset,"for additive group and additive element",IsCollsElms,[IsAdditiveGroup,IsAdditiveElement],0,COM_FUN(1));
InstallMethod(AdditivelyActingDomain,"for additive coset in default repres.",true,[IsAdditiveCoset and IsAdditiveCosetDefaultRep],SUM_FLAGS,COM_FUN(2));
InstallMethod(Representative,"for additive coset in default repres.",true,[IsAdditiveCoset and IsAdditiveCosetDefaultRep],SUM_FLAGS,COM_FUN(3));
InstallOtherMethod(\+,"for additive group and additive element",IsCollsElms,[IsAdditiveGroup,IsAdditiveElement],0,COM_FUN(4));
InstallOtherMethod(\+,"for additive element and additive group",IsElmsColls,[IsAdditiveElement,IsAdditiveGroup],0,COM_FUN(5));
InstallMethod(\+,"for additive coset and additive element",IsCollsElms,[IsAdditiveCoset,IsAdditiveElement],0,COM_FUN(6));
InstallMethod(\+,"for additive element and additive coset",IsElmsColls,[IsAdditiveElement,IsAdditiveCoset],0,COM_FUN(7));
InstallMethod(Enumerator,"for an additive coset",true,[IsAdditiveCoset],0,COM_FUN(8));
InstallMethod(IsFinite,"for an additive coset",true,[IsAdditiveCoset],0,COM_FUN(9));
InstallMethod(Random,"for an additive coset",true,[IsAdditiveCoset],0,COM_FUN(10));
InstallMethod(Size,"for an additive coset",true,[IsAdditiveCoset],0,COM_FUN(11));
InstallMethod(\=,"for two additive cosets",IsIdenticalObj,[IsAdditiveCoset,IsAdditiveCoset],0,COM_FUN(12));
InstallMethod(\=,"for additive coset and additive group",IsIdenticalObj,[IsAdditiveCoset,IsAdditiveGroup],0,COM_FUN(13));
InstallMethod(\=,"for additive group and additive coset",IsIdenticalObj,[IsAdditiveGroup,IsAdditiveCoset],0,COM_FUN(14));
InstallMethod(\in,"for additive element and additive coset",IsElmsColls,[IsAdditiveElement,IsAdditiveCoset],0,COM_FUN(15));
InstallMethod(Intersection2,"for two additive cosets",IsIdenticalObj,[IsAdditiveCoset,IsAdditiveCoset],0,COM_FUN(16));
InstallMethod(PrintObj,"for an additive coset",true,[IsAdditiveCoset],0,COM_FUN(17));
InstallMethod(ViewObj,"for an additive coset",true,[IsAdditiveCoset],0,COM_FUN(18));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/addcoset.gi"

#F  file="lib/ring.gi" crc=85210880
RANK_FILTER_LIST  := [ 10477489, 26, 55868525, 27, 4185463, 29, 27858656, 30, 
  10477489, 26, 55868525, 27, 4185463, 29, 27858656, 30, 57146856, 29, 
  10477489, 26, 46468841, 29, 10477489, 26, 22195601, 28, 22195601, 28, 
  15904535, 31, 15904535, 31, 46468841, 29, 22195601, 28, 15904535, 31, 
  44032463, 29, 34742765, 29, 19823217, 32, 49577491, 32, 10477489, 26, 
  27858656, 30, 55868525, 27, 27858656, 30, 10477489, 26, 1, 0, 1, 0, 
  8126465, 2, 8126465, 2, 8126465, 2, 10477489, 26, 64918210, 8, 64918210, 8, 
  64918210, 8, 64918210, 8, 10477489, 26, 55868525, 27, 4185463, 29, 
  27858656, 30, 55868525, 27, 27858656, 30, 55868525, 27, 10477489, 26, 
  10477489, 26, 64918210, 8, 4185463, 29, 64918210, 8, 10463570, 28, 
  64918210, 8, 10477489, 26, 10477489, 26, 4185463, 29, 4185463, 29, 
  10463570, 28, 8126465, 2, 10477489, 26, 8126465, 2, 64918210, 8, 64918210, 
  8, 10477489, 26, 64918210, 8, 64918210, 8, 64918210, 8, 38493679, 27, 
  64918210, 8, 10477489, 26, 64918210, 8, 10477489, 26, 64918210, 8, 
  64918210, 8, 10477489, 26, 64918210, 8, 64918210, 8, 64918210, 8, 64918210, 
  8, 64918210, 8, 64918210, 8, 64918210, 8, 57619825, 31, 64918210, 8, 
  64918210, 8, 64918210, 8, 64918210, 8, 57619825, 31, 64918210, 8, 64918210, 
  8, 64918210, 8, 64918210, 8, 64918210, 8, 64918210, 8, 64918210, 8, 
  57619825, 31, 64918210, 8, 64918210, 8, 64918210, 8, 64918210, 8, 17, 18, 
  64918210, 8, 10477489, 26, 64918210, 8, 17, 18, 64918210, 8, 64918210, 8, 
  64918210, 8, 57619825, 31, 64918210, 8, 64918210, 8, 64918210, 8, 64918210, 
  8, 57619825, 31, 64918210, 8, 64918210, 8, 64918210, 8, 64918210, 8, 
  57619825, 31, 64918210, 8, 64918210, 8, 55868525, 27, 55868525, 27 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/ring.gi", 85210880 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/ring.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/ring.gi");
elif COM_RESULT = 3  then
Revision.ring_gi:="@(#)$Id: ring.gi,v 4.49 2002/04/15 10:05:15 sal Exp $";
InstallMethod(PrintObj,"for a ring",true,[IsRing],0,COM_FUN(1));
InstallMethod(PrintObj,"for a ring with generators",true,[IsRing and HasGeneratorsOfRing],0,COM_FUN(2));
InstallMethod(PrintObj,"for a ring-with-one",true,[IsRingWithOne],0,COM_FUN(3));
InstallMethod(PrintObj,"for a ring-with-one with generators",true,[IsRingWithOne and HasGeneratorsOfRingWithOne],0,COM_FUN(4));
InstallMethod(ViewObj,"for a ring",true,[IsRing],0,COM_FUN(5));
InstallMethod(ViewObj,"for a ring with known generators",true,[IsRing and HasGeneratorsOfRing],0,COM_FUN(6));
InstallMethod(ViewObj,"for a ring-with-one",true,[IsRingWithOne],0,COM_FUN(7));
InstallMethod(ViewObj,"for a ring-with-one with known generators",true,[IsRingWithOne and HasGeneratorsOfRingWithOne],0,COM_FUN(8));
InstallImmediateMethod(IsAnticommutative,IsRing and IsCommutative and HasCharacteristic,0,COM_FUN(9));
InstallMethod(IsAnticommutative,"generic method for rings",true,[IsRing],0,COM_FUN(10));
InstallImmediateMethod(IsZeroSquaredRing,IsRing and IsAnticommutative and HasCharacteristic,0,COM_FUN(11));
InstallMethod(IsZeroSquaredRing,"for a ring",true,[IsRing],0,COM_FUN(12));
InstallMethod(IsCentral,"for two associative rings",IsIdenticalObj,[IsRing and IsAssociative,IsRing and IsAssociative],0,IsCentralFromGenerators(GeneratorsOfRing,GeneratorsOfRing));
InstallMethod(IsCentral,"for two associative rings-with-one",IsIdenticalObj,[IsRingWithOne and IsAssociative,IsRingWithOne and IsAssociative],0,IsCentralFromGenerators(GeneratorsOfRingWithOne,GeneratorsOfRingWithOne));
InstallImmediateMethod(IsCommutative,IsRing and IsAnticommutative and HasCharacteristic,0,COM_FUN(13));
InstallMethod(IsCommutative,"for an associative ring",true,[IsRing and IsAssociative],0,IsCommutativeFromGenerators(GeneratorsOfRing));
InstallMethod(IsCommutative,"for an associative ring-with-one",true,[IsRingWithOne and IsAssociative],0,IsCommutativeFromGenerators(GeneratorsOfRingWithOne));
InstallImmediateMethod(GeneratorsOfRing,IsRing and HasGeneratorsOfMagma and IsAttributeStoringRep,0,GeneratorsOfMagma);
InstallImmediateMethod(GeneratorsOfRing,IsRing and HasGeneratorsOfAdditiveMagmaWithInverses and IsAttributeStoringRep,0,GeneratorsOfAdditiveMagmaWithInverses);
InstallImmediateMethod(GeneratorsOfRingWithOne,IsRingWithOne and HasGeneratorsOfMagmaWithOne and IsAttributeStoringRep,0,GeneratorsOfMagmaWithOne);
InstallImmediateMethod(GeneratorsOfRingWithOne,IsRingWithOne and HasGeneratorsOfRing and IsAttributeStoringRep,0,GeneratorsOfRing);
InstallMethod(GeneratorsOfRing,"for a ring",true,[IsRing],0,GeneratorsOfMagma);
InstallMethod(GeneratorsOfRing,"for a ring-with-one with generators",true,[IsRingWithOne and HasGeneratorsOfRingWithOne],0,COM_FUN(14));
InstallMethod(Representative,"for a ring with generators",true,[IsRing and HasGeneratorsOfRing],0,RepresentativeFromGenerators(GeneratorsOfRing));
InstallMethod(Representative,"for a ring-with-one with generators",true,[IsRingWithOne and HasGeneratorsOfRingWithOne],0,RepresentativeFromGenerators(GeneratorsOfRingWithOne));
InstallOtherMethod(InterpolatedPolynomial,true,[IsRing,IsObject,IsObject],0,COM_FUN(15));
InstallMethod(RingByGenerators,"for a collection",true,[IsCollection],0,COM_FUN(16));
InstallMethod(DefaultRingByGenerators,"for a collection",true,[IsCollection],0,RingByGenerators);
InstallGlobalFunction(Ring,COM_FUN(17));
InstallGlobalFunction(DefaultRing,COM_FUN(18));
InstallGlobalFunction(Subring,COM_FUN(19));
InstallGlobalFunction(SubringNC,COM_FUN(20));
InstallGlobalFunction(SubringWithOne,COM_FUN(21));
InstallGlobalFunction(SubringWithOneNC,COM_FUN(22));
InstallMethod(RingWithOneByGenerators,"for a collection",true,[IsCollection],0,COM_FUN(23));
InstallGlobalFunction(RingWithOne,COM_FUN(24));
InstallMethod(IsAssociated,"for ring and two ring elements",IsCollsElmsElms,[IsRing,IsRingElement,IsRingElement],0,COM_FUN(25));
InstallOtherMethod(IsAssociated,"for two ring elements",IsIdenticalObj,[IsRingElement,IsRingElement],0,COM_FUN(26));
InstallMethod(IsSubset,"for two rings",IsIdenticalObj,[IsRing,IsRing and HasGeneratorsOfRing],0,COM_FUN(27));
InstallMethod(IsSubset,"for two rings-with-one",IsIdenticalObj,[IsRingWithOne,IsRingWithOne and HasGeneratorsOfRingWithOne],0,COM_FUN(28));
EnumeratorOfRing:=COM_FUN(29);
InstallMethod(Enumerator,"generic method for a ring with known generators",true,[IsRing and HasGeneratorsOfRing],0,EnumeratorOfRing);
InstallMethod(Enumerator,"generic method for a ring-with-one with known generators",true,[IsRingWithOne and HasGeneratorsOfRingWithOne],0,EnumeratorOfRing);
InstallMethod(Size,"characteristic zero ring is infinite",true,[IsRing and HasGeneratorsOfRing],0,COM_FUN(30));
InstallMethod(IsIntegralRing,"for a ring",true,[IsRing],0,COM_FUN(31));
InstallMethod(ClosureRing,"for a ring and a ring element",IsCollsElms,[IsRing,IsRingElement],0,COM_FUN(32));
InstallMethod(ClosureRing,"for a ring-with-one and a ring element",IsCollsElms,[IsRingWithOne,IsRingElement],0,COM_FUN(33));
InstallMethod(ClosureRing,"for a ring containing the whole family, and a ring element",IsCollsElms,[IsRing and IsWholeFamily,IsRingElement],SUM_FLAGS,COM_FUN(34));
InstallMethod(ClosureRing,"for two rings",IsIdenticalObj,[IsRing,IsRing],0,COM_FUN(35));
InstallMethod(ClosureRing,"for two rings-with-one",IsIdenticalObj,[IsRingWithOne,IsRingWithOne],0,COM_FUN(36));
InstallMethod(ClosureRing,"for a ring cont. the whole family, and a collection",IsIdenticalObj,[IsRing and IsWholeFamily,IsCollection],SUM_FLAGS,COM_FUN(37));
InstallMethod(ClosureRing,"for ring and collection of elements",IsIdenticalObj,[IsRing,IsCollection],0,COM_FUN(38));
InstallOtherMethod(Quotient,"for two ring elements (delegate to three argument version",IsIdenticalObj,[IsRingElement,IsRingElement],0,COM_FUN(39));
InstallMethod(Quotient,"for a ring and two ring elements",IsCollsElmsElms,[IsRing,IsRingElement,IsRingElement],0,COM_FUN(40));
InstallOtherMethod(IsUnit,"for a ring element",true,[IsRingElement],0,COM_FUN(41));
InstallMethod(IsUnit,"for a ring with known units and a ring element",IsCollsElms,[IsRing and HasUnits,IsRingElement],0,COM_FUN(42));
InstallMethod(IsUnit,"for a ring and a ring element",IsCollsElms,[IsRing,IsRingElement],0,COM_FUN(43));
InstallMethod(Units,"for a (finite) ring",true,[IsRing],0,COM_FUN(44));
InstallOtherMethod(StandardAssociate,"for a ring element",true,[IsRingElement],0,COM_FUN(45));
InstallOtherMethod(Associates,"for a ring element",true,[IsRingElement],0,COM_FUN(46));
InstallMethod(Associates,"for a ring and a ring element",IsCollsElms,[IsRing,IsRingElement],0,COM_FUN(47));
InstallOtherMethod(IsPrime,"for a ring element",true,[IsRingElement],0,COM_FUN(48));
InstallOtherMethod(IsIrreducibleRingElement,"for a ring element",true,[IsRingElement],0,COM_FUN(49));
InstallOtherMethod(Factors,"for a ring element",true,[IsRingElement],0,COM_FUN(50));
InstallOtherMethod(EuclideanDegree,"for a ring element",true,[IsRingElement],0,COM_FUN(51));
InstallOtherMethod(EuclideanRemainder,"for two ring elements",IsIdenticalObj,[IsRingElement,IsRingElement],0,COM_FUN(52));
InstallMethod(EuclideanRemainder,"for a Euclidean ring and two ring elements",IsCollsElmsElms,[IsEuclideanRing,IsRingElement,IsRingElement],0,COM_FUN(53));
InstallOtherMethod(EuclideanQuotient,"for two ring elements",IsIdenticalObj,[IsRingElement,IsRingElement],0,COM_FUN(54));
InstallMethod(EuclideanQuotient,"for a Euclidean ring and two ring elements",IsCollsElmsElms,[IsEuclideanRing,IsRingElement,IsRingElement],0,COM_FUN(55));
InstallOtherMethod(QuotientRemainder,"for two ring elements",IsIdenticalObj,[IsRingElement,IsRingElement],0,COM_FUN(56));
InstallOtherMethod(QuotientMod,"for three ring elements",COM_FUN(57),[IsRingElement,IsRingElement,IsRingElement],0,COM_FUN(58));
InstallMethod(QuotientMod,"for a Euclidean ring and three ring elements",IsCollsElmsElmsElms,[IsEuclideanRing,IsRingElement,IsRingElement,IsRingElement],0,COM_FUN(59));
InstallOtherMethod(PowerMod,"for ring element, integer, and ring element",true,[IsRingElement,IsInt,IsRingElement],0,COM_FUN(60));
InstallMethod(PowerMod,"for Euclidean ring, ring element, integer, and ring element",true,[IsRing,IsRingElement,IsInt,IsRingElement],0,COM_FUN(61));
InstallGlobalFunction(Gcd,COM_FUN(62));
InstallOtherMethod(GcdOp,"for two ring elements",IsIdenticalObj,[IsRingElement,IsRingElement],0,COM_FUN(63));
InstallMethod(GcdOp,"for a Euclidean ring and two ring elements",IsCollsElmsElms,[IsEuclideanRing,IsRingElement,IsRingElement],0,COM_FUN(64));
InstallGlobalFunction(GcdRepresentation,COM_FUN(65));
InstallOtherMethod(GcdRepresentationOp,"for two ring elements",IsIdenticalObj,[IsRingElement,IsRingElement],0,COM_FUN(66));
InstallMethod(GcdRepresentationOp,"for a Euclidean ring and two ring elements",IsCollsElmsElms,[IsEuclideanRing,IsRingElement,IsRingElement],0,COM_FUN(67));
InstallGlobalFunction(Lcm,COM_FUN(68));
InstallOtherMethod(LcmOp,"for two ring elements",IsIdenticalObj,[IsRingElement,IsRingElement],0,COM_FUN(69));
InstallMethod(LcmOp,"for a Euclidean ring and two ring elements",IsCollsElmsElms,[IsEuclideanRing,IsRingElement,IsRingElement],0,COM_FUN(70));
InstallMethod(\=,"for two rings with known generators",IsIdenticalObj,[IsRing and HasGeneratorsOfRing,IsRing and HasGeneratorsOfRing],0,COM_FUN(71));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/ring.gi"

#F  file="lib/ideal.gi" crc=-31914055
RANK_FILTER_LIST  := [ 10477489, 26, 8126465, 2, 10477489, 26, 8126465, 2, 
  10477489, 26, 8126465, 2, 28498634, 29, 1623772, 29, 32286326, 28, 
  54095163, 28, 31445622, 29, 32286326, 28, 54095163, 28, 31445622, 29, 
  1080815, 27, 58793020, 27, 41682040, 27, 5778672, 27, 59633724, 27, 
  41682040, 27, 5778672, 27, 59633724, 27, 13493938, 29, 44699449, 29, 
  31445622, 29, 31445622, 29, 1080815, 27, 1080815, 27, 58793020, 27, 
  58793020, 27, 49397306, 28, 49397306, 28, 64918210, 8, 10477489, 26, 
  10477489, 26, 64918210, 8, 1080815, 27, 10477489, 26, 10477489, 26, 
  58793020, 27, 10477489, 26, 10477489, 26, 10477489, 26, 10477489, 26, 
  10477489, 26, 10477489, 26 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/ideal.gi", -31914055 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/ideal.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/ideal.gi");
elif COM_RESULT = 3  then
Revision.ideal_gi:="@(#)$Id: ideal.gi,v 4.8.4.1 2005/03/31 13:23:24 gap Exp $";
InstallGlobalFunction(TwoSidedIdeal,COM_FUN(1));
InstallGlobalFunction(TwoSidedIdealNC,COM_FUN(2));
InstallGlobalFunction(LeftIdeal,COM_FUN(3));
InstallGlobalFunction(LeftIdealNC,COM_FUN(4));
InstallGlobalFunction(RightIdeal,COM_FUN(5));
InstallGlobalFunction(RightIdealNC,COM_FUN(6));
InstallMethod(TwoSidedIdealByGenerators,"for ring and collection",IsIdenticalObj,[IsRing,IsCollection],0,COM_FUN(7));
InstallMethod(LeftIdealByGenerators,"for ring and collection",IsIdenticalObj,[IsRing,IsCollection],0,COM_FUN(8));
InstallMethod(RightIdealByGenerators,"for ring and collection",IsIdenticalObj,[IsRing,IsCollection],0,COM_FUN(9));
InstallImmediateMethod(IsIdealInParent,IsLeftIdealInParent and HasParent,10,COM_FUN(10));
InstallImmediateMethod(IsIdealInParent,IsRightIdealInParent and HasParent,10,COM_FUN(11));
InstallMethod(PrintObj,"for a left ideal with known generators",true,[IsRing and HasLeftActingRingOfIdeal and HasGeneratorsOfLeftIdeal],0,COM_FUN(12));
InstallMethod(PrintObj,"for a right ideal with known generators",true,[IsRing and HasRightActingRingOfIdeal and HasGeneratorsOfRightIdeal],0,COM_FUN(13));
InstallMethod(PrintObj,"for a two-sided ideal with known generators",true,[IsRing and HasLeftActingRingOfIdeal and HasRightActingRingOfIdeal and HasGeneratorsOfTwoSidedIdeal],0,COM_FUN(14));
InstallMethod(ViewObj,"for a left ideal with known generators",true,[IsRing and HasLeftActingRingOfIdeal and HasGeneratorsOfLeftIdeal],100,COM_FUN(15));
InstallMethod(ViewObj,"for a right ideal with known generators",true,[IsRing and HasRightActingRingOfIdeal and HasGeneratorsOfRightIdeal],100,COM_FUN(16));
InstallMethod(ViewObj,"for a two-sided ideal with known generators",true,[IsRing and HasLeftActingRingOfIdeal and HasRightActingRingOfIdeal and HasGeneratorsOfTwoSidedIdeal],100,COM_FUN(17));
InstallOtherMethod(Zero,"for a left ideal",true,[IsRing and HasLeftActingRingOfIdeal],0,COM_FUN(18));
InstallOtherMethod(Zero,"for a right ideal",true,[IsRing and HasRightActingRingOfIdeal],0,COM_FUN(19));
EnumeratorOfIdeal:=COM_FUN(20);
InstallMethod(Enumerator,"generic method for a left ideal with known generators",true,[IsRing and HasGeneratorsOfLeftIdeal],0,EnumeratorOfIdeal);
InstallMethod(Enumerator,"generic method for a right ideal with known generators",true,[IsRing and HasGeneratorsOfRightIdeal],0,EnumeratorOfIdeal);
InstallMethod(Enumerator,"generic method for a two-sided ideal with known generators",true,[IsRing and HasGeneratorsOfIdeal],0,EnumeratorOfIdeal);
GeneratorsOfRingForIdeal:=COM_FUN(21);
InstallMethod(GeneratorsOfRing,"generic method for a left ideal with known generators",true,[IsRing and HasGeneratorsOfLeftIdeal],0,GeneratorsOfRingForIdeal);
InstallMethod(GeneratorsOfRing,"generic method for a right ideal with known generators",true,[IsRing and HasGeneratorsOfRightIdeal],0,GeneratorsOfRingForIdeal);
InstallMethod(GeneratorsOfRing,"generic method for a two-sided ideal with known generators",true,[IsRing and HasGeneratorsOfTwoSidedIdeal],0,GeneratorsOfRingForIdeal);
InstallMethod(GeneratorsOfTwoSidedIdeal,"for a two-sided ideal with known `GeneratorsOfLeftIdeal'",true,[IsRing and HasLeftActingRingOfIdeal and HasRightActingRingOfIdeal and HasGeneratorsOfLeftIdeal],0,GeneratorsOfLeftIdeal);
InstallMethod(GeneratorsOfTwoSidedIdeal,"for a two-sided ideal with known `GeneratorsOfRightIdeal'",true,[IsRing and HasLeftActingRingOfIdeal and HasRightActingRingOfIdeal and HasGeneratorsOfRightIdeal],0,GeneratorsOfRightIdeal);
InstallMethod(GeneratorsOfLeftIdeal,"for an ideal with known `GeneratorsOfTwoSidedIdeal'",true,[IsRing and HasLeftActingRingOfIdeal and HasRightActingRingOfIdeal and HasGeneratorsOfTwoSidedIdeal],0,GeneratorsOfRing);
InstallMethod(GeneratorsOfRightIdeal,"for an ideal with known `GeneratorsOfTwoSidedIdeal'",true,[IsRing and HasLeftActingRingOfIdeal and HasRightActingRingOfIdeal and HasGeneratorsOfTwoSidedIdeal],0,GeneratorsOfRing);
InstallMethod(\+,"method for two left ideals",IsIdenticalObj,[IsRing and HasLeftActingRingOfIdeal,IsRing and HasLeftActingRingOfIdeal],0,COM_FUN(22));
InstallMethod(\+,"method for two right ideals",IsIdenticalObj,[IsRing and HasRightActingRingOfIdeal,IsRing and HasRightActingRingOfIdeal],0,COM_FUN(23));
InstallMethod(\+,"method for two two-sided ideals",IsIdenticalObj,[IsRing and HasLeftActingRingOfIdeal and HasRightActingRingOfIdeal,IsRing and HasLeftActingRingOfIdeal and HasRightActingRingOfIdeal],0,COM_FUN(24));
InstallMethod(\*,"for ring element and ring (construct a right ideal)",IsElmsColls,[IsRingElement,IsRing],0,COM_FUN(25));
InstallMethod(\*,"for ring and ring element (construct a left ideal)",IsCollsElms,[IsRing,IsRingElement],0,COM_FUN(26));
InstallMethod(\*,"for left ideal and ring (construct a two-sided ideal)",IsIdenticalObj,[IsRing and HasLeftActingRingOfIdeal,IsRing],0,COM_FUN(27));
InstallMethod(\*,"for ring and right ideal (construct a two-sided ideal)",IsCollsElms,[IsRing,IsRing and HasRightActingRingOfIdeal],0,COM_FUN(28));
InstallMethod(AsLeftIdeal,"for two rings",IsIdenticalObj,[IsRing,IsRing],0,COM_FUN(29));
InstallMethod(AsRightIdeal,"for two rings",IsIdenticalObj,[IsRing,IsRing],0,COM_FUN(30));
InstallMethod(AsTwoSidedIdeal,"for two rings",IsIdenticalObj,[IsRing,IsRing],0,COM_FUN(31));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/ideal.gi"

#F  file="lib/module.gi" crc=-64859979
RANK_FILTER_LIST  := [ 10477489, 26, 8126465, 2, 10477489, 26, 32769, 4, 1, 
  0, 10477489, 26, 8126465, 2, 10477489, 26, 65147699, 22, 29524136, 25, 
  8193, 2, 43127408, 23, 32593131, 19, 51633992, 19, 65147699, 22, 63198130, 
  7, 65147699, 22, 65147699, 22, 65147699, 22, 65147699, 22, 65147699, 22, 
  29523144, 23 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/module.gi", -64859979 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/module.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/module.gi");
elif COM_RESULT = 3  then
Revision.module_gi:="@(#)$Id: module.gi,v 4.41 2002/04/15 10:05:04 sal Exp $";
InstallMethod(LeftModuleByGenerators,"for ring and collection",true,[IsRing,IsCollection],0,COM_FUN(1));
InstallMethod(LeftModuleByGenerators,"for ring, homogeneous list, and vector",true,[IsRing,IsHomogeneousList,IsObject],0,COM_FUN(2));
InstallMethod(AsLeftModule,"generic method for a ring and a collection",true,[IsRing,IsCollection],0,COM_FUN(3));
InstallMethod(AsLeftModule," for a ring and a left module",true,[IsRing,IsLeftModule],0,COM_FUN(4));
InstallMethod(SetGeneratorsOfLeftModule,"method that checks for `IsFiniteDimensional'",IsIdenticalObj,[IsFreeLeftModule and IsAttributeStoringRep,IsList],0,COM_FUN(5));
InstallMethod(Characteristic,"for a left module with known left acting domain",true,[IsLeftModule and HasLeftActingDomain],0,COM_FUN(6));
InstallMethod(Representative,"for left operator additive group with known generators",true,[IsLeftOperatorAdditiveGroup and HasGeneratorsOfLeftOperatorAdditiveGroup],0,RepresentativeFromGenerators(GeneratorsOfLeftOperatorAdditiveGroup));
InstallMethod(Representative,"for right operator additive group with known generators",true,[IsRightOperatorAdditiveGroup and HasGeneratorsOfRightOperatorAdditiveGroup],0,RepresentativeFromGenerators(GeneratorsOfRightOperatorAdditiveGroup));
InstallMethod(ClosureLeftModule,"for left module and vector",IsCollsElms,[IsLeftModule,IsVector],0,COM_FUN(7));
InstallOtherMethod(ClosureLeftModule,"for two left modules",IsIdenticalObj,[IsLeftModule,IsLeftModule],0,COM_FUN(8));
InstallOtherMethod(\+,"for two left modules",IsIdenticalObj,[IsLeftModule,IsLeftModule],0,COM_FUN(9));
InstallGlobalFunction(Submodule,COM_FUN(10));
InstallGlobalFunction(SubmoduleNC,COM_FUN(11));
InstallMethod(TrivialSubadditiveMagmaWithZero,"generic method for left modules",true,[IsLeftModule],0,COM_FUN(12));
InstallMethod(DimensionOfVectors,"generic method for left modules",true,[IsFreeLeftModule],0,COM_FUN(13));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/module.gi"

#F  file="lib/modfree.gi" crc=77356917
RANK_FILTER_LIST  := [ 29523144, 23, 29523144, 23, 29523144, 23, 29523144, 
  23, 63198130, 7, 5341125, 25, 13401798, 24, 29523144, 23, 4357545, 24, 
  29523144, 23, 29523144, 23, 29523144, 23, 29523144, 23, 29523144, 23, 
  29523144, 23, 29523144, 23, 29523144, 23, 4357545, 24, 38731269, 26, 
  29523144, 23, 29523144, 23, 38730277, 24, 63198130, 7, 29523144, 23, 32769, 
  4, 4357545, 24, 46300825, 24, 29523144, 23, 46300825, 24, 29523144, 23 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/modfree.gi", 77356917 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/modfree.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/modfree.gi");
elif COM_RESULT = 3  then
Revision.modfree_gi:="@(#)$Id: modfree.gi,v 4.40 2003/05/24 09:30:36 gap Exp $";
InstallMethod(\=,"for two free left modules (at least one fin. dim.)",IsIdenticalObj,[IsFreeLeftModule,IsFreeLeftModule],COM_FUN(1));
InstallMethod(\<,"for two free left modules",IsIdenticalObj,[IsFreeLeftModule,IsFreeLeftModule],COM_FUN(2));
InstallMethod(\in,"for vector and fin. dim. free left module",IsElmsColls,[IsVector,IsFreeLeftModule and IsFiniteDimensional],COM_FUN(3));
InstallImmediateMethod(IsFinite,IsFreeLeftModule and HasIsFiniteDimensional,0,COM_FUN(4));
InstallMethod(IsFinite,"for a free left module",[IsFreeLeftModule],COM_FUN(5));
InstallImmediateMethod(IsTrivial,IsFreeLeftModule and HasDimension,0,COM_FUN(6));
InstallMethod(IsTrivial,"for a free left module",[IsFreeLeftModule],COM_FUN(7));
InstallMethod(Size,"for a free left module",[IsFreeLeftModule],COM_FUN(8));
AsListOfFreeLeftModule:=COM_FUN(9);
InstallMethod(AsList,"for a free left module",[IsFreeLeftModule],AsListOfFreeLeftModule);
InstallMethod(AsSSortedList,"for a free left module",[IsFreeLeftModule],AsListOfFreeLeftModule);
InstallMethod(Random,"for a free left module",[IsFreeLeftModule],COM_FUN(10));
BindGlobal("GeneratorsOverIntersection",COM_FUN(11));
InstallMethod(IsSubset,"for two free left modules",IsIdenticalObj,[IsFreeLeftModule,IsFreeLeftModule],COM_FUN(12));
InstallMethod(Dimension,"for a free left module",[IsFreeLeftModule],COM_FUN(13));
InstallMethod(IsFiniteDimensional,"for a free left module with known dimension",[IsFreeLeftModule and HasDimension],COM_FUN(14));
InstallImmediateMethod(GeneratorsOfLeftModule,IsFreeLeftModule and HasBasis and IsAttributeStoringRep,0,COM_FUN(15));
InstallMethod(Enumerator,"for free left module (delegate to 'EnumeratorByBasis')",[IsFreeLeftModule],COM_FUN(16));
InstallMethod(Iterator,"for free left module (delegate to 'IteratorByBasis')",[IsFreeLeftModule],COM_FUN(17));
InstallMethod(ClosureLeftModule,"for free left module and vector",IsCollsElms,[IsFreeLeftModule and HasBasis,IsVector],COM_FUN(18));
InstallGlobalFunction(FreeLeftModule,COM_FUN(19));
InstallMethod(UseBasis,"for a free left module and a homog. list",[IsFreeLeftModule,IsHomogeneousList],COM_FUN(20));
InstallMethod(ViewObj,"for free left module with known dimension",[IsFreeLeftModule and HasDimension],COM_FUN(21));
InstallMethod(ViewObj,"for free left module with known generators",[IsFreeLeftModule and HasGeneratorsOfLeftModule],COM_FUN(22));
InstallMethod(ViewObj,"for free left module",[IsFreeLeftModule],COM_FUN(23));
InstallMethod(PrintObj,"for free left module with known generators",[IsFreeLeftModule and HasGeneratorsOfLeftModule],COM_FUN(24));
InstallMethod(PrintObj,"for free left module",[IsFreeLeftModule],COM_FUN(25));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/modfree.gi"

#F  file="lib/modulrow.gi" crc=133039391
RANK_FILTER_LIST  := [ 10477489, 26, 17, 18, 29523144, 23, 29523144, 23, 
  67009946, 48, 67009946, 48, 67009946, 48, 67009946, 48, 67009946, 48, 
  67009946, 48, 65077940, 12, 67009946, 48, 4524990, 16, 67009946, 48, 
  67009946, 48, 63755036, 16, 65077940, 12, 16800902, 7, 4524990, 16, 
  63755036, 16 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/modulrow.gi", 133039391 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/modulrow.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/modulrow.gi");
elif COM_RESULT = 3  then
Revision.modulrow_gi:="@(#)$Id: modulrow.gi,v 4.38 2003/06/04 17:45:08 gap Exp $";
InstallGlobalFunction(FullRowModule,COM_FUN(1));
InstallOtherMethod(\^,"for ring and integer (delegate to `FullRowModule')",[IsRing,IsInt],FullRowModule);
InstallMethod(IsRowModule,"for a free left module",[IsFreeLeftModule],COM_FUN(2));
InstallMethod(IsFullRowModule,"for free left (row) module",[IsFreeLeftModule],COM_FUN(3));
InstallMethod(Dimension,"for full row module",[IsFreeLeftModule and IsFullRowModule],DimensionOfVectors);
InstallMethod(Random,"for full row module",[IsFreeLeftModule and IsFullRowModule],COM_FUN(4));
InstallMethod(Representative,"for full row module",[IsFreeLeftModule and IsFullRowModule],COM_FUN(5));
InstallMethod(GeneratorsOfLeftModule,"for full row module",[IsFreeLeftModule and IsFullRowModule],COM_FUN(6));
InstallMethod(ViewObj,"for full row module",[IsFreeLeftModule and IsFullRowModule],COM_FUN(7));
InstallMethod(PrintObj,"for full row module",[IsFreeLeftModule and IsFullRowModule],COM_FUN(8));
InstallMethod(\in,"for full row module",IsElmsColls,[IsRowVector,IsFreeLeftModule and IsFullRowModule],COM_FUN(9));
InstallMethod(BasisVectors,"for canonical basis of a full row module",[IsBasis and IsCanonicalBasis and IsCanonicalBasisFullRowModule],COM_FUN(10));
InstallMethod(CanonicalBasis,"for a full row module",[IsFreeLeftModule and IsFullRowModule],COM_FUN(11));
InstallMethod(Basis,"for full row module (delegate to `CanonicalBasis')",[IsFreeLeftModule and IsFullRowModule],CANONICAL_BASIS_FLAGS,CanonicalBasis);
InstallMethod(Coefficients,"for canonical basis of a full row module",IsCollsElms,[IsBasis and IsCanonicalBasisFullRowModule,IsRowVector],COM_FUN(12));
InstallMethod(IsCanonicalBasisFullRowModule,"for a basis",[IsBasis],COM_FUN(13));
BindGlobal("NumberElement_FiniteFullRowModule",COM_FUN(14));
BindGlobal("PosVecEnumFF",COM_FUN(15));
BindGlobal("ElementNumber_FiniteFullRowModule",COM_FUN(16));
BindGlobal("NumberElement_InfiniteFullRowModule",COM_FUN(17));
BindGlobal("ElementNumber_InfiniteFullRowModule",COM_FUN(18));
InstallMethod(EnumeratorByBasis,"for enumerator via canonical basis of a full row module",[IsBasis and IsCanonicalBasis and IsCanonicalBasisFullRowModule],COM_FUN(19));
BindGlobal("NextIterator_FiniteFullRowModule",COM_FUN(20));
BindGlobal("IsDoneIterator_FiniteFullRowModule",COM_FUN(21));
BindGlobal("ShallowCopy_FiniteFullRowModule",COM_FUN(22));
BindGlobal("NextIterator_InfiniteFullRowModule",COM_FUN(23));
BindGlobal("ShallowCopy_InfiniteFullRowModule",COM_FUN(24));
InstallMethod(IteratorByBasis,"for canonical basis of a full row module",[IsBasis and IsCanonicalBasisFullRowModule],COM_FUN(25));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/modulrow.gi"

#F  file="lib/modulmat.gi" crc=13007432
RANK_FILTER_LIST  := [ 10477489, 26, 40093620, 27, 29523144, 23, 29523144, 
  23, 45252594, 48, 45252594, 48, 45252594, 48, 45252594, 48, 45252594, 48, 
  45252594, 48, 1, 0, 45252594, 48, 11169634, 16, 45252594, 48, 45252594, 48, 
  3290801, 16, 58412696, 30, 16800902, 7 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/modulmat.gi", 13007432 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/modulmat.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/modulmat.gi");
elif COM_RESULT = 3  then
Revision.modulmat_gi:="@(#)$Id: modulmat.gi,v 4.20 2002/04/15 10:05:04 sal Exp $";
InstallGlobalFunction(FullMatrixModule,COM_FUN(1));
InstallOtherMethod(\^,"for ring and list of integers (delegate to `FullMatrixModule')",[IsRing,IsCyclotomicCollection and IsList],COM_FUN(2));
InstallMethod(IsMatrixModule,"for a free left module",[IsFreeLeftModule],COM_FUN(3));
InstallMethod(IsFullMatrixModule,"for matrix module",[IsFreeLeftModule],COM_FUN(4));
InstallMethod(Dimension,"for full matrix module",[IsFreeLeftModule and IsFullMatrixModule],COM_FUN(5));
InstallMethod(Random,"for full matrix module",[IsFreeLeftModule and IsFullMatrixModule],COM_FUN(6));
InstallMethod(Representative,"for full matrix module",[IsFreeLeftModule and IsFullMatrixModule],COM_FUN(7));
InstallGlobalFunction(StandardGeneratorsOfFullMatrixModule,COM_FUN(8));
InstallMethod(GeneratorsOfLeftModule,"for full matrix module",[IsFreeLeftModule and IsFullMatrixModule],StandardGeneratorsOfFullMatrixModule);
InstallMethod(ViewObj,"for full matrix module",[IsFreeLeftModule and IsFullMatrixModule],COM_FUN(9));
InstallMethod(PrintObj,"for full matrix module",[IsFreeLeftModule and IsFullMatrixModule],COM_FUN(10));
InstallMethod(\in,"for full matrix module",IsElmsColls,[IsObject,IsFreeLeftModule and IsFullMatrixModule],COM_FUN(11));
InstallMethod(BasisVectors,"for canonical basis of a full matrix module",[IsBasis and IsCanonicalBasis and IsCanonicalBasisFullMatrixModule],COM_FUN(12));
InstallMethod(CanonicalBasis,[IsFreeLeftModule and IsFullMatrixModule],COM_FUN(13));
InstallMethod(Basis,"for full matrix module (delegate to `CanonicalBasis')",[IsFreeLeftModule and IsFullMatrixModule],CANONICAL_BASIS_FLAGS,CanonicalBasis);
InstallMethod(Coefficients,"for canonical basis of a full matrix module",IsCollsElms,[IsBasis and IsCanonicalBasisFullMatrixModule,IsMatrix],COM_FUN(14));
InstallMethod(IsCanonicalBasisFullMatrixModule,"for a basis",[IsBasis],COM_FUN(15));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/modulmat.gi"

#F  file="lib/basis.gi" crc=48000416
RANK_FILTER_LIST  := [ 16800902, 7, 16800902, 7, 52247917, 19, 16800902, 7, 
  1, 0, 17, 18, 16800902, 7, 16800902, 7, 32769, 4, 16800902, 7, 32769, 4, 
  4792773, 8, 16800902, 7, 12564616, 10, 24571785, 9, 24679735, 9, 4792773, 
  8, 16800902, 7, 12564616, 10, 24571785, 9, 24679735, 9, 63078388, 26, 
  29523144, 23, 16800902, 7, 32769, 4, 8193, 2, 8193, 2, 16800902, 7, 
  16800902, 7, 16800902, 7, 16800482, 13, 63198130, 7, 29523144, 23, 32769, 
  4, 29523144, 23, 32769, 4, 66353596, 27, 66353596, 27, 1, 0, 66353596, 27, 
  1, 0, 66353596, 27, 36076129, 27, 36076129, 27, 1, 0, 36076129, 27, 1, 0, 
  13106931, 13, 13106931, 13, 13106931, 13, 13106931, 13, 63198130, 7, 
  50494784, 26, 13106931, 13, 50494784, 26, 50494784, 26, 32769, 4, 50494784, 
  26, 32769, 4, 163586, 27, 54617831, 37, 66335943, 39, 64792380, 39, 
  8361516, 39, 63198130, 7, 50494784, 26, 63076886, 30, 29523144, 23, 
  41951068, 17, 29523144, 23, 41951068, 17, 29523144, 23, 41951068, 17, 
  29523144, 23, 41951068, 17, 58743777, 18, 58743777, 18, 63198130, 7, 
  58743777, 18, 41951068, 17, 58743777, 18, 63198130, 7, 16800062, 10, 
  16800062, 10, 63198130, 7, 16800062, 10, 32769, 4, 16800062, 10 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/basis.gi", 48000416 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/basis.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/basis.gi");
elif COM_RESULT = 3  then
Revision.basis_gi:="@(#)$Id: basis.gi,v 4.67 2003/05/15 15:18:03 gap Exp $";
InstallMethod(IsCanonicalBasis,"for a basis",[IsBasis],COM_FUN(1));
InstallMethod(\[\],"for a basis and a positive integer",[IsBasis,IsPosInt],COM_FUN(2));
InstallMethod(Position,"for a basis, an object, and a nonnegative integer",[IsBasis,IsObject,IsInt],COM_FUN(3));
InstallMethod(Length,"for a basis",[IsBasis],COM_FUN(4));
DeclareRepresentation("IsRelativeBasisDefaultRep",IsAttributeStoringRep,["basis","basechangeMatrix"]);
InstallTrueMethod(IsFinite,IsBasis and IsRelativeBasisDefaultRep);
InstallMethod(RelativeBasis,"for a basis and a homogeneous list",IsIdenticalObj,[IsBasis,IsHomogeneousList],COM_FUN(5));
InstallMethod(RelativeBasisNC,"for a basis and a homogeneous list",IsIdenticalObj,[IsBasis,IsHomogeneousList],COM_FUN(6));
InstallMethod(PrintObj,"for a basis with basis vectors",[IsBasis and HasBasisVectors],COM_FUN(7));
InstallMethod(PrintObj,"for a basis",[IsBasis],COM_FUN(8));
InstallMethod(PrintObj,"for a semi-echelonized basis with basis vectors",[IsBasis and HasBasisVectors and IsSemiEchelonized],COM_FUN(9));
InstallMethod(PrintObj,"for a semi-echelonized basis",[IsBasis and IsSemiEchelonized],COM_FUN(10));
InstallMethod(PrintObj,"for a canonical basis",[IsBasis and IsCanonicalBasis],SUM_FLAGS,COM_FUN(11));
InstallMethod(ViewObj,"for a basis with basis vectors",[IsBasis and HasBasisVectors],COM_FUN(12));
InstallMethod(ViewObj,"for a basis",[IsBasis],COM_FUN(13));
InstallMethod(ViewObj,"for a semi-echelonized basis with basis vectors",[IsBasis and HasBasisVectors and IsSemiEchelonized],COM_FUN(14));
InstallMethod(ViewObj,"for a semi-echelonized basis",[IsBasis and IsSemiEchelonized],COM_FUN(15));
InstallMethod(ViewObj,"for a canonical basis",[IsBasis and IsCanonicalBasis],SUM_FLAGS,COM_FUN(16));
InstallImmediateMethod(Basis,IsFreeLeftModule and HasCanonicalBasis and IsAttributeStoringRep,0,CanonicalBasis);
InstallMethod(CanonicalBasis,"default method, return `fail'",[IsFreeLeftModule],ReturnFail);
InstallMethod(LinearCombination,"for a basis and a homogeneous list",[IsBasis,IsHomogeneousList],COM_FUN(17));
InstallOtherMethod(LinearCombination,"for two lists",[IsList,IsList],COM_FUN(18));
BindGlobal("ElementNumber_Basis",COM_FUN(19));
BindGlobal("NumberElement_Basis",COM_FUN(20));
InstallMethod(EnumeratorByBasis,"for basis of a finite dimensional left module",[IsBasis],COM_FUN(21));
BindGlobal("IsDoneIterator_Basis",COM_FUN(22));
BindGlobal("NextIterator_Basis",COM_FUN(23));
BindGlobal("ShallowCopy_Basis",COM_FUN(24));
InstallMethod(IteratorByBasis,"for basis of a finite dimensional left module",[IsBasis],COM_FUN(25));
InstallMethod(StructureConstantsTable,"for a basis",[IsBasis],COM_FUN(26));
InstallMethod(Coefficients,"for relative basis and vector",IsCollsElms,[IsBasis and IsRelativeBasisDefaultRep,IsVector],COM_FUN(27));
InstallMethod(Basis,"method returning a relative basis",IsIdenticalObj,[IsFreeLeftModule,IsHomogeneousList],COM_FUN(28));
InstallMethod(BasisNC,"method returning a relative basis",IsIdenticalObj,[IsFreeLeftModule,IsHomogeneousList],COM_FUN(29));
InstallGlobalFunction("InstallHandlingByNiceBasis",COM_FUN(30));
InstallGlobalFunction("CheckForHandlingByNiceBasis",COM_FUN(31));
InstallHandlingByNiceBasis("IsGenericFiniteSpace",rec(detect:=COM_FUN(32),NiceFreeLeftModuleInfo:=COM_FUN(33),NiceVector:=COM_FUN(34),UglyVector:=COM_FUN(35)));
InstallMethod(NiceFreeLeftModule,"for generic finite space (use that this is a full row module)",[IsFreeLeftModule and IsGenericFiniteSpace],COM_FUN(36));
InstallHandlingByNiceBasis("IsSpaceOfRationalFunctions",rec(detect:=COM_FUN(37),NiceFreeLeftModuleInfo:=COM_FUN(38),NiceVector:=COM_FUN(39),UglyVector:=COM_FUN(40)));
InstallMethod(NiceBasis,"for basis by nice basis",[IsBasisByNiceBasis],COM_FUN(41));
InstallMethod(NiceBasisNC,"for basis by nice basis",[IsBasisByNiceBasis],COM_FUN(42));
InstallMethod(BasisVectors,"for basis by nice basis",[IsBasisByNiceBasis],COM_FUN(43));
InstallMethod(Coefficients,"for basis handled by nice basis, and vector",IsCollsElms,[IsBasisByNiceBasis,IsVector],COM_FUN(44));
InstallMethod(CanonicalBasis,"for free module that is handled by a nice basis",[IsFreeLeftModule and IsHandledByNiceBasis],COM_FUN(45));
InstallMethod(IsCanonicalBasis,"for a basis handled by a nice basis",[IsBasisByNiceBasis],COM_FUN(46));
BasisForFreeModuleByNiceBasis:=COM_FUN(47);
InstallMethod(Basis,"for free module that is handled by a nice basis",[IsFreeLeftModule and IsHandledByNiceBasis],BasisForFreeModuleByNiceBasis);
InstallMethod(Basis,"for free module that is handled by a nice basis, and hom. list",IsIdenticalObj,[IsFreeLeftModule and IsHandledByNiceBasis,IsHomogeneousList],COM_FUN(48));
InstallMethod(BasisNC,"for free module that is handled by a nice basis, and hom. list",IsIdenticalObj,[IsFreeLeftModule and IsHandledByNiceBasis,IsHomogeneousList],COM_FUN(49));
InstallMethod(NiceFreeLeftModule,"for free module that is handled by a nice basis",[IsFreeLeftModule and HasGeneratorsOfLeftModule and IsHandledByNiceBasis],COM_FUN(50));
BindGlobal("NiceFreeLeftModuleForFLMLOR",COM_FUN(51));
InstallMethod(NiceFreeLeftModule,"for FLMLOR that is handled by a nice basis",[IsFLMLOR and IsHandledByNiceBasis],COM_FUN(52));
InstallMethod(NiceFreeLeftModule,"for associative FLMLOR that is handled by a nice basis",[IsFLMLOR and IsAssociative and IsHandledByNiceBasis],COM_FUN(53));
InstallMethod(NiceFreeLeftModule,"for anticommutative FLMLOR that is handled by a nice basis",[IsFLMLOR and IsAnticommutative and IsHandledByNiceBasis],COM_FUN(54));
InstallMethod(NiceFreeLeftModule,"for commutative FLMLOR that is handled by a nice basis",[IsFLMLOR and IsCommutative and IsHandledByNiceBasis],COM_FUN(55));
InstallMethod(\in,"for vector and free left module that is handled by a nice basis",IsElmsColls,[IsVector,IsFreeLeftModule and IsHandledByNiceBasis],COM_FUN(56));
InstallMethod(Basis,"for trivial free left module",[IsFreeLeftModule and IsTrivial],COM_FUN(57));
InstallMethod(Basis,"for free left module and empty list",[IsFreeLeftModule,IsList and IsEmpty],COM_FUN(58));
InstallMethod(BasisNC,"for free left module and empty list",[IsFreeLeftModule,IsList and IsEmpty],COM_FUN(59));
InstallMethod(SemiEchelonBasis,"for free left module and empty list",[IsFreeLeftModule,IsList and IsEmpty],COM_FUN(60));
InstallMethod(SemiEchelonBasisNC,"for free left module and empty list",[IsFreeLeftModule,IsList and IsEmpty],COM_FUN(61));
InstallMethod(BasisVectors,"for empty basis",[IsBasis and IsEmpty],SUM_FLAGS,COM_FUN(62));
InstallMethod(Coefficients,"for empty basis and vector",IsCollsElms,[IsBasis and IsEmpty,IsVector],SUM_FLAGS,COM_FUN(63));
InstallMethod(LinearCombination,"for empty basis and empty list",[IsBasis and IsEmpty,IsList and IsEmpty],SUM_FLAGS,COM_FUN(64));
InstallMethod(SiftedVector,"for empty basis and vector",IsCollsElms,[IsBasis and IsEmpty,IsVector],SUM_FLAGS,COM_FUN(65));
DeclareRepresentation("IsBasisWithReplacedLeftModuleRep",IsAttributeStoringRep,["basisWithWrongModule"]);
InstallGlobalFunction(BasisWithReplacedLeftModule,COM_FUN(66));
InstallMethod(BasisVectors,"for a basis with replaced left module",[IsBasis and IsBasisWithReplacedLeftModuleRep],COM_FUN(67));
InstallMethod(Coefficients,"for a basis with replaced left module, and a vector",IsCollsElms,[IsBasis and IsBasisWithReplacedLeftModuleRep,IsVector],COM_FUN(68));
InstallMethod(LinearCombination,"for a basis with replaced left module, and a hom. list",[IsBasis and IsBasisWithReplacedLeftModuleRep,IsHomogeneousList],COM_FUN(69));
InstallMethod(IsCanonicalBasis,"for a basis with replaced left module, and a vector",[IsBasis and IsBasisWithReplacedLeftModuleRep],COM_FUN(70));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/basis.gi"

#F  file="lib/basismut.gi" crc=103375615
RANK_FILTER_LIST  := [ 8388084, 1, 8388084, 1, 8388084, 1, 29523144, 23, 
  10477489, 26, 8126465, 2, 10477489, 26, 8193, 2, 1, 0, 49143350, 3, 
  49143350, 3, 49143350, 3, 49143351, 5, 63198130, 7, 49143350, 3, 63198130, 
  7, 49143350, 3, 63546683, 3, 63546683, 3, 63546683, 3, 63546683, 3, 
  63546684, 5, 63198130, 7, 63546683, 3, 63198130, 7, 63546683, 3 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/basismut.gi", 103375615 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/basismut.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/basismut.gi");
elif COM_RESULT = 3  then
Revision.basismut_gi:="@(#)$Id: basismut.gi,v 4.23 2003/07/04 15:26:23 gap Exp $";
InstallMethod(ShallowCopy,"generic method for mutable basis",true,[IsMutableBasis],0,COM_FUN(1));
InstallMethod(NrBasisVectors,"generic method for mutable basis",true,[IsMutableBasis],0,COM_FUN(2));
InstallMethod(ImmutableBasis,"for mutable basis, and free left module",IsIdenticalObj,[IsMutableBasis,IsFreeLeftModule],0,COM_FUN(3));
DeclareRepresentation("IsMutableBasisByImmutableBasisRep",IsComponentObjectRep,["immutableBasis","leftActingDomain"]);
InstallMethod(MutableBasis,"generic method for ring and collection",true,[IsRing,IsCollection],0,COM_FUN(4));
InstallOtherMethod(MutableBasis,"generic method for ring, list, and object",true,[IsRing,IsList,IsObject],0,COM_FUN(5));
InstallMethod(ViewObj,"for mutable basis represented by an immutable basis",true,[IsMutableBasis and IsMutableBasisByImmutableBasisRep],0,COM_FUN(6));
InstallMethod(PrintObj,"for mutable basis represented by an immutable basis",true,[IsMutableBasis and IsMutableBasisByImmutableBasisRep],0,COM_FUN(7));
InstallOtherMethod(BasisVectors,"for mutable basis represented by an immutable basis",true,[IsMutableBasis and IsMutableBasisByImmutableBasisRep],0,COM_FUN(8));
InstallMethod(CloseMutableBasis,"for mutable basis represented by an immutable basis, and vector",IsCollsElms,[IsMutableBasis and IsMutable and IsMutableBasisByImmutableBasisRep,IsVector],0,COM_FUN(9));
InstallMethod(IsContainedInSpan,"for mutable basis represented by an immutable basis, and vector",IsCollsElms,[IsMutableBasis and IsMutableBasisByImmutableBasisRep,IsVector],0,COM_FUN(10));
InstallMethod(ImmutableBasis,"for mutable basis represented by an immutable basis",true,[IsMutableBasis and IsMutableBasisByImmutableBasisRep],0,COM_FUN(11));
DeclareRepresentation("IsMutableBasisViaNiceMutableBasisRep",IsComponentObjectRep,["leftModule","niceMutableBasis","zero"]);
InstallGlobalFunction(MutableBasisViaNiceMutableBasisMethod2,COM_FUN(12));
InstallGlobalFunction(MutableBasisViaNiceMutableBasisMethod3,COM_FUN(13));
InstallMethod(ViewObj,"for mutable basis represented by a nice mutable basis",true,[IsMutableBasis and IsMutableBasisViaNiceMutableBasisRep],0,COM_FUN(14));
InstallMethod(PrintObj,"for mutable basis represented by a nice mutable basis",true,[IsMutableBasis and IsMutableBasisViaNiceMutableBasisRep],0,COM_FUN(15));
InstallOtherMethod(BasisVectors,"for mutable basis represented by a nice mutable basis",true,[IsMutableBasis and IsMutableBasisViaNiceMutableBasisRep],0,COM_FUN(16));
InstallMethod(NrBasisVectors,"for mutable basis represented by a nice mutable basis",true,[IsMutableBasis and IsMutableBasisViaNiceMutableBasisRep],0,COM_FUN(17));
InstallMethod(CloseMutableBasis,"for mutable basis repres. by a nice mutable basis, and vector",IsCollsElms,[IsMutableBasis and IsMutable and IsMutableBasisViaNiceMutableBasisRep,IsVector],0,COM_FUN(18));
InstallMethod(IsContainedInSpan,"for mutable basis repres. by a nice mutable basis, and vector",IsCollsElms,[IsMutableBasis and IsMutableBasisViaNiceMutableBasisRep,IsVector],0,COM_FUN(19));
InstallMethod(ImmutableBasis,"for mutable basis represented by a nice mutable basis",true,[IsMutableBasis and IsMutableBasisViaNiceMutableBasisRep],0,COM_FUN(20));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/basismut.gi"

#F  file="lib/vspc.gi" crc=129797316
RANK_FILTER_LIST  := [ 26575481, 9, 1, 0, 29772091, 7, 23269910, 25, 8126465, 
  2, 4417712, 46, 23269910, 25, 40046631, 26, 65212230, 26, 23269910, 25, 
  40046631, 26, 23269910, 25, 23269910, 25, 8126465, 2, 23269910, 25, 
  23269910, 25, 23269910, 25, 23269910, 25, 32477043, 26, 63198130, 7, 
  464255, 10, 464255, 10, 464255, 10, 464255, 10, 23269910, 25, 17, 18, 
  23269910, 25, 49346896, 7 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/vspc.gi", 129797316 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/vspc.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/vspc.gi");
elif COM_RESULT = 3  then
Revision.vspc_gi:="@(#)$Id: vspc.gi,v 4.43.2.3 2005/04/27 13:16:19 gap Exp $";
InstallOtherMethod(SetLeftActingDomain,"method to set also 'IsLeftActedOnByDivisionRing'",[IsAttributeStoringRep and IsLeftActedOnByRing,IsObject],0,COM_FUN(1));
InstallMethod(IsLeftActedOnByDivisionRing,"method for external left set that is left acted on by a ring",[IsExtLSet and IsLeftActedOnByRing],COM_FUN(2));
InstallMethod(AsSubspace,"for a vector space and a collection",[IsVectorSpace,IsCollection],COM_FUN(3));
InstallMethod(AsLeftModule,"method for a division ring and a vector space",[IsDivisionRing,IsVectorSpace],COM_FUN(4));
InstallMethod(ViewObj,"for vector space with known generators",[IsVectorSpace and HasGeneratorsOfLeftModule],COM_FUN(5));
InstallMethod(ViewObj,"for vector space with known dimension",[IsVectorSpace and HasDimension],1,COM_FUN(6));
InstallMethod(ViewObj,"for vector space",[IsVectorSpace],COM_FUN(7));
InstallMethod(PrintObj,"method for vector space with left module generators",[IsVectorSpace and HasGeneratorsOfLeftModule],COM_FUN(8));
InstallMethod(PrintObj,"method for vector space",[IsVectorSpace],COM_FUN(9));
InstallOtherMethod(\/,"method for vector space and collection",IsIdenticalObj,[IsVectorSpace,IsCollection],COM_FUN(10));
InstallOtherMethod(\/,"generic method for two vector spaces",IsIdenticalObj,[IsVectorSpace,IsVectorSpace],COM_FUN(11));
InstallGlobalFunction(Intersection2Spaces,COM_FUN(12));
InstallMethod(Intersection2,"method for two vector spaces",IsIdenticalObj,[IsVectorSpace,IsVectorSpace],Intersection2Spaces(AsLeftModule,SubspaceNC,VectorSpace));
InstallMethod(ClosureLeftModule,"method for a vector space with basis, and a vector",IsCollsElms,[IsVectorSpace and HasBasis,IsVector],COM_FUN(13));
DeclareRepresentation("IsSubspacesVectorSpaceDefaultRep",IsComponentObjectRep,["dimension","structure"]);
InstallMethod(PrintObj,"method for a subspaces domain",[IsSubspacesVectorSpace and IsSubspacesVectorSpaceDefaultRep],COM_FUN(14));
InstallMethod(Size,"method for a subspaces domain",[IsSubspacesVectorSpace and IsSubspacesVectorSpaceDefaultRep],COM_FUN(15));
InstallMethod(Enumerator,"method for a subspaces domain",[IsSubspacesVectorSpace and IsSubspacesVectorSpaceDefaultRep],COM_FUN(16));
BindGlobal("IsDoneIterator_Subspaces",COM_FUN(17));
BindGlobal("NextIterator_Subspaces",COM_FUN(18));
BindGlobal("ShallowCopy_Subspaces",COM_FUN(19));
InstallMethod(Iterator,"for a subspaces domain",[IsSubspacesVectorSpace and IsSubspacesVectorSpaceDefaultRep],COM_FUN(20));
InstallMethod(Subspaces,"for a vector space, and an integer",[IsVectorSpace,IsInt],COM_FUN(21));
InstallMethod(Subspaces,"for a vector space",[IsVectorSpace],COM_FUN(22));
InstallGlobalFunction(IsSubspace,COM_FUN(23));
InstallMethod(IsVectorSpaceHomomorphism,[IsGeneralMapping],COM_FUN(24));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/vspc.gi"

#F  file="lib/vspcrow.gi" crc=66396349
RANK_FILTER_LIST  := [ 4417712, 46, 58412696, 30, 4417712, 46, 41951068, 17, 
  65077940, 12, 4417712, 46, 58412696, 30, 65077940, 12, 29522769, 27, 
  29522769, 27, 1, 0, 29522769, 27, 1, 0, 24158861, 15, 65077940, 12, 
  24158861, 15, 65077940, 12, 24158861, 15, 65077940, 12, 16800902, 7, 
  6493436, 29, 58412696, 30, 6493436, 29, 58412696, 30, 65077940, 12, 
  23270562, 30, 23270562, 30, 23270562, 30, 58412696, 30, 23270562, 30, 
  58412696, 30, 56825806, 33, 23270562, 30, 23270562, 30, 58412696, 30, 
  23270562, 30, 58412696, 30, 24158861, 15, 6493436, 29, 65077940, 12, 
  4417712, 46, 58412696, 30, 23270562, 30, 23270562, 30, 23270562, 30, 
  23270562, 30, 23270562, 30, 41685788, 31, 23270562, 30, 23270562, 30, 
  23269535, 29, 65147699, 22, 60755752, 51, 39081693, 11, 60755752, 51, 17, 
  18, 60755752, 51, 67108760, 5, 60755752, 51, 10477489, 26, 58412696, 30, 
  10477489, 26, 8193, 2, 65077940, 12, 53902631, 3, 53902631, 3, 53902631, 3, 
  53902632, 5, 65077940, 12, 53902631, 3, 65077940, 12, 53902631, 3, 
  53902631, 3, 65077940, 12, 59219357, 23, 23270562, 30 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/vspcrow.gi", 66396349 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/vspcrow.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/vspcrow.gi");
elif COM_RESULT = 3  then
Revision.vspcrow_gi:="@(#)$Id: vspcrow.gi,v 4.91.2.2 2005/04/27 13:43:36 gap Exp $";
InstallMethod(LeftModuleByGenerators,"for division ring and matrix over it",IsElmsColls,[IsDivisionRing,IsMatrix],COM_FUN(1));
InstallMethod(LeftModuleByGenerators,"for division ring, empty list, and row vector",[IsDivisionRing,IsList and IsEmpty,IsRowVector],COM_FUN(2));
InstallMethod(LeftModuleByGenerators,"for division ring, matrix over it, and row vector",[IsDivisionRing,IsMatrix,IsRowVector],COM_FUN(3));
InstallHandlingByNiceBasis("IsNonGaussianRowSpace",rec(detect:=COM_FUN(4),NiceFreeLeftModuleInfo:=COM_FUN(5),NiceVector:=COM_FUN(6),UglyVector:=COM_FUN(7)));
DeclareRepresentation("IsSemiEchelonBasisOfGaussianRowSpaceRep",IsAttributeStoringRep,["heads"]);
InstallTrueMethod(IsSmallList,IsList and IsSemiEchelonBasisOfGaussianRowSpaceRep);
InstallMethod(LinearCombination,IsCollsElms,[IsBasis and IsSemiEchelonBasisOfGaussianRowSpaceRep,IsRowVector],COM_FUN(8));
InstallMethod(Coefficients,"for semi-ech. basis of a Gaussian row space, and a row vector",IsCollsElms,[IsBasis and IsSemiEchelonBasisOfGaussianRowSpaceRep,IsRowVector],COM_FUN(9));
BindGlobal("SiftedVectorForGaussianRowSpace",COM_FUN(10));
InstallMethod(SiftedVector,"for semi-ech. basis of Gaussian row space, and row vector",IsCollsElms,[IsBasis and IsSemiEchelonBasisOfGaussianRowSpaceRep,IsRowVector],COM_FUN(11));
HeadsInfoOfSemiEchelonizedMat:=COM_FUN(12);
InstallMethod(IsSemiEchelonized,"for basis of a Gaussian row space",[IsBasis],COM_FUN(13));
InstallOtherMethod(\*,IsIdenticalObj,[IsRowSpace,IsMatrix],COM_FUN(14));
InstallOtherMethod(\^,IsIdenticalObj,[IsRowSpace,IsMatrix],COM_FUN(15));
InstallMethod(\in,"for row vector and Gaussian row space",IsElmsColls,[IsRowVector,IsGaussianRowSpace],COM_FUN(16));
InstallMethod(Basis,"for Gaussian row space (construct a semi-echelonized basis)",[IsGaussianRowSpace],SemiEchelonBasis);
InstallMethod(Basis,"for Gaussian row space and matrix (try semi-echelonized)",IsIdenticalObj,[IsGaussianRowSpace,IsMatrix],COM_FUN(17));
InstallMethod(BasisNC,"for Gaussian row space and matrix (try semi-echelonized)",IsIdenticalObj,[IsGaussianRowSpace,IsMatrix],COM_FUN(18));
InstallImmediateMethod(SemiEchelonBasis,IsGaussianRowSpace and HasCanonicalBasis and IsAttributeStoringRep,20,CanonicalBasis);
InstallMethod(SemiEchelonBasis,"for Gaussian row space",[IsGaussianRowSpace],COM_FUN(19));
InstallMethod(SemiEchelonBasis,"for Gaussian row space and matrix",IsIdenticalObj,[IsGaussianRowSpace,IsMatrix],COM_FUN(20));
InstallMethod(SemiEchelonBasisNC,"for Gaussian row space and matrix",IsIdenticalObj,[IsGaussianRowSpace,IsMatrix],COM_FUN(21));
InstallMethod(BasisVectors,"for semi-ech. basis of a Gaussian row space",[IsBasis and IsSemiEchelonBasisOfGaussianRowSpaceRep],COM_FUN(22));
InstallOtherMethod(Zero,"for a row space",[IsRowSpace],COM_FUN(23));
InstallMethod(IsZero,"for row vector",[IsRowVector],COM_FUN(24));
InstallMethod(AsLeftModule,"for division ring and matrix",IsElmsColls,[IsDivisionRing,IsMatrix],COM_FUN(25));
InstallOtherMethod(\+,"for two Gaussian row spaces",IsIdenticalObj,[IsGaussianRowSpace,IsGaussianRowSpace],COM_FUN(26));
InstallMethod(Intersection2,"for two Gaussian row spaces",IsIdenticalObj,[IsGaussianRowSpace,IsGaussianRowSpace],COM_FUN(27));
InstallMethod(NormedRowVectors,"for Gaussian row space",[IsGaussianRowSpace],COM_FUN(28));
InstallMethod(CanonicalBasis,"for Gaussian row space with known semi-ech. basis",[IsGaussianRowSpace and HasSemiEchelonBasis],COM_FUN(29));
InstallMethod(CanonicalBasis,"for Gaussian row space",[IsGaussianRowSpace],COM_FUN(30));
InstallMethod(IsFullRowModule,"for Gaussian row space",[IsGaussianRowSpace],COM_FUN(31));
InstallMethod(IsFullRowModule,"for non-Gaussian row space",[IsVectorSpace and IsNonGaussianRowSpace],ReturnFalse);
InstallOtherMethod(IsFullRowModule,"for arbitrary free left module",[IsLeftModule],COM_FUN(32));
InstallMethod(CanonicalBasis,"for a full row space",[IsFullRowModule and IsVectorSpace],COM_FUN(33));
DeclareRepresentation("IsSubspacesFullRowSpaceDefaultRep",IsSubspacesVectorSpaceDefaultRep,[]);
BindGlobal("IsDoneIterator_SubspacesDim",COM_FUN(34));
BindGlobal("NextIterator_SubspacesDim",COM_FUN(35));
BindGlobal("ShallowCopy_SubspacesDim",COM_FUN(36));
BindGlobal("IsDoneIterator_SubspacesAll",COM_FUN(37));
BindGlobal("NextIterator_SubspacesAll",COM_FUN(38));
BindGlobal("ShallowCopy_SubspacesAll",COM_FUN(39));
InstallMethod(Iterator,"for subspaces collection of a (finite) full row module",[IsSubspacesVectorSpace and IsSubspacesFullRowSpaceDefaultRep],COM_FUN(40));
InstallMethod(Subspaces,"for (Gaussian) full row space",[IsFullRowModule and IsVectorSpace,IsInt],COM_FUN(41));
InstallOtherMethod(Subspaces,"for (Gaussian) full row space",[IsFullRowModule and IsVectorSpace,IsString],COM_FUN(42));
InstallMethod(Subspaces,[IsFullRowModule and IsVectorSpace],COM_FUN(43));
DeclareRepresentation("IsMutableBasisOfGaussianRowSpaceRep",IsComponentObjectRep,["heads","basisVectors","leftActingDomain","zero"]);
InstallMethod(MutableBasis,"method to construct mutable bases of row spaces",IsElmsColls,[IsRing,IsMatrix],COM_FUN(44));
InstallOtherMethod(MutableBasis,"method to construct mutable bases of row spaces",IsIdenticalObjObjXObj,[IsRing,IsList,IsRowVector],COM_FUN(45));
InstallMethod(ViewObj,"for a mutable basis of a Gaussian row space",[IsMutableBasis and IsMutableBasisOfGaussianRowSpaceRep],COM_FUN(46));
InstallMethod(PrintObj,"for a mutable basis of a Gaussian row space",[IsMutableBasis and IsMutableBasisOfGaussianRowSpaceRep],COM_FUN(47));
InstallOtherMethod(BasisVectors,"for a mutable basis of a Gaussian row space",[IsMutableBasis and IsMutableBasisOfGaussianRowSpaceRep],COM_FUN(48));
InstallMethod(CloseMutableBasis,"for a mut. basis of a Gaussian row space, and a row vector",IsCollsElms,[IsMutableBasis and IsMutable and IsMutableBasisOfGaussianRowSpaceRep,IsRowVector],COM_FUN(49));
InstallMethod(IsContainedInSpan,"for a mut. basis of a Gaussian row space, and a row vector",IsCollsElms,[IsMutableBasis and IsMutableBasisOfGaussianRowSpaceRep,IsRowVector],COM_FUN(50));
InstallMethod(ImmutableBasis,"for a mutable basis of a Gaussian row space",[IsMutableBasis and IsMutableBasisOfGaussianRowSpaceRep],COM_FUN(51));
InstallOtherMethod(SiftedVector,"for mutable basis of Gaussian row space, and row vector",IsCollsElms,[IsMutableBasis and IsMutableBasisOfGaussianRowSpaceRep,IsRowVector],COM_FUN(52));
InstallGlobalFunction(OnLines,COM_FUN(53));
InstallMethod(NormedRowVector,"for a row vector of scalars",[IsRowVector and IsScalarCollection],COM_FUN(54));
BindGlobal("ElementNumber_ExtendedVectors",COM_FUN(55));
BindGlobal("NumberElement_ExtendedVectors",COM_FUN(56));
BindGlobal("NumberElement_ExtendedVectorsFF",COM_FUN(57));
BindGlobal("Length_ExtendedVectors",COM_FUN(58));
BindGlobal("PrintObj_ExtendedVectors",COM_FUN(59));
BindGlobal("ExtendedVectors",COM_FUN(60));
BindGlobal("ElementNumber_NormedRowVectors",COM_FUN(61));
BindGlobal("NumberElement_NormedRowVectors",COM_FUN(62));
BindGlobal("Length_NormedRowVectors",COM_FUN(63));
BindGlobal("PrintObj_NormedRowVectors",COM_FUN(64));
BindGlobal("EnumeratorOfNormedRowVectors",COM_FUN(65));
InstallMethod(OrthogonalSpaceInFullRowSpace,"dual space for Gaussian row space",[IsGaussianRowSpace],COM_FUN(66));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/vspcrow.gi"

#F  file="lib/vspcmat.gi" crc=3570240
RANK_FILTER_LIST  := [ 46355192, 27, 46355192, 27, 1, 0, 46355192, 27, 1, 0, 
  40721117, 15, 58412696, 30, 40721117, 15, 58412696, 30, 16800902, 7, 
  23277610, 30, 23277610, 30, 32769, 4, 23277610, 30, 32769, 4, 56832854, 33, 
  23277610, 30, 23277610, 30, 32769, 4, 23277610, 30, 32769, 4, 40721117, 15, 
  6500484, 29, 23277610, 30, 23277610, 30, 40101958, 29, 65147699, 22, 
  15728491, 48, 10477489, 26, 8126465, 2, 4417712, 46, 15466392, 16, 
  10477489, 26, 32769, 4, 58412696, 30, 56228514, 3, 56228514, 3, 56228514, 
  3, 56228515, 5, 58412696, 30, 56228514, 3, 58412696, 30, 56228514, 3, 
  58412696, 30, 56228514, 3 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/vspcmat.gi", 3570240 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/vspcmat.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/vspcmat.gi");
elif COM_RESULT = 3  then
Revision.vspcmat_gi:="@(#)$Id: vspcmat.gi,v 4.37 2002/08/23 14:35:10 gap Exp $";
InstallHandlingByNiceBasis("IsNonGaussianMatrixSpace",rec(detect:=COM_FUN(1),NiceFreeLeftModuleInfo:=ReturnFalse,NiceVector:=COM_FUN(2),UglyVector:=COM_FUN(3)));
DeclareRepresentation("IsSemiEchelonBasisOfGaussianMatrixSpaceRep",IsAttributeStoringRep,["heads"]);
InstallTrueMethod(IsSmallList,IsList and IsSemiEchelonBasisOfGaussianMatrixSpaceRep);
InstallMethod(Coefficients,"for semi-ech. basis of a Gaussian matrix space, and a matrix",IsCollsElms,[IsBasis and IsSemiEchelonBasisOfGaussianMatrixSpaceRep,IsMatrix],COM_FUN(4));
BindGlobal("SiftedVectorForGaussianMatrixSpace",COM_FUN(5));
InstallMethod(SiftedVector,"for semi-ech. basis of Gaussian matrix space, and matrix",IsCollsElms,[IsBasis and IsSemiEchelonBasisOfGaussianMatrixSpaceRep,IsMatrix],COM_FUN(6));
BindGlobal("HeadsInfoOfSemiEchelonizedMats",COM_FUN(7));
InstallMethod(IsSemiEchelonized,"for basis (of a Gaussian matrix space)",[IsBasis],COM_FUN(8));
InstallMethod(Basis,"for Gaussian matrix space (construct a semi-echelonized basis)",[IsGaussianMatrixSpace],SemiEchelonBasis);
InstallMethod(Basis,"for Gaussian matrix space and list of matrices (try semi-ech.)",IsIdenticalObj,[IsGaussianMatrixSpace,IsHomogeneousList],COM_FUN(9));
InstallMethod(BasisNC,"for Gaussian matrix space and list of matrices (try semi-ech.)",IsIdenticalObj,[IsGaussianMatrixSpace,IsHomogeneousList],COM_FUN(10));
InstallImmediateMethod(SemiEchelonBasis,IsGaussianMatrixSpace and HasCanonicalBasis and IsAttributeStoringRep,20,CanonicalBasis);
InstallMethod(SemiEchelonBasis,"for Gaussian matrix space",[IsGaussianMatrixSpace],COM_FUN(11));
InstallMethod(SemiEchelonBasis,"for Gaussian matrix space and list of matrices",IsIdenticalObj,[IsGaussianMatrixSpace,IsHomogeneousList],COM_FUN(12));
InstallMethod(SemiEchelonBasisNC,"for Gaussian matrix space and list of matrices",IsIdenticalObj,[IsGaussianMatrixSpace,IsHomogeneousList],COM_FUN(13));
InstallMethod(BasisVectors,"for semi-ech. basis of a Gaussian matrix space",[IsBasis and IsSemiEchelonBasisOfGaussianMatrixSpaceRep],COM_FUN(14));
InstallOtherMethod(Zero,"for a matrix space",[IsMatrixSpace],COM_FUN(15));
InstallMethod(CanonicalBasis,"for Gaussian matrix space",[IsGaussianMatrixSpace],COM_FUN(16));
InstallMethod(IsFullMatrixModule,"for Gaussian matrix space",[IsGaussianMatrixSpace],COM_FUN(17));
InstallMethod(IsFullMatrixModule,"for non-Gaussian matrix space",[IsVectorSpace and IsNonGaussianMatrixSpace],ReturnFalse);
InstallOtherMethod(IsFullMatrixModule,"for arbitrary free left module",[IsLeftModule],COM_FUN(18));
InstallMethod(CanonicalBasis,"for full matrix space",[IsFullMatrixModule],COM_FUN(19));
DeclareRepresentation("IsMutableBasisOfGaussianMatrixSpaceRep",IsComponentObjectRep,["heads","basisVectors","leftActingDomain","zero"]);
InstallMethod(MutableBasis,"to construct mutable bases of Gaussian matrix spaces",IsElmsCollColls,[IsRing,IsCollection],COM_FUN(20));
InstallMethod(MutableBasis,"to construct a mutable basis of a Lie matrix space",IsElmsCollLieColls,[IsDivisionRing,IsLieObjectCollection],COM_FUN(21));
InstallOtherMethod(MutableBasis,"to construct mutable bases of matrix spaces",COM_FUN(22),[IsRing,IsHomogeneousList,IsMatrix],COM_FUN(23));
InstallMethod(ViewObj,"for a mutable basis of a Gaussian matrix space",[IsMutableBasis and IsMutableBasisOfGaussianMatrixSpaceRep],COM_FUN(24));
InstallMethod(PrintObj,"for a mutable basis of a Gaussian matrix space",[IsMutableBasis and IsMutableBasisOfGaussianMatrixSpaceRep],COM_FUN(25));
InstallOtherMethod(BasisVectors,"for a mutable basis of a Gaussian matrix space",[IsMutableBasis and IsMutableBasisOfGaussianMatrixSpaceRep],COM_FUN(26));
InstallMethod(CloseMutableBasis,"for a mut. basis of a Gaussian matrix space, and a matrix",IsCollsElms,[IsMutableBasis and IsMutable and IsMutableBasisOfGaussianMatrixSpaceRep,IsMatrix],COM_FUN(27));
InstallMethod(IsContainedInSpan,"for a mut. basis of a Gaussian matrix space, and a matrix",IsCollsElms,[IsMutableBasis and IsMutableBasisOfGaussianMatrixSpaceRep,IsMatrix],COM_FUN(28));
InstallOtherMethod(SiftedVector,"for mutable basis of Gaussian matrix space, and matrix",IsCollsElms,[IsMutableBasis and IsMutableBasisOfGaussianMatrixSpaceRep,IsMatrix],COM_FUN(29));
InstallMethod(ImmutableBasis,"for a mutable basis of a Gaussian matrix space",[IsMutableBasis and IsMutableBasisOfGaussianMatrixSpaceRep],COM_FUN(30));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/vspcmat.gi"

#F  file="lib/vspchom.gi" crc=-117060172
RANK_FILTER_LIST  := [ 29523144, 23, 29523144, 23, 32769, 4, 32769, 4, 
  29523144, 23, 29523144, 23, 8193, 2, 8193, 2, 50465224, 23, 10809998, 23, 
  10809998, 23, 10809998, 23, 10809998, 23, 10809998, 23, 10809998, 23, 
  10809998, 23, 1, 0, 10809998, 23, 1, 0, 10809998, 23, 10809998, 23, 
  62119252, 27, 32505602, 3, 10809998, 23, 10809998, 23, 6093618, 19, 
  50465224, 23, 10809998, 23, 49346896, 7, 49346896, 7, 10809998, 23, 
  62119252, 27, 33547271, 11, 33547271, 11, 62119252, 27, 16800902, 7, 
  58412696, 30, 16800902, 7, 39381979, 23, 39381979, 23, 39381979, 23, 1, 0, 
  39381979, 23, 1, 0, 39381979, 23, 39381979, 23, 29523144, 23, 63076886, 30, 
  29523144, 23, 29523144, 23, 32505602, 3, 39381979, 23, 39381979, 23, 
  6093618, 19, 63237580, 27, 23582354, 27, 33547271, 11, 33547271, 11, 
  23582354, 27, 23582354, 27, 62119252, 27, 62119252, 27, 23582354, 27, 
  10447079, 29, 10447079, 29, 1, 0, 10447079, 29, 1, 0, 40162743, 11, 
  40162743, 11, 40162743, 11, 2577007, 32, 53526029, 34, 53526029, 34, 
  53526029, 34, 53526029, 34, 53526029, 34, 53526029, 34, 53526029, 34, 
  49346896, 7, 53526029, 34, 16800902, 7, 19270353, 9, 19270353, 9, 49346896, 
  7, 19270353, 9, 23582354, 27, 13363287, 25, 4417712, 46, 29523144, 23, 
  29523144, 23, 4417712, 46, 29523144, 23 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/vspchom.gi", -117060172 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/vspchom.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/vspchom.gi");
elif COM_RESULT = 3  then
Revision.vspchom_gi:="@(#)$Id: vspchom.gi,v 4.38.4.1 2005/02/21 08:36:32 gap Exp $";
DeclareRepresentation("IsLinearGeneralMappingByImagesDefaultRep",IsAttributeStoringRep,["basisimage","preimagesbasisimage","corelations","basispreimage","imagesbasispreimage","relations","generators","genimages"]);
InstallTrueMethod(IsAdditiveElementWithInverse,IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep);
InstallTrueMethod(IsLeftModuleGeneralMapping,IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep);
InstallMethod(LeftModuleGeneralMappingByImages,"for two free left modules and two homogeneous lists",[IsFreeLeftModule,IsFreeLeftModule,IsHomogeneousList,IsHomogeneousList],COM_FUN(1));
InstallMethod(LeftModuleHomomorphismByImagesNC,"for two left modules and two lists",[IsFreeLeftModule,IsFreeLeftModule,IsList,IsList],COM_FUN(2));
InstallGlobalFunction(LeftModuleHomomorphismByImages,COM_FUN(3));
InstallMethod(AsLeftModuleGeneralMappingByImages,"for a linear g.m.b.i.",[IsLeftModuleGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep],IdFunc);
InstallMethod(ImagesSource,"for a linear g.m.b.i.",[IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep],COM_FUN(4));
InstallMethod(PreImagesRange,"for a linear g.m.b.i.",[IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep],COM_FUN(5));
BindGlobal("MakeImagesInfoLinearGeneralMappingByImages",COM_FUN(6));
BindGlobal("MakePreImagesInfoLinearGeneralMappingByImages",COM_FUN(7));
InstallMethod(CoKernelOfAdditiveGeneralMapping,"for left module g.m.b.i.",[IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep],COM_FUN(8));
InstallMethod(IsSingleValued,"for left module g.m.b.i.",[IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep],COM_FUN(9));
InstallMethod(KernelOfAdditiveGeneralMapping,"for left module g.m.b.i.",[IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep],COM_FUN(10));
InstallMethod(IsInjective,"for left module g.m.b.i.",[IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep],COM_FUN(11));
InstallMethod(ImagesRepresentative,"for left module g.m.b.i., and element",FamSourceEqFamElm,[IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep,IsObject],COM_FUN(12));
InstallMethod(PreImagesRepresentative,"for left module g.m.b.i., and element",FamRangeEqFamElm,[IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep,IsObject],COM_FUN(13));
InstallMethod(ViewObj,"for a left module g.m.b.i",[IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep],COM_FUN(14));
InstallMethod(PrintObj,"for a left module g.m.b.i",[IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep],COM_FUN(15));
InstallMethod(PrintObj,"for a left module hom. b.i",[IsMapping and IsLinearGeneralMappingByImagesDefaultRep],COM_FUN(16));
InstallMethod(\*,"for scalar and linear g.m.b.i.",[IsMultiplicativeElement,IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep],COM_FUN(17));
InstallMethod(AdditiveInverseOp,"for linear g.m.b.i.",[IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep],COM_FUN(18));
InstallMethod(CompositionMapping2,"for left module hom. and linear g.m.b.i.",FamSource1EqFamRange2,[IsLeftModuleHomomorphism,IsLeftModuleGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep],COM_FUN(19));
InstallOtherMethod(\+,"for linear g.m.b.i. and general mapping",IsIdenticalObj,[IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep,IsGeneralMapping],COM_FUN(20));
InstallOtherMethod(\+,"for general mapping and linear g.m.b.i.",IsIdenticalObj,[IsGeneralMapping,IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep],COM_FUN(21));
InstallOtherMethod(\+,"for linear m.b.i. and mapping",IsIdenticalObj,[IsMapping and IsLinearGeneralMappingByImagesDefaultRep,IsMapping],COM_FUN(22));
InstallOtherMethod(\+,"for mapping and linear m.b.i.",IsIdenticalObj,[IsMapping,IsMapping and IsLinearGeneralMappingByImagesDefaultRep],COM_FUN(23));
DeclareRepresentation("IsLinearMappingByMatrixDefaultRep",IsAttributeStoringRep,["basissource","basisrange","matrix","basisimage","preimagesbasisimage","relations"]);
InstallTrueMethod(IsAdditiveElementWithInverse,IsGeneralMapping and IsLinearMappingByMatrixDefaultRep);
InstallTrueMethod(IsLeftModuleGeneralMapping,IsGeneralMapping and IsLinearMappingByMatrixDefaultRep);
InstallMethod(LeftModuleHomomorphismByMatrix,"for two bases of free left modules and a matrix",[IsBasis,IsMatrix,IsBasis],COM_FUN(24));
BindGlobal("MakePreImagesInfoLinearMappingByMatrix",COM_FUN(25));
InstallMethod(KernelOfAdditiveGeneralMapping,"for left module m.b.m.",[IsGeneralMapping and IsLinearMappingByMatrixDefaultRep],COM_FUN(26));
InstallMethod(IsInjective,"for left module m.b.m.",[IsGeneralMapping and IsLinearMappingByMatrixDefaultRep],COM_FUN(27));
InstallMethod(ImagesRepresentative,"for left module m.b.m., and element",FamSourceEqFamElm,[IsGeneralMapping and IsLinearMappingByMatrixDefaultRep,IsObject],COM_FUN(28));
InstallMethod(PreImagesRepresentative,"for left module m.b.m., and element",FamRangeEqFamElm,[IsGeneralMapping and IsLinearMappingByMatrixDefaultRep,IsObject],COM_FUN(29));
InstallMethod(ViewObj,"for a left module m.b.m.",[IsGeneralMapping and IsLinearMappingByMatrixDefaultRep],COM_FUN(30));
InstallMethod(PrintObj,"for a left module m.b.m.",[IsGeneralMapping and IsLinearMappingByMatrixDefaultRep],COM_FUN(31));
InstallMethod(NaturalHomomorphismBySubspace,"for left module and trivial left module",IsIdenticalObj,[IsFreeLeftModule,IsFreeLeftModule and IsTrivial],SUM_FLAGS,COM_FUN(32));
InstallGlobalFunction(NaturalHomomorphismBySubspaceOntoFullRowSpace,COM_FUN(33));
InstallMethod(NaturalHomomorphismBySubspace,"for two finite dimensional free left modules",IsIdenticalObj,[IsFreeLeftModule,IsFreeLeftModule],NaturalHomomorphismBySubspaceOntoFullRowSpace);
InstallMethod(\*,"for scalar and linear m.b.m.",[IsMultiplicativeElement,IsGeneralMapping and IsLinearMappingByMatrixDefaultRep],COM_FUN(34));
InstallMethod(AdditiveInverseOp,"for linear m.b.m.",[IsGeneralMapping and IsLinearMappingByMatrixDefaultRep],COM_FUN(35));
InstallMethod(CompositionMapping2,"for left module hom. and linear m.b.m.",FamSource1EqFamRange2,[IsLeftModuleHomomorphism,IsLeftModuleHomomorphism and IsLinearMappingByMatrixDefaultRep],COM_FUN(36));
BindGlobal("SumOfMBMAndMapping",COM_FUN(37));
BindGlobal("SumOfMappingAndMBM",COM_FUN(38));
InstallOtherMethod(\+,"for linear m.b.m. and mapping",IsIdenticalObj,[IsMapping and IsLinearMappingByMatrixDefaultRep,IsMapping],SumOfMBMAndMapping);
InstallOtherMethod(\+,"for mapping and linear m.b.m.",IsIdenticalObj,[IsMapping,IsMapping and IsLinearMappingByMatrixDefaultRep],SumOfMappingAndMBM);
InstallMethod(\+,"for linear m.b.m. and linear m.b.i.",IsIdenticalObj,[IsMapping and IsLinearMappingByMatrixDefaultRep,IsMapping and IsLinearGeneralMappingByImagesDefaultRep],SumOfMBMAndMapping);
InstallMethod(\+,"for linear m.b.i. and linear m.b.m.",IsIdenticalObj,[IsMapping and IsLinearGeneralMappingByImagesDefaultRep,IsMapping and IsLinearMappingByMatrixDefaultRep],SumOfMappingAndMBM);
InstallHandlingByNiceBasis("IsLinearMappingsModule",rec(detect:=COM_FUN(39),NiceFreeLeftModuleInfo:=COM_FUN(40),NiceVector:=COM_FUN(41),UglyVector:=COM_FUN(42)));
InstallOtherMethod(RingByGenerators,"for a list of linear mappings of finite vector spaces",[IsGeneralMappingCollection],COM_FUN(43));
InstallOtherMethod(DefaultRingByGenerators,"for a list of linear mappings of vector spaces",[IsGeneralMappingCollection],COM_FUN(44));
InstallOtherMethod(RingWithOneByGenerators,"for a list of linear mappings of finite vector spaces",[IsGeneralMappingCollection],COM_FUN(45));
InstallMethod(IsFullHomModule,"for space of linear mappings",[IsFreeLeftModule and IsGeneralMappingCollection],COM_FUN(46));
InstallMethod(Dimension,"for full hom space of linear mappings",[IsFreeLeftModule and IsGeneralMappingCollection and IsFullHomModule],COM_FUN(47));
InstallMethod(Random,"for full hom space of linear mappings",[IsFreeLeftModule and IsGeneralMappingCollection and IsFullHomModule],COM_FUN(48));
InstallMethod(Representative,"for full hom space of linear mappings",[IsFreeLeftModule and IsGeneralMappingCollection and IsFullHomModule],COM_FUN(49));
BindGlobal("StandardGeneratorsOfFullHomModule",COM_FUN(50));
InstallMethod(GeneratorsOfLeftModule,"for full hom space of linear mappings",[IsFreeLeftModule and IsGeneralMappingCollection and IsFullHomModule],StandardGeneratorsOfFullHomModule);
InstallMethod(NiceFreeLeftModule,"for full hom space of linear mappings",[IsFreeLeftModule and IsGeneralMappingCollection and IsFullHomModule],COM_FUN(51));
BindGlobal("ViewFullHomModule",COM_FUN(52));
InstallMethod(ViewObj,"for full hom space of linear mappings",[IsFreeLeftModule and IsGeneralMappingCollection and IsFullHomModule],SUM_FLAGS,ViewFullHomModule);
InstallMethod(PrintObj,"for full hom space of linear mappings",[IsFreeLeftModule and IsGeneralMappingCollection and IsFullHomModule],SUM_FLAGS,ViewFullHomModule);
InstallMethod(\in,"for full hom space of linear mappings",IsElmsColls,[IsGeneralMapping,IsFreeLeftModule and IsGeneralMappingCollection and IsFullHomModule],COM_FUN(53));
InstallMethod(IsPseudoCanonicalBasisFullHomModule,"for a basis of a full hom module",[IsBasis],COM_FUN(54));
InstallMethod(BasisVectors,"for pseudo canonical basis of a full hom module",[IsBasis and IsPseudoCanonicalBasisFullHomModule],COM_FUN(55));
InstallOtherMethod(Coefficients,"for pseudo canon. basis of a full hom module, and lin. mapping",IsCollsElms,[IsBasis and IsPseudoCanonicalBasisFullHomModule,IsGeneralMapping],COM_FUN(56));
InstallMethod(Coefficients,"for pseudo can. basis of full hom module, and lin. m.b.m.",IsCollsElms,[IsBasis and IsPseudoCanonicalBasisFullHomModule,IsMapping and IsLinearMappingByMatrixDefaultRep],COM_FUN(57));
InstallMethod(Basis,"for full hom space of linear mappings",[IsFreeLeftModule and IsFullHomModule],100,COM_FUN(58));
InstallMethod(Hom,"for division ring and two free left modules",[IsDivisionRing,IsFreeLeftModule,IsFreeLeftModule],COM_FUN(59));
InstallMethod(End,"for division ring and space of linear mappings",[IsDivisionRing,IsFreeLeftModule],COM_FUN(60));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/vspchom.gi"

#F  file="lib/zlattice.gi" crc=-96933444
RANK_FILTER_LIST  := [ 65077940, 12, 65077940, 12, 58412696, 30, 52247917, 19 
 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/zlattice.gi", -96933444 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/zlattice.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/zlattice.gi");
elif COM_RESULT = 3  then
Revision.zlattice_gi:="@(#)$Id: zlattice.gi,v 4.16 2002/04/15 10:05:30 sal Exp $";
InstallMethod(ScalarProduct,"method for two row vectors",IsIdenticalObj,[IsRowVector,IsRowVector],0,COM_FUN(1));
InstallGlobalFunction(StandardScalarProduct,COM_FUN(2));
InstallMethod(InverseMatMod,"method for a matrix, and an integer",true,[IsMatrix,IsPosInt],0,COM_FUN(3));
InstallGlobalFunction(PadicCoefficients,COM_FUN(4));
InstallGlobalFunction(LinearIndependentColumns,COM_FUN(5));
InstallGlobalFunction(DecompositionInt,COM_FUN(6));
InstallGlobalFunction(IntegralizedMat,COM_FUN(7));
InstallGlobalFunction(Decomposition,COM_FUN(8));
InstallGlobalFunction(LLLReducedBasis,COM_FUN(9));
InstallGlobalFunction(LLLReducedGramMat,COM_FUN(10));
InstallGlobalFunction(ShortestVectors,COM_FUN(11));
InstallGlobalFunction(OrthogonalEmbeddings,COM_FUN(12));
InstallGlobalFunction(LLLint,COM_FUN(13));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/zlattice.gi"

#F  file="lib/mgmring.gi" crc=-65269158
RANK_FILTER_LIST  := [ 28754976, 5, 8193, 2, 1985, 1, 64918210, 8, 32769, 4, 
  32769, 4, 13623789, 13, 13623789, 13, 33553623, 11, 33553623, 11, 33553623, 
  11, 33553623, 11, 33553623, 11, 33553623, 11, 33553623, 11, 33553623, 11, 
  33553623, 11, 33553623, 11, 33553623, 11, 64918210, 8, 33553623, 11, 33, 
  17, 64918210, 8, 33553623, 11, 33, 17, 33553623, 11, 33553623, 11, 
  32505602, 3, 33553623, 11, 33553623, 11, 32505602, 3, 32505602, 3, 
  33553623, 11, 33553623, 11, 32505602, 3, 33553623, 11, 32505602, 3, 
  32505602, 3, 33553623, 11, 33553623, 11, 64918210, 8, 33553623, 11, 17, 18, 
  33553623, 11, 33553623, 11, 8585363, 36, 8585363, 36, 8585363, 36, 
  27249212, 12, 52042571, 12, 8585363, 36, 8585363, 36, 8585363, 36, 8585363, 
  36, 17978545, 39, 8585363, 36, 8585363, 36, 51512173, 38, 33553623, 11, 
  4292682, 35, 8585363, 36, 8585363, 36, 8585363, 36, 8585363, 36, 2293337, 
  39, 10477489, 26, 8585363, 36, 54499383, 25, 64918210, 8, 54499383, 25, 
  64918210, 8, 54499383, 25, 52042571, 12, 54499383, 25, 52042571, 12, 
  63962867, 11, 8585363, 36, 41889886, 19, 32505602, 3, 41889886, 19, 
  32505602, 3, 41889886, 19, 52042571, 12, 41889886, 19, 52042571, 12, 
  33553623, 11, 67108490, 4, 8193, 2, 54707416, 27, 54707416, 27, 1, 0, 
  54707416, 27, 1, 0, 12592137, 5, 8193, 2, 6296069, 36, 6296069, 36, 
  6296069, 36, 6296069, 36, 67108205, 16 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/mgmring.gi", -65269158 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/mgmring.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/mgmring.gi");
elif COM_RESULT = 3  then
Revision.mgmring_gi:="@(#)$Id: mgmring.gi,v 4.58.2.1 2005/02/21 09:47:50 gap Exp $";
DeclareRepresentation("IsMagmaRingObjDefaultRep",IsPositionalObjectRep,[1,2]);
InstallMethod(NormalizedElementOfMagmaRingModuloRelations,"for a family of elements in a *free* magma ring, and a list",[IsElementOfFreeMagmaRingFamily,IsList],COM_FUN(1));
BindGlobal("FMRRemoveZero",COM_FUN(2));
InstallMethod(ElementOfMagmaRing,"for family, ring element, and two homogeneous lists",[IsFamily,IsRingElement,IsHomogeneousList,IsHomogeneousList],COM_FUN(3));
InstallMethod(ZeroCoefficient,"for magma ring element in default repr.",[IsElementOfMagmaRingModuloRelations and IsMagmaRingObjDefaultRep],COM_FUN(4));
InstallMethod(CoefficientsAndMagmaElements,"for magma ring element in default repr.",[IsElementOfMagmaRingModuloRelations and IsMagmaRingObjDefaultRep],COM_FUN(5));
InstallMethod(PrintObj,"for magma ring element",[IsElementOfMagmaRingModuloRelations],COM_FUN(6));
InstallMethod(\=,"for two free magma ring elements",IsIdenticalObj,[IsElementOfMagmaRingModuloRelations,IsElementOfMagmaRingModuloRelations],COM_FUN(7));
InstallMethod(\<,"for two free magma ring elements",IsIdenticalObj,[IsElementOfMagmaRingModuloRelations,IsElementOfMagmaRingModuloRelations],COM_FUN(8));
InstallMethod(\+,"for two magma ring elements",IsIdenticalObj,[IsElementOfMagmaRingModuloRelations,IsElementOfMagmaRingModuloRelations],COM_FUN(9));
InstallMethod(AdditiveInverseOp,"for magma ring element",[IsElementOfMagmaRingModuloRelations],COM_FUN(10));
InstallMethod(\*,"for two magma ring elements",IsIdenticalObj,[IsElementOfMagmaRingModuloRelations,IsElementOfMagmaRingModuloRelations],COM_FUN(11));
ElmTimesRingElm:=COM_FUN(12);
InstallMethod(\*,"for magma ring element, and ring element",IsMagmaRingsRings,[IsElementOfMagmaRingModuloRelations,IsRingElement],ElmTimesRingElm);
InstallMethod(\*,"for magma ring element, and rational",[IsElementOfMagmaRingModuloRelations,IsRat],ElmTimesRingElm);
RingElmTimesElm:=COM_FUN(13);
InstallMethod(\*,"for ring element, and magma ring element",IsRingsMagmaRings,[IsRingElement,IsElementOfMagmaRingModuloRelations],RingElmTimesElm);
InstallMethod(\*,"for rational, and magma ring element",[IsRat,IsElementOfMagmaRingModuloRelations],RingElmTimesElm);
InstallOtherMethod(InverseOp,"for magma ring element",[IsElementOfMagmaRingModuloRelations],COM_FUN(14));
InstallMethod(\*,"for magma element and magma ring element",IsMagmasMagmaRings,[IsMultiplicativeElement,IsElementOfMagmaRingModuloRelations],COM_FUN(15));
InstallMethod(\*,"for magma ring element and magma element",IsMagmaRingsMagmas,[IsElementOfMagmaRingModuloRelations,IsMultiplicativeElement],COM_FUN(16));
InstallOtherMethod(\+,"for magma element and magma ring element",IsMagmasMagmaRings,[IsMultiplicativeElement,IsElementOfMagmaRingModuloRelations],COM_FUN(17));
InstallOtherMethod(\+,"for magma ring element and magma element",IsMagmaRingsMagmas,[IsElementOfMagmaRingModuloRelations,IsMultiplicativeElement],COM_FUN(18));
InstallOtherMethod(\-,"for magma ring element and magma element",IsMagmaRingsMagmas,[IsElementOfMagmaRingModuloRelations,IsMultiplicativeElement],COM_FUN(19));
InstallOtherMethod(\-,"for magma ring element and magma element",IsMagmasMagmaRings,[IsMultiplicativeElement,IsElementOfMagmaRingModuloRelations],COM_FUN(20));
ElmDivRingElm:=COM_FUN(21);
InstallOtherMethod(\/,"for magma ring element, and ring element",IsMagmaRingsRings,[IsElementOfMagmaRingModuloRelations,IsRingElement],ElmDivRingElm);
InstallMethod(\/,"for magma ring element, and integer",[IsElementOfMagmaRingModuloRelations,IsInt],ElmDivRingElm);
InstallMethod(OneOp,"for magma ring element",[IsElementOfMagmaRingModuloRelations],COM_FUN(22));
InstallMethod(ZeroOp,"for magma ring element",[IsElementOfMagmaRingModuloRelations],COM_FUN(23));
InstallMethod(IsGroupRing,"for free magma ring",[IsFreeMagmaRing],COM_FUN(24));
InstallMethod(PrintObj,"for a free magma ring",[IsFreeMagmaRing],COM_FUN(25));
InstallGlobalFunction(FreeMagmaRing,COM_FUN(26));
InstallGlobalFunction(GroupRing,COM_FUN(27));
InstallMethod(AugmentationIdeal,"for a free magma ring",[IsFreeMagmaRing],COM_FUN(28));
DeclareRepresentation("IsCanonicalBasisFreeMagmaRingRep",IsCanonicalBasis and IsAttributeStoringRep,["zerovector"]);
InstallMethod(Coefficients,"for canon. basis of a free magma ring, and a vector",IsCollsElms,[IsCanonicalBasisFreeMagmaRingRep,IsElementOfFreeMagmaRing],COM_FUN(29));
InstallMethod(Basis,"for a free magma ring (delegate to `CanonicalBasis')",[IsFreeMagmaRing],CANONICAL_BASIS_FLAGS,CanonicalBasis);
InstallMethod(CanonicalBasis,"for a free magma ring",[IsFreeMagmaRing],COM_FUN(30));
InstallMethod(IsFinite,"for a free magma ring",[IsFreeMagmaRing],COM_FUN(31));
InstallMethod(IsFiniteDimensional,"for a free magma ring",[IsFreeMagmaRing],COM_FUN(32));
InstallMethod(IsFiniteDimensional,"for a left module of free magma ring elements",[IsFreeLeftModule and IsElementOfFreeMagmaRingCollection and HasGeneratorsOfLeftOperatorRing],COM_FUN(33));
InstallMethod(Dimension,"for a free magma ring",[IsFreeMagmaRing],COM_FUN(34));
InstallMethod(GeneratorsOfLeftModule,"for a free magma ring",[IsFreeMagmaRing],COM_FUN(35));
InstallMethod(Centre,"for a group ring",[IsGroupRing],COM_FUN(36));
InstallMethod(\in,"for ring element, and magma ring",IsElmsColls,[IsElementOfMagmaRingModuloRelations,IsMagmaRingModuloRelations],COM_FUN(37));
InstallMethod(IsAssociative,"for a free magma ring",[IsFreeMagmaRing],COM_FUN(38));
InstallMethod(IsCommutative,"for a free magma ring",[IsFreeMagmaRing],COM_FUN(39));
InstallMethod(IsWholeFamily,"for a free magma ring",[IsFreeMagmaRing],COM_FUN(40));
InstallMethod(GeneratorsOfRing,"for a free magma ring",[IsFreeMagmaRing],COM_FUN(41));
InstallMethod(GeneratorsOfRingWithOne,"for a free magma ring-with-one",[IsFreeMagmaRingWithOne],COM_FUN(42));
DeclareRepresentation("IsEmbeddingRingMagmaRing",IsSPGeneralMapping and IsMapping and IsInjective and RespectsAddition and RespectsZero and RespectsMultiplication and RespectsOne and IsAttributeStoringRep,[]);
InstallMethod(Embedding,"for ring and magma ring",IsRingCollsMagmaRingColls,[IsRing,IsFreeMagmaRing],COM_FUN(43));
InstallMethod(ImagesElm,"for embedding of ring into magma ring, and ring element",FamSourceEqFamElm,[IsEmbeddingRingMagmaRing,IsRingElement],COM_FUN(44));
InstallMethod(ImagesRepresentative,"for embedding of ring into magma ring, and ring element",FamSourceEqFamElm,[IsEmbeddingRingMagmaRing,IsRingElement],COM_FUN(45));
InstallMethod(PreImagesElm,"for embedding of ring into magma ring, and free magma ring element",FamRangeEqFamElm,[IsEmbeddingRingMagmaRing,IsElementOfFreeMagmaRing],COM_FUN(46));
InstallMethod(PreImagesRepresentative,"for embedding of ring into magma ring, and free magma ring element",FamRangeEqFamElm,[IsEmbeddingRingMagmaRing,IsElementOfFreeMagmaRing],COM_FUN(47));
DeclareRepresentation("IsEmbeddingMagmaMagmaRing",IsSPGeneralMapping and IsMapping and IsInjective and RespectsMultiplication and IsAttributeStoringRep,[]);
InstallMethod(Embedding,"for magma and magma ring",IsMagmaCollsMagmaRingColls,[IsMagma,IsFreeMagmaRing],COM_FUN(48));
InstallMethod(ImagesElm,"for embedding of magma into magma ring, and mult. element",FamSourceEqFamElm,[IsEmbeddingMagmaMagmaRing,IsMultiplicativeElement],COM_FUN(49));
InstallMethod(ImagesRepresentative,"for embedding of magma into magma ring, and mult. element",FamSourceEqFamElm,[IsEmbeddingMagmaMagmaRing,IsMultiplicativeElement],COM_FUN(50));
InstallMethod(PreImagesElm,"for embedding of magma into magma ring, and free magma ring element",FamRangeEqFamElm,[IsEmbeddingMagmaMagmaRing,IsElementOfFreeMagmaRing],COM_FUN(51));
InstallMethod(PreImagesRepresentative,"for embedding of magma into magma ring, and free magma ring element",FamRangeEqFamElm,[IsEmbeddingMagmaMagmaRing,IsElementOfFreeMagmaRing],COM_FUN(52));
InstallMethod(ExtRepOfObj,"for magma ring element",[IsElementOfMagmaRingModuloRelations],COM_FUN(53));
InstallMethod(ObjByExtRep,"for magma ring elements family, and list",[IsElementOfMagmaRingModuloRelationsFamily,IsList],COM_FUN(54));
InstallHandlingByNiceBasis("IsSpaceOfElementsOfMagmaRing",rec(detect:=COM_FUN(55),NiceFreeLeftModuleInfo:=COM_FUN(56),NiceVector:=COM_FUN(57),UglyVector:=COM_FUN(58)));
InstallGlobalFunction(MagmaRingModuloSpanOfZero,COM_FUN(59));
InstallMethod(NormalizedElementOfMagmaRingModuloRelations,"for family of magma rings modulo the span of ``zero'', and list",[IsElementOfMagmaRingModuloSpanOfZeroFamily,IsList],COM_FUN(60));
InstallMethod(IsFinite,"for a magma ring modulo the span of ``zero''",[IsMagmaRingModuloSpanOfZero],COM_FUN(61));
InstallMethod(IsFiniteDimensional,"for a magma ring modulo the span of ``zero''",[IsMagmaRingModuloSpanOfZero],COM_FUN(62));
InstallMethod(Dimension,"for a magma ring modulo the span of ``zero''",[IsMagmaRingModuloSpanOfZero],COM_FUN(63));
InstallMethod(GeneratorsOfLeftModule,"for a magma ring modulo the span of ``zero''",[IsMagmaRingModuloSpanOfZero],COM_FUN(64));
InstallMethod(IsGeneratorsOfMagmaWithInverses,"for a collection of free magma ring elements",[IsElementOfMagmaRingModuloRelationsCollection],COM_FUN(65));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/mgmring.gi"

#F  file="lib/algebra.gi" crc=-81511694
RANK_FILTER_LIST  := [ 52842125, 30, 28161257, 33, 10477489, 26, 8126465, 2, 
  10477489, 26, 32769, 4, 64918210, 8, 10477489, 26, 8126465, 2, 10477489, 
  26, 32769, 4, 64918210, 8, 11576548, 36, 9464172, 36, 33646191, 34, 
  33646191, 34, 33646191, 34, 45364303, 36, 39073237, 39, 33646191, 34, 
  33646191, 34, 33646191, 34, 33646191, 34, 27354165, 37, 27354165, 37, 
  33646191, 34, 8126465, 2, 33646191, 34, 41951068, 17, 33646191, 34, 
  33646191, 34, 33646191, 34, 10477489, 26, 8126465, 2, 4417712, 46, 
  29523144, 23, 4417712, 46, 33646191, 34, 10477489, 26, 8126465, 2, 4417712, 
  46, 29523144, 23, 4417712, 46, 33646191, 34, 4417712, 46, 27354165, 37, 
  33646191, 34, 64918210, 8, 42853324, 35, 64918210, 8, 27354165, 37, 
  64918210, 8, 36561298, 38, 64918210, 8, 33632272, 36, 64918210, 8, 4123048, 
  29, 4123048, 29, 64939901, 32, 64939901, 32, 4109129, 31, 8126465, 2, 
  4123048, 29, 8126465, 2, 33646191, 34, 33646191, 34, 27354165, 37, 
  27354165, 37, 33646191, 34, 8480592, 35, 15256389, 35, 33646191, 34, 
  15256389, 35, 27354165, 37, 2188566, 38, 57684400, 38, 27354165, 37, 
  8964363, 38, 11576548, 36, 53518868, 37, 60295625, 37, 11576548, 36, 
  60295625, 37, 5284522, 39, 47226842, 40, 35614757, 40, 5284522, 39, 
  54003599, 40, 20239680, 42, 62182000, 43, 1849878, 43, 11576548, 36, 
  11576548, 36, 11576548, 36, 5284522, 39, 11576548, 36, 11576548, 36, 
  11576548, 36, 5284522, 39, 11576548, 36, 38358164, 26, 23294660, 38, 
  26664802, 37, 11576548, 36, 23269910, 25, 23294660, 38, 11576548, 36, 
  11576548, 36, 1, 0, 33646191, 34, 29523144, 23, 29523144, 23, 11576548, 36, 
  11576548, 36, 13240177, 43, 13240177, 43, 11576548, 36, 33646191, 34, 
  27354165, 37, 33646191, 34, 33646191, 34, 45364303, 36, 39073237, 39, 
  20239680, 42, 11576548, 36, 11576548, 36, 64918210, 8, 27354165, 37, 
  50423872, 35, 44131846, 38, 11576548, 36, 11576548, 36, 16385, 3, 33646191, 
  34, 33646191, 34, 45364303, 36, 45364303, 36, 39073237, 39, 39073237, 39, 
  53011759, 36, 52247917, 19, 38808379, 39, 52247917, 19, 11576548, 36, 
  11576548, 36, 11576548, 36, 23294660, 38 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/algebra.gi", -81511694 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/algebra.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/algebra.gi");
elif COM_RESULT = 3  then
Revision.algebra_gi:="@(#)$Id: algebra.gi,v 4.80 2003/10/19 09:54:43 gap Exp $";
InstallMethod(Representative,"for left operator ring with known generators",[IsLeftOperatorRing and HasGeneratorsOfLeftOperatorRing],RepresentativeFromGenerators(GeneratorsOfLeftOperatorRing));
InstallMethod(Representative,"for left operator ring-with-one with known generators",[IsLeftOperatorRingWithOne and HasGeneratorsOfLeftOperatorRingWithOne],RepresentativeFromGenerators(GeneratorsOfLeftOperatorRingWithOne));
InstallMethod(FLMLORByGenerators,"for ring and collection",[IsRing,IsCollection],COM_FUN(1));
InstallOtherMethod(FLMLORByGenerators,"for ring, homogeneous list, and ring element",[IsRing,IsHomogeneousList,IsRingElement],COM_FUN(2));
InstallMethod(FLMLORWithOneByGenerators,"for ring and collection",[IsRing,IsCollection],COM_FUN(3));
InstallOtherMethod(FLMLORWithOneByGenerators,"for ring, homogeneous list, and ring element",[IsRing,IsHomogeneousList,IsRingElement],COM_FUN(4));
InstallGlobalFunction(FLMLOR,COM_FUN(5));
InstallGlobalFunction(SubFLMLOR,COM_FUN(6));
InstallGlobalFunction(SubFLMLORNC,COM_FUN(7));
InstallGlobalFunction(FLMLORWithOne,COM_FUN(8));
InstallGlobalFunction(SubFLMLORWithOne,COM_FUN(9));
InstallGlobalFunction(SubFLMLORWithOneNC,COM_FUN(10));
InstallMethod(LieAlgebraByDomain,"for an algebra",[IsAlgebra],COM_FUN(11));
InstallGlobalFunction(LieAlgebra,COM_FUN(12));
InstallGlobalFunction(EmptySCTable,COM_FUN(13));
InstallGlobalFunction(SetEntrySCTable,COM_FUN(14));
InstallGlobalFunction(ReducedSCTable,COM_FUN(15));
InstallGlobalFunction(GapInputSCTable,COM_FUN(16));
InstallGlobalFunction(IdentityFromSCTable,COM_FUN(17));
InstallGlobalFunction(QuotientFromSCTable,COM_FUN(18));
InstallGlobalFunction(TestJacobi,COM_FUN(19));
InstallMethod(MultiplicativeNeutralElement,[IsFLMLOR and IsFiniteDimensional],COM_FUN(20));
InstallMethod(IsAssociative,"generic method for a (finite dimensional) FLMLOR",[IsFLMLOR],COM_FUN(21));
InstallMethod(IsAnticommutative,"generic method for a (finite dimensional) FLMLOR",[IsFLMLOR],COM_FUN(22));
InstallMethod(IsCommutative,"generic method for a finite dimensional FLMLOR",[IsFLMLOR],IsCommutativeFromGenerators(GeneratorsOfVectorSpace));
InstallMethod(IsCommutative,"for an associative FLMLOR",[IsFLMLOR and IsAssociative],IsCommutativeFromGenerators(GeneratorsOfAlgebra));
InstallMethod(IsCommutative,"for an associative FLMLOR-with-one",[IsFLMLORWithOne and IsAssociative],IsCommutativeFromGenerators(GeneratorsOfAlgebraWithOne));
InstallMethod(IsZeroSquaredRing,"for a finite dimensional FLMLOR",[IsFLMLOR],COM_FUN(23));
InstallMethod(IsJacobianRing,"for a (finite dimensional) FLMLOR",[IsFLMLOR],COM_FUN(24));
InstallMethod(Intersection2,"generic method for two FLMLORs",IsIdenticalObj,[IsFLMLOR,IsFLMLOR],Intersection2Spaces(AsFLMLOR,SubFLMLORNC,FLMLOR));
InstallMethod(Intersection2,"generic method for two FLMLORs-with-one",IsIdenticalObj,[IsFLMLORWithOne,IsFLMLORWithOne],Intersection2Spaces(AsFLMLORWithOne,SubFLMLORWithOneNC,FLMLORWithOne));
InstallOtherMethod(\/,"for FLMLOR and collection",IsIdenticalObj,[IsFLMLOR,IsCollection],COM_FUN(25));
InstallOtherMethod(\/,"for FLMLOR and empty list",[IsFLMLOR,IsList and IsEmpty],COM_FUN(26));
InstallOtherMethod(\/,"generic method for two FLMLORs",IsIdenticalObj,[IsFLMLOR,IsFLMLOR],COM_FUN(27));
InstallMethod(TrivialSubadditiveMagmaWithZero,"for a FLMLOR",[IsFLMLOR],COM_FUN(28));
InstallMethod(AsFLMLOR,"for a ring and a collection",[IsRing,IsCollection],COM_FUN(29));
InstallMethod(AsFLMLOR,"for a division ring and a free left module",[IsDivisionRing,IsFreeLeftModule],COM_FUN(30));
InstallMethod(AsFLMLOR,"for a division ring and an algebra",[IsDivisionRing,IsFLMLOR],COM_FUN(31));
InstallMethod(AsFLMLORWithOne,"for a ring and a collection",[IsRing,IsCollection],COM_FUN(32));
InstallMethod(AsFLMLORWithOne,"for a division ring and a free left module",[IsDivisionRing,IsFreeLeftModule],COM_FUN(33));
InstallMethod(AsFLMLORWithOne,"for a division ring and an algebra",[IsDivisionRing,IsFLMLOR],COM_FUN(34));
InstallMethod(AsFLMLORWithOne,"for a division ring and a algebra-with-one",[IsDivisionRing,IsFLMLORWithOne],COM_FUN(35));
InstallMethod(ClosureLeftOperatorRing,"for a FLMLOR and a ring element",IsCollsElms,[IsFLMLOR,IsRingElement],COM_FUN(36));
InstallMethod(ClosureLeftOperatorRing,"for an FLMLOR with basis, and a ring element",IsCollsElms,[IsFLMLOR and HasBasis,IsRingElement],COM_FUN(37));
InstallMethod(ClosureLeftOperatorRing,"for a FLMLOR-with-one and a ring element",IsCollsElms,[IsFLMLORWithOne,IsRingElement],COM_FUN(38));
InstallMethod(ClosureLeftOperatorRing,"for a FLMLOR-with-one with basis, and a ring element",IsCollsElms,[IsFLMLORWithOne and HasBasis,IsRingElement],COM_FUN(39));
InstallMethod(ClosureLeftOperatorRing,"for a FLMLOR containing the whole family, and a ring element",IsCollsElms,[IsFLMLOR and IsWholeFamily,IsRingElement],SUM_FLAGS,COM_FUN(40));
InstallMethod(ClosureLeftOperatorRing,"for two left operator rings",IsIdenticalObj,[IsLeftOperatorRing,IsLeftOperatorRing],COM_FUN(41));
InstallMethod(ClosureLeftOperatorRing,"for two left operator rings-with-one",IsIdenticalObj,[IsLeftOperatorRingWithOne,IsLeftOperatorRingWithOne],COM_FUN(42));
InstallMethod(ClosureLeftOperatorRing,"for a left op. ring cont. the whole family, and a collection",IsIdenticalObj,[IsLeftOperatorRing and IsWholeFamily,IsCollection],SUM_FLAGS,COM_FUN(43));
InstallMethod(ClosureLeftOperatorRing,"for left operator ring and list of elements",IsIdenticalObj,[IsLeftOperatorRing,IsCollection],COM_FUN(44));
InstallGlobalFunction(MutableBasisOfClosureUnderAction,COM_FUN(45));
InstallGlobalFunction(MutableBasisOfNonassociativeAlgebra,COM_FUN(46));
InstallGlobalFunction(MutableBasisOfIdealInNonassociativeAlgebra,COM_FUN(47));
InstallMethod(IsSubset,"for two FLMLORs",IsIdenticalObj,[IsFLMLOR,IsFLMLOR],COM_FUN(48));
InstallMethod(IsSubset,"for two FLMLORs-with-one",IsIdenticalObj,[IsFLMLORWithOne,IsFLMLORWithOne],COM_FUN(49));
InstallMethod(ViewObj,"for a FLMLOR",[IsFLMLOR],COM_FUN(50));
InstallMethod(ViewObj,"for a FLMLOR with known dimension",[IsFLMLOR and HasDimension],1,COM_FUN(51));
InstallMethod(ViewObj,"for a FLMLOR with known generators",[IsFLMLOR and HasGeneratorsOfAlgebra],COM_FUN(52));
InstallMethod(PrintObj,"for a FLMLOR",[IsFLMLOR],COM_FUN(53));
InstallMethod(PrintObj,"for a FLMLOR with known generators",[IsFLMLOR and HasGeneratorsOfFLMLOR],COM_FUN(54));
InstallMethod(ViewObj,"for a FLMLOR-with-one",[IsFLMLORWithOne],COM_FUN(55));
InstallMethod(ViewObj,"for a FLMLOR-with-one with known dimension",[IsFLMLORWithOne and HasDimension],1,COM_FUN(56));
InstallMethod(ViewObj,"for a FLMLOR-with-one with known generators",[IsFLMLORWithOne and HasGeneratorsOfFLMLORWithOne],COM_FUN(57));
InstallMethod(PrintObj,"for a FLMLOR-with-one",[IsFLMLORWithOne],COM_FUN(58));
InstallMethod(PrintObj,"for a FLMLOR-with-one with known generators",[IsFLMLORWithOne and HasGeneratorsOfFLMLOR],COM_FUN(59));
InstallMethod(ViewObj,"for an algebra",[IsAlgebra],COM_FUN(60));
InstallMethod(ViewObj,"for an algebra with known dimension",[IsAlgebra and HasDimension],1,COM_FUN(61));
InstallMethod(ViewObj,"for an algebra with known generators",[IsAlgebra and HasGeneratorsOfAlgebra],COM_FUN(62));
InstallMethod(PrintObj,"for an algebra",[IsAlgebra],COM_FUN(63));
InstallMethod(PrintObj,"for an algebra with known generators",[IsAlgebra and HasGeneratorsOfAlgebra],COM_FUN(64));
InstallMethod(ViewObj,"for an algebra-with-one",[IsAlgebraWithOne],COM_FUN(65));
InstallMethod(ViewObj,"for an algebra-with-one with known dimension",[IsAlgebraWithOne and HasDimension],1,COM_FUN(66));
InstallMethod(ViewObj,"for an algebra-with-one with known generators",[IsAlgebraWithOne and HasGeneratorsOfAlgebraWithOne],COM_FUN(67));
InstallMethod(PrintObj,"for an algebra-with-one",[IsAlgebraWithOne],COM_FUN(68));
InstallMethod(PrintObj,"for an algebra-with-one with known generators",[IsAlgebraWithOne and HasGeneratorsOfAlgebra],COM_FUN(69));
InstallMethod(ViewObj,"for a Lie algebra",[IsLieAlgebra],COM_FUN(70));
InstallMethod(ViewObj,"for a Lie algebra with known dimension",[IsLieAlgebra and HasDimension],1,COM_FUN(71));
InstallMethod(ViewObj,"for a Lie algebra with known generators",[IsLieAlgebra and HasGeneratorsOfAlgebra],COM_FUN(72));
InstallMethod(AsSubalgebra,"for two algebras",IsIdenticalObj,[IsAlgebra,IsAlgebra],COM_FUN(73));
InstallMethod(AsSubalgebra,"for an algebra and an algebra-with-one",IsIdenticalObj,[IsAlgebra,IsAlgebraWithOne],COM_FUN(74));
InstallMethod(AsSubalgebraWithOne,"for two algebras",IsIdenticalObj,[IsAlgebra,IsAlgebra],COM_FUN(75));
InstallMethod(AsSubalgebraWithOne,"for an algebra and a algebra-with-one",IsIdenticalObj,[IsAlgebra,IsAlgebraWithOne],COM_FUN(76));
InstallGlobalFunction(CentralizerInFiniteDimensionalAlgebra,COM_FUN(77));
InstallMethod(CentralizerOp,"for a finite dimensional algebra and a vector space with parent",IsIdenticalObj,[IsAlgebra,IsVectorSpace and HasParent],COM_FUN(78));
InstallMethod(CentralizerOp,"for a fin. dim. assoc. algebra and an algebra with parent",IsIdenticalObj,[IsAlgebra and IsAssociative,IsAlgebra and HasParent],COM_FUN(79));
InstallMethod(CentralizerOp,"for a finite dimensional algebra and a vector space",IsIdenticalObj,[IsAlgebra,IsVectorSpace],COM_FUN(80));
InstallMethod(CentralizerOp,"for a fin. dim. assoc. algebra and an algebra",IsIdenticalObj,[IsAlgebra and IsAssociative,IsAlgebra],COM_FUN(81));
InstallMethod(CentralizerOp,"for an algebra and an element",IsCollsElms,[IsAlgebra,IsObject],COM_FUN(82));
BindGlobal("CentreFromSCTable",COM_FUN(83));
InstallMethod(Centre,"for a finite dimensional FLMLOR",[IsFLMLOR],COM_FUN(84));
BindGlobal("MutableBasisOfProductSpace",COM_FUN(85));
InstallMethod(ProductSpace,"for two free left modules",IsIdenticalObj,[IsFreeLeftModule,IsFreeLeftModule],COM_FUN(86));
InstallMethod(ProductSpace,"for two algebras",IsIdenticalObj,[IsAlgebra,IsAlgebra],COM_FUN(87));
InstallMethod(ProductSpace,"for two ideals with same parent",IsIdenticalObj,[IsAlgebra and HasParent and IsTwoSidedIdealInParent,IsAlgebra and HasParent and IsTwoSidedIdealInParent],COM_FUN(88));
InstallMethod(RadicalOfAlgebra,"for an associative algebra",[IsAlgebra],COM_FUN(89));
InstallMethod(IsTrivial,"for a FLMLOR",[IsFLMLOR],COM_FUN(90));
InstallMethod(IsTrivial,"for a FLMLOR-with-one",[IsFLMLORWithOne],COM_FUN(91));
InstallMethod(GeneratorsOfLeftModule,"for a FLMLOR",[IsFLMLOR],COM_FUN(92));
InstallMethod(Basis,"for a FLMLOR",[IsFLMLOR],COM_FUN(93));
InstallMethod(Basis,"for an associative FLMLOR",[IsFLMLOR and IsAssociative],COM_FUN(94));
InstallMethod(Basis,"for an associative FLMLOR-with-one",[IsFLMLORWithOne and IsAssociative],COM_FUN(95));
InstallMethod(Basis,"for a Lie algebra",[IsLieAlgebra],COM_FUN(96));
InstallOtherMethod(PowerSubalgebraSeries,"for an algebra",[IsAlgebra],COM_FUN(97));
InstallMethod(IsNilpotentElement,"for an algebra, and an element",IsCollsElms,[IsAlgebra,IsRingElement],COM_FUN(98));
InstallMethod(GeneratorsOfLeftOperatorRing,"for a FLMLOR-with-one",[IsFLMLORWithOne],COM_FUN(99));
InstallMethod(GeneratorsOfLeftOperatorRing,"for a FLMLOR with known left module generators",[IsFLMLOR and HasGeneratorsOfLeftModule],GeneratorsOfLeftModule);
InstallMethod(GeneratorsOfLeftOperatorRingWithOne,"for a FLMLOR-with-one with known left module generators",[IsFLMLORWithOne and HasGeneratorsOfLeftModule],GeneratorsOfLeftModule);
InstallOtherMethod(DirectSumOfAlgebras,"for two algebras",[IsAlgebra,IsAlgebra],COM_FUN(100));
InstallMethod(DirectSumOfAlgebras,"for list of algebras",[IsDenseList],COM_FUN(101));
InstallMethod(IsCentral,"for two FLMLORs",IsIdenticalObj,[IsFLMLOR,IsFLMLOR],IsCentralFromGenerators(GeneratorsOfLeftModule,GeneratorsOfLeftModule));
InstallMethod(IsCentral,"for two associative FLMLORs",IsIdenticalObj,[IsFLMLOR and IsAssociative,IsFLMLOR and IsAssociative],IsCentralFromGenerators(GeneratorsOfAlgebra,GeneratorsOfAlgebra));
InstallMethod(IsCentral,"for two associative FLMLORs-with-one",IsIdenticalObj,[IsFLMLORWithOne and IsAssociative,IsFLMLORWithOne and IsAssociative],IsCentralFromGenerators(GeneratorsOfAlgebraWithOne,GeneratorsOfAlgebraWithOne));
BindGlobal("FreeAlgebraConstructor",COM_FUN(102));
InstallGlobalFunction(FreeAlgebra,FreeAlgebraConstructor("FreeAlgebra",FreeMagma));
InstallGlobalFunction(FreeAlgebraWithOne,FreeAlgebraConstructor("FreeAlgebraWithOne",FreeMagmaWithOne));
InstallGlobalFunction(FreeAssociativeAlgebra,FreeAlgebraConstructor("FreeAssociativeAlgebra",FreeSemigroup));
InstallGlobalFunction(FreeAssociativeAlgebraWithOne,FreeAlgebraConstructor("FreeAssociativeAlgebraWithOne",FreeMonoid));
InstallAccessToGenerators(IsMagmaRingModuloRelations,"magma ring containing the whole family",GeneratorsOfAlgebra);
InstallAccessToGenerators(IsMagmaRingModuloRelations and IsRingWithOne,"magma ring-with-one containing the whole family",GeneratorsOfAlgebraWithOne);
InstallMethod(CentralIdempotentsOfAlgebra,"for an associative algebra",[IsAlgebra],COM_FUN(103));
InstallMethod(IsSimpleAlgebra,"for an associative algebra",[IsAlgebra],COM_FUN(104));
InstallMethod(LeviMalcevDecomposition,"for an associative or a Lie algebra",[IsAlgebra],COM_FUN(105));
InstallMethod(DirectSumDecomposition,"for semisimple associative algebras",[IsAlgebra and IsAssociative],COM_FUN(106));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/algebra.gi"

#F  file="lib/idealalg.gi" crc=-64690832
RANK_FILTER_LIST  := [ 33646191, 34, 29523144, 23, 45364303, 36, 29523144, 
  23, 39073237, 39, 29523144, 23, 45364303, 36, 33646191, 34, 33646191, 34, 
  29523144, 23, 45364303, 36, 29523144, 23, 39073237, 39, 29523144, 23, 
  45364303, 36, 33646191, 34, 54498755, 36, 29523144, 23, 43820740, 36, 
  29523144, 23, 33646191, 34, 29523144, 23, 33646191, 34, 8126465, 2, 
  33646191, 34, 8126465, 2, 33646191, 34, 8126465, 2, 33646191, 34, 41951068, 
  17, 33646191, 34, 41951068, 17, 33646191, 34, 41951068, 17, 15694507, 35, 
  49156236, 27, 64851702, 35, 49156236, 27, 28948334, 35, 15694507, 35, 
  49156236, 27, 64851702, 35, 49156236, 27, 28948334, 35, 33646191, 34, 
  33646191, 34, 10477489, 26, 10477489, 26, 10477489, 26, 10477489, 26, 
  24250477, 35, 14853803, 35 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/idealalg.gi", -64690832 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/idealalg.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/idealalg.gi");
elif COM_RESULT = 3  then
Revision.idealalg_gi:="@(#)$Id: idealalg.gi,v 4.7 2002/04/15 10:04:53 sal Exp $";
BindGlobal("IsLeftIdealFromGenerators",COM_FUN(1));
BindGlobal("IsRightIdealFromGenerators",COM_FUN(2));
InstallOtherMethod(IsLeftIdealOp,"for FLMLOR and free left module",IsIdenticalObj,[IsFLMLOR,IsFreeLeftModule],0,IsLeftIdealFromGenerators(AsFLMLOR,AsLeftModule,GeneratorsOfLeftModule,GeneratorsOfLeftModule));
InstallOtherMethod(IsLeftIdealOp,"for associative FLMLOR and free left module",IsIdenticalObj,[IsFLMLOR and IsAssociative,IsFreeLeftModule],0,IsLeftIdealFromGenerators(AsFLMLOR,AsLeftModule,GeneratorsOfLeftOperatorRing,GeneratorsOfLeftModule));
InstallOtherMethod(IsLeftIdealOp,"for associative FLMLOR-with-one and free left module",IsIdenticalObj,[IsFLMLORWithOne and IsAssociative,IsFreeLeftModule],0,IsLeftIdealFromGenerators(AsFLMLOR,AsLeftModule,GeneratorsOfLeftOperatorRingWithOne,GeneratorsOfLeftModule));
InstallMethod(IsLeftIdealOp,"for associative FLMLOR and FLMLOR",IsIdenticalObj,[IsFLMLOR and IsAssociative,IsFLMLOR],0,IsLeftIdealFromGenerators(AsFLMLOR,AsFLMLOR,GeneratorsOfLeftOperatorRing,GeneratorsOfLeftOperatorRing));
InstallOtherMethod(IsRightIdealOp,"for FLMLOR and free left module",IsIdenticalObj,[IsFLMLOR,IsFreeLeftModule],0,IsRightIdealFromGenerators(AsFLMLOR,AsLeftModule,GeneratorsOfLeftModule,GeneratorsOfLeftModule));
InstallOtherMethod(IsRightIdealOp,"for associative FLMLOR and free left module",IsIdenticalObj,[IsFLMLOR and IsAssociative,IsFreeLeftModule],0,IsRightIdealFromGenerators(AsFLMLOR,AsLeftModule,GeneratorsOfLeftOperatorRing,GeneratorsOfLeftModule));
InstallOtherMethod(IsRightIdealOp,"for associative FLMLOR-with-one and free left module",IsIdenticalObj,[IsFLMLORWithOne and IsAssociative,IsFreeLeftModule],0,IsRightIdealFromGenerators(AsFLMLOR,AsLeftModule,GeneratorsOfLeftOperatorRingWithOne,GeneratorsOfLeftModule));
InstallMethod(IsRightIdealOp,"for associative FLMLOR and FLMLOR",IsIdenticalObj,[IsFLMLOR and IsAssociative,IsFLMLOR],0,IsRightIdealFromGenerators(AsFLMLOR,AsFLMLOR,GeneratorsOfLeftOperatorRing,GeneratorsOfLeftOperatorRing));
InstallOtherMethod(IsTwoSidedIdealOp,"for commutative FLMLOR and free left module",IsIdenticalObj,[IsFLMLOR and IsCommutative,IsFreeLeftModule],0,IsLeftIdeal);
InstallOtherMethod(IsTwoSidedIdealOp,"for anti-commutative FLMLOR and free left module",IsIdenticalObj,[IsFLMLOR and IsAnticommutative,IsFreeLeftModule],0,IsLeftIdeal);
InstallOtherMethod(IsTwoSidedIdealOp,"for FLMLOR and free left module",IsIdenticalObj,[IsFLMLOR,IsFreeLeftModule],0,COM_FUN(3));
InstallMethod(TwoSidedIdealByGenerators,"for FLMLOR and collection",IsIdenticalObj,[IsFLMLOR,IsCollection],0,COM_FUN(4));
InstallMethod(LeftIdealByGenerators,"for FLMLOR and collection",IsIdenticalObj,[IsFLMLOR,IsCollection],0,COM_FUN(5));
InstallMethod(RightIdealByGenerators,"for FLMLOR and collection",IsIdenticalObj,[IsFLMLOR,IsCollection],0,COM_FUN(6));
InstallMethod(TwoSidedIdealByGenerators,"for FLMLOR and empty list",true,[IsFLMLOR,IsList and IsEmpty],0,COM_FUN(7));
InstallMethod(LeftIdealByGenerators,"for FLMLOR and empty list",true,[IsFLMLOR,IsList and IsEmpty],0,COM_FUN(8));
InstallMethod(RightIdealByGenerators,"for FLMLOR and empty list",true,[IsFLMLOR,IsList and IsEmpty],0,COM_FUN(9));
LeftModuleGeneratorsForIdealFromGenerators:=COM_FUN(10);
InstallMethod(GeneratorsOfLeftModule,"for FLMLOR with known ideal generators",true,[IsFLMLOR and HasGeneratorsOfTwoSidedIdeal],0,COM_FUN(11));
InstallMethod(GeneratorsOfLeftModule,"for FLMLOR with known left ideal generators",true,[IsFLMLOR and HasGeneratorsOfLeftIdeal],RankFilter(HasGeneratorsOfTwoSidedIdeal),COM_FUN(12));
InstallMethod(GeneratorsOfLeftModule,"for FLMLOR with known right ideal generators",true,[IsFLMLOR and HasGeneratorsOfRightIdeal],RankFilter(HasGeneratorsOfTwoSidedIdeal),COM_FUN(13));
InstallMethod(GeneratorsOfLeftOperatorRing,"for FLMLOR with known ideal generators",true,[IsFLMLOR and HasGeneratorsOfTwoSidedIdeal],0,COM_FUN(14));
InstallMethod(GeneratorsOfLeftOperatorRing,"for FLMLOR with known left ideal generators",true,[IsFLMLOR and HasGeneratorsOfLeftIdeal],RankFilter(HasGeneratorsOfTwoSidedIdeal),COM_FUN(15));
InstallMethod(GeneratorsOfLeftOperatorRing,"for FLMLOR with known right ideal generators",true,[IsFLMLOR and HasGeneratorsOfRightIdeal],RankFilter(HasGeneratorsOfTwoSidedIdeal),COM_FUN(16));
InstallMethod(AsLeftIdeal,"for two FLMLORs",IsIdenticalObj,[IsFLMLOR,IsFLMLOR],0,COM_FUN(17));
InstallMethod(AsRightIdeal,"for two FLMLORs",IsIdenticalObj,[IsRing,IsRing],0,COM_FUN(18));
InstallMethod(AsTwoSidedIdeal,"for two FLMLORs",IsIdenticalObj,[IsRing,IsRing],0,COM_FUN(19));
InstallMethod(IsFiniteDimensional,"for an ideal in an algebra",true,[IsFLMLOR and HasLeftActingRingOfIdeal],0,COM_FUN(20));
InstallMethod(IsFiniteDimensional,"for an ideal in an algebra",true,[IsFLMLOR and HasRightActingRingOfIdeal],0,COM_FUN(21));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/idealalg.gi"

#F  file="lib/alghom.gi" crc=-97290782
RANK_FILTER_LIST  := [ 33646191, 34, 33646191, 34, 32769, 4, 32769, 4, 
  33646191, 34, 33646191, 34, 32769, 4, 32769, 4, 33646191, 34, 33646191, 34, 
  32769, 4, 32769, 4, 33646191, 34, 33646191, 34, 32769, 4, 32769, 4, 
  66018747, 25, 62494413, 31, 50219122, 29, 38123166, 27, 66018747, 25, 
  51794944, 25, 9057312, 29, 66018747, 25, 66018747, 25, 66018747, 25, 
  66018747, 25, 66018747, 25, 66018747, 25, 66018747, 25, 1, 0, 66018747, 25, 
  1, 0, 32505602, 3, 66018747, 25, 66018747, 25, 6093618, 19, 51794944, 25, 
  59494340, 21, 51794944, 25, 66018747, 25, 49346896, 7, 49346896, 7, 
  66018747, 25, 33343703, 29, 33343703, 29, 33343703, 29, 33343703, 29, 
  64918210, 8, 33343703, 29, 58412696, 30, 66688365, 29, 66688365, 29, 
  66688365, 29, 66688365, 29, 64918210, 8, 66688365, 29, 58412696, 30, 
  33646191, 34, 16800902, 7, 5, 1, 33646191, 34, 8126465, 2, 33646191, 34, 
  22117846, 26, 5, 1, 33343703, 29, 66890973, 29, 33646191, 34, 63198130, 7, 
  63198130, 7, 5, 1, 33646191, 34, 32769, 4, 32769, 4, 5, 1, 33646191, 34, 
  91054, 47, 33646191, 34, 33646191, 34, 33646191, 34, 27354165, 37, 298919, 
  37, 33646191, 34, 16800902, 7, 2772311, 39 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/alghom.gi", -97290782 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/alghom.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/alghom.gi");
elif COM_RESULT = 3  then
Revision.alghom_gi:="@(#)$Id: alghom.gi,v 4.25 2002/04/15 10:04:24 sal Exp $";
DeclareRepresentation("IsAlgebraGeneralMappingByImagesDefaultRep",IsAlgebraGeneralMapping and IsAdditiveElementWithInverse and IsAttributeStoringRep,[]);
InstallMethod(AlgebraGeneralMappingByImages,"for two FLMLORs and two homogeneous lists",[IsFLMLOR,IsFLMLOR,IsHomogeneousList,IsHomogeneousList],COM_FUN(1));
InstallMethod(AlgebraHomomorphismByImagesNC,"for two FLMLORs and two homogeneous lists",[IsFLMLOR,IsFLMLOR,IsHomogeneousList,IsHomogeneousList],COM_FUN(2));
InstallMethod(AlgebraWithOneGeneralMappingByImages,"for two FLMLORs and two homogeneous lists",[IsFLMLOR,IsFLMLOR,IsHomogeneousList,IsHomogeneousList],COM_FUN(3));
InstallMethod(AlgebraWithOneHomomorphismByImagesNC,"for two FLMLORs and two homogeneous lists",true,[IsFLMLOR,IsFLMLOR,IsHomogeneousList,IsHomogeneousList],0,COM_FUN(4));
InstallGlobalFunction(AlgebraHomomorphismByImages,COM_FUN(5));
InstallGlobalFunction(AlgebraWithOneHomomorphismByImages,COM_FUN(6));
InstallMethod(ViewObj,"for an algebra g.m.b.i",true,[IsGeneralMapping and IsAlgebraGeneralMappingByImagesDefaultRep],0,COM_FUN(7));
InstallMethod(PrintObj,"for an algebra-with-one hom. b.i",true,[IsMapping and IsTotal and RespectsOne and IsAlgebraGeneralMappingByImagesDefaultRep],0,COM_FUN(8));
InstallMethod(PrintObj,"for an algebra hom. b.i.",true,[IsMapping and IsTotal and IsAlgebraGeneralMappingByImagesDefaultRep],0,COM_FUN(9));
InstallMethod(PrintObj,"for an algebra-with-one g.m.b.i",true,[IsGeneralMapping and RespectsOne and IsAlgebraGeneralMappingByImagesDefaultRep],0,COM_FUN(10));
InstallMethod(PrintObj,"for an algebra g.m.b.i",true,[IsGeneralMapping and IsAlgebraGeneralMappingByImagesDefaultRep],0,COM_FUN(11));
InstallMethod(AsLeftModuleGeneralMappingByImages,"for an algebra general mapping by images",[IsAlgebraGeneralMapping and IsAlgebraGeneralMappingByImagesDefaultRep],COM_FUN(12));
InstallMethod(AsLeftModuleGeneralMappingByImages,"for an algebra homomorphism by images",[IsAlgebraHomomorphism and IsAlgebraGeneralMappingByImagesDefaultRep],COM_FUN(13));
InstallMethod(ImagesSource,"for an algebra g.m.b.i.",[IsGeneralMapping and IsAlgebraGeneralMappingByImagesDefaultRep],COM_FUN(14));
InstallMethod(PreImagesRange,"for an algebra g.m.b.i.",[IsGeneralMapping and IsAlgebraGeneralMappingByImagesDefaultRep],COM_FUN(15));
InstallMethod(CoKernelOfAdditiveGeneralMapping,"for algebra g.m.b.i.",[IsGeneralMapping and IsAlgebraGeneralMappingByImagesDefaultRep],COM_FUN(16));
InstallMethod(IsSingleValued,"for algebra g.m.b.i.",[IsGeneralMapping and IsAlgebraGeneralMappingByImagesDefaultRep],COM_FUN(17));
InstallMethod(KernelOfAdditiveGeneralMapping,"for algebra g.m.b.i.",[IsGeneralMapping and IsAlgebraGeneralMappingByImagesDefaultRep],COM_FUN(18));
InstallMethod(IsInjective,"for algebra g.m.b.i.",[IsGeneralMapping and IsAlgebraGeneralMappingByImagesDefaultRep],COM_FUN(19));
InstallMethod(ImagesRepresentative,"for algebra g.m.b.i., and element",FamSourceEqFamElm,[IsGeneralMapping and IsAlgebraGeneralMappingByImagesDefaultRep,IsObject],COM_FUN(20));
InstallMethod(PreImagesRepresentative,"for algebra g.m.b.i., and element",FamRangeEqFamElm,[IsGeneralMapping and IsAlgebraGeneralMappingByImagesDefaultRep,IsObject],COM_FUN(21));
InstallMethod(\*,"for scalar and algebra g.m.b.i.",[IsMultiplicativeElement,IsGeneralMapping and IsAlgebraGeneralMappingByImagesDefaultRep],COM_FUN(22));
InstallMethod(AdditiveInverseOp,"for algebra g.m.b.i.",[IsGeneralMapping and IsAlgebraGeneralMappingByImagesDefaultRep],COM_FUN(23));
InstallMethod(CompositionMapping2,"for left module hom. and algebra g.m.b.i.",FamSource1EqFamRange2,[IsLeftModuleHomomorphism,IsAlgebraGeneralMapping and IsAlgebraGeneralMappingByImagesDefaultRep],COM_FUN(24));
InstallMethod(CompositionMapping2,"for left module hom. and algebra g.m.b.i.",FamSource1EqFamRange2,[IsAlgebraHomomorphism,IsAlgebraGeneralMapping and IsAlgebraGeneralMappingByImagesDefaultRep],COM_FUN(25));
InstallOtherMethod(\+,"for an algebra g.m.b.i. and general mapping",IsIdenticalObj,[IsGeneralMapping and IsAlgebraGeneralMappingByImagesDefaultRep,IsGeneralMapping],COM_FUN(26));
InstallOtherMethod(\+,"for general mapping and algebra g.m.b.i.",IsIdenticalObj,[IsGeneralMapping,IsGeneralMapping and IsAlgebraGeneralMappingByImagesDefaultRep],COM_FUN(27));
DeclareRepresentation("IsOperationAlgebraHomomorphismDefaultRep",IsAlgebraHomomorphism and IsAdditiveElementWithInverse and IsAttributeStoringRep,["basis","operation","basisImage","preimagesBasisImage"]);
InstallMethod(ViewObj,"for an operation algebra homomorphism",[IsOperationAlgebraHomomorphismDefaultRep],COM_FUN(28));
InstallMethod(PrintObj,"for an operation algebra homomorphism",[IsOperationAlgebraHomomorphismDefaultRep],COM_FUN(29));
InstallGlobalFunction(InducedLinearAction,COM_FUN(30));
InstallMethod(MakePreImagesInfoOperationAlgebraHomomorphism,"for an operation algebra homomorphism",[IsOperationAlgebraHomomorphismDefaultRep],COM_FUN(31));
InstallMethod(ImagesRepresentative,"for an operation algebra homomorphism, and an element",FamSourceEqFamElm,[IsOperationAlgebraHomomorphismDefaultRep,IsRingElement],COM_FUN(32));
PreImagesRepresentativeOperationAlgebraHomomorphism:=COM_FUN(33);
InstallMethod(PreImagesRepresentative,"for an operation algebra homomorphism, and an element",FamRangeEqFamElm,[IsOperationAlgebraHomomorphismDefaultRep,IsMatrix],PreImagesRepresentativeOperationAlgebraHomomorphism);
DeclareRepresentation("IsAlgebraHomomorphismFromFpRep",IsAlgebraHomomorphism and IsAdditiveElementWithInverse and IsAttributeStoringRep,["Agenerators","Agenimages","basisImage","preimagesBasisImage"]);
InstallMethod(ViewObj,"for an alg. hom. from f. p. algebra",[IsAlgebraHomomorphismFromFpRep],COM_FUN(34));
InstallMethod(PrintObj,"for an alg. hom. from f. p. algebra",[IsAlgebraHomomorphismFromFpRep],COM_FUN(35));
InstallMethod(MakePreImagesInfoOperationAlgebraHomomorphism,"for an alg. hom. from f. p. algebra",[IsAlgebraHomomorphismFromFpRep],COM_FUN(36));
InstallMethod(ImagesRepresentative,"for an alg. hom. from f. p. algebra, and an element",FamSourceEqFamElm,[IsAlgebraHomomorphismFromFpRep,IsRingElement],COM_FUN(37));
InstallMethod(PreImagesRepresentative,"for an alg. hom. from f. p. algebra, and an element",FamRangeEqFamElm,[IsAlgebraHomomorphismFromFpRep,IsMatrix],PreImagesRepresentativeOperationAlgebraHomomorphism);
InstallMethod(OperationAlgebraHomomorphism,"for a FLMLOR, a basis, and a function",[IsFLMLOR,IsBasis,IsFunction],COM_FUN(38));
InstallOtherMethod(OperationAlgebraHomomorphism,"for a FLMLOR and a collection (add `OnRight' argument)",[IsFLMLOR,IsCollection],COM_FUN(39));
InstallOtherMethod(OperationAlgebraHomomorphism,"for a FLMLOR, a free left module with known generators, and a function",[IsFLMLOR,IsFreeLeftModule and IsFiniteDimensional and HasGeneratorsOfLeftModule,IsFunction],COM_FUN(40));
InstallMethod(Range,"for operation algebra homomorphism (set full matrix FLMLOR)",[IsOperationAlgebraHomomorphismDefaultRep],COM_FUN(41));
InstallMethod(KernelOfAdditiveGeneralMapping,"for operation algebra hom. with fin. dim. source",[IsMapping and IsOperationAlgebraHomomorphismDefaultRep],COM_FUN(42));
InstallMethod(RepresentativeLinearOperation,"for a FLMLOR, two elements in it, and `OnRight'",IsCollsElmsElmsX,[IsFLMLOR,IsVector,IsVector,IsFunction],COM_FUN(43));
InstallOtherMethod(RepresentativeLinearOperation,"for a FLMLOR, two tuples of elements in it, and `OnTuples'",IsFamFamFamX,[IsFLMLOR,IsHomogeneousList,IsHomogeneousList,IsFunction],COM_FUN(44));
InstallMethod(NaturalHomomorphismByIdeal,"for FLMLOR and trivial FLMLOR",IsIdenticalObj,[IsFLMLOR,IsFLMLOR and IsTrivial],SUM_FLAGS,COM_FUN(45));
InstallMethod(NaturalHomomorphismByIdeal,"for two finite dimensional FLMLORs",IsIdenticalObj,[IsFLMLOR,IsFLMLOR],COM_FUN(46));
InstallMethod(IsomorphismMatrixFLMLOR,"for a finite dimensional associative FLMLOR with identity",[IsFLMLOR],COM_FUN(47));
InstallMethod(IsomorphismFpFLMLOR,"for a finite dimensional FLMLOR-with-one",[IsFLMLORWithOne],COM_FUN(48));
InstallMethod(IsomorphismFpFLMLOR,"for f.p. FLMLOR (return the identity mapping)",[IsSubalgebraFpAlgebra],SUM_FLAGS,IdentityMapping);
InstallMethod(IsomorphismSCFLMLOR,"for a finite dimensional FLMLOR (delegate to the method for a basis)",[IsFLMLOR],COM_FUN(49));
InstallMethod(IsomorphismSCFLMLOR,"for a basis (of a finite dimensional FLMLOR)",[IsBasis],COM_FUN(50));
InstallMethod(IsomorphismSCFLMLOR,"for s.c. FLMLOR (return the identity mapping)",[IsFLMLOR and IsSCAlgebraObjCollection],SUM_FLAGS,IdentityMapping);
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/alghom.gi"

#F  file="lib/algfp.gi" crc=53789989
RANK_FILTER_LIST  := [ 149460, 4, 64918210, 8, 9586629, 5, 64918210, 8, 
  51384353, 11, 9586629, 5, 8193, 2, 50368545, 9, 32769, 4, 32769, 4, 
  40669202, 11, 40669202, 11, 50368545, 9, 50368545, 9, 40669202, 11, 
  40669202, 11, 50368545, 9, 50368545, 9, 2092427, 40, 2092427, 40, 2092427, 
  40, 11875466, 37, 4292682, 35, 33646191, 34, 51384353, 11, 51384353, 11, 
  51384353, 11, 51384353, 11, 51384353, 11, 51384353, 11, 51384353, 11, 
  51384353, 11, 51384353, 11, 51384353, 11, 64918210, 8, 51384353, 11, 
  51384353, 11, 64918210, 8, 33945109, 37, 41165663, 45, 41165663, 45, 
  8126465, 2, 5, 1, 41165663, 45, 298919, 37, 162941, 27, 162941, 27, 1, 0, 
  162941, 27, 1, 0 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/algfp.gi", 53789989 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/algfp.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/algfp.gi");
elif COM_RESULT = 3  then
Revision.algfp_gi:="@(#)$Id: algfp.gi,v 4.25 2002/04/15 10:04:24 sal Exp $";
InstallMethod(ElementOfFpAlgebra,"for family of fp. alg. elements and ring element",true,[IsElementOfFpAlgebraFamily,IsRingElement],0,COM_FUN(1));
InstallMethod(ElementOfFpAlgebra,"for fp. alg. elms. family with normal form, and ring element",true,[IsElementOfFpAlgebraFamily and HasNiceNormalFormByExtRepFunction,IsRingElement],0,COM_FUN(2));
InstallMethod(ExtRepOfObj,"for f.p. algebra element",true,[IsElementOfFpAlgebra and IsPackedElementDefaultRep],0,COM_FUN(3));
InstallMethod(ObjByExtRep,"for family of f.p. algebra elements with normal form",true,[IsElementOfFpAlgebraFamily and HasNiceNormalFormByExtRepFunction,IsList],0,COM_FUN(4));
BindGlobal("MappedExpressionForElementOfFreeAssociativeAlgebra",COM_FUN(5));
InstallMethod(MappedExpression,"for element of f.p. algebra, and two lists of generators",IsElmsCollsX,[IsElementOfFpAlgebra,IsHomogeneousList,IsHomogeneousList],0,MappedExpressionForElementOfFreeAssociativeAlgebra);
InstallMethod(\=,"for two normalized f.p. algebra elements",IsIdenticalObj,[IsElementOfFpAlgebra and IsNormalForm,IsElementOfFpAlgebra and IsNormalForm],0,COM_FUN(6));
InstallMethod(\=,"for two f.p. algebra elements (try nice monomorphism)",IsIdenticalObj,[IsElementOfFpAlgebra,IsElementOfFpAlgebra],0,COM_FUN(7));
InstallMethod(\<,"for two normalized f.p. algebra elements",IsIdenticalObj,[IsElementOfFpAlgebra and IsNormalForm,IsElementOfFpAlgebra and IsNormalForm],0,COM_FUN(8));
InstallMethod(\<,"for two f.p. algebra elements (try nice monomorphism)",IsIdenticalObj,[IsElementOfFpAlgebra,IsElementOfFpAlgebra],0,COM_FUN(9));
InstallGlobalFunction(FactorFreeAlgebraByRelators,COM_FUN(10));
InstallMethod(FreeGeneratorsOfFpAlgebra,"for a full f.p. algebra",true,[IsSubalgebraFpAlgebra and IsFullFpAlgebra],0,COM_FUN(11));
InstallMethod(RelatorsOfFpAlgebra,"for a full f.p. algebra",true,[IsSubalgebraFpAlgebra and IsFullFpAlgebra],0,COM_FUN(12));
InstallMethod(FreeAlgebraOfFpAlgebra,"for a full f.p. algebra",true,[IsSubalgebraFpAlgebra and IsFullFpAlgebra],0,COM_FUN(13));
InstallOtherMethod(IsFullFpAlgebra,"for f. p. algebra",true,[IsAlgebra and IsSubalgebraFpAlgebra],0,COM_FUN(14));
InstallMethod(NaturalHomomorphismByIdeal,"for free algebra and ideal",IsIdenticalObj,[IsMagmaRingModuloRelations,IsFLMLOR],0,COM_FUN(15));
InstallMethod(PrintObj,"fp algebra elements",true,[IsElementOfFpAlgebra and IsPackedElementDefaultRep],0,COM_FUN(16));
InstallMethod(\+,"fp algebra elements",IsIdenticalObj,[IsElementOfFpAlgebra and IsPackedElementDefaultRep,IsElementOfFpAlgebra and IsPackedElementDefaultRep],0,COM_FUN(17));
InstallMethod(\-,"fp algebra elements",IsIdenticalObj,[IsElementOfFpAlgebra and IsPackedElementDefaultRep,IsElementOfFpAlgebra and IsPackedElementDefaultRep],0,COM_FUN(18));
InstallMethod(AdditiveInverseOp,"fp algebra element",true,[IsElementOfFpAlgebra and IsPackedElementDefaultRep],0,COM_FUN(19));
InstallOtherMethod(OneOp,"for an f.p. algebra element",true,[IsElementOfFpAlgebra and IsPackedElementDefaultRep],0,COM_FUN(20));
InstallMethod(ZeroOp,"for an f.p. algebra element",true,[IsElementOfFpAlgebra and IsPackedElementDefaultRep],0,COM_FUN(21));
InstallMethod(\*,"fp algebra elements",IsIdenticalObj,[IsElementOfFpAlgebra and IsPackedElementDefaultRep,IsElementOfFpAlgebra and IsPackedElementDefaultRep],0,COM_FUN(22));
InstallMethod(\*,"ring el *fp algebra el",IsRingsMagmaRings,[IsRingElement,IsElementOfFpAlgebra and IsPackedElementDefaultRep],0,COM_FUN(23));
InstallMethod(\*,"fp algebra el*ring el",IsMagmaRingsRings,[IsElementOfFpAlgebra and IsPackedElementDefaultRep,IsRingElement],0,COM_FUN(24));
InstallMethod(IsomorphismMatrixFLMLOR,"for a f.p. FLMLOR",true,[IsFLMLOR and IsSubalgebraFpAlgebra],0,COM_FUN(25));
InstallMethod(IsomorphismMatrixFLMLOR,"for a full f.p. associative FLMLOR",true,[IsFLMLORWithOne and IsSubalgebraFpAlgebra and IsAssociative and IsFullFpAlgebra],0,COM_FUN(26));
InstallOtherMethod(OperationAlgebraHomomorphism,"for a full f.p. associative FLMLOR, a collection, and a function",true,[IsFLMLORWithOne and IsSubalgebraFpAlgebra and IsAssociative and IsFullFpAlgebra,IsCollection,IsFunction],0,COM_FUN(27));
InstallMethod(NiceAlgebraMonomorphism,"for a full f.p. associative FLMLOR (call `IsomorphismMatrixFLMLOR')",true,[IsFLMLORWithOne and IsSubalgebraFpAlgebra and IsAssociative and IsFullFpAlgebra],0,IsomorphismMatrixFLMLOR);
InstallMethod(IsFiniteDimensional,"for f.p. algebra",true,[IsSubalgebraFpAlgebra],0,COM_FUN(28));
InstallHandlingByNiceBasis("IsFpAlgebraElementsSpace",rec(detect:=COM_FUN(29),NiceFreeLeftModuleInfo:=ReturnTrue,NiceVector:=COM_FUN(30),UglyVector:=COM_FUN(31)));
InstallGlobalFunction(FpAlgebraByGeneralizedCartanMatrix,COM_FUN(32));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/algfp.gi"

#F  file="lib/alglie.gi" crc=124517007
RANK_FILTER_LIST  := [ 20239680, 42, 20239680, 42, 20239680, 42, 20239680, 
  42, 20239680, 42, 20239680, 42, 29446813, 43, 20239680, 42, 20239680, 42, 
  45405099, 48, 23269910, 25, 20239680, 42, 23269910, 25, 20239680, 42, 
  23269910, 25, 20239680, 42, 23269910, 25, 16800902, 7, 64918210, 8, 
  16800902, 7, 16800902, 7, 16800902, 7, 16800902, 7, 20239680, 42, 20239680, 
  42, 16800902, 7, 64918210, 8, 16800902, 7, 20239680, 42, 20239680, 42, 
  20239680, 42, 20239680, 42, 20239680, 42, 20239680, 42, 20239680, 42, 
  20239680, 42, 20239680, 42, 13106691, 1, 13106691, 1, 1, 0, 20239680, 42, 
  26214341, 2, 20239680, 42, 20239680, 42, 16800902, 7, 20239680, 42, 
  28683074, 27, 28683074, 27, 1, 0, 28683074, 27, 1, 0, 56214979, 5, 8193, 2, 
  62490903, 22, 50368545, 9, 62490903, 22, 50368545, 9, 62490903, 22, 
  51671940, 11, 20538598, 43, 20538598, 43, 20538598, 43, 53660808, 21, 
  53660808, 21 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/alglie.gi", 124517007 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/alglie.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/alglie.gi");
elif COM_RESULT = 3  then
Revision.alglie_gi:="@(#)$Id: alglie.gi,v 4.84 2003/07/29 14:43:35 gap Exp $";
InstallMethod(LieUpperCentralSeries,"for a Lie algebra",true,[IsAlgebra and IsLieAlgebra],0,COM_FUN(1));
InstallMethod(LieLowerCentralSeries,"for a Lie algebra",true,[IsAlgebra and IsLieAlgebra],0,COM_FUN(2));
InstallMethod(LieDerivedSubalgebra,"for a Lie algebra",true,[IsAlgebra and IsLieAlgebra],0,COM_FUN(3));
InstallMethod(LieDerivedSeries,"for a Lie algebra",true,[IsAlgebra and IsLieAlgebra],0,COM_FUN(4));
InstallMethod(IsLieSolvable,"for a Lie algebra",true,[IsAlgebra and IsLieAlgebra],0,COM_FUN(5));
InstallTrueMethod(IsLieSolvable,IsLieNilpotent);
InstallMethod(IsLieNilpotent,"for a Lie algebra",true,[IsAlgebra and IsLieAlgebra],0,COM_FUN(6));
InstallTrueMethod(IsLieNilpotent,IsLieAbelian);
InstallMethod(IsLieAbelian,"for a Lie algebra with known basis",true,[IsAlgebra and IsLieAlgebra and HasBasis],0,COM_FUN(7));
InstallMethod(IsLieAbelian,"for a Lie algebra",true,[IsAlgebra and IsLieAlgebra],0,COM_FUN(8));
InstallTrueMethod(IsLieAbelian,IsAlgebra and IsZeroMultiplicationRing);
InstallMethod(LieCentre,"for a Lie algebra",true,[IsAlgebra and IsLieAlgebra],0,COM_FUN(9));
InstallMethod(LieCentralizer,"for an abelian Lie algebra and a vector space",IsIdenticalObj,[IsAlgebra and IsLieAlgebra and IsLieAbelian,IsVectorSpace],0,COM_FUN(10));
InstallMethod(LieCentralizer,"for a Lie algebra and a vector space",IsIdenticalObj,[IsAlgebra and IsLieAlgebra,IsVectorSpace],0,COM_FUN(11));
InstallMethod(LieNormalizer,"for a Lie algebra and a vector space",IsIdenticalObj,[IsAlgebra and IsLieAlgebra,IsVectorSpace],0,COM_FUN(12));
InstallMethod(KappaPerp,"for a Lie algebra and a vector space",IsIdenticalObj,[IsAlgebra and IsLieAlgebra,IsVectorSpace],0,COM_FUN(13));
InstallMethod(AdjointMatrix,"for a basis of a Lie algebra, and an element",IsCollsElms,[IsBasis,IsRingElement],0,COM_FUN(14));
InstallMethod(RightDerivations,"method for a basis of an algebra",true,[IsBasis],0,COM_FUN(15));
InstallMethod(LeftDerivations,"method for a basis of an algebra",true,[IsBasis],0,COM_FUN(16));
InstallMethod(KillingMatrix,"for a basis of a Lie algebra",true,[IsBasis],0,COM_FUN(17));
InstallMethod(AdjointBasis,"for a basis of a Lie algebra",true,[IsBasis],0,COM_FUN(18));
InstallMethod(IsRestrictedLieAlgebra,"for a Lie algebra",true,[IsAlgebra and IsLieAlgebra],0,COM_FUN(19));
InstallGlobalFunction(PowerSi,COM_FUN(20));
InstallMethod(PowerS,"for a Lie algebra",true,[IsLieAlgebra],0,COM_FUN(21));
InstallMethod(PthPowerImage,"for a basis of an algebra, and a ring element",IsCollsElms,[IsBasis,IsRingElement],0,COM_FUN(22));
InstallMethod(PthPowerImages,"for a basis of a Lie algebra",true,[IsBasis],0,COM_FUN(23));
InstallMethod(CartanSubalgebra,"for a Lie algebra",true,[IsLieAlgebra],0,COM_FUN(24));
InstallMethod(AdjointAssociativeAlgebra,"for a Lie algebra and a subalgebra",true,[IsAlgebra and IsLieAlgebra,IsAlgebra and IsLieAlgebra],0,COM_FUN(25));
InstallMethod(LieNilRadical,"for a Lie algebra",true,[IsAlgebra and IsLieAlgebra],0,COM_FUN(26));
InstallMethod(LieSolvableRadical,"for a Lie algebra",true,[IsLieAlgebra],0,COM_FUN(27));
InstallMethod(DirectSumDecomposition,"for a Lie algebra",true,[IsAlgebra and IsLieAlgebra],0,COM_FUN(28));
InstallMethod(IsSimpleAlgebra,"for a Lie algebra in characteristic zero",true,[IsAlgebra and IsLieAlgebra],0,COM_FUN(29));
InstallGlobalFunction(FindSl2,COM_FUN(30));
InstallMethod(SemiSimpleType,"for a Lie algebra",true,[IsAlgebra and IsLieAlgebra],0,COM_FUN(31));
InstallMethod(NonNilpotentElement,"for a Lie algebra",true,[IsAlgebra and IsLieAlgebra],0,COM_FUN(32));
InstallMethod(PrintObj,"for a root system",true,[IsRootSystem],0,COM_FUN(33));
InstallMethod(\.,"for a root system and a record component",true,[IsRootSystem,IsObject],0,COM_FUN(34));
InstallMethod(RootSystem,"for a (semisimple) Lie algebra",true,[IsAlgebra and IsLieAlgebra],0,COM_FUN(35));
InstallMethod(CanonicalGenerators,"for a root system from a (semisimple) Lie algebra",true,[IsRootSystemFromLieAlgebra],0,COM_FUN(36));
InstallMethod(ChevalleyBasis,"for a semisimple Lie algebra with a split Cartan subalgebra",true,[IsLieAlgebra],0,COM_FUN(37));
InstallGlobalFunction(DescriptionOfNormalizedUEAElement,COM_FUN(38));
InstallOtherMethod(UniversalEnvelopingAlgebra,"for a finite dimensional Lie algebra and a basis of it",true,[IsLieAlgebra,IsBasis],0,COM_FUN(39));
InstallMethod(UniversalEnvelopingAlgebra,"for a finite dimensional Lie algebra",true,[IsLieAlgebra],0,COM_FUN(40));
DeclareHandlingByNiceBasis("IsSpaceOfUEAElements","for free left modules of elements of a universal enveloping algebra");
InstallHandlingByNiceBasis("IsSpaceOfUEAElements",rec(detect:=COM_FUN(41),NiceFreeLeftModuleInfo:=COM_FUN(42),NiceVector:=COM_FUN(43),UglyVector:=COM_FUN(44)));
InstallGlobalFunction(FreeLieAlgebra,COM_FUN(45));
InstallMethod(NormalizedElementOfMagmaRingModuloRelations,"for family of free Lie algebra elements, and list",true,[IsFamilyElementOfFreeLieAlgebra,IsList],0,COM_FUN(46));
BindGlobal("FptoSCAMorphismImageElm",COM_FUN(47));
InstallMethod(ImageElm,"for Fp to SCA mapping, and element",FamSourceEqFamElm,[IsFptoSCAMorphism,IsElementOfFpAlgebra],0,FptoSCAMorphismImageElm);
InstallMethod(ImagesRepresentative,"for Fp to SCA mapping, and element",FamSourceEqFamElm,[IsFptoSCAMorphism,IsElementOfFpAlgebra],0,FptoSCAMorphismImageElm);
InstallMethod(PreImagesRepresentative,"for Fp to SCA mapping, and element",FamRangeEqFamElm,[IsFptoSCAMorphism,IsSCAlgebraObj],0,COM_FUN(48));
InstallMethod(Dimension,"for a f.p. Lie algebra",true,[IsLieAlgebra and IsSubalgebraFpAlgebra],0,COM_FUN(49));
InstallMethod(IsFiniteDimensional,"for a f.p. Lie algebra",true,[IsLieAlgebra and IsSubalgebraFpAlgebra],0,COM_FUN(50));
InstallGlobalFunction(FpLieAlgebraEnumeration,COM_FUN(51));
InstallMethod(NiceAlgebraMonomorphism,"for a f.p. Lie algebra",true,[IsLieAlgebra and IsSubalgebraFpAlgebra],0,COM_FUN(52));
InstallGlobalFunction(NilpotentQuotientOfFpLieAlgebra,COM_FUN(53));
InstallGlobalFunction(FpLieAlgebraByCartanMatrix,COM_FUN(54));
InstallMethod(JenningsLieAlgebra,"for a p-group",true,[IsGroup],0,COM_FUN(55));
InstallMethod(PCentralLieAlgebra,"for a p-group",true,[IsGroup],0,COM_FUN(56));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/alglie.gi"

#F  file="lib/algliess.gi" crc=-128304571
RANK_FILTER_LIST  := [  ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/algliess.gi", -128304571 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/algliess.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/algliess.gi");
elif COM_RESULT = 3  then
Revision.algliess_gi:="@(#)$Id: algliess.gi,v 4.24 2003/10/19 09:54:44 gap Exp $";
AddendumSCTable:=COM_FUN(1);
SimpleLieAlgebraTypeA_G:=COM_FUN(2);
SimpleLieAlgebraTypeW:=COM_FUN(3);
SimpleLieAlgebraTypeS:=COM_FUN(4);
SimpleLieAlgebraTypeH:=COM_FUN(5);
SimpleLieAlgebraTypeK:=COM_FUN(6);
InstallGlobalFunction(SimpleLieAlgebra,COM_FUN(7));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/algliess.gi"

#F  file="lib/algsc.gi" crc=-63809150
RANK_FILTER_LIST  := [ 63796962, 33, 47811547, 41, 21444477, 4, 32769, 4, 
  13726007, 5, 32769, 4, 49991800, 13, 51671940, 11, 21444477, 4, 51671940, 
  11, 51671940, 11, 49991800, 13, 49991800, 13, 51671940, 11, 51671940, 11, 
  49991800, 13, 49991800, 13, 51671940, 11, 51671940, 11, 49991800, 13, 
  49991800, 13, 51671940, 11, 51671940, 11, 49991800, 13, 49991800, 13, 
  51671940, 11, 51671940, 11, 49991800, 13, 49991800, 13, 64918210, 8, 
  51671940, 11, 64918210, 8, 49991800, 13, 51671940, 11, 64918210, 8, 
  49991800, 13, 64918210, 8, 17, 18, 51671940, 11, 17, 18, 49991800, 13, 
  51671940, 11, 17, 18, 49991800, 13, 17, 18, 51671940, 11, 30625149, 10, 
  49991800, 13, 30625149, 10, 51671940, 11, 51671940, 11, 51671940, 11, 
  51671940, 11, 51671940, 11, 61562778, 41, 31748216, 23, 31748216, 23, 
  31748216, 23, 44686386, 27, 44686386, 27, 1, 0, 44686386, 27, 1, 0, 
  10477489, 26, 36235000, 16, 10477489, 26, 8193, 2, 51671940, 11, 61727293, 
  11, 51671940, 11, 61727293, 11, 65077940, 12, 61727293, 11, 60212041, 41, 
  60212041, 41, 16800902, 7 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/algsc.gi", -63809150 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/algsc.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/algsc.gi");
elif COM_RESULT = 3  then
Revision.algsc_gi:="@(#)$Id: algsc.gi,v 4.29 2002/06/18 15:58:56 gap Exp $";
InstallMethod(IsWholeFamily,"for s. c. algebra elements collection",[IsSCAlgebraObjCollection and IsLeftModule and IsFreeLeftModule],COM_FUN(1));
InstallMethod(IsFullSCAlgebra,"for s. c. algebra elements collection",[IsSCAlgebraObjCollection and IsAlgebra],COM_FUN(2));
DeclareRepresentation("IsDenseCoeffVectorRep",IsPositionalObjectRep,[1]);
InstallMethod(ObjByExtRep,"for s. c. algebra elements family",[IsSCAlgebraObjFamily,IsHomogeneousList],COM_FUN(3));
InstallMethod(ObjByExtRep,"for s. c. alg. elms. family with coefficients family",[IsSCAlgebraObjFamily and IsFamilyOverFullCoefficientsFamily,IsHomogeneousList],COM_FUN(4));
InstallMethod(ExtRepOfObj,"for s. c. algebra element in dense coeff. vector rep.",[IsSCAlgebraObj and IsDenseCoeffVectorRep],COM_FUN(5));
InstallMethod(PrintObj,"for s. c. algebra element",[IsSCAlgebraObj],COM_FUN(6));
InstallMethod(One,"for family of s. c. algebra elements",[IsSCAlgebraObjFamily],COM_FUN(7));
InstallMethod(\=,"for s. c. algebra elements",IsIdenticalObj,[IsSCAlgebraObj,IsSCAlgebraObj],COM_FUN(8));
InstallMethod(\=,"for s. c. algebra elements in dense vector rep.",IsIdenticalObj,[IsSCAlgebraObj and IsDenseCoeffVectorRep,IsSCAlgebraObj and IsDenseCoeffVectorRep],COM_FUN(9));
InstallMethod(\<,"for s. c. algebra elements",IsIdenticalObj,[IsSCAlgebraObj,IsSCAlgebraObj],COM_FUN(10));
InstallMethod(\<,"for s. c. algebra elements in dense vector rep.",IsIdenticalObj,[IsSCAlgebraObj and IsDenseCoeffVectorRep,IsSCAlgebraObj and IsDenseCoeffVectorRep],0,COM_FUN(11));
InstallMethod(\+,"for s. c. algebra elements",IsIdenticalObj,[IsSCAlgebraObj,IsSCAlgebraObj],COM_FUN(12));
InstallMethod(\+,"for s. c. algebra elements in dense vector rep.",IsIdenticalObj,[IsSCAlgebraObj and IsDenseCoeffVectorRep,IsSCAlgebraObj and IsDenseCoeffVectorRep],COM_FUN(13));
InstallMethod(\-,"for s. c. algebra elements",IsIdenticalObj,[IsSCAlgebraObj,IsSCAlgebraObj],COM_FUN(14));
InstallMethod(\-,"for s. c. algebra elements in dense vector rep.",IsIdenticalObj,[IsSCAlgebraObj and IsDenseCoeffVectorRep,IsSCAlgebraObj and IsDenseCoeffVectorRep],COM_FUN(15));
InstallMethod(\*,"for s. c. algebra elements",IsIdenticalObj,[IsSCAlgebraObj,IsSCAlgebraObj],COM_FUN(16));
InstallMethod(\*,"for s. c. algebra elements in dense vector rep.",IsIdenticalObj,[IsSCAlgebraObj and IsDenseCoeffVectorRep,IsSCAlgebraObj and IsDenseCoeffVectorRep],COM_FUN(17));
InstallMethod(\*,"for ring element and s. c. algebra element",IsCoeffsElms,[IsRingElement,IsSCAlgebraObj],COM_FUN(18));
InstallMethod(\*,"for ring element and s. c. algebra element in dense vector rep.",IsCoeffsElms,[IsRingElement,IsSCAlgebraObj and IsDenseCoeffVectorRep],COM_FUN(19));
InstallMethod(\*,"for s. c. algebra element and ring element",IsElmsCoeffs,[IsSCAlgebraObj,IsRingElement],COM_FUN(20));
InstallMethod(\*,"for s. c. algebra element in dense vector rep. and ring element",IsElmsCoeffs,[IsSCAlgebraObj and IsDenseCoeffVectorRep,IsRingElement],COM_FUN(21));
InstallMethod(\*,"for integer and s. c. algebra element",[IsInt,IsSCAlgebraObj],COM_FUN(22));
InstallMethod(\*,"for integer and s. c. algebra element in dense vector rep.",[IsInt,IsSCAlgebraObj and IsDenseCoeffVectorRep],COM_FUN(23));
InstallMethod(\*,"for s. c. algebra element and integer",[IsSCAlgebraObj,IsInt],COM_FUN(24));
InstallMethod(\*,"for s. c. algebra element in dense vector rep. and integer",[IsSCAlgebraObj and IsDenseCoeffVectorRep,IsInt],COM_FUN(25));
InstallMethod(\/,"for s. c. algebra element and scalar",IsElmsCoeffs,[IsSCAlgebraObj,IsScalar],COM_FUN(26));
InstallMethod(\/,"for s. c. algebra element in dense vector rep. and scalar",IsElmsCoeffs,[IsSCAlgebraObj and IsDenseCoeffVectorRep,IsScalar],COM_FUN(27));
InstallMethod(ZeroOp,"for s. c. algebra element",[IsSCAlgebraObj],COM_FUN(28));
InstallMethod(AdditiveInverseOp,"for s. c. algebra element",[IsSCAlgebraObj],COM_FUN(29));
InstallOtherMethod(OneOp,"for s. c. algebra element",[IsSCAlgebraObj],COM_FUN(30));
InstallOtherMethod(InverseOp,"for s. c. algebra element",[IsSCAlgebraObj],COM_FUN(31));
InstallMethod(\in,"for s. c. algebra element, and full s. c. algebra",IsElmsColls,[IsSCAlgebraObj,IsFullSCAlgebra],COM_FUN(32));
BindGlobal("AlgebraByStructureConstantsArg",COM_FUN(33));
InstallGlobalFunction(AlgebraByStructureConstants,COM_FUN(34));
InstallGlobalFunction(LieAlgebraByStructureConstants,COM_FUN(35));
InstallGlobalFunction(QuaternionAlgebra,COM_FUN(36));
InstallMethod(OneOp,"for a quaternion",[IsQuaternion and IsSCAlgebraObj],COM_FUN(37));
InstallMethod(InverseOp,"for a quaternion",[IsQuaternion and IsSCAlgebraObj],COM_FUN(38));
InstallMethod(ComplexConjugate,"for a quaternion",[IsQuaternion and IsSCAlgebraObj],COM_FUN(39));
InstallGlobalFunction(ComplexificationQuat,COM_FUN(40));
InstallGlobalFunction(OctaveAlgebra,COM_FUN(41));
InstallHandlingByNiceBasis("IsSCAlgebraObjSpace",rec(detect:=COM_FUN(42),NiceFreeLeftModuleInfo:=ReturnTrue,NiceVector:=COM_FUN(43),UglyVector:=COM_FUN(44)));
InstallMethod(MutableBasis,"for ring and collection of s. c. algebra elements",[IsRing,IsSCAlgebraObjCollection],MutableBasisViaNiceMutableBasisMethod2);
InstallOtherMethod(MutableBasis,"for ring, (possibly empty) list, and zero element",[IsRing,IsList,IsSCAlgebraObj],MutableBasisViaNiceMutableBasisMethod3);
InstallMethod(Coefficients,"for canonical basis of full s. c. algebra",IsCollsElms,[IsBasis and IsCanonicalBasisFullSCAlgebra,IsSCAlgebraObj],COM_FUN(45));
InstallMethod(LinearCombination,"for canonical basis of full s. c. algebra",[IsBasis and IsCanonicalBasisFullSCAlgebra,IsRowVector],COM_FUN(46));
InstallMethod(BasisVectors,"for canonical basis of full s. c. algebra",[IsBasis and IsCanonicalBasisFullSCAlgebra],COM_FUN(47));
InstallMethod(Basis,"for full s. c. algebra (delegate to `CanonicalBasis')",[IsFreeLeftModule and IsSCAlgebraObjCollection and IsFullSCAlgebra],CANONICAL_BASIS_FLAGS,CanonicalBasis);
InstallMethod(CanonicalBasis,"for full s. c. algebras",[IsFreeLeftModule and IsSCAlgebraObjCollection and IsFullSCAlgebra],COM_FUN(48));
InstallMethod(IsCanonicalBasisFullSCAlgebra,"for a basis",[IsBasis],COM_FUN(49));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/algsc.gi"

#F  file="lib/algmat.gi" crc=-45224384
RANK_FILTER_LIST  := [ 53865321, 19, 26123951, 19, 53865321, 19, 26123951, 
  19, 27788788, 29, 27788788, 29, 53865321, 19, 26123951, 19, 4417712, 46, 
  8134657, 5, 4417712, 46, 41951068, 17, 24644793, 32, 4417712, 46, 8134657, 
  5, 24644793, 32, 4417712, 46, 15474584, 23, 4417712, 46, 41951068, 17, 
  5651446, 34, 4417712, 46, 15474584, 23, 5651446, 34, 4417712, 46, 8134657, 
  5, 4417712, 46, 41951068, 17, 24644793, 32, 4417712, 46, 8134657, 5, 
  24644793, 32, 6809622, 49, 8134657, 5, 32954799, 48, 8134657, 5, 16122751, 
  44, 41951068, 17, 6809622, 49, 8134657, 5, 32954799, 48, 8134657, 5, 
  16122751, 44, 41951068, 17, 6809622, 49, 8134657, 5, 32954799, 48, 8134657, 
  5, 16122751, 44, 41951068, 17, 16122751, 44, 58412696, 30, 6809622, 49, 
  44617989, 49, 24644793, 32, 44617989, 49, 16122751, 44, 38326923, 52, 
  24644793, 32, 38326923, 52, 16122751, 44, 54056373, 75, 16122751, 44, 
  54056373, 75, 65147699, 22, 54056373, 75, 8134657, 5, 31852201, 67, 
  41951068, 17, 27840863, 46, 27840863, 46, 32239383, 52, 32239383, 52, 
  14061479, 73, 33246692, 42, 33246692, 42, 33246692, 42, 33246692, 42, 
  33246692, 42, 41951068, 17, 41951068, 17, 33246692, 42, 33246692, 42, 
  64918210, 8, 64918210, 8, 33246692, 42, 33246692, 42, 17, 18, 10477489, 26, 
  16122751, 44, 65077940, 12, 65077940, 12, 5, 1, 33646191, 34, 58412696, 30, 
  58412696, 30, 5, 1, 16122751, 44 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/algmat.gi", -45224384 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/algmat.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/algmat.gi");
elif COM_RESULT = 3  then
Revision.algmat_gi:="@(#)$Id: algmat.gi,v 4.32 2002/04/15 10:04:25 sal Exp $";
InstallOtherMethod(RingByGenerators,"for a list of matrices over a finite field",true,[IsFFECollCollColl],0,COM_FUN(1));
InstallOtherMethod(RingByGenerators,"for a list of matrices over the Cyclotomics",true,[IsCyclotomicCollCollColl],0,COM_FUN(2));
InstallOtherMethod(DefaultRingByGenerators,"for a list of matrices over a finite field",true,[IsFFECollCollColl],0,COM_FUN(3));
InstallOtherMethod(DefaultRingByGenerators,"for a list of matrices over the Cyclotomics",true,[IsCyclotomicCollCollColl],0,COM_FUN(4));
InstallOtherMethod(RingByGenerators,"for a list of Lie matrices over a finite field",true,[IsLieObjectCollection and IsMatrixCollection],0,COM_FUN(5));
InstallOtherMethod(DefaultRingByGenerators,"for a list of Lie matrices",true,[IsLieObjectCollection and IsMatrixCollection],0,COM_FUN(6));
InstallOtherMethod(RingWithOneByGenerators,"for a list of matrices over a finite field",true,[IsFFECollCollColl],0,COM_FUN(7));
InstallOtherMethod(RingWithOneByGenerators,"for a list of matrices over the Cyclotomics",true,[IsCyclotomicCollCollColl],0,COM_FUN(8));
InstallMethod(FLMLORByGenerators,"for division ring and list of ordinary matrices over it",IsElmsCollColls,[IsDivisionRing,IsCollection and IsList],0,COM_FUN(9));
InstallOtherMethod(FLMLORByGenerators,"for division ring, empty list, and square ordinary matrix",COM_FUN(10),[IsDivisionRing,IsList and IsEmpty,IsOrdinaryMatrix],0,COM_FUN(11));
InstallOtherMethod(FLMLORByGenerators,"for division ring, list of matrices over it, and ordinary matrix",COM_FUN(12),[IsDivisionRing,IsCollection and IsList,IsOrdinaryMatrix],0,COM_FUN(13));
InstallMethod(FLMLORByGenerators,"for division ring and list of Lie matrices over it",IsElmsCollLieColls,[IsDivisionRing,IsLieObjectCollection and IsList],0,COM_FUN(14));
InstallOtherMethod(FLMLORByGenerators,"for division ring, empty list, and Lie matrix",COM_FUN(15),[IsDivisionRing,IsList and IsEmpty,IsLieMatrix and IsLieObject],0,COM_FUN(16));
InstallOtherMethod(FLMLORByGenerators,"for division ring, list of Lie matrices over it, and Lie matrix",COM_FUN(17),[IsDivisionRing,IsLieObjectCollection and IsList,IsLieObject and IsLieMatrix],0,COM_FUN(18));
InstallMethod(FLMLORWithOneByGenerators,"for division ring and list of ordinary matrices over it",IsElmsCollColls,[IsDivisionRing,IsCollection and IsList],0,COM_FUN(19));
InstallOtherMethod(FLMLORWithOneByGenerators,"for division ring, empty list, and square ordinary matrix",COM_FUN(20),[IsDivisionRing,IsList and IsEmpty,IsOrdinaryMatrix],0,COM_FUN(21));
InstallOtherMethod(FLMLORWithOneByGenerators,"for division ring, list of matrices over it, and ordinary matrix",COM_FUN(22),[IsDivisionRing,IsCollection and IsList,IsOrdinaryMatrix],0,COM_FUN(23));
InstallMethod(TwoSidedIdealByGenerators,"for Gaussian matrix algebra and list of matrices",IsIdenticalObj,[IsMatrixFLMLOR and IsGaussianMatrixSpace,IsCollection and IsList],0,COM_FUN(24));
InstallMethod(TwoSidedIdealByGenerators,"for non-Gaussian matrix algebra and list of matrices",IsIdenticalObj,[IsMatrixFLMLOR and IsNonGaussianMatrixSpace,IsCollection and IsList],0,COM_FUN(25));
InstallMethod(TwoSidedIdealByGenerators,"for matrix algebra and empty list",true,[IsMatrixFLMLOR,IsList and IsEmpty],0,COM_FUN(26));
InstallMethod(LeftIdealByGenerators,"for Gaussian matrix algebra and list of matrices",IsIdenticalObj,[IsMatrixFLMLOR and IsGaussianMatrixSpace,IsCollection and IsList],0,COM_FUN(27));
InstallMethod(LeftIdealByGenerators,"for non-Gaussian matrix algebra and list of matrices",IsIdenticalObj,[IsMatrixFLMLOR and IsNonGaussianMatrixSpace,IsCollection and IsList],0,COM_FUN(28));
InstallMethod(LeftIdealByGenerators,"for matrix algebra and empty list",true,[IsMatrixFLMLOR,IsList and IsEmpty],0,COM_FUN(29));
InstallMethod(RightIdealByGenerators,"for Gaussian matrix algebra and list of matrices",IsIdenticalObj,[IsMatrixFLMLOR and IsGaussianMatrixSpace,IsCollection and IsList],0,COM_FUN(30));
InstallMethod(RightIdealByGenerators,"for non-Gaussian matrix algebra and list of matrices",IsIdenticalObj,[IsMatrixFLMLOR and IsNonGaussianMatrixSpace,IsCollection and IsList],0,COM_FUN(31));
InstallMethod(RightIdealByGenerators,"for matrix algebra and empty list",true,[IsMatrixFLMLOR,IsList and IsEmpty],0,COM_FUN(32));
InstallMethod(IsUnit,"for matrix FLMLOR and matrix",IsCollsElms,[IsMatrixFLMLOR,IsMatrix],0,COM_FUN(33));
InstallMethod(RadicalOfAlgebra,"for associative Gaussian matrix algebra",true,[IsAlgebra and IsGaussianMatrixSpace and IsMatrixFLMLOR],0,COM_FUN(34));
CentralizerInAssociativeGaussianMatrixAlgebra:=COM_FUN(35);
InstallMethod(CentralizerOp,"for associative Gaussian matrix FLMLOR, and ordinary matrix",IsCollsElms,[IsMatrixFLMLOR and IsAssociative and IsGaussianSpace,IsOrdinaryMatrix],0,COM_FUN(36));
InstallMethod(CentralizerOp,"for associative Gaussian matrix FLMLOR, and FLMLOR",IsIdenticalObj,[IsMatrixFLMLOR and IsAssociative and IsGaussianSpace,IsMatrixFLMLOR],0,COM_FUN(37));
InstallMethod(CentralizerOp,"for associative Gaussian matrix FLMLOR-with-one, and ordinary matrix",IsCollsElms,[IsMatrixFLMLOR and IsFLMLORWithOne and IsAssociative and IsGaussianSpace,IsOrdinaryMatrix],0,COM_FUN(38));
InstallMethod(CentralizerOp,"for associative Gaussian matrix FLMLOR-with-one, and FLMLOR",IsIdenticalObj,[IsMatrixFLMLOR and IsFLMLORWithOne and IsAssociative and IsGaussianSpace,IsMatrixFLMLOR],0,COM_FUN(39));
InstallGlobalFunction(FullMatrixAlgebraCentralizer,COM_FUN(40));
InstallMethod(CentralizerOp,"for full (associative) matrix FLMLOR, and FLMLOR",IsIdenticalObj,[IsMatrixFLMLOR and IsFLMLORWithOne and IsAssociative and IsGaussianSpace and IsFullMatrixModule,IsMatrixFLMLOR],0,COM_FUN(41));
InstallMethod(CentralizerOp,"for full (associative) matrix FLMLOR, and left module",IsIdenticalObj,[IsMatrixFLMLOR and IsFLMLORWithOne and IsAssociative and IsGaussianSpace and IsFullMatrixModule,IsLeftModule],0,COM_FUN(42));
InstallMethod(CentralizerOp,"for full (associative) matrix FLMLOR, and list of matrices",IsIdenticalObj,[IsMatrixFLMLOR and IsFLMLORWithOne and IsAssociative and IsGaussianSpace and IsFullMatrixModule,IsCollection and IsList],0,COM_FUN(43));
InstallMethod(CentralizerOp,"for full (associative) matrix FLMLOR, and empty list",true,[IsMatrixFLMLOR and IsFullMatrixModule,IsList and IsEmpty],0,COM_FUN(44));
InstallGlobalFunction(FullMatrixFLMLOR,COM_FUN(45));
InstallGlobalFunction(FullMatrixLieFLMLOR,COM_FUN(46));
InstallOtherMethod(DirectSumOfAlgebras,"for two associative matrix FLMLORs",IsIdenticalObj,[IsMatrixFLMLOR and IsAssociative,IsMatrixFLMLOR and IsAssociative],0,COM_FUN(47));
InstallOtherMethod(DirectSumOfAlgebras,"for two matrix Lie FLMLORs",IsIdenticalObj,[IsMatrixFLMLOR and IsLieAlgebra,IsMatrixFLMLOR and IsLieAlgebra],0,COM_FUN(48));
InstallMethod(Units,"for a full matrix algebra (over a finite field)",[IsAlgebra and IsFullMatrixModule and IsFFECollCollColl],COM_FUN(49));
InstallGlobalFunction(EmptyMatrix,COM_FUN(50));
InstallMethod(\+,"for two empty matrices",IsIdenticalObj,[IsMatrix and IsEmpty,IsMatrix and IsEmpty],0,COM_FUN(51));
InstallOtherMethod(\*,"for two empty matrices",IsIdenticalObj,[IsMatrix and IsEmpty,IsMatrix and IsEmpty],0,COM_FUN(52));
InstallOtherMethod(\*,"for empty matrix, and empty list",true,[IsMatrix and IsEmpty,IsList and IsEmpty],0,COM_FUN(53));
InstallOtherMethod(\*,"for empty list, and empty matrix",true,[IsList and IsEmpty,IsMatrix and IsEmpty],0,COM_FUN(54));
InstallOtherMethod(\*,"for empty matrix, and ring element",true,[IsMatrix and IsEmpty,IsRingElement],0,COM_FUN(55));
InstallOtherMethod(\*,"for ring element, and empty matrix",true,[IsRingElement,IsMatrix and IsEmpty],0,COM_FUN(56));
InstallMethod(\^,"for empty matrix, and integer",true,[IsMatrix and IsEmpty,IsInt],0,COM_FUN(57));
InstallMethod(NullAlgebra,"for a ring",true,[IsRing],0,COM_FUN(58));
InstallMethod(RepresentativeLinearOperation,"for a matrix FLMLOR, two row vectors, and `OnRight'",IsCollCollsElmsElmsX,[IsMatrixFLMLOR,IsRowVector,IsRowVector,IsFunction],0,COM_FUN(59));
InstallMethod(RepresentativeLinearOperation,"for a matrix FLMLOR, two lists of row vectors, and `OnTuples'",IsCollsElmsElmsX,[IsFLMLOR,IsMatrix,IsMatrix,IsFunction],0,COM_FUN(60));
InstallMethod(IsomorphismMatrixFLMLOR,"for a matrix FLMLOR",true,[IsMatrixFLMLOR],0,IdentityMapping);
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/algmat.gi"

#F  file="lib/liefam.gi" crc=14813825
RANK_FILTER_LIST  := [ 51101810, 3, 32505857, 2, 64918210, 8, 42302964, 13, 
  32488978, 33, 42302964, 13, 42302964, 13, 42302964, 13, 42302964, 13, 
  42302964, 13, 42302964, 13, 42302964, 13, 64918210, 8, 64918210, 8, 
  42302964, 13, 42302964, 13, 42302964, 13, 42302964, 13, 64918210, 8, 
  64918210, 8, 42302964, 13, 42302964, 13, 42302964, 13, 42302964, 13, 
  64918210, 8, 64918210, 8, 42302964, 13, 42302964, 13, 52247917, 19, 
  42302964, 13, 41287156, 11, 41287156, 11, 42302964, 13, 32488978, 33, 
  52247917, 19, 32488978, 33, 32488978, 33, 52247917, 19, 32488978, 33, 
  65077940, 12, 17, 18, 30934767, 2, 1985, 1, 45987576, 10, 1, 0, 45987576, 
  10, 42302964, 13, 41287156, 11, 10477489, 26, 15466392, 16, 10477489, 26, 
  8193, 2, 41287156, 11, 8550844, 27, 8550844, 27, 1, 0, 8550844, 27, 1, 0, 
  20239680, 42, 15474584, 23, 20239680, 42, 15474584, 23, 20239680, 42, 
  15474584, 23, 20239680, 42, 41951068, 17, 20239680, 42, 41951068, 17, 
  20239680, 42, 41951068, 17 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/liefam.gi", 14813825 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/liefam.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/liefam.gi");
elif COM_RESULT = 3  then
Revision.liefam_gi:="@(#)$Id: liefam.gi,v 4.28 2002/04/15 10:04:54 sal Exp $";
InstallMethod(LieFamily,"for family of ring elements",true,[IsRingElementFamily],0,COM_FUN(1));
InstallMethod(LieFamily,"for a collections family (special case of Lie matrices)",true,[IsCollectionFamily],0,COM_FUN(2));
InstallMethod(LieObject,"for a ring element",true,[IsRingElement],0,COM_FUN(3));
InstallMethod(PrintObj,"for a Lie object in default representation",true,[IsLieObject and IsPackedElementDefaultRep],SUM_FLAGS,COM_FUN(4));
InstallMethod(ViewObj,"for a Lie matrix in default representation",true,[IsLieMatrix and IsPackedElementDefaultRep],SUM_FLAGS,COM_FUN(5));
InstallMethod(\=,"for two Lie objects in default representation",IsIdenticalObj,[IsLieObject and IsPackedElementDefaultRep,IsLieObject and IsPackedElementDefaultRep],0,COM_FUN(6));
InstallMethod(\<,"for two Lie objects in default representation",IsIdenticalObj,[IsLieObject and IsPackedElementDefaultRep,IsLieObject and IsPackedElementDefaultRep],0,COM_FUN(7));
InstallMethod(\+,"for two Lie objects in default representation",IsIdenticalObj,[IsLieObject and IsPackedElementDefaultRep,IsLieObject and IsPackedElementDefaultRep],0,COM_FUN(8));
InstallMethod(\+,"for Lie object in default representation, and ring element",true,[IsLieObject and IsPackedElementDefaultRep,IsRingElement],0,COM_FUN(9));
InstallMethod(\+,"for ring element, and Lie object in default representation",true,[IsRingElement,IsLieObject and IsPackedElementDefaultRep],0,COM_FUN(10));
InstallMethod(\-,"for two Lie objects in default representation",IsIdenticalObj,[IsLieObject and IsPackedElementDefaultRep,IsLieObject and IsPackedElementDefaultRep],0,COM_FUN(11));
InstallMethod(\-,"for Lie object in default representation, and ring element",true,[IsLieObject and IsPackedElementDefaultRep,IsRingElement],0,COM_FUN(12));
InstallMethod(\-,"for ring element, and Lie object in default representation",true,[IsRingElement,IsLieObject and IsPackedElementDefaultRep],0,COM_FUN(13));
InstallMethod(\*,"for two Lie objects in default representation",IsIdenticalObj,[IsLieObject and IsPackedElementDefaultRep,IsLieObject and IsPackedElementDefaultRep],0,COM_FUN(14));
InstallMethod(\*,"for Lie object in default representation, and ring element",true,[IsLieObject and IsPackedElementDefaultRep,IsRingElement],0,COM_FUN(15));
InstallMethod(\*,"for ring element, and Lie object in default representation",true,[IsRingElement,IsLieObject and IsPackedElementDefaultRep],0,COM_FUN(16));
InstallMethod(\^,"for Lie object in default representation, and positive integer",true,[IsLieObject and IsPackedElementDefaultRep,IsPosInt],0,COM_FUN(17));
InstallMethod(ZeroOp,"for Lie object in default representation",true,[IsLieObject and IsPackedElementDefaultRep],SUM_FLAGS,COM_FUN(18));
InstallOtherMethod(OneOp,"for Lie object",true,[IsLieObject],0,ReturnFail);
InstallOtherMethod(InverseOp,"for Lie object",true,[IsLieObject],0,ReturnFail);
InstallMethod(AdditiveInverseOp,"for Lie object in default representation",true,[IsLieObject and IsPackedElementDefaultRep],0,COM_FUN(19));
InstallMethod(\[\],"for Lie matrix in default representation, and positive integer",true,[IsLieMatrix and IsPackedElementDefaultRep,IsPosInt],0,COM_FUN(20));
InstallMethod(Length,"for Lie matrix in default representation",true,[IsLieMatrix and IsPackedElementDefaultRep],0,COM_FUN(21));
InstallMethod(IsBound\[\],"for Lie matrix in default representation, and integer",true,[IsLieMatrix and IsPackedElementDefaultRep,IsPosInt],0,COM_FUN(22));
InstallMethod(Position,"for Lie matrix in default representation, row vector, and integer",true,[IsLieMatrix and IsPackedElementDefaultRep,IsRowVector,IsInt],0,COM_FUN(23));
DeclareRepresentation("IsLieEmbeddingRep",IsAttributeStoringRep,["packedType"]);
InstallOtherMethod(Embedding,"for two families, the first with known Lie family",true,[IsFamily and HasLieFamily,IsFamily],0,COM_FUN(24));
InstallMethod(ImagesElm,"for Lie embedding and object",FamSourceEqFamElm,[IsGeneralMapping and IsLieEmbeddingRep,IsObject],0,COM_FUN(25));
InstallMethod(PreImagesElm,"for Lie embedding and Lie object in default representation",FamRangeEqFamElm,[IsGeneralMapping and IsLieEmbeddingRep,IsLieObject and IsPackedElementDefaultRep],0,COM_FUN(26));
InstallOtherMethod(IsUnit,"for a Lie object (return `false')",true,[IsLieObject],0,ReturnFalse);
InstallMethod(MutableBasis,"for ring and collection of Lie elements",COM_FUN(27),[IsRing,IsLieObjectCollection],0,MutableBasisViaNiceMutableBasisMethod2);
InstallOtherMethod(MutableBasis,"for ring, (possibly empty) list, and Lie zero",COM_FUN(28),[IsRing,IsList,IsLieObject],0,MutableBasisViaNiceMutableBasisMethod3);
InstallHandlingByNiceBasis("IsLieObjectsModule",rec(detect:=COM_FUN(29),NiceFreeLeftModuleInfo:=ReturnFalse,NiceVector:=COM_FUN(30),UglyVector:=COM_FUN(31)));
IdealByGeneratorsForLieAlgebra:=COM_FUN(32);
InstallMethod(TwoSidedIdealByGenerators,"for Lie algebra and collection of Lie objects",IsIdenticalObj,[IsLieAlgebra,IsLieObjectCollection and IsList],0,IdealByGeneratorsForLieAlgebra);
InstallMethod(LeftIdealByGenerators,"for Lie algebra and collection of Lie objects",IsIdenticalObj,[IsLieAlgebra,IsLieObjectCollection and IsList],0,IdealByGeneratorsForLieAlgebra);
InstallMethod(RightIdealByGenerators,"for Lie algebra and collection of Lie objects",IsIdenticalObj,[IsLieAlgebra,IsLieObjectCollection and IsList],0,IdealByGeneratorsForLieAlgebra);
InstallMethod(TwoSidedIdealByGenerators,"for Lie algebra and empty list",true,[IsLieAlgebra,IsList and IsEmpty],0,IdealByGeneratorsForLieAlgebra);
InstallMethod(LeftIdealByGenerators,"for Lie algebra and empty list",true,[IsLieAlgebra,IsList and IsEmpty],0,IdealByGeneratorsForLieAlgebra);
InstallMethod(RightIdealByGenerators,"for Lie algebra and empty list",true,[IsLieAlgebra,IsList and IsEmpty],0,IdealByGeneratorsForLieAlgebra);
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/liefam.gi"

#F  file="lib/algrep.gi" crc=82994859
RANK_FILTER_LIST  := [ 51450867, 27, 51450867, 27, 26181048, 10, 33553998, 2, 
  1, 0, 11576548, 36, 5, 1, 32769, 4, 11576548, 36, 5, 1, 32769, 4, 67108760, 
  5, 11576548, 36, 5, 1, 32769, 4, 11576548, 36, 5, 1, 32769, 4, 67108760, 5, 
  11576548, 36, 11576548, 36, 5, 1, 5, 1, 32769, 4, 11576548, 36, 11576548, 
  36, 5, 1, 5, 1, 32769, 4, 67108760, 5, 11576548, 36, 5, 1, 23269910, 25, 
  11576548, 36, 5, 1, 23269910, 25, 11576548, 36, 11576548, 36, 5, 1, 5, 1, 
  23269910, 25, 10477489, 26, 50331439, 13, 10477489, 26, 8193, 2, 25165240, 
  8, 1670404, 3, 1670404, 3, 1670405, 5, 63198130, 7, 1670405, 5, 63198130, 
  7, 28180958, 24, 26181048, 10, 26181048, 10, 26181048, 10, 26181048, 10, 
  26181048, 10, 26181048, 10, 26181048, 10, 26181048, 10, 63198130, 7, 
  63198130, 7, 26181048, 10, 26181048, 10, 26181048, 10, 30625149, 10, 
  30625149, 10, 26181048, 10, 26181048, 10, 42302964, 13, 65077940, 12, 
  65077940, 12, 42302964, 13, 64918210, 8, 1014924, 11, 63513701, 11, 
  64918210, 8, 57704101, 25, 12745703, 28, 63953863, 8, 26181048, 10, 
  12745703, 28, 50339631, 20, 12745703, 28, 50339631, 20, 12745703, 28, 
  12745703, 28, 57704101, 25, 50339631, 20, 57704101, 25, 50339631, 20, 
  67108760, 5, 11576548, 36, 59494340, 21, 11576548, 36, 59494340, 21, 
  11576548, 36, 11576548, 36, 28180958, 24, 11576548, 36, 28180958, 24, 
  11576548, 36, 11576548, 36, 28180958, 24, 28180958, 24, 51450867, 27, 
  8126465, 2, 51450867, 27, 28180958, 24, 63953863, 8, 1, 0, 63953863, 8, 1, 
  0, 1, 0, 33275455, 2, 8193, 2, 28437224, 10, 28437224, 10, 28437224, 10, 
  28437224, 10, 28437224, 10, 28437224, 10, 64918210, 8, 64918210, 8, 
  28437224, 10, 28437224, 10, 28437224, 10, 28437224, 10, 28437224, 10, 
  46160391, 28, 16645440, 20, 46160391, 28, 16645440, 20, 46160391, 28, 
  57039061, 9, 28437224, 10, 53115549, 11, 66550909, 9, 16385, 3, 23269910, 
  25, 23269910, 25, 16385, 3, 28180958, 24, 28180958, 24, 51444516, 11, 
  64879876, 9, 65147699, 22, 17, 18, 28180958, 24, 17, 18, 44760384, 11, 
  58195744, 9, 65147699, 22, 17, 18, 28180958, 24, 17, 18, 67108175, 2, 8193, 
  2, 51346572, 10, 50330764, 8, 51346572, 10, 51346572, 10, 51346572, 10, 
  51346572, 10, 51346572, 10, 64918210, 8, 64918210, 8, 51346572, 10, 
  51346572, 10, 51346572, 10, 51346572, 10, 51346572, 10, 63076751, 28, 
  32769, 4, 63076751, 28, 32769, 4, 63076751, 28, 30169301, 9, 50330764, 8, 
  10477489, 26, 17, 18, 32472144, 10, 58719342, 2, 8193, 2, 32472144, 10, 
  32472144, 10, 32472144, 10, 32472144, 10, 32472144, 10, 32472144, 10, 
  64918210, 8, 64918210, 8, 32472144, 10, 32472144, 10, 32472144, 10, 
  32472144, 10, 32472144, 10, 29522694, 27, 29522694, 27, 1, 0, 29522694, 27, 
  1, 0, 16385, 3, 28180958, 24, 28180958, 24, 28180958, 24, 29523144, 23, 
  29523144, 23 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/algrep.gi", 82994859 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/algrep.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/algrep.gi");
elif COM_RESULT = 3  then
Revision.algrep_gi:="@(#)$Id: algrep.gi,v 4.31.2.1 2004/05/15 00:28:44 gap Exp $";
InstallMethod(PrintObj,"for algebra module",true,[IsVectorSpace and IsAlgebraModule],0,COM_FUN(1));
InstallMethod(ViewObj,"for algebra module",true,[IsVectorSpace and IsAlgebraModule],0,COM_FUN(2));
InstallMethod(ExtRepOfObj,"for algebra module element in packed element rep",true,[IsAlgebraModuleElement and IsPackedElementDefaultRep],0,COM_FUN(3));
InstallMethod(ObjByExtRep,"for algebra module elements family, object",true,[IsAlgebraModuleElementFamily,IsObject],0,COM_FUN(4));
BindGlobal("BasisOfAlgebraModule",COM_FUN(5));
InstallMethod(LeftAlgebraModuleByGenerators,"for algebra, function of 2 args, module generators",true,[IsAlgebra,IS_FUNCTION,IsHomogeneousList],0,COM_FUN(6));
InstallOtherMethod(LeftAlgebraModuleByGenerators,"for algebra, function of 2 args, generators, string",true,[IsAlgebra,IS_FUNCTION,IsHomogeneousList,IsString],0,COM_FUN(7));
InstallMethod(RightAlgebraModuleByGenerators,"for algebra, function of 2 args, module generators",true,[IsAlgebra,IS_FUNCTION,IsHomogeneousList],0,COM_FUN(8));
InstallOtherMethod(RightAlgebraModuleByGenerators,"for algebra, function of 2 args, generators, string",true,[IsAlgebra,IS_FUNCTION,IsHomogeneousList,IsString],0,COM_FUN(9));
InstallMethod(BiAlgebraModuleByGenerators,"for 2 algebras, function of 2 args, function of 2 args, module generators",true,[IsAlgebra,IsAlgebra,IS_FUNCTION,IS_FUNCTION,IsHomogeneousList],0,COM_FUN(10));
InstallOtherMethod(BiAlgebraModuleByGenerators,"for 2 algebras, function of 2 args, function of 2 args, generators, string",true,[IsAlgebra,IsAlgebra,IS_FUNCTION,IS_FUNCTION,IsHomogeneousList,IsString],0,COM_FUN(11));
InstallMethod(LeftAlgebraModule,"for algebra, function of 2 args, underlying space",true,[IsAlgebra,IS_FUNCTION,IsVectorSpace],0,COM_FUN(12));
InstallMethod(RightAlgebraModule,"for algebra, function of 2 args, underlying space",true,[IsAlgebra,IS_FUNCTION,IsVectorSpace],0,COM_FUN(13));
InstallMethod(BiAlgebraModule,"for 2 algebras, function of 2 args, function of 2 args, module generators",true,[IsAlgebra,IsAlgebra,IS_FUNCTION,IS_FUNCTION,IsVectorSpace],0,COM_FUN(14));
DeclareRepresentation("IsMutableBasisViaUnderlyingMutableBasisRep",IsComponentObjectRep,["moduleElementsFam","underlyingMutableBasis"]);
InstallMethod(MutableBasis,"for ring and vectors",true,[IsRing,IsAlgebraModuleElementCollection],0,COM_FUN(15));
InstallOtherMethod(MutableBasis,"for ring, list and zero",true,[IsRing,IsList,IsAlgebraModuleElement],0,COM_FUN(16));
InstallMethod(PrintObj,"for mutable basis with underlying mutable basis",true,[IsMutableBasis and IsMutableBasisViaUnderlyingMutableBasisRep],0,COM_FUN(17));
InstallOtherMethod(BasisVectors,"for mutable basis with underlying mutable basis",true,[IsMutableBasis and IsMutableBasisViaUnderlyingMutableBasisRep],0,COM_FUN(18));
InstallMethod(CloseMutableBasis,"for mutable basis with underlying mutable basis, and vector",IsCollsElms,[IsMutableBasis and IsMutable and IsMutableBasisViaUnderlyingMutableBasisRep,IsVector],0,COM_FUN(19));
InstallMethod(IsContainedInSpan,"for mutable basis with underlying mutable basis, and vector",IsCollsElms,[IsMutableBasis and IsMutable and IsMutableBasisViaUnderlyingMutableBasisRep,IsVector],0,COM_FUN(20));
InstallMethod(ActingAlgebra,"for an algebra module",true,[IsAlgebraModule],0,COM_FUN(21));
InstallMethod(PrintObj,"for algebra module element in packed representation",true,[IsAlgebraModuleElement and IsPackedElementDefaultRep],0,COM_FUN(22));
InstallMethod(\=,"for two algebra module elements in packed representation",IsIdenticalObj,[IsAlgebraModuleElement and IsPackedElementDefaultRep,IsAlgebraModuleElement and IsPackedElementDefaultRep],0,COM_FUN(23));
InstallMethod(\<,"for two algebra module elements in packed representation",IsIdenticalObj,[IsAlgebraModuleElement and IsPackedElementDefaultRep,IsAlgebraModuleElement and IsPackedElementDefaultRep],0,COM_FUN(24));
InstallMethod(\+,"for two algebra module elements in packed representation",IsIdenticalObj,[IsAlgebraModuleElement and IsPackedElementDefaultRep,IsAlgebraModuleElement and IsPackedElementDefaultRep],0,COM_FUN(25));
InstallMethod(\+,"for an algebra module element in packed representation and a vector",true,[IsAlgebraModuleElement and IsPackedElementDefaultRep,IsVector],0,COM_FUN(26));
InstallMethod(\+,"for a vector and an algebra module element in packed representation",true,[IsVector,IsAlgebraModuleElement and IsPackedElementDefaultRep],0,COM_FUN(27));
InstallMethod(AdditiveInverseOp,"for an algebra module element in packed representation",true,[IsAlgebraModuleElement and IsPackedElementDefaultRep],0,COM_FUN(28));
InstallMethod(\*,"for an algebra module element in packed representation and a scalar",true,[IsAlgebraModuleElement and IsPackedElementDefaultRep,IsScalar],0,COM_FUN(29));
InstallMethod(\*,"for a scalar and an algebra module element in packed representation",true,[IsScalar,IsAlgebraModuleElement and IsPackedElementDefaultRep],0,COM_FUN(30));
InstallMethod(ZeroOp,"for an algebra module element in packed representation",true,[IsAlgebraModuleElement and IsPackedElementDefaultRep],0,COM_FUN(31));
InstallMethod(\*,"for Lie object and row vector",true,[IsLieObject and IsPackedElementDefaultRep,IsRowVector],0,COM_FUN(32));
InstallMethod(\*,"for row vector and Lie object",true,[IsRowVector,IsLieObject and IsPackedElementDefaultRep],0,COM_FUN(33));
InstallOtherMethod(\^,"for an algebra element and an element of an algebra module",COM_FUN(34),[IsRingElement,IsLeftAlgebraModuleElement and IsPackedElementDefaultRep],0,COM_FUN(35));
InstallOtherMethod(\^,"for an algebra element and an element of an algebra module",COM_FUN(36),[IsRightAlgebraModuleElement and IsPackedElementDefaultRep,IsRingElement],0,COM_FUN(37));
InstallMethod(Basis,"for an algebra module",true,[IsFreeLeftModule and IsAlgebraModule],0,COM_FUN(38));
InstallMethod(Basis,"for a space of algebra module elements",true,[IsFreeLeftModule and IsAlgebraModuleElementCollection],0,COM_FUN(39));
InstallMethod(Coefficients,"for basis of a space of algebra module elements, and algebra module element",true,[IsBasisOfAlgebraModuleElementSpace,IsAlgebraModuleElement and IsPackedElementDefaultRep],0,COM_FUN(40));
InstallMethod(Basis,"for a space of algebra module elements and a collection of algebra module el\
ements",IsIdenticalObj,[IsFreeLeftModule and IsAlgebraModuleElementCollection,IsAlgebraModuleElementCollection and IsList],0,COM_FUN(41));
InstallMethod(BasisNC,"for a space of algebra module elements and a collection of algebra module el\
ements",IsIdenticalObj,[IsFreeLeftModule and IsAlgebraModuleElementCollection,IsAlgebraModuleElementCollection and IsList],0,COM_FUN(42));
InstallMethod(IsFiniteDimensional,"for a space of algebra module elements",true,[IsFreeLeftModule and IsAlgebraModuleElementCollection],0,COM_FUN(43));
InstallMethod(GeneratorsOfLeftModule,"for a space of algebra module elements",true,[IsFreeLeftModule and IsAlgebraModuleElementCollection],0,COM_FUN(44));
InstallMethod(SubAlgebraModule,"for algebra module, and a list of submodule generators",IsIdenticalObj,[IsFreeLeftModule and IsAlgebraModule,IsAlgebraModuleElementCollection and IsList],0,COM_FUN(45));
InstallOtherMethod(SubAlgebraModule,"for algebra module, and a list of submodule generators, and string",COM_FUN(46),[IsFreeLeftModule and IsAlgebraModule,IsAlgebraModuleElementCollection and IsList,IsString],0,COM_FUN(47));
InstallMethod(LeftModuleByHomomorphismToMatAlg,"for an algebra and a homomorphism to a matrix algebra",true,[IsAlgebra,IsAlgebraHomomorphism],0,COM_FUN(48));
InstallMethod(RightModuleByHomomorphismToMatAlg,"for an algebra and a homomorphism to a matrix algebra",true,[IsAlgebra,IsAlgebraHomomorphism],0,COM_FUN(49));
InstallMethod(AdjointModule,"for an algebra",true,[IsAlgebra],0,COM_FUN(50));
InstallMethod(FaithfulModule,"for an algebra",true,[IsAlgebra],0,COM_FUN(51));
InstallMethod(ModuleByRestriction,"for an algebra module and a subalgebra",true,[IsAlgebraModule,IsAlgebra],0,COM_FUN(52));
InstallOtherMethod(ModuleByRestriction,"for a bi-algebra module and a subalgebra and a subalgebra",true,[IsAlgebraModule,IsAlgebra,IsAlgebra],0,COM_FUN(53));
InstallMethod(NaturalHomomorphismBySubAlgebraModule,"for algebra module and a submodule",IsIdenticalObj,[IsAlgebraModule,IsAlgebraModule],0,COM_FUN(54));
InstallOtherMethod(\/,"for an algebra module and collection",IsIdenticalObj,[IsVectorSpace and IsAlgebraModule,IsCollection],0,COM_FUN(55));
InstallOtherMethod(\/,"for two algebra modules",IsIdenticalObj,[IsVectorSpace and IsAlgebraModule,IsAlgebraModule],0,COM_FUN(56));
InstallMethod(MatrixOfAction,"for a basis of an algebra module and an algebra element",true,[IsBasisOfAlgebraModuleElementSpace,IsObject],0,COM_FUN(57));
InstallOtherMethod(MatrixOfAction,"for a basis of an algebra module, an algebra element and a side",true,[IsBasisOfAlgebraModuleElementSpace,IsObject,IsObject],0,COM_FUN(58));
DeclareRepresentation("IsMonomialElementRep",IsPositionalObjectRep,[1,2]);
InstallMethod(ObjByExtRep,"for a family of monomial elements and a list",true,[IsMonomialElementFamily,IsList],0,COM_FUN(59));
InstallMethod(ExtRepOfObj,"for a monomial element",true,[IsMonomialElement and IsMonomialElementRep],0,COM_FUN(60));
InstallMethod(ZeroOp,"for monomial elements",true,[IsMonomialElement and IsMonomialElementRep],0,COM_FUN(61));
InstallMethod(\+,"for monomial elements",IsIdenticalObj,[IsMonomialElement and IsMonomialElementRep,IsMonomialElement and IsMonomialElementRep],0,COM_FUN(62));
InstallMethod(AdditiveInverseOp,"for a monomial element",true,[IsMonomialElement and IsMonomialElementRep],0,COM_FUN(63));
InstallMethod(\*,"for a monomial element and a scalar",true,[IsMonomialElement and IsMonomialElementRep,IsRingElement],0,COM_FUN(64));
InstallMethod(\*,"for a scalar and a monomial element",true,[IsRingElement,IsMonomialElement and IsMonomialElementRep],0,COM_FUN(65));
InstallMethod(\<,"for monomial elements",IsIdenticalObj,[IsMonomialElement and IsMonomialElementRep,IsMonomialElement and IsMonomialElementRep],0,COM_FUN(66));
InstallMethod(\=,"for monomial elements",IsIdenticalObj,[IsMonomialElement and IsMonomialElementRep,IsMonomialElement and IsMonomialElementRep],0,COM_FUN(67));
TriangulizeMonomialElementList:=COM_FUN(68);
DeclareRepresentation("IsBasisOfMonomialSpaceRep",IsComponentObjectRep,["echelonBasis","heads","baseChange","zeroCoefficient"]);
BindGlobal("BasisOfMonomialSpace",COM_FUN(69));
InstallMethod(Basis,"for a space of monomial elements and a list of tensor elements",IsIdenticalObj,[IsFreeLeftModule and IsMonomialElementCollection,IsMonomialElementCollection and IsList],SUM_FLAGS,COM_FUN(70));
InstallMethod(BasisNC,"for a space of monomial elements and a list of monomial elements",IsIdenticalObj,[IsFreeLeftModule and IsMonomialElementCollection,IsMonomialElementCollection and IsList],SUM_FLAGS,COM_FUN(71));
InstallMethod(Basis,"for a space of monomial elements",true,[IsFreeLeftModule and IsMonomialElementCollection],SUM_FLAGS,COM_FUN(72));
InstallMethod(Coefficients,"for basis of a monomial space, and a vector",IsCollsElms,[IsBasis and IsBasisOfMonomialSpaceRep,IsMonomialElement and IsMonomialElementRep],SUM_FLAGS,COM_FUN(73));
InstallMethod(PrintObj,"for tensor elements",true,[IsTensorElement and IsMonomialElementRep],0,COM_FUN(74));
InstallMethod(ConvertToNormalFormMonomialElement,"for a tensor element",true,[IsTensorElement],0,COM_FUN(75));
InstallMethod(TensorProduct,"for a list of finite dimensional vector spaces",true,[IsDenseList],0,COM_FUN(76));
InstallOtherMethod(TensorProduct,"for two vector spaces",true,[IsVectorSpace,IsVectorSpace],0,COM_FUN(77));
InstallMethod(TensorProductOfAlgebraModules,"for a list of algebra modules",true,[IsDenseList],0,COM_FUN(78));
InstallOtherMethod(TensorProductOfAlgebraModules,"for two algebra modules",true,[IsAlgebraModule,IsAlgebraModule],0,COM_FUN(79));
InstallMethod(PrintObj,"for wedge elements",true,[IsWedgeElement and IsMonomialElementRep],0,COM_FUN(80));
InstallMethod(ConvertToNormalFormMonomialElement,"for a wedge element",true,[IsWedgeElement],0,COM_FUN(81));
InstallMethod(ExteriorPower,"for a vector space and an integer",true,[IsLeftModule,IsInt],0,COM_FUN(82));
InstallMethod(ExteriorPowerOfAlgebraModule,"for an algebra module and an integer",true,[IsAlgebraModule,IsInt],0,COM_FUN(83));
InstallMethod(PrintObj,"for symmetric elements",true,[IsSymmetricPowerElement and IsMonomialElementRep],0,COM_FUN(84));
InstallMethod(ConvertToNormalFormMonomialElement,"for a symmetric element",true,[IsSymmetricPowerElement],0,COM_FUN(85));
InstallMethod(SymmetricPower,"for an algebra module and an integer",true,[IsLeftModule,IsInt],0,COM_FUN(86));
InstallMethod(SymmetricPowerOfAlgebraModule,"for an algebra module and an integer",true,[IsAlgebraModule,IsInt],0,COM_FUN(87));
InstallMethod(ObjByExtRep,"for a sparse rowspace element family and a list",true,[IsSparseRowSpaceElementFamily,IsList],0,COM_FUN(88));
InstallMethod(ExtRepOfObj,"for a sparse rowspace element",true,[IsSparseRowSpaceElement and IsPackedElementDefaultRep],0,COM_FUN(89));
InstallMethod(PrintObj,"for a sparse rowspace element",true,[IsSparseRowSpaceElement],0,COM_FUN(90));
InstallMethod(ZeroOp,"for sparse rowspace elements",true,[IsSparseRowSpaceElement and IsPackedElementDefaultRep],0,COM_FUN(91));
InstallMethod(\+,"for sparse rowspace elements",IsIdenticalObj,[IsSparseRowSpaceElement and IsPackedElementDefaultRep,IsSparseRowSpaceElement and IsPackedElementDefaultRep],0,COM_FUN(92));
InstallMethod(AdditiveInverseOp,"for a sparse rowspace element",true,[IsSparseRowSpaceElement and IsPackedElementDefaultRep],0,COM_FUN(93));
InstallMethod(\*,"for a sparse rowspace element and a scalar",true,[IsSparseRowSpaceElement and IsPackedElementDefaultRep,IsRingElement],0,COM_FUN(94));
InstallMethod(\*,"for a scalar and a sparse rowspace element",true,[IsRingElement,IsSparseRowSpaceElement and IsPackedElementDefaultRep],0,COM_FUN(95));
InstallMethod(\<,"for sparse rowspace elements",IsIdenticalObj,[IsSparseRowSpaceElement and IsPackedElementDefaultRep,IsSparseRowSpaceElement and IsPackedElementDefaultRep],0,COM_FUN(96));
InstallMethod(\=,"for sparse rowspace elements",IsIdenticalObj,[IsSparseRowSpaceElement and IsPackedElementDefaultRep,IsSparseRowSpaceElement and IsPackedElementDefaultRep],0,COM_FUN(97));
DeclareRepresentation("IsBasisOfSparseRowSpaceRep",IsComponentObjectRep,["echelonBasis","heads","baseChange","zeroCoefficient"]);
BindGlobal("BasisOfSparseRowSpace",COM_FUN(98));
InstallMethod(Basis,"for a free module of sparse row space elements, and list",true,[IsFreeLeftModule and IsSparseRowSpaceElementCollection,IsHomogeneousList],SUM_FLAGS,COM_FUN(99));
InstallMethod(BasisNC,"for a free module of sparse row space elements, and list",true,[IsFreeLeftModule and IsSparseRowSpaceElementCollection,IsHomogeneousList],SUM_FLAGS,COM_FUN(100));
InstallMethod(Basis,"for a free module of sparse row space elements",true,[IsFreeLeftModule and IsSparseRowSpaceElementCollection],SUM_FLAGS,COM_FUN(101));
InstallMethod(Coefficients,"for basis of a sparse rowspace, and a vector",IsCollsElms,[IsBasis and IsBasisOfSparseRowSpaceRep,IsSparseRowSpaceElement],SUM_FLAGS,COM_FUN(102));
InstallMethod(FullSparseRowSpace,"for a ring and an integer",true,[IsRing,IsInt],0,COM_FUN(103));
InstallMethod(PrintObj,"for direct sum elements",true,[IsDirectSumElement and IsPackedElementDefaultRep],0,COM_FUN(104));
InstallMethod(ObjByExtRep,"for a family of direct sum elements and a list",true,[IsDirectSumElementFamily,IsList],0,COM_FUN(105));
InstallMethod(ExtRepOfObj,"for a direct sum element",true,[IsDirectSumElement and IsPackedElementDefaultRep],0,COM_FUN(106));
InstallMethod(ZeroOp,"for direct sum elements",true,[IsDirectSumElement and IsPackedElementDefaultRep],0,COM_FUN(107));
InstallMethod(\+,"for direct sum elements",IsIdenticalObj,[IsDirectSumElement and IsPackedElementDefaultRep,IsDirectSumElement and IsPackedElementDefaultRep],0,COM_FUN(108));
InstallMethod(AdditiveInverseOp,"for a direct sum element",true,[IsDirectSumElement and IsPackedElementDefaultRep],0,COM_FUN(109));
InstallMethod(\*,"for a direct sum element and a scalar",true,[IsDirectSumElement and IsPackedElementDefaultRep,IsRingElement],0,COM_FUN(110));
InstallMethod(\*,"for a direct sum element and a scalar",true,[IsRingElement,IsDirectSumElement and IsPackedElementDefaultRep],0,COM_FUN(111));
InstallMethod(\<,"for direct sum elements",IsIdenticalObj,[IsDirectSumElement and IsPackedElementDefaultRep,IsDirectSumElement and IsPackedElementDefaultRep],0,COM_FUN(112));
InstallMethod(\=,"for direct sum elements",IsIdenticalObj,[IsDirectSumElement and IsPackedElementDefaultRep,IsDirectSumElement and IsPackedElementDefaultRep],0,COM_FUN(113));
InstallHandlingByNiceBasis("IsDirectSumElementsSpace",rec(detect:=COM_FUN(114),NiceFreeLeftModuleInfo:=ReturnFalse,NiceVector:=COM_FUN(115),UglyVector:=COM_FUN(116)));
InstallMethod(DirectSumOfAlgebraModules,"for a list of algebra modules",true,[IsDenseList],0,COM_FUN(117));
InstallOtherMethod(DirectSumOfAlgebraModules,"for two algebra modules",true,[IsAlgebraModule,IsAlgebraModule],0,COM_FUN(118));
InstallMethod(TranslatorSubalgebra,"for an algebra, an algebra module and two subspaces",true,[IsAlgebraModule,IsFreeLeftModule,IsFreeLeftModule],0,COM_FUN(119));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/algrep.gi"

#F  file="lib/lierep.gi" crc=-88873740
RANK_FILTER_LIST  := [ 28180958, 24, 17, 18, 1, 0, 1014909, 10, 67107980, 8, 
  28180958, 24, 17, 18, 1014909, 10, 1014909, 10, 26736859, 11, 26736859, 11, 
  1014909, 10, 26736859, 11, 30625149, 10, 1014909, 10, 38630566, 12, 
  1014909, 10, 30625149, 10, 26736859, 11, 1014909, 10, 30625149, 10, 
  1014909, 10, 38630566, 12, 26736859, 11, 30625149, 10, 1014909, 10, 
  1014909, 10, 1014909, 10, 1014909, 10, 1014909, 10, 26736859, 11, 52391236, 
  27, 52391236, 27, 1, 0, 52391236, 27, 1, 0, 28180958, 24, 17, 18, 28180958, 
  24, 17, 18, 13106691, 1, 8193, 2, 17, 18, 8193, 2, 23619395, 23, 23619395, 
  23, 8193, 2, 23619395, 23, 8193, 2, 23619395, 23, 8193, 2, 13106691, 1, 
  13106691, 1, 8193, 2, 26214341, 2, 13106691, 1, 8193, 2, 20239680, 42, 
  8193, 2, 20239680, 42, 8193, 2, 8193, 2, 20239680, 42, 8193, 2, 63271799, 
  4, 8193, 2, 49372390, 10, 50388198, 12, 50388198, 12, 50388198, 12, 
  50388198, 12, 50388198, 12, 50388198, 12, 50388198, 12, 50388198, 12, 
  50388198, 12, 50388198, 12, 30625149, 10, 50388198, 12, 50388198, 12, 
  30625149, 10, 50388198, 12, 50388198, 12, 53476477, 5, 32769, 4, 1, 0, 
  53476477, 5, 32769, 4, 24366370, 2, 53476477, 5, 20239680, 42, 17, 18, 
  49372390, 10, 5716544, 2, 8193, 2, 52776364, 10, 52776364, 10, 52776364, 
  10, 52776364, 10, 52776364, 10, 52776364, 10, 64918210, 8, 64918210, 8, 
  52776364, 10, 52776364, 10, 52776364, 10, 52776364, 10, 52776364, 10, 
  52776364, 10, 64918210, 8, 52776364, 10, 65935375, 28, 36420424, 20, 
  65935375, 28, 36420424, 20, 65935375, 28, 11434047, 8, 52776364, 10, 
  20239680, 42, 8193, 2, 20239680, 42 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/lierep.gi", -88873740 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/lierep.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/lierep.gi");
elif COM_RESULT = 3  then
Revision.lierep_gi:="@(#)$Id: lierep.gi,v 4.35 2003/09/30 13:25:41 gap Exp $";
DeclareRepresentation("IsZeroCochainRep",IsPackedElementDefaultRep,[1]);
InstallMethod(Cochain,"for a module over a Lie algebra, an integer and an object",true,[IsAlgebraModule,IsInt,IsObject],0,COM_FUN(1));
InstallMethod(ExtRepOfObj,"for a cochain",true,[IsCochain and IsPackedElementDefaultRep],0,COM_FUN(2));
InstallMethod(PrintObj,"for a cochain",true,[IsCochain],0,COM_FUN(3));
InstallMethod(CochainSpace,"for a module over a Lie algebra and an integer",true,[IsAlgebraModule,IS_INT],0,COM_FUN(4));
InstallMethod(\+,"for two cochains",IsIdenticalObj,[IsCochain and IsPackedElementDefaultRep,IsCochain and IsPackedElementDefaultRep],0,COM_FUN(5));
InstallMethod(\+,"for two 0-cochains",IsIdenticalObj,[IsCochain and IsZeroCochainRep,IsCochain and IsZeroCochainRep],0,COM_FUN(6));
InstallMethod(AdditiveInverseOp,"for a cochain",true,[IsCochain and IsPackedElementDefaultRep],0,COM_FUN(7));
InstallMethod(AdditiveInverseOp,"for a 0-cochain",true,[IsCochain and IsZeroCochainRep],0,COM_FUN(8));
InstallMethod(\*,"for scalar and cochain",true,[IsScalar,IsCochain and IsPackedElementDefaultRep],0,COM_FUN(9));
InstallMethod(\*,"for scalar and cochain",true,[IsScalar and IsZero,IsCochain and IsPackedElementDefaultRep],0,COM_FUN(10));
InstallMethod(\*,"for scalar and 0-cochain",true,[IsScalar,IsCochain and IsZeroCochainRep],0,COM_FUN(11));
InstallMethod(\*,"for cochain and scalar",true,[IsCochain and IsPackedElementDefaultRep,IsScalar],0,COM_FUN(12));
InstallMethod(\*,"for cochain and scalar",true,[IsCochain and IsPackedElementDefaultRep,IsScalar and IsZero],0,COM_FUN(13));
InstallMethod(\*,"for 0-cochain and scalar",true,[IsCochain and IsZeroCochainRep,IsScalar],0,COM_FUN(14));
InstallMethod(\<,"for two cochains",true,[IsCochain and IsPackedElementDefaultRep,IsCochain and IsPackedElementDefaultRep],0,COM_FUN(15));
InstallMethod(\=,"for two cochains",true,[IsCochain and IsPackedElementDefaultRep,IsCochain and IsPackedElementDefaultRep],0,COM_FUN(16));
InstallMethod(ZeroOp,"for a cochain",true,[IsCochain and IsPackedElementDefaultRep],0,COM_FUN(17));
InstallMethod(ZeroOp,"for a 0-cochain",true,[IsCochain and IsZeroCochainRep],0,COM_FUN(18));
InstallHandlingByNiceBasis("IsCochainsSpace",rec(detect:=COM_FUN(19),NiceFreeLeftModuleInfo:=COM_FUN(20),NiceVector:=COM_FUN(21),UglyVector:=COM_FUN(22)));
InstallGlobalFunction(ValueCochain,COM_FUN(23));
InstallGlobalFunction(LieCoboundaryOperator,COM_FUN(24));
InstallMethod(Coboundaries,"for module over a Lie algebra and an integer",true,[IsAlgebraModule,IS_INT],0,COM_FUN(25));
InstallMethod(Cocycles,"for module over a Lie algebra and an integer",true,[IsAlgebraModule,IS_INT],0,COM_FUN(26));
InstallMethod(WeylGroup,"for a root system",true,[IsRootSystem],0,COM_FUN(27));
InstallMethod(ApplySimpleReflection,"for a sparse Cartan matrix, index and weight",true,[IsList,IS_INT,IsList],0,COM_FUN(28));
InstallMethod(LongestWeylWordPerm,"for Weyl group",true,[IsWeylGroup],0,COM_FUN(29));
InstallMethod(ConjugateDominantWeight,"for Weyl group and weight",true,[IsWeylGroup,IsList],0,COM_FUN(30));
InstallMethod(ConjugateDominantWeightWithWord,"for Weyl group and weight",true,[IsWeylGroup,IsList],0,COM_FUN(31));
BindGlobal("IsDoneIterator_WeylOrbit",COM_FUN(32));
BindGlobal("NextIterator_WeylOrbit",COM_FUN(33));
InstallMethod(WeylOrbitIterator,"for weights of a W-orbit",[IsWeylGroup,IsList],COM_FUN(34));
InstallMethod(PositiveRootsAsWeights,"for a root system",true,[IsRootSystem],0,COM_FUN(35));
InstallMethod(DominantWeights,"for a root system and a dominant weight",true,[IsRootSystem,IsList],0,COM_FUN(36));
InstallMethod(BilinearFormMat,"for a root system from a Lie algebra",true,[IsRootSystemFromLieAlgebra],0,COM_FUN(37));
InstallMethod(DominantCharacter,"for a root system and a highest weight",true,[IsRootSystem,IsList],0,COM_FUN(38));
InstallOtherMethod(DominantCharacter,"for a semisimple Lie algebra and a highest weight",true,[IsLieAlgebra,IsList],0,COM_FUN(39));
InstallMethod(DecomposeTensorProduct,"for a semisimple Lie algebra and two dominant weights",true,[IsLieAlgebra,IsList,IsList],0,COM_FUN(40));
InstallMethod(DimensionOfHighestWeightModule,"for a semisimple Lie algebra",true,[IsLieAlgebra,IsList],0,COM_FUN(41));
InstallMethod(ObjByExtRep,"for family of UEALattice elements, and list",true,[IsUEALatticeElementFamily,IsList],0,COM_FUN(42));
InstallMethod(ExtRepOfObj,"for an UEALattice element",true,[IsUEALatticeElement],0,COM_FUN(43));
InstallMethod(PrintObj,"for UEALattice element",true,[IsUEALatticeElement and IsPackedElementDefaultRep],0,COM_FUN(44));
InstallMethod(OneOp,"for UEALattice element",true,[IsUEALatticeElement and IsPackedElementDefaultRep],0,COM_FUN(45));
InstallMethod(ZeroOp,"for UEALattice element",true,[IsUEALatticeElement and IsPackedElementDefaultRep],0,COM_FUN(46));
InstallMethod(\<,"for two UEALattice elements",IsIdenticalObj,[IsUEALatticeElement and IsPackedElementDefaultRep,IsUEALatticeElement and IsPackedElementDefaultRep],0,COM_FUN(47));
InstallMethod(\=,"for two UEALattice elements",IsIdenticalObj,[IsUEALatticeElement and IsPackedElementDefaultRep,IsUEALatticeElement and IsPackedElementDefaultRep],0,COM_FUN(48));
InstallMethod(\+,"for two UEALattice elements",true,[IsUEALatticeElement and IsPackedElementDefaultRep,IsUEALatticeElement and IsPackedElementDefaultRep],0,COM_FUN(49));
InstallMethod(AdditiveInverseOp,"for UEALattice element",true,[IsUEALatticeElement and IsPackedElementDefaultRep],0,COM_FUN(50));
InstallMethod(\*,"for scalar and UEALattice element",true,[IsScalar,IsUEALatticeElement and IsPackedElementDefaultRep],0,COM_FUN(51));
InstallMethod(\*,"for UEALattice element and scalar",true,[IsUEALatticeElement and IsPackedElementDefaultRep,IsScalar],0,COM_FUN(52));
InstallGlobalFunction(CollectUEALatticeElement,COM_FUN(53));
InstallMethod(\*,"for two UEALattice elements",IsIdenticalObj,[IsUEALatticeElement and IsPackedElementDefaultRep,IsUEALatticeElement and IsPackedElementDefaultRep],0,COM_FUN(54));
DeclareRepresentation("IsVectorSearchTableDefaultRep",IsVectorSearchTable and IsComponentObjectRep and IsAttributeStoringRep,["top"]);
VSTNode:=COM_FUN(55);
VSTInsertToLeft:=COM_FUN(56);
InstallMethod(Insert,"for a vector search table in default representation",[IsVectorSearchTableDefaultRep,IsHomogeneousList,IsObject],COM_FUN(57));
InstallMethod(Search,"for vector search tables in default representation",[IsVectorSearchTableDefaultRep,IsHomogeneousList],COM_FUN(58));
InstallGlobalFunction(VectorSearchTable,COM_FUN(59));
InstallMethod(ViewObj,"for vector search tables",[IsVectorSearchTable],COM_FUN(60));
InstallMethod(Display,"for vector search tables in default representation",[IsVectorSearchTableDefaultRep],COM_FUN(61));
InstallMethod(LatticeGeneratorsInUEA,"for semsimple Lie algebra",true,[IsLieAlgebra],0,COM_FUN(62));
InstallMethod(LeadingUEALatticeMonomial,"for an integer and a UEALattice element",true,[IsInt,IsUEALatticeElement],0,COM_FUN(63));
InstallGlobalFunction(LeftReduceUEALatticeElement,COM_FUN(64));
InstallMethod(ObjByExtRep,"for a family of weight rep elements and a list",true,[IsWeightRepElementFamily,IsList],0,COM_FUN(65));
InstallMethod(ExtRepOfObj,"for weight rep element",true,[IsWeightRepElement and IsPackedElementDefaultRep],0,COM_FUN(66));
InstallMethod(PrintObj,"for weight rep element",true,[IsWeightRepElement and IsPackedElementDefaultRep],0,COM_FUN(67));
InstallMethod(\+,"for weight rep elements",IsIdenticalObj,[IsWeightRepElement and IsPackedElementDefaultRep,IsWeightRepElement and IsPackedElementDefaultRep],0,COM_FUN(68));
InstallMethod(AdditiveInverseOp,"for a weight rep element",true,[IsWeightRepElement and IsPackedElementDefaultRep],0,COM_FUN(69));
InstallMethod(\*,"for weight rep element and a scalar",true,[IsWeightRepElement and IsPackedElementDefaultRep,IsRingElement],0,COM_FUN(70));
InstallMethod(\*,"for weight rep element and a scalar",true,[IsRingElement,IsWeightRepElement and IsPackedElementDefaultRep],0,COM_FUN(71));
InstallMethod(ZeroOp,"for weight rep element",true,[IsWeightRepElement and IsPackedElementDefaultRep],0,COM_FUN(72));
InstallMethod(\=,"for two weight rep elements",IsIdenticalObj,[IsWeightRepElement and IsPackedElementDefaultRep,IsWeightRepElement and IsPackedElementDefaultRep],0,COM_FUN(73));
InstallMethod(\<,"for two weight rep elements",IsIdenticalObj,[IsWeightRepElement and IsPackedElementDefaultRep,IsWeightRepElement and IsPackedElementDefaultRep],0,COM_FUN(74));
InstallOtherMethod(\^,"for a Lie algebra element and a weight rep element",true,[IsRingElement,IsWeightRepElement and IsPackedElementDefaultRep],0,COM_FUN(75));
BindGlobal("BasisOfWeightRepSpace",COM_FUN(76));
TriangulizeWeightRepElementList:=COM_FUN(77);
InstallMethod(Basis,"for a space of weight rep elements and a list of weight rep elements",IsIdenticalObj,[IsFreeLeftModule and IsWeightRepElementCollection,IsWeightRepElementCollection and IsList],0,COM_FUN(78));
InstallMethod(BasisNC,"for a space of weight rep elements and a list of weight rep elements",IsIdenticalObj,[IsFreeLeftModule and IsWeightRepElementCollection,IsWeightRepElementCollection and IsList],0,COM_FUN(79));
InstallMethod(Basis,"for a space of weight rep elements",true,[IsFreeLeftModule and IsWeightRepElementCollection],0,COM_FUN(80));
InstallMethod(Coefficients,"for basis of weight rep elements, and algebra module element",true,[IsBasisOfWeightRepElementSpace,IsWeightRepElement and IsPackedElementDefaultRep],0,COM_FUN(81));
InstallMethod(HighestWeightModule,"for a Lie algebra and a list of non-negative integers",true,[IsLieAlgebra,IsList],0,COM_FUN(82));
InstallGlobalFunction(ExtendRepresentation,COM_FUN(83));
InstallMethod(FaithfulModule,"for a Lie algebra",true,[IsLieAlgebra],0,COM_FUN(84));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/lierep.gi"

#F  file="lib/numtheor.gi" crc=-70511732
RANK_FILTER_LIST  := [  ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/numtheor.gi", -70511732 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/numtheor.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/numtheor.gi");
elif COM_RESULT = 3  then
Revision.numtheor_gi:="@(#)$Id: numtheor.gi,v 4.19.2.1 2004/01/30 22:48:46 gap Exp $";
BindGlobal("PrimeResiduesCache",List([[],[0],[1],[1,2],[1,3],[1,2,3,4],[1,5],[1,2,3,4,5,6]],Immutable));
InstallGlobalFunction(PrimeResidues,COM_FUN(1));
InstallGlobalFunction(Phi,COM_FUN(2));
InstallGlobalFunction(Lambda,COM_FUN(3));
InstallGlobalFunction(OrderMod,COM_FUN(4));
InstallGlobalFunction(IsPrimitiveRootMod,COM_FUN(5));
InstallGlobalFunction(PrimitiveRootMod,COM_FUN(6));
InstallGlobalFunction(GeneratorsPrimeResidues,COM_FUN(7));
InstallGlobalFunction(Jacobi,COM_FUN(8));
InstallGlobalFunction(Legendre,COM_FUN(9));
BindGlobal("RootModPrime",COM_FUN(10));
RootModPrimePower:=COM_FUN(11);
MakeReadOnlyGlobal("RootModPrimePower");
InstallGlobalFunction(RootMod,COM_FUN(12));
BindGlobal("RootsModPrime",COM_FUN(13));
RootsModPrimePower:=COM_FUN(14);
MakeReadOnlyGlobal("RootsModPrimePower");
InstallGlobalFunction(RootsMod,COM_FUN(15));
BindGlobal("RootsUnityModPrime",COM_FUN(16));
RootsUnityModPrimePower:=COM_FUN(17);
MakeReadOnlyGlobal("RootsUnityModPrimePower");
InstallGlobalFunction(RootsUnityMod,COM_FUN(18));
InstallGlobalFunction(LogModShanks,COM_FUN(19));
BindGlobal("LogModRhoIterate",COM_FUN(20));
InstallGlobalFunction(DoLogModRho,COM_FUN(21));
InstallGlobalFunction(LogMod,COM_FUN(22));
InstallGlobalFunction(Sigma,COM_FUN(23));
InstallGlobalFunction(Tau,COM_FUN(24));
InstallGlobalFunction(MoebiusMu,COM_FUN(25));
InstallGlobalFunction(TwoSquares,COM_FUN(26));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/numtheor.gi"

#F  file="lib/contfrac.gi" crc=-116226566
RANK_FILTER_LIST  := [  ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/contfrac.gi", -116226566 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/contfrac.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/contfrac.gi");
elif COM_RESULT = 3  then
Revision.contfrac_gi:="@(#)$Id: contfrac.gi,v 4.5.2.1 2005/05/03 13:44:09 stefan Exp $";
InstallGlobalFunction(ContinuedFractionExpansionOfRoot,COM_FUN(1));
InstallGlobalFunction(ContinuedFractionApproximationOfRoot,COM_FUN(2));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/contfrac.gi"

#F  file="lib/string.gi" crc=51631039
RANK_FILTER_LIST  := [ 67108760, 5, 67108760, 5, 30176509, 1, 67097600, 8, 
  41942756, 18, 67108760, 5, 67108760, 5, 67108760, 5, 67108760, 5, 30176509, 
  1, 30176509, 1, 67108760, 5, 67108760, 5, 30176509, 1, 67108760, 5, 
  30176509, 1, 67108760, 5, 67108760, 5, 67108760, 5, 67108760, 5, 30176509, 
  1, 67108640, 2, 67108640, 2, 67108640, 2, 67108640, 2, 17, 18 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/string.gi", 51631039 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/string.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/string.gi");
elif COM_RESULT = 3  then
Revision.string_gi:="@(#)$Id: string.gi,v 4.30 2003/08/07 13:39:42 sal Exp $";
BIND_GLOBAL("CHARS_DIGITS",Immutable(SSortedList("0123456789")));
InstallGlobalFunction(IsDigitChar,COM_FUN(1));
BIND_GLOBAL("CHARS_UALPHA",Immutable(SSortedList("ABCDEFGHIJKLMNOPQRSTUVWXYZ")));
InstallGlobalFunction(IsUpperAlphaChar,COM_FUN(2));
BIND_GLOBAL("CHARS_LALPHA",Immutable(SSortedList("abcdefghijklmnopqrstuvwxyz")));
InstallGlobalFunction(IsLowerAlphaChar,COM_FUN(3));
InstallGlobalFunction(IsAlphaChar,COM_FUN(4));
InstallGlobalFunction(DaysInYear,COM_FUN(5));
InstallGlobalFunction(DaysInMonth,COM_FUN(6));
InstallGlobalFunction(DMYDay,COM_FUN(7));
InstallGlobalFunction(DayDMY,COM_FUN(8));
InstallGlobalFunction(WeekDay,COM_FUN(9));
InstallGlobalFunction(SecondsDMYhms,COM_FUN(10));
InstallGlobalFunction(DMYhmsSeconds,COM_FUN(11));
InstallGlobalFunction(StringDate,COM_FUN(12));
InstallGlobalFunction(HMSMSec,COM_FUN(13));
InstallGlobalFunction(SecHMSM,COM_FUN(14));
InstallGlobalFunction(StringTime,COM_FUN(15));
InstallGlobalFunction(StringPP,COM_FUN(16));
InstallGlobalFunction(WordAlp,COM_FUN(17));
LOWERCASETRANSTABLE:=0;
InstallGlobalFunction(LowercaseString,COM_FUN(18));
InstallOtherMethod(Int,"for strings",true,[IsString],0,COM_FUN(19));
InstallOtherMethod(Rat,"for strings",true,[IsString],0,COM_FUN(20));
InstallMethod(ViewObj,"IsChar",true,[IsChar],0,COM_FUN(21));
InstallMethod(ViewObj,"IsString",true,[IsString and IsFinite],0,COM_FUN(22));
InstallMethod(ViewObj,"empty strings",true,[IsString and IsEmpty],0,COM_FUN(23));
InstallMethod(SplitString,"for three strings",true,[IsString,IsString,IsString],0,SplitStringInternal);
InstallMethod(SplitString,"for a string and two characters",true,[IsString,IsChar,IsChar],0,COM_FUN(24));
InstallMethod(SplitString,"for two strings and a character",true,[IsString,IsString,IsChar],0,COM_FUN(25));
InstallMethod(SplitString,"for a string, a character and a string",true,[IsString,IsChar,IsString],0,COM_FUN(26));
InstallOtherMethod(SplitString,"for two strings",true,[IsString,IsString],0,COM_FUN(27));
InstallOtherMethod(SplitString,"for a string and a character",true,[IsString,IsChar],0,COM_FUN(28));
InstallOtherMethod(PositionSublist,"for two args in IsStringRep",true,[IS_STRING_REP,IS_STRING_REP],0,COM_FUN(29));
InstallOtherMethod(PositionSublist,"for two args in IsStringRep and offset",true,[IS_STRING_REP,IS_STRING_REP,IsInt],0,COM_FUN(30));
InstallGlobalFunction("NormalizedWhitespace",COM_FUN(31));
InstallGlobalFunction("RemoveCharacters",REMOVE_CHARACTERS);
_EVALSTRINGTMP:=0;
InstallGlobalFunction("EvalString",COM_FUN(32));
Unbind(_EVALSTRINGTMP);
InstallGlobalFunction("JoinStringsWithSeparator",COM_FUN(33));
InstallGlobalFunction(Chomp,COM_FUN(34));
InstallGlobalFunction(StringFile,COM_FUN(35));
InstallGlobalFunction(FileString,COM_FUN(36));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/string.gi"

#F  file="lib/ratfun.gi" crc=-74077075
RANK_FILTER_LIST  := [ 41942456, 2, 52247917, 19, 41942456, 2, 52247917, 19, 
  41942456, 2, 52247917, 19, 67108760, 5, 56456811, 17, 67108760, 5, 
  47668643, 15, 12886388, 14, 41549180, 12, 55037098, 16, 1, 0, 1, 0, 
  58464892, 22, 27568479, 18, 42966276, 17, 15990440, 13, 15990440, 13, 
  15990440, 13, 47668643, 15, 5338371, 17, 63659082, 15, 15990440, 13, 
  15990440, 13, 54436527, 15, 15990440, 13, 39640261, 14, 15990440, 13, 
  39640261, 14, 39640261, 14, 15990440, 13, 15990440, 13, 8193, 2, 8193, 2, 
  1, 0, 8193, 2, 8193, 2, 8193, 2, 1, 0, 8193, 2, 1985, 1, 1, 0, 15990440, 
  13, 39640261, 14, 54525188, 15, 39640261, 14, 39640261, 14, 39640261, 14, 
  39640261, 14, 15990440, 13, 15990440, 13, 39640261, 14, 39640261, 14, 
  15990440, 13, 15990440, 13, 64918210, 8, 15990440, 13, 15990440, 13, 
  64918210, 8, 39640261, 14, 64918210, 8, 64918210, 8, 39640261, 14, 
  16776992, 5, 8193, 2, 8193, 2, 15990440, 13, 15990440, 13, 35414261, 27, 
  39640261, 14, 39640261, 14, 39640261, 14, 39640261, 14, 15990440, 13, 
  15990440, 13, 15990440, 13, 64918210, 8, 64918210, 8, 15990440, 13, 33, 17, 
  15990440, 13, 33, 17, 33, 17, 33, 17, 15990440, 13, 39640261, 14, 52247917, 
  19, 39640261, 14, 56456811, 17, 57619825, 31, 15990440, 13, 15990440, 13, 
  15990440, 13, 8193, 2, 8193, 2, 64918210, 8, 15990440, 13, 8193, 2, 8193, 
  2, 39640261, 14, 15497657, 17, 39640261, 14, 52247917, 19, 54436527, 15, 
  52247917, 19, 54436527, 15, 54436527, 15, 15990440, 13, 12886388, 14, 
  52247917, 19, 12886388, 14, 12886388, 14, 41549180, 12, 52247917, 19, 
  12886388, 14, 12886388, 14, 41549180, 12, 12886388, 14, 12886388, 14, 
  12886388, 14, 52247917, 19, 12886388, 14, 12886388, 14, 12886388, 14 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/ratfun.gi", -74077075 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/ratfun.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/ratfun.gi");
elif COM_RESULT = 3  then
Revision.ratfun_gi:="@(#)$Id: ratfun.gi,v 4.108.2.2 2005/05/12 09:10:55 gap Exp $";
InstallMethod(IndeterminateName,"for rational function families",true,[IsPolynomialFunctionsFamily,IsPosInt],0,COM_FUN(1));
InstallMethod(HasIndeterminateName,"for rational function families",true,[IsPolynomialFunctionsFamily,IsPosInt],0,COM_FUN(2));
InstallMethod(SetIndeterminateName,"for rational function families",true,[IsPolynomialFunctionsFamily,IsPosInt,IsString],0,COM_FUN(3));
InstallMethod(SetName,"set name of indeterminate",true,[IsLaurentPolynomial,IsString],0,COM_FUN(4));
InstallGlobalFunction(LaurentPolynomialByExtRep,LAUR_POL_BY_EXTREP);
InstallGlobalFunction(UnivariateRationalFunctionByExtRep,UNIV_FUNC_BY_EXTREP);
InstallGlobalFunction(PolynomialByExtRep,COM_FUN(5));
InstallGlobalFunction(RationalFunctionByExtRep,COM_FUN(6));
InstallMethod(IsLaurentPolynomial,true,[IsUnivariateRationalFunction],0,COM_FUN(7));
InstallMethod(IsConstantRationalFunction,"polynomial",true,[IsPolynomialFunction and IsPolynomial],0,COM_FUN(8));
InstallMethod(IsConstantRationalFunction,"rational function",true,[IsPolynomialFunction],0,COM_FUN(9));
InstallMethod(IsPolynomial,"rational function rep.",true,[IsRationalFunctionDefaultRep],0,COM_FUN(10));
InstallOtherMethod(IsPolynomial,"fallback for non-ratfun",true,[IsObject],0,COM_FUN(11));
InstallOtherMethod(IsLaurentPolynomial,"fallback for non-ratfun",true,[IsObject],0,COM_FUN(12));
InstallMethod(ExtRepPolynomialRatFun,"laurent polynomial rep.",true,[IsLaurentPolynomialDefaultRep and IsPolynomial],0,EXTREP_POLYNOMIAL_LAURENT);
InstallMethod(ExtRepPolynomialRatFun,"rational function rep.",true,[IsRationalFunctionDefaultRep and IsPolynomial],0,COM_FUN(13));
InstallMethod(ExtRepNumeratorRatFun,"polynomial rep -> ExtRepPolynomialRatFun",true,[IsPolynomialDefaultRep],0,ExtRepPolynomialRatFun);
InstallMethod(ExtRepDenominatorRatFun,"polynomial, return constant",true,[IsRationalFunction],0,COM_FUN(14));
InstallGlobalFunction(UnivariatenessTestRationalFunction,UNIVARTEST_RATFUN);
BindGlobal("DoUnivTestRatfun",COM_FUN(15));
InstallMethod(IsUnivariateRationalFunction,"ratfun",true,[IsRationalFunction],0,COM_FUN(16));
InstallMethod(IsLaurentPolynomial,"ratfun",true,[IsRationalFunction],0,COM_FUN(17));
InstallMethod(IndeterminateNumberOfUnivariateRationalFunction,"ratfun",true,[IsUnivariateRationalFunction],0,COM_FUN(18));
InstallMethod(CoefficientsOfLaurentPolynomial,"ratfun",true,[IsRationalFunction and IsLaurentPolynomial],0,COM_FUN(19));
InstallMethod(CoefficientsOfUnivariateRationalFunction,"ratfun",true,[IsRationalFunction and IsUnivariateRationalFunction],0,COM_FUN(20));
InstallMethod(NumeratorOfRationalFunction,"call ExtRepNumerator",true,[IsRationalFunction],0,COM_FUN(21));
InstallMethod(DenominatorOfRationalFunction,"call ExtRepDenominator",true,[IsRationalFunction],0,COM_FUN(22));
InstallMethod(AsPolynomial,"call ExtRepPolynomial",true,[IsRationalFunction and IsPolynomial],0,COM_FUN(23));
BindGlobal("ExtRepOfPolynomial_String",COM_FUN(24));
InstallMethod(String,"rational function",[IsRationalFunction],COM_FUN(25));
InstallMethod(String,"polynomial",[IsPolynomial],COM_FUN(26));
InstallMethod(PrintObj,"rational function",[IsRationalFunction],COM_FUN(27));
InstallMethod(PrintObj,"polynomial",[IsPolynomial],COM_FUN(28));
InstallMethod(LaTeXObj,"polynomial",true,[IsPolynomial],0,COM_FUN(29));
InstallMethod(OneOp,"defer to family",true,[IsRationalFunction],0,COM_FUN(30));
InstallMethod(ZeroOp,"defer to family",true,[IsRationalFunction],0,COM_FUN(31));
InstallGlobalFunction(MonomialExtGrlexLess,MONOM_GRLEX);
InstallMethod(ZippedSum,true,[IsList,IsList,IsObject,IsList],0,ZIPPED_SUM_LISTS);
InstallMethod(ZippedProduct,true,[IsList,IsList,IsObject,IsList],0,ZIPPED_PRODUCT_LISTS);
InstallMethod(RationalFunctionsFamily,true,[IsFamily],1,COM_FUN(32));
InstallOtherMethod(RationalFunctionsFamily,"not UFD ring",true,[IsObject],0,COM_FUN(33));
InstallMethod(AdditiveInverseOp,"rational function",true,[IsRationalFunction],0,ADDITIVE_INV_RATFUN);
InstallMethod(AdditiveInverseOp,"polynomial",true,[IsPolynomial],0,ADDITIVE_INV_POLYNOMIAL);
InstallMethod(InverseOp,"rational function",true,[IsRationalFunctionsFamilyElement],0,COM_FUN(34));
InstallMethod(\+,"polynomial + polynomial",IsIdenticalObj,[IsPolynomial,IsPolynomial],0,COM_FUN(35));
InstallMethod(\*,"polynomial * polynomial",IsIdenticalObj,[IsPolynomial,IsPolynomial],0,COM_FUN(36));
InstallMethod(\=,"rational functions",IsIdenticalObj,[IsRationalFunction,IsRationalFunction],0,COM_FUN(37));
InstallMethod(\=,"polynomial",IsIdenticalObj,[IsPolynomial,IsPolynomial],0,COM_FUN(38));
InstallMethod(\<,"rational functions",IsIdenticalObj,[IsRationalFunction,IsRationalFunction],0,SMALLER_RATFUN);
InstallGlobalFunction(ProdCoefRatfun,COM_FUN(39));
InstallMethod(\*,"coeff * rat-fun",IsCoeffsElms,[IsRingElement,IsRationalFunction],3,COM_FUN(40));
InstallMethod(\*,"rat-fun * coeff",IsElmsCoeffs,[IsRationalFunction,IsRingElement],3,COM_FUN(41));
InstallGlobalFunction(SumCoefPolynomial,SUM_COEF_POLYNOMIAL);
InstallMethod(\+,"polynomial + coeff",IsElmsCoeffs,[IsPolynomial,IsRingElement],0,COM_FUN(42));
InstallMethod(\+,"coeff + polynomial ",IsCoeffsElms,[IsRingElement,IsPolynomial],0,COM_FUN(43));
InstallGlobalFunction(QuotientPolynomialsExtRep,QUOTIENT_POLYNOMIALS_EXT);
InstallGlobalFunction(SpecializedExtRepPol,SPECIALIZED_EXTREP_POL);
InstallMethod(HeuristicCancelPolynomialsExtRep,"ignore",true,[IsRationalFunctionsFamily,IsList,IsList],-1,COM_FUN(44));
InstallGlobalFunction(TryGcdCancelExtRepPolynomials,TRY_GCD_CANCEL_EXTREP_POL);
InstallGlobalFunction(RationalFunctionByExtRepWithCancellation,COM_FUN(45));
InstallMethod(\*,"rat-fun * rat-fun",IsIdenticalObj,[IsRationalFunction,IsRationalFunction],0,COM_FUN(46));
InstallMethod(Quotient,"multivar with ring",IsCollsElmsElms,[IsPolynomialRing,IsPolynomial,IsPolynomial],0,COM_FUN(47));
InstallOtherMethod(Quotient,"multivar",IsIdenticalObj,[IsPolynomial,IsPolynomial],0,COM_FUN(48));
InstallMethod(\+,"rat-fun + rat-fun",IsIdenticalObj,[IsRationalFunction,IsRationalFunction],0,COM_FUN(49));
InstallGlobalFunction(SumCoefRatfun,COM_FUN(50));
InstallMethod(\+,"ratfun + coeff",IsElmsCoeffs,[IsRationalFunction,IsRingElement],0,COM_FUN(51));
InstallMethod(\+,"coeff + ratfun ",IsCoeffsElms,[IsRingElement,IsRationalFunction],0,COM_FUN(52));
InstallMethod(\+,"ratfun + rat",true,[IsRationalFunction,IsRat],-RankFilter(IsRat),COM_FUN(53));
InstallMethod(\+,"rat + ratfun ",true,[IsRat,IsRationalFunction],-RankFilter(IsRat),COM_FUN(54));
InstallMethod(DegreeIndeterminate,"pol,indetnr",true,[IsPolynomial,IsPosInt],0,COM_FUN(55));
InstallOtherMethod(DegreeIndeterminate,"pol,indet",IsIdenticalObj,[IsPolynomial,IsLaurentPolynomial],0,COM_FUN(56));
InstallMethod(GcdOp,"Gcd(Polyring, Pol,Pol)",IsCollsElmsElms,[IsEuclideanRing,IsRationalFunction,IsRationalFunction],0,COM_FUN(57));
InstallOtherMethod(Value,"rat.fun., with one",true,[IsRationalFunction,IsList,IsList,IsRingElement],0,COM_FUN(58));
InstallMethod(Value,"rational function: supply `one'",true,[IsRationalFunction,IsList,IsList],0,COM_FUN(59));
InstallMethod(LeadingMonomial,"multivariate polynomials wrt total degree",true,[IsPolynomial],0,COM_FUN(60));
InstallMethod(LeadingCoefficient,"multivariate polynomials wrt total degree",true,[IsPolynomial and IsPolynomialDefaultRep],0,COM_FUN(61));
InstallOtherMethod(LeadingCoefficient,"multivariate",true,[IsPolynomial,IsPosInt],0,COM_FUN(62));
InstallMethod(PolynomialCoefficientsOfPolynomial,"polynomial,integer",true,[IsRationalFunction and IsPolynomial,IsPosInt],0,COM_FUN(63));
InstallOtherMethod(PolynomialCoefficientsOfPolynomial,"polynomial,indet",IsIdenticalObj,[IsRationalFunction and IsPolynomial,IsRationalFunction and IsPolynomial],0,COM_FUN(64));
InstallMethod(ZeroCoefficientRatFun,"via family",[IsRationalFunction],0,COM_FUN(65));
BindGlobal("ConstantInBaseRingPol",COM_FUN(66));
InstallOtherMethod(Discriminant,"poly,inum",true,[IsPolynomialFunction and IsPolynomial,IsPosInt],0,COM_FUN(67));
InstallOtherMethod(Discriminant,"poly,ind",true,[IsPolynomialFunction and IsPolynomial,IsPolynomialFunction and IsPolynomial]\
,0,COM_FUN(68));
InstallOtherMethod(Derivative,"ratfun,inum",true,[IsPolynomialFunction,IsPosInt],0,COM_FUN(69));
InstallOtherMethod(Derivative,"poly,ind",true,[IsPolynomialFunction and IsPolynomial,IsPolynomialFunction and IsPolynomial]\
,0,COM_FUN(70));
InstallOtherMethod(Derivative,"ratfun,ind",true,[IsPolynomialFunction,IsPolynomialFunction and IsPolynomial],0,COM_FUN(71));
InstallGlobalFunction(OnIndeterminates,COM_FUN(72));
InstallMethod(Resultant,"pol,pol,inum",IsFamFamX,[IsPolynomialFunction and IsPolynomial,IsPolynomialFunction and IsPolynomial,IsPosInt],0,COM_FUN(73));
InstallOtherMethod(Resultant,"pol,pol,indet",IsFamFamFam,[IsPolynomialFunction and IsPolynomial,IsPolynomialFunction and IsPolynomial,IsPolynomialFunction and IsPolynomial],0,COM_FUN(74));
InstallGlobalFunction(LeadingMonomialPosExtRep,COM_FUN(75));
InstallGlobalFunction(ConstituentsPolynomial,COM_FUN(76));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/ratfun.gi"

#F  file="lib/ratfunul.gi" crc=-44397005
RANK_FILTER_LIST  := [ 1985, 1, 8193, 2, 17, 18, 17, 18, 1115, 2, 8193, 2, 
  17, 18, 17, 18, 1985, 1, 8193, 2, 17, 18, 1985, 1, 8193, 2, 52247917, 19, 
  1985, 1, 8193, 2, 10477489, 26, 62727540, 13, 52247917, 19, 10477489, 26, 
  62727540, 13, 20200024, 19, 41549180, 12, 30897111, 17, 56456811, 17, 
  52247917, 19, 18824632, 20, 18824632, 20, 34815071, 20, 22108943, 15, 
  22108943, 15, 22108943, 15, 22108943, 15, 22108943, 15, 30897111, 17, 
  30897111, 17, 30897111, 17, 30897111, 17, 30897111, 17, 30897111, 17, 
  30897111, 17, 30897111, 17, 64918210, 8, 37016574, 17, 37016574, 17, 
  64918210, 8, 64918210, 8, 37016574, 17, 37016574, 17, 64918210, 8, 
  28988192, 19, 28988192, 19, 35414261, 27, 56456811, 17, 56456811, 17, 
  35414261, 27, 15990440, 13, 15990440, 13, 56456811, 17, 56456811, 17, 
  15990440, 13, 15990440, 13, 35414261, 27, 56456811, 17, 56456811, 17, 
  56456811, 17, 56456811, 17, 10477489, 26, 56456811, 17, 56456811, 17, 
  56456811, 17, 56456811, 17, 56456811, 17, 56456811, 17, 35414261, 27, 
  56456811, 17, 17, 18, 56456811, 17, 56456811, 17, 17, 18, 56456811, 17, 
  56456811, 17, 56456811, 17, 56456811, 17, 56456811, 17, 56456811, 17, 
  56456811, 17, 35414261, 27, 56456811, 17, 56456811, 17, 35414261, 27, 
  56456811, 17, 56456811, 17, 56456811, 17, 56456811, 17, 56456811, 17, 
  56456811, 17, 57619825, 31, 39640261, 14, 39640261, 14, 54436527, 15, 
  54436527, 15, 57619825, 31, 15990440, 13, 15990440, 13, 15990440, 13, 
  15990440, 13, 35414261, 27, 56456811, 17, 56456811, 17, 39640261, 14, 
  47668643, 15, 39640261, 14, 56456811, 17, 39640261, 14, 56456811, 17, 
  64918210, 8, 64918210, 8, 47668643, 15, 64918210, 8, 64918210, 8, 47668643, 
  15, 64918210, 8, 41549180, 12, 64918210, 8, 56456811, 17, 1985, 1, 8193, 2, 
  8193, 2, 17, 18, 17, 18, 1985, 1, 8193, 2, 8193, 2, 17, 18, 47668643, 15, 
  56456811, 17, 47668643, 15, 47668643, 15, 47668643, 15, 47668643, 15, 
  47668643, 15, 47668643, 15, 22108943, 15, 22108943, 15, 22108943, 15, 
  22108943, 15, 22108943, 15, 63659082, 15, 22108943, 15, 22108943, 15, 
  22108943, 15, 22108943, 15, 22108943, 15, 22108943, 15, 64918210, 8, 
  22108943, 15, 22108943, 15, 64918210, 8, 64918210, 8, 22108943, 15, 
  22108943, 15, 64918210, 8, 33, 17, 33, 17, 22108943, 15, 33, 17, 22108943, 
  15, 33, 17 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/ratfunul.gi", -44397005 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/ratfunul.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/ratfunul.gi");
elif COM_RESULT = 3  then
Revision.ratfunul_gi:="@(#)$Id: ratfunul.gi,v 4.81.2.2 2005/03/08 02:19:48 gap Exp $";
InstallMethod(LaurentPolynomialByCoefficients,"with indeterminate",true,[IsFamily,IsList,IsInt,IsInt],0,COM_FUN(1));
InstallMethod(LaurentPolynomialByCoefficients,"warn about iterated polynomials",true,[IsFamily and HasCoefficientsFamily,IsList,IsInt,IsInt],0,COM_FUN(2));
InstallOtherMethod(LaurentPolynomialByCoefficients,"fam, cof,val",true,[IsFamily,IsList,IsInt],0,COM_FUN(3));
InstallMethod(UnivariatePolynomialByCoefficients,"fam, cof,ind",true,[IsFamily,IsList,IsPosInt],0,COM_FUN(4));
InstallOtherMethod(UnivariatePolynomialByCoefficients,"fam,cof",true,[IsFamily,IsList],0,COM_FUN(5));
InstallMethod(UnivariatePolynomial,"ring,cof,indn",true,[IsRing,IsRingElementCollection,IsPosInt],0,COM_FUN(6));
InstallOtherMethod(UnivariatePolynomial,"ring,cof",true,[IsRing,IsRingElementCollection],0,COM_FUN(7));
InstallMethod(CoefficientsOfUnivariatePolynomial,"use laurent coeffs",true,[IsUnivariatePolynomial],0,COM_FUN(8));
RedispatchOnCondition(CoefficientsOfUnivariatePolynomial,true,[IsPolynomialFunction],[IsUnivariatePolynomial],0);
InstallMethod(DegreeOfLaurentPolynomial,true,[IsPolynomialFunction and IsLaurentPolynomial],0,COM_FUN(9));
InstallOtherMethod(DegreeIndeterminate,"laurent,indetnr",true,[IsLaurentPolynomial,IsPosInt],0,COM_FUN(10));
InstallMethod(IsPolynomial,"laurent rep.",true,[IsLaurentPolynomialDefaultRep],0,COM_FUN(11));
InstallGlobalFunction(CIUnivPols,COM_FUN(12));
InstallMethod(ExtRepNumeratorRatFun,"laurent polynomial rep.",true,[IsLaurentPolynomialDefaultRep],0,COM_FUN(13));
InstallMethod(ExtRepDenominatorRatFun,"laurent polynomial rep.",true,[IsLaurentPolynomialDefaultRep and IsRationalFunction],0,COM_FUN(14));
InstallMethod(OneOp,"univariate",true,[IsPolynomialFunction and IsUnivariateRationalFunction],0,COM_FUN(15));
InstallMethod(One,"univariate",true,[IsPolynomialFunction and IsUnivariateRationalFunction],0,OneOp);
InstallMethod(ZeroOp,"univariate",true,[IsPolynomialFunction and IsUnivariateRationalFunction],0,COM_FUN(16));
InstallMethod(Zero,"univariate",true,[IsPolynomialFunction and IsUnivariateRationalFunction],0,ZeroOp);
InstallMethod(IndeterminateOfUnivariateRationalFunction,"use `IndeterminateNumber'",true,[IsPolynomialFunction and IsUnivariateRationalFunction],0,COM_FUN(17));
InstallMethod(AdditiveInverseOp,"laurent polynomial",true,[IsPolynomialFunction and IsLaurentPolynomial],0,COM_FUN(18));
InstallMethod(InverseOp,"try to express as laurent polynomial",true,[IsPolynomialFunction and IsLaurentPolynomial],0,COM_FUN(19));
InstallMethod(\*,"laurent * laurent",IsIdenticalObj,[IsPolynomialFunction and IsLaurentPolynomial,IsPolynomialFunction and IsLaurentPolynomial],0,PRODUCT_LAURPOLS);
InstallMethod(\+,"laurent + laurent",IsIdenticalObj,[IsPolynomialFunction and IsLaurentPolynomial,IsPolynomialFunction and IsLaurentPolynomial],0,SUM_LAURPOLS);
InstallMethod(\-,"laurent - laurent",IsIdenticalObj,[IsPolynomialFunction and IsLaurentPolynomial,IsPolynomialFunction and IsLaurentPolynomial],0,DIFF_LAURPOLS);
BindGlobal("ProdCoeffLaurpol",COM_FUN(20));
InstallMethod(\*,"coeff * laurent",IsCoeffsElms,[IsRingElement,IsUnivariateRationalFunction and IsLaurentPolynomial],0,ProdCoeffLaurpol);
InstallMethod(\*,"laurent * coeff",IsElmsCoeffs,[IsUnivariateRationalFunction and IsLaurentPolynomial,IsRingElement],0,COM_FUN(21));
BindGlobal("SumCoeffLaurpol",COM_FUN(22));
InstallMethod(\+,"coeff + laurent",IsCoeffsElms,[IsRingElement,IsUnivariateRationalFunction and IsLaurentPolynomial],0,SumCoeffLaurpol);
InstallMethod(\+,"laurent + coeff",IsElmsCoeffs,[IsUnivariateRationalFunction and IsLaurentPolynomial,IsRingElement],0,COM_FUN(23));
InstallGlobalFunction(QuotRemLaurpols,COM_FUN(24));
InstallMethod(\/,"upol/upol",true,[IsLaurentPolynomial and IsPolynomial,IsLaurentPolynomial and IsPolynomial],2,COM_FUN(25));
InstallMethod(QuotientRemainder,"laurent, ring",IsCollsElmsElms,[IsPolynomialRing,IsLaurentPolynomial,IsLaurentPolynomial],0,COM_FUN(26));
RedispatchOnCondition(QuotientRemainder,IsCollsElmsElms,[IsPolynomialRing,IsRationalFunction,IsRationalFunction],[,IsLaurentPolynomial,IsLaurentPolynomial],0);
InstallOtherMethod(QuotientRemainder,"laurent",IsIdenticalObj,[IsLaurentPolynomial,IsLaurentPolynomial],0,COM_FUN(27));
RedispatchOnCondition(QuotientRemainder,IsIdenticalObj,[IsRationalFunction,IsRationalFunction],[IsLaurentPolynomial,IsLaurentPolynomial],0);
InstallMethod(Quotient,"laurent, ring",IsCollsElmsElms,[IsPolynomialRing,IsLaurentPolynomial,IsLaurentPolynomial],0,COM_FUN(28));
InstallOtherMethod(Quotient,"laurent",IsIdenticalObj,[IsLaurentPolynomial,IsLaurentPolynomial],0,COM_FUN(29));
BIND_GLOBAL("QUOMOD_UPOLY",COM_FUN(30));
InstallMethod(QuotientMod,"laurent,ring",IsCollsElmsElmsElms,[IsRing,IsLaurentPolynomial,IsLaurentPolynomial,IsLaurentPolynomial],0,COM_FUN(31));
InstallOtherMethod(QuotientMod,"laurent",IsFamFamFam,[IsLaurentPolynomial,IsLaurentPolynomial,IsLaurentPolynomial],0,QUOMOD_UPOLY);
BindGlobal("POWMOD_UPOLY",COM_FUN(32));
InstallMethod(PowerMod,"laurent,ring ",IsCollsElmsXElms,[IsPolynomialRing,IsLaurentPolynomial,IsInt,IsLaurentPolynomial],0,COM_FUN(33));
InstallOtherMethod(PowerMod,"laurent",IsFamXFam,[IsLaurentPolynomial,IsInt,IsLaurentPolynomial],0,POWMOD_UPOLY);
InstallMethod(\=,"laurent",IsIdenticalObj,[IsLaurentPolynomial,IsLaurentPolynomial],0,COM_FUN(34));
InstallMethod(\<,"Univariate Polynomials",IsIdenticalObj,[IsLaurentPolynomial,IsLaurentPolynomial],0,COM_FUN(35));
InstallGlobalFunction(RandomPol,COM_FUN(36));
InstallMethod(LeadingCoefficient,"laurent",true,[IsLaurentPolynomial],0,COM_FUN(37));
InstallMethod(LeadingMonomial,"for a univariate laurent polynomial",true,[IsLaurentPolynomial],0,COM_FUN(38));
InstallOtherMethod(EuclideanDegree,"laurent,ring",IsCollsElms,[IsPolynomialRing,IsLaurentPolynomial],0,COM_FUN(39));
InstallOtherMethod(EuclideanDegree,"laurent",true,[IsLaurentPolynomial],0,DegreeOfLaurentPolynomial);
BindGlobal("MOD_UPOLY",COM_FUN(40));
InstallOtherMethod(EuclideanRemainder,"laurent,ring",IsCollsElmsElms,[IsPolynomialRing,IsLaurentPolynomial,IsLaurentPolynomial],0,COM_FUN(41));
InstallOtherMethod(EuclideanRemainder,"laurent",IsIdenticalObj,[IsLaurentPolynomial,IsLaurentPolynomial],0,MOD_UPOLY);
InstallMethod(\mod,"laurent",IsIdenticalObj,[IsLaurentPolynomial,IsLaurentPolynomial],0,MOD_UPOLY);
InstallGlobalFunction(GcdCoeffs,GCD_COEFFS);
BindGlobal("GCD_UPOLY",COM_FUN(42));
InstallMethod(GcdOp,"univariate polynomials, ring",IsCollsElmsElms,[IsEuclideanRing,IsPolynomial,IsPolynomial],0,COM_FUN(43));
InstallOtherMethod(GcdOp,"univariate polynomials",IsIdenticalObj,[IsPolynomial and IsRationalFunction,IsPolynomial and IsRationalFunction],0,GCD_UPOLY);
RedispatchOnCondition(GcdOp,IsCollsElmsElms,[IsEuclideanRing,IsRationalFunction,IsRationalFunction],[,IsUnivariatePolynomial,IsUnivariatePolynomial],0);
RedispatchOnCondition(GcdOp,IsIdenticalObj,[IsRationalFunction,IsRationalFunction],[IsUnivariatePolynomial,IsUnivariatePolynomial],0);
InstallMethod(StandardAssociate,"laurent",IsCollsElms,[IsPolynomialRing,IsLaurentPolynomial],0,COM_FUN(44));
InstallOtherMethod(Derivative,"Laurent Polynomials",true,[IsLaurentPolynomial],0,COM_FUN(45));
RedispatchOnCondition(Derivative,true,[IsPolynomial],[IsLaurentPolynomial],0);
InstallOtherMethod(Derivative,"uratfun,ind",true,[IsUnivariateRationalFunction],0,COM_FUN(46));
RedispatchOnCondition(Derivative,true,[IsPolynomial],[IsUnivariateRationalFunction],0);
InstallOtherMethod(Discriminant,"laurent",true,[IsLaurentPolynomial],0,COM_FUN(47));
RedispatchOnCondition(Discriminant,true,[IsPolynomial],[IsLaurentPolynomial],0);
InstallOtherMethod(Value,"Laurent, ring element, and mult. neutral element",true,[IsLaurentPolynomial,IsRingElement,IsRingElement],0,COM_FUN(48));
InstallOtherMethod(Value,"univariate rational function",true,[IsUnivariateRationalFunction,IsRingElement,IsRingElement],0,COM_FUN(49));
InstallOtherMethod(Value,"supply `one'",true,[IsUnivariateRationalFunction,IsRingElement],0,COM_FUN(50));
RedispatchOnCondition(Value,true,[IsPolynomialFunction,IsRingElement],[IsUnivariateRationalFunction,IsRingElement],0);
BindGlobal("StringUnivariateLaurent",COM_FUN(51));
BindGlobal("DoPrintUnivariateLaurent",COM_FUN(52));
InstallMethod(PrintObj,"laurent polynomial",true,[IsLaurentPolynomial],0,COM_FUN(53));
InstallMethod(UnivariateRationalFunctionByCoefficients,"with indeterminate",true,[IsFamily,IsList,IsList,IsInt,IsInt],0,COM_FUN(54));
InstallOtherMethod(UnivariateRationalFunctionByCoefficients,"fam, ncof,dcof,val",true,[IsFamily,IsList,IsList,IsInt],0,COM_FUN(55));
InstallMethod(PrintObj,"univar",true,[IsUnivariateRationalFunction],0,COM_FUN(56));
InstallMethod(CoefficientsOfUnivariateRationalFunction,"laurent polynomial",true,[IsLaurentPolynomial],0,COM_FUN(57));
InstallMethod(IsLaurentPolynomial,"univariate",true,[IsUnivariateRationalFunction],0,COM_FUN(58));
InstallMethod(IsPolynomial,"univariate",true,[IsUnivariateRationalFunction],0,COM_FUN(59));
InstallOtherMethod(ExtRepPolynomialRatFun,"univariate",true,[IsUnivariateRationalFunction],0,COM_FUN(60));
RedispatchOnCondition(CoefficientsOfLaurentPolynomial,true,[IsUnivariateRationalFunction],[IsLaurentPolynomial],0);
InstallMethod(ExtRepNumeratorRatFun,"univariate",true,[IsUnivariateRationalFunction],0,COM_FUN(61));
InstallMethod(ExtRepDenominatorRatFun,"univariate",true,[IsUnivariateRationalFunction],0,COM_FUN(62));
InstallMethod(AdditiveInverseOp,"univariate",true,[IsPolynomialFunction and IsUnivariateRationalFunction],0,COM_FUN(63));
InstallMethod(InverseOp,"univariate",true,[IsPolynomialFunction and IsUnivariateRationalFunction],0,COM_FUN(64));
InstallMethod(\*,"univariate * univariate",IsIdenticalObj,[IsPolynomialFunction and IsUnivariateRationalFunction,IsPolynomialFunction and IsUnivariateRationalFunction],0,PRODUCT_UNIVFUNCS);
InstallMethod(\/,"univariate / univariate",IsIdenticalObj,[IsPolynomialFunction and IsUnivariateRationalFunction,IsRationalFunction and IsUnivariateRationalFunction],0,QUOT_UNIVFUNCS);
InstallMethod(\+,"univariate + univariate",IsIdenticalObj,[IsPolynomialFunction and IsUnivariateRationalFunction,IsPolynomialFunction and IsUnivariateRationalFunction],0,SUM_UNIVFUNCS);
InstallMethod(\-,"univariate - univariate",IsIdenticalObj,[IsPolynomialFunction and IsUnivariateRationalFunction,IsPolynomialFunction and IsUnivariateRationalFunction],0,DIFF_UNIVFUNCS);
InstallMethod(\=,"univariate = univariate",IsIdenticalObj,[IsPolynomialFunction and IsUnivariateRationalFunction,IsPolynomialFunction and IsUnivariateRationalFunction],0,COM_FUN(65));
BindGlobal("ProdCoeffUnivfunc",COM_FUN(66));
InstallMethod(\*,"coeff * univariate",IsCoeffsElms,[IsRingElement,IsPolynomialFunction and IsUnivariateRationalFunction],3,ProdCoeffUnivfunc);
InstallMethod(\*,"univariate * coeff",IsElmsCoeffs,[IsPolynomialFunction and IsUnivariateRationalFunction,IsRingElement],3,COM_FUN(67));
BindGlobal("SumCoeffUnivfunc",COM_FUN(68));
InstallMethod(\+,"coeff + univariate",IsCoeffsElms,[IsRingElement,IsPolynomialFunction and IsUnivariateRationalFunction],0,SumCoeffUnivfunc);
InstallMethod(\+,"univariate + coeff",IsElmsCoeffs,[IsPolynomialFunction and IsUnivariateRationalFunction,IsRingElement],0,COM_FUN(69));
InstallMethod(\+,"rat + univariate",true,[IsRat,IsPolynomialFunction and IsUnivariateRationalFunction],-RankFilter(IsRat),COM_FUN(70));
InstallMethod(\+,"univariate + rat",true,[IsPolynomialFunction and IsUnivariateRationalFunction,IsRat],-RankFilter(IsRat),COM_FUN(71));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/ratfunul.gi"

#F  file="lib/ringpoly.gi" crc=-56198139
RANK_FILTER_LIST  := [ 10477489, 26, 8193, 2, 10477489, 26, 8193, 2, 
  10477489, 26, 52247917, 19, 10477489, 26, 52247917, 19, 8193, 2, 10477489, 
  26, 8193, 2, 8193, 2, 10477489, 26, 10477489, 26, 10477489, 26, 52247917, 
  19, 10477489, 26, 67108760, 5, 10477489, 26, 8193, 2, 10477489, 26, 
  67108760, 5, 8193, 2, 33646191, 34, 35414261, 27, 33646191, 34, 35414261, 
  27, 10477489, 26, 52247917, 19, 1985, 1, 52247917, 19, 10477489, 26, 
  10477489, 26, 8193, 2, 10477489, 26, 67108760, 5, 10477489, 26, 67108760, 
  5, 8193, 2, 35414261, 27, 52247917, 19, 15990440, 13, 35414261, 27, 
  63962717, 18, 10477489, 26, 63011586, 6, 35414261, 27, 39640261, 14 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/ringpoly.gi", -56198139 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/ringpoly.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/ringpoly.gi");
elif COM_RESULT = 3  then
Revision.ringpoly_gi:="@(#)$Id: ringpoly.gi,v 4.41 2003/04/16 20:43:56 gap Exp $";
BindGlobal("GiveNumbersNIndeterminates",COM_FUN(1));
InstallMethod(PolynomialRing,"indetlist",true,[IsRing,IsList],1,COM_FUN(2));
InstallMethod(PolynomialRing,"names",true,[IsRing,IsList],0,COM_FUN(3));
InstallMethod(PolynomialRing,"rank",true,[IsRing,IsPosInt],0,COM_FUN(4));
InstallOtherMethod(PolynomialRing,"rank,avoid",true,[IsRing,IsPosInt,IsList],0,COM_FUN(5));
InstallOtherMethod(PolynomialRing,"names,avoid",true,[IsRing,IsList,IsList],0,COM_FUN(6));
InstallOtherMethod(PolynomialRing,true,[IsRing],0,COM_FUN(7));
InstallMethod(UnivariatePolynomialRing,"indet 1",true,[IsRing],0,COM_FUN(8));
InstallOtherMethod(UnivariatePolynomialRing,"indet number",true,[IsRing,IsPosInt],0,COM_FUN(9));
InstallOtherMethod(UnivariatePolynomialRing,"name",true,[IsRing,IsString],0,COM_FUN(10));
InstallOtherMethod(UnivariatePolynomialRing,"avoid",true,[IsRing,IsList],0,COM_FUN(11));
InstallOtherMethod(UnivariatePolynomialRing,"name,avoid",true,[IsRing,IsString,IsList],0,COM_FUN(12));
InstallMethod(ViewObj,"for a polynomial ring",true,[IsPolynomialRing],RankFilter(IsFLMLOR),COM_FUN(13));
InstallMethod(PrintObj,"for a polynomial ring",true,[IsPolynomialRing],RankFilter(IsFLMLOR),COM_FUN(14));
InstallMethod(Indeterminate,"number",true,[IsRing,IsPosInt],0,COM_FUN(15));
InstallOtherMethod(Indeterminate,"fam,number",true,[IsFamily,IsPosInt],0,COM_FUN(16));
InstallOtherMethod(Indeterminate,"number 1",true,[IsRing],0,COM_FUN(17));
InstallOtherMethod(Indeterminate,"number, avoid",true,[IsRing,IsList],0,COM_FUN(18));
InstallOtherMethod(Indeterminate,"number, name",true,[IsRing,IsString],0,COM_FUN(19));
InstallOtherMethod(Indeterminate,"number, name, avoid",true,[IsRing,IsString,IsList],0,COM_FUN(20));
InstallMethod(\.,"pring indeterminates",true,[IsPolynomialRing,IsPosInt],COM_FUN(21));
InstallMethod(\in,"polynomial in polynomial ring",IsElmsColls,[IsRationalFunction,IsPolynomialRing],0,COM_FUN(22));
InstallMethod(DefaultRingByGenerators,true,[IsRationalFunctionCollection],0,COM_FUN(23));
InstallOtherMethod(MinimalPolynomial,"supply indeterminate 1",[IsRing,IsMultiplicativeElement and IsAdditiveElement],COM_FUN(24));
InstallMethod(StandardAssociate,"normalize leading coefficient",IsCollsElms,[IsPolynomialRing,IsPolynomial],0,COM_FUN(25));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/ringpoly.gi"

#F  file="lib/upoly.gi" crc=-61206995
RANK_FILTER_LIST  := [ 39640261, 14, 35414261, 27, 39640261, 14, 39640261, 
  14, 10477489, 26, 39640261, 14, 10477489, 26, 39640261, 14, 25270276, 48, 
  15990440, 13 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/upoly.gi", -61206995 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/upoly.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/upoly.gi");
elif COM_RESULT = 3  then
Revision.upoly_gi:="@(#)$Id: upoly.gi,v 4.48.2.2 2005/04/13 11:45:39 gap Exp $";
InstallMethod(IrrFacsPol,true,[IsPolynomial],0,COM_FUN(1));
InstallGlobalFunction(StoreFactorsPol,COM_FUN(2));
InstallMethod(IsIrreducibleRingElement,"polynomial",IsCollsElms,[IsPolynomialRing,IsPolynomial],0,COM_FUN(3));
InstallGlobalFunction(RootsOfUPol,COM_FUN(4));
RedispatchOnCondition(Factors,true,[IsPolynomial],[IsUnivariatePolynomial],0);
RedispatchOnCondition(Factors,true,[IsRing,IsPolynomial],[,IsUnivariatePolynomial],0);
RedispatchOnCondition(IsIrreducibleRingElement,true,[IsRing,IsPolynomial],[,IsUnivariatePolynomial],0);
InstallGlobalFunction(CyclotomicPol,COM_FUN(5));
InstallGlobalFunction(CyclotomicPolynomial,COM_FUN(6));
InstallMethod(IsPrimitivePolynomial,"for a (finite) field, and a polynomial",COM_FUN(7),[IsField,IsRationalFunction],0,COM_FUN(8));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/upoly.gi"

#F  file="lib/upolyirr.gi" crc=-77259681
RANK_FILTER_LIST  := [  ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/upolyirr.gi", -77259681 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/upolyirr.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/upolyirr.gi");
elif COM_RESULT = 3  then
Revision.upolyirr_gi:="@(#)$Id: upolyirr.gi,v 4.7 2002/04/15 10:05:26 sal Exp $";
AllMonicPolynomialCoeffsOfDegree:=COM_FUN(1);
IRR_POLS_OVER_GF_CACHE:=[];
AllIrreducibleMonicPolynomialCoeffsOfDegree:=COM_FUN(2);
InstallGlobalFunction(CompanionMat,COM_FUN(3));
InstallGlobalFunction(AllIrreducibleMonicPolynomials,COM_FUN(4));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/upolyirr.gi"

#F  file="lib/polyfinf.gi" crc=-103220236
RANK_FILTER_LIST  := [ 7442163, 28, 20200024, 19, 4097, 1, 7442163, 28, 
  20200024, 19, 20200024, 19, 15990440, 13, 20200024, 19 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/polyfinf.gi", -103220236 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/polyfinf.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/polyfinf.gi");
elif COM_RESULT = 3  then
Revision.polyfinf_gi:="@(#)$Id: polyfinf.gi,v 4.35.2.1 2004/01/25 02:09:37 gap Exp $";
InstallGlobalFunction(FactorsCommonDegreePol,COM_FUN(1));
InstallMethod(FactorsSquarefree,"univariate polynomial over finite field",true,[IsFiniteFieldPolynomialRing,IsUnivariatePolynomial,IsRecord],0,COM_FUN(2));
InstallGlobalFunction(RootsRepresentativeFFPol,COM_FUN(3));
InstallMethod(Factors,"polynomial over a finite field",IsCollsElms,[IsFiniteFieldPolynomialRing,IsUnivariatePolynomial],0,COM_FUN(4));
BindGlobal("ProductPP",COM_FUN(5));
BindGlobal("LcmPP",COM_FUN(6));
BindGlobal("FFPPowerModCheck",COM_FUN(7));
InstallGlobalFunction(OrderKnownDividendList,COM_FUN(8));
InstallGlobalFunction(FFPOrderKnownDividend,COM_FUN(9));
BindGlobal("FFPUpperBoundOrder",COM_FUN(10));
InstallOtherMethod(ProjectiveOrder,"divide and conquer for univariate polynomials",true,[IsUnivariatePolynomial],0,COM_FUN(11));
RedispatchOnCondition(ProjectiveOrder,true,[IsRationalFunction],[IsUnivariatePolynomial],0);
InstallMethod(SplittingField,"finite field polynomials",true,[IsUnivariatePolynomial],0,COM_FUN(12));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/polyfinf.gi"

#F  file="lib/polyrat.gi" crc=5469470
RANK_FILTER_LIST  := [ 25862396, 17, 20200024, 19, 39640261, 14, 50050162, 
  34, 20200024, 19, 20200024, 19, 20200024, 19, 17, 18, 39640261, 14, 17, 18, 
  59539217, 29, 20200024, 19, 4097, 1, 59539217, 29, 20200024, 19, 16776992, 
  5, 8193, 2, 8193, 2 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/polyrat.gi", 5469470 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/polyrat.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/polyrat.gi");
elif COM_RESULT = 3  then
Revision.polyrat_gi:="@(#)$Id: polyrat.gi,v 4.40.2.1 2004/01/25 02:09:37 gap Exp $";
InstallGlobalFunction(APolyProd,COM_FUN(1));
InstallGlobalFunction(BPolyProd,COM_FUN(2));
BindGlobal("ApproxRational",COM_FUN(3));
APPROXROOTS:=[];
BindGlobal("ApproximateRoot",COM_FUN(4));
BindGlobal("ApproxRootBound",COM_FUN(5));
InstallGlobalFunction(RootBound,COM_FUN(6));
InstallGlobalFunction(BombieriNorm,COM_FUN(7));
InstallMethod(MinimizedBombieriNorm,true,[IsPolynomial and IsRationalFunctionsFamilyElement],0,COM_FUN(8));
BindGlobal("BeauzamyBound",COM_FUN(9));
InstallGlobalFunction(OneFactorBound,COM_FUN(10));
InstallMethod(PrimitivePolynomial,"univariate polynomial",true,[IsUnivariatePolynomial],0,COM_FUN(11));
BindGlobal("PrimitiveFacExtRepRatPol",COM_FUN(12));
InstallMethod(PrimitivePolynomial,"rational polynomial",true,[IsPolynomial],0,COM_FUN(13));
BindGlobal("BeauzamyBoundGcd",COM_FUN(14));
BindGlobal("RPGcdModPrime",COM_FUN(15));
BindGlobal("RPGcdCRT",COM_FUN(16));
BindGlobal("RPGcd1",COM_FUN(17));
BindGlobal("RPIGcd",COM_FUN(18));
InstallMethod(GcdOp,"rational univariate polynomials",IsCollsElmsElms,[IsRationalsPolynomialRing and IsEuclideanRing,IsUnivariatePolynomial,IsUnivariatePolynomial],0,COM_FUN(19));
InstallMethod(\mod,"reduction of univariate rational polynomial at a prime",true,[IsUnivariatePolynomial,IsInt],0,COM_FUN(20));
InstallMethod(\mod,"reduction of general rational polynomial at a prime",true,[IsPolynomial,IsInt],0,COM_FUN(21));
BindGlobal("RPQuotientModPrime",COM_FUN(22));
BindGlobal("RPGcdRepresentationModPrime",COM_FUN(23));
InstallGlobalFunction(HenselBound,COM_FUN(24));
InstallGlobalFunction(TrialQuotientRPF,COM_FUN(25));
InstallGlobalFunction(TryCombinations,COM_FUN(26));
BindGlobal("RPSquareHensel",COM_FUN(27));
BindGlobal("RPFactorsModPrime",COM_FUN(28));
InstallMethod(FactorsSquarefree,"univariate rational poly",true,[IsRationalsPolynomialRing,IsUnivariatePolynomial,IsRecord],0,COM_FUN(29));
BindGlobal("RPIFactors",COM_FUN(30));
InstallMethod(Factors,"univariate rational polynomial",IsCollsElms,[IsRationalsPolynomialRing,IsUnivariatePolynomial],0,COM_FUN(31));
SymAdic:=COM_FUN(32);
MAXTRYGCDHEU:=6;
InstallGlobalFunction(HeuGcdIntPolsExtRep,COM_FUN(33));
InstallGlobalFunction(HeuGcdIntPolsCoeffs,COM_FUN(34));
InstallMethod(HeuristicCancelPolynomialsExtRep,"rationals",true,[IsRationalFunctionsFamily,IsList,IsList],0,COM_FUN(35));
InstallGlobalFunction(PolynomialModP,COM_FUN(36));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/polyrat.gi"

#F  file="lib/polyconw.gi" crc=-98243240
RANK_FILTER_LIST  := [  ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/polyconw.gi", -98243240 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/polyconw.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/polyconw.gi");
elif COM_RESULT = 3  then
Revision.polyconw_gi:="@(#)$Id: polyconw.gi,v 4.19.4.2 2005/05/09 07:11:37 gap Exp $";
InstallGlobalFunction(PowerModEvalPol,COM_FUN(1));
BindGlobal("CONWAYPOLYNOMIALSINFO",rec(RP:="original list by Richard Parker (from 1980's)\n",GAP:="computed with the GAP function by Thomas Breuer, just checks\nconditions st\
arting from 'smallest' polynomial\n",FL:="computed by a parallelized program by Frank Luebeck, computes\nminimal poly\
nomial of all compatible elements (~2001)\n",KM:="computed by Kate Minola, a parallelized program for p=2, considering\nminim\
al polynomials of all compatible elements (~2004)\n",RPn:="computed by Richard Parker (2004)\n",3\,21:="for p=3, n=21 there appeared a polynomial in some lists/systems\nwhich was \
not the Conway polynomial; the current one in GAP is correct\n",JB:="computed by John Bray using similar algorithm as in GAP (~2005)\n",conwdat1:=false,conwdat2:=false,conwdat3:=false));
BindGlobal("CONWAYPOLDATA",[]);
BindGlobal("IsConsistentPolynomial",COM_FUN(2));
BindGlobal("NrCompatiblePolynomials",COM_FUN(3));
ConwayCandidates:=COM_FUN(4);
InstallGlobalFunction(ConwayPol,COM_FUN(5));
InstallGlobalFunction(ConwayPolynomial,COM_FUN(6));
InstallGlobalFunction(IsCheapConwayPolynomial,COM_FUN(7));
InstallGlobalFunction(RandomPrimitivePolynomial,COM_FUN(8));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/polyconw.gi"

#F  file="lib/listcoef.gi" crc=65838264
RANK_FILTER_LIST  := [ 32106331, 39, 56879028, 37, 53597154, 15, 52247917, 
  19, 52247917, 19, 42352567, 11, 16385, 3, 32505602, 3, 52247917, 19, 
  52247917, 19, 16386, 5, 16385, 3, 32505602, 3, 52247917, 19, 52247917, 19, 
  8193, 2, 1, 0, 1, 0, 52247917, 19, 52247917, 19, 32106331, 39, 56879028, 
  37, 53597154, 15, 42352567, 11, 16385, 3, 32505602, 3, 20578051, 4, 
  20578050, 2, 257, 15, 52247917, 19, 52247917, 19, 20578051, 4, 20578050, 2, 
  257, 15, 14745813, 41, 14745812, 39, 257, 15, 52247917, 19, 52247917, 19, 
  14745813, 41, 14745812, 39, 257, 15, 16386, 5, 16385, 3, 32505602, 3, 8193, 
  2, 1, 0, 1, 0, 8193, 2, 1, 0, 8005418, 6, 32106331, 39, 56879028, 37, 
  18547111, 22, 18547110, 20, 14745813, 41, 14745812, 39, 16386, 5, 16385, 3, 
  42352567, 11, 16385, 3, 20578051, 4, 20578050, 2, 8193, 2, 1, 0, 16386, 5, 
  52247917, 19, 8193, 2, 1, 0, 16385, 3, 7665940, 21, 16386, 5, 16385, 3, 
  16385, 3, 16385, 3, 32505602, 3, 8193, 2, 1, 0, 1, 0, 1, 0, 1, 0, 16386, 5, 
  32505602, 3, 8193, 2, 1, 0, 42352567, 11, 32505602, 3, 32106331, 39, 
  53597154, 15, 14745813, 41, 257, 15, 8194, 4, 52247917, 19, 1, 0, 8193, 2, 
  1, 0, 8193, 2, 1, 0, 1, 0, 8193, 2, 7665940, 21, 1, 0, 8194, 4, 8193, 2, 
  16386, 5, 16385, 3, 16385, 3, 16385, 3, 32505602, 3, 8193, 2, 1, 0, 1, 0, 
  1, 0, 1, 0, 16386, 5, 16385, 3, 32505602, 3, 8193, 2, 1, 0, 1, 0, 16386, 5, 
  16385, 3, 16386, 5, 41951068, 17, 8193, 2, 1, 0, 8194, 4, 16385, 3, 17, 18, 
  16385, 3, 17, 18, 8193, 2, 1, 0, 17, 18, 1, 0, 17, 18, 16386, 5, 17, 18, 
  16385, 3, 17, 18, 8193, 2, 17, 18, 1, 0, 17, 18, 16386, 5, 16385, 3, 8193, 
  2, 1, 0, 16386, 5, 17, 18, 16385, 3, 17, 18, 17, 18, 8193, 2, 17, 18, 1, 0, 
  17, 18, 17, 18, 16386, 5, 16385, 3, 17, 18, 8193, 2, 1, 0, 17, 18, 16386, 
  5, 17, 18, 17, 18, 8193, 2, 17, 18, 17, 18, 16386, 5, 17, 18, 8193, 2, 17, 
  18, 16386, 5, 1, 0, 8193, 2, 1, 0, 8194, 4, 8193, 2, 16385, 3, 17, 18, 17, 
  18, 16385, 3, 17, 18, 16385, 3, 17, 18, 17, 18, 16385, 3, 17, 18, 16385, 3, 
  17, 18, 16385, 3, 16385, 3, 17, 18, 16385, 3, 17, 18, 16385, 3, 16385, 3, 
  16385, 3, 17, 18, 41951068, 17, 17, 18, 8193, 2, 64918210, 8, 8193, 2, 33, 
  17, 8193, 2, 20586242, 12, 8193, 2, 8193, 2, 20586242, 12, 20586242, 12, 
  8193, 2, 8193, 2, 58412696, 30, 25269811, 65, 8193, 2, 58412696, 30, 
  25269811, 65, 8193, 2, 17, 18, 17, 18, 58412696, 30, 25269811, 65, 8193, 2, 
  17, 18, 17, 18, 58412696, 30, 25269811, 65, 56870837, 39, 67108790, 38, 17, 
  18 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/listcoef.gi", 65838264 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/listcoef.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/listcoef.gi");
elif COM_RESULT = 3  then
Revision.listcoef_gi:="@(#)$Id: listcoef.gi,v 4.54.2.2 2005/05/12 09:10:54 gap Exp $";
InstallMethod(AddRowVector,"kernel method for plain lists of cyclotomics",IsCollsCollsElmsXX,[IsSmallList and IsDenseList and IsMutable and IsCyclotomicCollection and IsPlistRep,IsDenseList and IsCyclotomicCollection and IsPlistRep,IsCyclotomic,IsPosInt,IsPosInt],0,ADD_ROW_VECTOR_5_FAST);
InstallMethod(AddRowVector,"kernel method for small lists",IsCollsCollsElmsXX,[IsSmallList and IsDenseList and IsMutable,IsDenseList,IsMultiplicativeElement,IsPosInt,IsPosInt],0,ADD_ROW_VECTOR_5);
InstallMethod(AddRowVector,"generic method",IsCollsCollsElmsXX,[IsDenseList and IsMutable,IsDenseList,IsMultiplicativeElement,IsPosInt,IsPosInt],0,COM_FUN(1));
L1_IMMUTABLE_ERROR:=COM_FUN(2);
InstallOtherMethod(AddRowVector,"error if immutable",true,[IsList,IsObject,IsObject,IsPosInt,IsPosInt],0,L1_IMMUTABLE_ERROR);
InstallOtherMethod(AddRowVector,"kernel method for plain lists of cyclotomics(3 args)",IsCollsCollsElms,[IsSmallList and IsDenseList and IsMutable and IsCyclotomicCollection and IsPlistRep,IsDenseList and IsPlistRep and IsCyclotomicCollection,IsCyclotomic],0,ADD_ROW_VECTOR_3_FAST);
InstallOtherMethod(AddRowVector,"kernel method for small lists (3 args)",IsCollsCollsElms,[IsSmallList and IsDenseList and IsMutable,IsDenseList,IsMultiplicativeElement],0,ADD_ROW_VECTOR_3);
InstallOtherMethod(AddRowVector,"kernel method for GF2 (5 args, last 2 ignored)",IsCollsCollsElmsXX,[IsGF2VectorRep and IsMutable,IsGF2VectorRep,IS_FFE,IsPosInt,IsPosInt],0,COM_FUN(3));
InstallOtherMethod(AddRowVector,"kernel method for GF2 (3 args)",IsCollsCollsElms,[IsGF2VectorRep and IsMutable,IsGF2VectorRep,IS_FFE],0,ADDCOEFFS_GF2VEC_GF2VEC_MULT);
InstallOtherMethod(AddRowVector,"kernel method for vecffe (5 args -- ignores last 2)",IsCollsCollsElmsXX,[IsRowVector and IsMutable and IsPlistRep and IsFFECollection,IsRowVector and IsPlistRep and IsFFECollection,IS_FFE,IsPosInt,IsPosInt],0,COM_FUN(4));
InstallOtherMethod(AddRowVector,"kernel method for vecffe (3 args)",IsCollsCollsElms,[IsRowVector and IsMutable and IsPlistRep and IsFFECollection,IsRowVector and IsPlistRep and IsFFECollection,IS_FFE],0,ADD_ROWVECTOR_VECFFES_3);
InstallOtherMethod(AddRowVector,"generic method 3 args",IsCollsCollsElms,[IsDenseList and IsMutable,IsDenseList,IsMultiplicativeElement],0,COM_FUN(5));
InstallOtherMethod(AddRowVector,"error if immutable",true,[IsList,IsObject,IsObject],0,L1_IMMUTABLE_ERROR);
InstallOtherMethod(AddRowVector,"do nothing if mult is zero",IsCollsCollsElms,[IsList,IsObject,IsObject and IsZero],SUM_FLAGS,ReturnTrue);
InstallOtherMethod(AddRowVector,"kernel method for plain lists of cyclotomics (2 args)",IsIdenticalObj,[IsSmallList and IsDenseList and IsMutable and IsCyclotomicCollection and IsPlistRep,IsDenseList and IsCyclotomicCollection and IsPlistRep],0,ADD_ROW_VECTOR_2_FAST);
InstallOtherMethod(AddRowVector,"kernel method for GF2 (2 args)",IsIdenticalObj,[IsGF2VectorRep and IsMutable and IsRowVector,IsGF2VectorRep and IsRowVector],0,ADDCOEFFS_GF2VEC_GF2VEC);
InstallOtherMethod(AddRowVector,"kernel method for vecffe (2 args)",IsIdenticalObj,[IsRowVector and IsMutable and IsPlistRep and IsFFECollection,IsRowVector and IsPlistRep and IsFFECollection],0,ADD_ROWVECTOR_VECFFES_2);
InstallOtherMethod(AddRowVector,"generic method (2 args)",IsIdenticalObj,[IsDenseList and IsMutable,IsDenseList],0,COM_FUN(6));
InstallOtherMethod(AddRowVector,"kernel method for small lists (2 args)",IsIdenticalObj,[IsSmallList and IsDenseList and IsMutable,IsDenseList],0,ADD_ROW_VECTOR_2);
InstallOtherMethod(AddRowVector,"kernel method for GF2 (2 args)",IsIdenticalObj,[IsGF2VectorRep and IsMutable,IsGF2VectorRep],0,ADDCOEFFS_GF2VEC_GF2VEC);
InstallOtherMethod(AddRowVector,"error if immutable",true,[IsList,IsObject],0,L1_IMMUTABLE_ERROR);
InstallMethod(LeftShiftRowVector,"generic method",true,[IsDenseList and IsMutable,IsPosInt],0,COM_FUN(7));
InstallOtherMethod(LeftShiftRowVector,"error if immutable",true,[IsList,IsObject],0,L1_IMMUTABLE_ERROR);
InstallOtherMethod(LeftShiftRowVector,true,[IsDenseList,IsInt and IsZeroCyc],SUM_FLAGS,COM_FUN(8));
InstallMethod(MultRowVector,"generic method",true,[IsDenseList and IsMutable,IsDenseList,IsDenseList,IsDenseList,IsMultiplicativeElement],0,COM_FUN(9));
InstallOtherMethod(MultRowVector,"error if immutable",true,[IsList,IsObject,IsObject,IsObject,IsObject],0,L1_IMMUTABLE_ERROR);
InstallOtherMethod(MultRowVector,"two argument generic method",true,[IsDenseList and IsMutable,IsMultiplicativeElement],0,COM_FUN(10));
InstallOtherMethod(MultRowVector,"error if immutable",true,[IsList,IsObject],0,L1_IMMUTABLE_ERROR);
InstallOtherMethod(MultRowVector,"Two argument kernel method for small list",IsCollsElms,[IsSmallList and IsDenseList and IsMutable,IsMultiplicativeElement],0,MULT_ROW_VECTOR_2);
InstallOtherMethod(MultRowVector,"Two argument kernel method for plain list of cyclotomics and an integer",IsCollsElms,[IsSmallList and IsDenseList and IsMutable and IsPlistRep and IsCyclotomicCollection,IsCyclotomic],0,MULT_ROW_VECTOR_2_FAST);
InstallOtherMethod(MultRowVector,"kernel method for vecffe (2 args)",IsCollsElms,[IsRowVector and IsMutable and IsPlistRep and IsFFECollection,IsFFE],0,MULT_ROWVECTOR_VECFFES);
InstallMethod(RightShiftRowVector,"generic method",true,[IsList and IsMutable,IsPosInt,IsObject],0,COM_FUN(11));
InstallOtherMethod(RightShiftRowVector,"error if immutable",true,[IsList,IsObject],0,L1_IMMUTABLE_ERROR);
InstallOtherMethod(RightShiftRowVector,"error if immutable",true,[IsList,IsObject,IsObject],0,L1_IMMUTABLE_ERROR);
InstallOtherMethod(RightShiftRowVector,true,[IsList,IsInt and IsZeroCyc,IsObject],SUM_FLAGS,COM_FUN(12));
InstallMethod(ShrinkRowVector,"generic method",true,[IsList and IsMutable],0,COM_FUN(13));
InstallOtherMethod(ShrinkRowVector,"error if immutable",true,[IsList],0,L1_IMMUTABLE_ERROR);
InstallMethod(AddCoeffs,"generic method (5 args)",true,[IsDenseList and IsMutable,IsDenseList,IsDenseList,IsDenseList,IsMultiplicativeElement],0,COM_FUN(14));
InstallOtherMethod(AddCoeffs,"error if immutable",true,[IsList,IsObject,IsObject,IsObject,IsObject],0,L1_IMMUTABLE_ERROR);
InstallOtherMethod(AddCoeffs,"generic method 3args",true,[IsDenseList and IsMutable,IsDenseList,IsMultiplicativeElement],0,ADDCOEFFS_GENERIC_3);
InstallOtherMethod(AddCoeffs,"error if immutable",true,[IsList,IsObject,IsObject],0,L1_IMMUTABLE_ERROR);
InstallOtherMethod(AddCoeffs,"generic method (2 args)",true,[IsDenseList and IsMutable,IsDenseList],0,COM_FUN(15));
InstallOtherMethod(AddCoeffs,"generic method (2nd arg empty)",true,[IsDenseList and IsMutable,IsList and IsEmpty],0,COM_FUN(16));
InstallOtherMethod(AddCoeffs,"error if immutable",true,[IsList,IsObject],0,L1_IMMUTABLE_ERROR);
InstallMethod(MultCoeffs,"generic method",true,[IsList and IsMutable,IsDenseList,IsInt,IsDenseList,IsInt],0,COM_FUN(17));
InstallOtherMethod(MultCoeffs,"error if immutable",true,[IsList,IsObject,IsInt,IsObject,IsInt],0,L1_IMMUTABLE_ERROR);
InstallMethod(ReduceCoeffs,"generic method",true,[IsDenseList and IsMutable,IsInt,IsDenseList,IsInt],0,COM_FUN(18));
InstallOtherMethod(ReduceCoeffs,"error if immutable",true,[IsList,IsInt,IsObject,IsInt],0,L1_IMMUTABLE_ERROR);
InstallOtherMethod(ReduceCoeffs,true,[IsDenseList and IsMutable,IsDenseList],0,COM_FUN(19));
InstallOtherMethod(ReduceCoeffs,"error if immutable",true,[IsList,IsObject],0,L1_IMMUTABLE_ERROR);
InstallMethod(ReduceCoeffsMod,"generic method (5 args)",true,[IsDenseList and IsMutable,IsInt,IsDenseList,IsInt,IsInt],0,COM_FUN(20));
InstallOtherMethod(ReduceCoeffsMod,"error if immutable",true,[IsList,IsInt,IsObject,IsInt,IsInt],0,L1_IMMUTABLE_ERROR);
InstallOtherMethod(ReduceCoeffsMod,"generic: list,list,int",true,[IsDenseList and IsMutable,IsDenseList,IsInt],0,COM_FUN(21));
InstallOtherMethod(ReduceCoeffsMod,"error if immutable",true,[IsList,IsObject,IsInt],0,L1_IMMUTABLE_ERROR);
InstallOtherMethod(ReduceCoeffsMod,"generic: list, int,int",true,[IsDenseList and IsMutable,IsInt,IsInt],0,COM_FUN(22));
InstallOtherMethod(ReduceCoeffsMod,"error if immutable",true,[IsList,IsInt,IsInt],0,L1_IMMUTABLE_ERROR);
InstallOtherMethod(ReduceCoeffsMod,true,[IsDenseList and IsMutable,IsInt],0,COM_FUN(23));
InstallOtherMethod(ReduceCoeffsMod,"error if immutable",true,[IsList,IsInt],0,L1_IMMUTABLE_ERROR);
InstallMethod(RemoveOuterCoeffs,"generic method",true,[IsDenseList and IsMutable,IsObject],0,REMOVE_OUTER_COEFFS_GENERIC);
InstallOtherMethod(RemoveOuterCoeffs,"error if immutable",true,[IsList,IsObject],0,L1_IMMUTABLE_ERROR);
InstallMethod(ShrinkCoeffs,"call `ShrinkRowVector'",true,[IsList and IsMutable],0,COM_FUN(24));
InstallOtherMethod(ShrinkCoeffs,"error if immutable",true,[IsList],0,L1_IMMUTABLE_ERROR);
InstallMethod(CoeffsMod,"call `ReduceCoeffsMod'",true,[IsDenseList,IsInt,IsInt],0,COM_FUN(25));
InstallOtherMethod(CoeffsMod,true,[IsDenseList,IsInt],0,COM_FUN(26));
InstallMethod(PowerModCoeffs,"default five argt method",true,[IsDenseList,IsInt,IsInt,IsDenseList,IsInt],0,COM_FUN(27));
InstallOtherMethod(PowerModCoeffs,"default, 3 argt",true,[IsDenseList,IsInt,IsDenseList],0,COM_FUN(28));
InstallMethod(ProductCoeffs,"call PRODUCT_COEFFS_GENERIC_LISTS",true,[IsDenseList,IsInt,IsDenseList,IsInt],0,PRODUCT_COEFFS_GENERIC_LISTS);
InstallOtherMethod(ProductCoeffs,"call PRODUCT_COEFFS_GENERIC_LISTS with lengths",true,[IsDenseList,IsDenseList],0,COM_FUN(29));
InstallMethod(ShiftedCoeffs,"call ShiftRowVektor",true,[IsDenseList,IsInt],0,COM_FUN(30));
InstallMethod(ShiftedCoeffs,"empty list",true,[IsList and IsEmpty,IsInt],0,COM_FUN(31));
InstallGlobalFunction(ProductPol,COM_FUN(32));
InstallMethod(ValuePol,"generic",true,[IsList,IsRingElement],0,COM_FUN(33));
InstallMethod(ValuePol,"special code for rational values",true,[IsList,IsRat],0,COM_FUN(34));
QuotRemPolList:=COM_FUN(35);
InstallMethod(WeightVecFFE,"generic",true,[IsList],0,COM_FUN(36));
InstallMethod(WeightVecFFE,"gf2 vectors",true,[IsGF2VectorRep and IsList],0,COM_FUN(37));
InstallMethod(DistanceVecFFE,"generic",IsIdenticalObj,[IsList,IsList],0,COM_FUN(38));
InstallMethod(DistanceVecFFE,"gf2 vectors",IsIdenticalObj,[IsGF2VectorRep and IsList,IsGF2VectorRep and IsList],0,DIST_GF2VEC_GF2VEC);
InstallMethod(DistancesDistributionVecFFEsVecFFE,"generic",IsCollsElms,[IsList,IsList],0,COM_FUN(39));
DistVecClosVecLib:=COM_FUN(40);
InstallMethod(DistancesDistributionMatFFEVecFFE,"generic",IsCollsElmsElms,[IsMatrix,IsFFECollection and IsField,IsList],0,COM_FUN(41));
AClosVecLib:=COM_FUN(42);
AClosestVectorDriver:=COM_FUN(43);
InstallMethod(AClosestVectorCombinationsMatFFEVecFFE,"generic",COM_FUN(44),[IsMatrix,IsFFECollection and IsField,IsList,IsInt,IsInt],0,COM_FUN(45));
InstallMethod(AClosestVectorCombinationsMatFFEVecFFECoords,"generic",COM_FUN(46),[IsMatrix,IsFFECollection and IsField,IsList,IsInt,IsInt],0,COM_FUN(47));
CosetLeadersInner:=COM_FUN(48);
MakeReadOnlyGlobal("CosetLeadersInner");
InstallMethod(CosetLeadersMatFFE,"generic",IsCollsElms,[IsMatrix,IsFFECollection and IsField],0,COM_FUN(49));
InstallMethod(AddToListEntries,"fast kernel method",true,[IsList and IsPlistRep and IsMutable and IsCyclotomicCollection,IsRange and IsRangeRep,IsInt],0,ADD_TO_LIST_ENTRIES_PLIST_RANGE);
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/listcoef.gi"

#F  file="lib/algfld.gi" crc=12127295
RANK_FILTER_LIST  := [ 20200024, 19, 25270276, 48, 20200024, 19, 25270276, 
  48, 20200024, 19, 25270276, 48, 20200024, 19, 67108760, 5, 25270276, 48, 
  20200024, 19, 65010108, 13, 10484336, 13, 33554253, 4, 64918210, 8, 
  33554253, 4, 8193, 2, 12582148, 13, 25165255, 13, 12582148, 13, 25165255, 
  13, 25165255, 13, 25165255, 13, 25165255, 13, 12582148, 13, 12582148, 13, 
  25165255, 13, 12582148, 13, 12582148, 13, 25165255, 13, 64918210, 8, 
  64918210, 8, 25165255, 13, 12582148, 13, 64918210, 8, 64918210, 8, 
  12582148, 13, 25165255, 13, 12582148, 13, 25165255, 13, 25165255, 13, 
  25165255, 13, 12582148, 13, 12582148, 13, 25165255, 13, 12582148, 13, 
  12582148, 13, 52427961, 11, 64918210, 8, 64918210, 8, 52427961, 11, 
  52427961, 11, 63198130, 7, 63198130, 7, 52427961, 11, 25165255, 13, 
  12582148, 13, 25165255, 13, 25165255, 13, 25165255, 13, 12582148, 13, 
  12582148, 13, 25165255, 13, 12582148, 13, 12582148, 13, 25165255, 13, 
  64918210, 8, 64918210, 8, 25165255, 13, 12582148, 13, 64918210, 8, 
  64918210, 8, 12582148, 13, 25165255, 13, 25165255, 13, 25165255, 13, 
  12582148, 13, 12582148, 13, 25165255, 13, 12582148, 13, 12582148, 13, 
  25165255, 13, 64918210, 8, 64918210, 8, 25165255, 13, 12582148, 13, 
  64918210, 8, 64918210, 8, 12582148, 13, 52427961, 11, 52247917, 19, 
  52427961, 11, 67108505, 49, 64918210, 8, 67108505, 49, 25270276, 48, 
  52427961, 11, 52247917, 19, 67108505, 49, 33, 17, 65010108, 13, 10484336, 
  13, 67108505, 49, 67108505, 49, 50331469, 12, 50331469, 12, 52427961, 11, 
  50331469, 12, 30625149, 10, 52427961, 11, 37756194, 23, 34602579, 35, 
  67108505, 49, 29769609, 28, 20200024, 19, 4097, 1, 29769609, 28, 20200024, 
  19, 29769609, 28, 20200024, 19 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/algfld.gi", 12127295 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/algfld.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/algfld.gi");
elif COM_RESULT = 3  then
Revision.algfld_gi:="@(#)$Id: algfld.gi,v 4.51.2.1 2004/01/25 02:09:37 gap Exp $";
DeclareRepresentation("IsAlgebraicExtensionDefaultRep",IsAlgebraicExtension and IsComponentObjectRep and IsAttributeStoringRep,["extFam"]);
DeclareRepresentation("IsAlgBFRep",IsPositionalObjectRep and IsAlgebraicElement,[]);
DeclareRepresentation("IsAlgExtRep",IsPositionalObjectRep and IsAlgebraicElement,[]);
InstallMethod(AlgebraicElementsFamilies,true,[IsUnivariatePolynomial],0,COM_FUN(1));
StoreAlgExtFam:=COM_FUN(2);
InstallMethod(AlgebraicElementsFamily,"generic",true,[IsField,IsUnivariatePolynomial],0,COM_FUN(3));
DoAlgebraicExt:=COM_FUN(4);
InstallMethod(AlgebraicExtension,"generic",true,[IsField,IsUnivariatePolynomial],0,DoAlgebraicExt);
InstallOtherMethod(AlgebraicExtension,"with name",true,[IsField,IsUnivariatePolynomial,IsString],0,DoAlgebraicExt);
InstallMethod(FieldExtension,"generic",true,[IsField,IsUnivariatePolynomial],0,AlgebraicExtension);
InstallMethod(ExtRepOfObj,"baseFieldElm",true,[IsAlgebraicElement and IsAlgBFRep],0,COM_FUN(5));
InstallMethod(ExtRepOfObj,"ExtElm",true,[IsAlgebraicElement and IsAlgExtRep],0,COM_FUN(6));
InstallMethod(ObjByExtRep,"baseFieldElm",true,[IsAlgebraicElementFamily,IsRingElement],0,COM_FUN(7));
InstallMethod(ObjByExtRep,"ExtElm",true,[IsAlgebraicElementFamily,IsList],0,COM_FUN(8));
BindGlobal("AlgExtElm",COM_FUN(9));
InstallMethod(PrintObj,"BFElm",true,[IsAlgBFRep],0,COM_FUN(10));
InstallMethod(PrintObj,"AlgElm",true,[IsAlgExtRep],0,COM_FUN(11));
InstallMethod(String,"BFElm",true,[IsAlgBFRep],0,COM_FUN(12));
InstallMethod(String,"AlgElm",true,[IsAlgExtRep],0,COM_FUN(13));
InstallMethod(\+,"AlgElm+AlgElm",IsIdenticalObj,[IsAlgExtRep,IsAlgExtRep],0,COM_FUN(14));
InstallMethod(\+,"AlgElm+BFElm",IsIdenticalObj,[IsAlgExtRep,IsAlgBFRep],0,COM_FUN(15));
InstallMethod(\+,"BFElm+AlgElm",IsIdenticalObj,[IsAlgBFRep,IsAlgExtRep],0,COM_FUN(16));
InstallMethod(\+,"BFElm+BFElm",IsIdenticalObj,[IsAlgBFRep,IsAlgBFRep],0,COM_FUN(17));
InstallMethod(\+,"AlgElm+FElm",IsElmsCoeffs,[IsAlgExtRep,IsRingElement],0,COM_FUN(18));
InstallMethod(\+,"FElm+AlgElm",IsCoeffsElms,[IsRingElement,IsAlgExtRep],0,COM_FUN(19));
InstallMethod(\+,"BFElm+FElm",IsElmsCoeffs,[IsAlgBFRep,IsRingElement],0,COM_FUN(20));
InstallMethod(\+,"FElm+BFElm",IsCoeffsElms,[IsRingElement,IsAlgBFRep],0,COM_FUN(21));
InstallMethod(AdditiveInverseOp,"AlgElm",true,[IsAlgExtRep],0,COM_FUN(22));
InstallMethod(AdditiveInverseOp,"BFElm",true,[IsAlgBFRep],0,COM_FUN(23));
InstallMethod(\*,"AlgElm*AlgElm",IsIdenticalObj,[IsAlgExtRep,IsAlgExtRep],0,COM_FUN(24));
InstallMethod(\*,"AlgElm*BFElm",IsIdenticalObj,[IsAlgExtRep,IsAlgBFRep],0,COM_FUN(25));
InstallMethod(\*,"BFElm*AlgElm",IsIdenticalObj,[IsAlgBFRep,IsAlgExtRep],0,COM_FUN(26));
InstallMethod(\*,"BFElm*BFElm",IsIdenticalObj,[IsAlgBFRep,IsAlgBFRep],0,COM_FUN(27));
InstallMethod(\*,"Alg*FElm",IsElmsCoeffs,[IsAlgebraicElement,IsRingElement],0,COM_FUN(28));
InstallMethod(\*,"FElm*Alg",IsCoeffsElms,[IsRingElement,IsAlgebraicElement],0,COM_FUN(29));
InstallMethod(\*,"Alg*List",true,[IsAlgebraicElement,IsVector],0,COM_FUN(30));
InstallMethod(\*,"List*Alg",true,[IsVector,IsAlgebraicElement],0,COM_FUN(31));
InstallMethod(InverseOp,"AlgElm",true,[IsAlgExtRep],0,COM_FUN(32));
InstallMethod(InverseOp,"BFElm",true,[IsAlgBFRep],0,COM_FUN(33));
InstallMethod(\<,"AlgElm<AlgElm",IsIdenticalObj,[IsAlgExtRep,IsAlgExtRep],0,COM_FUN(34));
InstallMethod(\<,"AlgElm<BFElm",IsIdenticalObj,[IsAlgExtRep,IsAlgBFRep],0,COM_FUN(35));
InstallMethod(\<,"BFElm<AlgElm",IsIdenticalObj,[IsAlgBFRep,IsAlgExtRep],0,COM_FUN(36));
InstallMethod(\<,"BFElm<BFElm",IsIdenticalObj,[IsAlgBFRep,IsAlgBFRep],0,COM_FUN(37));
InstallMethod(\<,"AlgElm<FElm",true,[IsAlgExtRep,IsRingElement],0,COM_FUN(38));
InstallMethod(\<,"FElm<AlgElm",true,[IsRingElement,IsAlgExtRep],0,COM_FUN(39));
InstallMethod(\<,"BFElm<FElm",true,[IsAlgBFRep,IsRingElement],0,COM_FUN(40));
InstallMethod(\<,"FElm<BFElm",true,[IsRingElement,IsAlgBFRep],0,COM_FUN(41));
InstallMethod(\=,"AlgElm=AlgElm",IsIdenticalObj,[IsAlgExtRep,IsAlgExtRep],0,COM_FUN(42));
InstallMethod(\=,"AlgElm=BFElm",IsIdenticalObj,[IsAlgExtRep,IsAlgBFRep],0,COM_FUN(43));
InstallMethod(\=,"BFElm<AlgElm",IsIdenticalObj,[IsAlgBFRep,IsAlgExtRep],0,COM_FUN(44));
InstallMethod(\=,"BFElm=BFElm",IsIdenticalObj,[IsAlgBFRep,IsAlgBFRep],0,COM_FUN(45));
InstallMethod(\=,"AlgElm=FElm",true,[IsAlgExtRep,IsRingElement],0,COM_FUN(46));
InstallMethod(\=,"FElm=AlgElm",true,[IsRingElement,IsAlgExtRep],0,COM_FUN(47));
InstallMethod(\=,"BFElm=FElm",true,[IsAlgBFRep,IsRingElement],0,COM_FUN(48));
InstallMethod(\=,"FElm=BFElm",true,[IsRingElement,IsAlgBFRep],0,COM_FUN(49));
InstallMethod(\mod,"AlgElm",IsElmsCoeffs,[IsAlgebraicElement,IsPosInt],0,COM_FUN(50));
InstallMethod(\in,"Alg in Ext",true,[IsAlgebraicElement,IsAlgebraicExtension],0,COM_FUN(51));
InstallMethod(\in,"FElm in Ext",true,[IsRingElement,IsAlgebraicExtension],0,COM_FUN(52));
InstallMethod(MinimalPolynomial,"AlgElm",true,[IsField,IsAlgebraicElement,IsPosInt],0,COM_FUN(53));
InstallMethod(Random,"Alg",true,[IsAlgebraicExtension],0,COM_FUN(54));
InstallMethod(MaxNumeratorCoeffAlgElm,"rational",true,[IsRat],0,COM_FUN(55));
InstallMethod(MaxNumeratorCoeffAlgElm,"algebraic element",true,[IsAlgebraicElement and IsAlgBFRep],0,COM_FUN(56));
InstallMethod(MaxNumeratorCoeffAlgElm,"algebraic element",true,[IsAlgebraicElement and IsAlgExtRep],0,COM_FUN(57));
InstallMethod(Basis,"for an algebraic extension (delegate to `CanonicalBasis')",[IsAlgebraicExtension],CANONICAL_BASIS_FLAGS,CanonicalBasis);
DeclareRepresentation("IsCanonicalBasisAlgebraicExtension",IsBasis and IsCanonicalBasis and IsAttributeStoringRep,[]);
InstallMethod(CanonicalBasis,"for an algebraic extension",true,[IsAlgebraicExtension],0,COM_FUN(58));
InstallMethod(BasisVectors,"for canon. basis of an algebraic extension",[IsCanonicalBasisAlgebraicExtension],COM_FUN(59));
InstallMethod(Coefficients,"for canon. basis of an algebraic extension, and alg. element",IsCollsElms,[IsCanonicalBasisAlgebraicExtension,IsAlgebraicElement],0,COM_FUN(60));
InstallMethod(Coefficients,"for canon. basis of an algebraic extension, and scalar",true,[IsCanonicalBasisAlgebraicExtension,IsScalar],0,COM_FUN(61));
InstallMethod(Characteristic,"alg elm",true,[IsAlgebraicElement],0,COM_FUN(62));
InstallMethod(DefaultFieldByGenerators,"alg elms",[IsList and IsAlgebraicElementCollection],0,COM_FUN(63));
InstallMethod(DefaultFieldOfMatrixGroup,"alg elms",[IsGroup and IsAlgebraicElementCollCollColl and HasGeneratorsOfGroup],0,COM_FUN(64));
InstallGlobalFunction(AlgExtEmbeddedPol,COM_FUN(65));
BindGlobal("AlgExtFactSQFree",COM_FUN(66));
InstallMethod(DefectApproximation,"Algebraic Extension",true,[IsAlgebraicExtension],0,COM_FUN(67));
BindGlobal("ChaNuPol",COM_FUN(68));
BindGlobal("AlgebraicPolynomialModP",COM_FUN(69));
BindGlobal("AlgFacUPrep",COM_FUN(70));
BindGlobal("TransferedExtensionPol",COM_FUN(71));
BindGlobal("OrthogonalityDefectEuclideanLattice",COM_FUN(72));
InstallGlobalFunction(AlgExtSquareHensel,COM_FUN(73));
InstallMethod(FactorsSquarefree,"polynomial/alg. ext.",IsCollsElmsX,[IsAlgebraicExtensionPolynomialRing,IsUnivariatePolynomial,IsRecord],COM_FUN(74));
InstallMethod(Factors,"alg ext polynomial",IsCollsElms,[IsAlgebraicExtensionPolynomialRing,IsUnivariatePolynomial],0,COM_FUN(75));
InstallMethod(IsIrreducibleRingElement,"AlgPol",true,[IsAlgebraicExtensionPolynomialRing,IsUnivariatePolynomial],0,COM_FUN(76));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/algfld.gi"

#F  file="lib/groebner.gi" crc=-89902814
RANK_FILTER_LIST  := [ 18660446, 5, 5, 1, 39640261, 14, 15990440, 13, 
  42884663, 1, 15990440, 13, 42884663, 1, 15990440, 13, 42884663, 1, 
  63995485, 25, 42884663, 1, 46251143, 33, 46251143, 33, 42884663, 1, 
  9284428, 34, 42884663, 1, 63995485, 25, 42884663, 1, 46251143, 33, 
  42884663, 1, 39640261, 14, 46251143, 33 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/groebner.gi", -89902814 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/groebner.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/groebner.gi");
elif COM_RESULT = 3  then
Revision.groebner_gi:="@(#)$Id: groebner.gi,v 4.1.2.1 2005/01/18 22:35:33 gap Exp $";
BindGlobal("MakeMonomialOrdering",COM_FUN(1));
BindGlobal("InstallMonomialOrdering",COM_FUN(2));
InstallMethod(MonomialComparisonFunction,"default: use extrep",true,[IsMonomialOrderingDefaultRep],0,COM_FUN(3));
InstallMonomialOrdering(MonomialLexOrdering,COM_FUN(4),COM_FUN(5),"lp");
InstallMonomialOrdering(MonomialGrlexOrdering,COM_FUN(6),COM_FUN(7),"Dp");
InstallMonomialOrdering(MonomialGrevlexOrdering,COM_FUN(8),COM_FUN(9),"dp");
InstallGlobalFunction(EliminationOrdering,COM_FUN(10));
InstallMethod(MonomialExtrepComparisonFun,"functions are themselves -- for compatibility",true,[IsFunction],0,COM_FUN(1\
1));
InstallOtherMethod(OccuringVariableIndices,"polynomial",true,[IsPolynomial],0,COM_FUN(12));
InstallMethod(LeadingTermOfPolynomial,"with ordering",true,[IsRationalFunction,IsMonomialOrdering],0,COM_FUN(13));
InstallOtherMethod(LeadingMonomialOfPolynomial,"with ordering",true,[IsRationalFunction,IsMonomialOrdering],0,COM_FUN(14));
InstallOtherMethod(LeadingCoefficientOfPolynomial,"with ordering",true,[IsRationalFunction,IsMonomialOrdering],0,COM_FUN(15));
BindGlobal("SPolynomial",COM_FUN(16));
InstallGlobalFunction(PolynomialReduction,COM_FUN(17));
InstallGlobalFunction(PolynomialReducedRemainder,COM_FUN(18));
InstallGlobalFunction(PolynomialDivisionAlgorithm,COM_FUN(19));
BindGlobal("SyzygyCriterion",COM_FUN(20));
BindGlobal("GAPGBASIS",rec(name:="naive GAP version of Buchberger's algorithm",GroebnerBasis:=COM_FUN(21)));
GBASIS:=GAPGBASIS;
InstallGlobalFunction(GroebnerBasisNC,COM_FUN(22));
InstallMethod(GroebnerBasis,"polynomials",true,[IsHomogeneousList and IsRationalFunctionCollection,IsMonomialOrdering],0,COM_FUN(23));
InstallMethod(StoredGroebnerBasis,"ideal",true,[IsPolynomialRingIdeal],0,COM_FUN(24));
InstallMethod(GroebnerBasis,"ideal",true,[IsPolynomialRingIdeal,IsMonomialOrdering],0,COM_FUN(25));
InstallMethod(GroebnerBasis,"ideal with stored GB",true,[IsPolynomialRingIdeal and HasStoredGroebnerBasis,IsMonomialOrdering],0,COM_FUN(26));
InstallMethod(ReducedGroebnerBasis,"polynomials",true,[IsHomogeneousList and IsRationalFunctionCollection,IsMonomialOrdering],0,COM_FUN(27));
InstallMethod(ReducedGroebnerBasis,"ideal",true,[IsPolynomialRingIdeal,IsMonomialOrdering],0,COM_FUN(28));
InstallMethod(\in,"polynomial ideal",true,[IsPolynomial,IsPolynomialRingIdeal],0,COM_FUN(29));
BindGlobal("Naive",COM_FUN(30));
BindGlobal("CANGB",COM_FUN(31));
DoTest:=COM_FUN(32);
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/groebner.gi"

#F  file="lib/unknown.gi" crc=-2995805
RANK_FILTER_LIST  := [ 52247917, 19, 28332735, 18, 61887557, 16, 65, 16, 65, 
  16, 61887557, 16, 28332735, 18, 28332735, 18, 61887557, 16, 65, 16, 65, 16, 
  61887557, 16, 28332735, 18, 28332735, 18, 61887557, 16, 65, 16, 65, 16, 
  61887557, 16, 61887557, 16, 61887557, 16, 61887557, 16, 65, 16, 65, 16, 
  61887557, 16, 28332735, 18, 28332735, 18, 61887557, 16, 65, 16, 65, 16, 
  61887557, 16, 61887557, 16, 61887557, 16, 61887557, 16, 65, 16, 61887557, 
  16, 52247917, 19, 28332735, 18 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/unknown.gi", -2995805 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/unknown.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/unknown.gi");
elif COM_RESULT = 3  then
Revision.unknown_gi:="@(#)$Id: unknown.gi,v 4.9 2002/04/15 10:05:25 sal Exp $";
DeclareRepresentation("IsUnknownDefaultRep",IsPositionalObjectRep,[1]);
BindGlobal("UnknownsType",NewType(CyclotomicsFamily,IsUnknown and IsUnknownDefaultRep));
InstallMethod(Unknown,"for positive integer",true,[IsPosInt],0,COM_FUN(1));
InstallMethod(Unknown,"for empty argument",true,[],0,COM_FUN(2));
InstallMethod(PrintObj,"for unknown in default representation",true,[IsUnknown and IsUnknownDefaultRep],0,COM_FUN(3));
InstallMethod(\=,"for unknown and cyclotomic",true,[IsUnknown,IsCyc],0,ReturnFalse);
InstallMethod(\=,"for cyclotomic and unknown",true,[IsCyc,IsUnknown],0,ReturnFalse);
InstallMethod(\=,"for two unknowns in default representation",true,[IsUnknown and IsUnknownDefaultRep,IsUnknown and IsUnknownDefaultRep],0,COM_FUN(4));
InstallMethod(\<,"for unknown and cyclotomic",true,[IsUnknown,IsCyc],0,ReturnFalse);
InstallMethod(\<,"for cyclotomic and unknown",true,[IsCyc,IsUnknown],0,ReturnTrue);
InstallMethod(\<,"for two unknowns in default representation",true,[IsUnknown and IsUnknownDefaultRep,IsUnknown and IsUnknownDefaultRep],0,COM_FUN(5));
InstallMethod(\+,"for unknown and cyclotomic",true,[IsUnknown,IsCyc],0,COM_FUN(6));
InstallMethod(\+,"for cyclotomic and unknown",true,[IsCyc,IsUnknown],0,COM_FUN(7));
InstallMethod(\+,"for two unknowns",true,[IsUnknown,IsUnknown],0,COM_FUN(8));
InstallMethod(\-,"for unknown and cyclotomic",true,[IsUnknown,IsCyc],0,COM_FUN(9));
InstallMethod(\-,"for cyclotomic and unknown",true,[IsCyc,IsUnknown],0,COM_FUN(10));
InstallMethod(\-,"for two unknowns in default representation",true,[IsUnknown and IsUnknownDefaultRep,IsUnknown and IsUnknownDefaultRep],0,COM_FUN(11));
InstallMethod(\*,"for unknown and cyclotomic",true,[IsUnknown,IsCyc],0,COM_FUN(12));
InstallMethod(\*,"for cyclotomic and unknown",true,[IsCyc,IsUnknown],0,COM_FUN(13));
InstallMethod(\*,"for two unknowns",true,[IsUnknown,IsUnknown],0,COM_FUN(14));
InstallMethod(\/,"for unknown and cyclotomic",true,[IsUnknown,IsCyc],0,COM_FUN(15));
InstallMethod(\^,"for unknown and positive integer",true,[IsUnknown,IsPosInt],0,COM_FUN(16));
InstallMethod(String,"for an unknown in default representation",true,[IsUnknown and IsUnknownDefaultRep],0,COM_FUN(17));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/unknown.gi"

#F  file="lib/field.gi" crc=-67356484
RANK_FILTER_LIST  := [ 8126465, 2, 4417712, 46, 8126465, 2, 8126465, 2, 
  8126465, 2, 4417712, 46, 30625149, 10, 4403793, 48, 30625149, 10, 4417712, 
  46, 8126465, 2, 4417712, 46, 41951068, 17, 25270276, 48, 34587861, 49, 
  25270276, 48, 4417712, 46, 4417712, 46, 55362102, 50, 4417712, 46, 
  25270276, 48, 25270276, 48, 25270276, 48, 16800902, 7, 55362102, 50, 
  30091827, 48, 25270276, 48, 25270276, 48, 30625149, 10, 4417712, 46, 
  13735297, 47, 13735297, 47, 13735297, 47, 55362102, 50, 55362102, 50, 
  55362102, 50, 4417712, 46, 4417712, 46, 4417712, 46, 4417712, 46, 8126465, 
  2, 4417712, 46, 8126465, 2, 4417712, 46, 4417712, 46, 4417712, 46, 4417712, 
  46, 30625149, 10, 25270276, 48, 30625149, 10, 25270276, 48, 25270276, 48, 
  30625149, 10, 3553505, 49, 25270276, 48, 30625149, 10, 30625149, 10, 
  25270276, 48, 30625149, 10, 3553505, 49, 25270276, 48, 30625149, 10, 
  25270276, 48, 25270276, 48, 30625149, 10, 30625149, 10, 25270276, 48, 
  30625149, 10, 3553505, 49, 25270276, 48, 30625149, 10, 25270276, 48, 
  25270276, 48, 30625149, 10, 25270276, 48, 30625149, 10, 52247917, 19, 
  25270276, 48, 25270276, 48, 30625149, 10, 52247917, 19, 25270276, 48, 
  25270276, 48, 30625149, 10, 25270276, 48, 25270276, 48, 30625149, 10, 
  25270276, 48, 25270276, 48, 30625149, 10, 52247917, 19, 14609503, 27, 
  14609503, 27, 1, 0, 14609503, 27, 1, 0, 25270276, 48, 64918210, 8, 
  64918210, 8, 25270276, 48, 64918210, 8, 4417712, 46, 25259116, 53, 
  25270276, 48, 64918210, 8, 64918210, 8, 25270276, 48, 30625149, 10, 
  25270276, 48, 30625149, 10, 49346896, 7, 40582329, 23, 40582329, 23, 
  40582329, 23, 40582329, 23, 40582329, 23, 40582329, 23, 25270276, 48, 
  40582329, 23, 1, 0, 40582329, 23, 25270276, 48 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/field.gi", -67356484 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/field.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/field.gi");
elif COM_RESULT = 3  then
Revision.field_gi:="@(#)$Id: field.gi,v 4.65 2003/04/11 18:05:30 gap Exp $";
InstallOtherMethod(DivisionRingByGenerators,"for a collection",[IsCollection],COM_FUN(1));
InstallMethod(DivisionRingByGenerators,"for a division ring, and a collection",IsIdenticalObj,[IsDivisionRing,IsCollection],COM_FUN(2));
InstallMethod(FieldOverItselfByGenerators,"for a collection",[IsCollection],COM_FUN(3));
InstallMethod(DefaultFieldByGenerators,"for a collection",[IsCollection],DivisionRingByGenerators);
InstallGlobalFunction(Field,COM_FUN(4));
InstallGlobalFunction(DefaultField,COM_FUN(5));
InstallGlobalFunction(Subfield,COM_FUN(6));
InstallGlobalFunction(SubfieldNC,COM_FUN(7));
InstallMethod(ClosureDivisionRing,"for a division ring and a scalar",IsCollsElms,[IsDivisionRing,IsScalar],COM_FUN(8));
InstallMethod(ClosureDivisionRing,"for a division ring containing the whole family, and a scalar",IsCollsElms,[IsDivisionRing and IsWholeFamily,IsScalar],SUM_FLAGS,COM_FUN(9));
InstallMethod(ClosureDivisionRing,"for division ring and collection of elements",IsIdenticalObj,[IsDivisionRing,IsCollection],COM_FUN(10));
InstallMethod(ClosureDivisionRing,"for division ring and empty list",[IsDivisionRing,IsList and IsEmpty],COM_FUN(11));
InstallMethod(ViewObj,"for a field",[IsField],COM_FUN(12));
InstallMethod(PrintObj,"for a field with known generators",[IsField and HasGeneratorsOfField],COM_FUN(13));
InstallMethod(PrintObj,"for a field",[IsField],COM_FUN(14));
InstallMethod(IsTrivial,"for a division ring",[IsDivisionRing],ReturnFalse);
InstallMethod(PrimeField,"for a division ring",[IsDivisionRing],COM_FUN(15));
InstallMethod(PrimeField,"for a prime field",[IsField and IsPrimeField],IdFunc);
InstallMethod(IsPrimeField,"for a division ring",[IsDivisionRing],COM_FUN(16));
InstallMethod(IsNumberField,"for a field",[IsField],COM_FUN(17));
InstallMethod(IsAbelianNumberField,"for a field",[IsField],COM_FUN(18));
InstallMethod(IsCyclotomicField,"for a field",[IsField],COM_FUN(19));
InstallMethod(IsNormalBasis,"for a basis of a field",[IsBasis],COM_FUN(20));
InstallMethod(GeneratorsOfDivisionRing,"for a prime field",[IsField and IsPrimeField],COM_FUN(21));
InstallImmediateMethod(DegreeOverPrimeField,IsPrimeField,20,COM_FUN(22));
InstallMethod(NormalBase,"for a field (in characteristic zero)",[IsField],COM_FUN(23));
InstallMethod(NormalBase,"for a field (in characteristic zero), and a scalar",[IsField,IsScalar],COM_FUN(24));
InstallMethod(PrimitiveElement,"for a division ring",[IsDivisionRing],COM_FUN(25));
InstallMethod(Representative,"for a division ring with known generators",[IsDivisionRing and HasGeneratorsOfDivisionRing],RepresentativeFromGenerators(GeneratorsOfDivisionRing));
InstallMethod(GeneratorsOfRing,"for a division ring with known generators",[IsDivisionRing and HasGeneratorsOfDivisionRing],COM_FUN(26));
InstallMethod(GeneratorsOfRingWithOne,"for a division ring with known generators",[IsDivisionRing and HasGeneratorsOfDivisionRing],COM_FUN(27));
EnumeratorOfPrimeField:=COM_FUN(28);
InstallMethod(Enumerator,"for a prime field",[IsField and IsPrimeField],EnumeratorOfPrimeField);
InstallMethod(EnumeratorSorted,"for a prime field",[IsField and IsPrimeField],EnumeratorOfPrimeField);
InstallMethod(AsList,"for a prime field",[IsField and IsPrimeField],COM_FUN(29));
BindGlobal("DivisionRing_IsSubset",COM_FUN(30));
InstallMethod(IsSubset,"for two division rings",IsIdenticalObj,[IsDivisionRing,IsDivisionRing],DivisionRing_IsSubset);
InstallMethod(\=,"for two division rings",IsIdenticalObj,[IsDivisionRing,IsDivisionRing],COM_FUN(31));
InstallMethod(AsDivisionRing,"for a collection",[IsCollection],COM_FUN(32));
InstallMethod(AsDivisionRing,"for a division ring, and a collection",IsIdenticalObj,[IsDivisionRing,IsCollection],COM_FUN(33));
InstallMethod(AsDivisionRing,"for two division rings",IsIdenticalObj,[IsDivisionRing,IsDivisionRing],COM_FUN(34));
InstallMethod(AsLeftModule,"for two division rings",IsIdenticalObj,[IsDivisionRing,IsDivisionRing],AsDivisionRing);
InstallMethod(Conjugates,"for a scalar (delegate to version with default field)",[IsScalar],COM_FUN(35));
InstallMethod(Conjugates,"for a field and a scalar (delegate to version with two fields)",IsCollsElms,[IsField,IsScalar],COM_FUN(36));
InstallMethod(Conjugates,"for two fields and a scalar (call `TracePolynomial')",IsCollsXElms,[IsField,IsField,IsScalar],COM_FUN(37));
InstallMethod(Conjugates,"for two fields and a scalar (call `GaloisGroup')",IsCollsXElms,[IsFieldControlledByGaloisGroup,IsField,IsScalar],COM_FUN(38));
InstallMethod(Norm,"for a scalar (delegate to version with default field)",[IsScalar],COM_FUN(39));
InstallMethod(Norm,"for a field and a scalar (delegate to version with two fields)",IsCollsElms,[IsField,IsScalar],COM_FUN(40));
InstallMethod(Norm,"for two fields and a scalar (use `Conjugates')",IsCollsXElms,[IsFieldControlledByGaloisGroup,IsField,IsScalar],COM_FUN(41));
InstallMethod(Norm,"for two fields and a scalar (use the trace pol.)",IsCollsXElms,[IsField,IsField,IsScalar],COM_FUN(42));
InstallMethod(Trace,"for a scalar (delegate to version with default field)",[IsScalar],COM_FUN(43));
InstallMethod(Trace,"for a field and a scalar (delegate to version with two fields)",IsCollsElms,[IsField,IsScalar],COM_FUN(44));
InstallMethod(Trace,"for two fields and a scalar (use `Conjugates')",IsCollsXElms,[IsFieldControlledByGaloisGroup,IsField,IsScalar],COM_FUN(45));
InstallMethod(Trace,"for two fields and a scalar (use the trace pol.)",IsCollsXElms,[IsField,IsField,IsScalar],COM_FUN(46));
InstallMethod(MinimalPolynomial,"for field, scalar, and indet. number",IsCollsElmsX,[IsField,IsScalar,IsPosInt],COM_FUN(47));
InstallMethod(TracePolynomial,"using minimal polynomial",IsCollsXElmsX,[IsField,IsField,IsScalar,IsPosInt],COM_FUN(48));
InstallMethod(TracePolynomial,"add default indet. 1",IsCollsXElms,[IsField,IsField,IsScalar],COM_FUN(49));
InstallOtherMethod(CharacteristicPolynomial,"call `TracePolynomial'",IsCollsXElms,[IsField,IsField,IsScalar],COM_FUN(50));
InstallOtherMethod(CharacteristicPolynomial,"call `TracePolynomial'",IsCollsXElmsX,[IsField,IsField,IsScalar,IsPosInt],TracePolynomial);
InstallHandlingByNiceBasis("IsFieldElementsSpace",rec(detect:=COM_FUN(51),NiceFreeLeftModuleInfo:=COM_FUN(52),NiceVector:=COM_FUN(53),UglyVector:=COM_FUN(54)));
InstallMethod(Quotient,"for field, and two ring elements",IsCollsElmsElms,[IsField,IsRingElement,IsRingElement],COM_FUN(55));
InstallMethod(IsUnit,"for field, and ring element",IsCollsElms,[IsField,IsRingElement],COM_FUN(56));
InstallMethod(Units,"for a division ring",[IsDivisionRing],COM_FUN(57));
InstallMethod(PrimitiveRoot,"for a finite prime field",[IsField and IsFinite],COM_FUN(58));
InstallMethod(IsAssociated,"for field, and two ring elements",IsCollsElmsElms,[IsField,IsRingElement,IsRingElement],COM_FUN(59));
InstallMethod(StandardAssociate,"for field and ring element",IsCollsElms,[IsField,IsScalar],COM_FUN(60));
InstallMethod(IsIrreducibleRingElement,"for field and ring element",IsCollsElms,[IsField,IsScalar],0,COM_FUN(61));
InstallMethod(IsFieldHomomorphism,[IsGeneralMapping],COM_FUN(62));
InstallMethod(KernelOfAdditiveGeneralMapping,"for a field homomorphism",[IsFieldHomomorphism],COM_FUN(63));
InstallMethod(IsInjective,"for a field homomorphism",[IsFieldHomomorphism],COM_FUN(64));
InstallMethod(IsSurjective,"for a field homomorphism",[IsFieldHomomorphism],COM_FUN(65));
InstallMethod(\=,"for two field homomorphisms",IsIdenticalObj,[IsFieldHomomorphism,IsFieldHomomorphism],COM_FUN(66));
InstallMethod(ImagesSet,"for field homomorphism and field",CollFamSourceEqFamElms,[IsFieldHomomorphism,IsField],COM_FUN(67));
InstallMethod(PreImagesElm,"for field homomorphism and element",FamRangeEqFamElm,[IsFieldHomomorphism,IsObject],COM_FUN(68));
InstallMethod(PreImagesSet,"for field homomorphism and field",CollFamRangeEqFamElms,[IsFieldHomomorphism,IsField],COM_FUN(69));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/field.gi"

#F  file="lib/fieldfin.gi" crc=85679008
RANK_FILTER_LIST  := [ 25259116, 53, 55350942, 55, 25703304, 54, 25259116, 
  53, 25259116, 53, 25259116, 53, 25259116, 53, 25259116, 53, 25269811, 65, 
  25269811, 65, 25259116, 53, 30625149, 10, 52247917, 19, 257, 15, 53661303, 
  248, 53661303, 248, 25259116, 53, 25259116, 53, 7728, 27, 25259116, 53, 
  32769, 4, 16800137, 13, 30625149, 10, 16800137, 13, 32769, 4, 25259116, 53, 
  25259116, 53, 30625149, 10, 25270276, 48, 55478700, 26, 55478700, 26, 
  65568939, 17, 55478700, 26, 55478700, 26, 65568939, 17, 55478700, 26, 1, 0, 
  55478700, 26, 1, 0, 55478700, 26, 25270276, 48, 55478700, 26, 1, 0, 
  55478700, 26, 55478700, 26, 55478700, 26, 55478700, 26, 17, 18, 65568939, 
  17, 55478700, 26, 55478700, 26, 65568939, 17, 55478700, 26, 55478700, 26, 
  55478700, 26, 25259116, 53 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/fieldfin.gi", 85679008 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/fieldfin.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/fieldfin.gi");
elif COM_RESULT = 3  then
Revision.fieldfin_gi:="@(#)$Id: fieldfin.gi,v 4.41.4.3 2005/04/21 09:43:25 gap Exp $";
InstallMethod(GeneratorsOfLeftModule,"for a finite field (return the vectors of the canonical basis)",[IsField and IsFinite],COM_FUN(1));
InstallMethod(Random,"for a finite prime field",[IsField and IsPrimeField and IsFinite],COM_FUN(2));
InstallMethod(Random,"for a finite field with known primitive root",[IsField and IsFinite and HasPrimitiveRoot],COM_FUN(3));
InstallMethod(Units,"for a finite field",[IsField and IsFinite],COM_FUN(4));
InstallMethod(\=,"for two finite fields in the same family",IsIdenticalObj,[IsField and IsFinite,IsField and IsFinite],COM_FUN(5));
InstallMethod(IsSubset,"for two finite fields in the same family",IsIdenticalObj,[IsField and IsFinite,IsField and IsFinite],COM_FUN(6));
InstallMethod(Subfields,"for finite field of FFEs",[IsField and IsFFECollection],COM_FUN(7));
InstallMethod(PrimeField,"for finite field of FFEs",[IsField and IsFFECollection],COM_FUN(8));
InstallMethod(MinimalPolynomial,"finite field, finite field element, and indet. number",IsCollsElmsX,[IsField and IsFinite,IsScalar,IsPosInt],COM_FUN(9));
InstallTrueMethod(IsHandledByNiceMonomorphism,IsGroup and IsFFECollection);
InstallTrueMethod(IsCyclic,IsGroup and IsFFECollection);
InstallMethod(\in,"for groups of FFE, Z/pZ, p<>2",IsElmsColls,[IsFFE,IsGroup and IsFFECollection],COM_FUN(10));
InstallMethod(Pcgs,"for groups of FFE",[IsGroup and IsFFECollection],COM_FUN(11));
DeclareRepresentation("IsBasisFiniteFieldRep",IsAttributeStoringRep,["inverseBase","d","q"]);
InstallTrueMethod(IsFinite,IsBasis and IsBasisFiniteFieldRep);
InstallMethod(Basis,"for a finite field (delegate to `CanonicalBasis')",[IsField and IsFinite],CANONICAL_BASIS_FLAGS,CanonicalBasis);
InstallMethod(Basis,"for a finite field, and a hom. list",IsIdenticalObj,[IsField and IsFinite,IsFFECollection and IsList],COM_FUN(12));
InstallMethod(BasisNC,"for a finite field, and a hom. list",IsIdenticalObj,[IsField and IsFinite,IsHomogeneousList],10,COM_FUN(13));
InstallMethod(Coefficients,"for a basis of a finite field, and a scalar",IsCollsElms,[IsBasis and IsBasisFiniteFieldRep,IsScalar],COM_FUN(14));
InstallMethod(LinearCombination,"for a basis of a finite field, and a hom. list",IsIdenticalObj,[IsBasis and IsBasisFiniteFieldRep,IsHomogeneousList],COM_FUN(15));
InstallMethod(CanonicalBasis,"for a finite field",[IsField and IsFinite],COM_FUN(16));
InstallMethod(NormalBase,"for a finite field and scalar",[IsField and IsFinite,IsScalar],COM_FUN(17));
DeclareRepresentation("IsFrobeniusAutomorphism",IsFieldHomomorphism and IsMapping and IsAttributeStoringRep,["power"]);
BindGlobal("FrobeniusAutomorphismI",COM_FUN(18));
InstallMethod(FrobeniusAutomorphism,"for a field",[IsField],COM_FUN(19));
InstallMethod(\=,"for two Frobenius automorphisms",IsIdenticalObj,[IsFrobeniusAutomorphism,IsFrobeniusAutomorphism],COM_FUN(20));
InstallMethod(\=,"for identity mapping and Frobenius automorphism",IsIdenticalObj,[IsMapping and IsOne,IsFrobeniusAutomorphism],COM_FUN(21));
InstallMethod(\=,"for Frobenius automorphism and identity mapping",IsIdenticalObj,[IsFrobeniusAutomorphism,IsMapping and IsOne],COM_FUN(22));
InstallMethod(ImageElm,"for Frobenius automorphism and source element",FamSourceEqFamElm,[IsFrobeniusAutomorphism,IsObject],COM_FUN(23));
InstallMethod(ImagesElm,"for Frobenius automorphism and source element",FamSourceEqFamElm,[IsFrobeniusAutomorphism,IsObject],COM_FUN(24));
InstallMethod(ImagesSet,"for Frobenius automorphism and field contained in the source",CollFamSourceEqFamElms,[IsFrobeniusAutomorphism,IsField],COM_FUN(25));
InstallMethod(ImagesRepresentative,"for Frobenius automorphism and source element",FamSourceEqFamElm,[IsFrobeniusAutomorphism,IsObject],COM_FUN(26));
InstallMethod(CompositionMapping2,"for two Frobenius automorphisms",IsIdenticalObj,[IsFrobeniusAutomorphism,IsFrobeniusAutomorphism],COM_FUN(27));
InstallMethod(InverseGeneralMapping,"for a Frobenius automorphism",[IsFrobeniusAutomorphism],COM_FUN(28));
InstallMethod(\^,"for a Frobenius automorphism, and an integer",[IsFrobeniusAutomorphism,IsInt],COM_FUN(29));
InstallMethod(\<,"for an identity mapping, and a Frobenius automorphism",IsIdenticalObj,[IsMapping and IsOne,IsFrobeniusAutomorphism],COM_FUN(30));
InstallMethod(\<,"for a Frobenius automorphism, and an identity mapping",IsIdenticalObj,[IsFrobeniusAutomorphism,IsMapping and IsOne],COM_FUN(31));
InstallMethod(\<,"for two Frobenius automorphisms",IsIdenticalObj,[IsFrobeniusAutomorphism,IsFrobeniusAutomorphism],COM_FUN(32));
InstallMethod(PrintObj,"for a Frobenius automorphism",[IsFrobeniusAutomorphism],COM_FUN(33));
InstallMethod(GaloisGroup,"for a finite field",[IsField and IsFinite],COM_FUN(34));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/fieldfin.gi"

#F  file="lib/zmodnz.gi" crc=5647597
RANK_FILTER_LIST  := [ 59637401, 4, 17, 18, 13837276, 5, 17, 18, 17, 18, 
  52247917, 19, 59637401, 4, 17, 18, 39674185, 14, 2392588, 13, 2392844, 18, 
  2392588, 13, 2392844, 18, 2392588, 13, 2392588, 13, 2392844, 18, 319, 16, 
  319, 16, 2392844, 18, 39674185, 14, 39674185, 14, 62038090, 19, 62038090, 
  19, 47128500, 19, 47128500, 19, 47128500, 19, 319, 16, 319, 16, 47128500, 
  19, 2392588, 13, 2392588, 13, 2392588, 13, 17, 18, 17, 18, 2392588, 13, 
  2392588, 13, 33, 17, 33, 17, 2392588, 13, 47128500, 19, 319, 16, 319, 16, 
  47128500, 19, 2392588, 13, 2392588, 13, 2392588, 13, 17, 18, 17, 18, 
  2392588, 13, 2392588, 13, 33, 17, 33, 17, 2392588, 13, 47128500, 19, 319, 
  16, 319, 16, 47128500, 19, 2392588, 13, 2392588, 13, 2392588, 13, 17, 18, 
  17, 18, 2392588, 13, 2392588, 13, 33, 17, 33, 17, 2392588, 13, 47128500, 
  19, 319, 16, 319, 16, 47128500, 19, 2392588, 13, 2392588, 13, 2392588, 13, 
  17, 18, 17, 18, 2392588, 13, 2392588, 13, 33, 17, 33, 17, 2392588, 13, 
  47128500, 19, 319, 16, 319, 16, 47128500, 19, 2392588, 13, 17, 18, 
  37281598, 11, 2392588, 13, 37281598, 11, 2392588, 13, 2392844, 18, 2392844, 
  18, 2392844, 18, 2392588, 13, 2392588, 13, 53172532, 37, 53172532, 37, 
  53172533, 39, 52152003, 18, 52152003, 18, 52152003, 18, 52152003, 18, 
  52152003, 18, 52152003, 18, 62629491, 33, 7454316, 12, 38717850, 33, 
  52152003, 18, 55362102, 50, 2392844, 18, 48733699, 40, 52247917, 19, 
  7454316, 12, 37281854, 16, 257, 15, 52165922, 16, 43477295, 34 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/zmodnz.gi", 5647597 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/zmodnz.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/zmodnz.gi");
elif COM_RESULT = 3  then
Revision.zmodnz_gi:="@(#)$Id: zmodnz.gi,v 4.53 2003/11/20 14:20:43 gap Exp $";
DeclareSynonym("ZNZ_PURE_TYPE",POS_FIRST_FREE_TYPE);
DeclareRepresentation("IsModulusRep",IsPositionalObjectRep,[1]);
InstallMethod(ZmodnZObj,"for family of elements in Z/nZ (nonprime), and integer",[IsZmodnZObjNonprimeFamily,IsInt],COM_FUN(1));
InstallOtherMethod(ZmodnZObj,"for family of FFE elements, and integer",[IsFFEFamily,IsInt],COM_FUN(2));
InstallMethod(ZmodnZObj,"for a positive integer, and an integer",[IsInt,IsPosInt],COM_FUN(3));
InstallMethod(ObjByExtRep,"for family of elements in Z/nZ (nonprime), and integer",[IsZmodnZObjNonprimeFamily,IsInt],COM_FUN(4));
InstallMethod(ExtRepOfObj,"for element in Z/nZ (ModulusRep, nonprime)",[IsZmodnZObjNonprime and IsModulusRep],COM_FUN(5));
InstallMethod(PrintObj,"for element in Z/nZ (ModulusRep)",IsZmodnZObjNonprimeFamily,[IsZmodnZObj and IsModulusRep],COM_FUN(6));
InstallMethod(PrintObj,"for element in Z/pZ (ModulusRep)",[IsZmodpZObj and IsModulusRep],COM_FUN(7));
InstallMethod(String,"for element in Z/nZ (ModulusRep)",IsZmodnZObjNonprimeFamily,[IsZmodnZObj and IsModulusRep],COM_FUN(8));
InstallMethod(String,"for element in Z/pZ (ModulusRep)",[IsZmodpZObj and IsModulusRep],COM_FUN(9));
InstallMethod(\=,"for two elements in Z/nZ (ModulusRep)",IsIdenticalObj,[IsZmodnZObj and IsModulusRep,IsZmodnZObj and IsModulusRep],COM_FUN(10));
InstallMethod(\=,"for element in Z/pZ (ModulusRep) and internal FFE",IsIdenticalObj,[IsZmodpZObj and IsModulusRep,IsFFE and IsInternalRep],COM_FUN(11));
InstallMethod(\=,"for internal FFE and element in Z/pZ (ModulusRep)",IsIdenticalObj,[IsFFE and IsInternalRep,IsZmodpZObj and IsModulusRep],COM_FUN(12));
InstallMethod(\<,"for two elements in Z/nZ (ModulusRep, nonprime)",IsIdenticalObj,[IsZmodnZObjNonprime and IsModulusRep,IsZmodnZObjNonprime and IsModulusRep],COM_FUN(13));
InstallMethod(\<,"for two elements in Z/pZ (ModulusRep, large)",IsIdenticalObj,[IsZmodpZObjLarge and IsModulusRep,IsZmodpZObjLarge and IsModulusRep],COM_FUN(14));
InstallMethod(\<,"for two elements in Z/pZ (ModulusRep, small)",IsIdenticalObj,[IsZmodpZObjSmall and IsModulusRep,IsZmodpZObjSmall and IsModulusRep],COM_FUN(15));
InstallMethod(\<,"for element in Z/pZ (ModulusRep) and internal FFE",IsIdenticalObj,[IsZmodpZObjSmall and IsModulusRep,IsFFE and IsInternalRep],COM_FUN(16));
InstallMethod(\<,"for internal FFE and element in Z/pZ (ModulusRep)",IsIdenticalObj,[IsFFE and IsInternalRep,IsZmodpZObjSmall and IsModulusRep],COM_FUN(17));
InstallMethod(\+,"for two elements in Z/nZ (ModulusRep)",IsIdenticalObj,[IsZmodnZObj and IsModulusRep,IsZmodnZObj and IsModulusRep],COM_FUN(18));
InstallMethod(\+,"for element in Z/nZ (ModulusRep) and integer",[IsZmodnZObj and IsModulusRep,IsInt],COM_FUN(19));
InstallMethod(\+,"for integer and element in Z/nZ (ModulusRep)",[IsInt,IsZmodnZObj and IsModulusRep],COM_FUN(20));
InstallMethod(\+,"for element in Z/nZ (ModulusRep) and rational",[IsZmodnZObj and IsModulusRep,IsRat],COM_FUN(21));
InstallMethod(\+,"for rational and element in Z/nZ (ModulusRep)",[IsRat,IsZmodnZObj and IsModulusRep],COM_FUN(22));
InstallMethod(\+,"for element in Z/pZ (ModulusRep) and internal FFE",IsIdenticalObj,[IsZmodpZObjSmall and IsModulusRep,IsFFE and IsInternalRep],COM_FUN(23));
InstallMethod(\+,"for internal FFE and element in Z/pZ (ModulusRep)",IsIdenticalObj,[IsFFE and IsInternalRep,IsZmodpZObjSmall and IsModulusRep],COM_FUN(24));
InstallMethod(\-,"for two elements in Z/nZ (ModulusRep)",IsIdenticalObj,[IsZmodnZObj and IsModulusRep,IsZmodnZObj and IsModulusRep],COM_FUN(25));
InstallMethod(\-,"for element in Z/nZ (ModulusRep) and integer",[IsZmodnZObj and IsModulusRep,IsInt],COM_FUN(26));
InstallMethod(\-,"for integer and element in Z/nZ (ModulusRep)",[IsInt,IsZmodnZObj and IsModulusRep],COM_FUN(27));
InstallMethod(\-,"for element in Z/nZ (ModulusRep) and rational",[IsZmodnZObj and IsModulusRep,IsRat],COM_FUN(28));
InstallMethod(\-,"for rational and element in Z/nZ (ModulusRep)",[IsRat,IsZmodnZObj and IsModulusRep],COM_FUN(29));
InstallMethod(\-,"for element in Z/pZ (ModulusRep) and internal FFE",IsIdenticalObj,[IsZmodpZObjSmall and IsModulusRep,IsFFE and IsInternalRep],COM_FUN(30));
InstallMethod(\-,"for internal FFE and element in Z/pZ (ModulusRep)",IsIdenticalObj,[IsFFE and IsInternalRep,IsZmodpZObjSmall and IsModulusRep],COM_FUN(31));
InstallMethod(\*,"for two elements in Z/nZ (ModulusRep)",IsIdenticalObj,[IsZmodnZObj and IsModulusRep,IsZmodnZObj and IsModulusRep],COM_FUN(32));
InstallMethod(\*,"for element in Z/nZ (ModulusRep) and integer",[IsZmodnZObj and IsModulusRep,IsInt],COM_FUN(33));
InstallMethod(\*,"for integer and element in Z/nZ (ModulusRep)",[IsInt,IsZmodnZObj and IsModulusRep],COM_FUN(34));
InstallMethod(\*,"for element in Z/nZ (ModulusRep) and rational",[IsZmodnZObj and IsModulusRep,IsRat],COM_FUN(35));
InstallMethod(\*,"for rational and element in Z/nZ (ModulusRep)",[IsRat,IsZmodnZObj and IsModulusRep],COM_FUN(36));
InstallMethod(\*,"for element in Z/pZ (ModulusRep) and internal FFE",IsIdenticalObj,[IsZmodpZObjSmall and IsModulusRep,IsFFE and IsInternalRep],COM_FUN(37));
InstallMethod(\*,"for internal FFE and element in Z/pZ (ModulusRep)",IsIdenticalObj,[IsFFE and IsInternalRep,IsZmodpZObjSmall and IsModulusRep],COM_FUN(38));
InstallMethod(\/,"for two elements in Z/nZ (ModulusRep)",IsIdenticalObj,[IsZmodnZObj and IsModulusRep,IsZmodnZObj and IsModulusRep],COM_FUN(39));
InstallMethod(\/,"for element in Z/nZ (ModulusRep) and integer",[IsZmodnZObj and IsModulusRep,IsInt],COM_FUN(40));
InstallMethod(\/,"for integer and element in Z/nZ (ModulusRep)",[IsInt,IsZmodnZObj and IsModulusRep],COM_FUN(41));
InstallMethod(\/,"for element in Z/nZ (ModulusRep) and rational",[IsZmodnZObj and IsModulusRep,IsRat],COM_FUN(42));
InstallMethod(\/,"for rational and element in Z/nZ (ModulusRep)",[IsRat,IsZmodnZObj and IsModulusRep],COM_FUN(43));
InstallMethod(\/,"for element in Z/pZ (ModulusRep) and internal FFE",IsIdenticalObj,[IsZmodpZObjSmall and IsModulusRep,IsFFE and IsInternalRep],COM_FUN(44));
InstallMethod(\/,"for internal FFE and element in Z/pZ (ModulusRep)",IsIdenticalObj,[IsFFE and IsInternalRep,IsZmodpZObjSmall and IsModulusRep],COM_FUN(45));
InstallMethod(\^,"for element in Z/nZ (ModulusRep), and integer",[IsZmodnZObj and IsModulusRep,IsInt],COM_FUN(46));
InstallMethod(ZeroOp,"for element in Z/nZ (ModulusRep)",[IsZmodnZObj],COM_FUN(47));
InstallMethod(AdditiveInverseOp,"for element in Z/nZ (ModulusRep)",[IsZmodnZObj and IsModulusRep],COM_FUN(48));
InstallMethod(OneOp,"for element in Z/nZ (ModulusRep)",[IsZmodnZObj],COM_FUN(49));
InstallMethod(InverseOp,"for element in Z/nZ (ModulusRep)",[IsZmodnZObj and IsModulusRep],COM_FUN(50));
InstallMethod(DegreeFFE,"for element in Z/pZ (ModulusRep)",[IsZmodpZObj and IsModulusRep],COM_FUN(51));
InstallMethod(LogFFE,"for two elements in Z/pZ (ModulusRep)",IsIdenticalObj,[IsZmodpZObj and IsModulusRep,IsZmodpZObj and IsModulusRep],COM_FUN(52));
InstallMethod(Int,"for element in Z/nZ (ModulusRep)",[IsZmodnZObj and IsModulusRep],COM_FUN(53));
InstallOtherMethod(IntFFESymm,"Z/nZ (ModulusRep)",[IsZmodnZObj and IsModulusRep],COM_FUN(54));
InstallMethod(InverseOp,"for an ordinary matrix over a ring Z/nZ",[IsMatrix and IsOrdinaryMatrix and IsZmodnZObjNonprimeCollColl],COM_FUN(55));
InstallMethod(InverseSM,"for an ordinary matrix over a ring Z/nZ",[IsMatrix and IsOrdinaryMatrix and IsZmodnZObjNonprimeCollColl],COM_FUN(56));
InstallMethod(TriangulizeMat,"for a mutable ordinary matrix over a ring Z/nZ",[IsMatrix and IsMutable and IsOrdinaryMatrix and IsZmodnZObjNonprimeCollColl],COM_FUN(57));
InstallMethod(ViewObj,"for full ring Z/nZ",[IsZmodnZObjNonprimeCollection and IsWholeFamily],SUM_FLAGS,COM_FUN(58));
InstallMethod(PrintObj,"for full ring Z/nZ",[IsZmodnZObjNonprimeCollection and IsWholeFamily],SUM_FLAGS,COM_FUN(59));
InstallMethod(AsList,"for full ring Z/nZ",[IsZmodnZObjNonprimeCollection and IsWholeFamily],COM_FUN(60));
InstallMethod(AsSSortedList,"for full ring Z/nZ",[IsZmodnZObjNonprimeCollection and IsWholeFamily],COM_FUN(61));
InstallMethod(Random,"for full ring Z/nZ",[IsZmodnZObjNonprimeCollection and IsWholeFamily],COM_FUN(62));
InstallMethod(Size,"for full ring Z/nZ",[IsZmodnZObjNonprimeCollection and IsWholeFamily],COM_FUN(63));
InstallMethod(Units,"for full ring Z/nZ",[IsZmodnZObjNonprimeCollection and IsWholeFamily and IsRing],COM_FUN(64));
InstallMethod(\in,"for subgroups of Z/p^aZ, p<>2",IsElmsColls,[IsZmodnZObjNonprime,IsGroup and IsZmodnZObjNonprimeCollection],COM_FUN(65));
BindGlobal("ElementNumber_ZmodnZ",COM_FUN(66));
BindGlobal("NumberElement_ZmodnZ",COM_FUN(67));
InstallGlobalFunction(EnumeratorOfZmodnZ,COM_FUN(68));
InstallMethod(Enumerator,"for full ring Z/nZ",[IsZmodnZObjNonprimeCollection and IsWholeFamily],SUM_FLAGS,EnumeratorOfZmodnZ);
InstallMethod(SquareRoots,"for prime field and object in Z/pZ",IsCollsElms,[IsField and IsPrimeField,IsZmodpZObj and IsModulusRep],COM_FUN(69));
InstallGlobalFunction(ZmodpZ,COM_FUN(70));
InstallGlobalFunction(ZmodpZNC,COM_FUN(71));
InstallGlobalFunction(ZmodnZ,COM_FUN(72));
InstallMethod(\mod,"for `Integers', and positive integers",[IsIntegers,IsPosInt],COM_FUN(73));
InstallMethod(ModulusOfZmodnZObj,"for element in Z/nZ (nonprime)",[IsZmodnZObjNonprime],COM_FUN(74));
InstallMethod(ModulusOfZmodnZObj,"for element in Z/pZ (prime)",[IsZmodpZObj],Characteristic);
InstallOtherMethod(ModulusOfZmodnZObj,"for FFE",[IsFFE],COM_FUN(75));
InstallMethod(DefaultRingByGenerators,"for a collection over a ring Z/nZ",[IsZmodnZObjNonprimeCollection],COM_FUN(76));
InstallMethod(DefaultFieldOfMatrixGroup,"for a matrix group over a ring Z/nZ",[IsMatrixGroup and IsZmodnZObjNonprimeCollCollColl],COM_FUN(77));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/zmodnz.gi"

#F  file="lib/ffe.gi" crc=-122519731
RANK_FILTER_LIST  := [ 257, 15, 33, 17, 33, 17, 257, 15, 257, 15, 33, 17, 33, 
  17, 257, 15, 65077475, 29, 31628240, 40, 257, 15, 257, 15, 65077475, 29, 
  13837276, 5, 13837276, 5, 25269811, 268, 56456811, 17, 25269811, 268, 
  25269811, 268, 25269811, 268, 25269811, 268, 257, 15, 25269811, 268, 
  25269811, 268, 25269811, 268, 25258651, 278, 25258651, 278, 257, 15, 
  25258651, 278, 25258651, 278, 257, 15, 25258651, 278, 25258651, 278, 257, 
  15, 319, 16, 25270276, 48, 257, 15, 25270276, 48, 257, 15, 52247917, 19, 
  319, 16, 319, 16, 65077475, 29, 319, 16, 319, 16, 67108415, 20, 25269811, 
  268, 67108415, 20, 7728, 27, 25259116, 53, 7728, 27, 67108415, 20, 
  67108415, 20, 7728, 27, 25269811, 268, 67108415, 20, 25269811, 268, 
  67108415, 20, 67108415, 20 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/ffe.gi", -122519731 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/ffe.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/ffe.gi");
elif COM_RESULT = 3  then
Revision.ffe_gi:="@(#)$Id: ffe.gi,v 4.67 2003/04/16 20:41:41 gap Exp $";
InstallMethod(\+,"for a FFE and a rational",[IsFFE,IsRat],COM_FUN(1));
InstallMethod(\+,"for a rational and a FFE",[IsRat,IsFFE],COM_FUN(2));
InstallMethod(\*,"for a FFE and a rational",[IsFFE,IsRat],COM_FUN(3));
InstallMethod(\*,"for a rational and a FFE",[IsRat,IsFFE],COM_FUN(4));
InstallOtherMethod(DegreeFFE,"for a row vector of FFEs",true,[IsRowVector and IsFFECollection],0,COM_FUN(5));
InstallOtherMethod(DegreeFFE,"for a matrix of FFEs",true,[IsMatrix and IsFFECollColl],0,COM_FUN(6));
InstallMethod(LogFFE,"for two FFEs (in a prime field)",IsIdenticalObj,[IsFFE,IsFFE],COM_FUN(7));
InstallMethod(IntVecFFE,"for a row vector of FFEs",true,[IsRowVector and IsFFECollection],0,COM_FUN(8));
InstallGlobalFunction(FFEFamily,COM_FUN(9));
InstallOtherMethod(Zero,"for a family of FFEs",true,[IsFFEFamily],0,COM_FUN(10));
InstallOtherMethod(One,"for a family of FFEs",true,[IsFFEFamily],0,COM_FUN(11));
InstallGlobalFunction(LargeGaloisField,COM_FUN(12));
GFCACHE:=[0,0];
InstallGlobalFunction(GaloisField,COM_FUN(13));
InstallOtherMethod(FieldExtension,"for a field of FFEs, and a univ. Laurent polynomial",true,[IsField and IsFFECollection,IsLaurentPolynomial],0,COM_FUN(14));
InstallMethod(DefiningPolynomial,"for a field of FFEs (return the Conway polynomial)",true,[IsField and IsFFECollection],0,COM_FUN(15));
InstallMethod(RootOfDefiningPolynomial,"for a small field of FFEs",true,[IsField and IsFFECollection],0,COM_FUN(16));
InstallMethod(ViewObj,"for a field of FFEs",true,[IsField and IsFFECollection],10,COM_FUN(17));
InstallMethod(PrintObj,"for a field of FFEs",true,[IsField and IsFFECollection],10,COM_FUN(18));
InstallMethod(\in,"for a FFE, and a field of FFEs",IsElmsColls,[IsFFE,IsField and IsFFECollection],0,COM_FUN(19));
InstallMethod(Intersection2,"for two fields of FFEs",IsIdenticalObj,[IsField and IsFFECollection,IsField and IsFFECollection],0,COM_FUN(20));
InstallMethod(Conjugates,"for two fields of FFEs, and a FFE",IsCollsXElms,[IsField and IsFinite and IsFFECollection,IsField and IsFinite and IsFFECollection,IsFFE],0,COM_FUN(21));
InstallMethod(Norm,"for two fields of FFEs, and a FFE",IsCollsXElms,[IsField and IsFinite and IsFFECollection,IsField and IsFinite and IsFFECollection,IsFFE],0,COM_FUN(22));
InstallMethod(Trace,"for two fields of FFEs, and a FFE",IsCollsXElms,[IsField and IsFinite and IsFFECollection,IsField and IsFinite and IsFFECollection,IsFFE],0,COM_FUN(23));
InstallMethod(Order,"for an internal FFE",true,[IsFFE and IsInternalRep],0,COM_FUN(24));
InstallMethod(SquareRoots,"for a field of FFEs, and a FFE",IsCollsElms,[IsField,IsFFE],0,COM_FUN(25));
InstallMethod(NthRoot,"for a field of FFEs, and a FFE",IsCollsElmsX,[IsField,IsFFE,IsPosInt],0,COM_FUN(26));
InstallMethod(Int,"for an internal FFE",true,[IsFFE and IsInternalRep],0,IntFFE);
InstallMethod(IntFFESymm,"internal FFE",true,[IsFFE and IsInternalRep],0,COM_FUN(27));
InstallOtherMethod(IntFFESymm,"vector",true,[IsRowVector and IsFFECollection],0,COM_FUN(28));
InstallMethod(String,"for an internal FFE",true,[IsFFE and IsInternalRep],0,COM_FUN(29));
InstallMethod(LaTeXObj,"for an internal FFE",true,[IsFFE and IsInternalRep],0,COM_FUN(30));
InstallMethod(FieldOverItselfByGenerators,"for a collection of FFEs",true,[IsFFECollection],0,COM_FUN(31));
InstallMethod(FieldByGenerators,"for two coll. of FFEs, the first a field",IsIdenticalObj,[IsFFECollection and IsField,IsFFECollection],0,COM_FUN(32));
InstallMethod(DefaultFieldByGenerators,"for a collection of FFEs that is a list",true,[IsFFECollection and IsList],0,COM_FUN(33));
InstallOtherMethod(DefaultFieldByGenerators,"for a finite field, and a collection of FFEs that is a list",IsIdenticalObj,[IsField and IsFinite,IsFFECollection and IsList],0,COM_FUN(34));
RingFromFFE:=COM_FUN(35);
InstallMethod(RingByGenerators,"for a collection of FFE",true,[IsFFECollection],0,RingFromFFE);
InstallMethod(RingWithOneByGenerators,"for a collection of FFE",true,[IsFFECollection],0,RingFromFFE);
InstallMethod(DefaultRingByGenerators,"for a collection of FFE",true,[IsFFECollection and IsList],0,RingFromFFE);
FLMLORFromFFE:=COM_FUN(36);
InstallMethod(FLMLORByGenerators,"for a field, and a collection of FFE",IsIdenticalObj,[IsField and IsFFECollection,IsFFECollection],0,FLMLORFromFFE);
InstallMethod(FLMLORWithOneByGenerators,"for a field, and a collection of FFE",IsIdenticalObj,[IsField and IsFFECollection,IsFFECollection],0,FLMLORFromFFE);
InstallMethod(IsGeneratorsOfMagmaWithInverses,"for a collection of FFEs",true,[IsFFECollection],0,COM_FUN(37));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/ffe.gi"

#F  file="lib/rational.gi" crc=-118506038
RANK_FILTER_LIST  := [ 1, 0, 28338650, 56, 28338650, 56, 28338650, 56, 
  28338650, 56, 33, 17, 28338650, 56, 10380984, 12, 63198130, 7, 28338650, 
  56, 28338650, 56, 33, 17, 33, 17, 33, 17 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/rational.gi", -118506038 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/rational.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/rational.gi");
elif COM_RESULT = 3  then
Revision.rational_gi:="@(#)$Id: rational.gi,v 4.36 2003/04/16 07:47:56 gap Exp $";
InstallValue(Rationals,Objectify(NewType(CollectionsFamily(CyclotomicsFamily),IsRationals and IsAttributeStoringRep),rec()));
SetName(Rationals,"Rationals");
SetLeftActingDomain(Rationals,Rationals);
SetIsPrimeField(Rationals,true);
SetIsCyclotomicField(Rationals,true);
SetSize(Rationals,infinity);
SetConductor(Rationals,1);
SetDimension(Rationals,1);
SetGaloisStabilizer(Rationals,[1]);
SetGeneratorsOfLeftModule(Rationals,[1]);
SetIsWholeFamily(Rationals,false);
InstallValue(GaussianRationals,Objectify(NewType(CollectionsFamily(CyclotomicsFamily),IsGaussianRationals and IsAttributeStoringRep),rec()));
SetName(GaussianRationals,"GaussianRationals");
SetLeftActingDomain(GaussianRationals,Rationals);
SetIsPrimeField(GaussianRationals,false);
SetIsCyclotomicField(GaussianRationals,true);
SetSize(GaussianRationals,infinity);
SetConductor(GaussianRationals,4);
SetDimension(GaussianRationals,2);
SetDegreeOverPrimeField(GaussianRationals,2);
SetGaloisStabilizer(GaussianRationals,[1]);
SetGeneratorsOfLeftModule(GaussianRationals,[1,E(4)]);
SetIsWholeFamily(GaussianRationals,false);
InstallMethod(\in,"for Rationals and an object",[IsObject,IsRationals],COM_FUN(1));
InstallMethod(Random,"for Rationals",[IsRationals],COM_FUN(2));
InstallMethod(Conjugates,"for Rationals, Rationals, and a rational",IsCollsXElms,[IsRationals,IsRationals,IsRat],COM_FUN(3));
DeclareRepresentation("IsCanonicalBasisRationals",IsAttributeStoringRep,[]);
InstallMethod(CanonicalBasis,"for Rationals",[IsRationals],COM_FUN(4));
InstallMethod(Coefficients,"method for canonical basis of Rationals",IsCollsElms,[IsBasis and IsCanonicalBasis and IsCanonicalBasisRationals,IsVector],COM_FUN(5));
BindGlobal("NextIterator_Rationals",COM_FUN(6));
BindGlobal("ShallowCopy_Rationals",COM_FUN(7));
InstallMethod(Iterator,"for `Rationals'",[IsRationals],COM_FUN(8));
BindGlobal("NumberElement_Rationals",COM_FUN(9));
BindGlobal("ElementNumber_Rationals",COM_FUN(10));
InstallMethod(Enumerator,"for `Rationals'",[IsRationals],COM_FUN(11));
BindGlobal("EvalF",COM_FUN(12));
InstallMethod(RoundCyc,"Rational",[IsRat],COM_FUN(13));
InstallMethod(RoundCycDown,"Rational",[IsRat],COM_FUN(14));
InstallMethod(LaTeXObj,"rational",[IsRat],COM_FUN(15));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/rational.gi"

#F  file="lib/gaussian.gi" crc=-31646309
RANK_FILTER_LIST  := [ 65, 16, 54329030, 42, 54329030, 42, 54329030, 42, 
  51562462, 12, 65, 16, 54329030, 42, 65, 16, 65, 16, 54329030, 42, 65, 16, 
  54329030, 42, 65, 16, 54329030, 42, 65, 16, 65, 16, 54329030, 42, 65, 16, 
  65, 16, 54329030, 42, 65, 16, 65, 16, 54329030, 42, 17, 18, 54329030, 42, 
  65, 16, 54329030, 42, 65, 16 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/gaussian.gi", -31646309 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/gaussian.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/gaussian.gi");
elif COM_RESULT = 3  then
Revision.gaussian_gi:="@(#)$Id: gaussian.gi,v 4.13 2002/04/15 10:04:40 sal Exp $";
InstallMethod(\in,"for Gaussian integers",IsElmsColls,[IsCyc,IsGaussianIntegers],COM_FUN(1));
InstallMethod(Basis,"for Gaussian integers (delegate to `CanonicalBasis')",[IsGaussianIntegers],CANONICAL_BASIS_FLAGS,CanonicalBasis);
DeclareRepresentation("IsCanonicalBasisGaussianIntegersRep",IsAttributeStoringRep,["conductor","zumbroichbase"]);
InstallMethod(CanonicalBasis,"for Gaussian integers",[IsGaussianIntegers],COM_FUN(2));
InstallMethod(Coefficients,"for canon. basis of Gaussian integers, and cyclotomic",IsCollsElms,[IsBasis and IsCanonicalBasis and IsCanonicalBasisGaussianIntegersRep,IsCyc],COM_FUN(3));
InstallMethod(Quotient,"for Gaussian integers",IsCollsElmsElms,[IsGaussianIntegers,IsCyc,IsCyc],COM_FUN(4));
InstallMethod(StandardAssociate,"for Gaussian integers",IsCollsElms,[IsGaussianIntegers,IsCyc],COM_FUN(5));
InstallMethod(EuclideanDegree,"for Gaussian integers",IsCollsElms,[IsGaussianIntegers,IsCyc],COM_FUN(6));
InstallMethod(EuclideanRemainder,"for Gaussian integers",IsCollsElmsElms,[IsGaussianIntegers,IsCyc,IsCyc],COM_FUN(7));
InstallMethod(EuclideanQuotient,"for Gaussian integers",IsCollsElmsElms,[IsGaussianIntegers,IsCyc,IsCyc],COM_FUN(8));
InstallMethod(QuotientRemainder,"for Gaussian integers",IsCollsElmsElms,[IsGaussianIntegers,IsCyc,IsCyc],COM_FUN(9));
InstallMethod(IsPrime,"for Gaussian integers and integer",IsCollsElms,[IsGaussianIntegers,IsInt],COM_FUN(10));
InstallMethod(IsPrime,"for Gaussian integers and cyclotomic",IsCollsElms,[IsGaussianIntegers,IsCyc],COM_FUN(11));
InstallMethod(Factors,"for Gaussian integers",IsCollsElms,[IsGaussianIntegers,IsCyc],COM_FUN(12));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/gaussian.gi"

#F  file="lib/cyclotom.gi" crc=30390548
RANK_FILTER_LIST  := [ 8193, 2, 53597154, 15, 53597154, 15, 65, 16, 127, 17, 
  33, 17, 4365792, 40, 58412696, 30, 41951068, 17, 40085428, 20, 14884325, 
  28, 20200024, 19, 4097, 1, 14884325, 28, 20200024, 19 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/cyclotom.gi", 30390548 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/cyclotom.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/cyclotom.gi");
elif COM_RESULT = 3  then
Revision.cyclotom_gi:="@(#)$Id: cyclotom.gi,v 4.50 2003/05/23 15:45:48 gap Exp $";
InstallOtherMethod(Conductor,"for a list",[IsList],COM_FUN(1));
InstallMethod(RoundCyc,"general cyclotomic",[IsCyclotomic],COM_FUN(2));
InstallMethod(RoundCycDown,"general cyclotomic",[IsCyclotomic],COM_FUN(3));
InstallMethod(ComplexConjugate,"for a cyclotomic",[IsCyc],COM_FUN(4));
InstallMethod(ExtRepOfObj,"for an internal cyclotomic",[IsCyc and IsInternalRep],COEFFS_CYC);
InstallGlobalFunction(CoeffsCyc,COM_FUN(5));
BindGlobal("CycList",COM_FUN(6));
InstallGlobalFunction(IsGaussInt,COM_FUN(7));
InstallGlobalFunction(IsGaussRat,COM_FUN(8));
InstallGlobalFunction(DescriptionOfRootOfUnity,COM_FUN(9));
BindGlobal("Atlas1",COM_FUN(10));
InstallGlobalFunction(EB,COM_FUN(11));
InstallGlobalFunction(EC,COM_FUN(12));
InstallGlobalFunction(ED,COM_FUN(13));
InstallGlobalFunction(EE,COM_FUN(14));
InstallGlobalFunction(EF,COM_FUN(15));
InstallGlobalFunction(EG,COM_FUN(16));
InstallGlobalFunction(EH,COM_FUN(17));
InstallGlobalFunction(NK,COM_FUN(18));
BindGlobal("Atlas2",COM_FUN(19));
InstallGlobalFunction(EY,COM_FUN(20));
InstallGlobalFunction(EX,COM_FUN(21));
InstallGlobalFunction(EW,COM_FUN(22));
InstallGlobalFunction(EV,COM_FUN(23));
InstallGlobalFunction(EU,COM_FUN(24));
InstallGlobalFunction(ET,COM_FUN(25));
InstallGlobalFunction(ES,COM_FUN(26));
InstallGlobalFunction(EM,COM_FUN(27));
InstallGlobalFunction(EL,COM_FUN(28));
InstallGlobalFunction(EK,COM_FUN(29));
InstallGlobalFunction(EJ,COM_FUN(30));
InstallGlobalFunction(ER,COM_FUN(31));
InstallGlobalFunction(EI,COM_FUN(32));
InstallMethod(Sqrt,"for a rational",[IsRat],ER);
InstallGlobalFunction(StarCyc,COM_FUN(33));
InstallGlobalFunction(AtlasIrrationality,COM_FUN(34));
InstallGlobalFunction(Quadratic,COM_FUN(35));
InstallMethod(GaloisMat,"for a matrix of cyclotomics",[IsMatrix and IsCyclotomicCollColl],COM_FUN(36));
InstallMethod(RationalizedMat,"for a matrix",[IsMatrix],COM_FUN(37));
InstallOtherMethod(RationalizedMat,"for an empty list",[IsList and IsEmpty],COM_FUN(38));
InstallMethod(IsGeneratorsOfMagmaWithInverses,"for a collection of cyclotomics (return false)",[IsCyclotomicCollection],SUM_FLAGS,COM_FUN(39));
InstallMethod(FactorsSquarefree,"for a polynomial over a field of cyclotomics",IsCollsElmsX,[IsAbelianNumberFieldPolynomialRing,IsUnivariatePolynomial,IsRecord],COM_FUN(40));
InstallMethod(Factors,"for a polynomial over a field of cyclotomics",IsCollsElms,[IsAbelianNumberFieldPolynomialRing,IsUnivariatePolynomial],COM_FUN(41));
InstallGlobalFunction(DenominatorCyc,COM_FUN(42));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/cyclotom.gi"

#F  file="lib/fldabnum.gi" crc=-103551766
RANK_FILTER_LIST  := [ 33422398, 59, 6770908, 61, 33422398, 59, 6770908, 61, 
  33422398, 59, 6770908, 61, 60445850, 53, 60445850, 53, 60445850, 53, 
  60445850, 53, 65, 16, 33422398, 59, 65, 16, 6770908, 61, 6770908, 61, 
  6770908, 61, 6770908, 61, 33422398, 59, 33422398, 59, 6770908, 61, 
  33422398, 59, 33422398, 59, 33422398, 59, 33422398, 59, 33422398, 59, 
  33422398, 59, 33422398, 59, 56456811, 17, 33422398, 59, 33422398, 59, 65, 
  16, 6770908, 61, 33422398, 59, 65, 16, 33422398, 59, 33422398, 59, 65, 16, 
  6770908, 61, 33422398, 59, 65, 16, 33422398, 59, 33422398, 59, 65, 16, 
  6770908, 61, 33422398, 59, 65, 16, 33422398, 59, 33422398, 59, 66815579, 
  12, 65, 16, 40085428, 20, 65355703, 54, 40085428, 20, 40085428, 20, 
  6770908, 61, 26344233, 13, 26344233, 13, 65, 16, 36876267, 14, 65568939, 
  17, 33547271, 11, 43911325, 26, 43911325, 26, 65568939, 17, 43911325, 26, 
  43911325, 26, 65568939, 17, 43911325, 26, 43911325, 26, 65568939, 17, 
  43911325, 26, 43911325, 26, 65568939, 17, 43911325, 26, 65, 16, 43911325, 
  26, 30625149, 10, 43911325, 26, 25270276, 48, 43911325, 26, 30625149, 10, 
  43762816, 30, 30625149, 10, 43911325, 26, 30625149, 10, 43911325, 26, 
  25270276, 48, 43911325, 26, 30625149, 10, 43911325, 26, 43911325, 26, 
  43911325, 26, 43911325, 26, 17, 18, 43911325, 26, 60445850, 53 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/fldabnum.gi", -103551766 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/fldabnum.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/fldabnum.gi");
elif COM_RESULT = 3  then
Revision.fldabnum_gi:="@(#)$Id: fldabnum.gi,v 4.48 2002/04/15 10:04:40 sal Exp $";
BindGlobal("AbelianNumberFieldByReducedGaloisStabilizerInfo",COM_FUN(1));
InstallGlobalFunction(CyclotomicField,COM_FUN(2));
BindGlobal("ReducedGaloisStabilizerInfo",COM_FUN(3));
InstallGlobalFunction(AbelianNumberField,COM_FUN(4));
InstallMethod(ViewObj,"for abelian number field of cyclotomics",[IsAbelianNumberField and IsCyclotomicCollection],COM_FUN(5));
InstallMethod(ViewObj,"for cyclotomic field of cyclotomics",[IsCyclotomicField and IsCyclotomicCollection],COM_FUN(6));
InstallMethod(PrintObj,"for abelian number field of cyclotomics",[IsAbelianNumberField and IsCyclotomicCollection],COM_FUN(7));
InstallMethod(PrintObj,"for cyclotomic field of cyclotomics",[IsCyclotomicField and IsCyclotomicCollection],COM_FUN(8));
InstallMethod(String,"for abelian number field of cyclotomics",[IsAbelianNumberField and IsCyclotomicCollection],COM_FUN(9));
InstallMethod(String,"for cyclotomic field of cyclotomics",[IsCyclotomicField and IsCyclotomicCollection],COM_FUN(10));
InstallMethod(\=,"for two abelian number fields",IsIdenticalObj,[IsAbelianNumberField,IsAbelianNumberField],COM_FUN(11));
InstallMethod(\<,"for two abelian number fields",IsIdenticalObj,[IsAbelianNumberField,IsAbelianNumberField],COM_FUN(12));
InstallMethod(\in,"for cyclotomic and abelian number field",IsElmsColls,[IsCyc,IsAbelianNumberField and IsCyclotomicCollection],COM_FUN(13));
InstallMethod(\in,"for cyclotomic and cyclotomic field",IsElmsColls,[IsCyc,IsCyclotomicField and IsCyclotomicCollection],COM_FUN(14));
InstallMethod(Intersection2,"for two cyclotomic fields of cyclotomics",IsIdenticalObj,[IsCyclotomicField and IsCyclotomicCollection,IsCyclotomicField and IsCyclotomicCollection],COM_FUN(15));
InstallMethod(Intersection2,"for cyclotomic field and abelian number field",IsIdenticalObj,[IsCyclotomicField and IsCyclotomicCollection,IsAbelianNumberField and IsCyclotomicCollection],COM_FUN(16));
InstallMethod(Intersection2,"for abelian number field and cyclotomic field",IsIdenticalObj,[IsAbelianNumberField and IsCyclotomicCollection,IsCyclotomicField and IsCyclotomicCollection],COM_FUN(17));
InstallMethod(Intersection2,"for two abelian number fields",IsIdenticalObj,[IsAbelianNumberField and IsCyclotomicCollection,IsAbelianNumberField and IsCyclotomicCollection],COM_FUN(18));
InstallMethod(GeneratorsOfDivisionRing,"for abelian number field of cyclotomics",[IsAbelianNumberField and IsCyclotomicCollection],COM_FUN(19));
InstallOtherMethod(Conductor,"for abelian number field of cyclotomics",[IsAbelianNumberField and IsCyclotomicCollection],COM_FUN(20));
InstallMethod(Subfields,"for abelian number field of cyclotomics",[IsAbelianNumberField and IsCyclotomicCollection],COM_FUN(21));
InstallMethod(PrimeField,"for abelian number field of cyclotomics",[IsAbelianNumberField and IsCyclotomicCollection],COM_FUN(22));
InstallOtherMethod(FieldExtension,"for field of cyclotomics, and univ. polynomial (degree <= 2)",[IsAbelianNumberField and IsCyclotomicCollection,IsLaurentPolynomial],COM_FUN(23));
InstallMethod(Conjugates,"for two abelian number fields of cyclotomics, and cyclotomic",IsCollsXElms,[IsAbelianNumberField and IsCyclotomicCollection,IsAbelianNumberField and IsCyclotomicCollection,IsCyc],COM_FUN(24));
InstallMethod(Conjugates,"for cycl. field of cyclotomics, ab. number field, and cyclotomic",IsCollsXElms,[IsCyclotomicField and IsCyclotomicCollection,IsAbelianNumberField and IsCyclotomicCollection,IsCyc],COM_FUN(25));
InstallMethod(Norm,"for two abelian number fields of cyclotomics, and cyclotomic",IsCollsXElms,[IsAbelianNumberField and IsCyclotomicCollection,IsAbelianNumberField and IsCyclotomicCollection,IsCyc],COM_FUN(26));
InstallMethod(Norm,"for cycl. field of cyclotomics, ab. number field, and cyclotomic",IsCollsXElms,[IsCyclotomicField and IsCyclotomicCollection,IsAbelianNumberField and IsCyclotomicCollection,IsCyc],COM_FUN(27));
InstallMethod(Trace,"for two abelian number fields of cyclotomics, and cyclotomic",IsCollsXElms,[IsAbelianNumberField and IsCyclotomicCollection,IsAbelianNumberField and IsCyclotomicCollection,IsCyc],COM_FUN(28));
InstallMethod(Trace,"for cycl. field of cyclotomics, ab. number field, and cyclotomic",IsCollsXElms,[IsCyclotomicField and IsCyclotomicCollection,IsAbelianNumberField and IsCyclotomicCollection,IsCyc],COM_FUN(29));
InstallGlobalFunction(ZumbroichBase,COM_FUN(30));
InstallGlobalFunction(LenstraBase,COM_FUN(31));
DeclareRepresentation("IsCanonicalBasisAbelianNumberFieldRep",IsAttributeStoringRep,["coeffslist","coeffsmat","lenstrabase","conductor"]);
DeclareRepresentation("IsCanonicalBasisCyclotomicFieldRep",IsCanonicalBasisAbelianNumberFieldRep,["zumbroichbase"]);
InstallMethod(CanonicalBasis,"for abelian number field of cyclotomics",[IsAbelianNumberField and IsCyclotomicCollection],COM_FUN(32));
InstallMethod(Basis,"for abelian number field of cyclotomics (delegate to `CanonicalBasis')",[IsAbelianNumberField and IsCyclotomicCollection],CANONICAL_BASIS_FLAGS,CanonicalBasis);
InstallMethod(Coefficients,"for canonical basis of abelian number field, and cyclotomic",IsCollsElms,[IsBasis and IsCanonicalBasis and IsCanonicalBasisAbelianNumberFieldRep,IsCyc],COM_FUN(33));
InstallOtherMethod(FieldByGenerators,"for collection of cyclotomics",[IsCyclotomicCollection],COM_FUN(34));
InstallMethod(FieldByGenerators,"for field and collection, both collections of cyclotomics",IsIdenticalObj,[IsField and IsCyclotomicCollection,IsCyclotomicCollection],COM_FUN(35));
InstallMethod(DefaultFieldByGenerators,"for collection of cyclotomics",[IsCyclotomicCollection],COM_FUN(36));
InstallMethod(CanonicalBasis,"for cyclotomic field of cyclotomics",[IsCyclotomicField and IsCyclotomicCollection],COM_FUN(37));
InstallMethod(BasisVectors,"for canon. basis of cyclotomic field of cyclotomics",[IsBasis and IsCanonicalBasis and IsCanonicalBasisCyclotomicFieldRep],COM_FUN(38));
InstallMethod(Coefficients,"for canonical basis of cyclotomic field, and cyclotomic",IsCollsElms,[IsBasis and IsCanonicalBasis and IsCanonicalBasisCyclotomicFieldRep,IsCyc],COM_FUN(39));
InstallValue(Cyclotomics,Objectify(NewType(CollectionsFamily(CyclotomicsFamily),IsField and IsAttributeStoringRep),rec()));
SetName(Cyclotomics,"Cyclotomics");
SetLeftActingDomain(Cyclotomics,Rationals);
SetIsFiniteDimensional(Cyclotomics,false);
SetIsFinite(Cyclotomics,false);
SetIsWholeFamily(Cyclotomics,true);
SetDegreeOverPrimeField(Cyclotomics,infinity);
SetDimension(Cyclotomics,infinity);
DeclareRepresentation("IsANFAutomorphismRep",IsAttributeStoringRep,["galois"]);
DeclareSynonym("IsANFAutomorphism",IsANFAutomorphismRep and IsFieldHomomorphism and IsMapping and IsBijective);
InstallMethod(ExponentOfPowering,"for an ANFAutomorphism",[IsMapping and IsANFAutomorphismRep],COM_FUN(40));
InstallMethod(ExponentOfPowering,"for an identity mapping",[IsMapping and IsOne],COM_FUN(41));
InstallMethod(ExponentOfPowering,"for a mapping (check whether it is the identity mapping)",[IsMapping],COM_FUN(42));
InstallGlobalFunction(ANFAutomorphism,COM_FUN(43));
InstallMethod(\=,"for two ANF automorphisms",IsIdenticalObj,[IsFieldHomomorphism and IsANFAutomorphismRep,IsFieldHomomorphism and IsANFAutomorphismRep],COM_FUN(44));
InstallMethod(\=,"for identity mapping and ANF automorphism",IsIdenticalObj,[IsMapping and IsOne,IsFieldHomomorphism and IsANFAutomorphismRep],COM_FUN(45));
InstallMethod(\=,"for ANF automorphism and identity mapping",IsIdenticalObj,[IsFieldHomomorphism and IsANFAutomorphismRep,IsMapping and IsOne],COM_FUN(46));
InstallMethod(\<,"for two ANF automorphisms",IsIdenticalObj,[IsFieldHomomorphism and IsANFAutomorphismRep,IsFieldHomomorphism and IsANFAutomorphismRep],COM_FUN(47));
InstallMethod(\<,"for identity mapping and ANF automorphism",IsIdenticalObj,[IsMapping and IsOne,IsFieldHomomorphism and IsANFAutomorphismRep],COM_FUN(48));
InstallMethod(\<,"for ANF automorphism and identity mapping",IsIdenticalObj,[IsFieldHomomorphism and IsANFAutomorphismRep,IsMapping and IsOne],COM_FUN(49));
InstallMethod(ImageElm,"for ANF automorphism and scalar",FamSourceEqFamElm,[IsFieldHomomorphism and IsANFAutomorphismRep,IsCyc],COM_FUN(50));
InstallMethod(ImagesElm,"for ANF automorphism and scalar",FamSourceEqFamElm,[IsFieldHomomorphism and IsANFAutomorphismRep,IsScalar],COM_FUN(51));
InstallMethod(ImagesSet,"for ANF automorphism and field",CollFamSourceEqFamElms,[IsFieldHomomorphism and IsANFAutomorphismRep,IsField],COM_FUN(52));
InstallMethod(ImagesRepresentative,"for ANF automorphism and scalar",FamSourceEqFamElm,[IsFieldHomomorphism and IsANFAutomorphismRep,IsScalar],COM_FUN(53));
InstallMethod(PreImageElm,"for ANF automorphism and scalar",FamRangeEqFamElm,[IsFieldHomomorphism and IsBijective and IsANFAutomorphismRep,IsScalar],COM_FUN(54));
InstallMethod(PreImagesElm,"for ANF automorphism and scalar",FamRangeEqFamElm,[IsFieldHomomorphism and IsANFAutomorphismRep,IsScalar],COM_FUN(55));
InstallMethod(PreImagesSet,"for ANF automorphism and scalar",CollFamRangeEqFamElms,[IsFieldHomomorphism and IsANFAutomorphismRep,IsField],COM_FUN(56));
InstallMethod(PreImagesRepresentative,"for ANF automorphism and scalar",FamRangeEqFamElm,[IsFieldHomomorphism and IsANFAutomorphismRep,IsScalar],COM_FUN(57));
InstallMethod(CompositionMapping2,"for two ANF automorphisms",FamSource1EqFamRange2,[IsFieldHomomorphism and IsANFAutomorphismRep,IsFieldHomomorphism and IsANFAutomorphismRep],COM_FUN(58));
InstallOtherMethod(InverseGeneralMapping,"for ANF automorphism",[IsFieldHomomorphism and IsANFAutomorphismRep],COM_FUN(59));
InstallMethod(\^,"for ANF automorphism and integer",[IsFieldHomomorphism and IsANFAutomorphismRep,IsInt],COM_FUN(60));
InstallMethod(PrintObj,"for ANF automorphism",[IsFieldHomomorphism and IsANFAutomorphismRep],COM_FUN(61));
InstallMethod(GaloisGroup,"for abelian number field ",[IsAbelianNumberField],COM_FUN(62));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/fldabnum.gi"

#F  file="lib/padics.gi" crc=-42719481
RANK_FILTER_LIST  := [ 13769829, 13, 17, 18, 13769829, 13, 33, 17, 33, 17, 
  13769829, 13, 27547849, 25, 33, 17, 33, 17, 27547849, 25, 13769829, 13, 
  13769829, 13, 37981223, 5, 40085428, 20, 37981223, 5, 33, 17, 18990612, 14, 
  37981223, 5, 37981223, 5, 18990612, 14, 37981223, 5, 18990612, 14, 
  18990612, 14, 18990612, 14, 18990612, 14, 18990612, 14, 18990612, 14, 
  18990612, 14, 18990612, 14, 18990612, 14, 18990612, 14, 18990612, 14, 
  18990612, 14, 18990612, 14, 17707131, 5, 8193, 2, 17707131, 5, 33, 17, 
  8853566, 14, 17707131, 5, 17707131, 5, 8853566, 14, 17707131, 5, 8853566, 
  14, 8853566, 14, 8853566, 14, 8853566, 14, 8853566, 14, 8853566, 14, 
  8853566, 14, 18990612, 14, 8853566, 14, 8853566, 14, 18990612, 14, 8853566, 
  14, 8853566, 14, 8853566, 14, 8853566, 14, 8853566, 14, 8853566, 14 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/padics.gi", -42719481 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/padics.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/padics.gi");
elif COM_RESULT = 3  then
Revision.padics_gi:="@(#)$Id: padics.gi,v 4.18 2002/04/15 10:05:11 sal Exp $";
PrintPadicExpansion:=COM_FUN(1);
PadicExpansionByRat:=COM_FUN(2);
MultMatrixPadicNumbersByCoefficientsList:=COM_FUN(3);
StructureConstantsPadicNumbers:=COM_FUN(4);
InstallMethod(ShiftedPadicNumber,true,[IsPadicNumber,IsInt],0,COM_FUN(5));
InstallMethod(\*,true,[IsPadicNumber,IsRat],0,COM_FUN(6));
InstallMethod(\*,true,[IsRat,IsPadicNumber],0,COM_FUN(7));
InstallMethod(\*,true,[IsPadicNumberList,IsRat],0,COM_FUN(8));
InstallMethod(\*,true,[IsRat,IsPadicNumberList],0,COM_FUN(9));
InstallMethod(ZeroOp,"for a p-adic number",true,[IsPadicNumber],0,COM_FUN(10));
InstallMethod(OneOp,"for a p-adic number",true,[IsPadicNumber],0,COM_FUN(11));
InstallGlobalFunction(PurePadicNumberFamily,COM_FUN(12));
InstallMethod(PadicNumber,true,[IsPurePadicNumberFamily,IsCyclotomicCollection],0,COM_FUN(13));
InstallMethod(PadicNumber,true,[IsPurePadicNumberFamily,IsRat],0,COM_FUN(14));
InstallMethod(PrintObj,true,[IsPurePadicNumber],0,COM_FUN(15));
InstallOtherMethod(Random,true,[IsPurePadicNumberFamily],0,COM_FUN(16));
InstallOtherMethod(Zero,true,[IsPurePadicNumberFamily],0,COM_FUN(17));
InstallMethod(IsZero,true,[IsPurePadicNumber],0,COM_FUN(18));
InstallOtherMethod(One,true,[IsPurePadicNumberFamily],0,COM_FUN(19));
InstallMethod(Valuation,true,[IsPurePadicNumber],0,COM_FUN(20));
InstallMethod(AdditiveInverseOp,true,[IsPurePadicNumber],0,COM_FUN(21));
InstallMethod(InverseOp,true,[IsPurePadicNumber],0,COM_FUN(22));
InstallMethod(\+,IsIdenticalObj,[IsPurePadicNumber,IsPurePadicNumber],0,COM_FUN(23));
InstallMethod(\*,IsIdenticalObj,[IsPurePadicNumber,IsPurePadicNumber],0,COM_FUN(24));
InstallMethod(\/,IsIdenticalObj,[IsPurePadicNumber,IsPurePadicNumber],0,COM_FUN(25));
InstallMethod(\=,IsIdenticalObj,[IsPurePadicNumber,IsPurePadicNumber],0,COM_FUN(26));
InstallMethod(\<,IsIdenticalObj,[IsPurePadicNumber,IsPurePadicNumber],0,COM_FUN(27));
InstallGlobalFunction(PadicExtensionNumberFamily,COM_FUN(28));
InstallMethod(PadicNumber,true,[IsPadicExtensionNumberFamily,IsList],0,COM_FUN(29));
InstallMethod(PadicNumber,true,[IsPadicExtensionNumberFamily,IsRat],0,COM_FUN(30));
InstallMethod(PrintObj,true,[IsPadicExtensionNumber],0,COM_FUN(31));
InstallOtherMethod(Random,true,[IsPadicExtensionNumberFamily],0,COM_FUN(32));
InstallOtherMethod(Zero,true,[IsPadicExtensionNumberFamily],0,COM_FUN(33));
InstallMethod(IsZero,true,[IsPadicExtensionNumber],0,COM_FUN(34));
InstallOtherMethod(One,true,[IsPadicExtensionNumberFamily],0,COM_FUN(35));
InstallMethod(Valuation,true,[IsPadicExtensionNumber],0,COM_FUN(36));
InstallMethod(AdditiveInverseOp,true,[IsPadicExtensionNumber],0,COM_FUN(37));
InstallMethod(InverseOp,true,[IsPadicExtensionNumber],0,COM_FUN(38));
InstallMethod(\+,IsIdenticalObj,[IsPadicExtensionNumber,IsPadicExtensionNumber],0,COM_FUN(39));
InstallMethod(\-,IsIdenticalObj,[IsPadicExtensionNumber,IsPadicExtensionNumber],0,COM_FUN(40));
InstallMethod(\*,true,[IsPurePadicNumber,IsPadicExtensionNumber],0,COM_FUN(41));
InstallMethod(\*,true,[IsPadicExtensionNumber,IsPurePadicNumber],0,COM_FUN(42));
InstallMethod(\*,IsIdenticalObj,[IsPadicExtensionNumber,IsPadicExtensionNumber],0,COM_FUN(43));
InstallMethod(\=,IsIdenticalObj,[IsPadicExtensionNumber,IsPadicExtensionNumber],0,COM_FUN(44));
InstallMethod(\<,IsIdenticalObj,[IsPadicExtensionNumber,IsPadicExtensionNumber],0,COM_FUN(45));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/padics.gi"

#F  file="lib/vecmat.gi" crc=91453122
RANK_FILTER_LIST  := [ 20586242, 12, 20586242, 12, 52247917, 19, 20586242, 
  12, 52247917, 19, 20586242, 12, 24639, 14, 20586242, 12, 52247917, 19, 1, 
  0, 20586242, 12, 52247917, 19, 20578050, 2, 18535950, 20, 17497739, 23, 
  17497740, 25, 17497739, 23, 17497739, 23, 17497739, 23, 17497740, 25, 
  17497739, 23, 18547110, 20, 18547110, 20, 18547110, 20, 18547110, 20, 
  17497739, 23, 17497739, 23, 17497739, 23, 17497739, 23, 13124591, 31, 
  13124591, 31, 257, 15, 14173962, 28, 14173962, 28, 257, 15, 18547111, 22, 
  18547110, 20, 257, 15, 18547111, 22, 18547110, 20, 41951069, 19, 18547110, 
  20, 257, 15, 41951069, 19, 18547110, 20, 18547111, 22, 12688527, 30, 
  32459915, 39, 32459915, 39, 52247917, 19, 41164292, 14, 52247917, 19, 1, 0, 
  41164291, 12, 52247917, 19, 1, 0, 41164292, 14, 52247917, 19, 41164291, 12, 
  52247917, 19, 41156099, 2, 32448755, 39, 32459915, 39, 32459915, 39, 
  32459915, 39, 31410544, 40, 31410544, 40, 31410544, 40, 12902677, 50, 
  12902677, 50, 48405456, 51, 48405456, 51, 49023315, 40, 49023315, 40, 
  49023315, 40, 31410544, 40, 31410544, 40, 31410544, 40, 31410544, 40, 
  31410544, 40, 31410544, 40, 31410544, 40, 31410544, 40, 31410544, 40, 
  31410544, 40, 31410544, 40, 13124591, 31, 31410544, 40, 56510143, 28, 
  8081033, 40, 31410544, 40, 17497739, 23, 31410544, 40, 31410544, 40, 257, 
  15, 31410544, 40, 31410544, 40, 257, 15, 1, 0, 58412696, 30, 1, 0, 
  58412696, 30, 1025, 1, 25270276, 48, 30408555, 2, 25270276, 48, 41156099, 
  2, 52247917, 19, 30408555, 2, 52247917, 19, 41156099, 2, 1, 0, 41942876, 3, 
  1, 0, 8193, 2, 62914231, 12, 16383401, 12, 18547111, 22, 257, 15, 18547110, 
  20, 8005674, 17, 18547110, 20, 8005674, 17, 8005434, 20, 20586243, 14, 
  20586242, 12, 41164291, 12, 1, 0, 18555302, 20, 18547110, 20, 65077940, 12, 
  18546645, 36, 52247917, 19, 65077475, 29, 52247917, 19, 25258651, 278, 
  18546645, 36, 5675459, 50, 18546645, 36, 18547111, 22, 52247917, 19, 
  18547111, 22, 52247917, 19, 8005674, 17, 18547111, 22, 18547111, 22, 
  8005674, 17, 18547110, 20, 17, 18, 18547110, 20, 17, 18, 18547110, 20, 
  18547110, 20, 18547111, 22, 17, 18, 18547110, 20, 17, 18, 18547111, 22, 
  18547110, 20, 18547110, 20, 17, 18, 52247917, 19, 18547110, 20, 17, 18, 
  63197665, 24, 8193, 2, 5, 1, 5675459, 50, 5675459, 50, 48405457, 53, 
  48405457, 53, 48405457, 53, 5675460, 52, 48405457, 53, 48405457, 53, 
  41156099, 2, 41156099, 2, 20578050, 2, 20578050, 2, 41156099, 2 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/vecmat.gi", 91453122 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/vecmat.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/vecmat.gi");
elif COM_RESULT = 3  then
Revision.vecmat_gi:="@(#)$Id: vecmat.gi,v 4.93.2.2 2005/05/03 21:16:52 sal Exp $";
DeclareFilter("IsLockedRepresentationVector");
InstallValue(TYPE_LIST_GF2VEC,NewType(CollectionsFamily(FFEFamily(2)),IsHomogeneousList and IsListDefault and IsNoImmediateMethodsObject and IsMutable and IsCopyable and IsGF2VectorRep));
InstallValue(TYPE_LIST_GF2VEC_IMM,NewType(CollectionsFamily(FFEFamily(2)),IsHomogeneousList and IsListDefault and IsNoImmediateMethodsObject and IsCopyable and IsGF2VectorRep));
InstallValue(TYPE_LIST_GF2VEC_IMM_LOCKED,NewType(CollectionsFamily(FFEFamily(2)),IsHomogeneousList and IsListDefault and IsNoImmediateMethodsObject and IsCopyable and IsGF2VectorRep and IsLockedRepre\
sentationVector));
InstallValue(TYPE_LIST_GF2VEC_LOCKED,NewType(CollectionsFamily(FFEFamily(2)),IsHomogeneousList and IsListDefault and IsNoImmediateMethodsObject and IsCopyable and IsGF2VectorRep and IsLockedRepresentationVector and IsMutable));
InstallValue(TYPE_LIST_GF2MAT,NewType(CollectionsFamily(CollectionsFamily(FFEFamily(2))),IsMatrix and IsListDefault and IsSmallList and IsFFECollColl and IsNoImmediateMethodsObject and IsMutable and IsCopyable and IsGF2MatrixRep and HasIsRectangularTable and IsRectangularTable));
InstallValue(TYPE_LIST_GF2MAT_IMM,NewType(CollectionsFamily(CollectionsFamily(FFEFamily(2))),IsMatrix and IsListDefault and IsCopyable and IsGF2MatrixRep and IsNoImmediateMethodsObject and IsSmallList and IsFFECollColl and HasIsRectangularTable and IsRectangularTable));
InstallMethod(Length,"for GF2 vector",true,[IsList and IsGF2VectorRep],0,LEN_GF2VEC);
InstallMethod(ELM0_LIST,"for GF2 vector",true,[IsList and IsGF2VectorRep,IsPosInt],0,ELM0_GF2VEC);
InstallMethod(ELM_LIST,"for GF2 vector",true,[IsList and IsGF2VectorRep,IsPosInt],0,ELM_GF2VEC);
InstallMethod(ELMS_LIST,"for GF2 vector",true,[IsList and IsGF2VectorRep,IsList and IsDenseList and IsInternalRep],0,ELMS_GF2VEC);
InstallOtherMethod(ASS_LIST,"for GF2 vector",true,[IsList and IsGF2VectorRep,IsPosInt,IsObject],0,ASS_GF2VEC);
InstallOtherMethod(UNB_LIST,"for GF2 vector",true,[IsList and IsGF2VectorRep,IsPosInt],0,UNB_GF2VEC);
InstallMethod(PrintObj,"for GF2 vector",true,[IsGF2VectorRep],0,COM_FUN(1));
InstallMethod(ViewObj,"for GF2 vector",true,[IsRowVector and IsFinite and IsGF2VectorRep],0,COM_FUN(2));
InstallMethod(AdditiveInverseMutable,"for GF2 vector",true,[IsRowVector and IsListDefault and IsGF2VectorRep],0,ShallowCopy);
InstallMethod(AdditiveInverseSameMutability,"for GF2 vector, mutable",true,[IsRowVector and IsListDefault and IsGF2VectorRep and IsMutable],0,ShallowCopy);
InstallMethod(AdditiveInverseSameMutability,"for GF2 vector, immutable",true,[IsRowVector and IsListDefault and IsGF2VectorRep],0,COM_FUN(3));
InstallMethod(AdditiveInverse,"for GF2 vector",true,[IsRowVector and IsListDefault and IsGF2VectorRep],0,Immutable);
InstallMethod(ZeroOp,"for GF2 vector",true,[IsRowVector and IsListDefault and IsGF2VectorRep],0,ZERO_GF2VEC);
InstallMethod(ZeroSameMutability,"for GF2 vector, mutable",true,[IsRowVector and IsListDefault and IsGF2VectorRep and IsMutable],0,ZERO_GF2VEC);
InstallMethod(ZeroSameMutability,"for GF2 vector, immutable",true,[IsRowVector and IsListDefault and IsGF2VectorRep],0,COM_FUN(4));
InstallMethod(\=,"for GF2 vectors",IsIdenticalObj,[IsRowVector and IsGF2VectorRep,IsRowVector and IsGF2VectorRep],0,EQ_GF2VEC_GF2VEC);
InstallMethod(\<,"for GF2 vectors",IsIdenticalObj,[IsRowVector and IsGF2VectorRep,IsRowVector and IsGF2VectorRep],0,LT_GF2VEC_GF2VEC);
InstallMethod(\+,"for GF2 vectors",IsIdenticalObj,[IsRowVector and IsListDefault and IsGF2VectorRep,IsRowVector and IsListDefault and IsGF2VectorRep],0,SUM_GF2VEC_GF2VEC);
InstallMethod(\-,"for GF2 vectors",IsIdenticalObj,[IsRowVector and IsListDefault and IsGF2VectorRep,IsRowVector and IsListDefault and IsGF2VectorRep],0,SUM_GF2VEC_GF2VEC);
InstallMethod(\*,"for GF2 vectors",IsIdenticalObj,[IsRingElementList and IsListDefault and IsRowVector and IsGF2VectorRep,IsRingElementList and IsListDefault and IsRowVector and IsGF2VectorRep],0,PROD_GF2VEC_GF2VEC);
InstallMethod(\*,"for FFE and GF2 vector",IsElmsColls,[IsFFE,IsRingElementList and IsRowVector and IsGF2VectorRep],10,COM_FUN(5));
InstallMethod(\*,"for GF2 vector and FFE",IsCollsElms,[IsRingElementList and IsRowVector and IsGF2VectorRep,IsFFE],10,COM_FUN(6));
InstallOtherMethod(AddCoeffs,"for GF2 vectors and FFE",COM_FUN(7),[IsRowVector and IsGF2VectorRep and IsMutable,IsRowVector and IsGF2VectorRep,IsFFE],0,ADDCOEFFS_GF2VEC_GF2VEC_MULT);
InstallOtherMethod(AddCoeffs,"for GF2 vectors",IsIdenticalObj,[IsRowVector and IsGF2VectorRep and IsMutable,IsRowVector and IsGF2VectorRep],0,ADDCOEFFS_GF2VEC_GF2VEC);
InstallOtherMethod(AddCoeffs,"for empty list, GF2 vector and FFE",true,[IsList and IsEmpty and IsMutable,IsRowVector and IsGF2VectorRep,IsFFE],0,COM_FUN(8));
InstallOtherMethod(AddCoeffs,"for empty list, GF2 vector",true,[IsList and IsEmpty and IsMutable,IsRowVector and IsGF2VectorRep],0,COM_FUN(9));
InstallMethod(ShrinkCoeffs,"for GF2 vector",true,[IsMutable and IsRowVector and IsGF2VectorRep],0,SHRINKCOEFFS_GF2VEC);
InstallMethod(NormedRowVector,"for GF(2) vector",true,[IsRowVector and IsGF2VectorRep and IsScalarCollection],0,COM_FUN(10));
InstallMethod(Length,"for GF2 matrix",true,[IsMatrix and IsGF2MatrixRep],0,COM_FUN(11));
InstallMethod(ELM_LIST,"for GF2 matrix",true,[IsMatrix and IsGF2MatrixRep,IsPosInt],0,COM_FUN(12));
InstallMethod(ASS_LIST,"for GF2 matrix",true,[IsList and IsGF2MatrixRep and IsMutable,IsPosInt,IsObject],0,ASS_GF2MAT);
InstallOtherMethod(ASS_LIST,"for GF2 matrix",true,[IsList and IsGF2MatrixRep,IsPosInt,IsObject],0,ASS_GF2MAT);
InstallMethod(UNB_LIST,"for GF2 matrix",true,[IsList and IsGF2MatrixRep and IsMutable,IsPosInt],0,UNB_GF2MAT);
InstallOtherMethod(UNB_LIST,"for GF2 matrix",true,[IsList and IsGF2MatrixRep,IsPosInt],0,COM_FUN(13));
InstallMethod(PrintObj,"for GF2 matrix",true,[IsGF2MatrixRep],0,COM_FUN(14));
InstallMethod(ViewObj,"for GF2 matrix",true,[IsMatrix and IsFinite and IsGF2MatrixRep],0,COM_FUN(15));
BindGlobal("SHALLOWCOPY_GF2MAT",COM_FUN(16));
InstallMethod(ShallowCopy,"for GF2 matrix",true,[IsMatrix and IsGF2MatrixRep],0,SHALLOWCOPY_GF2MAT);
InstallMethod(TransposedMat,"GF2 matrix",true,[IsMatrix and IsGF2MatrixRep],0,TRANSPOSED_GF2MAT);
InstallMethod(MutableTransposedMat,"GF2 matrix",true,[IsMatrix and IsGF2Matrix\
Rep],0,TRANSPOSED_GF2MAT);
InstallMethod(AdditiveInverseOp,"for GF2 matrix",true,[IsMatrix and IsListDefault and IsGF2MatrixRep],0,COM_FUN(17));
InstallMethod(AdditiveInverseSameMutability,"for GF2 matrix",true,[IsMatrix and IsListDefault and IsGF2MatrixRep],0,COM_FUN(18));
InstallMethod(AdditiveInverse,"for GF2 matrix",true,[IsMatrix and IsListDefault and IsGF2MatrixRep],0,Immutable);
InstallMethod(InverseOp,"for GF2 matrix",true,[IsMultiplicativeElementWithInverse and IsOrdinaryMatrix and IsSmallList and IsFFECollColl and IsGF2MatrixRep],0,INV_GF2MAT_MUTABLE);
InstallMethod(InverseSameMutability,"for GF2 matrix",true,[IsMultiplicativeElementWithInverse and IsOrdinaryMatrix and IsSmallList and IsFFECollColl and IsGF2MatrixRep],0,INV_GF2MAT_SAME_MUTABILITY);
InstallMethod(InverseOp,"for plain list of GF2 vectors",true,[IsPlistRep and IsFFECollColl and IsMatrix],0,COM_FUN(19));
InstallMethod(InverseSameMutability,"for plain list of GF2 vectors",true,[IsPlistRep and IsFFECollColl and IsMatrix],0,COM_FUN(20));
BindGlobal("GF2IdentityMatrix",COM_FUN(21));
InstallMethod(OneOp,"for GF2 Matrix",true,[IsOrdinaryMatrix and IsGF2MatrixRep and IsMultiplicativeElementWithOne],0,COM_FUN(22));
InstallMethod(One,"for GF2 Matrix",true,[IsOrdinaryMatrix and IsGF2MatrixRep and IsMultiplicativeElementWithOne],0,COM_FUN(23));
InstallMethod(OneSameMutability,"for GF2 Matrix",true,[IsOrdinaryMatrix and IsGF2MatrixRep and IsMultiplicativeElementWithOne],0,COM_FUN(24));
InstallMethod(ZeroOp,"for GF2 Matrix",true,[IsMatrix and IsListDefault and IsGF2MatrixRep],0,COM_FUN(25));
InstallMethod(ZeroSameMutability,"for GF2 Matrix",true,[IsMatrix and IsListDefault and IsGF2MatrixRep],0,COM_FUN(26));
InstallMethod(Zero,"for GF2 Matrix",true,[IsMatrix and IsListDefault and IsGF2MatrixRep],0,COM_FUN(27));
InstallMethod(\+,"for GF2 matrix and GF2 matrix",IsIdenticalObj,[IsMatrix and IsListDefault and IsGF2MatrixRep,IsMatrix and IsListDefault and IsGF2MatrixRep],0,SUM_GF2MAT_GF2MAT);
InstallMethod(\<,"for GF2 matrix and GF2 matrix",IsIdenticalObj,[IsMatrix and IsListDefault and IsGF2MatrixRep,IsMatrix and IsListDefault and IsGF2MatrixRep],0,LT_GF2MAT_GF2MAT);
InstallMethod(\=,"for GF2 matrix and GF2 matrix",IsIdenticalObj,[IsMatrix and IsListDefault and IsGF2MatrixRep,IsMatrix and IsListDefault and IsGF2MatrixRep],0,EQ_GF2MAT_GF2MAT);
InstallMethod(\-,"for GF2 matrix and GF2 matrix",IsIdenticalObj,[IsMatrix and IsListDefault and IsGF2MatrixRep,IsMatrix and IsListDefault and IsGF2MatrixRep],0,SUM_GF2MAT_GF2MAT);
InstallMethod(\*,"for GF2 vector and GF2 matrix",true,[IsRingElementList and IsRowVector and IsListDefault and IsGF2VectorRep,IsMatrix and IsListDefault and IsGF2MatrixRep],0,PROD_GF2VEC_GF2MAT);
InstallMethod(\*,"For a GF2 vector and a compatible matrix",IsElmsColls,[IsRowVector and IsGF2VectorRep and IsSmallList and IsRingElementList,IsRingElementTable and IsPlistRep],0,PROD_GF2VEC_ANYMAT);
InstallMethod(\*,"for GF2 matrix and GF2 vector",true,[IsMatrix and IsListDefault and IsGF2MatrixRep,IsRowVector and IsListDefault and IsGF2VectorRep],0,PROD_GF2MAT_GF2VEC);
InstallMethod(\*,"for GF2 matrix and GF2 matrix",IsIdenticalObj,[IsMatrix and IsListDefault and IsGF2MatrixRep,IsMatrix and IsListDefault and IsGF2MatrixRep],0,PROD_GF2MAT_GF2MAT);
InstallMethod(\*,"for GF2 element and GF2 matrix",IsElmsCollColls,[IsFFE,IsMatrix and IsListDefault and IsGF2MatrixRep],0,COM_FUN(28));
InstallMethod(\*,"for GF2 matrix and GF2 element",IsCollCollsElms,[IsMatrix and IsListDefault and IsGF2MatrixRep,IsFFE],0,COM_FUN(29));
LOCAL_COPY_GF2:=GF(2);
InstallGlobalFunction(ConvertToVectorRepNC,COM_FUN(30));
DoImmutableMatrix:=COM_FUN(31);
InstallMethod(ImmutableMatrix,"general,2",[IsObject,IsMatrix],0,COM_FUN(32));
InstallOtherMethod(ImmutableMatrix,"general,3",[IsObject,IsMatrix,IsBool],0,DoImmutableMatrix);
InstallOtherMethod(ImmutableMatrix,"field,8bit",[IsField,Is8BitMatrixRep],0,COM_FUN(33));
InstallOtherMethod(ImmutableMatrix,"field,gf2",[IsField,IsGF2MatrixRep],0,COM_FUN(34));
InstallOtherMethod(ImmutableMatrix,"fieldsize,8bit",[IsPosInt,Is8BitMatrixRep]\
,0,COM_FUN(35));
InstallOtherMethod(ImmutableMatrix,"fieldsize,gf2",[IsPosInt,IsGF2MatrixRep],0,COM_FUN(36));
InstallOtherMethod(ImmutableMatrix,"empty",[IsObject,IsEmpty],0,COM_FUN(37));
InstallOtherMethod(ImmutableMatrix,"transposed empty",[IsObject,IsList],0,COM_FUN(38));
InstallMethod(PlainListCopyOp,"for a GF2 vector",true,[IsGF2VectorRep and IsSmallList],0,COM_FUN(39));
InstallMethod(PlainListCopyOp,"for a GF2 matrix",true,[IsSmallList and IsGF2MatrixRep],0,COM_FUN(40));
InstallOtherMethod(MultRowVector,"for GF(2) vector and char 2 scalar",IsCollsElms,[IsGF2VectorRep and IsRowVector and IsMutable,IsFFE],0,MULT_ROW_VECTOR_GF2VECS_2);
InstallOtherMethod(PositionNot,"for GF(2) vector and 0*Z(2)",IsCollsElms,[IsGF2VectorRep and IsRowVector,IsFFE and IsZero],0,POSITION_NONZERO_GF2VEC);
InstallMethod(PositionNot,"for GF(2) vector and 0*Z(2) and 0",IsCollsElmsX,[IsGF2VectorRep and IsRowVector,IsFFE and IsZero,IsZero and IsInt],0,COM_FUN(41));
InstallMethod(Append,"for GF2 vectors",true,[IsGF2VectorRep and IsMutable and IsList,IsGF2VectorRep and IsList],0,APPEND_GF2VEC);
InstallMethod(PositionCanonical,"for internally represented lists, fall back on `Position'",true,[IsList and IsGF2MatrixRep,IsObject],0,COM_FUN(42));
InstallMethod(ShallowCopy,"for GF2 vectors",true,[IsGF2VectorRep and IsList and IsRowVector],0,SHALLOWCOPY_GF2VEC);
InstallMethod(PositionNonZero,"for GF(2) vector",true,[IsGF2VectorRep and IsRowVector],0,COM_FUN(43));
InstallMethod(PositionNonZero,"General method for a row vector",true,[IsRowVector],0,COM_FUN(44));
InstallMethod(NumberFFVector,"GF2-Vector",true,[IsGF2VectorRep and IsRowVector and IsFFECollection,IsPosInt],0,COM_FUN(45));
InstallMethod(NumberFFVector,"uncompressed vecffe",[IsRowVector and IsFFECollection,IsPosInt],COM_FUN(46));
InstallMethod(IsSubset,"field, 8bit-vector",IsIdenticalObj,[IsField and IsFinite and IsFFECollection,IsGF2VectorRep and IsRowVector and IsFFECollection],0,COM_FUN(47));
InstallMethod(DefaultFieldOfMatrix,"method for a matrix over GF(2)",true,[IsMatrix and IsFFECollColl and IsGF2MatrixRep],0,COM_FUN(48));
InstallOtherMethod(DegreeFFE,"for GF(2) vectors",true,[IsRowVector and IsFFECollection and IsGF2VectorRep],0,COM_FUN(49));
InstallMethod(LeftShiftRowVector,"gf2 vector",true,[IsMutable and IsRowVector and IsGF2VectorRep,IsPosInt],0,SHIFT_LEFT_GF2VEC);
InstallMethod(RightShiftRowVector,"gf2 vector, fill with zeros",IsCollsXElms,[IsMutable and IsRowVector and IsGF2VectorRep,IsPosInt,IsFFE and IsZero],0,SHIFT_RIGHT_GF2VEC);
InstallMethod(ShrinkRowVector,"GF2 vector",true,[IsMutable and IsRowVector and IsGF2VectorRep],0,COM_FUN(50));
InstallMethod(RemoveOuterCoeffs,"gf2vec and zero",IsCollsElms,[IsMutable and IsGF2VectorRep and IsRowVector,IsFFE and IsZero],0,COM_FUN(51));
InstallMethod(ProductCoeffs,"GF2 vectors, kernel method",IsFamXFamY,[IsGF2VectorRep and IsRowVector,IsInt,IsGF2VectorRep and IsRowVector,IsInt],0,PROD_COEFFS_GF2VEC);
InstallOtherMethod(ProductCoeffs,"Gf2 vectors, kernel method (2 arg)",IsIdenticalObj,[IsGF2VectorRep and IsRowVector,IsGF2VectorRep and IsRowVector],0,COM_FUN(52));
InstallMethod(ReduceCoeffs,"GF2 vectors, kernel method",IsFamXFamY,[IsGF2VectorRep and IsRowVector and IsMutable,IsInt,IsGF2VectorRep and IsRowVector,IsInt],0,REDUCE_COEFFS_GF2VEC);
InstallOtherMethod(ReduceCoeffs,"Gf2 vectors, kernel method (2 arg)",IsIdenticalObj,[IsGF2VectorRep and IsRowVector and IsMutable,IsGF2VectorRep and IsRowVector],0,COM_FUN(53));
InstallMethod(PowerModCoeffs,"for gf2vectors",IsFamXYFamZ,[IsGF2VectorRep and IsRowVector,IsInt,IsPosInt,IsGF2VectorRep and IsRowVector,IsInt],0,COM_FUN(54));
InstallMethod(DomainForAction,"FFE vector/matrix",IsElmsCollCollsX,[IsVector and IsFFECollection,IsList,IsFunction],0,COM_FUN(55));
BindGlobal("GF2_AHEAD_OF_8BIT_RANK",10);
InstallMethod(SemiEchelonMat,"shortcut method for GF2 matrices",true,[IsMatrix and IsGF2MatrixRep and IsFFECollColl],0,COM_FUN(56));
InstallMethod(SemiEchelonMatTransformation,"kernel method for plain lists of GF2 vectors",true,[IsMatrix and IsFFECollColl and IsGF2MatrixRep],0,COM_FUN(57));
InstallMethod(SemiEchelonMatDestructive,"kernel method for plain lists of GF2 vectors",true,[IsPlistRep and IsMatrix and IsMutable and IsFFECollColl],GF2_AHEAD_OF_8BIT_RANK,SEMIECHELON_LIST_GF2VECS);
InstallMethod(SemiEchelonMatTransformationDestructive,"kernel method for plain lists of GF2 vectors",true,[IsMatrix and IsPlistRep and IsFFECollColl and IsMutable],GF2_AHEAD_OF_8BIT_RANK,SEMIECHELON_LIST_GF2VECS_TRANSFORMATIONS);
InstallMethod(TriangulizeMat,"kernel method for plain list of GF2 vectors",true,[IsMatrix and IsPlistRep and IsFFECollColl and IsMutable],GF2_AHEAD_OF_8BIT_RANK,TRIANGULIZE_LIST_GF2VECS);
InstallMethod(TriangulizeMat,"for GF2 matrices",true,[IsMatrix and IsMutable and IsFFECollColl and IsGF2MatrixRep],0,COM_FUN(58));
InstallMethod(DeterminantMatDestructive,"kernel method for plain list of GF2 vectors",true,[IsMatrix and IsPlistRep and IsFFECollColl and IsMutable],GF2_AHEAD_OF_8BIT_RANK,DETERMINANT_LIST_GF2VECS);
InstallMethod(RankMatDestructive,"kernel method for plain list of GF2 vectors",true,[IsMatrix and IsPlistRep and IsFFECollColl and IsMutable],GF2_AHEAD_OF_8BIT_RANK,RANK_LIST_GF2VECS);
InstallMethod(NestingDepthM,[IsGF2MatrixRep],COM_FUN(59));
InstallMethod(NestingDepthA,[IsGF2MatrixRep],COM_FUN(60));
InstallMethod(NestingDepthM,[IsGF2VectorRep],COM_FUN(61));
InstallMethod(NestingDepthA,[IsGF2VectorRep],COM_FUN(62));
InstallMethod(PostMakeImmutable,[IsGF2MatrixRep],COM_FUN(63));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/vecmat.gi"

#F  file="lib/vec8bit.gi" crc=-88233078
RANK_FILTER_LIST  := [ 15212470, 15, 15212470, 15, 52247917, 19, 15212471, 
  17, 52247917, 19, 1, 0, 15212471, 17, 52247917, 19, 57540459, 15, 57540459, 
  15, 57540459, 15, 13173338, 23, 13173338, 23, 18547110, 20, 13173338, 23, 
  13173338, 23, 18547110, 20, 57540459, 15, 15212470, 15, 52247917, 19, 
  13172873, 39, 15212470, 15, 16793601, 15, 15212470, 15, 33, 37, 13173338, 
  23, 319, 16, 51136371, 31, 8081033, 40, 257, 15, 14173962, 28, 319, 16, 
  13173338, 23, 257, 15, 14173962, 28, 13173338, 23, 13173338, 23, 18547110, 
  20, 13173338, 23, 13173338, 23, 18547110, 20, 13173338, 23, 13173338, 23, 
  13173338, 23, 13173338, 23, 13173338, 23, 13173338, 23, 13173338, 23, 
  13173338, 23, 13173338, 23, 10831130, 30, 10831130, 30, 18547110, 20, 
  13173338, 23, 13173338, 23, 18547110, 20, 13173338, 23, 13173338, 23, 319, 
  16, 52247917, 19, 52247917, 19, 13173338, 23, 13173338, 23, 319, 16, 
  13173338, 23, 13173338, 23, 13173338, 23, 319, 16, 13173338, 23, 8005674, 
  17, 13173338, 23, 8005674, 17, 8005434, 20, 13173338, 23, 15212471, 17, 
  15212470, 15, 13172873, 39, 52247917, 19, 25258651, 278, 13172873, 39, 
  13173338, 23, 13173338, 23, 13173338, 23, 13173338, 23, 257, 15, 13173338, 
  23, 18547110, 20, 257, 15, 18547110, 20, 13173338, 23, 257, 15, 13173338, 
  23, 13173338, 23, 13173338, 23, 18547110, 20, 18547110, 20, 13173338, 23, 
  13173339, 25, 52247917, 19, 13173339, 25, 52247917, 19, 8005674, 17, 
  13173339, 25, 13173339, 25, 13173339, 25, 8005674, 17, 13173338, 23, 17, 
  18, 13173338, 23, 17, 18, 13173338, 23, 13173338, 23, 13173339, 25, 17, 18, 
  13173338, 23, 17, 18, 13173339, 25, 13173338, 23, 13173338, 23, 17, 18, 
  52247917, 19, 13173338, 23, 17, 18 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/vec8bit.gi", -88233078 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/vec8bit.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/vec8bit.gi");
elif COM_RESULT = 3  then
Revision.vec8bit_gi:="@(#)$Id: vec8bit.gi,v 4.46.2.1 2005/05/03 21:18:37 sal Exp $";
InstallValue(TYPES_VEC8BIT,[[],[],[],[]]);
TYPES_VEC8BIT[1][257]:=1;
TYPES_VEC8BIT[2][257]:=1;
TYPES_VEC8BIT[3][257]:=1;
TYPES_VEC8BIT[4][257]:=1;
InstallGlobalFunction(TYPE_VEC8BIT,COM_FUN(1));
InstallGlobalFunction(TYPE_VEC8BIT_LOCKED,COM_FUN(2));
InstallValue(TYPE_FIELDINFO_8BIT,NewType(NewFamily("FieldInfo8BitFamily",IsObject),IsObject and IsDataObjectRep));
InstallMethod(Length,"For a compressed VecFFE",true,[IsList and Is8BitVectorRep],0,LEN_VEC8BIT);
InstallMethod(\[\],"For a compressed VecFFE",true,[IsList and Is8BitVectorRep,IsPosInt],0,ELM_VEC8BIT);
InstallMethod(\[\]\:\=,"For a compressed VecFFE",true,[IsMutable and IsList and Is8BitVectorRep,IsPosInt,IsObject],0,ASS_VEC8BIT);
InstallMethod(Unbind\[\],"For a compressed VecFFE",true,[IsMutable and IsList and Is8BitVectorRep,IsPosInt],0,UNB_VEC8BIT);
InstallMethod(ViewObj,"For a compressed VecFFE",true,[Is8BitVectorRep and IsSmallList],0,COM_FUN(3));
InstallMethod(PrintObj,"For a compressed VecFFE",true,[Is8BitVectorRep and IsSmallList],0,COM_FUN(4));
InstallMethod(ShallowCopy,"For a compressed VecFFE",true,[Is8BitVectorRep and IsSmallList],0,SHALLOWCOPY_VEC8BIT);
InstallMethod(\+,"For two 8 bit vectors in same characteristic",IsIdenticalObj,[IsRowVector and Is8BitVectorRep,IsRowVector and Is8BitVectorRep],0,SUM_VEC8BIT_VEC8BIT);
InstallMethod(\+,"For a GF2 vector and an 8 bit vector of char 2",IsIdenticalObj,[IsRowVector and IsGF2VectorRep,IsRowVector and Is8BitVectorRep],0,COM_FUN(5));
InstallMethod(\+,"For an 8 bit vector of char 2 and a GF2 vector",IsIdenticalObj,[IsRowVector and Is8BitVectorRep,IsRowVector and IsGF2VectorRep],0,COM_FUN(6));
InstallMethod(PlainListCopyOp,"For an 8 bit vector",true,[IsSmallList and Is8BitVectorRep],0,COM_FUN(7));
InstallMethod(ELM0_LIST,"For an 8 bit vector",true,[IsList and Is8BitVectorRep,IsPosInt],0,ELM0_VEC8BIT);
BindGlobal("Q_TO_DEGREE",[0,1,1,2,1,0,1,3,2,0,1,0,1,0,0,4,1,0,1,0,0,0,1,0,2,0,3,0,1,0,1,5,0,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,2,0,0,0,1,0,0,0,0,0,1,0,1,0,0,6,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,0,4,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,2,0,0,0,3,0,1,7,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,2,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,5,0,0,0,0,0,0,0,1,0,0,0,0,8]);
InstallOtherMethod(DegreeFFE,"for 8 bit vectors",true,[IsRowVector and IsFFECollection and Is8BitVectorRep],0,COM_FUN(8));
InstallMethod(ELMS_LIST,"For an 8 bit vector and a plain list",true,[IsList and Is8BitVectorRep,IsPlistRep and IsDenseList],0,ELMS_VEC8BIT);
InstallMethod(ELMS_LIST,"For an 8 bit vector and a range",true,[IsList and Is8BitVectorRep,IsRange and IsInternalRep],0,ELMS_VEC8BIT_RANGE);
InstallMethod(\*,"For an 8 bit vector and an FFE",IsCollsElms,[IsRowVector and Is8BitVectorRep,IsFFE and IsInternalRep],0,PROD_VEC8BIT_FFE);
InstallMethod(\*,"For an 8 bit vector and a compatible matrix",IsElmsColls,[IsRowVector and Is8BitVectorRep and IsSmallList and IsRingElementList,IsRingElementTable and IsPlistRep],0,PROD_VEC8BIT_MATRIX);
InstallMethod(\*,"for FFE and GF2 vector",IsElmsColls,[IsFFE,IsRingElementList and IsRowVector and IsGF2VectorRep],0,COM_FUN(9));
InstallMethod(\*,"For an FFE and an 8 bit vector ",IsElmsColls,[IsFFE and IsInternalRep,IsRowVector and Is8BitVectorRep],0,PROD_FFE_VEC8BIT);
InstallMethod(\*,"for FFE and GF2 vector",IsElmsColls,[IsFFE,IsRingElementList and IsRowVector and IsGF2VectorRep],0,COM_FUN(10));
InstallMethod(\-,"For two 8bit vectors",IsIdenticalObj,[IsRowVector and Is8BitVectorRep,IsRowVector and Is8BitVectorRep],0,DIFF_VEC8BIT_VEC8BIT);
InstallMethod(\-,"For a GF2 vector and an 8 bit vector of char 2",IsIdenticalObj,[IsRowVector and IsGF2VectorRep,IsRowVector and Is8BitVectorRep],0,COM_FUN(11));
InstallMethod(\-,"For an 8 bit vector of char 2 and a GF2 vector",IsIdenticalObj,[IsRowVector and Is8BitVectorRep,IsRowVector and IsGF2VectorRep],0,COM_FUN(12));
InstallMethod(AdditiveInverseOp,"For an 8 bit vector",true,[IsRowVector and Is8BitVectorRep],0,AINV_VEC8BIT_MUTABLE);
InstallMethod(AdditiveInverseSameMutability,"For an 8 bit vector",true,[IsRowVector and Is8BitVectorRep],0,AINV_VEC8BIT_SAME_MUTABILITY);
InstallMethod(AdditiveInverseImmutable,"For an 8 bit vector",true,[IsRowVector and Is8BitVectorRep],0,AINV_VEC8BIT_IMMUTABLE);
InstallMethod(ZeroOp,"For an 8 bit vector",true,[IsRowVector and Is8BitVectorRep],0,ZERO_VEC8BIT);
InstallMethod(ZeroSameMutability,"For an 8 bit vector",true,[IsRowVector and Is8BitVectorRep],0,COM_FUN(13));
InstallMethod(\=,"For 2 8 bit vectors",IsIdenticalObj,[IsRowVector and Is8BitVectorRep,IsRowVector and Is8BitVectorRep],0,EQ_VEC8BIT_VEC8BIT);
InstallMethod(\<,"For 2 8 bit vectors",IsIdenticalObj,[IsRowVector and Is8BitVectorRep,IsRowVector and Is8BitVectorRep],0,LT_VEC8BIT_VEC8BIT);
InstallMethod(\*,"For 2 8 bit vectors",IsIdenticalObj,[IsRingElementList and Is8BitVectorRep,IsRingElementList and Is8BitVectorRep],0,PROD_VEC8BIT_VEC8BIT);
InstallMethod(\*,"For a GF2 vector and an 8 bit vector of char 2",IsIdenticalObj,[IsRowVector and IsGF2VectorRep,IsRowVector and Is8BitVectorRep],0,COM_FUN(14));
InstallMethod(\*,"For an 8 bit vector of char 2 and a GF2 vector",IsIdenticalObj,[IsRowVector and Is8BitVectorRep,IsRowVector and IsGF2VectorRep],0,COM_FUN(15));
InstallOtherMethod(AddRowVector,"For 2 8 bit vectors and a field element and f\
rom and to",IsCollsCollsElmsXX,[IsRowVector and Is8BitVectorRep,IsRowVector and Is8BitVectorRep,IsFFE and IsInternalRep,IsPosInt,IsPosInt],0,ADD_ROWVECTOR_VEC8BITS_5);
InstallOtherMethod(AddRowVector,"For 2 8 bit vectors and a field element",IsCollsCollsElms,[IsRowVector and Is8BitVectorRep,IsRowVector and Is8BitVectorRep,IsFFE and IsInternalRep],0,ADD_ROWVECTOR_VEC8BITS_3);
InstallOtherMethod(AddRowVector,"For 2 8 bit vectors",IsIdenticalObj,[IsRowVector and Is8BitVectorRep,IsRowVector and Is8BitVectorRep],0,ADD_ROWVECTOR_VEC8BITS_2);
InstallOtherMethod(MultRowVector,"For an 8 bit vector and an ffe",IsCollsElms,[IsRowVector and Is8BitVectorRep,IsFFE and IsInternalRep],0,MULT_ROWVECTOR_VEC8BITS);
InstallOtherMethod(PositionNot,"for 8-bit vector and 0*Z(p)",IsCollsElms,[Is8BitVectorRep and IsRowVector,IsFFE and IsZero],0,POSITION_NONZERO_VEC8BIT);
InstallMethod(PositionNot,"for 8-bit vector and 0*Z(p) and 0",IsCollsElmsX,[Is8BitVectorRep and IsRowVector,IsFFE and IsZero,IsZero and IsInt],0,COM_FUN(16));
InstallMethod(PositionNonZero,"for 8-bit vector",true,[Is8BitVectorRep and IsRowVector],0,COM_FUN(17));
InstallMethod(Append,"for 8bitm vectors",IsIdenticalObj,[Is8BitVectorRep and IsMutable and IsList,Is8BitVectorRep and IsList],0,APPEND_VEC8BIT);
InstallMethod(NumberFFVector,"8bit-vector",true,[Is8BitVectorRep and IsRowVector and IsFFECollection,IsPosInt],0,COM_FUN(18));
InstallMethod(IsSubset,"field, 8bit-vector",IsIdenticalObj,[IsField and IsFinite and IsFFECollection,Is8BitVectorRep and IsRowVector and IsFFECollection],0,COM_FUN(19));
InstallMethod(DistanceVecFFE,"8bit-vector",true,[Is8BitVectorRep and IsRowVector,Is8BitVectorRep and IsRowVector],0,DISTANCE_VEC8BIT_VEC8BIT);
InstallOtherMethod(AddCoeffs,"two 8 bit vectors",IsCollsCollsElms,[Is8BitVectorRep and IsRowVector,Is8BitVectorRep and IsRowVector,IsFFE],0,ADD_COEFFS_VEC8BIT_3);
InstallOtherMethod(AddCoeffs,"8 bit vector and GF2 vector",IsCollsCollsElms,[Is8BitVectorRep and IsRowVector,IsGF2VectorRep and IsRowVector,IsFFE],0,COM_FUN(20));
InstallOtherMethod(AddCoeffs,"GF2 vector and 8 bit vector",IsCollsCollsElms,[IsGF2VectorRep and IsRowVector,Is8BitVectorRep and IsRowVector,IsFFE],0,COM_FUN(21));
InstallOtherMethod(AddCoeffs,"two 8 bit vectors",IsIdenticalObj,[Is8BitVectorRep and IsRowVector,Is8BitVectorRep and IsRowVector],0,ADD_COEFFS_VEC8BIT_2);
InstallOtherMethod(AddCoeffs,"8 bit vector and GF2 vector",IsIdenticalObj,[Is8BitVectorRep and IsRowVector,IsGF2VectorRep and IsRowVector],0,COM_FUN(22));
InstallOtherMethod(AddCoeffs,"GF2 vector and 8 bit vector",IsIdenticalObj,[IsGF2VectorRep and IsRowVector,Is8BitVectorRep and IsRowVector],0,COM_FUN(23));
InstallMethod(LeftShiftRowVector,"8bit vector",true,[IsMutable and IsRowVector and Is8BitVectorRep,IsPosInt],0,SHIFT_VEC8BIT_LEFT);
InstallMethod(RightShiftRowVector,"8bit vector, fill with zeros",IsCollsXElms,[IsMutable and IsRowVector and Is8BitVectorRep,IsPosInt,IsFFE and IsZero],0,SHIFT_VEC8BIT_RIGHT);
InstallMethod(ShrinkCoeffs,"8 bit vector",true,[IsMutable and IsRowVector and Is8BitVectorRep],0,COM_FUN(24));
InstallMethod(ShrinkRowVector,"8 bit vector",true,[IsMutable and IsRowVector and Is8BitVectorRep],0,COM_FUN(25));
InstallMethod(RemoveOuterCoeffs,"vec8bit and zero",IsCollsElms,[IsMutable and Is8BitVectorRep and IsRowVector,IsFFE and IsZero],0,COM_FUN(26));
InstallMethod(ProductCoeffs,"8 bit vectors, kernel method",IsFamXFamY,[Is8BitVectorRep and IsRowVector,IsInt,Is8BitVectorRep and IsRowVector,IsInt],0,PROD_COEFFS_VEC8BIT);
InstallOtherMethod(ProductCoeffs,"8 bit vectors, kernel method (2 arg)",IsIdenticalObj,[Is8BitVectorRep and IsRowVector,Is8BitVectorRep and IsRowVector],0,COM_FUN(27));
BindGlobal("ADJUST_FIELDS_VEC8BIT",COM_FUN(28));
InstallMethod(ReduceCoeffs,"8 bit vectors, kernel method",IsFamXFamY,[Is8BitVectorRep and IsRowVector and IsMutable,IsInt,Is8BitVectorRep and IsRowVector,IsInt],0,COM_FUN(29));
InstallOtherMethod(ReduceCoeffs,"8 bit vectors, kernel method (2 arg)",IsIdenticalObj,[Is8BitVectorRep and IsRowVector and IsMutable,Is8BitVectorRep and IsRowVector],0,COM_FUN(30));
IsFamXYFamZ:=COM_FUN(31);
InstallMethod(PowerModCoeffs,"for 8 bit vectors",IsFamXYFamZ,[Is8BitVectorRep and IsRowVector,IsInt,IsPosInt,Is8BitVectorRep and IsRowVector,IsInt],0,COM_FUN(32));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/vec8bit.gi"

#F  file="lib/mat8bit.gi" crc=5646043
RANK_FILTER_LIST  := [ 30416747, 15, 30416747, 15, 52247917, 19, 30416748, 
  17, 52247917, 19, 1, 0, 30416748, 17, 52247917, 19, 5635857, 15, 5635857, 
  15, 5635857, 15, 30416747, 15, 1, 0, 21712371, 39, 21712371, 39, 21712371, 
  39, 21712371, 39, 5635857, 15, 30416747, 15, 52247917, 19, 8800190, 31, 
  21712371, 39, 21712371, 39, 8800190, 31, 21712371, 39, 21712371, 39, 257, 
  15, 21712371, 39, 21712371, 39, 257, 15, 27564821, 39, 27564821, 39, 
  27564821, 39, 27564821, 39, 27564821, 39, 27564821, 39, 9790245, 51, 
  9790245, 51, 9790245, 51, 9790245, 51, 9790245, 51, 62036794, 49, 62036794, 
  49, 62036794, 49, 62036794, 49, 62036794, 49, 62036794, 49, 62036794, 49, 
  62036794, 49, 62036794, 49, 48405457, 53, 48405457, 53, 48405457, 53, 
  62036795, 51, 48405457, 53, 48405457, 53, 30408555, 2, 30408555, 2, 
  15204278, 2, 15204278, 2, 30408555, 2 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/mat8bit.gi", 5646043 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/mat8bit.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/mat8bit.gi");
elif COM_RESULT = 3  then
Revision.mat8bit_gi:="@(#)$Id: mat8bit.gi,v 4.33 2002/07/02 09:52:23 sal Exp $";
InstallValue(TYPES_MAT8BIT,[[],[]]);
TYPES_MAT8BIT[1][257]:=1;
TYPES_MAT8BIT[2][257]:=1;
InstallGlobalFunction(TYPE_MAT8BIT,COM_FUN(1));
InstallMethod(Length,"For a compressed MatFFE",true,[IsList and Is8BitMatrixRep],0,COM_FUN(2));
InstallMethod(\[\],"For a compressed MatFFE",true,[IsList and Is8BitMatrixRep,IsPosInt],0,COM_FUN(3));
InstallMethod(\[\]\:\=,"For a compressed MatFE",true,[IsMutable and IsList and Is8BitMatrixRep,IsPosInt,IsObject],0,ASS_MAT8BIT);
InstallMethod(Unbind\[\],"For a compressed MatFFE",true,[IsMutable and IsList and Is8BitMatrixRep,IsPosInt],0,COM_FUN(4));
InstallMethod(ViewObj,"For a compressed MatFFE",true,[Is8BitMatrixRep and IsSmallList],0,COM_FUN(5));
InstallMethod(PrintObj,"For a compressed MatFFE",true,[Is8BitMatrixRep and IsSmallList],0,COM_FUN(6));
InstallMethod(ShallowCopy,"For a compressed MatFFE",true,[Is8BitMatrixRep and IsSmallList],0,COM_FUN(7));
InstallMethod(PositionCanonical,"for 8bit matrices lists, fall back on `Position'",true,[IsList and Is8BitMatrixRep,IsObject],0,COM_FUN(8));
InstallMethod(\+,"For two 8 bit matrices in same characteristic",IsIdenticalObj,[IsMatrix and Is8BitMatrixRep,IsMatrix and Is8BitMatrixRep],0,SUM_MAT8BIT_MAT8BIT);
InstallMethod(\-,"For two 8 bit matrices in same characteristic",IsIdenticalObj,[IsMatrix and Is8BitMatrixRep,IsMatrix and Is8BitMatrixRep],0,DIFF_MAT8BIT_MAT8BIT);
InstallMethod(PlainListCopyOp,"For an 8 bit vector",true,[IsSmallList and Is8BitMatrixRep],0,COM_FUN(9));
InstallMethod(ELM0_LIST,"For an 8 bit matrix",true,[IsList and Is8BitMatrixRep,IsPosInt],0,COM_FUN(10));
InstallGlobalFunction(ConvertToMatrixRepNC,COM_FUN(11));
InstallMethod(\*,"8 bit vector * 8 bit matrix",IsElmsColls,[Is8BitVectorRep and IsRowVector and IsRingElementList,Is8BitMatrixRep and IsMatrix],0,PROD_VEC8BIT_MAT8BIT);
InstallMethod(\*,"8 bit matrix * 8 bit vector",IsCollsElms,[Is8BitMatrixRep and IsMatrix,Is8BitVectorRep and IsRowVector and IsRingElementList],0,PROD_MAT8BIT_VEC8BIT);
InstallMethod(\*,"8 bit matrix * 8 bit matrix",IsIdenticalObj,[Is8BitMatrixRep and IsMatrix,Is8BitMatrixRep and IsMatrix],0,PROD_MAT8BIT_MAT8BIT);
InstallMethod(\*,"scalar * 8 bit matrix",IsElmsCollColls,[IsFFE,Is8BitMatrixRep and IsMatrix],0,COM_FUN(12));
InstallMethod(\*,"scalar * 8 bit matrix",IsCollCollsElms,[Is8BitMatrixRep and IsMatrix,IsFFE],0,COM_FUN(13));
InstallMethod(AdditiveInverseMutable,"8 bit matrix",true,[Is8BitMatrixRep and IsMatrix and IsAdditiveElementWithZero and IsSmallList],0,COM_FUN(14));
InstallMethod(AdditiveInverseImmutable,"8 bit matrix",true,[Is8BitMatrixRep and IsMatrix and IsAdditiveElementWithZero and IsSmallList],0,COM_FUN(15));
InstallMethod(AdditiveInverseSameMutability,"8 bit matrix",true,[Is8BitMatrixRep and IsMatrix and IsAdditiveElementWithZero and IsSmallList],0,COM_FUN(16));
InstallMethod(ZeroMutable,"8 bit matrix",true,[Is8BitMatrixRep and IsMatrix and IsAdditiveElementWithZero and IsSmallList],0,COM_FUN(17));
InstallMethod(ZeroImmutable,"8 bit matrix",true,[Is8BitMatrixRep and IsMatrix and IsAdditiveElementWithZero and IsSmallList],0,COM_FUN(18));
InstallMethod(ZeroSameMutability,"8 bit matrix",true,[Is8BitMatrixRep and IsMatrix and IsAdditiveElementWithZero and IsSmallList],0,COM_FUN(19));
InstallMethod(InverseOp,"8 bit matrix",true,[Is8BitMatrixRep and IsMatrix and IsMultiplicativeElementWithInverse and IsOrdinaryMatrix and IsSmallList and IsCommutativeElementCollColl and IsRingElementTable and IsFFECollColl],0,INV_MAT8BIT_MUTABLE);
InstallMethod(InverseSameMutability,"8 bit matrix",true,[Is8BitMatrixRep and IsMatrix and IsMultiplicativeElementWithInverse and IsOrdinaryMatrix and IsSmallList and IsCommutativeElementCollColl and IsRingElementTable and IsFFECollColl],0,INV_MAT8BIT_SAME_MUTABILITY);
InstallMethod(OneSameMutability,"8 bit matrix",true,[Is8BitMatrixRep and IsMatrix and IsMultiplicativeElementWithInverse and IsOrdinaryMatrix and IsSmallList and IsCommutativeElementCollColl and IsRingElementTable and IsFFECollColl],0,COM_FUN(20));
InstallMethod(OneMutable,"8 bit matrix",true,[Is8BitMatrixRep and IsMatrix and IsMultiplicativeElementWithInverse and IsOrdinaryMatrix and IsSmallList and IsCommutativeElementCollColl and IsRingElementTable and IsFFECollColl],0,COM_FUN(21));
InstallMethod(One,"8 bit matrix",true,[Is8BitMatrixRep and IsMatrix and IsMultiplicativeElementWithInverse and IsOrdinaryMatrix and IsSmallList and IsCommutativeElementCollColl and IsRingElementTable and IsFFECollColl],0,COM_FUN(22));
InstallGlobalFunction(RepresentationsOfMatrix,COM_FUN(23));
InstallMethod(DefaultFieldOfMatrix,"method for a compressed matrix over GF(q)",true,[IsMatrix and IsFFECollColl and Is8BitMatrixRep],0,COM_FUN(24));
InstallMethod(\<,"for two compressed 8 bit matrices",IsIdenticalObj,[IsMatrix and IsFFECollColl and Is8BitMatrixRep,IsMatrix and IsFFECollColl an\
d Is8BitMatrixRep],0,LT_MAT8BIT_MAT8BIT);
InstallMethod(\=,"for two compressed 8 bit matrices",IsIdenticalObj,[IsMatrix and IsFFECollColl and Is8BitMatrixRep,IsMatrix and IsFFECollColl an\
d Is8BitMatrixRep],0,EQ_MAT8BIT_MAT8BIT);
InstallMethod(TransposedMat,"for a compressed 8 bit matrix",true,[IsMatrix and IsFFECollColl and Is8BitMatrixRep],0,TRANSPOSED_MAT8BIT);
InstallMethod(MutableTransposedMat,"for a compressed 8 bit matrix",true,[IsMatrix and IsFFECollColl and Is8BitMatrixRep],0,TRANSPOSED_MAT8BIT);
InstallMethod(SemiEchelonMat,"shortcut method for 8bit matrices",true,[IsMatrix and Is8BitMatrixRep and IsFFECollColl],0,COM_FUN(25));
InstallMethod(SemiEchelonMatTransformation,"shortcut method for 8bit matrices",true,[IsMatrix and Is8BitMatrixRep and IsFFECollColl],0,COM_FUN(26));
InstallMethod(SemiEchelonMatDestructive,"kernel method for plain lists of 8bit\
 vectors",true,[IsPlistRep and IsMatrix and IsMutable and IsFFECollColl],0,SEMIECHELON_LIST_VEC8BITS);
InstallMethod(SemiEchelonMatTransformationDestructive," kernel method for plain lists of 8 bit vectors",true,[IsMatrix and IsFFECollColl and IsPlistRep and IsMutable],0,SEMIECHELON_LIST_VEC8BITS_TRANSFORMATIONS);
InstallMethod(TriangulizeMat,"kernel method for plain list of GF2 vectors",true,[IsMatrix and IsPlistRep and IsFFECollColl and IsMutable],0,TRIANGULIZE_LIST_VEC8BITS);
InstallMethod(TriangulizeMat,"method for compressed matrices",true,[IsMutable and IsMatrix and Is8BitMatrixRep and IsFFECollColl],0,COM_FUN(27));
InstallMethod(DeterminantMatDestructive,"kernel method for plain list of GF2 vectors",true,[IsMatrix and IsPlistRep and IsFFECollColl and IsMutable],0,DETERMINANT_LIST_VEC8BITS);
InstallMethod(RankMatDestructive,"kernel method for plain list of GF2 vectors",true,[IsMatrix and IsPlistRep and IsFFECollColl and IsMutable],0,RANK_LIST_VEC8BITS);
InstallMethod(NestingDepthM,[Is8BitMatrixRep],COM_FUN(28));
InstallMethod(NestingDepthA,[Is8BitMatrixRep],COM_FUN(29));
InstallMethod(NestingDepthM,[Is8BitVectorRep],COM_FUN(30));
InstallMethod(NestingDepthA,[Is8BitVectorRep],COM_FUN(31));
InstallMethod(PostMakeImmutable,[Is8BitMatrixRep],COM_FUN(32));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/mat8bit.gi"

#F  file="lib/meataxe.gi" crc=-39066494
RANK_FILTER_LIST  := [  ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/meataxe.gi", -39066494 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/meataxe.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/meataxe.gi");
elif COM_RESULT = 3  then
Revision.meataxe_gi:="@(#)$Id: meataxe.gi,v 4.64.2.4 2004/02/05 22:08:29 gap Exp $";
InstallGlobalFunction(GModuleByMats,COM_FUN(1));
InstallGlobalFunction(TrivialGModule,COM_FUN(2));
InstallGlobalFunction(InducedGModule,COM_FUN(3));
InstallGlobalFunction(PermutationGModule,COM_FUN(4));
InstallGlobalFunction(TensorProductGModule,COM_FUN(5));
InstallGlobalFunction(WedgeGModule,COM_FUN(6));
SMTX.Setter:=COM_FUN(7);
SMTX.IsMTXModule:=COM_FUN(8);
SMTX.IsZeroGens:=COM_FUN(9);
SMTX.Dimension:=COM_FUN(10);
SMTX.Field:=COM_FUN(11);
SMTX.Generators:=COM_FUN(12);
SMTX.SetIsIrreducible:=COM_FUN(13);
SMTX.HasIsIrreducible:=COM_FUN(14);
SMTX.IsAbsolutelyIrreducible:=COM_FUN(15);
SMTX.SetIsAbsolutelyIrreducible:=COM_FUN(16);
SMTX.HasIsAbsolutelyIrreducible:=COM_FUN(17);
SMTX.SetSmashRecord:=SMTX.Setter("dummy");
SMTX.Subbasis:=SMTX.Getter("subbasis");
SMTX.SetSubbasis:=SMTX.Setter("subbasis");
SMTX.AlgEl:=SMTX.Getter("algebraElement");
SMTX.SetAlgEl:=SMTX.Setter("algebraElement");
SMTX.AlgElMat:=SMTX.Getter("algebraElementMatrix");
SMTX.SetAlgElMat:=SMTX.Setter("algebraElementMatrix");
SMTX.AlgElCharPol:=SMTX.Getter("characteristicPolynomial");
SMTX.SetAlgElCharPol:=SMTX.Setter("characteristicPolynomial");
SMTX.AlgElCharPolFac:=SMTX.Getter("charpolFactors");
SMTX.SetAlgElCharPolFac:=SMTX.Setter("charpolFactors");
SMTX.AlgElNullspaceVec:=SMTX.Getter("nullspaceVector");
SMTX.SetAlgElNullspaceVec:=SMTX.Setter("nullspaceVector");
SMTX.AlgElNullspaceDimension:=SMTX.Getter("ndimFlag");
SMTX.SetAlgElNullspaceDimension:=SMTX.Setter("ndimFlag");
SMTX.CentMat:=SMTX.Getter("centMat");
SMTX.SetCentMat:=SMTX.Setter("centMat");
SMTX.CentMatMinPoly:=SMTX.Getter("centMatMinPoly");
SMTX.SetCentMatMinPoly:=SMTX.Setter("centMatMinPoly");
SMTX.FGCentMat:=SMTX.Getter("fieldGenCentMat");
SMTX.SetFGCentMat:=SMTX.Setter("fieldGenCentMat");
SMTX.FGCentMatMinPoly:=SMTX.Getter("fieldGenCentMatMinPoly");
SMTX.SetFGCentMatMinPoly:=SMTX.Setter("fieldGenCentMatMinPoly");
SMTX.SetDegreeFieldExt:=SMTX.Setter("degreeFieldExt");
LinearCombinationVecs:=COM_FUN(18);
SMTX_OrthogonalVector:=COM_FUN(19);
SMTX.OrthogonalVector:=SMTX_OrthogonalVector;
SubGModLeadPos:=COM_FUN(20);
SMTX_SpinnedBasis:=COM_FUN(21);
SMTX.SpinnedBasis:=SMTX_SpinnedBasis;
SMTX_SubGModule:=COM_FUN(22);
SMTX.SubGModule:=SMTX_SubGModule;
SMTX.SubmoduleGModule:=SMTX_SubGModule;
SMTX_SubQuotActions:=COM_FUN(23);
SMTX.SubQuotActions:=SMTX_SubQuotActions;
SMTX.NormedBasisAndBaseChange:=COM_FUN(24);
SMTX.InducedActionSubmoduleNB:=COM_FUN(25);
SMTX.InducedActionSubmodule:=COM_FUN(26);
SMTX.ProperSubmoduleBasis:=COM_FUN(27);
SMTX.InducedActionFactorModule:=COM_FUN(28);
SMTX.InducedActionFactorModuleWithBasis:=COM_FUN(29);
SMTX.InducedAction:=COM_FUN(30);
SMTX.InducedActionSubMatrixNB:=COM_FUN(31);
SMTX.InducedActionSubMatrix:=COM_FUN(32);
SMTX.InducedActionFactorMatrix:=COM_FUN(33);
SMTX_SMCoRaEl:=COM_FUN(34);
SMTX.SMCoRaEl:=SMTX_SMCoRaEl;
SMTX.RAND_ELM_LIMIT:=500;
SMTX_IrreducibilityTest:=COM_FUN(35);
SMTX.IrreducibilityTest:=SMTX_IrreducibilityTest;
SMTX.IsIrreducible:=COM_FUN(36);
SMTX_RandomIrreducibleSubGModule:=COM_FUN(37);
SMTX.RandomIrreducibleSubGModule:=SMTX_RandomIrreducibleSubGModule;
SMTX_GoodElementGModule:=COM_FUN(38);
SMTX.GoodElementGModule:=SMTX_GoodElementGModule;
SMTX_FrobeniusAction:=COM_FUN(39);
SMTX.FrobeniusAction:=SMTX_FrobeniusAction;
SMTX_CompleteBasis:=COM_FUN(40);
SMTX.CompleteBasis:=SMTX_CompleteBasis;
SMTX_AbsoluteIrreducibilityTest:=COM_FUN(41);
SMTX.AbsoluteIrreducibilityTest:=SMTX_AbsoluteIrreducibilityTest;
SMTX.DegreeFieldExt:=COM_FUN(42);
SMTX.DegreeSplittingField:=COM_FUN(43);
SMTX.FieldGenCentMat:=COM_FUN(44);
SMTX_CollectedFactors:=COM_FUN(45);
SMTX.CollectedFactors:=SMTX_CollectedFactors;
SMTX.CompositionFactors:=COM_FUN(46);
SMTX_Distinguish:=COM_FUN(47);
SMTX.Distinguish:=SMTX_Distinguish;
SMTX_MinimalSubGModule:=COM_FUN(48);
SMTX.MinimalSubGModule:=SMTX_MinimalSubGModule;
SMTX_IsomorphismComp:=COM_FUN(49);
SMTX.IsomorphismComp:=SMTX_IsomorphismComp;
SMTX.Isomorphism:=COM_FUN(50);
SMTX.IsEquivalent:=COM_FUN(51);
SMTX_MatrixSum:=COM_FUN(52);
SMTX.MatrixSum:=SMTX_MatrixSum;
SMTX_Homomorphisms:=COM_FUN(53);
SMTX.Homomorphisms:=SMTX_Homomorphisms;
SMTX_SortHomGModule:=COM_FUN(54);
SMTX.SortHomGModule:=SMTX_SortHomGModule;
SMTX_Homomorphism:=COM_FUN(55);
SMTX.Homomorphism:=SMTX_Homomorphism;
SMTX_MinimalSubGModules:=COM_FUN(56);
SMTX.MinimalSubGModules:=SMTX_MinimalSubGModules;
SMTX_BasesCompositionSeries:=COM_FUN(57);
SMTX.BasesCompositionSeries:=SMTX_BasesCompositionSeries;
SMTX_BasesSubmodules:=COM_FUN(58);
SMTX.BasesSubmodules:=SMTX_BasesSubmodules;
SMTX_BasesMinimalSubmodules:=COM_FUN(59);
SMTX.BasesMinimalSubmodules:=SMTX_BasesMinimalSubmodules;
SMTX.DualModule:=COM_FUN(60);
InstallGlobalFunction(DualGModule,COM_FUN(61));
SMTX.DualizedBasis:=COM_FUN(62);
SMTX_BasesMaximalSubmodules:=COM_FUN(63);
SMTX.BasesMaximalSubmodules:=SMTX_BasesMaximalSubmodules;
SMTX_BasesMinimalSupermodules:=COM_FUN(64);
SMTX.BasesMinimalSupermodules:=SMTX_BasesMinimalSupermodules;
SMTX_BasisRadical:=COM_FUN(65);
SMTX.BasisRadical:=SMTX_BasisRadical;
SMTX_SpanOfMinimalSubGModules:=COM_FUN(66);
SMTX.SpanOfMinimalSubGModules:=SMTX_SpanOfMinimalSubGModules;
SMTX_BasisSocle:=COM_FUN(67);
SMTX.BasisSocle:=SMTX_BasisSocle;
SMTX_BasisRadical:=COM_FUN(68);
SMTX.BasisRadical:=SMTX_BasisRadical;
SMTX.funcs:=[SMTX_OrthogonalVector,SMTX_SpinnedBasis,SMTX_SubQuotActions,SMTX_SMCoRaEl,SMTX_IrreducibilityTest,SMTX_RandomIrreducibleSubGModule,SMTX_GoodElementGModule,SMTX_FrobeniusAction,SMTX_CompleteBasis,SMTX_AbsoluteIrreducibilityTest,SMTX_CollectedFactors,SMTX_Distinguish,SMTX_MinimalSubGModule,SMTX_IsomorphismComp,SMTX_MatrixSum,SMTX_Homomorphisms,SMTX_SortHomGModule,SMTX_MinimalSubGModules,SMTX_BasesCompositionSeries,SMTX_BasesSubmodules,SMTX_BasesMinimalSubmodules,SMTX_BasesMaximalSubmodules,SMTX_BasesMinimalSupermodules,SMTX_BasisSocle,SMTX_BasisRadical];
SMTX.SetBasisInOrbit:=COM_FUN(69);
SMTX_BasisInOrbit:=COM_FUN(70);
SMTX.BasisInOrbit:=SMTX_BasisInOrbit;
SMTX.SetInvariantBilinearForm:=COM_FUN(71);
SMTX_InvariantBilinearForm:=COM_FUN(72);
SMTX.InvariantBilinearForm:=SMTX_InvariantBilinearForm;
SMTX.MatrixUnderFieldAuto:=COM_FUN(73);
SMTX.TwistedDualModule:=COM_FUN(74);
SMTX.SetInvariantSesquilinearForm:=COM_FUN(75);
SMTX_InvariantSesquilinearForm:=COM_FUN(76);
SMTX.InvariantSesquilinearForm:=SMTX_InvariantSesquilinearForm;
SMTX.SetInvariantQuadraticForm:=COM_FUN(77);
SMTX_InvariantQuadraticForm:=COM_FUN(78);
SMTX.InvariantQuadraticForm:=SMTX_InvariantQuadraticForm;
SMTX.SetOrthogonalSign:=COM_FUN(79);
SMTX_OrthogonalSign:=COM_FUN(80);
SMTX.OrthogonalSign:=SMTX_OrthogonalSign;
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/meataxe.gi"

#F  file="lib/word.gi" crc=92396111
RANK_FILTER_LIST  := [ 51445991, 4, 51445991, 4, 51445991, 4, 51445991, 4, 
  55904514, 5, 55904514, 5, 55904514, 5, 55904514, 5, 39480865, 9, 8193, 2, 
  51445991, 4, 41942876, 3, 8193, 2, 55904514, 5, 55904514, 5, 48422789, 2, 
  17, 18, 48422789, 2, 8193, 2, 2111619, 7, 18243806, 6 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/word.gi", 92396111 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/word.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/word.gi");
elif COM_RESULT = 3  then
Revision.word_gi:="@(#)$Id: word.gi,v 4.30 2002/04/15 10:05:29 sal Exp $";
InstallMethod(\=,"for two words",IsIdenticalObj,[IsWord,IsWord],0,COM_FUN(1));
InstallMethod(\<,"nonassoc words",IsIdenticalObj,[IsWord,IsWord],0,COM_FUN(2));
InstallMethod(\*,"for two nonassoc. words",IsIdenticalObj,[IsNonassocWord,IsNonassocWord],0,COM_FUN(3));
InstallOtherMethod(Length,"for a nonassoc. word",true,[IsNonassocWord],0,COM_FUN(4));
InstallMethod(MappedWord,"for a nonassoc. word, a homogeneous list, and a list",IsElmsCollsX,[IsNonassocWord,IsNonassocWordCollection,IsList],0,COM_FUN(5));
InstallOtherMethod(MappedWord,"empty generators list",true,[IsWord,IsEmpty,IsList],0,COM_FUN(6));
DeclareRepresentation("IsBracketRep",IsPositionalObjectRep,[]);
InstallMethod(PrintObj,"for a nonassociative word",true,[IsNonassocWord],0,COM_FUN(7));
InstallMethod(String,"for a nonassociative word",true,[IsNonassocWord],0,COM_FUN(8));
InstallMethod(ObjByExtRep,"for a family of nonassociative words, and an integer",true,[IsNonassocWordFamily,IsInt],0,COM_FUN(9));
InstallMethod(ObjByExtRep,"for a family of nonassociative words, and a list",true,[IsNonassocWordFamily,IsList],0,COM_FUN(10));
InstallMethod(ExtRepOfObj,"for a nonassoc. word",true,[IsNonassocWord and IsBracketRep],0,COM_FUN(11));
InstallMethod(OneOp,"for a nonassoc. word-with-one",true,[IsNonassocWordWithOne],0,COM_FUN(12));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/word.gi"

#F  file="lib/wordass.gi" crc=264270
RANK_FILTER_LIST  := [ 47284410, 5, 47284410, 5, 46268257, 6, 46268257, 6, 
  47284410, 5, 47284410, 5, 46268257, 6, 52247917, 19, 44927197, 8, 17, 18, 
  44927197, 8, 46268257, 6, 46268257, 6, 52247917, 19, 17, 18, 47284410, 5, 
  52247917, 19, 17, 18, 47284410, 5, 47284410, 5, 46268257, 6, 47284410, 5, 
  52247917, 19, 47284410, 5, 52247917, 19, 52247917, 19, 47284410, 5, 
  47284410, 5, 47284410, 5, 52247917, 19, 47284410, 5, 47284410, 5, 47284410, 
  5, 47284410, 5, 46268257, 6, 8193, 2, 46268257, 6, 59473395, 10, 8193, 2 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/wordass.gi", 264270 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/wordass.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/wordass.gi");
elif COM_RESULT = 3  then
Revision.wordass_gi:="@(#)$Id: wordass.gi,v 4.31 2002/04/15 10:05:30 sal Exp $";
InstallGlobalFunction("AssignGeneratorVariables",COM_FUN(1));
InstallGlobalFunction(ERepAssWorProd,COM_FUN(2));
InstallGlobalFunction(ERepAssWorInv,COM_FUN(3));
InstallMethod(\<,"assoc words",IsIdenticalObj,[IsAssocWord,IsAssocWord],0,COM_FUN(4));
BindGlobal("AssocWord_Product",COM_FUN(5));
InstallMethod(\*,"for two assoc. words in syllable rep",IsIdenticalObj,[IsAssocWord and IsSyllableAssocWordRep,IsAssocWord and IsSyllableAssocWordRep],0,AssocWord_Product);
InstallMethod(\*,"for two assoc. words: force syllable rep",IsIdenticalObj,[IsAssocWord,IsAssocWord],0,COM_FUN(6));
InstallMethod(\^,"for an assoc. word in syllable rep, and a positive integer",true,[IsAssocWord and IsSyllableAssocWordRep,IsPosInt],0,COM_FUN(7));
BindGlobal("AssocWordWithInverse_Power",COM_FUN(8));
InstallMethod(\^,"for an assoc. word with inverse in syllable rep, and an integer",true,[IsAssocWordWithInverse and IsSyllableAssocWordRep,IsInt],0,AssocWordWithInverse_Power);
BindGlobal("AssocWordWithInverse_Inverse",COM_FUN(9));
InstallMethod(InverseOp,"for an assoc. word with inverse in syllable rep",true,[IsAssocWordWithInverse and IsSyllableAssocWordRep],0,AssocWordWithInverse_Inverse);
InstallOtherMethod(ReversedOp,"for an assoc. word in syllable rep",true,[IsAssocWord and IsSyllableAssocWordRep],0,COM_FUN(10));
InstallOtherMethod(Subword,"for syllable associative word and two positions",true,[IsAssocWord and IsSyllableAssocWordRep,IsPosInt,IsInt],0,COM_FUN(11));
InstallMethod(SubSyllables,"for associative word and two positions, using ext rep.",true,[IsAssocWord,IsPosInt,IsInt],0,COM_FUN(12));
InstallOtherMethod(PositionWord,"for two associative words,start at 1",IsIdenticalObj,[IsAssocWord,IsAssocWord],0,COM_FUN(13));
InstallMethod(PositionWord,"for two associative words and a positive integer, using syllables",IsFamFamX,[IsAssocWord and IsSyllableAssocWordRep,IsAssocWord,IsPosInt],0,COM_FUN(14));
InstallMethod(SubstitutedWord,"for assoc. word, two positive integers, and assoc. word",true,[IsAssocWord,IsPosInt,IsPosInt,IsAssocWord],0,COM_FUN(15));
InstallOtherMethod(SubstitutedWord,"for three associate words",true,[IsAssocWord,IsAssocWord,IsPosInt,IsAssocWord],0,COM_FUN(16));
InstallMethod(EliminatedWord,"for three associative words, using the external rep.",IsFamFamFam,[IsAssocWord,IsAssocWord,IsAssocWord],0,COM_FUN(17));
InstallMethod(RenumberedWord,"associative words in syllable rep",true,[IsAssocWord and IsSyllableAssocWordRep,IsList],0,COM_FUN(18));
BindGlobal("MappedWordSyllableAssocWord",COM_FUN(19));
InstallMethod(MappedWord,"for a syllable assoc. word, a homogeneous list, and a list",IsElmsCollsX,[IsAssocWord and IsSyllableAssocWordRep,IsAssocWordCollection,IsList],MappedWordSyllableAssocWord);
BindGlobal("LengthOfLongestCommonPrefixOfTwoAssocWords",COM_FUN(20));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/wordass.gi"

#F  file="lib/wordrep.gi" crc=-80941172
RANK_FILTER_LIST  := [ 47284410, 5, 47284410, 5, 54227872, 3, 32769, 4, 
  47284410, 5, 46268257, 6, 35321865, 4, 32769, 4, 64617770, 4, 32769, 4, 
  56102621, 4, 32769, 4, 39071363, 4, 32769, 4, 54227872, 3, 53597154, 15, 
  17, 18, 32769, 4, 26631969, 8, 26631969, 8, 26631969, 8, 26631969, 8, 
  26631969, 8, 26631969, 8, 26631969, 8, 57138802, 9, 9854393, 9, 22999690, 
  23, 25290909, 10, 52720704, 21, 26631969, 8, 472804, 21, 26631969, 8, 
  52247917, 19, 26631969, 8, 17, 18, 26631969, 8, 26631969, 8, 26631969, 8, 
  17, 18, 17, 18, 26631969, 8, 53263937, 8, 53263937, 8, 53263937, 8, 
  53263937, 8, 53263937, 8, 53263937, 8, 53263937, 8, 16661891, 9, 36486361, 
  9, 22999690, 23, 51922877, 10, 52720704, 21, 53263937, 8, 472804, 21, 
  53263937, 8, 52247917, 19, 53263937, 8, 17, 18, 53263937, 8, 53263937, 8, 
  53263937, 8, 17, 18, 17, 18, 53263937, 8, 39418994, 8, 39418994, 8, 
  39418994, 8, 39418994, 8, 39418994, 8, 39418994, 8, 39418994, 8, 2816948, 
  9, 22641418, 9, 22999690, 23, 38077934, 10, 52720704, 21, 39418994, 8, 
  472804, 21, 39418994, 8, 52247917, 19, 39418994, 8, 52247917, 19, 39418994, 
  8, 39418994, 8, 39418994, 8, 17, 18, 17, 18, 39418994, 8, 11729108, 8, 
  11729108, 8, 11729108, 8, 11729108, 8, 11729108, 8, 42235941, 9, 11729108, 
  8, 52247917, 19, 11729108, 8, 17, 18, 11729108, 8, 11729108, 8, 11729108, 
  8, 17, 18, 17, 18, 35321865, 4, 17, 18, 17, 18, 32769, 4, 64617770, 4, 17, 
  18, 17, 18, 32769, 4, 56102621, 4, 17, 18, 17, 18, 32769, 4, 39071363, 4, 
  53597154, 15, 17, 18, 32769, 4, 23466407, 4, 23466407, 4, 23466407, 4, 
  52247917, 19, 23466407, 4, 23466407, 4, 1, 0, 7665924, 21, 46924621, 4, 
  46924621, 4, 46924621, 4, 46924621, 4, 52247917, 19, 46924621, 4, 1, 0, 
  7665924, 21, 46924621, 4, 66092727, 6, 8193, 2, 66092727, 6, 48201913, 3, 
  32769, 4, 48201913, 3, 32769, 4, 32769, 4, 46268257, 6, 46268257, 6, 
  52247917, 19, 46268257, 6, 52247917, 19, 46268257, 6, 46268257, 6, 
  47284410, 5, 53660808, 21, 47284410, 5 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/wordrep.gi", -80941172 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/wordrep.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/wordrep.gi");
elif COM_RESULT = 3  then
Revision.wordrep_gi:="@(#)$Id: wordrep.gi,v 4.49 2002/04/15 10:05:30 sal Exp $";
DeclareRepresentation("Is8BitsAssocWord",IsSyllableAssocWordRep and IsDataObjectRep,[]);
DeclareRepresentation("Is16BitsAssocWord",IsSyllableAssocWordRep and IsDataObjectRep,[]);
DeclareRepresentation("Is32BitsAssocWord",IsSyllableAssocWordRep and IsDataObjectRep,[]);
DeclareRepresentation("IsInfBitsAssocWord",IsSyllableAssocWordRep and IsPositionalObjectRep,[]);
BindGlobal("InfBits_AssocWord",COM_FUN(1));
InstallMethod(PrintObj,"for an associative word",true,[IsAssocWord],0,COM_FUN(2));
InstallMethod(String,"for an associative word",true,[IsAssocWord],0,COM_FUN(3));
InstallGlobalFunction(AssocWord,COM_FUN(4));
BindGlobal("SyllableWordObjByExtRep",COM_FUN(5));
InstallMethod(ObjByExtRep,"for a family of associative words, and a homogeneous list",true,[IsAssocWordFamily and IsSyllableWordsFamily,IsHomogeneousList],0,SyllableWordObjByExtRep);
InstallMethod(SyllableRepAssocWord,"assoc word: via extrep",true,[IsAssocWord],0,COM_FUN(6));
InstallMethod(SyllableRepAssocWord,"assoc word in syllable rep",true,[IsAssocWord and IsSyllableAssocWordRep],0,COM_FUN(7));
InstallOtherMethod(ObjByExtRep,"for a 8Bits-family of associative words, and a homogeneous list",true,[IsAssocWordFamily and Is8BitsFamily,IsHomogeneousList],0,COM_FUN(8));
InstallOtherMethod(ObjByExtRep,"for a 16Bits-family of associative words, and a homogeneous list",true,[IsAssocWordFamily and Is16BitsFamily,IsHomogeneousList],0,COM_FUN(9));
InstallOtherMethod(ObjByExtRep,"for a 32Bits-family of associative words, and a homogeneous list",true,[IsAssocWordFamily and Is32BitsFamily,IsHomogeneousList],0,COM_FUN(10));
InstallOtherMethod(ObjByExtRep,"for a InfBits-family of associative words, and a homogeneous list",true,[IsAssocWordFamily and IsInfBitsFamily,IsHomogeneousList],0,COM_FUN(11));
InstallOtherMethod(ObjByExtRep,"for a fam. of assoc. words, a cyclotomic, an int., and a homog. list",true,[IsAssocWordFamily and IsSyllableWordsFamily,IsCyclotomic,IsInt,IsHomogeneousList],0,COM_FUN(12));
InstallMethod(ExtRepOfObj,"for an 8 bits assoc. word",true,[Is8BitsAssocWord],0,8Bits_ExtRepOfObj);
InstallMethod(\=,"for two 8 bits assoc. words",IsIdenticalObj,[Is8BitsAssocWord,Is8BitsAssocWord],0,8Bits_Equal);
InstallMethod(\<,"for two 8 bits assoc. words",IsIdenticalObj,[Is8BitsAssocWord,Is8BitsAssocWord],0,8Bits_Less);
InstallMethod(\*,"for two 8 bits assoc. words",IsIdenticalObj,[Is8BitsAssocWord,Is8BitsAssocWord],0,8Bits_Product);
InstallMethod(OneOp,"for an 8 bits assoc. word-with-one",true,[Is8BitsAssocWord and IsAssocWordWithOne],0,COM_FUN(13));
InstallMethod(\^,"for an 8 bits assoc. word, and zero (in small integer rep)",true,[Is8BitsAssocWord and IsMultiplicativeElementWithOne,IsZeroCyc and IsSmallIntRep],0,8Bits_Power);
InstallMethod(\^,"for an 8 bits assoc. word, and a small negative integer",true,[Is8BitsAssocWord and IsMultiplicativeElementWithInverse,IsInt and IsNegRat and IsSmallIntRep],0,8Bits_Power);
InstallMethod(\^,"for an 8 bits assoc. word, and a small positive integer",true,[Is8BitsAssocWord,IsPosInt and IsSmallIntRep],0,8Bits_Power);
InstallMethod(ExponentSyllable,"for an 8 bits assoc. word, and a pos. integer",true,[Is8BitsAssocWord,IsPosInt],0,8Bits_ExponentSyllable);
InstallMethod(GeneratorSyllable,"for an 8 bits assoc. word, and an integer",true,[Is8BitsAssocWord,IsInt],0,8Bits_GeneratorSyllable);
InstallMethod(NumberSyllables,"for an 8 bits assoc. word",true,[Is8BitsAssocWord],0,8Bits_NumberSyllables);
InstallMethod(ExponentSums,"for an 8 bits assoc. word",true,[Is8BitsAssocWord],0,8Bits_ExponentSums1);
InstallOtherMethod(ExponentSums,"for an 8 bits assoc. word, and two integers",true,[Is8BitsAssocWord,IsInt,IsInt],0,8Bits_ExponentSums3);
InstallOtherMethod(Length,"for an 8 bits assoc. word",true,[Is8BitsAssocWord],0,8Bits_LengthWord);
InstallMethod(ExtRepOfObj,"for a 16 bits assoc. word",true,[Is16BitsAssocWord],0,16Bits_ExtRepOfObj);
InstallMethod(\=,"for two 16 bits assoc. words",IsIdenticalObj,[Is16BitsAssocWord,Is16BitsAssocWord],0,16Bits_Equal);
InstallMethod(\<,"for two 16 bits assoc. words",IsIdenticalObj,[Is16BitsAssocWord,Is16BitsAssocWord],0,16Bits_Less);
InstallMethod(\*,"for two 16 bits assoc. words",IsIdenticalObj,[Is16BitsAssocWord,Is16BitsAssocWord],0,16Bits_Product);
InstallMethod(OneOp,"for a 16 bits assoc. word-with-one",true,[Is16BitsAssocWord and IsAssocWordWithOne],0,COM_FUN(14));
InstallMethod(\^,"for a 16 bits assoc. word, and zero (in small integer rep)",true,[Is16BitsAssocWord and IsMultiplicativeElementWithOne,IsZeroCyc and IsSmallIntRep],0,16Bits_Power);
InstallMethod(\^,"for a 16 bits assoc. word, and a small negative integer",true,[Is16BitsAssocWord and IsMultiplicativeElementWithInverse,IsInt and IsNegRat and IsSmallIntRep],0,16Bits_Power);
InstallMethod(\^,"for a 16 bits assoc. word, and a small positive integer",true,[Is16BitsAssocWord,IsPosInt and IsSmallIntRep],0,16Bits_Power);
InstallMethod(ExponentSyllable,"for a 16 bits assoc. word, and pos. integer",true,[Is16BitsAssocWord,IsPosInt],0,16Bits_ExponentSyllable);
InstallMethod(GeneratorSyllable,"for a 16 bits assoc. word, and integer",true,[Is16BitsAssocWord,IsInt],0,16Bits_GeneratorSyllable);
InstallMethod(NumberSyllables,"for a 16 bits assoc. word",true,[Is16BitsAssocWord],0,16Bits_NumberSyllables);
InstallMethod(ExponentSums,"for a 16 bits assoc. word",true,[Is16BitsAssocWord],0,16Bits_ExponentSums1);
InstallOtherMethod(ExponentSums,"for a 16 bits assoc. word, and two integers",true,[Is16BitsAssocWord,IsInt,IsInt],0,16Bits_ExponentSums3);
InstallOtherMethod(Length,"for a 16 bits assoc. word",true,[Is16BitsAssocWord],0,16Bits_LengthWord);
InstallMethod(ExtRepOfObj,"for a 32 bits assoc. word",true,[Is32BitsAssocWord],0,32Bits_ExtRepOfObj);
InstallMethod(\=,"for two 32 bits assoc. words",IsIdenticalObj,[Is32BitsAssocWord,Is32BitsAssocWord],0,32Bits_Equal);
InstallMethod(\<,"for two 32 bits assoc. words",IsIdenticalObj,[Is32BitsAssocWord,Is32BitsAssocWord],0,32Bits_Less);
InstallMethod(\*,"for two 32 bits assoc. words",IsIdenticalObj,[Is32BitsAssocWord,Is32BitsAssocWord],0,32Bits_Product);
InstallMethod(OneOp,"for a 32 bits assoc. word-with-one",true,[Is32BitsAssocWord and IsAssocWordWithOne],0,COM_FUN(15));
InstallMethod(\^,"for a 32 bits assoc. word, and zero (in small integer rep)",true,[Is32BitsAssocWord and IsMultiplicativeElementWithOne,IsZeroCyc and IsSmallIntRep],0,32Bits_Power);
InstallMethod(\^,"for a 32 bits assoc. word, and a small negative integer",true,[Is32BitsAssocWord and IsMultiplicativeElementWithInverse,IsInt and IsNegRat and IsSmallIntRep],0,32Bits_Power);
InstallMethod(\^,"for a 32 bits assoc. word, and a small positive integer",true,[Is32BitsAssocWord,IsPosInt and IsSmallIntRep],0,32Bits_Power);
InstallMethod(ExponentSyllable,"for a 32 bits assoc. word, and pos. integer",true,[Is32BitsAssocWord,IsPosInt],0,32Bits_ExponentSyllable);
InstallMethod(GeneratorSyllable,"for a 32 bits assoc. word, and pos. integer",true,[Is32BitsAssocWord,IsPosInt],0,32Bits_GeneratorSyllable);
InstallMethod(NumberSyllables,"for a 32 bits assoc. word",true,[Is32BitsAssocWord],0,32Bits_NumberSyllables);
InstallMethod(ExponentSums,"for a 32 bits assoc. word",true,[Is32BitsAssocWord],0,32Bits_ExponentSums1);
InstallOtherMethod(ExponentSums,"for a 32 bits assoc. word",true,[Is32BitsAssocWord,IsInt,IsInt],0,32Bits_ExponentSums3);
InstallOtherMethod(Length,"for a 32 bits assoc. word",true,[Is32BitsAssocWord],0,32Bits_LengthWord);
InfBits_ExtRepOfObj:=COM_FUN(16);
InstallMethod(ExtRepOfObj,"for a inf. bits assoc. word",true,[IsInfBitsAssocWord],0,InfBits_ExtRepOfObj);
InfBits_Equal:=COM_FUN(17);
InstallMethod(\=,"for two inf. bits assoc. words",IsIdenticalObj,[IsInfBitsAssocWord,IsInfBitsAssocWord],0,InfBits_Equal);
InfBits_Less:=COM_FUN(18);
InstallMethod(\<,"for two inf. bits assoc. words",IsIdenticalObj,[IsInfBitsAssocWord,IsInfBitsAssocWord],100,InfBits_Less);
InfBits_One:=COM_FUN(19);
InstallMethod(OneOp,"for an inf. bits assoc. word-with-one",true,[IsInfBitsAssocWord and IsAssocWordWithOne],0,InfBits_One);
InfBits_ExponentSyllable:=COM_FUN(20);
InstallMethod(ExponentSyllable,"for an inf. bits assoc. word, and a pos. integer",true,[IsInfBitsAssocWord,IsPosInt],0,InfBits_ExponentSyllable);
InfBits_GeneratorSyllable:=COM_FUN(21);
InstallMethod(GeneratorSyllable,"for an inf. bits assoc. word, and an integer",true,[IsInfBitsAssocWord,IsInt],0,InfBits_GeneratorSyllable);
InfBits_NumberSyllables:=COM_FUN(22);
InstallMethod(NumberSyllables,"for an inf. bits assoc. word",true,[IsInfBitsAssocWord],0,InfBits_NumberSyllables);
InfBits_ExponentSums1:=COM_FUN(23);
InstallMethod(ExponentSums,"for an inf. bits assoc. word",true,[IsInfBitsAssocWord],0,InfBits_ExponentSums1);
InfBits_ExponentSums3:=COM_FUN(24);
InstallOtherMethod(ExponentSums,"for an inf. bits assoc. word, and two integers",true,[IsInfBitsAssocWord,IsInt,IsInt],1,InfBits_ExponentSums3);
InstallGlobalFunction(ObjByVector,COM_FUN(25));
BindGlobal("InfBits_ObjByVector",COM_FUN(26));
InstallOtherMethod(ObjByExtRep,"for an 8 bits assoc. words family, two integers, and a list",true,[IsAssocWordFamily and Is8BitsFamily,IsInt,IsInt,IsHomogeneousList],0,COM_FUN(27));
InstallOtherMethod(ObjByExtRep,"for a 16 bits assoc. words family, two integers, and a list",true,[IsAssocWordFamily and Is16BitsFamily,IsInt,IsInt,IsHomogeneousList],0,COM_FUN(28));
InstallOtherMethod(ObjByExtRep,"for a 32 bits assoc. words family, two integers, and a list",true,[IsAssocWordFamily and Is32BitsFamily,IsInt,IsInt,IsHomogeneousList],0,COM_FUN(29));
InstallOtherMethod(ObjByExtRep,"for an inf. bits assoc. words family, two integers, and a list",true,[IsAssocWordFamily and IsInfBitsFamily,IsCyclotomic,IsInt,IsHomogeneousList],0,COM_FUN(30));
InstallGlobalFunction(StoreInfoFreeMagma,COM_FUN(31));
DeclareRepresentation("IsInfiniteListOfNamesRep",IsPositionalObjectRep,[1,2]);
InstallMethod(PrintObj,"for an infinite list of names",true,[IsList and IsInfiniteListOfNamesRep],0,COM_FUN(32));
InstallMethod(ViewObj,"for an infinite list of names",true,[IsList and IsInfiniteListOfNamesRep],0,COM_FUN(33));
InstallMethod(\[\],"for an infinite list of names",true,[IsList and IsInfiniteListOfNamesRep,IsPosInt],0,COM_FUN(34));
InstallMethod(Length,"for an infinite list of names",true,[IsList and IsInfiniteListOfNamesRep],0,COM_FUN(35));
InstallMethod(Position,"for an infinite list of names, an object, and zero",true,[IsList and IsInfiniteListOfNamesRep,IsObject,IsZeroCyc],0,COM_FUN(36));
InstallGlobalFunction(InfiniteListOfNames,COM_FUN(37));
DeclareRepresentation("IsInfiniteListOfGeneratorsRep",IsPositionalObjectRep,[1,2]);
InstallMethod(ViewObj,"for an infinite list of generators",true,[IsList and IsInfiniteListOfGeneratorsRep],0,COM_FUN(38));
InstallMethod(PrintObj,"for an infinite list of generators",true,[IsList and IsInfiniteListOfGeneratorsRep],0,COM_FUN(39));
InstallMethod(Length,"for an infinite list of generators",true,[IsList and IsInfiniteListOfGeneratorsRep],0,COM_FUN(40));
InstallMethod(\[\],"for an infinite list of generators",true,[IsList and IsInfiniteListOfGeneratorsRep,IsPosInt],0,COM_FUN(41));
InstallMethod(Position,"for an infinite list of generators, an object, and zero",true,[IsList and IsInfiniteListOfGeneratorsRep,IsObject,IsZeroCyc],0,COM_FUN(42));
InstallMethod(Random,"for an infinite list of generators",true,[IsList and IsInfiniteListOfGeneratorsRep],0,COM_FUN(43));
InstallGlobalFunction(InfiniteListOfGenerators,COM_FUN(44));
InstallOtherMethod(LetterRepAssocWord,"syllable rep, generators",true,[IsSyllableAssocWordRep,IsList],0,COM_FUN(45));
InstallMethod(LetterRepAssocWord,"syllable rep",true,[IsSyllableAssocWordRep],0,COM_FUN(46));
InstallMethod(AssocWordByLetterRep,"family, list: syllables",true,[IsSyllableWordsFamily,IsHomogeneousList],0,COM_FUN(47));
InstallOtherMethod(AssocWordByLetterRep,"family, list, gens: syllables",true,[IsSyllableWordsFamily,IsHomogeneousList,IsHomogeneousList],0,COM_FUN(48));
InstallOtherMethod(Length,"for an assoc. word in syllable rep",true,[IsAssocWord and IsSyllableAssocWordRep],0,COM_FUN(49));
InstallMethod(ExponentSyllable,"for an assoc. word in syllable rep, and a positive integer",true,[IsAssocWord and IsSyllableAssocWordRep,IsPosInt],0,COM_FUN(50));
InstallMethod(GeneratorSyllable,"for an assoc. word in syllable rep, and a positive integer",true,[IsAssocWord and IsSyllableAssocWordRep,IsPosInt],0,COM_FUN(51));
InstallMethod(NumberSyllables,"for an assoc. word in syllable rep",true,[IsAssocWord and IsSyllableAssocWordRep],0,COM_FUN(52));
InstallMethod(ExponentSumWord,"syllable rep as.word, gen",IsIdenticalObj,[IsAssocWord and IsSyllableAssocWordRep,IsAssocWord],0,COM_FUN(53));
InstallOtherMethod(ExponentSums,"for a group and an assoc. word in syllable rep",true,[IsGroup,IsAssocWord],0,COM_FUN(54));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/wordrep.gi"

#F  file="lib/wordlett.gi" crc=10344165
RANK_FILTER_LIST  := [ 2096208, 4, 32769, 4, 34602544, 4, 32769, 4, 50855232, 
  3, 32769, 4, 32769, 4, 58981576, 7, 63045228, 7, 65076574, 6, 32769, 4, 
  56881191, 3, 32769, 4, 56881191, 3, 17, 18, 17, 18, 32769, 4, 45252104, 6, 
  45252104, 6, 39157106, 7, 52247917, 19, 43220758, 7, 52247917, 19, 
  45252104, 6, 52247917, 19, 45252104, 6, 47284410, 5, 45252104, 6, 45252104, 
  6, 17, 18, 17, 18, 45252104, 6, 22379530, 8, 26443182, 8, 37816046, 9, 
  41879698, 9, 45252104, 6, 45252104, 6, 45252104, 6, 45252104, 6, 45252104, 
  6, 45252104, 6, 39157106, 7, 39157106, 7, 43220758, 7, 43220758, 7, 
  39157106, 7, 52247917, 19, 39157106, 7, 37386938, 19, 43220758, 7, 
  52247917, 19, 43220758, 7, 37386938, 19, 45252104, 6, 45252104, 6, 
  52247917, 19, 17, 18, 45252104, 6, 47284410, 5, 52247917, 19, 45252104, 6, 
  8193, 2, 45252104, 6, 59473395, 10, 8193, 2 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/wordlett.gi", 10344165 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/wordlett.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/wordlett.gi");
elif COM_RESULT = 3  then
Revision.wordlett_gi:="@(#)$Id: wordlett.gi,v 4.16 2002/12/18 13:54:24 gap Exp $";
LIB_CHAR_SINT:=COM_FUN(1);
LIB_SINT_CHAR:=COM_FUN(2);
LIB_SINTLIST_STRING:=COM_FUN(3);
LIB_STRING_SINTLIST:=COM_FUN(4);
SINTLIST_STRING:=COM_FUN(5);
InstallMethod(AssocWordByLetterRep,"W letter words family",true,[IsWLetterWordsFamily,IsHomogeneousList],0,COM_FUN(6));
InstallMethod(AssocWordByLetterRep,"B letter words family",true,[IsBLetterWordsFamily,IsHomogeneousList],0,COM_FUN(7));
InstallOtherMethod(AssocWordByLetterRep,"letter words family",true,[IsLetterWordsFamily,IsHomogeneousList,IsHomogeneousList],0,COM_FUN(8));
InstallMethod(LetterRepAssocWord,"W letter rep",true,[IsWLetterAssocWordRep],0,COM_FUN(9));
InstallMethod(LetterRepAssocWord,"B letter rep",true,[IsBLetterAssocWordRep],0,COM_FUN(10));
InstallOtherMethod(LetterRepAssocWord,"letter rep,gens",true,[IsLetterAssocWordRep,IsHomogeneousList],0,COM_FUN(11));
InstallMethod(ObjByExtRep,"letter rep family",true,[IsAssocWordFamily and IsLetterWordsFamily,IsHomogeneousList],0,COM_FUN(12));
InstallOtherMethod(ObjByExtRep,"letter rep family,integers (ignored)",true,[IsAssocWordFamily and IsLetterWordsFamily,IsInt,IsInt,IsHomogeneousList],0,COM_FUN(13));
LETTER_WORD_EREP_CACHE:=[1,1,1];
LETTER_WORD_EREP_CACHEVAL:=[1,1,1];
LETTER_WORD_EREP_CACHEPOS:=1;
BindGlobal("ERepLettWord",COM_FUN(14));
InstallMethod(ExtRepOfObj,"assoc word in letter rep",true,[IsAssocWord and IsLetterAssocWordRep],0,ERepLettWord);
InstallMethod(NumberSyllables,"assoc word in letter rep",true,[IsAssocWord and IsLetterAssocWordRep],0,COM_FUN(15));
InstallMethod(GeneratorSyllable,"assoc word in W letter rep",true,[IsAssocWord and IsWLetterAssocWordRep,IsPosInt],0,COM_FUN(16));
InstallMethod(GeneratorSyllable,"assoc word in B letter rep",true,[IsAssocWord and IsBLetterAssocWordRep,IsPosInt],0,COM_FUN(17));
InstallMethod(ExponentSyllable,"assoc word in letter rep",true,[IsAssocWord and IsLetterAssocWordRep,IsPosInt],0,COM_FUN(18));
InstallMethod(ExponentSumWord,"letter rep as.word, gen",IsIdenticalObj,[IsAssocWord and IsLetterAssocWordRep,IsAssocWord],0,COM_FUN(19));
InstallMethod(ExponentSums,"assoc word in letter rep",true,[IsAssocWord and IsLetterAssocWordRep],0,COM_FUN(20));
InstallOtherMethod(ExponentSums,"assoc word in letter rep,ints",true,[IsAssocWord and IsLetterAssocWordRep,IsInt,IsInt],0,COM_FUN(21));
InstallMethod(Length,"assoc word in letter rep",true,[IsAssocWord and IsLetterAssocWordRep],0,COM_FUN(22));
InstallMethod(OneOp,"assoc word in W letter rep",true,[IsAssocWord and IsWLetterAssocWordRep and IsMultiplicativeElementWithOne],0,COM_FUN(23));
InstallMethod(OneOp,"assoc word in B letter rep",true,[IsAssocWord and IsBLetterAssocWordRep and IsMultiplicativeElementWithOne],0,COM_FUN(24));
InstallMethod(InverseOp,"assoc word in W letter rep",true,[IsAssocWord and IsWLetterAssocWordRep and IsMultiplicativeElementWithInverse],0,COM_FUN(25));
InstallMethod(InverseOp,"assoc word in B letter rep",true,[IsAssocWord and IsBLetterAssocWordRep and IsMultiplicativeElementWithInverse],0,COM_FUN(26));
InstallMethod(PrintObj,"assoc word in letter rep",true,[IsAssocWord and IsLetterAssocWordRep],0,COM_FUN(27));
InstallMethod(LaTeXObj,"assoc word in letter rep",true,[IsAssocWord and IsLetterAssocWordRep],0,COM_FUN(28));
InstallMethod(\=,"assoc words in letter rep",IsIdenticalObj,[IsAssocWord and IsLetterAssocWordRep,IsAssocWord and IsLetterAssocWordRep],0,COM_FUN(29));
InstallMethod(\<,"assoc words in letter rep",IsIdenticalObj,[IsAssocWord and IsLetterAssocWordRep,IsAssocWord and IsLetterAssocWordRep],0,COM_FUN(30));
InstallMethod(\*,"assoc words in W letter rep",IsIdenticalObj,[IsAssocWord and IsWLetterAssocWordRep,IsAssocWord and IsWLetterAssocWordRep],0,COM_FUN(31));
MUL_BYT_LETTREP:=COM_FUN(32);
InstallMethod(\*,"assoc words in B letter rep",IsIdenticalObj,[IsAssocWord and IsBLetterAssocWordRep,IsAssocWord and IsBLetterAssocWordRep],0,COM_FUN(33));
AssocWWorLetRepPow:=COM_FUN(34);
InstallMethod(\^,"assoc word in W letter rep and positive integer",true,[IsAssocWord and IsWLetterAssocWordRep,IsPosInt],0,AssocWWorLetRepPow);
InstallMethod(\^,"assoc word in W letter rep and negative integer",true,[IsAssocWord and IsWLetterAssocWordRep,IsNegRat and IsInt],0,AssocWWorLetRepPow);
AssocBWorLetRepPow:=COM_FUN(35);
InstallMethod(\^,"assoc word in B letter rep and positive integer",true,[IsAssocWord and IsBLetterAssocWordRep,IsPosInt],0,AssocBWorLetRepPow);
InstallMethod(\^,"assoc word in B letter rep and negative integer",true,[IsAssocWord and IsBLetterAssocWordRep,IsNegRat and IsInt],0,AssocBWorLetRepPow);
InstallOtherMethod(ReversedOp,"for an assoc. word in letter rep",true,[IsAssocWord and IsLetterAssocWordRep],0,COM_FUN(36));
InstallOtherMethod(Subword,"for letter associative word and two positions",true,[IsAssocWord and IsLetterAssocWordRep,IsPosInt,IsInt],0,COM_FUN(37));
InstallMethod(PositionWord,"for two associative words and a positive integer, using letters",IsFamFamX,[IsAssocWord and IsLetterAssocWordRep,IsAssocWord,IsPosInt],0,COM_FUN(38));
InstallMethod(RenumberedWord,"associative words in letter rep",true,[IsAssocWord and IsLetterAssocWordRep,IsList],0,COM_FUN(39));
InstallMethod(MappedWord,"for a letter assoc. word, a homogeneous list, and a list",IsElmsCollsX,[IsAssocWord and IsLetterAssocWordRep,IsAssocWordCollection,IsList],COM_FUN(40));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/wordlett.gi"

#F  file="lib/mgmfree.gi" crc=-15721771
RANK_FILTER_LIST  := [ 36334852, 13, 36334852, 13, 36334852, 13, 36334852, 
  13, 36334852, 13, 48422789, 2, 27402927, 14, 24256914, 17, 60956909, 15, 
  52247917, 19, 39893676, 18, 52247917, 19 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/mgmfree.gi", -15721771 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/mgmfree.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/mgmfree.gi");
elif COM_RESULT = 3  then
Revision.mgmfree_gi:="@(#)$Id: mgmfree.gi,v 4.13 2003/03/10 08:47:31 gap Exp $";
InstallMethod(IsWholeFamily,"for a free magma",[IsMagma and IsNonassocWordCollection],COM_FUN(1));
InstallMethod(IsFinite,"for a magma of nonassoc. words",[IsMagma and IsNonassocWordCollection],IsTrivial);
InstallMethod(IsAssociative,"for a magma of nonassoc. words",[IsMagma and IsNonassocWordCollection],IsTrivial);
InstallMethod(Size,"for a free magma",[IsMagma and IsNonassocWordCollection],COM_FUN(2));
InstallMethod(Random,"for a free magma",[IsMagma and IsNonassocWordCollection],COM_FUN(3));
InstallMethod(MagmaGeneratorsOfFamily,"for a family of free magma elements",[IsNonassocWordFamily],COM_FUN(4));
InstallGlobalFunction(FreeMagma,COM_FUN(5));
InstallGlobalFunction(FreeMagmaWithOne,COM_FUN(6));
InstallMethod(ViewObj,"for a free magma containing the whole family",[IsMagma and IsWordCollection and IsWholeFamily],COM_FUN(7));
InstallMethod(ViewObj,"for a free magma-with-one containing the whole family",[IsMagmaWithOne and IsWordCollection and IsWholeFamily],COM_FUN(8));
InstallAccessToGenerators(IsMagma and IsWordCollection and IsWholeFamily,"free magma containing the whole family",GeneratorsOfMagma);
InstallAccessToGenerators(IsMagmaWithOne and IsWordCollection and IsWholeFamily,"free magma-with-one containing the whole family",GeneratorsOfMagmaWithOne);
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/mgmfree.gi"

#F  file="lib/smgrpfre.gi" crc=80804827
RANK_FILTER_LIST  := [ 936615, 16, 59459476, 12, 922696, 18, 936615, 16, 
  60410009, 18, 936615, 16, 6025000, 2, 922696, 18 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/smgrpfre.gi", 80804827 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/smgrpfre.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/smgrpfre.gi");
elif COM_RESULT = 3  then
Revision.smgrpfre_gi:="@(#)$Id: smgrpfre.gi,v 4.42 2003/04/16 07:47:56 gap Exp $";
InstallMethod(IsWholeFamily,"for a free semigroup",[IsSemigroup and IsAssocWordCollection],COM_FUN(1));
BindGlobal("FreeSemigroup_NextWordExp",COM_FUN(2));
BindGlobal("NextIterator_FreeSemigroup",COM_FUN(3));
BindGlobal("ShallowCopy_FreeSemigroup",COM_FUN(4));
InstallMethod(Iterator,"for a free semigroup",[IsAssocWordCollection and IsWholeFamily],COM_FUN(5));
BindGlobal("ElementNumber_FreeMonoid",COM_FUN(6));
BindGlobal("ElementNumber_FreeSemigroup",COM_FUN(7));
BindGlobal("NumberElement_FreeMonoid",COM_FUN(8));
BindGlobal("NumberElement_FreeSemigroup",COM_FUN(9));
InstallMethod(Enumerator,"for a free semigroup",[IsAssocWordCollection and IsWholeFamily and IsSemigroup],COM_FUN(10));
InstallMethod(IsFinite,"for a semigroup of assoc. words",[IsSemigroup and IsAssocWordCollection],IsTrivial);
InstallMethod(Size,"for a free semigroup",[IsSemigroup and IsAssocWordWithOneCollection],COM_FUN(11));
InstallMethod(Random,"for a free semigroup",[IsSemigroup and IsAssocWordCollection],COM_FUN(12));
InstallMethod(MagmaGeneratorsOfFamily,"for a family of free semigroup elements",[IsAssocWordFamily],COM_FUN(13));
InstallGlobalFunction(FreeSemigroup,COM_FUN(14));
InstallMethod(ViewObj,"for a free semigroup containing the whole family",[IsSemigroup and IsAssocWordCollection and IsWholeFamily],COM_FUN(15));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/smgrpfre.gi"

#F  file="lib/monofree.gi" crc=-14527031
RANK_FILTER_LIST  := [ 57264956, 20, 51823991, 14, 57251037, 22, 57264956, 
  20, 57264956, 20, 12049999, 3, 12049999, 3, 64886522, 21 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/monofree.gi", -14527031 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/monofree.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/monofree.gi");
elif COM_RESULT = 3  then
Revision.monofree_gi:="@(#)$Id: monofree.gi,v 4.36 2003/04/16 07:47:56 gap Exp $";
InstallMethod(IsWholeFamily,"for a free monoid",[IsAssocWordWithOneCollection and IsMonoid],COM_FUN(1));
InstallMethod(Iterator,"for a free monoid",[IsAssocWordWithOneCollection and IsWholeFamily],COM_FUN(2));
InstallMethod(Enumerator,"for a free monoid",[IsAssocWordWithOneCollection and IsWholeFamily and IsMonoid],COM_FUN(3));
InstallMethod(Random,"for a free monoid",[IsMonoid and IsAssocWordWithOneCollection],COM_FUN(4));
InstallMethod(Size,"for a free monoid",[IsMonoid and IsAssocWordWithOneCollection],COM_FUN(5));
InstallOtherMethod(One,"for a family of free monoid elements",[IsAssocWordWithOneFamily],COM_FUN(6));
InstallMethod(MagmaGeneratorsOfFamily,"for a family of free monoid elements",[IsAssocWordWithOneFamily],COM_FUN(7));
InstallGlobalFunction(FreeMonoid,COM_FUN(8));
InstallMethod(ViewObj,"for a free monoid containing the whole family",[IsMonoid and IsAssocWordCollection and IsWholeFamily],COM_FUN(9));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/monofree.gi"

#F  file="lib/grpfree.gi" crc=-45769649
RANK_FILTER_LIST  := [ 36553021, 18, 23105909, 33, 23118868, 30, 23118868, 
  30, 23118868, 30, 24100957, 4, 22368281, 31, 22368281, 31, 22368281, 31, 
  45943350, 7, 24100957, 4, 45943350, 7, 23118868, 30, 53641805, 32, 
  52247917, 19 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grpfree.gi", -45769649 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grpfree.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grpfree.gi");
elif COM_RESULT = 3  then
Revision.grpfree_gi:="@(#)$Id: grpfree.gi,v 4.51 2003/04/16 07:47:56 gap Exp $";
BindGlobal("NextIterator_FreeGroup",COM_FUN(1));
BindGlobal("ShallowCopy_FreeGroup",COM_FUN(2));
InstallMethod(Iterator,"for a free group",[IsAssocWordWithInverseCollection and IsWholeFamily],COM_FUN(3));
BindGlobal("ElementNumber_FreeGroup",COM_FUN(4));
BindGlobal("NumberElement_FreeGroup",COM_FUN(5));
InstallMethod(Enumerator,"for enumerator of a free group",[IsAssocWordWithInverseCollection and IsWholeFamily and IsGroup],COM_FUN(6));
InstallMethod(IsWholeFamily,"for a free group",[IsAssocWordWithInverseCollection and IsGroup],COM_FUN(7));
InstallMethod(Random,"for a free group",[IsAssocWordWithInverseCollection and IsGroup],COM_FUN(8));
InstallMethod(Size,"for a free group",[IsAssocWordWithInverseCollection and IsGroup],COM_FUN(9));
InstallMethod(MagmaGeneratorsOfFamily,"for a family of assoc. words",[IsAssocWordWithInverseFamily],COM_FUN(10));
InstallGlobalFunction(FreeGroup,COM_FUN(11));
InstallMethod(FreeGeneratorsOfFpGroup,"for a free group",[IsSubgroupFpGroup and IsGroupOfFamily and IsFreeGroup],GeneratorsOfGroup);
InstallMethod(RelatorsOfFpGroup,"for a free group",[IsSubgroupFpGroup and IsGroupOfFamily and IsFreeGroup],COM_FUN(12));
InstallMethod(FreeGroupOfFpGroup,"for a free group",[IsSubgroupFpGroup and IsGroupOfFamily and IsFreeGroup],IdFunc);
InstallMethod(UnderlyingElement,"for an element of a free group",[IsElementOfFreeGroup],IdFunc);
InstallOtherMethod(ElementOfFpGroup,"for a family of free group elements, and an assoc. word",[IsElementOfFreeGroupFamily and IsAssocWordWithInverseFamily,IsAssocWordWithInverse],COM_FUN(13));
InstallMethod(ViewObj,"subgroup of free group",[IsFreeGroup],COM_FUN(14));
InstallAccessToGenerators(IsSubgroupFpGroup and IsGroupOfFamily and IsFreeGroup,"free group containing the whole family",GeneratorsOfMagmaWithInverses);
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grpfree.gi"

#F  file="lib/rws.gi" crc=-111236058
RANK_FILTER_LIST  := [ 67108851, 3, 32769, 4, 67108850, 2, 67108850, 2, 
  67108850, 2, 56195099, 10, 67108850, 2, 56195099, 10, 67108851, 3, 4025226, 
  4, 32412609, 5, 56195099, 10, 65767820, 5, 65767820, 5, 56195099, 10, 
  65767820, 5, 65767820, 5, 4025226, 4, 32412609, 5, 32412609, 5, 14048753, 
  8, 65767820, 5, 14048753, 8, 65767820, 5, 65767820, 5, 37066606, 6, 
  56195099, 10, 32505602, 3, 17, 18, 16100031, 4, 32505602, 3, 32505602, 3, 
  14048753, 8, 65767820, 5, 65767820, 5, 4025226, 4, 30505985, 3, 30505985, 
  3, 4025226, 4, 67108850, 2, 1, 0 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/rws.gi", -111236058 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/rws.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/rws.gi");
elif COM_RESULT = 3  then
Revision.rws_gi:="@(#)$Id: rws.gi,v 4.29 2002/04/15 10:05:15 sal Exp $";
InstallMethod(AddGenerators,true,[IsRewritingSystem and IsMutable,IsHomogeneousList],0,COM_FUN(1));
InstallMethod(NumberGeneratorsOfRws,true,[IsRewritingSystem],0,COM_FUN(2));
InstallMethod(UnderlyingFamily,true,[IsRewritingSystem],0,COM_FUN(3));
InstallMethod(ViewObj,true,[IsRewritingSystem],0,COM_FUN(4));
InstallMethod(ViewObj,true,[IsRewritingSystem and IsBuiltFromGroup],0,COM_FUN(5));
InstallMethod(PrintObj,true,[IsRewritingSystem],0,COM_FUN(6));
InstallMethod(PrintObj,true,[IsRewritingSystem and IsBuiltFromGroup],0,COM_FUN(7));
InstallMethod(ReduceRules,true,[IsRewritingSystem and IsMutable],0,COM_FUN(8));
IsIdenticalObjFamiliesRwsObj:=COM_FUN(9);
IsIdenticalObjFamiliesRwsObjObj:=COM_FUN(10);
IsIdenticalObjFamiliesRwsObjXXX:=COM_FUN(11);
InstallMethod(ReducedAdditiveInverse,"ReducedForm",IsIdenticalObjFamiliesRwsObj,[IsRewritingSystem and IsBuiltFromAdditiveMagmaWithInverses,IsAdditiveElementWithInverse],0,COM_FUN(12));
InstallMethod(ReducedComm,"ReducedLeftQuotient/ReducedProduct",IsIdenticalObjFamiliesRwsObjObj,[IsRewritingSystem and IsBuiltFromGroup,IsMultiplicativeElementWithInverse,IsMultiplicativeElementWithInverse],0,COM_FUN(13));
InstallMethod(ReducedConjugate,"ReducedLeftQuotient/ReducedProduct",IsIdenticalObjFamiliesRwsObjObj,[IsRewritingSystem and IsBuiltFromGroup,IsMultiplicativeElementWithInverse,IsMultiplicativeElementWithInverse],0,COM_FUN(14));
InstallMethod(ReducedDifference,"ReducedSum/ReducedAdditiveInverse",IsIdenticalObjFamiliesRwsObjObj,[IsRewritingSystem and IsBuiltFromAdditiveMagmaWithInverses,IsAdditiveElementWithInverse,IsAdditiveElementWithInverse],0,COM_FUN(15));
InstallMethod(ReducedInverse,"ReducedForm",IsIdenticalObjFamiliesRwsObj,[IsRewritingSystem and IsBuiltFromMagmaWithInverses,IsMultiplicativeElementWithInverse],0,COM_FUN(16));
InstallMethod(ReducedLeftQuotient,"ReducedProduct/ReducedInverse",IsIdenticalObjFamiliesRwsObjObj,[IsRewritingSystem and IsBuiltFromMagmaWithInverses,IsMultiplicativeElementWithInverse,IsMultiplicativeElementWithInverse],0,COM_FUN(17));
InstallMethod(ReducedOne,"ReducedForm",true,[IsRewritingSystem and IsBuiltFromMagmaWithOne],0,COM_FUN(18));
InstallMethod(ReducedPower,"ReducedProduct/ReducedInverse",IsIdenticalObjFamiliesRwsObjXXX,[IsRewritingSystem and IsBuiltFromGroup,IsMultiplicativeElement,IsInt],0,COM_FUN(19));
InstallMethod(ReducedProduct,"ReducedForm",IsIdenticalObjFamiliesRwsObjObj,[IsRewritingSystem and IsBuiltFromMagma,IsMultiplicativeElement,IsMultiplicativeElement],0,COM_FUN(20));
InstallMethod(ReducedQuotient,"ReducedProduct/ReducedInverse",IsIdenticalObjFamiliesRwsObjObj,[IsRewritingSystem and IsBuiltFromMagmaWithInverses,IsMultiplicativeElementWithInverse,IsMultiplicativeElementWithInverse],0,COM_FUN(21));
InstallMethod(ReducedSum,"ReducedForm",IsIdenticalObjFamiliesRwsObjObj,[IsRewritingSystem and IsBuiltFromAdditiveMagmaWithInverses,IsAdditiveElement,IsAdditiveElement],0,COM_FUN(22));
InstallMethod(ReducedOne,"ReducedForm",true,[IsRewritingSystem and IsBuiltFromAdditiveMagmaWithInverses],0,COM_FUN(23));
InstallMethod(IsReducedForm,"for a rewriting system and an object",true,[IsRewritingSystem,IsObject],COM_FUN(24));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/rws.gi"

#F  file="lib/rwspcclt.gi" crc=93081492
RANK_FILTER_LIST  := [ 52416711, 15, 52427871, 11, 52416711, 15, 8193, 2, 
  52427872, 12, 52427871, 11, 37747822, 12, 8387724, 12, 52427871, 11, 
  37747822, 12, 8387724, 12, 52427871, 11, 8193, 2, 65767820, 5, 52427871, 
  11, 8193, 2, 65767820, 5, 18873724, 12, 8193, 2, 65767820, 5, 52427871, 11, 
  65767820, 5, 52427871, 11, 65767820, 5, 17, 18, 52427872, 12, 65767820, 5, 
  65767820, 5, 65767820, 5, 37747823, 13, 65767820, 5, 65767820, 5, 65767820, 
  5, 37747823, 13, 17, 18, 17, 18, 65767820, 5, 37747823, 13, 17, 18, 17, 18, 
  1, 0, 52427872, 12, 65767820, 5, 65767820, 5, 65767820, 5, 52427872, 12, 
  65767820, 5, 65767820, 5, 65767820, 5, 8387725, 13, 17, 18, 17, 18, 
  65767820, 5, 8387725, 13, 17, 18, 17, 18, 65767820, 5, 52427872, 12, 
  65767820, 5, 65767820, 5, 52427872, 12, 65767820, 5, 65767820, 5, 52427872, 
  12, 65767820, 5, 17, 18, 52427872, 12, 65767820, 5, 17, 18, 52427871, 11, 
  32769, 4, 32769, 4, 52247917, 19, 52247917, 19, 52247917, 19, 52427871, 11, 
  32769, 4, 32769, 4, 52247917, 19, 52247917, 19, 52247917, 19, 52427871, 11, 
  32769, 4, 32769, 4, 52247917, 19, 52247917, 19, 52247917, 19, 52427871, 11, 
  32769, 4, 32769, 4, 52247917, 19, 52247917, 19 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/rwspcclt.gi", 93081492 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/rwspcclt.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/rwspcclt.gi");
elif COM_RESULT = 3  then
Revision.rwspcclt_gi:="@(#)$Id: rwspcclt.gi,v 4.32 2002/04/15 10:05:15 sal Exp $";
IsIdenticalObjFamiliesColObjObj:=COM_FUN(1);
IsIdenticalObjFamiliesColObjObjObj:=COM_FUN(2);
IsIdenticalObjFamiliesColXXXObj:=COM_FUN(3);
IsIdenticalObjFamiliesColXXXXXXObj:=COM_FUN(4);
FinitePolycyclicCollector_IsConfluent:=COM_FUN(5);
InstallMethod(IsConfluent,"method for finite polycylic rewriting systems",true,[IsPolycyclicCollector and IsFinite],0,COM_FUN(6));
InstallMethod(IsConfluent,"generic method for polycyclic rewriting systems",true,[IsPolycyclicCollector],0,COM_FUN(7));
InstallOtherMethod(IsConfluent,true,[IsPolycyclicCollector and IsFinite,IsList],0,FinitePolycyclicCollector_IsConfluent);
InstallMethod(OutdatePolycyclicCollector,true,[IsPolycyclicCollector and IsMutable],0,COM_FUN(8));
InstallMethod(ViewObj,true,[IsPolycyclicCollector],0,COM_FUN(9));
InstallMethod(ViewObj,true,[IsPowerConjugateCollector],0,COM_FUN(10));
InstallMethod(ViewObj,true,[IsPowerCommutatorCollector],0,COM_FUN(11));
InstallMethod(PrintObj,true,[IsPolycyclicCollector],0,COM_FUN(12));
InstallMethod(PrintObj,true,[IsPowerConjugateCollector],0,COM_FUN(13));
InstallMethod(PrintObj,true,[IsPowerCommutatorCollector],0,COM_FUN(14));
InstallMethod(CollectWord,IsIdenticalObjFamiliesColXXXObj,[IsPolycyclicCollector,IsList,IsMultiplicativeElementWithInverse],0,COM_FUN(15));
InstallMethod(CollectWordOrFail,IsIdenticalObjFamiliesColXXXObj,[IsPolycyclicCollector,IsList,IsMultiplicativeElementWithInverse],0,COM_FUN(16));
InstallMethod(CollectWordOrFail,IsIdenticalObjFamiliesColXXXObj,[IsPolycyclicCollector and IsUpToDatePolycyclicCollector,IsList,IsMultiplicativeElementWithInverse],0,COM_FUN(17));
InstallMethod(ReducedForm,"CollectWordOrFail",IsIdenticalObjFamiliesRwsObj,[IsPolycyclicCollector,IsMultiplicativeElementWithInverse],0,COM_FUN(18));
InstallMethod(ReducedPower,"ReducedInverse/CollectWordOrFail",IsIdenticalObjFamiliesRwsObjXXX,[IsPolycyclicCollector,IsMultiplicativeElementWithInverse,IsInt],0,COM_FUN(19));
InstallMethod(SetCommutator,"elements",IsIdenticalObjFamiliesColObjObjObj,[IsPolycyclicCollector and IsMutable,IsMultiplicativeElementWithInverse,IsMultiplicativeElementWithInverse,IsMultiplicativeElementWithInverse],0,COM_FUN(20));
InstallMethod(SetCommutatorNC,"elements",IsIdenticalObjFamiliesColObjObjObj,[IsPowerConjugateCollector and IsMutable,IsMultiplicativeElementWithInverse,IsMultiplicativeElementWithInverse,IsMultiplicativeElementWithInverse],0,COM_FUN(21));
InstallMethod(SetCommutatorNC,"integers",IsIdenticalObjFamiliesColXXXXXXObj,[IsPowerConjugateCollector and IsMutable,IsInt,IsInt,IsMultiplicativeElementWithInverse],0,COM_FUN(22));
InstallMethod(SetCommutator,"integers",IsIdenticalObjFamiliesColXXXXXXObj,[IsPowerConjugateCollector and IsMutable,IsInt,IsInt,IsObject],0,COM_FUN(23));
InstallMethod(SetConjugate,IsIdenticalObjFamiliesColObjObjObj,[IsPolycyclicCollector and IsMutable,IsMultiplicativeElementWithInverse,IsMultiplicativeElementWithInverse,IsMultiplicativeElementWithInverse],0,COM_FUN(24));
InstallMethod(SetConjugateNC,IsIdenticalObjFamiliesColObjObjObj,[IsPolycyclicCollector and IsMutable,IsMultiplicativeElementWithInverse,IsMultiplicativeElementWithInverse,IsMultiplicativeElementWithInverse],0,COM_FUN(25));
InstallMethod(SetConjugate,IsIdenticalObjFamiliesColXXXXXXObj,[IsPowerCommutatorCollector and IsMutable,IsInt,IsInt,IsMultiplicativeElementWithInverse],0,COM_FUN(26));
InstallMethod(SetConjugateNC,IsIdenticalObjFamiliesColXXXXXXObj,[IsPowerCommutatorCollector and IsMutable,IsInt,IsInt,IsMultiplicativeElementWithInverse],0,COM_FUN(27));
InstallMethod(SetPower,IsIdenticalObjFamiliesColObjObj,[IsPolycyclicCollector and IsMutable,IsMultiplicativeElementWithInverse,IsMultiplicativeElementWithInverse],0,COM_FUN(28));
InstallMethod(SetPowerNC,IsIdenticalObjFamiliesColObjObj,[IsPolycyclicCollector and IsMutable,IsMultiplicativeElementWithInverse,IsMultiplicativeElementWithInverse],0,COM_FUN(29));
InstallMethod(SetRelativeOrder,IsIdenticalObjFamiliesColObjObj,[IsPolycyclicCollector and IsMutable,IsMultiplicativeElementWithInverse,IsInt],0,COM_FUN(30));
InstallMethod(SetRelativeOrderNC,IsIdenticalObjFamiliesColObjObj,[IsPolycyclicCollector and IsMutable,IsMultiplicativeElementWithInverse,IsInt],0,COM_FUN(31));
InstallMethod(EvaluateOverlapCBA,"polyc. collector, 2 hom. lists, 3 pos. integers",true,[IsPolycyclicCollector,IsHomogeneousList,IsHomogeneousList,IsPosInt,IsPosInt,IsPosInt],0,COM_FUN(32));
InstallMethod(EvaluateOverlapBNA,"polyc. collector, 2 hom. lists, 3 pos. integers",true,[IsPolycyclicCollector,IsHomogeneousList,IsHomogeneousList,IsPosInt,IsPosInt,IsPosInt],0,COM_FUN(33));
InstallMethod(EvaluateOverlapBAN,"polyc. collector, 2 hom. lists, 3 pos. integers",true,[IsPolycyclicCollector,IsHomogeneousList,IsHomogeneousList,IsPosInt,IsPosInt,IsPosInt],0,COM_FUN(34));
InstallMethod(EvaluateOverlapANA,"polyc. collector, 2 hom. lists, 3 pos. integers",true,[IsPolycyclicCollector,IsHomogeneousList,IsHomogeneousList,IsPosInt,IsPosInt],0,COM_FUN(35));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/rwspcclt.gi"

#F  file="lib/rwspcsng.gi" crc=-123092339
RANK_FILTER_LIST  := [ 64460639, 18, 64460640, 19, 64460640, 19, 17, 18, 17, 
  18, 65767820, 5, 64460640, 19, 17, 18, 17, 18, 65767820, 5, 64460640, 19, 
  17, 18, 17, 18, 65767820, 5, 64460640, 19, 17, 18, 65767820, 5, 64460640, 
  19, 17, 18, 65767820, 5, 64460640, 19, 17, 18, 65767820, 5, 64460639, 18, 
  17, 18, 17, 18, 64460639, 18, 17, 18, 64460640, 19, 17, 18, 17, 18, 
  64460640, 19, 17, 18, 17, 18, 64460639, 18, 30553684, 31, 8193, 2, 
  30553684, 31, 17, 18, 8193, 2, 8193, 2, 8193, 2, 17, 18, 1985, 1, 8193, 2, 
  8193, 2, 64460639, 18, 64460639, 18, 64460639, 18, 64460639, 18, 30906492, 
  19, 8193, 2, 65767820, 5, 15458668, 21, 8193, 2, 26631969, 8, 1797743, 21, 
  8193, 2, 53263937, 8, 41586692, 21, 8193, 2, 39418994, 8, 64460639, 18, 
  64460639, 18, 64460639, 18, 8193, 2, 64460639, 18, 30906492, 19, 24075737, 
  19, 57630469, 20, 10415772, 19, 43970504, 20, 50204721, 19, 16650574, 20, 
  64460639, 18, 30906492, 19, 24075737, 19, 57630469, 20, 10415772, 19, 
  43970504, 20, 50204721, 19, 16650574, 20, 15458668, 21, 26631969, 8, 
  26631969, 8, 1797743, 21, 53263937, 8, 53263937, 8, 41586692, 21, 39418994, 
  8, 39418994, 8, 64460639, 18, 47284410, 5, 15458668, 21, 26631969, 8, 
  1797743, 21, 53263937, 8, 41586692, 21, 39418994, 8, 15458668, 21, 
  26631969, 8, 26631969, 8, 1797743, 21, 53263937, 8, 53263937, 8, 41586692, 
  21, 39418994, 8, 39418994, 8, 64460639, 18, 15458668, 21, 26631969, 8, 
  26631969, 8, 1797743, 21, 53263937, 8, 53263937, 8, 41586692, 21, 39418994, 
  8, 39418994, 8, 15458668, 21, 26631969, 8, 15332823, 20, 1797743, 21, 
  53263937, 8, 15332823, 20, 41586692, 21, 39418994, 8, 15332823, 20, 
  15458668, 21, 26631969, 8, 26631969, 8, 1797743, 21, 53263937, 8, 53263937, 
  8, 41586692, 21, 39418994, 8, 39418994, 8 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/rwspcsng.gi", -123092339 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/rwspcsng.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/rwspcsng.gi");
elif COM_RESULT = 3  then
Revision.rwspcsng_gi:="@(#)$Id: rwspcsng.gi,v 4.50 2002/05/04 13:45:53 gap Exp $";
DeclareRepresentation("IsSingleCollectorRep",IsPositionalObjectRep,[1..SCP_AVECTOR],IsPowerConjugateCollector and IsFinite);
DeclareRepresentation("Is8BitsSingleCollectorRep",IsSingleCollectorRep,[],IsPowerConjugateCollector and IsFinite);
DeclareRepresentation("Is16BitsSingleCollectorRep",IsSingleCollectorRep,[],IsPowerConjugateCollector and IsFinite);
DeclareRepresentation("Is32BitsSingleCollectorRep",IsSingleCollectorRep,[],IsPowerConjugateCollector and IsFinite);
DeclareFilter("IsDefaultRhsTypeSingleCollector");
SingleCollector_CollectWordRunning:=false;
SingleCollector_CollectWord:=COM_FUN(1);
SingleCollector_Solution:=COM_FUN(2);
InstallMethod(Rules,true,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep],0,COM_FUN(3));
InstallMethod(ReduceRules,true,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep and IsMutable],0,COM_FUN(4));
InstallMethod(SetConjugateANC,"pow conj single collector",IsIdenticalObjFamiliesColXXXXXXObj,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep and IsMutable,IsInt,IsInt,IsMultiplicativeElementWithInverse],0,COM_FUN(5));
SingleCollector_SetConjugateNC:=COM_FUN(6);
InstallMethod(SetConjugateNC,IsIdenticalObjFamiliesColXXXXXXObj,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep and IsMutable,IsInt,IsInt,IsMultiplicativeElementWithInverse],0,SingleCollector_SetConjugateNC);
InstallMethod(SetConjugate,IsIdenticalObjFamiliesColXXXXXXObj,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep and IsMutable,IsInt,IsInt,IsMultiplicativeElementWithInverse],0,COM_FUN(7));
InstallMethod(SetPowerANC,"pow conj single collector",IsIdenticalObjFamiliesColXXXObj,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep and IsMutable,IsInt,IsMultiplicativeElementWithInverse],0,COM_FUN(8));
SingleCollector_SetPowerNC:=COM_FUN(9);
InstallMethod(SetPowerNC,IsIdenticalObjFamiliesColXXXObj,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep and IsMutable,IsInt,IsMultiplicativeElementWithInverse],0,SingleCollector_SetPowerNC);
InstallMethod(SetPower,IsIdenticalObjFamiliesColXXXObj,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep and IsMutable,IsInt,IsMultiplicativeElementWithInverse],0,COM_FUN(10));
InstallMethod(GetConjugateNC,"finite pow-conj single collector",true,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep,IsInt,IsInt],0,COM_FUN(11));
InstallMethod(GetPowerNC,true,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep,IsInt],0,COM_FUN(12));
SingleCollector_SetRelativeOrderNC:=COM_FUN(13);
InstallMethod(SetRelativeOrderNC,true,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep and IsMutable,IsInt,IsInt],0,SingleCollector_SetRelativeOrderNC);
InstallMethod(SetRelativeOrder,true,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep and IsMutable,IsInt,IsInt],0,COM_FUN(14));
SingleCollector_MakeAvector:=COM_FUN(15);
SingleCollector_MakeInverses:=COM_FUN(16);
InstallMethod(UpdatePolycyclicCollector,true,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep],0,COM_FUN(17));
InstallMethod(SingleCollector,true,[IsFreeGroup and IsGroupOfFamily,IsList],0,COM_FUN(18));
InstallMethod(SingleCollector,true,[IsFreeGroup and IsGroupOfFamily,IsInt],0,COM_FUN(19));
InstallMethod(SingleCollector,true,[IsList,IsList],0,COM_FUN(20));
InstallMethod(SingleCollector,true,[IsList,IsInt],0,COM_FUN(21));
InstallMethod(SingleCollectorByGenerators,true,[IsFamily,IsList,IsList],0,COM_FUN(22));
InstallMethod(NumberGeneratorsOfRws,true,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep],0,COM_FUN(23));
InstallMethod(GeneratorsOfRws,true,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep],0,COM_FUN(24));
InstallMethod(UnderlyingFamily,true,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep],0,COM_FUN(25));
InstallMethod(RelativeOrders,true,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep],0,COM_FUN(26));
InstallMethod(CollectWordOrFail,IsIdenticalObjFamiliesColXXXObj,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep and IsUpToDatePolycyclicCollector,IsList,IsMultiplicativeElementWithInverse],0,SingleCollector_CollectWord);
InstallMethod(CollectWordOrFail,IsIdenticalObjFamiliesColXXXObj,[IsPowerConjugateCollector and IsFinite and Is8BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePo\
lycyclicCollector,IsList,Is8BitsAssocWord],0,FinPowConjCol_CollectWordOrFail);
InstallMethod(CollectWordOrFail,IsIdenticalObjFamiliesColXXXObj,[IsPowerConjugateCollector and IsFinite and Is16BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDateP\
olycyclicCollector,IsList,Is16BitsAssocWord],0,FinPowConjCol_CollectWordOrFail);
InstallMethod(CollectWordOrFail,IsIdenticalObjFamiliesColXXXObj,[IsPowerConjugateCollector and IsFinite and Is32BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePolycyclicCollector,IsList,Is32BitsAssocWord],0,FinPowConjCol_CollectWordOrFail);
ShallowCopy_SingleCollector:=COM_FUN(27);
InstallMethod(ShallowCopy,true,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep],0,ShallowCopy_SingleCollector);
InstallMethod(NonTrivialRightHandSides,true,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep],0,COM_FUN(28));
InstallMethod(ObjByExponents,true,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep,IsList],0,COM_FUN(29));
InstallMethod(ViewObj,true,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep],0,COM_FUN(30));
InstallMethod(ViewObj,true,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep and IsUpToDatePolycyclicCollector],0,COM_FUN(31));
InstallMethod(ViewObj,true,[IsPowerConjugateCollector and IsFinite and Is8BitsSingleCollectorRep],0,COM_FUN(32));
InstallMethod(ViewObj,true,[IsPowerConjugateCollector and IsFinite and Is8BitsSingleCollectorRep and IsUpToDatePolycyclicCollector],0,COM_FUN(33));
InstallMethod(ViewObj,true,[IsPowerConjugateCollector and IsFinite and Is16BitsSingleCollectorRep],0,COM_FUN(34));
InstallMethod(ViewObj,true,[IsPowerConjugateCollector and IsFinite and Is16BitsSingleCollectorRep and IsUpToDatePolycyclicCollector],0,COM_FUN(35));
InstallMethod(ViewObj,true,[IsPowerConjugateCollector and IsFinite and Is32BitsSingleCollectorRep],0,COM_FUN(36));
InstallMethod(ViewObj,true,[IsPowerConjugateCollector and IsFinite and Is32BitsSingleCollectorRep and IsUpToDatePolycyclicCollector],0,COM_FUN(37));
InstallMethod(PrintObj,true,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep],0,COM_FUN(38));
InstallMethod(PrintObj,true,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep and IsUpToDatePolycyclicCollector],0,COM_FUN(39));
InstallMethod(PrintObj,true,[IsPowerConjugateCollector and IsFinite and Is8BitsSingleCollectorRep],0,COM_FUN(40));
InstallMethod(PrintObj,true,[IsPowerConjugateCollector and IsFinite and Is8BitsSingleCollectorRep and IsUpToDatePolycyclicCollector],0,COM_FUN(41));
InstallMethod(PrintObj,true,[IsPowerConjugateCollector and IsFinite and Is16BitsSingleCollectorRep],0,COM_FUN(42));
InstallMethod(PrintObj,true,[IsPowerConjugateCollector and IsFinite and Is16BitsSingleCollectorRep and IsUpToDatePolycyclicCollector],0,COM_FUN(43));
InstallMethod(PrintObj,true,[IsPowerConjugateCollector and IsFinite and Is32BitsSingleCollectorRep],0,COM_FUN(44));
InstallMethod(PrintObj,true,[IsPowerConjugateCollector and IsFinite and Is32BitsSingleCollectorRep and IsUpToDatePolycyclicCollector],0,COM_FUN(45));
InstallMethod(ReducedComm,IsIdenticalObjFamiliesRwsObjObj,[IsPowerConjugateCollector and IsFinite and Is8BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePolycyclicCollector,Is8BitsAssocWord,Is8BitsAssocWord],0,FinPowConjCol_ReducedComm);
InstallMethod(ReducedComm,IsIdenticalObjFamiliesRwsObjObj,[IsPowerConjugateCollector and IsFinite and Is16BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePolycyclicCollector,Is16BitsAssocWord,Is16BitsAssocWord],0,FinPowConjCol_ReducedComm);
InstallMethod(ReducedComm,IsIdenticalObjFamiliesRwsObjObj,[IsPowerConjugateCollector and IsFinite and Is32BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePolycyclicCollector,Is32BitsAssocWord,Is32BitsAssocWord],0,FinPowConjCol_ReducedComm);
InstallMethod(ReducedInverse,IsIdenticalObjFamiliesRwsObj,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep,IsAssocWord],0,COM_FUN(46));
InstallMethod(ReducedForm,IsIdenticalObjFamiliesRwsObj,[IsPowerConjugateCollector and IsFinite and Is8BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePolycyclicCollector,Is8BitsAssocWord],0,FinPowConjCol_ReducedForm);
InstallMethod(ReducedForm,IsIdenticalObjFamiliesRwsObj,[IsPowerConjugateCollector and IsFinite and Is16BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePolycyclicCollector,Is16BitsAssocWord],0,FinPowConjCol_ReducedForm);
InstallMethod(ReducedForm,IsIdenticalObjFamiliesRwsObj,[IsPowerConjugateCollector and IsFinite and Is32BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePolycyclicCollector,Is32BitsAssocWord],0,FinPowConjCol_ReducedForm);
InstallMethod(ReducedLeftQuotient,IsIdenticalObjFamiliesRwsObjObj,[IsPowerConjugateCollector and IsFinite and Is8BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePolycyclicCollector,Is8BitsAssocWord,Is8BitsAssocWord],0,FinPowConjCol_ReducedLeftQuotient);
InstallMethod(ReducedLeftQuotient,IsIdenticalObjFamiliesRwsObjObj,[IsPowerConjugateCollector and IsFinite and Is16BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePolycyclicCollector,Is16BitsAssocWord,Is16BitsAssocWord],0,FinPowConjCol_ReducedLeftQuotient);
InstallMethod(ReducedLeftQuotient,IsIdenticalObjFamiliesRwsObjObj,[IsPowerConjugateCollector and IsFinite and Is32BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePolycyclicCollector,Is32BitsAssocWord,Is32BitsAssocWord],0,FinPowConjCol_ReducedLeftQuotient);
InstallMethod(ReducedOne,true,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep],0,COM_FUN(47));
InstallMethod(ReducedProduct,IsIdenticalObjFamiliesRwsObjObj,[IsPowerConjugateCollector and IsFinite and Is8BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePolycyclicCollector,Is8BitsAssocWord,Is8BitsAssocWord],0,FinPowConjCol_ReducedProduct);
InstallMethod(ReducedProduct,IsIdenticalObjFamiliesRwsObjObj,[IsPowerConjugateCollector and IsFinite and Is16BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePolycyclicCollector,Is16BitsAssocWord,Is16BitsAssocWord],0,FinPowConjCol_ReducedProduct);
InstallMethod(ReducedProduct,IsIdenticalObjFamiliesRwsObjObj,[IsPowerConjugateCollector and IsFinite and Is32BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePolycyclicCollector,Is32BitsAssocWord,Is32BitsAssocWord],0,FinPowConjCol_ReducedProduct);
InstallMethod(ReducedPower,IsIdenticalObjFamiliesRwsObjXXX,[IsPowerConjugateCollector and IsFinite and Is8BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePolycyclicCollector,Is8BitsAssocWord,IsInt and IsSmallIntRep],0,FinPowConjCol_ReducedPowerSmallInt);
InstallMethod(ReducedPower,IsIdenticalObjFamiliesRwsObjXXX,[IsPowerConjugateCollector and IsFinite and Is16BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePolycyclicCollector,Is16BitsAssocWord,IsInt and IsSmallIntRep],0,FinPowConjCol_ReducedPowerSmallInt);
InstallMethod(ReducedPower,IsIdenticalObjFamiliesRwsObjXXX,[IsPowerConjugateCollector and IsFinite and Is32BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePolycyclicCollector,Is32BitsAssocWord,IsInt and IsSmallIntRep],0,FinPowConjCol_ReducedPowerSmallInt);
InstallMethod(ReducedQuotient,IsIdenticalObjFamiliesRwsObjObj,[IsPowerConjugateCollector and IsFinite and Is8BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePolycyclicCollector,Is8BitsAssocWord,Is8BitsAssocWord],0,FinPowConjCol_ReducedQuotient);
InstallMethod(ReducedQuotient,IsIdenticalObjFamiliesRwsObjObj,[IsPowerConjugateCollector and IsFinite and Is16BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePolycyclicCollector,Is16BitsAssocWord,Is16BitsAssocWord],0,FinPowConjCol_ReducedQuotient);
InstallMethod(ReducedQuotient,IsIdenticalObjFamiliesRwsObjObj,[IsPowerConjugateCollector and IsFinite and Is32BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePolycyclicCollector,Is32BitsAssocWord,Is32BitsAssocWord],0,FinPowConjCol_ReducedQuotient);
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/rwspcsng.gi"

#F  file="lib/rwspccoc.gi" crc=-13649274
RANK_FILTER_LIST  := [ 20500020, 20, 17, 18, 17, 18, 65767820, 5, 20500020, 
  20, 17, 18, 65767820, 5, 20500019, 19, 30553684, 31, 8193, 2, 30553684, 31, 
  17, 18, 8193, 2, 8193, 2, 8193, 2, 17, 18, 1985, 1, 8193, 2, 8193, 2, 
  20500019, 19, 20500019, 19, 54054751, 20, 6840054, 20, 40394786, 21, 
  60288968, 20, 26734821, 21, 32968078, 20, 66522810, 21, 20500019, 19, 
  54054751, 20, 6840054, 20, 40394786, 21, 60288968, 20, 26734821, 21, 
  32968078, 20, 66522810, 21 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/rwspccoc.gi", -13649274 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/rwspccoc.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/rwspccoc.gi");
elif COM_RESULT = 3  then
Revision.rwspccoc_gi:="@(#)$Id: rwspccoc.gi,v 4.3 2002/04/15 10:05:16 sal Exp $";
DeclareRepresentation("IsCombinatorialCollectorRep",IsSingleCollectorRep,[1..SCP_CLASS],IsPowerConjugateCollector and IsFinite);
InstallMethod(SetConjugate,"combinatorial collector rep",IsIdenticalObjFamiliesColXXXXXXObj,[IsPowerConjugateCollector and IsFinite and IsCombinatorialCollectorRep and IsMutable,IsInt,IsInt,IsMultiplicativeElementWithInverse],0,COM_FUN(1));
InstallMethod(SetPower,"combinatorial collector rep",IsIdenticalObjFamiliesColXXXObj,[IsPowerConjugateCollector and IsFinite and IsCombinatorialCollectorRep and IsMutable,IsInt,IsMultiplicativeElementWithInverse],0,COM_FUN(2));
CombiCollector_MakeAvector2:=COM_FUN(3);
InstallMethod(UpdatePolycyclicCollector,"combinatorial collector rep",true,[IsPowerConjugateCollector and IsFinite and IsCombinatorialCollectorRep],0,COM_FUN(4));
InstallMethod(CombinatorialCollector,true,[IsFreeGroup and IsGroupOfFamily,IsList],0,COM_FUN(5));
InstallMethod(CombinatorialCollector,true,[IsFreeGroup and IsGroupOfFamily,IsInt],0,COM_FUN(6));
InstallMethod(CombinatorialCollector,true,[IsList,IsList],0,COM_FUN(7));
InstallMethod(CombinatorialCollector,true,[IsList,IsInt],0,COM_FUN(8));
InstallMethod(CombinatorialCollectorByGenerators,true,[IsFamily,IsList,IsList],0,COM_FUN(9));
InstallMethod(ShallowCopy,"combinatorial collector rep",true,[IsPowerConjugateCollector and IsFinite and IsCombinatorialCollectorRep],0,COM_FUN(10));
InstallMethod(ViewObj,"combinatorial collector rep",true,[IsPowerConjugateCollector and IsFinite and IsCombinatorialCollectorRep],0,COM_FUN(11));
InstallMethod(ViewObj,"combinatorial collector rep (up to date)",true,[IsPowerConjugateCollector and IsFinite and IsCombinatorialCollectorRep and IsUpToDatePolycyclicCollector],0,COM_FUN(12));
InstallMethod(ViewObj,"combinatorial collector rep (8 Bits)",true,[IsPowerConjugateCollector and IsFinite and Is8BitsSingleCollectorRep and IsCombinatorialCollectorRep],0,COM_FUN(13));
InstallMethod(ViewObj,"combinatorial collector rep (8 Bits, up to date)",true,[IsPowerConjugateCollector and IsFinite and Is8BitsSingleCollectorRep and IsCombinatorialCollectorRep and IsUpToDatePolycyclicCollector],0,COM_FUN(14));
InstallMethod(ViewObj,"combinatorial collector rep (16 Bits)",true,[IsPowerConjugateCollector and IsFinite and Is16BitsSingleCollectorRep and IsCombinatorialCollectorRep],0,COM_FUN(15));
InstallMethod(ViewObj,"combinatorial collector rep (16 Bits, up to date)",true,[IsPowerConjugateCollector and IsFinite and Is16BitsSingleCollectorRep and IsCombinatorialCollectorRep and IsUpToDatePolycyclicCollector],0,COM_FUN(16));
InstallMethod(ViewObj,"combinatorial collector rep (32 Bits)",true,[IsPowerConjugateCollector and IsFinite and Is32BitsSingleCollectorRep and IsCombinatorialCollectorRep],0,COM_FUN(17));
InstallMethod(ViewObj,"combinatorial collector rep (32 Bits, up to date)",true,[IsPowerConjugateCollector and IsFinite and Is32BitsSingleCollectorRep and IsCombinatorialCollectorRep and IsUpToDatePolycyclicCollector],0,COM_FUN(18));
InstallMethod(PrintObj,"combinatorial collector",true,[IsPowerConjugateCollector and IsFinite and IsCombinatorialCollectorRep],0,COM_FUN(19));
InstallMethod(PrintObj,"combinatorial collector (up to date)",true,[IsPowerConjugateCollector and IsFinite and IsCombinatorialCollectorRep and IsUpToDatePolycyclicCollector],0,COM_FUN(20));
InstallMethod(PrintObj,"combinatorial collector rep (8 Bits)",true,[IsPowerConjugateCollector and IsFinite and Is8BitsSingleCollectorRep and IsCombinatorialCollectorRep],0,COM_FUN(21));
InstallMethod(PrintObj,"combinatorial collector rep (8 Bits, up to date)",true,[IsPowerConjugateCollector and IsFinite and Is8BitsSingleCollectorRep and IsCombinatorialCollectorRep and IsUpToDatePolycyclicCollector],0,COM_FUN(22));
InstallMethod(PrintObj,"combinatorial collector rep (16 Bits)",true,[IsPowerConjugateCollector and IsFinite and Is16BitsSingleCollectorRep and IsCombinatorialCollectorRep],0,COM_FUN(23));
InstallMethod(PrintObj,"combinatorial collector rep (16 Bits, up to date)",true,[IsPowerConjugateCollector and IsFinite and Is16BitsSingleCollectorRep and IsCombinatorialCollectorRep and IsUpToDatePolycyclicCollector],0,COM_FUN(24));
InstallMethod(PrintObj,"combinatorial collector rep (32 Bits)",true,[IsPowerConjugateCollector and IsFinite and Is32BitsSingleCollectorRep and IsCombinatorialCollectorRep],0,COM_FUN(25));
InstallMethod(PrintObj,"combinatorial collector rep (32 Bits, up to date)",true,[IsPowerConjugateCollector and IsFinite and Is32BitsSingleCollectorRep and IsCombinatorialCollectorRep and IsUpToDatePolycyclicCollector],0,COM_FUN(26));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/rwspccoc.gi"

#F  file="lib/rwsgrp.gi" crc=103617478
RANK_FILTER_LIST  := [ 67108505, 2, 1, 0, 67108505, 2, 8193, 2, 17008896, 8, 
  17008896, 8, 15993088, 6, 15993088, 6, 15993088, 6, 15993088, 6, 15993088, 
  6, 15993088, 6, 15993088, 6, 15993088, 6, 15993088, 6, 15993088, 6, 
  15993088, 6, 15993088, 6, 15993088, 6, 15993088, 6, 17, 18, 15993088, 6, 
  15993088, 6, 15993088, 6, 15993088, 6, 56195099, 10, 56195099, 10, 
  56195099, 10 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/rwsgrp.gi", 103617478 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/rwsgrp.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/rwsgrp.gi");
elif COM_RESULT = 3  then
Revision.rwsgrp_gi:="@(#)$Id: rwsgrp.gi,v 4.30 2002/04/15 10:05:15 sal Exp $";
InstallMethod(ElementByRws,true,[IsElementsFamilyByRws,IsObject],0,COM_FUN(1));
InstallMethod(ElementByRws,true,[IsElementsFamilyByRws,IsList],0,COM_FUN(2));
InstallMethod(PrintObj,true,[IsMultiplicativeElementWithInverseByRws and IsPackedElementDefaultRep],0,COM_FUN(3));
InstallMethod(UnderlyingElement,true,[IsMultiplicativeElementWithInverseByRws and IsPackedElementDefaultRep],0,COM_FUN(4));
InstallMethod(ExtRepOfObj,true,[IsMultiplicativeElementWithInverseByRws],0,COM_FUN(5));
InstallMethod(Comm,"rws-element, rws-element",IsIdenticalObj,[IsMultiplicativeElementWithInverseByRws,IsMultiplicativeElementWithInverseByRws],0,COM_FUN(6));
InstallMethod(InverseOp,"rws-element",true,[IsMultiplicativeElementWithInverseByRws],0,COM_FUN(7));
InstallMethod(LeftQuotient,"rws-element, rws-element",IsIdenticalObj,[IsMultiplicativeElementWithInverseByRws,IsMultiplicativeElementWithInverseByRws],0,COM_FUN(8));
InstallMethod(OneOp,"rws-element",true,[IsMultiplicativeElementWithInverseByRws],0,COM_FUN(9));
InstallMethod(\/,"rws-element, rws-element",IsIdenticalObj,[IsMultiplicativeElementWithInverseByRws,IsMultiplicativeElementWithInverseByRws],0,COM_FUN(10));
InstallMethod(\*,"rws-element * rws-element",IsIdenticalObj,[IsMultiplicativeElementWithInverseByRws,IsMultiplicativeElementWithInverseByRws],0,COM_FUN(11));
InstallMethod(\^,"rws-element ^ rws-element",IsIdenticalObj,[IsMultiplicativeElementWithInverseByRws,IsMultiplicativeElementWithInverseByRws],0,COM_FUN(12));
InstallMethod(\^,"rws-element ^ int",IsIdenticalObj,[IsMultiplicativeElementWithInverseByRws,IsInt],0,COM_FUN(13));
InstallMethod(\=,IsIdenticalObj,[IsMultiplicativeElementWithInverseByRws,IsMultiplicativeElementWithInverseByRws],0,COM_FUN(14));
InstallMethod(\<,IsIdenticalObj,[IsMultiplicativeElementWithInverseByRws,IsMultiplicativeElementWithInverseByRws],0,COM_FUN(15));
InstallMethod(MultiplicativeElementsWithInversesFamilyByRws,true,[IsRewritingSystem and IsBuiltFromGroup],0,COM_FUN(16));
InstallMethod(GroupByRws,true,[IsRewritingSystem and IsBuiltFromGroup],0,COM_FUN(17));
InstallMethod(GroupByRwsNC,"rewriting system",true,[IsRewritingSystem and IsBuiltFromGroup],100,COM_FUN(18));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/rwsgrp.gi"

#F  file="lib/rwspcgrp.gi" crc=40946607
RANK_FILTER_LIST  := [ 12585763, 29, 52427871, 11, 4101633, 10, 4101633, 10, 
  4101633, 10, 4101633, 10, 4101633, 10, 4101633, 10, 4101633, 10, 4101633, 
  10, 4101633, 10, 4101633, 10, 4101633, 10, 4101633, 10, 4101633, 10, 
  4101633, 10, 15332823, 20, 30138717, 20, 55692243, 3, 26631969, 8, 
  65273107, 103, 65273107, 103, 55692243, 3, 8193, 2, 36738186, 111, 
  36738186, 111, 36738186, 111, 36738186, 111, 16477792, 20, 44275606, 3, 
  53263937, 8, 63438294, 103, 63438294, 103, 44275606, 3, 8193, 2, 34903373, 
  111, 34903373, 111, 34903373, 111, 34903373, 111, 56266741, 20, 21442332, 
  3, 39418994, 8, 59768668, 103, 59768668, 103, 21442332, 3, 8193, 2, 
  31233747, 111, 31233747, 111, 31233747, 111, 31233747, 111, 1985, 1, 8193, 
  2, 8193, 2, 1985, 1, 8193, 2, 8193, 2, 23118868, 30, 32769, 4, 23118868, 
  30, 32769, 4, 23118868, 30, 41951068, 17 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/rwspcgrp.gi", 40946607 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/rwspcgrp.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/rwspcgrp.gi");
elif COM_RESULT = 3  then
Revision.rwspcgrp_gi:="@(#)$Id: rwspcgrp.gi,v 4.46 2003/07/04 15:26:23 gap Exp $";
InstallOtherMethod(IsConfluent,"for pc group",true,[IsPcGroup],0,COM_FUN(1));
InstallMethod(MultiplicativeElementsWithInversesFamilyByRws,"generic method",true,[IsPolycyclicCollector],0,COM_FUN(2));
DeclareRepresentation("IsNBitsPcWordRep",IsDataObjectRep,[]);
InstallMethod(PrintObj,"pcword",true,[IsMultiplicativeElementWithInverseByPolycyclicCollector and IsNBitsPcWordRep],0,COM_FUN(3));
InstallMethod(String,"pcword",true,[IsMultiplicativeElementWithInverseByPolycyclicCollector and IsNBitsPcWordRep],\
0,COM_FUN(4));
InstallMethod(InverseOp,"generic method for n bits pc word rep",true,[IsMultiplicativeElementWithInverseByPolycyclicCollector and IsNBitsPcWordRep],0,COM_FUN(5));
InstallMethod(Comm,"generic method for n bits pc word rep",IsIdenticalObj,[IsMultiplicativeElementWithInverseByPolycyclicCollector and IsNBitsPcWordRep,IsMultiplicativeElementWithInverseByPolycyclicCollector and IsNBitsPcWordRep],0,NBitsPcWord_Comm);
InstallMethod(LeftQuotient,"generic method for n bits pc word rep",IsIdenticalObj,[IsMultiplicativeElementWithInverseByPolycyclicCollector and IsNBitsPcWordRep,IsMultiplicativeElementWithInverseByPolycyclicCollector and IsNBitsPcWordRep],0,NBitsPcWord_LeftQuotient);
InstallMethod(\/,"generic method for n bits pc word rep",IsIdenticalObj,[IsMultiplicativeElementWithInverseByPolycyclicCollector and IsNBitsPcWordRep,IsMultiplicativeElementWithInverseByPolycyclicCollector and IsNBitsPcWordRep],0,NBitsPcWord_Quotient);
InstallMethod(\*,"generic method for n bits pc word rep",IsIdenticalObj,[IsMultiplicativeElementWithInverseByPolycyclicCollector and IsNBitsPcWordRep,IsMultiplicativeElementWithInverseByPolycyclicCollector and IsNBitsPcWordRep],0,NBitsPcWord_Product);
InstallMethod(\^,"generic method for n bits pc word rep",IsIdenticalObj,[IsMultiplicativeElementWithInverseByPolycyclicCollector and IsNBitsPcWordRep,IsMultiplicativeElementWithInverseByPolycyclicCollector and IsNBitsPcWordRep],0,NBitsPcWord_Conjugate);
InstallMethod(\^,"generic method for n bits pc word rep and small int",true,[IsMultiplicativeElementWithInverseByPolycyclicCollector and IsNBitsPcWordRep,IsInt and IsSmallIntRep],0,NBitsPcWord_PowerSmallInt);
DeclareRepresentation("Is8BitsPcWordRep",IsNBitsPcWordRep and IsKernelPcWord,[]);
InstallMethod(MultiplicativeElementsWithInversesFamilyByRws,"8 bits family",true,[IsPolycyclicCollector and IsFinite and Is8BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePolycyclicCollector],0,COM_FUN(6));
InstallMethod(ElementByRws,"using 8Bits_AssocWord",true,[IsElementsFamilyBy8BitsSingleCollector,Is8BitsAssocWord],0,COM_FUN(7));
InstallMethod(UnderlyingElement,"using 8Bits_ExtRepOfObj",true,[Is8BitsPcWordRep],0,COM_FUN(8));
InstallMethod(ExtRepOfObj,"using 8Bits_ExtRepOfObj",true,[Is8BitsPcWordRep],0,8Bits_ExtRepOfObj);
InstallMethod(ObjByExtRep,"using 8Bits_AssocWord",true,[IsElementsFamilyBy8BitsSingleCollector,IsList],0,COM_FUN(9));
InstallMethod(\=,"for 8 bits pc word rep",IsIdenticalObj,[IsMultiplicativeElementWithInverseByPolycyclicCollector and Is8BitsPcWordRep,IsMultiplicativeElementWithInverseByPolycyclicCollector and Is8BitsPcWordRep],0,8Bits_Equal);
InstallMethod(\<,"method for 8 bits pc word rep",IsIdenticalObj,[IsMultiplicativeElementWithInverseByPolycyclicCollector and Is8BitsPcWordRep,IsMultiplicativeElementWithInverseByPolycyclicCollector and Is8BitsPcWordRep],0,8Bits_Less);
DeclareRepresentation("Is16BitsPcWordRep",IsNBitsPcWordRep and IsKernelPcWord,[]);
InstallMethod(MultiplicativeElementsWithInversesFamilyByRws,"16 bits family",true,[IsPolycyclicCollector and IsFinite and Is16BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePolycyclicCollector],0,COM_FUN(10));
InstallMethod(ElementByRws,"using 16Bits_AssocWord",true,[IsElementsFamilyBy16BitsSingleCollector,Is16BitsAssocWord],0,COM_FUN(11));
InstallMethod(UnderlyingElement,"using 16Bits_ExtRepOfObj",true,[Is16BitsPcWordRep],0,COM_FUN(12));
InstallMethod(ExtRepOfObj,"using 16Bits_ExtRepOfObj",true,[Is16BitsPcWordRep],0,16Bits_ExtRepOfObj);
InstallMethod(ObjByExtRep,"using 16Bits_AssocWord",true,[IsElementsFamilyBy16BitsSingleCollector,IsList],0,COM_FUN(13));
InstallMethod(\=,"for 16 bits pc word rep",IsIdenticalObj,[IsMultiplicativeElementWithInverseByPolycyclicCollector and Is16BitsPcWordRep,IsMultiplicativeElementWithInverseByPolycyclicCollector and Is16BitsPcWordRep],0,16Bits_Equal);
InstallMethod(\<,"for 16 bits pc word rep",IsIdenticalObj,[IsMultiplicativeElementWithInverseByPolycyclicCollector and Is16BitsPcWordRep,IsMultiplicativeElementWithInverseByPolycyclicCollector and Is16BitsPcWordRep],0,16Bits_Less);
DeclareRepresentation("Is32BitsPcWordRep",IsNBitsPcWordRep and IsKernelPcWord,[]);
InstallMethod(MultiplicativeElementsWithInversesFamilyByRws,"32 bits family",true,[IsPolycyclicCollector and IsFinite and Is32BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePolycyclicCollector],0,COM_FUN(14));
InstallMethod(ElementByRws,"using 32Bits_AssocWord",true,[IsElementsFamilyBy32BitsSingleCollector,Is32BitsAssocWord],0,COM_FUN(15));
InstallMethod(UnderlyingElement,"using 16Bits_ExtRepOfObj",true,[Is32BitsPcWordRep],0,COM_FUN(16));
InstallMethod(ExtRepOfObj,"using 32Bits_ExtRepOfObj",true,[Is32BitsPcWordRep],0,32Bits_ExtRepOfObj);
InstallMethod(ObjByExtRep,"using 32Bits_AssocWord",true,[IsElementsFamilyBy32BitsSingleCollector,IsList],0,COM_FUN(17));
InstallMethod(\=,"for 32 bits pc word rep",IsIdenticalObj,[IsMultiplicativeElementWithInverseByPolycyclicCollector and Is32BitsPcWordRep,IsMultiplicativeElementWithInverseByPolycyclicCollector and Is32BitsPcWordRep],0,32Bits_Equal);
InstallMethod(\<,"for 32 bits pc word rep",IsIdenticalObj,[IsMultiplicativeElementWithInverseByPolycyclicCollector and Is32BitsPcWordRep,IsMultiplicativeElementWithInverseByPolycyclicCollector and Is32BitsPcWordRep],0,32Bits_Less);
SingleCollector_GroupRelators:=COM_FUN(18);
InstallGlobalFunction("SingleCollectorByRelators",COM_FUN(19));
InstallMethod(PolycyclicFactorGroupByRelatorsNC,"generic method for family, generators, relators",true,[IsFamily,IsList,IsList],0,COM_FUN(20));
InstallMethod(PolycyclicFactorGroupByRelators,"generic method for family, generators, relators",true,[IsFamily,IsList,IsList],0,COM_FUN(21));
InstallMethod(PolycyclicFactorGroup,"for free group, list using ' PolycyclicFactorGroupByRelators'",IsIdenticalObj,[IsFreeGroup,IsHomogeneousList],0,COM_FUN(22));
InstallMethod(PolycyclicFactorGroupNC,"for free group, list using ' PolycyclicFactorGroupByRelators'",IsIdenticalObj,[IsFreeGroup,IsHomogeneousList],0,COM_FUN(23));
InstallMethod(PolycyclicFactorGroup,"for free group, empty list using ' PolycyclicFactorGroupByRelators'",true,[IsFreeGroup,IsList and IsEmpty],0,COM_FUN(24));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/rwspcgrp.gi"

#F  file="lib/rwsdt.gi" crc=-114950986
RANK_FILTER_LIST  := [ 23105909, 33, 8193, 2, 23105909, 33, 17, 18, 1985, 1, 
  8193, 2, 8193, 2, 23067398, 14, 23067398, 14, 8193, 2, 23067399, 15, 17, 
  18, 1, 0, 23067398, 14, 23067398, 14, 17, 18, 23067398, 14, 23067398, 14, 
  8193, 2, 23067398, 14, 23067398, 14, 23067398, 14, 23067399, 15, 17, 18, 
  65767820, 5, 23067399, 15, 17, 18, 17, 18, 65767820, 5, 23067398, 14, 
  56622130, 15, 47284410, 5, 47284410, 5, 56622130, 15, 47284410, 5, 
  47284410, 5, 56622130, 15, 47284410, 5, 47284410, 5, 56622130, 15, 
  47284410, 5, 17, 18, 56622130, 15, 47284410, 5, 47284410, 5, 56622130, 15, 
  47284410, 5, 47284410, 5, 56622130, 15, 47284410, 5, 23067398, 14, 8193, 2, 
  65767820, 5, 23067398, 14, 8193, 2 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/rwsdt.gi", -114950986 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/rwsdt.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/rwsdt.gi");
elif COM_RESULT = 3  then
Revision.rwsdt_gi:="@(#)$Id: rwsdt.gi,v 4.12 2002/04/15 10:05:15 sal Exp $";
DeclareRepresentation("IsDeepThoughtCollectorRep",IsPositionalObjectRep,[1..PC_DEFAULT_TYPE],IsPowerConjugateCollector);
InstallMethod(DeepThoughtCollector,true,[IsFreeGroup and IsWholeFamily,IsList],0,COM_FUN(1));
InstallMethod(DeepThoughtCollector,true,[IsFreeGroup and IsWholeFamily,IsInt],0,COM_FUN(2));
InstallMethod(DeepThoughtCollectorByGenerators,true,[IsFamily,IsList,IsList],0,COM_FUN(3));
InstallMethod(Rules,"Deep Thought",true,[IsPowerConjugateCollector and IsDeepThoughtCollectorRep],0,COM_FUN(4));
InstallMethod(SetRelativeOrders,true,[IsDeepThoughtCollectorRep and IsPowerConjugateCollector,IsList],0,COM_FUN(5));
InstallMethod(SetRelativeOrder,true,[IsDeepThoughtCollectorRep and IsPowerConjugateCollector and IsMutable,IsInt,IsObject],0,COM_FUN(6));
InstallMethod(RelativeOrders,"Method for Deep Thought",true,[IsDeepThoughtCollectorRep and IsPowerConjugateCollector],0,COM_FUN(7));
InstallMethod(SetNumberGeneratorsOfRws,true,[IsDeepThoughtCollectorRep and IsPowerConjugateCollector,IsInt],0,COM_FUN(8));
InstallMethod(NumberGeneratorsOfRws,true,[IsDeepThoughtCollectorRep and IsPowerConjugateCollector],0,COM_FUN(9));
InstallMethod(SetGeneratorsOfRws,true,[IsDeepThoughtCollectorRep and IsPowerConjugateCollector,IsList],0,COM_FUN(10));
InstallMethod(GeneratorsOfRws,true,[IsDeepThoughtCollectorRep and IsPowerConjugateCollector],0,COM_FUN(11));
InstallMethod(ViewObj,true,[IsDeepThoughtCollectorRep and IsPowerConjugateCollector],0,COM_FUN(12));
InstallMethod(PrintObj,true,[IsDeepThoughtCollectorRep and IsPowerConjugateCollector],0,COM_FUN(13));
InstallMethod(SetPower,IsIdenticalObjFamiliesColXXXObj,[IsPowerConjugateCollector and IsDeepThoughtCollectorRep and IsMutable,IsInt,IsMultiplicativeElementWithInverse],0,COM_FUN(14));
DeepThoughtCollector_SetConjugateNC:=COM_FUN(15);
InstallMethod(SetConjugate,IsIdenticalObjFamiliesColXXXXXXObj,[IsPowerConjugateCollector and IsDeepThoughtCollectorRep and IsMutable,IsInt,IsInt,IsMultiplicativeElementWithInverse],0,COM_FUN(16));
InstallMethod(UpdatePolycyclicCollector,true,[IsPowerConjugateCollector and IsDeepThoughtCollectorRep],0,COM_FUN(17));
InstallMethod(ReducedProduct,"DeepThoughtReducedProduct",IsIdenticalObjFamiliesRwsObjObj,[IsPowerConjugateCollector and IsDeepThoughtCollectorRep and IsUpToDatePolycyclicCollector,IsAssocWord,IsAssocWord],0,COM_FUN(18));
InstallMethod(ReducedComm,"DeepThoughtReducedComm",IsIdenticalObjFamiliesRwsObjObj,[IsPowerConjugateCollector and IsDeepThoughtCollectorRep and IsUpToDatePolycyclicCollector,IsAssocWord,IsAssocWord],0,COM_FUN(19));
InstallMethod(ReducedLeftQuotient,"DeepThoughtReducedLeftQuotient",IsIdenticalObjFamiliesRwsObjObj,[IsPowerConjugateCollector and IsDeepThoughtCollectorRep and IsUpToDatePolycyclicCollector,IsAssocWord,IsAssocWord],0,COM_FUN(20));
InstallMethod(ReducedPower,"DeepThoughtReducedPower",IsIdenticalObjFamiliesRwsObjXXX,[IsPowerConjugateCollector and IsDeepThoughtCollectorRep and IsUpToDatePolycyclicCollector,IsAssocWord,IsInt],0,COM_FUN(21));
InstallMethod(ReducedQuotient,"DeepThoughtReducedQuotient",IsIdenticalObjFamiliesRwsObjObj,[IsPowerConjugateCollector and IsDeepThoughtCollectorRep and IsUpToDatePolycyclicCollector,IsAssocWord,IsAssocWord],0,COM_FUN(22));
InstallMethod(ReducedConjugate,"DeepThoughtReducedConjugate",IsIdenticalObjFamiliesRwsObjObj,[IsPowerConjugateCollector and IsDeepThoughtCollectorRep and IsUpToDatePolycyclicCollector,IsAssocWord,IsAssocWord],0,COM_FUN(23));
InstallMethod(ReducedInverse,"DeepThoughtReducedInverse",IsIdenticalObjFamiliesRwsObj,[IsPowerConjugateCollector and IsDeepThoughtCollectorRep and IsUpToDatePolycyclicCollector,IsAssocWord],0,COM_FUN(24));
InstallMethod(CollectWordOrFail,"DeepThought",IsIdenticalObjFamiliesColXXXObj,[IsPowerConjugateCollector and IsDeepThoughtCollectorRep,IsList,IsMultiplicativeElementWithInverse],0,COM_FUN(25));
InstallMethod(ObjByExponents,"DeepThought",true,[IsPowerConjugateCollector and IsDeepThoughtCollectorRep,IsList],0,COM_FUN(26));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/rwsdt.gi"

#F  file="lib/nilpquot.gi" crc=-72130247
RANK_FILTER_LIST  := [  ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/nilpquot.gi", -72130247 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/nilpquot.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/nilpquot.gi");
elif COM_RESULT = 3  then
Revision.nilpquot_gi:="$Id: nilpquot.gi,v 4.1 1999/09/13 16:51:06 werner Exp $";
LeftNormedComm:=COM_FUN(1);
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/nilpquot.gi"

#F  file="lib/pquot.gi" crc=59322737
RANK_FILTER_LIST  := [ 19203781, 3, 52247917, 19, 19203781, 3, 52247917, 19, 
  1, 0, 19203781, 3, 52247917, 19, 19203781, 3, 19203781, 3, 19203781, 3, 
  47284410, 5, 19203781, 3, 63198130, 7, 19203781, 3, 19203781, 3, 19203781, 
  3, 19203781, 3, 19203781, 3, 19203781, 3, 53660808, 21, 52247917, 19, 
  52247917, 19, 67108760, 5, 19203781, 3, 19203781, 3, 52247917, 19, 
  19203781, 3, 19203781, 3, 19203781, 3, 58909558, 26, 52247917, 19, 
  58909558, 26, 52247917, 19, 52247917, 19, 58923477, 23, 52247917, 19, 
  58923477, 23, 52247917, 19, 52247917, 19, 19203781, 3, 19203781, 3, 
  19203781, 3, 58923477, 23, 1, 0, 58909558, 26, 1, 0, 19203781, 3, 52247917, 
  19 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/pquot.gi", 59322737 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/pquot.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/pquot.gi");
elif COM_RESULT = 3  then
Revision.pquot_gi:="$Id: pquot.gi,v 4.42 2002/10/29 18:48:47 werner Exp $";
CHECK:=false;
NumberOfCommutators:=COM_FUN(1);
PQStatistics:=rec(TailCountBNA:=0,TailCountBAN:=0,TailCountCBA:=0,ConsCountANA:=0,ConsCountBNA:=0,ConsCountBAN:=0,ConsCountCBA:=0);
IncreaseCounter:=COM_FUN(2);
PrintCounters:=COM_FUN(3);
ClearPQuotientStatistics:=COM_FUN(4);
TrailingEntriesLTM:=COM_FUN(5);
ReducedVectorLTM:=COM_FUN(6);
AddVectorLTM:=COM_FUN(7);
RowEchelonFormLTM:=COM_FUN(8);
LowerTriangularMatrix:=COM_FUN(9);
InstallGlobalFunction(QuotSysDefinitionByIndex,COM_FUN(10));
InstallGlobalFunction(QuotSysIndexByDefinition,COM_FUN(11));
InstallMethod(GetDefinitionNC,true,[IsPQuotientSystem,IsPosInt],0,COM_FUN(12));
InstallMethod(SetDefinitionNC,true,[IsPQuotientSystem,IsPosInt,IsObject],0,COM_FUN(13));
InstallMethod(ClearDefinitionNC,true,[IsPQuotientSystem,IsPosInt],0,COM_FUN(14));
NumberOfNewGenerators:=COM_FUN(15);
InitialiseCentralRelations:=COM_FUN(16);
ClearCentralRelations:=COM_FUN(17);
CentralRelations:=COM_FUN(18);
InstallMethod(IncorporateCentralRelations,"p-quotient system",true,[IsPQuotientSystem],0,COM_FUN(19));
UpdateWeightInfo:=COM_FUN(20);
InstallMethod(DefineNewGenerators,"p-quotient system",true,[IsPQuotientSystem],0,COM_FUN(21));
InstallMethod(SplitWordTail,"p-quotient system, word",true,[IsPQuotientSystem,IsAssocWord],0,COM_FUN(22));
InstallMethod(ExtRepByTailVector,"p-quotient system, vector",true,[IsPQuotientSystem,IsVector],0,COM_FUN(23));
InstallMethod(TailsInverses,"p-quotient system",true,[IsPQuotientSystem],0,COM_FUN(24));
InstallMethod(ComputeTails,"p-quotient system",true,[IsPQuotientSystem],0,COM_FUN(25));
InstallMethod(EvaluateConsistency,"p-quotient system",true,[IsPQuotientSystem],0,COM_FUN(26));
InstallMethod(RenumberHighestWeightGenerators,"p-quotient system",true,[IsPQuotientSystem],0,COM_FUN(27));
EvaluateRelation:=COM_FUN(28);
InstallMethod(EvaluateRelators,"p-quotient system",true,[IsPQuotientSystem],0,COM_FUN(29));
InstallMethod(LiftEpimorphism,"p-quotient system",true,[IsPQuotientSystem],0,COM_FUN(30));
InstallMethod(QuotientSystem,"pquotient",true,[IsGroup,IsPosInt,IsPosInt,IsString],0,COM_FUN(31));
InstallMethod(GeneratorNumberOfQuotient,"p-quotient system",true,[IsPQuotientSystem],0,COM_FUN(32));
InstallMethod(GeneratorsOfLayer,"p-quotient system",true,[IsPQuotientSystem,IsPosInt],0,COM_FUN(33));
InstallMethod(LengthOfDescendingSeries,"p-quotient system",true,[IsPQuotientSystem],0,COM_FUN(34));
InstallMethod(RanksOfDescendingSeries,"p-quotient system",true,[IsPQuotientSystem],0,COM_FUN(35));
InstallMethod(CheckConsistencyOfDefinitions,"p-quotient system",true,[IsPQuotientSystem],0,COM_FUN(36));
InstallGlobalFunction(AbelianPQuotient,COM_FUN(37));
InstallGlobalFunction(PQuotient,COM_FUN(38));
InstallMethod(EpimorphismPGroup,"for finitely presented groups",true,[IsSubgroupFpGroup and IsWholeFamily,IsPosInt],0,COM_FUN(39));
InstallMethod(EpimorphismPGroup,"for finitely presented groups, class bound",true,[IsSubgroupFpGroup and IsWholeFamily,IsPosInt,IsPosInt],0,COM_FUN(40));
InstallMethod(EpimorphismPGroup,"for subgroups of finitely presented groups",true,[IsSubgroupFpGroup,IsPosInt],0,COM_FUN(41));
InstallMethod(EpimorphismPGroup,"for subgroups of finitely presented groups, class bound",true,[IsSubgroupFpGroup,IsPosInt,IsPosInt],0,COM_FUN(42));
InstallMethod(GroupByQuotientSystem,"p-group from a p-quotient system",true,[IsPQuotientSystem],0,COM_FUN(43));
PCover:=COM_FUN(44);
PMultiplicator:=COM_FUN(45);
Nucleus:=COM_FUN(46);
AllowableSubgroup:=COM_FUN(47);
InstallMethod(ViewObj,"p-quotient system",true,[IsPQuotientSystem],0,COM_FUN(48));
InstallMethod(EpimorphismQuotientSystem,"for p-quotient systems",true,[IsPQuotientSystem],0,COM_FUN(49));
InstallGlobalFunction("EpimorphismNilpotentQuotient",COM_FUN(50));
InstallMethod(EpimorphismNilpotentQuotientOp,"subgroup fp group",true,[IsSubgroupFpGroup,IsObject],0,COM_FUN(51));
InstallMethod(EpimorphismNilpotentQuotientOp,"full fp group",true,[IsSubgroupFpGroup and IsWholeFamily,IsObject],0,COM_FUN(52));
InstallMethod(TraceDefinition,"p-quotient system",true,[IsPQuotientSystem,IsPosInt],0,COM_FUN(53));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/pquot.gi"

#F  file="lib/pcgs.gi" crc=-7489441
RANK_FILTER_LIST  := [ 45797494, 30, 53660808, 21, 1025, 1, 39812596, 21, 
  52247917, 19, 64847138, 24, 64847138, 24, 64847138, 24, 1, 0, 17, 18, 
  64847138, 24, 64847138, 24, 64847138, 24, 52247917, 19, 39812596, 21, 
  16385, 3, 25034543, 3, 39812596, 21, 12585763, 29, 12585763, 29, 39812596, 
  21, 39812596, 21, 1, 0, 39812596, 21, 1, 0, 17, 18, 39812596, 21, 1, 0, 1, 
  0, 39812596, 21, 1, 0, 52247917, 19, 39812596, 21, 1, 0, 8193, 2, 53460738, 
  20, 52247917, 19, 52247917, 19, 53460738, 20, 52247917, 19, 53460738, 20, 
  52247917, 19, 52247917, 19, 39812596, 21, 1, 0, 17, 18, 39812596, 21, 
  39812596, 21, 1, 0, 39812596, 21, 41951068, 17, 8193, 2, 38054488, 29, 
  8193, 2, 65077475, 29, 39812596, 21, 41951068, 17, 41951068, 17, 39812596, 
  21, 8193, 2, 38054488, 29, 39812596, 21, 8193, 2, 65077475, 29, 53460738, 
  20, 38054488, 29, 65077475, 29, 53460738, 20, 38054488, 29, 38054488, 29, 
  23521090, 25, 1, 0, 1, 0, 23521090, 25, 1, 0, 39812596, 21, 1, 0, 39812596, 
  21, 65767820, 5, 52247917, 19, 52619935, 25, 8193, 2, 39813836, 23, 8193, 
  2, 39812596, 21, 1, 0, 1, 0, 39812596, 21, 41951068, 17, 23521090, 25, 
  8193, 2, 8193, 2, 1, 0, 23521090, 25, 8193, 2, 8193, 2, 23521090, 25, 8193, 
  2, 8193, 2, 23521090, 25, 8193, 2, 8193, 2, 23521090, 25, 8193, 2, 8193, 2, 
  1, 0, 39812596, 21, 39812596, 21, 39812596, 21, 39812596, 21, 8193, 2, 
  37756224, 5, 37756224, 5, 52247917, 19, 37756224, 5, 65767820, 5, 7665924, 
  21, 37756224, 5, 65767820, 5, 39812596, 21, 39812596, 21, 6258644, 22, 
  61546210, 28, 4160922, 23, 4899891, 22, 4899891, 22, 14306480, 22, 2486127, 
  28, 12209718, 23, 4899891, 22, 4899891, 22, 9734554, 22, 65022120, 28, 
  7637792, 23, 4899891, 22, 4899891, 22, 30626920, 22, 18805607, 28, 
  28530158, 23, 4899891, 22, 4899891, 22, 39812596, 21, 53660808, 21, 8193, 2 
 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/pcgs.gi", -7489441 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/pcgs.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/pcgs.gi");
elif COM_RESULT = 3  then
Revision.pcgs_gi:="@(#)$Id: pcgs.gi,v 4.103 2003/03/03 17:51:12 gap Exp $";
InstallGlobalFunction(PcgsByIndependentGeneratorsOfAbelianGroup,COM_FUN(1));
InstallMethod(Pcgs,"from independent generators of abelian group",true,[IsGroup and IsAbelian and HasIndependentGeneratorsOfAbelianGroup],0,COM_FUN(2));
InstallMethod(SetPcgs,true,[IsGroup,IsBool],0,COM_FUN(3));
InstallMethod(IsBound\[\],"pcgs",true,[IsPcgs,IsPosInt],0,COM_FUN(4));
InstallMethod(Length,"pcgs",true,[IsPcgs and IsPcgsDefaultRep],0,COM_FUN(5));
InstallMethod(AsList,"pcgs",true,[IsPcgs and IsPcgsDefaultRep],0,COM_FUN(6));
InstallMethod(Position,"pcgs, object, int",true,[IsPcgs and IsPcgsDefaultRep,IsObject,IsInt],0,COM_FUN(7));
InstallMethod(PrintObj,"pcgs",true,[IsPcgs and IsPcgsDefaultRep],0,COM_FUN(8));
InstallMethod(ViewObj,"pcgs",true,[IsPcgs and IsPcgsDefaultRep],0,COM_FUN(9));
InstallMethod(\[\],"pcgs, pos int",true,[IsPcgs and IsPcgsDefaultRep,IsPosInt],0,COM_FUN(10));
InstallMethod(ELMS_LIST,"pcgs, range",true,[IsPcgs,IsDenseList],0,COM_FUN(11));
InstallMethod(PcgsByPcSequenceCons,"generic constructor",true,[IsPcgsDefaultRep,IsObject,IsFamily,IsList,IsList],0,COM_FUN(12));
InstallMethod(IsPrimeOrdersPcgs,true,[IsPcgs],0,COM_FUN(13));
InstallMethod(RefinedPcGroup,"group with refined pcgs",true,[IsPcGroup],0,COM_FUN(14));
InstallMethod(IsomorphismRefinedPcGroup,"group with refined pcgs",true,[IsPcGroup],0,COM_FUN(15));
InstallTrueMethod(IsFiniteOrdersPcgs,IsPrimeOrdersPcgs);
InstallMethod(IsFiniteOrdersPcgs,true,[IsPcgs],0,COM_FUN(16));
InstallMethod(DepthOfPcElement,"generic methods, ExponentsOfPcElement",IsCollsElms,[IsPcgs,IsObject],0,COM_FUN(17));
InstallOtherMethod(DepthOfPcElement,"pcgs modulo pcgs, ignoring <min>",COM_FUN(18),[IsPcgs,IsObject,IsInt],0,COM_FUN(19));
InstallMethod(DifferenceOfPcElement,"generic methods, PcElementByExponents/ExponentsOfPcElement",IsCollsElmsElms,[IsPcgs,IsObject,IsObject],0,COM_FUN(20));
InstallMethod(ExponentOfPcElement,"generic method, ExponentsOfPcElement",COM_FUN(21),[IsPcgs,IsObject,IsPosInt],0,COM_FUN(22));
InstallOtherMethod(ExponentsOfPcElement,"with positions, falling back to ExponentsOfPcElement",COM_FUN(23),[IsPcgs,IsObject,IsList],0,COM_FUN(24));
InstallMethod(ExponentsOfConjugate,"generic: compute conjugate",true,[IsModuloPcgs,IsPosInt,IsPosInt],0,COM_FUN(25));
InstallMethod(ExponentsOfRelativePower,"generic: compute power",true,[IsModuloPcgs,IsPosInt],0,COM_FUN(26));
InstallMethod(ExponentsOfCommutator,"generic: compute commutator",true,[IsModuloPcgs,IsPosInt,IsPosInt],0,COM_FUN(27));
InstallMethod(HeadPcElementByNumber,"using 'ExponentsOfPcElement', 'PcElementByExponents'",true,[IsPcgs,IsObject,IsInt],0,COM_FUN(28));
InstallOtherMethod(ParentPcgs,true,[IsPcgs],0,IdFunc);
InstallMethod(LeadingExponentOfPcElement,"generic methods, ExponentsOfPcElement",IsCollsElms,[IsPcgs,IsObject],0,COM_FUN(29));
InstallGlobalFunction(PcElementByExponents,COM_FUN(30));
InstallMethod(PcElementByExponentsNC,"generic method for empty lists",true,[IsPcgs,IsList and IsEmpty],0,COM_FUN(31));
InstallGlobalFunction(PowerPcgsElement,COM_FUN(32));
InstallGlobalFunction(LeftQuotientPowerPcgsElement,COM_FUN(33));
InstallGlobalFunction(LinearCombinationPcgs,COM_FUN(34));
InstallOtherMethod(PcElementByExponentsNC,"generic method: call LinearCombinationPcgs",true,[IsList,IsRowVector and IsCyclotomicCollection],0,LinearCombinationPcgs);
InstallOtherMethod(PcElementByExponentsNC,"generic method",true,[IsList,IsRowVector and IsFFECollection],0,COM_FUN(35));
InstallOtherMethod(PcElementByExponentsNC,"generic method for empty lists",true,[IsPcgs,IsList and IsEmpty,IsList and IsEmpty],0,COM_FUN(36));
InstallOtherMethod(PcElementByExponentsNC,"multiply basis elements",IsFamFamX,[IsPcgs,IsList,IsRowVector and IsCyclotomicCollection],0,COM_FUN(37));
InstallOtherMethod(PcElementByExponentsNC,"multiply base elts., FFE",IsFamFamX,[IsPcgs,IsList,IsRowVector and IsFFECollection],0,COM_FUN(38));
InstallOtherMethod(PcElementByExponentsNC,"index: defer to basis",true,[IsModuloPcgs,IsRowVector and IsCyclotomicCollection,IsRowVector and IsFFECollection],0,COM_FUN(39));
InstallOtherMethod(PcElementByExponentsNC,"index: defer to basis,FFE",true,[IsModuloPcgs,IsRowVector and IsCyclotomicCollection,IsRowVector and IsCyclotomicCollection],0,COM_FUN(40));
InstallMethod(ReducedPcElement,"generic method",IsCollsElmsElms,[IsPcgs and IsPrimeOrdersPcgs,IsObject,IsObject],0,COM_FUN(41));
InstallMethod(RelativeOrderOfPcElement,"for IsPrimeOrdersPcgs using RelativeOrders",IsCollsElms,[IsPcgs and IsPrimeOrdersPcgs,IsObject],0,COM_FUN(42));
InstallMethod(RelativeOrderOfPcElement,"general method using RelativeOrders",IsCollsElms,[IsPcgs,IsObject],0,COM_FUN(43));
InstallMethod(CleanedTailPcElement,"generic: do nothing",IsCollsElmsX,[IsPcgs,IsMultiplicativeElementWithInverse,IsPosInt],0,COM_FUN(44));
SET_RELATIVE_ORDERS:=SETTER_FUNCTION("RelativeOrders",HasRelativeOrders);
InstallMethod(SetRelativeOrders,"setting orders for prime orders pcgs",true,[IsPcgs and IsComponentObjectRep and IsAttributeStoringRep and HasIsPrimeOrdersPcgs and HasIsFiniteOrdersPcgs,IsList],1,SET_RELATIVE_ORDERS);
InstallMethod(SetRelativeOrders,"setting orders and checking for prime orders",true,[IsPcgs and IsComponentObjectRep and IsAttributeStoringRep,IsList],0,COM_FUN(45));
InstallMethod(SumOfPcElement,"generic methods, PcElementByExponents+ExponentsOfPcElement",IsCollsElmsElms,[IsPcgs,IsObject,IsObject],0,COM_FUN(46));
InstallMethod(ExtendedPcgs,"pcgs, empty list",true,[IsPcgs,IsList and IsEmpty],0,COM_FUN(47));
InstallMethod(ExtendedIntersectionSumPcgs,"generic method for modulo pcgs",true,[IsPcgs and IsPrimeOrdersPcgs,IsList,IsList,IsObject],0,COM_FUN(48));
InstallMethod(IntersectionSumPcgs,"using 'ExtendedIntersectionSumPcgs'",COM_FUN(49),[IsPcgs and IsPrimeOrdersPcgs,IsList,IsList],0,COM_FUN(50));
InstallMethod(NormalIntersectionPcgs,"using 'ExtendedIntersectionSumPcgs'",COM_FUN(51),[IsPcgs and IsPrimeOrdersPcgs,IsList,IsList],0,COM_FUN(52));
InstallMethod(SumPcgs,"generic method",COM_FUN(53),[IsPcgs and IsPrimeOrdersPcgs,IsList,IsList],0,COM_FUN(54));
InstallMethod(SumFactorizationFunctionPcgs,"generic method",true,[IsPcgs and IsPrimeOrdersPcgs,IsList,IsList,IsObject],0,COM_FUN(55));
GROUP_BY_PCGS_FINITE_ORDERS:=COM_FUN(56);
InstallMethod(PcGroupWithPcgs,true,[IsPcgs],0,COM_FUN(57));
InstallMethod(GroupOfPcgs,true,[IsPcgs],0,COM_FUN(58));
DeclareRepresentation("IsEnumeratorByPcgsRep",IsAttributeStoringRep,["pcgs","sublist"]);
InstallMethod(EnumeratorByPcgs,"pcgs",true,[IsPcgs],0,COM_FUN(59));
InstallOtherMethod(EnumeratorByPcgs,"pcgs, sublist",true,[IsPcgs,IsList],0,COM_FUN(60));
InstallMethod(Length,"enum-by-pcgs",true,[IsList and IsEnumeratorByPcgsRep],0,COM_FUN(61));
InstallMethod(\[\],"enum-by-pcgs",true,[IsList and IsEnumeratorByPcgsRep,IsPosInt],0,COM_FUN(62));
InstallMethod(Position,"enum-by-pcgs",IsCollsElmsX,[IsList and IsEnumeratorByPcgsRep,IsMultiplicativeElementWithInverse,IsZeroCyc],0,COM_FUN(63));
InstallMethod(PositionCanonical,"enum-by-pcgs",IsCollsElms,[IsList and IsEnumeratorByPcgsRep,IsMultiplicativeElementWithInverse],0,COM_FUN(64));
InstallMethod(IndicesNormalSteps,"generic",true,[IsPcgs],0,COM_FUN(65));
InstallMethod(NormalSeriesByPcgs,"generic",true,[IsPcgs],0,COM_FUN(66));
InstallPcgsSeriesFromIndices:=COM_FUN(67);
InstallPcgsSeriesFromIndices(EANormalSeriesByPcgs,IndicesEANormalSteps);
InstallPcgsSeriesFromIndices(ChiefNormalSeriesByPcgs,IndicesChiefNormalSteps);
InstallPcgsSeriesFromIndices(CentralNormalSeriesByPcgs,IndicesCentralNormalSteps);
InstallPcgsSeriesFromIndices(PCentralNormalSeriesByPcgsPGroup,IndicesPCentralNormalStepsPGroup);
InstallMethod(IsPcgsElementaryAbelianSeries,"test if elm. abelian",true,[IsPcgs],0,COM_FUN(68));
InstallGlobalFunction(LiftedPcElement,COM_FUN(69));
InstallGlobalFunction(ProjectedPcElement,COM_FUN(70));
InstallGlobalFunction(ProjectedInducedPcgs,COM_FUN(71));
InstallGlobalFunction(LiftedInducedPcgs,COM_FUN(72));
BindGlobal("DoPcgsElementaryAbelianSeries",COM_FUN(73));
InstallMethod(PcgsElementaryAbelianSeries,"generic group",true,[IsGroup],0,DoPcgsElementaryAbelianSeries);
InstallOtherMethod(PcgsElementaryAbelianSeries,"group list",true,[IsList],0,DoPcgsElementaryAbelianSeries);
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/pcgs.gi"

#F  file="lib/pcgsind.gi" crc=54091002
RANK_FILTER_LIST  := [ 39812596, 21, 41951068, 17, 39812596, 21, 41951068, 
  17, 8193, 2, 39812596, 21, 8159233, 5, 39812596, 21, 8159233, 5, 8193, 2, 
  47212504, 30, 39812596, 21, 41951068, 17, 39812596, 21, 8159233, 5, 
  23521090, 25, 8193, 2, 8193, 2, 23521090, 25, 8126465, 2, 8126465, 2, 
  23521090, 25, 41951068, 17, 41951068, 17, 23521090, 25, 8126465, 2, 
  8126465, 2, 39812596, 21, 8193, 2, 8193, 2, 39812596, 21, 41951068, 17, 
  23521090, 25, 8126465, 2, 39812596, 21, 8126465, 2, 39812596, 21, 41951068, 
  17, 39812596, 21, 8126465, 2, 39812596, 21, 41951068, 17, 39812596, 21, 
  32769, 4, 38824361, 26, 55114907, 22, 28311448, 24, 39812596, 21, 8193, 2, 
  39812596, 21, 8193, 2, 1, 0, 39812596, 21, 41951068, 17, 23521090, 25, 
  32769, 4, 39812596, 21, 41951068, 17, 5, 1, 23521090, 25, 32769, 4, 5, 1, 
  39812596, 21, 41951068, 17, 1, 0, 23521090, 25, 32769, 4, 1, 0, 39812596, 
  21, 23521090, 25, 21559560, 28, 8193, 2, 23521090, 25, 21559560, 28, 8193, 
  2, 23521090, 25, 21559560, 28, 63503050, 26, 47212504, 30, 1, 0, 63503050, 
  26, 1, 0, 47212504, 30, 1, 0, 52247917, 19, 47212504, 30, 1, 0, 47212504, 
  30, 1, 0, 8193, 2, 47212504, 30, 1, 0, 40297376, 30, 1, 0, 40297376, 30, 1, 
  0, 8193, 2, 40297376, 30, 1, 0, 55114907, 22, 8193, 2 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/pcgsind.gi", 54091002 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/pcgsind.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/pcgsind.gi");
elif COM_RESULT = 3  then
Revision.pcgsind_gi:="@(#)$Id: pcgsind.gi,v 4.70 2002/04/15 10:05:12 sal Exp $";
DeclareRepresentation("IsInducedPcgsRep",IsPcgsDefaultRep,["depthsInParent","depthMapFromParent"]);
DeclareRepresentation("IsSubsetInducedPcgsRep",IsInducedPcgsRep,["parentZeroVector"]);
DeclareRepresentation("IsTailInducedPcgsRep",IsSubsetInducedPcgsRep,[]);
InstallMethod(InducedPcgsByPcSequenceNC,"pcgs, empty list",true,[IsPcgs,IsList and IsEmpty],0,COM_FUN(1));
InstallOtherMethod(InducedPcgsByPcSequenceNC,"pcgs, empty list,depths",true,[IsPcgs,IsList and IsEmpty,IsList],0,COM_FUN(2));
BindGlobal("DoInducedPcgsByPcSequenceNC",COM_FUN(3));
InstallMethod(InducedPcgsByPcSequenceNC,"pcgs, homogeneous list",IsIdenticalObj,[IsPcgs,IsCollection and IsHomogeneousList],0,DoInducedPcgsByPcSequenceNC);
InstallOtherMethod(InducedPcgsByPcSequenceNC,"pcgs, homogeneous list, depths",IsFamFamX,[IsPcgs,IsCollection and IsHomogeneousList,IsList],0,DoInducedPcgsByPcSequenceNC);
InstallMethod(LeadCoeffsIGS,"generic",true,[IsInducedPcgs and IsInducedPcgsRep and IsPrimeOrdersPcgs],0,COM_FUN(4));
InstallMethod(InducedPcgsByPcSequence,true,[IsPcgs,IsList and IsEmpty],0,COM_FUN(5));
InstallMethod(InducedPcgsByPcSequence,true,[IsPcgs,IsCollection and IsHomogeneousList],0,COM_FUN(6));
InstallMethod(InducedPcgsByPcSequenceAndGenerators,true,[IsPcgs and IsPrimeOrdersPcgs,IsList,IsList],0,COM_FUN(7));
InstallMethod(InducedPcgsByGeneratorsWithImages,true,[IsPcgs and IsPrimeOrdersPcgs,IsCollection,IsCollection],0,COM_FUN(8));
InstallOtherMethod(InducedPcgsByGeneratorsWithImages,true,[IsPcgs and IsPrimeOrdersPcgs,IsList and IsEmpty,IsList and IsEmpty],0,COM_FUN(9));
InstallMethod(CanonicalPcgsByGeneratorsWithImages,true,[IsPcgs and IsPrimeOrdersPcgs,IsCollection,IsCollection],0,COM_FUN(10));
InstallOtherMethod(CanonicalPcgsByGeneratorsWithImages,true,[IsPcgs,IsList,IsList],0,COM_FUN(11));
InstallOtherMethod(InducedPcgsByGeneratorsNC,"pcgs, empty list",true,[IsPcgs,IsList and IsEmpty],0,COM_FUN(12));
InstallMethod(InducedPcgsByGeneratorsNC,"prime order pcgs, collection",COM_FUN(13),[IsPcgs and IsPrimeOrdersPcgs,IsCollection],0,COM_FUN(14));
RedispatchOnCondition(InducedPcgsByGeneratorsNC,true,[IsPcgs,IsCollection],[IsPrimeOrdersPcgs],0);
InstallOtherMethod(InducedPcgsByGenerators,true,[IsPcgs,IsList and IsEmpty],0,COM_FUN(15));
InstallMethod(InducedPcgsByGenerators,"pcgs, collection",COM_FUN(16),[IsPcgs,IsCollection],0,COM_FUN(17));
InstallMethod(AsInducedPcgs,true,[IsPcgs,IsEmpty and IsList],0,COM_FUN(18));
InstallMethod(AsInducedPcgs,IsIdenticalObj,[IsPcgs,IsHomogeneousList],0,COM_FUN(19));
HOMOMORPHIC_IGS:=COM_FUN(20);
InstallGlobalFunction(NORMALIZE_IGS,COM_FUN(21));
InstallMethod(CanonicalPcgs,"induced prime orders pcgs",true,[IsInducedPcgs and IsPrimeOrdersPcgs],0,COM_FUN(22));
RedispatchOnCondition(CanonicalPcgs,true,[IsInducedPcgs],[IsPrimeOrdersPcgs],0);
InstallOtherMethod(CanonicalPcgs,"of an canonical pcgs",true,[IsCanonicalPcgs],SUM_FLAGS,COM_FUN(23));
InstallMethod(HomomorphicCanonicalPcgs,"pcgs, list",true,[IsPcgs,IsList],0,COM_FUN(24));
InstallOtherMethod(HomomorphicCanonicalPcgs,"pcgs, list, object",true,[IsPcgs,IsList,IsObject],0,COM_FUN(25));
InstallMethod(HomomorphicInducedPcgs,true,[IsPcgs,IsEmpty and IsList],0,COM_FUN(26));
InstallMethod(HomomorphicInducedPcgs,IsIdenticalObj,[IsPcgs and IsPrimeOrdersPcgs,IsHomogeneousList],0,COM_FUN(27));
InstallOtherMethod(HomomorphicInducedPcgs,true,[IsPcgs,IsEmpty and IsList,IsFunction],0,COM_FUN(28));
InstallOtherMethod(HomomorphicInducedPcgs,COM_FUN(29),[IsPcgs and IsPrimeOrdersPcgs,IsHomogeneousList,IsFunction],0,COM_FUN(30));
InstallOtherMethod(HomomorphicInducedPcgs,true,[IsPcgs,IsEmpty and IsList,IsObject],0,COM_FUN(31));
InstallOtherMethod(HomomorphicInducedPcgs,COM_FUN(32),[IsPcgs and IsPrimeOrdersPcgs,IsHomogeneousList,IsObject],0,COM_FUN(33));
InstallMethod(ElementaryAbelianSubseries,"generic method",true,[IsPcgs],0,COM_FUN(34));
InstallMethod(IntersectionSumPcgs,"prime orders pcgs, tail-pcgs, list",IsFamFamFam,[IsPcgs and IsPrimeOrdersPcgs,IsInducedPcgs and IsTailInducedPcgsRep,IsList],0,COM_FUN(35));
InstallMethod(NormalIntersectionPcgs,"prime orders pcgs, tail-pcgs, list",IsFamFamFam,[IsPcgs and IsPrimeOrdersPcgs,IsInducedPcgs and IsTailInducedPcgsRep,IsList],0,COM_FUN(36));
InstallMethod(NormalIntersectionPcgs,"prime orders pcgs, tail-pcgs, induced-pcgs",IsFamFamFam,[IsPcgs and IsPrimeOrdersPcgs,IsInducedPcgs and IsTailInducedPcgsRep,IsInducedPcgs and IsInducedPcgsRep],0,COM_FUN(37));
CANONICAL_PC_ELEMENT:=COM_FUN(38);
InstallMethod(CanonicalPcElement,"generic method",IsCollsElms,[IsInducedPcgs and IsInducedPcgsRep and IsPrimeOrdersPcgs,IsObject],0,CANONICAL_PC_ELEMENT);
InstallMethod(DepthOfPcElement,"induced pcgs",IsCollsElms,[IsInducedPcgs and IsInducedPcgsRep,IsObject],0,COM_FUN(39));
InstallMethod(ExponentOfPcElement,"induced pcgs",COM_FUN(40),[IsInducedPcgs and IsInducedPcgsRep and IsPrimeOrdersPcgs,IsObject,IsPosInt],0,COM_FUN(41));
InstallMethod(ExponentsOfPcElement,"induced pcgs",IsCollsElms,[IsInducedPcgs and IsInducedPcgsRep and IsPrimeOrdersPcgs,IsObject],0,COM_FUN(42));
InstallOtherMethod(ExponentsOfPcElement,"induced pcgs, subrange",IsCollsElmsX,[IsInducedPcgs and IsInducedPcgsRep and IsPrimeOrdersPcgs,IsObject,IsList],0,COM_FUN(43));
InstallMethod(SiftedPcElement,"for induced pcgs",IsCollsElms,[IsInducedPcgs and IsInducedPcgsRep and IsPrimeOrdersPcgs,IsObject],0,COM_FUN(44));
InstallMethod(ExponentsOfPcElement,"subset of induced pcgs",IsCollsElms,[IsPcgs and IsSubsetInducedPcgsRep and IsPrimeOrdersPcgs,IsObject],0,COM_FUN(45));
InstallOtherMethod(ExponentsOfPcElement,"subset of induced pcgs, subrange",IsCollsElmsX,[IsPcgs and IsSubsetInducedPcgsRep and IsPrimeOrdersPcgs,IsObject,IsList],0,COM_FUN(46));
InstallMethod(LeadingExponentOfPcElement,"subset induced pcgs",IsCollsElms,[IsPcgs and IsSubsetInducedPcgsRep and IsPrimeOrdersPcgs,IsObject],0,COM_FUN(47));
InstallMethod(ExtendedPcgs,"induced pcgs",IsIdenticalObj,[IsInducedPcgs,IsList],0,COM_FUN(48));
InstallGlobalFunction(CorrespondingGeneratorsByModuloPcgs,COM_FUN(49));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/pcgsind.gi"

#F  file="lib/pcgsmodu.gi" crc=-32146057
RANK_FILTER_LIST  := [ 53460738, 20, 52247917, 19, 53460738, 20, 53460738, 
  20, 1, 0, 17, 18, 53460738, 20, 53460738, 20, 52247917, 19, 39812596, 21, 
  8193, 2, 39812596, 21, 39812596, 21, 8193, 2, 55114907, 22, 39812596, 21, 
  55114907, 22, 39812596, 21, 39812596, 21, 55114907, 22, 55114907, 22, 
  53460738, 20, 53460738, 20, 39812596, 21, 39812596, 21, 53460738, 20, 1, 0, 
  17, 18, 53460738, 20, 1, 0, 52247917, 19, 53460738, 20, 1, 0, 8193, 2, 
  53460738, 20, 53460738, 20, 53460738, 20, 1, 0, 53460738, 20, 41951068, 17, 
  53460738, 20, 38054488, 29, 53460738, 20, 65077475, 29, 53460738, 20, 
  41951068, 17, 8193, 2, 53460738, 20, 8193, 2, 38054488, 29, 53460738, 20, 
  8193, 2, 65077475, 29, 53460738, 20, 1, 0, 1, 0, 53460738, 20, 37169232, 
  24, 37169232, 24, 1, 0, 53459883, 24, 1, 0, 53459883, 24, 1, 0, 53459883, 
  24, 1, 0, 8193, 2, 53459988, 25, 1, 0, 53459988, 25, 1, 0, 8193, 2, 
  53459988, 25, 1, 0, 52247917, 19, 53460738, 20, 65767820, 5, 65767820, 5, 
  53460738, 20, 53460738, 20, 45666457, 26, 45666457, 26, 39812596, 21, 
  39812596, 21, 53660808, 21, 53660808, 21, 55004796, 32, 38054488, 29, 
  55004796, 32, 38054488, 29, 38054488, 29, 55004796, 32, 65077475, 29, 
  55004796, 32, 38054488, 29, 65077475, 29, 55004796, 32, 65767820, 5, 
  65767820, 5, 55046865, 26, 1, 0, 8193, 2, 55046865, 26, 1, 0, 55046865, 26, 
  52247917, 19, 52247917, 19, 55046865, 26, 52247917, 19 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/pcgsmodu.gi", -32146057 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/pcgsmodu.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/pcgsmodu.gi");
elif COM_RESULT = 3  then
Revision.pcgsmodu_gi:="@(#)$Id: pcgsmodu.gi,v 4.47 2002/04/15 10:05:12 sal Exp $";
DeclareRepresentation("IsModuloPcgsRep",IsPcgsDefaultRep,["moduloDepths","moduloMap","numerator","denominator","depthMap"]);
DeclareRepresentation("IsModuloTailPcgsRep",IsModuloPcgsRep,["moduloDepths","moduloMap","numerator","denominator","depthMap"]);
DeclareRepresentation("IsSubsetInducedNumeratorModuloTailPcgsRep",IsModuloTailPcgsRep,["moduloDepths","moduloMap","numerator","denominator","depthMap","depthsInParent","numeratorParent","parentZeroVector"]);
DeclareRepresentation("IsModuloTailPcgsByListRep",IsModuloTailPcgsRep,["moduloDepths","moduloMap","numerator","denominator","depthMap","depthsInParent","numeratorParent","parentZeroVector"]);
DeclareRepresentation("IsNumeratorParentForExponentsRep",IsModuloPcgsRep,["moduloDepths","moduloMap","numerator","denominator","depthMap","depthsInParent","numeratorParent","parentZeroVector"]);
InstallMethod(IsBound\[\],true,[IsModuloPcgs,IsPosInt],0,COM_FUN(1));
InstallMethod(Length,"modulo pcgs",true,[IsModuloPcgs],0,COM_FUN(2));
InstallMethod(Position,"modulo pcgs",true,[IsModuloPcgs,IsObject,IsInt],0,COM_FUN(3));
InstallMethod(PrintObj,"modulo pcgs",true,[IsModuloPcgs],0,COM_FUN(4));
InstallMethod(\[\],"modulo pcgs",true,[IsModuloPcgs,IsPosInt],0,COM_FUN(5));
InstallGlobalFunction(ModuloTailPcgsByList,COM_FUN(6));
InstallMethod(ModuloPcgsByPcSequenceNC,"generic method for pcgs mod pcgs",true,[IsPcgs,IsList,IsPcgs],0,COM_FUN(7));
InstallMethod(ModuloPcgsByPcSequence,"generic method",true,[IsPcgs,IsList,IsInducedPcgs],0,COM_FUN(8));
InstallMethod(MOD,"parent pcgs mod induced pcgs",IsIdenticalObj,[IsPcgs,IsInducedPcgs],0,COM_FUN(9));
InstallMethod(MOD,"two parent pcgs",IsIdenticalObj,[IsPcgs,IsPcgs],0,COM_FUN(10));
InstallMethod(MOD,"two induced pcgs",IsIdenticalObj,[IsInducedPcgs,IsInducedPcgs],0,COM_FUN(11));
InstallMethod(MOD,"two modulo pcgs",IsIdenticalObj,[IsModuloPcgs,IsModuloPcgs],0,COM_FUN(12));
InstallMethod(MOD,"two induced pcgs",IsIdenticalObj,[IsPcgs,IsPcgs],0,COM_FUN(13));
InstallOtherMethod(DepthOfPcElement,"pcgs modulo pcgs, ignoring <min>",COM_FUN(14),[IsModuloPcgs,IsObject,IsInt],0,COM_FUN(15));
InstallOtherMethod(ExponentOfPcElement,"pcgs modulo pcgs, ExponentsOfPcElement",IsCollsElmsX,[IsModuloPcgs,IsObject,IsPosInt],0,COM_FUN(16));
InstallOtherMethod(ExponentsOfPcElement,"pcgs mod. pcgs,range, falling back to Exp.OfPcElement",IsCollsElmsX,[IsModuloPcgs,IsObject,IsList],0,COM_FUN(17));
InstallOtherMethod(IsFiniteOrdersPcgs,true,[IsModuloPcgs],0,COM_FUN(18));
InstallOtherMethod(IsPrimeOrdersPcgs,true,[IsModuloPcgs],0,COM_FUN(19));
InstallOtherMethod(LeadingExponentOfPcElement,"pcgs modulo pcgs, use ExponentsOfPcElement",IsCollsElms,[IsModuloPcgs,IsObject],0,COM_FUN(20));
InstallOtherMethod(PcElementByExponentsNC,"generic method for empty lists",true,[IsModuloPcgs,IsList and IsEmpty],0,COM_FUN(21));
InstallOtherMethod(PcElementByExponentsNC,"generic method: modulo",true,[IsModuloPcgs,IsRowVector and IsCyclotomicCollection],0,COM_FUN(22));
InstallOtherMethod(PcElementByExponentsNC,"generic method: modulo, FFE",true,[IsModuloPcgs,IsRowVector and IsFFECollection],0,COM_FUN(23));
InstallOtherMethod(PcElementByExponentsNC,"generic method for empty list as basis or basisindex, modulo",true,[IsModuloPcgs,IsList and IsEmpty,IsList],SUM_FLAGS,COM_FUN(24));
InstallOtherMethod(PcElementByExponentsNC,"generic method: modulo, basis",IsFamFamX,[IsModuloPcgs,IsList,IsRowVector and IsCyclotomicCollection],0,COM_FUN(25));
InstallOtherMethod(PcElementByExponentsNC,"generic method: modulo, basis, FFE",IsFamFamX,[IsModuloPcgs,IsList,IsRowVector and IsFFECollection],0,COM_FUN(26));
InstallOtherMethod(ReducedPcElement,"pcgs modulo pcgs",IsCollsElmsElms,[IsModuloPcgs,IsObject,IsObject],0,COM_FUN(27));
InstallOtherMethod(RelativeOrderOfPcElement,"pcgs modulo pcgs",IsCollsElms,[IsModuloPcgs and IsPrimeOrdersPcgs,IsObject],RankFilter(IsModuloPcgs)-RankFilter(IsModuloPcgs and IsPrimeOrdersPcgs),COM_FUN(28));
InstallOtherMethod(DepthOfPcElement,"pcgs modulo pcgs",IsCollsElms,[IsModuloPcgs and IsModuloPcgsRep,IsObject],0,COM_FUN(29));
InstallOtherMethod(ExponentsOfPcElement,"pcgs modulo pcgs",IsCollsElms,[IsModuloPcgs and IsModuloPcgsRep,IsObject],0,COM_FUN(30));
InstallOtherMethod(ExponentsOfPcElement,"pcgs modulo pcgs, subrange",IsCollsElmsX,[IsModuloPcgs and IsModuloPcgsRep,IsObject,IsList],0,COM_FUN(31));
InstallOtherMethod(ExponentsOfPcElement,"pcgs modulo tail-pcgs",IsCollsElms,[IsModuloPcgs and IsModuloTailPcgsRep,IsObject],0,COM_FUN(32));
InstallOtherMethod(ExponentsOfPcElement,"pcgs modulo tail-pcgs, subrange",IsCollsElmsX,[IsModuloPcgs and IsModuloTailPcgsRep,IsObject,IsList],0,COM_FUN(33));
InstallOtherMethod(ExponentOfPcElement,"pcgs modulo tail-pcgs, ExponentsOfPcElement",IsCollsElmsX,[IsModuloPcgs and IsModuloTailPcgsRep,IsObject,IsPosInt],0,COM_FUN(34));
InstallMethod(ExponentsConjugateLayer,"default: compute brute force",IsCollsElmsElms,[IsModuloPcgs,IsMultiplicativeElementWithInverse,IsMultiplicativeElementWithInverse],0,COM_FUN(35));
InstallMethod(PcGroupWithPcgs,"pcgs modulo pcgs",true,[IsModuloPcgs],0,COM_FUN(36));
InstallOtherMethod(GroupOfPcgs,true,[IsModuloPcgs],0,COM_FUN(37));
InstallMethod(NumeratorOfModuloPcgs,"modolo-tail-pcgs-by-list-rep",true,[IsModuloPcgs and IsModuloTailPcgsByListRep],0,COM_FUN(38));
InstallMethod(DenominatorOfModuloPcgs,"modolo-tail-pcgs-by-list-rep",true,[IsModuloPcgs and IsModuloTailPcgsByListRep],0,COM_FUN(39));
InstallMethod(NumeratorOfModuloPcgs,"for pcgs",true,[IsPcgs],0,COM_FUN(40));
InstallMethod(DenominatorOfModuloPcgs,"for pcgs",true,[IsPcgs],0,COM_FUN(41));
InstallMethod(ModuloPcgs,"for groups",IsIdenticalObj,[IsGroup,IsGroup],0,COM_FUN(42));
InstallMethod(PcElementByExponentsNC,"modulo subset induced wrt family pcgs",true,[IsModuloPcgs and IsSubsetInducedNumeratorModuloTailPcgsRep and IsPrimeOrdersPcgs and IsNumeratorParentPcgsFamilyPcgs,IsRowVector and IsCyclotomicCollection],0,COM_FUN(43));
InstallOtherMethod(PcElementByExponentsNC,"modulo subset induced wrt family pcgs,index",true,[IsModuloPcgs and IsSubsetInducedNumeratorModuloTailPcgsRep and IsPrimeOrdersPcgs and IsNumeratorParentPcgsFamilyPcgs,IsRowVector and IsCyclotomicCollection,IsRowVector and IsCyclotomicCollection],0,COM_FUN(44));
InstallMethod(PcElementByExponentsNC,"modulo subset induced wrt family pcgs, FFE",true,[IsModuloPcgs and IsSubsetInducedNumeratorModuloTailPcgsRep and IsPrimeOrdersPcgs and IsNumeratorParentPcgsFamilyPcgs,IsRowVector and IsFFECollection],0,COM_FUN(45));
InstallOtherMethod(PcElementByExponentsNC,"modulo subset induced wrt family pcgs, FFE, index",true,[IsModuloPcgs and IsSubsetInducedNumeratorModuloTailPcgsRep and IsPrimeOrdersPcgs and IsNumeratorParentPcgsFamilyPcgs,IsRowVector and IsCyclotomicCollection,IsRowVector and IsFFECollection],0,COM_FUN(46));
InstallMethod(ExponentsConjugateLayer,"subset induced modulo pcgs",IsCollsElmsElms,[IsModuloPcgs and IsSubsetInducedNumeratorModuloTailPcgsRep and IsPrimeOrdersPcgs and IsNumeratorParentPcgsFamilyPcgs,IsMultiplicativeElementWithInverse,IsMultiplicativeElementWithInverse],0,COM_FUN(47));
InstallOtherMethod(ExponentsOfPcElement,"subset induced pcgs modulo tail-pcgs, subrange",IsCollsElmsX,[IsModuloPcgs and IsModuloTailPcgsRep and IsNumeratorParentForExponentsRep,IsObject,IsList],0,COM_FUN(48));
InstallOtherMethod(ExponentsOfPcElement,"subset induced pcgs modulo tail-pcgs",IsCollsElms,[IsModuloPcgs and IsModuloTailPcgsRep and IsNumeratorParentForExponentsRep,IsObject],0,COM_FUN(49));
InstallOtherMethod(ExponentsOfConjugate,"subset induced pcgs modulo tail-pcgs",true,[IsModuloPcgs and IsModuloTailPcgsRep and IsNumeratorParentForExponentsRep,IsPosInt,IsPosInt],0,COM_FUN(50));
InstallOtherMethod(ExponentsOfRelativePower,"subset induced pcgs modulo tail-pcgs",true,[IsModuloPcgs and IsModuloTailPcgsRep and IsNumeratorParentForExponentsRep,IsPosInt],0,COM_FUN(51));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/pcgsmodu.gi"

#F  file="lib/pcgspcg.gi" crc=-8838266
RANK_FILTER_LIST  := [ 47477126, 3, 32769, 4, 67108505, 2, 32769, 4, 
  67108505, 2, 41951068, 17, 67108505, 2, 32769, 4, 67108505, 2, 41951068, 
  17, 8041300, 76, 65767820, 5, 8041300, 76, 15993088, 6, 8041300, 76, 
  15993088, 6, 8041300, 76, 15993088, 6, 8041300, 76, 38054488, 29, 8041300, 
  76, 65077475, 29, 8041300, 76, 38054488, 29, 38054488, 29, 8041300, 76, 
  38054488, 29, 65077475, 29, 19326366, 52, 38054488, 29, 19326366, 52, 
  38054488, 29, 38054488, 29, 19326366, 52, 65077475, 29, 19326366, 52, 
  38054488, 29, 65077475, 29, 12581563, 49, 65767820, 5, 65767820, 5, 588550, 
  49, 14157315, 109, 8041300, 76, 14157315, 109, 8041300, 76, 14157315, 109, 
  52247917, 19, 8041300, 76, 65273107, 103, 8041300, 76, 65273107, 103, 8193, 
  2, 8041300, 76, 14157315, 109, 17, 18, 8041300, 76, 14157315, 109, 17, 18, 
  8041300, 76, 14157315, 109, 588550, 49, 12322502, 109, 8041300, 76, 
  12322502, 109, 8041300, 76, 12322502, 109, 52247917, 19, 8041300, 76, 
  63438294, 103, 8041300, 76, 63438294, 103, 8193, 2, 8041300, 76, 12322502, 
  109, 17, 18, 8041300, 76, 12322502, 109, 17, 18, 8041300, 76, 12322502, 
  109, 588550, 49, 8652876, 109, 8041300, 76, 8652876, 109, 8041300, 76, 
  8652876, 109, 52247917, 19, 8041300, 76, 59768668, 103, 8041300, 76, 
  59768668, 103, 8193, 2, 8041300, 76, 8652876, 109, 17, 18, 8041300, 76, 
  8652876, 109, 17, 18, 8041300, 76, 8652876, 109, 8041300, 76, 52247917, 19, 
  52247917, 19, 8041300, 76, 52247917, 19, 8041300, 76, 65767820, 5, 
  52247917, 19, 844191, 25, 1, 0, 4017945, 26, 1, 0, 844191, 25, 1, 0, 
  52247917, 19, 4017945, 26, 1, 0, 52247917, 19, 844191, 25, 1, 0, 844191, 
  25, 1, 0, 8193, 2, 4017945, 26, 1, 0, 4017945, 26, 1, 0, 8193, 2, 844191, 
  25, 1, 0, 4017945, 26, 1, 0, 4017945, 26, 65767820, 5, 52247917, 19, 
  50331304, 4, 50331304, 4 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/pcgspcg.gi", -8838266 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/pcgspcg.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/pcgspcg.gi");
elif COM_RESULT = 3  then
Revision.pcgspcg_gi:="@(#)$Id: pcgspcg.gi,v 4.47 2002/04/15 10:05:12 sal Exp $";
DeclareRepresentation("IsUnsortedPcgsRep",IsPcgsDefaultRep,[]);
DeclareRepresentation("IsSortedPcgsRep",IsUnsortedPcgsRep,[]);
InstallMethod(PcgsByPcSequenceNC,"elements family by rws with defining pcgs",true,[IsElementsFamilyByRws and HasDefiningPcgs,IsHomogeneousList],0,COM_FUN(1));
InstallMethod(PcgsByPcSequenceNC,"elements family by rws",true,[IsElementsFamilyByRws,IsHomogeneousList],0,COM_FUN(2));
InstallMethod(PcgsByPcSequenceNC,"elements family by rws, empty sequence",true,[IsElementsFamilyByRws,IsList and IsEmpty],0,COM_FUN(3));
InstallMethod(PcgsByPcSequence,true,[IsElementsFamilyByRws,IsHomogeneousList],0,COM_FUN(4));
InstallMethod(PcgsByPcSequence,true,[IsElementsFamilyByRws,IsList and IsEmpty],0,COM_FUN(5));
InstallMethod(SiftedPcElement,"family pcgs",IsCollsElms,[IsPcgs and IsFamilyPcgs,IsMultiplicativeElementWithInverse],0,COM_FUN(6));
InstallMethod(DepthOfPcElement,"family pcgs",IsCollsElms,[IsPcgs and IsFamilyPcgs,IsMultiplicativeElementWithInverseByRws],0,COM_FUN(7));
InstallMethod(ExponentsOfPcElement,"family pcgs",IsCollsElms,[IsPcgs and IsFamilyPcgs,IsMultiplicativeElementWithInverseByRws],0,COM_FUN(8));
InstallMethod(LeadingExponentOfPcElement,"family pcgs",IsCollsElms,[IsPcgs and IsFamilyPcgs,IsMultiplicativeElementWithInverseByRws],0,COM_FUN(9));
InstallMethod(PcElementByExponentsNC,"family pcgs",true,[IsPcgs and IsFamilyPcgs,IsRowVector and IsCyclotomicCollection],0,COM_FUN(10));
InstallMethod(PcElementByExponentsNC,"family pcgs, FFE",true,[IsPcgs and IsFamilyPcgs,IsRowVector and IsFFECollection],0,COM_FUN(11));
InstallOtherMethod(PcElementByExponentsNC,"family pcgs, index",true,[IsPcgs and IsFamilyPcgs,IsRowVector and IsCyclotomicCollection,IsRowVector and IsCyclotomicCollection],0,COM_FUN(12));
InstallOtherMethod(PcElementByExponentsNC,"family pcgs, basisind, FFE",true,[IsPcgs and IsFamilyPcgs,IsRowVector and IsCyclotomicCollection,IsRowVector and IsFFECollection],0,COM_FUN(13));
InstallMethod(PcElementByExponentsNC,"subset induced wrt family pcgs",true,[IsPcgs and IsParentPcgsFamilyPcgs and IsSubsetInducedPcgsRep and IsPrimeOrdersPcgs,IsRowVector and IsCyclotomicColle\
ction],0,COM_FUN(14));
InstallOtherMethod(PcElementByExponentsNC,"subset induced wrt family pcgs, index",true,[IsPcgs and IsParentPcgsFamilyPcgs and IsSubsetInducedPcgsRep and IsPrimeOrdersPcgs,IsRowVector and IsCyclotomicColle\
ction,IsRowVector and IsCyclotomicCollection],0,COM_FUN(15));
InstallMethod(PcElementByExponentsNC,"subset induced wrt family pcgs, FFE",true,[IsPcgs and IsParentPcgsFamilyPcgs and IsSubsetInducedPcgsRep and IsPrimeOrdersPcgs,IsRowVector and IsFFECollection],0,COM_FUN(16));
InstallOtherMethod(PcElementByExponentsNC,"subset induced wrt family pcgs, FFE,index",true,[IsPcgs and IsParentPcgsFamilyPcgs and IsSubsetInducedPcgsRep and IsPrimeOrdersPcgs,IsRowVector and IsCyclotomicColle\
ction,IsRowVector and IsFFECollection],0,COM_FUN(17));
InstallGlobalFunction(DoExponentsConjLayerFampcgs,COM_FUN(18));
InstallMethod(ExponentsConjugateLayer,"subset induced pcgs",IsCollsElmsElms,[IsTailInducedPcgsRep and IsParentPcgsFamilyPcgs,IsMultiplicativeElementWithInverse,IsMultiplicativeElementWithInverse],0,COM_FUN(19));
InstallMethod(CanonicalPcElement,"tail induced pcgs, 8bits word",IsCollsElms,[IsInducedPcgs and IsTailInducedPcgsRep and IsParentPcgsFamilyPcgs,IsMultiplicativeElementWithInverseByRws and Is8BitsPcWordRep],0,COM_FUN(20));
InstallMethod(DepthOfPcElement,"family pcgs (8 bits)",IsCollsElms,[IsPcgs and IsFamilyPcgs,IsMultiplicativeElementWithInverseByRws and Is8BitsPcWordRep],0,8Bits_DepthOfPcElement);
InstallMethod(ExponentOfPcElement,"family pcgs (8bits)",IsCollsElmsX,[IsPcgs and IsFamilyPcgs,IsMultiplicativeElementWithInverseByRws and Is8BitsPcWordRep,IsPosInt],0,8Bits_ExponentOfPcElement);
InstallMethod(ExponentsOfPcElement,"family pcgs/8 bit",IsCollsElms,[IsPcgs and IsFamilyPcgs,Is8BitsPcWordRep],0,8Bits_ExponentsOfPcElement);
InstallOtherMethod(ExponentsOfPcElement,"family pcgs/8 bit",IsCollsElmsX,[IsPcgs and IsFamilyPcgs,Is8BitsPcWordRep,IsList],0,COM_FUN(21));
InstallMethod(HeadPcElementByNumber,"family pcgs (8bits)",IsCollsElmsX,[IsPcgs and IsFamilyPcgs,IsMultiplicativeElementWithInverseByRws and Is8BitsPcWordRep,IsInt],0,COM_FUN(22));
InstallMethod(CleanedTailPcElement,"family pcgs (8bits)",IsCollsElmsX,[IsPcgs and IsFamilyPcgs,IsMultiplicativeElementWithInverseByRws and Is8BitsPcWordRep,IsInt],0,COM_FUN(23));
InstallMethod(LeadingExponentOfPcElement,"family pcgs (8 bits)",IsCollsElms,[IsPcgs and IsFamilyPcgs,IsMultiplicativeElementWithInverseByRws and Is8BitsPcWordRep],0,8Bits_LeadingExponentOfPcElement);
InstallMethod(CanonicalPcElement,"tail induced pcgs, 16bits word",IsCollsElms,[IsInducedPcgs and IsTailInducedPcgsRep and IsParentPcgsFamilyPcgs,IsMultiplicativeElementWithInverseByRws and Is16BitsPcWordRep],0,COM_FUN(24));
InstallMethod(DepthOfPcElement,"family pcgs (16 bits)",IsCollsElms,[IsPcgs and IsFamilyPcgs,IsMultiplicativeElementWithInverseByRws and Is16BitsPcWordRep],0,16Bits_DepthOfPcElement);
InstallMethod(ExponentOfPcElement,"family pcgs (16bits)",IsCollsElmsX,[IsPcgs and IsFamilyPcgs,IsMultiplicativeElementWithInverseByRws and Is16BitsPcWordRep,IsPosInt],0,16Bits_ExponentOfPcElement);
InstallMethod(ExponentsOfPcElement,"family pcgs/16 bit",IsCollsElms,[IsPcgs and IsFamilyPcgs,Is16BitsPcWordRep],0,16Bits_ExponentsOfPcElement);
InstallOtherMethod(ExponentsOfPcElement,"family pcgs/16 bit",IsCollsElmsX,[IsPcgs and IsFamilyPcgs,Is16BitsPcWordRep,IsList],0,COM_FUN(25));
InstallMethod(HeadPcElementByNumber,"family pcgs (16bits)",IsCollsElmsX,[IsPcgs and IsFamilyPcgs,IsMultiplicativeElementWithInverseByRws and Is16BitsPcWordRep,IsInt],0,COM_FUN(26));
InstallMethod(CleanedTailPcElement,"family pcgs (16bits)",IsCollsElmsX,[IsPcgs and IsFamilyPcgs,IsMultiplicativeElementWithInverseByRws and Is16BitsPcWordRep,IsInt],0,COM_FUN(27));
InstallMethod(LeadingExponentOfPcElement,"family pcgs (16 bits)",IsCollsElms,[IsPcgs and IsFamilyPcgs,IsMultiplicativeElementWithInverseByRws and Is16BitsPcWordRep],0,16Bits_LeadingExponentOfPcElement);
InstallMethod(CanonicalPcElement,"tail induced pcgs, 32bits word",IsCollsElms,[IsInducedPcgs and IsTailInducedPcgsRep and IsParentPcgsFamilyPcgs,IsMultiplicativeElementWithInverseByRws and Is32BitsPcWordRep],0,COM_FUN(28));
InstallMethod(DepthOfPcElement,"family pcgs (32 bits)",IsCollsElms,[IsPcgs and IsFamilyPcgs,IsMultiplicativeElementWithInverseByRws and Is32BitsPcWordRep],0,32Bits_DepthOfPcElement);
InstallMethod(ExponentOfPcElement,"family pcgs (32bits)",IsCollsElmsX,[IsPcgs and IsFamilyPcgs,IsMultiplicativeElementWithInverseByRws and Is32BitsPcWordRep,IsPosInt],0,32Bits_ExponentOfPcElement);
InstallMethod(ExponentsOfPcElement,"family pcgs/32 bit",IsCollsElms,[IsPcgs and IsFamilyPcgs,Is32BitsPcWordRep],0,32Bits_ExponentsOfPcElement);
InstallOtherMethod(ExponentsOfPcElement,"family pcgs/32 bit",IsCollsElmsX,[IsPcgs and IsFamilyPcgs,Is32BitsPcWordRep,IsList],0,COM_FUN(29));
InstallMethod(HeadPcElementByNumber,"family pcgs (32bits)",IsCollsElmsX,[IsPcgs and IsFamilyPcgs,IsMultiplicativeElementWithInverseByRws and Is32BitsPcWordRep,IsInt],0,COM_FUN(30));
InstallMethod(CleanedTailPcElement,"family pcgs (32bits)",IsCollsElmsX,[IsPcgs and IsFamilyPcgs,IsMultiplicativeElementWithInverseByRws and Is32BitsPcWordRep,IsInt],0,COM_FUN(31));
InstallMethod(LeadingExponentOfPcElement,"family pcgs (32 bits)",IsCollsElms,[IsPcgs and IsFamilyPcgs,IsMultiplicativeElementWithInverseByRws and Is32BitsPcWordRep],0,32Bits_LeadingExponentOfPcElement);
InstallMethod(ExponentsOfConjugate,"family pcgs: look up",true,[IsPcgs and IsFamilyPcgs,IsPosInt,IsPosInt],0,COM_FUN(32));
InstallMethod(ExponentsOfRelativePower,"family pcgs: look up",true,[IsPcgs and IsFamilyPcgs,IsPosInt],0,COM_FUN(33));
InstallMethod(CleanedTailPcElement,"family pcgs",IsCollsElmsX,[IsPcgs and IsFamilyPcgs,IsMultiplicativeElementWithInverse,IsPosInt],0,COM_FUN(34));
InstallMethod(DepthOfPcElement,"unsorted pcgs",IsCollsElms,[IsPcgs and IsUnsortedPcgsRep,IsObject],0,COM_FUN(35));
InstallMethod(DepthOfPcElement,"sorted pcgs",IsCollsElms,[IsPcgs and IsSortedPcgsRep,IsObject],0,COM_FUN(36));
InstallMethod(ExponentOfPcElement,"unsorted pcgs",IsCollsElmsX,[IsPcgs and IsUnsortedPcgsRep,IsObject,IsPosInt],0,COM_FUN(37));
InstallMethod(ExponentOfPcElement,"sorted pcgs",IsCollsElmsX,[IsPcgs and IsSortedPcgsRep,IsObject,IsPosInt],0,COM_FUN(38));
InstallMethod(ExponentsOfPcElement,"unsorted pcgs",IsCollsElms,[IsPcgs and IsUnsortedPcgsRep,IsObject],0,COM_FUN(39));
InstallOtherMethod(ExponentsOfPcElement,"unsorted pcgs/range",IsCollsElmsX,[IsPcgs and IsUnsortedPcgsRep,IsObject,IsList],0,COM_FUN(40));
ExpPcElmSortedFun:=COM_FUN(41);
InstallMethod(ExponentsOfPcElement,"sorted pcgs",IsCollsElms,[IsPcgs and IsSortedPcgsRep,IsObject],0,COM_FUN(42));
InstallOtherMethod(ExponentsOfPcElement,"sorted pcgs/range",IsCollsElmsX,[IsPcgs and IsSortedPcgsRep,IsObject,IsList],0,ExpPcElmSortedFun);
InstallMethod(LeadingExponentOfPcElement,"unsorted pcgs",IsCollsElms,[IsPcgs and IsUnsortedPcgsRep,IsObject],0,COM_FUN(43));
InstallMethod(LeadingExponentOfPcElement,"sorted pcgs",IsCollsElms,[IsPcgs and IsSortedPcgsRep,IsObject],0,COM_FUN(44));
InstallMethod(CleanedTailPcElement,"sorted pcgs - defer to sorting pcgs",IsCollsElmsX,[IsPcgs and IsSortedPcgsRep,IsMultiplicativeElementWithInverse,IsPosInt],0,COM_FUN(45));
InstallMethod(Order,"method for a pc-element",HasDefiningPcgs,[IsMultiplicativeElementWithOne],3,COM_FUN(46));
InstallMethod(PrimePowerComponents,"method for a pc element",HasDefiningPcgs,[IsMultiplicativeElementWithOne],0,COM_FUN(47));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/pcgspcg.gi"

#F  file="lib/pcgscomp.gi" crc=-55152298
RANK_FILTER_LIST  := [ 1985, 1, 32769, 4, 1985, 1, 41951068, 17, 1985, 1, 
  32769, 4, 1985, 1, 41951068, 17, 53660808, 21, 39812596, 21, 1, 0, 
  39812596, 21, 39812596, 21 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/pcgscomp.gi", -55152298 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/pcgscomp.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/pcgscomp.gi");
elif COM_RESULT = 3  then
Revision.pcgscomp_gi:="@(#)$Id: pcgscomp.gi,v 4.27 2002/04/15 10:05:12 sal Exp $";
InstallMethod(PcgsByPcSequenceNC,"pc series",true,[IsFamily,IsHomogeneousList],0,COM_FUN(1));
InstallMethod(PcgsByPcSequenceNC,"pc series, empty sequence",true,[IsFamily,IsList and IsEmpty],0,COM_FUN(2));
InstallMethod(PcgsByPcSequence,true,[IsFamily,IsHomogeneousList],0,COM_FUN(3));
InstallMethod(PcgsByPcSequence,true,[IsFamily,IsList and IsEmpty],0,COM_FUN(4));
InstallMethod(Pcgs,"generic method using CompositionSeries",true,[IsGroup],0,COM_FUN(5));
InstallMethod(ExponentsOfPcElement,"pc series",IsCollsElms,[IsPcgs,IsObject],0,COM_FUN(6));
InstallMethod(RelativeOrders,"pc series",true,[IsPcgs],0,COM_FUN(7));
InstallMethod(PcSeries,"construct subgroups",true,[IsPcgs],0,COM_FUN(8));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/pcgscomp.gi"

#F  file="lib/pcgsperm.gi" crc=78755101
RANK_FILTER_LIST  := [ 15408791, 29, 46365208, 30, 58948660, 26, 58948660, 
  26, 45271600, 30, 51599439, 31, 27991283, 27, 27991283, 27, 13483603, 29, 
  58727864, 33, 11228408, 32, 13483603, 29, 58727864, 33, 13483603, 29, 513, 
  8, 13483603, 29, 513, 8, 52247917, 19, 13483603, 29, 513, 8, 13483603, 29, 
  513, 8, 13483603, 29, 513, 8, 40093620, 27, 13483603, 29, 513, 8, 41951068, 
  17, 13483603, 29, 513, 8, 52247917, 19, 28494189, 31, 513, 8, 513, 8, 5, 1, 
  45271600, 30, 45271600, 30, 45271600, 30, 45271600, 30, 28483029, 37 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/pcgsperm.gi", 78755101 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/pcgsperm.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/pcgsperm.gi");
elif COM_RESULT = 3  then
Revision.pcgsperm_gi:="@(#)$Id: pcgsperm.gi,v 4.120.2.1 2005/05/03 09:22:10 gap Exp $";
DeclareRepresentation("IsMemberPcSeriesPermGroup",IsPermGroup,["noInSeries"]);
InstallGlobalFunction(AddNormalizingElementPcgs,COM_FUN(1));
InstallGlobalFunction(ExtendSeriesPermGroup,COM_FUN(2));
InstallGlobalFunction(TryPcgsPermGroup,COM_FUN(3));
InstallGlobalFunction(PcgsStabChainSeries,COM_FUN(4));
BindGlobal("NorSerPermPcgs",COM_FUN(5));
InstallMethod(EANormalSeriesByPcgs,"perm group rep",true,[IsPcgs and IsPcgsElementaryAbelianSeries and IsPcgsPermGroupRep],0,NorSerPermPcgs);
InstallOtherMethod(EANormalSeriesByPcgs,"perm group modulo rep",true,[IsModuloPcgsPermGroupRep and IsPcgsElementaryAbelianSeries],0,NorSerPermPcgs);
InstallGlobalFunction(PcgsMemberPcSeriesPermGroup,COM_FUN(6));
InstallGlobalFunction(ExponentsOfPcElementPermGroup,COM_FUN(7));
InstallGlobalFunction(PermpcgsPcGroupPcgs,COM_FUN(8));
InstallGlobalFunction(SolvableNormalClosurePermGroup,COM_FUN(9));
InstallOtherMethod(NumeratorOfModuloPcgs,true,[IsModuloPcgsPermGroupRep],0,COM_FUN(10));
InstallOtherMethod(DenominatorOfModuloPcgs,true,[IsModuloPcgsPermGroupRep],0,COM_FUN(11));
InstallMethod(Pcgs,"Sims's method",true,[IsPermGroup],100,COM_FUN(12));
InstallMethod(Pcgs,"tail of perm pcgs",true,[IsMemberPcSeriesPermGroup],100,PcgsMemberPcSeriesPermGroup);
InstallMethod(GroupOfPcgs,true,[IsPcgs and IsPcgsPermGroupRep],0,COM_FUN(13));
InstallMethod(PcSeries,true,[IsPcgs and IsPcgsPermGroupRep],0,COM_FUN(14));
InstallGlobalFunction(TailOfPcgsPermGroup,COM_FUN(15));
InstallMethod(InducedPcgsByPcSequenceNC,"tail of perm pcgs",true,[IsPcgsPermGroupRep and IsPrimeOrdersPcgs and IsPcgs,IsList and IsPermCollection],0,COM_FUN(16));
InstallMethod(InducedPcgsWrtHomePcgs,"tail of perm pcgs",true,[IsMemberPcSeriesPermGroup and HasHomePcgs],0,COM_FUN(17));
InstallMethod(ExtendedPcgs,"perm pcgs",true,[IsPcgs and IsPcgsPermGroupRep and IsPrimeOrdersPcgs,IsList and IsPermCollection],0,COM_FUN(18));
InstallMethod(DepthOfPcElement,"permpcgs",true,[IsPcgs and IsPcgsPermGroupRep and IsPrimeOrdersPcgs,IsPerm],0,COM_FUN(19));
InstallOtherMethod(DepthOfPcElement,"permpcgs,start",true,[IsPcgs and IsPcgsPermGroupRep and IsPrimeOrdersPcgs,IsPerm,IsPosInt],0,COM_FUN(20));
InstallMethod(LeadingExponentOfPcElement,true,[IsPcgs and IsPcgsPermGroupRep and IsPrimeOrdersPcgs,IsPerm],0,COM_FUN(21));
InstallMethod(ExponentsOfPcElement,"perm group",true,[IsPcgs and IsPcgsPermGroupRep and IsPrimeOrdersPcgs,IsPerm],0,COM_FUN(22));
InstallOtherMethod(ExponentsOfPcElement,"perm group with positions",true,[IsPcgs and IsPcgsPermGroupRep and IsPrimeOrdersPcgs,IsPerm,IsList and IsCyclotomicCollection],0,COM_FUN(23));
InstallOtherMethod(ExponentsOfPcElement,"perm group with 0 positions",true,[IsPcgs and IsPcgsPermGroupRep and IsPrimeOrdersPcgs,IsPerm,IsList and IsEmpty],0,COM_FUN(24));
InstallMethod(ExponentOfPcElement,true,[IsPcgs and IsPcgsPermGroupRep and IsPrimeOrdersPcgs,IsPerm,IsPosInt],0,COM_FUN(25));
InstallOtherMethod(RepresentativeActionOp,"cycle structure comparison for solvable perm groups",true,[IsPermGroup and CanEasilyComputePcgs,IsPerm,IsPerm,IsFunction],0,COM_FUN(26));
InstallMethod(IsomorphismPcGroup,true,[IsPermGroup],0,COM_FUN(27));
BindGlobal("EpiPcByModpcgs",COM_FUN(28));
InstallMethod(ModuloPcgs,"for permutation groups",IsIdenticalObj,[IsPermGroup,IsPermGroup],0,COM_FUN(29));
InstallMethod(PcgsElementaryAbelianSeries,"perm group",true,[IsPermGroup],0,COM_FUN(30));
InstallMethod(MaximalSubgroupClassReps,"solvable perm group",true,[IsPermGroup and CanEasilyComputePcgs and IsFinite],0,COM_FUN(31));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/pcgsperm.gi"

#F  file="lib/pcgsnice.gi" crc=-15412413
RANK_FILTER_LIST  := [ 15881342, 222, 2033130, 222, 65767820, 5, 2033130, 
  222, 65767820, 5, 52247917, 19, 2033130, 222, 65767820, 5, 2033130, 222, 
  65767820, 5, 2033130, 222, 65767820, 5, 40093620, 27, 2033130, 222, 
  65767820, 5, 41951068, 17, 2033130, 222, 65767820, 5, 52247917, 19 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/pcgsnice.gi", -15412413 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/pcgsnice.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/pcgsnice.gi");
elif COM_RESULT = 3  then
Revision.pcgsnice_gi:="@(#)$Id: pcgsnice.gi,v 4.9 2002/04/15 10:05:12 sal Exp $";
InstallMethod(Pcgs,"via niceomorphism",true,[IsGroup and IsHandledByNiceMonomorphism],0,COM_FUN(1));
AttributeMethodByNiceMonomorphismCollElm(DepthOfPcElement,[IsPcgs,IsMultiplicativeElementWithInverse]);
InstallOtherMethod(DepthOfPcElement,true,[IsPcgs and IsHandledByNiceMonomorphism,IsMultiplicativeElementWithInverse,IsPosInt],0,COM_FUN(2));
AttributeMethodByNiceMonomorphismCollElm(LeadingExponentOfPcElement,[IsPcgs,IsMultiplicativeElementWithInverse]);
AttributeMethodByNiceMonomorphismCollElm(ExponentsOfPcElement,[IsPcgs,IsMultiplicativeElementWithInverse]);
InstallOtherMethod(ExponentsOfPcElement,true,[IsPcgs and IsHandledByNiceMonomorphism,IsMultiplicativeElementWithInverse,IsList and IsCyclotomicCollection],0,COM_FUN(3));
InstallOtherMethod(ExponentsOfPcElement,"perm group with 0 positions",true,[IsPcgs and IsHandledByNiceMonomorphism,IsMultiplicativeElementWithInverse,IsList and IsEmpty],0,COM_FUN(4));
InstallMethod(ExponentOfPcElement,"via nicoemorphism",true,[IsPcgs and IsHandledByNiceMonomorphism,IsMultiplicativeElementWithInverse,IsPosInt],0,COM_FUN(5));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/pcgsnice.gi"

#F  file="lib/pcgsspec.gi" crc=-60082645
RANK_FILTER_LIST  := [ 18147560, 25, 25466825, 25, 18147560, 25, 18147560, 
  25, 53660808, 21, 53660808, 21, 12585763, 29, 53660808, 21, 12585763, 29, 
  53660808, 21, 26397322, 22, 40028585, 22, 55152026, 23, 55152026, 23, 
  55152026, 23, 53660808, 21, 22261151, 47, 22261151, 47, 18147560, 25, 
  1827120, 22, 12585763, 29, 12585763, 29, 1827120, 22, 12585763, 29 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/pcgsspec.gi", -60082645 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/pcgsspec.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/pcgsspec.gi");
elif COM_RESULT = 3  then
Revision.pcgsspec_gi:="@(#)$Id: pcgsspec.gi,v 4.61 2003/02/04 23:22:49 gap Exp $";
PrimePowerPcSequence:=COM_FUN(1);
ModifyPcgs:=COM_FUN(2);
PcgsSystemWithWf:=COM_FUN(3);
PcgsSystemLGSeries:=COM_FUN(4);
LeastBadHallLayer:=COM_FUN(5);
PcgsSystemWithHallSystem:=COM_FUN(6);
LeastBadComplementLayer:=COM_FUN(7);
PcgsSystemWithComplementSystem:=COM_FUN(8);
InstallMethod(SpecialPcgs,"method for special pcgs",true,[IsSpecialPcgs],10,IdFunc);
InstallMethod(SpecialPcgs,"generic method for pcgs",true,[IsPcgs and IsFiniteOrdersPcgs and IsPrimeOrdersPcgs],0,COM_FUN(9));
InstallMethod(LGHeads,"for special pcgs",true,[IsSpecialPcgs],0,COM_FUN(10));
InstallMethod(LGTails,"for special pcgs",true,[IsSpecialPcgs],0,COM_FUN(11));
InstallOtherMethod(SpecialPcgs,"generic method for groups",true,[IsGroup],0,COM_FUN(12));
InstallOtherMethod(SpecialPcgs,"last resort method which tests solvability",true,[IsGroup],0,COM_FUN(13));
InstallMethod(IsomorphismSpecialPcGroup,"method for pc groups",true,[IsPcGroup],0,COM_FUN(14));
InstallMethod(IsomorphismSpecialPcGroup,"generic method for groups",true,[IsGroup],0,COM_FUN(15));
InstallOtherMethod(InducedPcgsWrtSpecialPcgs,"method for pc groups",true,[IsPcGroup],0,COM_FUN(16));
InstallOtherMethod(InducedPcgsWrtSpecialPcgs,"generic method for groups",true,[IsGroup],0,COM_FUN(17));
IndPcgsWrtSpecFromFamOrHome:=COM_FUN(18);
InstallOtherMethod(InducedPcgsWrtSpecialPcgs,"for groups that have already an induced pcgs wrt home pcgs",true,[IsGroup and HasInducedPcgsWrtHomePcgs],0,IndPcgsWrtSpecFromFamOrHome);
InstallOtherMethod(InducedPcgsWrtSpecialPcgs,"for groups that have already an induced pcgs wrt family pcgs",true,[IsGroup and HasInducedPcgsWrtFamilyPcgs],0,IndPcgsWrtSpecFromFamOrHome);
InstallMethod(LGWeights,"for induced wrt special",true,[IsInducedPcgsWrtSpecialPcgs],0,COM_FUN(19));
InstallMethod(LGLayers,"for induced wrt special",true,[IsInducedPcgsWrtSpecialPcgs],0,COM_FUN(20));
InstallMethod(LGFirst,"for induced wrt special",true,[IsInducedPcgsWrtSpecialPcgs],0,COM_FUN(21));
InstallMethod(LGLength,"for groups",true,[IsGroup],0,COM_FUN(22));
InstallMethod(PClassPGroup,"for groups with special pcgs",true,[IsPGroup and HasSpecialPcgs],1,COM_FUN(23));
InstallMethod(RankPGroup,"for groups with special pcgs",true,[IsPGroup and HasSpecialPcgs],1,COM_FUN(24));
SpecialPcgsSubgroup:=COM_FUN(25);
SpecialPcgsFactor:=COM_FUN(26);
InstallMethod(IndicesEANormalSteps,"special pcgs: LGFirst",true,[IsSpecialPcgs],0,LGFirst);
DoCentralSeriesPcgsIfNilpot:=COM_FUN(27);
InstallOtherMethod(PcgsCentralSeries,"if special pcgs is known",true,[HasSpecialPcgs],0,DoCentralSeriesPcgsIfNilpot);
InstallOtherMethod(PcgsCentralSeries,"for pc groups use SpecialPcgs",true,[IsPcGroup],0,DoCentralSeriesPcgsIfNilpot);
InstallOtherMethod(PcgsPCentralSeriesPGroup,"for pc groups use SpecialPcgs",true,[IsPcGroup],0,DoCentralSeriesPcgsIfNilpot);
PcgsElAbSerFromSpecPcgs:=COM_FUN(28);
InstallOtherMethod(PcgsElementaryAbelianSeries,"if special pcgs is known",true,[HasSpecialPcgs],0,PcgsElAbSerFromSpecPcgs);
InstallMethod(PcgsElementaryAbelianSeries,"for PCgroups via SpecialPcgs",true,[IsPcGroup],0,PcgsElAbSerFromSpecPcgs);
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/pcgsspec.gi"

#F  file="lib/grppc.gi" crc=16935695
RANK_FILTER_LIST  := [ 67029252, 22, 13289777, 22, 67029252, 22, 12572804, 
  31, 53660808, 21, 12585763, 29, 39812596, 21, 53660808, 21, 11009989, 22, 
  67029252, 22, 13289777, 22, 26397322, 22, 67016293, 24, 66243675, 22, 
  53660808, 21, 53660808, 21, 34160299, 13, 34160299, 13, 38573959, 8, 
  41951068, 17, 38573959, 8, 65767820, 5, 50252801, 23, 19974479, 23, 
  19974479, 23, 3263204, 23, 3263204, 23, 50252801, 23, 53660808, 21, 
  53660808, 21, 39812596, 21, 8193, 2, 58412696, 30, 5, 1, 5, 1, 53660808, 
  21, 58412696, 30, 5, 1, 5, 1, 53660808, 21, 8193, 2, 58412696, 30, 5, 1, 5, 
  1, 39812596, 21, 58412696, 30, 5, 1, 5, 1, 13289777, 22, 13289777, 22, 
  13289777, 22, 65767820, 5, 13289777, 22, 13289777, 22, 13289777, 22, 
  65767820, 5, 13289777, 22, 13289777, 22, 36883397, 22, 53660808, 21, 
  36883397, 22, 52247917, 19, 53660808, 21, 52247917, 19, 8193, 2, 58412696, 
  30, 5, 1, 53660808, 21, 58412696, 30, 5, 1, 39812596, 21, 58412696, 30, 5, 
  1, 53660808, 21, 8193, 2, 58412696, 30, 5, 1, 13289777, 22, 13289777, 22, 
  36873197, 27, 36873197, 27, 65767820, 5, 36873197, 27, 36873197, 27, 
  36873197, 27, 65767820, 5, 65767820, 5, 5, 1, 36883397, 22, 36883397, 22, 
  65767820, 5, 36883397, 22, 36883397, 22, 53660808, 21, 53660808, 21, 
  53660808, 21, 1, 0, 67105912, 7, 12585763, 29, 12585763, 29, 36873197, 27, 
  12585763, 29, 8193, 2, 12585763, 29, 12585763, 29, 12585763, 29, 12585763, 
  29, 12585763, 29, 5, 1, 53660808, 21, 36883397, 22, 16514503, 23, 45271600, 
  30, 16514503, 23, 16514503, 23, 12585763, 29, 44568071, 13 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grppc.gi", 16935695 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grppc.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grppc.gi");
elif COM_RESULT = 3  then
Revision.grppc_gi:="@(#)$Id: grppc.gi,v 4.143.2.2 2005/05/03 09:19:34 gap Exp $";
InstallMethod(CanonicalPcgsWrtFamilyPcgs,true,[IsGroup and HasFamilyPcgs],0,COM_FUN(1));
InstallMethod(CanonicalPcgsWrtHomePcgs,true,[IsGroup and HasHomePcgs],0,COM_FUN(2));
InstallMethod(InducedPcgsWrtFamilyPcgs,true,[IsGroup and HasFamilyPcgs],0,COM_FUN(3));
InstallMethod(InducedPcgsWrtFamilyPcgs,"whole family",true,[IsPcGroup and IsWholeFamily],0,FamilyPcgs);
InstallMethod(InducedPcgsWrtHomePcgs,"from generators",true,[IsGroup],0,COM_FUN(4));
InstallMethod(InducedPcgsWrtHomePcgs,"pc group: home=family",true,[IsPcGroup],0,InducedPcgsWrtFamilyPcgs);
InstallMethod(InducedPcgs,true,[IsPcgs,IsGroup],0,COM_FUN(5));
InstallGlobalFunction(SetInducedPcgs,COM_FUN(6));
InstallMethod(Pcgs,"fail if insolvable",true,[HasIsSolvableGroup],SUM_FLAGS,COM_FUN(7));
InstallMethod(Pcgs,"for a group with known family pcgs",true,[IsGroup and HasFamilyPcgs],0,InducedPcgsWrtFamilyPcgs);
InstallMethod(Pcgs,"for a group with known home pcgs",true,[IsGroup and HasHomePcgs],1,InducedPcgsWrtHomePcgs);
InstallMethod(Pcgs,"take induced pcgs",true,[IsGroup and HasInducedPcgsWrtHomePcgs],SUM_FLAGS,InducedPcgsWrtHomePcgs);
InstallMethod(Pcgs,"for a group containing the whole family and with known family pcgs",true,[IsGroup and HasFamilyPcgs and IsWholeFamily],0,FamilyPcgs);
InstallImmediateMethod(GeneralizedPcgs,IsGroup and HasPcgs,0,Pcgs);
InstallMethod(HomePcgs,true,[IsGroup],0,COM_FUN(8));
InstallMethod(PcgsChiefSeries,"compute chief series and pcgs",true,[IsGroup],0,COM_FUN(9));
InstallMethod(GroupWithGenerators,"method for pc elements collection",true,[IsCollection and IsMultiplicativeElementWithInverseByPolycyclicCollectorCollection],10,COM_FUN(10));
InstallOtherMethod(GroupWithGenerators,"method for pc collection and identity element",IsCollsElms,[IsCollection and IsMultiplicativeElementWithInverseByPolycyclicCollectorCollection,IsMultiplicativeElementWithInverseByPolycyclicCollector],0,COM_FUN(11));
InstallOtherMethod(GroupWithGenerators,"method for empty pc collection and identity element",true,[IsList and IsEmpty,IsMultiplicativeElementWithInverseByPolycyclicCollector],10,COM_FUN(12));
InstallMethod(\in,"for pcgs computable groups",IsElmsColls,[IsMultiplicativeElementWithInverse,IsGroup and HasFamilyPcgs and CanEasilyComputePcgs],0,COM_FUN(13));
InstallMethod(\=,"pcgs computable groups using home pcgs",IsIdenticalObj,[IsGroup and HasHomePcgs and HasCanonicalPcgsWrtHomePcgs,IsGroup and HasHomePcgs and HasCanonicalPcgsWrtHomePcgs],0,COM_FUN(14));
InstallMethod(\=,"pcgs computable groups using family pcgs",IsIdenticalObj,[IsGroup and HasFamilyPcgs and HasCanonicalPcgsWrtFamilyPcgs,IsGroup and HasFamilyPcgs and HasCanonicalPcgsWrtFamilyPcgs],0,COM_FUN(15));
InstallMethod(IsSubset,"pcgs computable groups",IsIdenticalObj,[IsGroup and HasFamilyPcgs and CanEasilyComputePcgs,IsGroup],0,COM_FUN(16));
InstallMethod(SubgroupByPcgs,"subgroup with pcgs",true,[IsGroup,IsPcgs],0,COM_FUN(17));
InstallGlobalFunction(VectorSpaceByPcgsOfElementaryAbelianGroup,COM_FUN(18));
InstallGlobalFunction(LinearActionLayer,COM_FUN(19));
InstallGlobalFunction(AffineActionLayer,COM_FUN(20));
InstallMethod(AffineAction,"generators",true,[IsList,IsMatrix,IsFunction,IsFunction],0,COM_FUN(21));
InstallOtherMethod(AffineAction,"group",true,[IsGroup,IsMatrix,IsFunction,IsFunction],0,COM_FUN(22));
InstallOtherMethod(AffineAction,"group2",true,[IsGroup,IsList,IsMatrix,IsFunction,IsFunction],0,COM_FUN(23));
InstallOtherMethod(AffineAction,"pcgs",true,[IsPcgs,IsMatrix,IsFunction,IsFunction],0,COM_FUN(24));
InstallMethod(ClosureGroup,"groups with home pcgs",IsIdenticalObj,[IsGroup and HasHomePcgs,IsGroup and HasHomePcgs],0,COM_FUN(25));
InstallMethod(ClosureGroup,"groups with home pcgs",IsCollsElms,[IsGroup and HasHomePcgs,IsMultiplicativeElementWithInverse],0,COM_FUN(26));
InstallMethod(CommutatorSubgroup,"groups with home pcgs",true,[IsGroup and HasHomePcgs,IsGroup and HasHomePcgs],0,COM_FUN(27));
InstallMethod(ConjugateGroup,"groups with home pcgs",IsCollsElms,[IsGroup and HasHomePcgs,IsMultiplicativeElementWithInverse],0,COM_FUN(28));
InstallMethod(ConjugateSubgroups,"groups with home pcgs",IsIdenticalObj,[IsGroup and HasHomePcgs,IsGroup and HasHomePcgs],0,COM_FUN(29));
InstallMethod(CoreOp,"pcgs computable groups",true,[IsGroup and CanEasilyComputePcgs,IsGroup],0,COM_FUN(30));
InstallMethod(EulerianFunction,"pcgs computable groups using special pcgs",true,[IsGroup and CanEasilyComputePcgs,IsPosInt],0,COM_FUN(31));
RedispatchOnCondition(EulerianFunction,true,[IsGroup,IsPosInt],[IsSolvableGroup,IsPosInt],1);
InstallMethod(LinearAction,true,[IsList,IsMatrix,IsFunction],0,COM_FUN(32));
InstallOtherMethod(LinearAction,true,[IsGroup,IsMatrix,IsFunction],0,COM_FUN(33));
InstallOtherMethod(LinearAction,true,[IsPcgs,IsMatrix,IsFunction],0,COM_FUN(34));
InstallOtherMethod(LinearAction,true,[IsGroup,IsList,IsMatrix,IsFunction],0,COM_FUN(35));
InstallMethod(NormalClosureOp,"groups with home pcgs",true,[IsGroup and HasHomePcgs,IsGroup and HasHomePcgs],0,COM_FUN(36));
InstallMethod(Random,"pcgs computable groups",true,[IsGroup and CanEasilyComputePcgs and IsFinite],0,COM_FUN(37));
BindGlobal("CentralizerSolvableGroup",COM_FUN(38));
InstallMethod(CentralizerOp,"pcgs computable group and element",IsCollsElms,[IsGroup and CanEasilyComputePcgs and IsFinite,IsMultiplicativeElementWithInverse],0,COM_FUN(39));
InstallMethod(CentralizerOp,"pcgs computable groups",IsIdenticalObj,[IsGroup and CanEasilyComputePcgs and IsFinite,IsGroup and CanEasilyComputePcgs and IsFinite],0,COM_FUN(40));
InstallOtherMethod(RepresentativeActionOp,"element conjugacy in pcgs computable groups",IsCollsElmsElmsX,[IsGroup and CanEasilyComputePcgs and IsFinite,IsMultiplicativeElementWithInverse,IsMultiplicativeElementWithInverse,IsFunction],0,COM_FUN(41));
InstallMethod(CentralizerModulo,"pcgs computable groups, for elm",IsCollsCollsElms,[IsGroup and CanEasilyComputePcgs,IsGroup and CanEasilyComputePcgs,IsMultiplicativeElementWithInverse],0,COM_FUN(42));
InstallMethod(CentralizerModulo,"group centralizer via generators",IsFamFamFam,[IsGroup and CanEasilyComputePcgs,IsGroup and CanEasilyComputePcgs,IsGroup],0,COM_FUN(43));
RedispatchOnCondition(CentralizerModulo,true,[IsGroup,IsGroup,IsObject],[IsGroup and IsSolvableGroup,IsGroup and IsSolvableGroup,IsObject],0);
InstallOtherMethod(ElementaryAbelianSeries,"list of pcgs computable groups",true,[IsList and IsFinite],1,COM_FUN(44));
InstallMethod(\<,"cgs comparison",IsIdenticalObj,[IsPcGroup,IsPcGroup],0,COM_FUN(45));
InstallGlobalFunction(GapInputPcGroup,COM_FUN(46));
InstallMethod(Enumerator,"finite pc computable groups",true,[IsGroup and CanEasilyComputePcgs and IsFinite],0,COM_FUN(47));
InstallMethod(KnowsHowToDecompose,"pc group and generators: always true",IsIdenticalObj,[IsPcGroup,IsList],0,ReturnTrue);
InstallGlobalFunction(CanonicalSubgroupRepresentativePcGroup,COM_FUN(48));
InstallMethod(ConjugacyClassSubgroups,IsIdenticalObj,[IsPcGroup,IsPcGroup],0,COM_FUN(49));
InstallOtherMethod(RepresentativeActionOp,"pc group on subgroups",true,[IsPcGroup,IsPcGroup,IsPcGroup,IsFunction],0,COM_FUN(50));
InstallMethod(ChiefSeriesUnderAction,"method for a pcgs computable group",IsIdenticalObj,[IsGroup,IsGroup and CanEasilyComputePcgs],0,COM_FUN(51));
InstallMethod(IsSimpleGroup,"for solvable groups",true,[IsSolvableGroup],Maximum(RankFilter(IsSolvableGroup),RankFilter(IsPermGroup)+1)-RankFilter(IsSolvableGroup),COM_FUN(52));
InstallMethod(ViewObj,"pc group",true,[IsPcGroup],0,COM_FUN(53));
InstallTrueMethod(CanEasilyComputePcgs,IsPcGroup);
InstallTrueMethod(CanEasilyComputePcgs,HasPcgs);
InstallTrueMethod(CanEasilyComputePcgs,IsGroup and HasFamilyPcgs);
InstallTrueMethod(CanEasilyTestMembership,CanEasilyComputePcgs);
InstallTrueMethod(CanComputeSize,CanEasilyComputePcgs);
InstallTrueMethod(CanComputeSizeAnySubgroup,CanEasilyComputePcgs);
InstallMethod(IsConjugatorIsomorphism,"for a pc group general mapping",true,[IsGroupGeneralMapping],1,COM_FUN(54));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grppc.gi"

#F  file="lib/grppcint.gi" crc=115538774
RANK_FILTER_LIST  := [ 13289777, 22, 13289777, 22, 13289777, 22, 13289777, 22 
 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grppcint.gi", 115538774 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grppcint.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grppcint.gi");
elif COM_RESULT = 3  then
Revision.grppcint_gi:="@(#)$Id: grppcint.gi,v 4.27.4.1 2005/04/12 19:07:15 gap Exp $";
GS_SIZE:=20;
GlasbyCover:=COM_FUN(1);
GlasbyShift:=COM_FUN(2);
GlasbyStabilizer:=COM_FUN(3);
AvoidedLayers:=COM_FUN(4);
GlasbyIntersection:=COM_FUN(5);
ZassenhausIntersection:=COM_FUN(6);
InstallMethod(Intersection2,"groups with pcgs",true,[IsGroup and HasHomePcgs,IsGroup and HasHomePcgs],0,COM_FUN(7));
InstallMethod(NormalIntersection,"method for two groups with home pcgs",IsIdenticalObj,[IsGroup and HasHomePcgs,IsGroup and HasHomePcgs],COM_FUN(8));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grppcint.gi"

#F  file="lib/grppcprp.gi" crc=122813800
RANK_FILTER_LIST  := [ 36883397, 25, 36883397, 25 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grppcprp.gi", 122813800 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grppcprp.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grppcprp.gi");
elif COM_RESULT = 3  then
Revision.grppcprp_gi:="@(#)$Id: grppcprp.gi,v 4.6 2002/04/15 10:04:52 sal Exp $";
InstallMethod(IsNilpotentGroup,"method for pc groups",true,[IsGroup and CanEasilyComputePcgs],0,COM_FUN(1));
InstallMethod(IsSupersolvableGroup,"method for pc groups",true,[IsGroup and CanEasilyComputePcgs],0,COM_FUN(2));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grppcprp.gi"

#F  file="lib/grppcatr.gi" crc=47881802
RANK_FILTER_LIST  := [ 36873197, 30, 36873197, 30, 12585763, 33, 36873197, 
  30, 36873197, 30, 36873197, 30, 36873197, 30, 36873197, 30, 8193, 2, 
  53660808, 21, 8193, 2, 36873197, 30, 36883397, 25, 36883397, 25, 36873197, 
  30, 52247917, 19, 53660808, 21, 52247917, 19, 36873197, 30, 52247917, 19, 
  36873197, 30, 67019052, 31, 36873197, 30, 12575563, 44, 12575563, 44, 
  12575563, 44, 13368445, 26, 36873197, 30, 36873197, 30, 12575563, 44, 
  52247917, 19 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grppcatr.gi", 47881802 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grppcatr.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grppcatr.gi");
elif COM_RESULT = 3  then
Revision.grppcatr_gi:="@(#)$Id: grppcatr.gi,v 4.56 2003/04/25 07:45:22 gap Exp $";
InstallMethod(AsSSortedListNonstored,"pcgs computable groups",true,[IsGroup and CanEasilyComputePcgs and IsFinite],0,COM_FUN(1));
InstallMethod(AsSSortedList,"pcgs computable groups",true,[IsGroup and CanEasilyComputePcgs and IsFinite],0,AsSSortedListNonstored);
InstallMethod(AsList,"pc group",true,[IsPcGroup],0,AsSSortedListNonstored);
InstallMethod(CompositionSeries,"pcgs computable groups",true,[IsGroup and CanEasilyComputePcgs and IsFinite],0,COM_FUN(2));
InstallMethod(DerivedSubgroup,"pcgs computable groups",true,[IsGroup and CanEasilyComputePcgs and IsFinite],0,COM_FUN(3));
InstallMethod(ElementaryAbelianSeries,"pcgs computable groups using `PcgsElementaryAbelianSeries'",true,[IsGroup and CanEasilyComputePcgs and IsFinite],0,COM_FUN(4));
InstallMethod(FrattiniSubgroup,"pcgs computable groups using prefrattini and core",true,[IsGroup and CanEasilyComputePcgs and IsFinite],0,COM_FUN(5));
InstallMethod(HallSubgroupOp,"pcgs computable groups using special pcgs",true,[IsGroup and CanEasilyComputePcgs and IsFinite,IsList],0,COM_FUN(6));
RedispatchOnCondition(HallSubgroupOp,true,[IsGroup,IsList],[IsGroup and IsSolvableGroup and CanEasilyComputePcgs and IsFinite,IsList],0);
InstallMethod(PrefrattiniSubgroup,"pcgs computable groups using special pcgs",true,[IsGroup and CanEasilyComputePcgs and IsFinite],0,COM_FUN(7));
InstallMethod(IsFinite,"pcgs computable groups",true,[IsGroup and CanEasilyComputePcgs],0,COM_FUN(8));
InstallMethod(Size,"pcgs computable groups",true,[IsGroup and CanEasilyComputePcgs],0,COM_FUN(9));
InstallMethod(SylowComplementOp,"pcgs computable groups using special pcgs",true,[IsGroup and CanEasilyComputePcgs and IsFinite,IsPosInt],80,COM_FUN(10));
RedispatchOnCondition(SylowComplementOp,true,[IsGroup,IsPosInt],[IsGroup and IsSolvableGroup and CanEasilyComputePcgs and IsFinite,IsPosInt],0);
InstallMethod(SylowSubgroupOp,"pcgs computable groups using special pcgs",true,[IsGroup and CanEasilyComputePcgs and IsFinite,IsPosInt],100,COM_FUN(11));
MaximalSubgroupClassesRepsLayer:=COM_FUN(12);
InstallMethod(MaximalSubgroupClassReps,"pcgs computable groups using special pcgs",true,[IsGroup and CanEasilyComputePcgs and IsFinite],0,COM_FUN(13));
InstallMethod(MaximalSubgroups,"pcgs computable groups using special pcgs",true,[IsGroup and HasFamilyPcgs and IsFinite],0,COM_FUN(14));
InstallMethod(NormalMaximalSubgroups,"pcgs computable groups using special pcgs",true,[IsGroup and CanEasilyComputePcgs and IsFinite],0,COM_FUN(15));
ModifyMinGens:=COM_FUN(16);
MinimalGensLayer:=COM_FUN(17);
InstallMethod(MinimalGeneratingSet,"pcgs computable groups using special pcgs",true,[IsPcGroup and IsFinite],0,COM_FUN(18));
InstallMethod(SmallGeneratingSet,"using minimal generating set",true,[IsPcGroup and IsFinite],0,COM_FUN(19));
InstallOtherMethod(GeneratorOfCyclicGroup,"pc groups",true,[IsPcGroup and IsFinite],0,COM_FUN(20));
InstallMethod(GeneratorsSmallest,"group of pc words which is full family",true,[HasFamilyPcgs],0,COM_FUN(21));
NextStepCentralizer:=COM_FUN(22);
InstallGlobalFunction(GeneratorsCentrePGroup,COM_FUN(23));
InstallGlobalFunction(CentrePcGroup,COM_FUN(24));
InstallMethod(Centre,"pcgs computable groups using special pcgs",[IsGroup and CanEasilyComputePcgs and IsFinite],CentrePcGroup);
InstallMethod(OmegaSeries,"for p-groups",true,[IsGroup and CanEasilyComputePcgs and IsFinite],0,COM_FUN(25));
InstallMethod(PCentralSeriesOp,"method for pc groups and prime",true,[IsPcGroup and IsFinite,IsPosInt],0,COM_FUN(26));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grppcatr.gi"

#F  file="lib/grppcnrm.gi" crc=92951878
RANK_FILTER_LIST  := [ 13289777, 22, 13289777, 22, 13289777, 22, 13289777, 
  22, 13289777, 22 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grppcnrm.gi", 92951878 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grppcnrm.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grppcnrm.gi");
elif COM_RESULT = 3  then
Revision.grppcnrm_gi:="@(#)$Id: grppcnrm.gi,v 4.26 2002/04/15 10:04:52 sal Exp $";
PCGS_STABILIZER:=COM_FUN(1);
PCGS_STABILIZER_HOMOMORPHIC:=COM_FUN(2);
PCGS_NORMALIZER_OPB:=COM_FUN(3);
PCGS_NORMALIZER_OPC1:=COM_FUN(4);
PCGS_NORMALIZER_OPC2:=COM_FUN(5);
PCGS_NORMALIZER_OPD:=COM_FUN(6);
PCGS_NORMALIZER_OPE:=COM_FUN(7);
PCGS_NORMALIZER_DATAE:=COM_FUN(8);
PCGS_NORMALIZER:=COM_FUN(9);
PCGS_NORMALIZER_LINEAR:=COM_FUN(10);
PCGS_CONJUGATING_WORD_GS:=COM_FUN(11);
PCGS_NORMALIZER_GLASBY:=COM_FUN(12);
PCGS_NORMALIZER_COBOUNDS:=COM_FUN(13);
PcGroup_NormalizerWrtHomePcgs:=COM_FUN(14);
InstallMethod(NormalizerInHomePcgs,"for group with home pcgs",true,[IsGroup and HasHomePcgs],0,COM_FUN(15));
InstallMethod(NormalizerOp,"for groups with home pcgs",IsIdenticalObj,[IsGroup and HasHomePcgs,IsGroup and HasHomePcgs],1,COM_FUN(16));
InstallMethod(NormalizerOp,"slightly better orbit algorithm for pc groups",IsIdenticalObj,[IsGroup and HasHomePcgs,IsGroup and HasHomePcgs],0,COM_FUN(17));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grppcnrm.gi"

#F  file="lib/grptbl.gi" crc=-62694532
RANK_FILTER_LIST  := [ 36089998, 7, 36089998, 7, 36089998, 7, 36089998, 7, 
  36089998, 7, 36089998, 7, 36089998, 7, 36089998, 7, 36089998, 7, 32769, 4, 
  63962867, 11 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grptbl.gi", -62694532 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grptbl.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grptbl.gi");
elif COM_RESULT = 3  then
Revision.grptbl_gi:="@(#)$Id: grptbl.gi,v 4.22.4.1 2005/05/06 08:46:30 gap Exp $";
DeclareRepresentation("IsMagmaByMultiplicationTableObj",IsPositionalObjectRep and IsMultiplicativeElementWithInverse,[1]);
InstallMethod(PrintObj,"for element of magma by mult. table",[IsMagmaByMultiplicationTableObj],COM_FUN(1));
InstallMethod(\=,"for two elements of magma by mult. table",IsIdenticalObj,[IsMagmaByMultiplicationTableObj,IsMagmaByMultiplicationTableObj],COM_FUN(2));
InstallMethod(\<,"for two elements of magma by mult. table",IsIdenticalObj,[IsMagmaByMultiplicationTableObj,IsMagmaByMultiplicationTableObj],COM_FUN(3));
InstallMethod(\*,"for two elements of magma by mult. table",IsIdenticalObj,[IsMagmaByMultiplicationTableObj,IsMagmaByMultiplicationTableObj],COM_FUN(4));
InstallMethod(OneOp,"for an element in a magma by mult. table",[IsMagmaByMultiplicationTableObj],COM_FUN(5));
InstallMethod(InverseOp,"for an element in a magma by mult. table",[IsMagmaByMultiplicationTableObj],COM_FUN(6));
InstallGlobalFunction(MagmaElement,COM_FUN(7));
InstallGlobalFunction(MagmaByMultiplicationTableCreator,COM_FUN(8));
InstallGlobalFunction(MagmaByMultiplicationTable,COM_FUN(9));
InstallGlobalFunction(MagmaWithOneByMultiplicationTable,COM_FUN(10));
InstallGlobalFunction(MagmaWithInversesByMultiplicationTable,COM_FUN(11));
InstallGlobalFunction(SemigroupByMultiplicationTable,COM_FUN(12));
InstallGlobalFunction(MonoidByMultiplicationTable,COM_FUN(13));
InstallGlobalFunction(GroupByMultiplicationTable,COM_FUN(14));
InstallMethod(MultiplicationTable,"for a list of elements",[IsHomogeneousList],COM_FUN(15));
InstallMethod(MultiplicationTable,"for a magma",[IsMagma],COM_FUN(16));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grptbl.gi"

#F  file="lib/ghom.gi" crc=-10759432
RANK_FILTER_LIST  := [ 1829479, 17, 53660808, 21, 44568071, 13, 44568071, 13, 
  1829479, 17, 44568071, 13, 4299740, 19, 49346896, 7, 46172500, 18, 
  65767820, 5, 56640690, 17, 65767820, 5, 46172500, 18, 50472239, 14, 
  46172500, 18, 50472239, 14, 46172500, 18, 50472239, 14, 46172500, 18, 
  50472239, 14, 46172500, 18, 50472239, 14, 46172500, 18, 50472239, 14, 
  46172500, 18, 50472239, 14, 46172500, 18, 50472239, 14, 53660808, 21, 
  53660808, 21, 8193, 2, 8193, 2, 53660808, 21, 53660808, 21, 8193, 2, 8193, 
  2, 1829479, 17, 49346896, 7, 1829479, 17, 44568071, 13, 61874785, 17, 
  44569063, 15, 44568071, 13, 63704263, 21, 1829479, 17, 1829479, 17, 
  63704263, 21, 1829479, 17, 1829479, 17, 1829479, 17, 1829479, 17, 61874785, 
  17, 44568071, 13, 61726276, 25, 61874785, 17, 61874785, 17, 61874785, 17, 
  61874785, 17, 65767820, 5, 61874785, 17, 65767820, 5, 61874785, 17, 
  61874785, 17, 61874785, 17, 28313176, 21, 53660808, 21, 65767820, 5, 
  53660808, 21, 65767820, 5, 53660808, 21, 65767820, 5, 1688866, 23, 1688866, 
  23, 1688866, 23, 51230112, 25, 6758341, 27, 1688866, 23, 1688866, 23, 
  51230112, 25, 51230112, 25, 6758341, 27, 6758341, 27, 1688866, 23, 
  65767820, 5, 1688866, 23, 53660808, 21, 1688866, 23, 65767820, 5, 1688866, 
  23, 53660808, 21, 1688866, 23, 1688866, 23, 1688866, 23, 6758341, 27, 
  44568071, 13, 44568071, 13, 53660808, 21, 20105671, 49, 53650608, 26, 
  53650608, 26, 53660808, 21 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/ghom.gi", -10759432 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/ghom.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/ghom.gi");
elif COM_RESULT = 3  then
Revision.ghom_gi:="@(#)$Id: ghom.gi,v 4.108 2003/08/23 18:59:19 gap Exp $";
InstallGlobalFunction(GroupHomomorphismByImages,COM_FUN(1));
InstallMethod(RestrictedMapping,"create new GHBI",CollFamSourceEqFamElms,[IsGroupHomomorphism,IsGroup],0,COM_FUN(2));
InstallMethod(\=,"compare source generator images",IsIdenticalObj,[IsGroupGeneralMapping,IsGroupGeneralMapping],0,COM_FUN(3));
InstallMethod(CompositionMapping2,"for gp. hom. and gp. gen. mapp., using `MappingGeneratorsImages'",FamSource1EqFamRange2,[IsGroupHomomorphism,IsGroupGeneralMapping],0,COM_FUN(4));
InstallOtherMethod(SetInverseGeneralMapping,"transfer the AsGHBI",true,[IsGroupGeneralMappingByAsGroupGeneralMappingByImages and HasAsGroupGeneralMappingByImages,IsGeneralMapping],0,COM_FUN(5));
InstallMethod(ImagesRepresentative,"for `ByAsGroupGeneralMapping' hom",FamSourceEqFamElm,[IsGroupGeneralMappingByAsGroupGeneralMappingByImages,IsMultiplicativeElementWithInverse],0,COM_FUN(6));
InstallMethod(PreImagesRepresentative,"for PBG-Hom",FamRangeEqFamElm,[IsPreimagesByAsGroupGeneralMappingByImages,IsMultiplicativeElementWithInverse],0,COM_FUN(7));
InstallAttributeMethodByGroupGeneralMappingByImages(CoKernelOfMultiplicativeGe\
neralMapping,IsGroup);
InstallAttributeMethodByGroupGeneralMappingByImages(KernelOfMultiplicativeGene\
ralMapping,IsGroup);
InstallAttributeMethodByGroupGeneralMappingByImages(PreImagesRange,IsGroup);
InstallAttributeMethodByGroupGeneralMappingByImages(ImagesSource,IsGroup);
InstallAttributeMethodByGroupGeneralMappingByImages(IsSingleValued,IsBool);
InstallAttributeMethodByGroupGeneralMappingByImages(IsInjective,IsBool);
InstallAttributeMethodByGroupGeneralMappingByImages(IsTotal,IsBool);
InstallAttributeMethodByGroupGeneralMappingByImages(IsSurjective,IsBool);
InstallMethod(GroupGeneralMappingByImages,"for group, group, list, list",true,[IsGroup,IsGroup,IsList,IsList],0,COM_FUN(8));
InstallMethod(GroupHomomorphismByImagesNC,"for group, group, list, list",true,[IsGroup,IsGroup,IsList,IsList],0,COM_FUN(9));
InstallMethod(MappingGeneratorsImages,"for a group homomorphism",true,[IsGroupHomomorphism],0,COM_FUN(10));
RedispatchOnCondition(MappingGeneratorsImages,true,[IsGeneralMapping],[IsGroupHomomorphism],0);
InstallMethod(AsGroupGeneralMappingByImages,"for a group homomorphism",true,[IsGroupHomomorphism],0,COM_FUN(11));
InstallMethod(AsGroupGeneralMappingByImages,"for group general mapping",true,[IsGroupGeneralMapping],0,COM_FUN(12));
InstallMethod(AsGroupGeneralMappingByImages,"for GHBI",true,[IsGroupGeneralMappingByImages],SUM_FLAGS,IdFunc);
InstallMethod(SetAsGroupGeneralMappingByImages,"assign MappingOfWhichItIsAsGGMBI",true,[IsGroupGeneralMapping and IsAttributeStoringRep,IsGroupGeneralMapping],0,COM_FUN(13));
InstallMethod(\=,"homomorphism by images with homomorphism: compare generator images",IsIdenticalObj,[IsGroupHomomorphism and IsGroupGeneralMappingByImages,IsGroupHomomorphism],1,COM_FUN(14));
InstallMethod(\=,"homomorphism with general mapping: test b=a",IsIdenticalObj,[IsGroupHomomorphism,IsGroupHomomorphism and IsGroupGeneralMappingByImages],0,COM_FUN(15));
InstallMethod(ImagesSmallestGenerators,"group homomorphisms",true,[IsGroupHomomorphism],0,COM_FUN(16));
InstallMethod(\<,"group homomorphisms: Images of smallest generators",IsIdenticalObj,[IsGroupHomomorphism,IsGroupHomomorphism],0,COM_FUN(17));
InstallMethod(ImagesSource,"for GHBI",true,[IsGroupHomomorphism],0,COM_FUN(18));
InstallMethod(PreImagesRange,"for GHBI",true,[IsGroupGeneralMappingByImages],0,COM_FUN(19));
InstallMethod(InverseGeneralMapping,"via generators/images",true,[IsGroupGeneralMapping],0,COM_FUN(20));
InstallMethod(InverseGeneralMapping,"for bijective GHBI",true,[IsGroupGeneralMappingByImages and IsBijective],0,COM_FUN(21));
InstallGlobalFunction(MakeMapping,COM_FUN(22));
InstallMethod(CoKernelOfMultiplicativeGeneralMapping,"for GHBI",true,[IsGroupGeneralMappingByImages],0,COM_FUN(23));
InstallMethod(KernelOfMultiplicativeGeneralMapping,"for GHBI",true,[IsGroupGeneralMappingByImages],0,COM_FUN(24));
InstallMethod(IsInjective,"for GHBI",true,[IsGroupGeneralMappingByImages],0,COM_FUN(25));
InstallGlobalFunction(ImagesRepresentativeGMBIByElementsList,COM_FUN(26));
InstallMethod(ImagesRepresentative,"parallel enumeration of source and range",FamSourceEqFamElm,[IsGroupGeneralMappingByImages,IsMultiplicativeElementWithInverse],0,ImagesRepresentativeGMBIByElementsList);
InstallMethod(PreImagesRepresentative,"for GHBI and mult.-elm.-with-inverse",FamRangeEqFamElm,[IsGroupGeneralMappingByImages,IsMultiplicativeElementWithInverse],0,COM_FUN(27));
InstallMethod(ViewObj,"for GHBI",true,[IsGroupGeneralMappingByImages],0,COM_FUN(28));
InstallMethod(String,"for GHBI",true,[IsGroupGeneralMappingByImages],0,COM_FUN(29));
InstallMethod(PrintObj,"for group general mapping b.i.",true,[IsGroupGeneralMappingByImages],0,COM_FUN(30));
InstallMethod(PrintObj,"for GHBI",true,[IsGroupGeneralMappingByImages and IsMapping],0,COM_FUN(31));
InstallMethod(ConjugatorIsomorphism,"for group and mult.-elm.-with-inverse",IsCollsElms,[IsGroup,IsMultiplicativeElementWithInverse],0,COM_FUN(32));
InstallMethod(ConjugatorAutomorphismNC,"group and mult.-elm.-with-inverse",IsCollsElms,[IsGroup,IsMultiplicativeElementWithInverse],0,COM_FUN(33));
InstallGlobalFunction(ConjugatorAutomorphism,COM_FUN(34));
InstallMethod(InnerAutomorphismNC,"for group and mult.-elm.-with-inverse",IsCollsElms,[IsGroup,IsMultiplicativeElementWithInverse],0,COM_FUN(35));
InstallGlobalFunction(InnerAutomorphism,COM_FUN(36));
InstallMethod(MappingGeneratorsImages,"for conjugator isomorphism",true,[IsConjugatorIsomorphism],0,COM_FUN(37));
InstallMethod(AsGroupGeneralMappingByImages,"for conjugator isomorphism",true,[IsConjugatorIsomorphism],0,COM_FUN(38));
InstallMethod(InverseGeneralMapping,"for conjugator isomorphism",true,[IsConjugatorIsomorphism],0,COM_FUN(39));
InstallMethod(InverseGeneralMapping,"for conjugator automorphism",true,[IsConjugatorAutomorphism],0,COM_FUN(40));
InstallMethod(InverseGeneralMapping,"for inner automorphism",true,[IsInnerAutomorphism],0,COM_FUN(41));
InstallMethod(CompositionMapping2,"for two conjugator isomorphisms",true,[IsConjugatorIsomorphism,IsConjugatorIsomorphism],0,COM_FUN(42));
InstallMethod(CompositionMapping2,"for two conjugator automorphisms",true,[IsConjugatorAutomorphism,IsConjugatorAutomorphism],0,COM_FUN(43));
InstallMethod(CompositionMapping2,"for two inner automorphisms",IsIdenticalObj,[IsInnerAutomorphism,IsInnerAutomorphism],0,COM_FUN(44));
InstallMethod(ImagesRepresentative,"for conjugator isomorphism",FamSourceEqFamElm,[IsConjugatorIsomorphism,IsMultiplicativeElementWithInverse],0,COM_FUN(45));
InstallMethod(ImagesSet,"for conjugator isomorphism, and group",CollFamSourceEqFamElms,[IsConjugatorIsomorphism,IsGroup],0,COM_FUN(46));
InstallMethod(PreImagesRepresentative,"for conjugator isomorphism",FamRangeEqFamElm,[IsConjugatorIsomorphism,IsMultiplicativeElementWithInverse],0,COM_FUN(47));
InstallMethod(PreImagesSet,"for conjugator isomorphism, and group",CollFamRangeEqFamElms,[IsConjugatorIsomorphism,IsGroup],0,COM_FUN(48));
InstallMethod(ViewObj,"for conjugator isomorphism",true,[IsConjugatorIsomorphism],0,COM_FUN(49));
InstallMethod(String,"for conjugator isomorphism",true,[IsConjugatorIsomorphism],0,COM_FUN(50));
InstallMethod(PrintObj,"for conjugator isomorphism",true,[IsConjugatorIsomorphism],0,COM_FUN(51));
InstallMethod(PrintObj,"for inner automorphism",true,[IsInnerAutomorphism],0,COM_FUN(52));
InstallMethod(IsConjugatorIsomorphism,"for a group general mapping",true,[IsGroupGeneralMapping],0,COM_FUN(53));
InstallMethod(IsInnerAutomorphism,"for a group general mapping",true,[IsGroupGeneralMapping],0,COM_FUN(54));
InstallGlobalFunction(NaturalHomomorphismByNormalSubgroup,COM_FUN(55));
InstallMethod(NaturalHomomorphismByNormalSubgroupOp,"for group, and trivial group (delegate to `IdentityMapping')",IsIdenticalObj,[IsGroup,IsGroup and IsTrivial],SUM_FLAGS,COM_FUN(56));
InstallMethod(IsomorphismPermGroup,"right regular operation",true,[IsGroup and IsFinite],0,COM_FUN(57));
InstallMethod(IsomorphismPcGroup,"via permutation representation",true,[IsGroup and IsFinite],0,COM_FUN(58));
InstallGlobalFunction(GroupHomomorphismByFunction,COM_FUN(59));
InstallMethod(RegularActionHomomorphism,"generic",true,[IsGroup],0,COM_FUN(60));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/ghom.gi"

#F  file="lib/ghompcgs.gi" crc=39198693
RANK_FILTER_LIST  := [ 1829479, 17, 38527992, 22, 11973834, 28, 11973834, 28, 
  1820029, 20, 65767820, 5, 4980722, 18, 4980722, 18, 63431597, 24, 43508713, 
  23, 43508713, 23, 53470155, 22, 65767820, 5, 12585763, 33, 12585763, 33, 
  55487927, 35, 19109964, 22, 39845769, 23, 39845769, 23, 46129928, 25, 
  65767820, 5, 46129928, 25, 65767820, 5, 43508713, 23, 43508713, 23, 
  43508713, 23, 53660808, 21, 39812596, 21, 12585763, 33 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/ghompcgs.gi", 39198693 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/ghompcgs.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/ghompcgs.gi");
elif COM_RESULT = 3  then
Revision.ghompcgs_gi:="@(#)$Id: ghompcgs.gi,v 4.54 2002/04/15 10:04:41 sal Exp $";
BindGlobal("PcgsHomSoImPow",COM_FUN(1));
InstallMethod(CompositionMapping2,"method for hom2 from pc group",FamSource1EqFamRange2,[IsGroupHomomorphism,IsGroupGeneralMappingByPcgs and IsMapping and IsTotal],0,COM_FUN(2));
InstallMethod(CompositionMapping2,"method for two pc group automorphisms",IsIdenticalObj,[IsPcGroupHomomorphismByImages and IsToPcGroupHomomorphismByImages and IsTotal and IsInjective and IsSurjective,IsPcGroupHomomorphismByImages and IsToPcGroupHomomorphismByImages and IsTotal and IsInjective and IsSurjective],0,COM_FUN(3));
InstallMethod(ImagesRepresentative,"for total GGMBPCGS, and mult.-elm.-with-inverse",FamSourceEqFamElm,[IsGroupGeneralMappingByPcgs and IsTotal,IsMultiplicativeElementWithInverse],100,COM_FUN(4));
InstallMethod(IsSingleValued,"for GMBPCGS: test relations",true,[IsGroupGeneralMappingByPcgs],0,COM_FUN(5));
InstallMethod(CoKernelOfMultiplicativeGeneralMapping,"for GMBPCGS: evaluate relations",true,[IsGroupGeneralMappingByPcgs],0,COM_FUN(6));
InversePcgs:=COM_FUN(7);
InstallMethod(KernelOfMultiplicativeGeneralMapping,"method for homs from pc group into pc group or perm group",true,[IsPcGroupHomomorphismByImages and IsToPcGroupHomomorphismByImages],0,COM_FUN(8));
InstallMethod(KernelOfMultiplicativeGeneralMapping,"method for homs from pc group",true,[IsPcGroupHomomorphismByImages],0,COM_FUN(9));
InstallMethod(IsInjective,"method for homs from pc group",true,[IsPcGroupHomomorphismByImages],0,COM_FUN(10));
InstallMethod(PreImagesRepresentative,"method for pcgs hom",FamRangeEqFamElm,[IsToPcGroupHomomorphismByImages,IsMultiplicativeElementWithInverse],0,COM_FUN(11));
InstallMethod(NaturalHomomorphismByNormalSubgroupOp,IsIdenticalObj,[IsPcGroup,IsPcGroup],0,COM_FUN(12));
InstallMethod(NaturalHomomorphismByNormalSubgroupOp,IsIdenticalObj,[IsGroup and HasSpecialPcgs,IsGroup and HasInducedPcgsWrtSpecialPcgs],0,COM_FUN(13));
InstallMethod(ViewObj,"for nat. hom. of pc group",true,[IsNaturalHomomorphismPcGroupRep],0,COM_FUN(14));
InstallMethod(PrintObj,"for nat. hom. of pc group",true,[IsNaturalHomomorphismPcGroupRep],0,COM_FUN(15));
InstallMethod(ImagesRepresentative,FamSourceEqFamElm,[IsPcgsToPcgsHomomorphism,IsMultiplicativeElementWithInverse],0,COM_FUN(16));
InstallMethod(PreImagesRepresentative,FamRangeEqFamElm,[IsPcgsToPcgsHomomorphism,IsMultiplicativeElementWithInverse],0,COM_FUN(17));
InstallMethod(\=,"pc group homomorphisms",IsIdenticalObj,[IsPcGroupHomomorphismByImages,IsPcGroupHomomorphismByImages],1,COM_FUN(18));
InstallMethod(PrintObj,"method for a PcGroupHomomorphisms",true,[IsPcGroupHomomorphismByImages],0,COM_FUN(19));
InstallMethod(NaturalIsomorphismByPcgs,"for group and pcgs",IsIdenticalObj,[IsGroup,IsPcgs],0,COM_FUN(20));
InstallMethod(IsomorphismPcGroup,true,[IsPcGroup],0,IdentityMapping);
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/ghompcgs.gi"

#F  file="lib/gprd.gi" crc=-39865373
RANK_FILTER_LIST  := [ 8193, 2, 53660808, 21, 67108280, 15, 11717243, 22, 
  11717243, 22, 52247917, 19, 11717243, 22, 52247917, 19, 11717243, 22, 
  11717243, 22, 12585763, 33, 61786102, 32, 62048711, 26, 53660808, 21, 
  53660808, 21, 1829479, 17, 1829479, 17, 36883517, 22, 52247917, 19, 
  36883517, 22, 53660808, 21, 53660808, 21, 53660808, 21, 53660808, 21, 
  48034737, 8, 67108310, 7, 67108310, 7, 67108310, 7, 67108310, 7, 67108310, 
  7, 67108310, 7, 67108310, 7, 67108310, 7, 67108310, 7, 53660343, 26, 
  52247917, 19, 53660343, 26, 53647384, 28, 67108310, 7, 53660808, 21, 1, 0, 
  53660808, 21, 1829479, 17, 53660808, 21, 20106226, 22, 52247917, 19, 
  20106226, 22, 53660808, 21, 1829479, 17, 60755752, 51, 20106226, 22, 
  52247917, 19 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/gprd.gi", -39865373 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/gprd.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/gprd.gi");
elif COM_RESULT = 3  then
Revision.gprd_gi:="@(#)$Id: gprd.gi,v 4.46 2003/12/04 00:10:23 gap Exp $";
InstallGlobalFunction(DirectProduct,COM_FUN(1));
InstallMethod(DirectProductOp,"for a list (of groups), and a group",true,[IsList,IsGroup],0,COM_FUN(2));
InstallMethod(\in,"generic direct product",IsElmsColls,[IsTuple,IsGroup and HasDirectProductInfo],0,COM_FUN(3));
InstallMethod(Embedding,"group direct product and integer",true,[IsGroup and HasDirectProductInfo,IsPosInt],0,COM_FUN(4));
InstallMethod(Projection,"group direct product and integer",true,[IsGroup and HasDirectProductInfo,IsPosInt],0,COM_FUN(5));
InstallMethod(Size,"group direct product",true,[IsGroup and HasDirectProductInfo],0,COM_FUN(6));
InstallMethod(IsSolvableGroup,"for direct products",true,[IsGroup and HasDirectProductInfo],0,COM_FUN(7));
InstallMethod(Pcgs,"for direct products",true,[IsGroup and CanEasilyComputePcgs and HasDirectProductInfo],Maximum(RankFilter(IsPcGroup),RankFilter(IsPermGroup and IsSolvableGroup)),COM_FUN(8));
InstallGlobalFunction(SubdirectProduct,COM_FUN(9));
InstallMethod(SubdirectProductOp,"groups",true,[IsGroup,IsGroup,IsGroupHomomorphism,IsGroupHomomorphism],0,COM_FUN(10));
InstallMethod(Projection,"pc subdirect product",true,[IsGroup and HasSubdirectProductInfo,IsPosInt],0,COM_FUN(11));
InstallMethod(Size,"subdirect product",true,[IsGroup and HasSubdirectProductInfo],0,COM_FUN(12));
InstallGlobalFunction(InnerSubdirectProducts2,COM_FUN(13));
InstallGlobalFunction(InnerSubdirectProducts,COM_FUN(14));
InstallGlobalFunction(SubdirectProducts,COM_FUN(15));
InstallOtherMethod(WreathProduct,"generic groups",true,[IsGroup,IsGroup],0,COM_FUN(16));
InstallOtherMethod(WreathProduct,"generic groups with permhom",true,[IsGroup,IsGroup,IsSPGeneralMapping],0,COM_FUN(17));
InstallMethod(PrintObj,"wreath elements",true,[IsWreathProductElement],0,COM_FUN(18));
InstallMethod(OneOp,"wreath elements",true,[IsWreathProductElement],0,COM_FUN(19));
InstallMethod(InverseOp,"wreath elements",true,[IsWreathProductElement],0,COM_FUN(20));
InstallMethod(\*,"wreath elements",IsIdenticalObj,[IsWreathProductElement,IsWreathProductElement],0,COM_FUN(21));
InstallMethod(\=,"wreath elements",IsIdenticalObj,[IsWreathProductElement,IsWreathProductElement],0,COM_FUN(22));
InstallMethod(\<,"wreath elements",IsIdenticalObj,[IsWreathProductElement,IsWreathProductElement],0,COM_FUN(23));
InstallMethod(Embedding,"generic wreath product",true,[IsGroup and HasWreathProductInfo and IsWreathProductElementCollection,IsPosInt],0,COM_FUN(24));
InstallOtherMethod(Projection,"generic wreath product",true,[IsGroup and HasWreathProductInfo and IsWreathProductElementCollection],0,COM_FUN(25));
InstallMethod(\in,"generic wreath product",IsCollsElms,[IsGroup and HasWreathProductInfo and IsWreathProductElementCollection and IsWholeFamily,IsWreathProductElement],0,COM_FUN(26));
InstallOtherMethod(SemidirectProduct,"automorphisms group with group",true,[IsGroup,IsObject],0,COM_FUN(27));
InstallMethod(SemidirectProduct,"different representations",true,[IsGroup,IsGroupHomomorphism,IsGroup],0,COM_FUN(28));
InstallMethod(Embedding,"of semidirect product and integer",true,[IsGroup and HasSemidirectProductInfo,IsPosInt],0,COM_FUN(29));
InstallOtherMethod(Projection,"of semidirect product",true,[IsGroup and HasSemidirectProductInfo],0,COM_FUN(30));
InstallOtherMethod(SemidirectProduct,"group with vector space: affine",true,[IsGroup,IsGroupHomomorphism,IsFullRowModule and IsVectorSpace],0,COM_FUN(31));
InstallMethod(Embedding,"vectorspace semidirect products",true,[IsGroup and HasSemidirectProductInfo,IsPosInt],0,COM_FUN(32));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/gprd.gi"

#F  file="lib/ghomperm.gi" crc=116480216
RANK_FILTER_LIST  := [ 36404717, 18, 36404717, 18, 36404717, 18, 36404717, 
  18, 65767820, 5, 1829479, 17, 38234195, 22, 42105990, 18, 65767820, 5, 
  47807263, 19, 47807263, 19, 47807263, 19, 38796983, 23, 65767820, 5, 
  38796983, 23, 62048771, 31, 18135739, 25, 19037774, 23, 38796983, 23, 513, 
  8, 38796983, 23, 45271600, 30, 38796983, 23, 10485086, 23, 10485086, 23, 
  65767820, 5, 10485086, 23, 45271600, 30, 9583051, 25, 10485086, 23, 
  10485086, 23, 65767820, 5, 10485086, 23, 45271600, 30, 10485086, 23, 
  12314564, 23, 49179149, 22, 45271600, 30, 44568071, 13 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/ghomperm.gi", 116480216 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/ghomperm.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/ghomperm.gi");
elif COM_RESULT = 3  then
Revision.ghomperm_gi:="@(#)$Id: ghomperm.gi,v 4.94.2.2 2004/02/10 18:34:23 gap Exp $";
InstallGlobalFunction(AddGeneratorsGenimagesExtendSchreierTree,COM_FUN(1));
InstallGlobalFunction(ImageSiftedBaseImage,COM_FUN(2));
BindGlobal("IsDoneIterator_CoKernelGens",COM_FUN(3));
BindGlobal("NextIterator_CoKernelGens",COM_FUN(4));
BindGlobal("ShallowCopy_CoKernelGens",COM_FUN(5));
InstallGlobalFunction(CoKernelGensIterator,COM_FUN(6));
InstallGlobalFunction(CoKernelGensPermHom,COM_FUN(7));
InstallGlobalFunction(RelatorsPermGroupHom,COM_FUN(8));
DoShortwordBasepoint:=COM_FUN(9);
InstallOtherMethod(StabChainMutable,"perm mapping by images",true,[IsPermGroupGeneralMappingByImages],0,COM_FUN(10));
InstallMethod(CoKernelOfMultiplicativeGeneralMapping,true,[IsPermGroupGeneralMappingByImages],0,COM_FUN(11));
InstallMethod(IsSingleValued,true,[IsPermGroupGeneralMappingByImages],0,COM_FUN(12));
InstallMethod(ImagesRepresentative,"perm group hom",FamSourceEqFamElm,[IsPermGroupGeneralMappingByImages,IsMultiplicativeElementWithInverse],COM_FUN(13));
InstallMethod(CompositionMapping2,"group hom. with perm group hom.",FamSource1EqFamRange2,[IsGroupHomomorphism,IsPermGroupGeneralMappingByImages and IsGroupHomomorphism],0,COM_FUN(14));
InstallMethod(PreImagesRepresentative,FamRangeEqFamElm,[IsToPermGroupGeneralMappingByImages,IsMultiplicativeElementWithInverse],0,COM_FUN(15));
InstallGlobalFunction(StabChainPermGroupToPermGroupGeneralMappingByImages,COM_FUN(16));
InstallGlobalFunction(MakeStabChainLong,COM_FUN(17));
InstallMethod(StabChainMutable,"perm to perm mapping by images",true,[IsPermGroupGeneralMappingByImages and IsToPermGroupGeneralMappingByImages],0,StabChainPermGroupToPermGroupGeneralMappingByImages);
InstallMethod(KernelOfMultiplicativeGeneralMapping,true,[IsPermGroupGeneralMappingByImages and IsToPermGroupGeneralMappingByImages],0,COM_FUN(18));
InstallMethod(CoKernelOfMultiplicativeGeneralMapping,true,[IsPermGroupGeneralMappingByImages and IsToPermGroupGeneralMappingByImages],0,COM_FUN(19));
InstallMethod(ImagesRepresentative,"Constituent homomorphism",FamSourceEqFamElm,[IsConstituentHomomorphism,IsMultiplicativeElementWithInverse],0,COM_FUN(20));
InstallMethod(ImagesSet,"constituent homomorphism",CollFamSourceEqFamElms,[IsConstituentHomomorphism,IsPermGroup and HasStabChainMutable],0,COM_FUN(21));
RanImgSrcSurjTraho:=COM_FUN(22);
InstallMethod(Range,"surjective constituent homomorphism",true,[IsConstituentHomomorphism and IsActionHomomorphism and IsSurjective],0,RanImgSrcSurjTraho);
InstallMethod(ImagesSource,"constituent homomorphism",true,[IsConstituentHomomorphism and IsActionHomomorphism],0,RanImgSrcSurjTraho);
InstallMethod(PreImagesRepresentative,"constituent homomorphism",FamRangeEqFamElm,[IsConstituentHomomorphism,IsPerm],0,COM_FUN(23));
InstallMethod(PreImagesSet,"constituent homomorphism",CollFamRangeEqFamElms,[IsConstituentHomomorphism,IsPermGroup],0,COM_FUN(24));
InstallMethod(KernelOfMultiplicativeGeneralMapping,"for constituent homomorphism",true,[IsConstituentHomomorphism],0,COM_FUN(25));
InstallMethod(StabChainMutable,"for blocks homomorphism",true,[IsBlocksHomomorphism],0,COM_FUN(26));
InstallMethod(ImagesRepresentative,"blocks homomorphism",FamSourceEqFamElm,[IsBlocksHomomorphism,IsMultiplicativeElementWithInverse],0,COM_FUN(27));
InstallGlobalFunction(ImageKernelBlocksHomomorphism,COM_FUN(28));
InstallMethod(ImagesSet,"for blocks homomorphism and perm. group",CollFamSourceEqFamElms,[IsBlocksHomomorphism,IsPermGroup],0,COM_FUN(29));
RanImgSrcSurjBloho:=COM_FUN(30);
InstallMethod(Range,"surjective blocks homomorphism",true,[IsBlocksHomomorphism and IsSurjective],0,RanImgSrcSurjBloho);
InstallMethod(ImagesSource,"blocks homomorphism",true,[IsBlocksHomomorphism],0,RanImgSrcSurjBloho);
InstallMethod(PreImagesRepresentative,"blocks homomorphism",FamRangeEqFamElm,[IsBlocksHomomorphism,IsMultiplicativeElementWithInverse],0,COM_FUN(31));
InstallMethod(PreImagesSet,CollFamRangeEqFamElms,[IsBlocksHomomorphism,IsPermGroup],0,COM_FUN(32));
InstallGlobalFunction(PreImageSetStabBlocksHomomorphism,COM_FUN(33));
InstallMethod(KernelOfMultiplicativeGeneralMapping,"blocks homomorphism",true,[IsBlocksHomomorphism],0,COM_FUN(34));
DeclareRepresentation("IsBlocksOfActionHomomorphism",IsActionHomomorphismByBase,[]);
InstallMethod(CompositionMapping2,"for action homomorphism with blocks homomorphism",FamSource1EqFamRange2,[IsGroupHomomorphism and IsBlocksHomomorphism,IsGroupHomomorphism and IsActionHomomorphism],0,COM_FUN(35));
InstallMethod(IsomorphismPermGroup,"perm groups",true,[IsPermGroup],0,IdentityMapping);
InstallOtherMethod(IsConjugatorIsomorphism,"perm group homomorphism",true,[IsGroupGeneralMapping],1,COM_FUN(36));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/ghomperm.gi"

#F  file="lib/grpperm.gi" crc=-106955520
RANK_FILTER_LIST  := [ 45271600, 33, 45271600, 33, 66124164, 42, 58719672, 
  33, 41951068, 17, 58719672, 33, 41951068, 17, 58719672, 33, 41951068, 17, 
  513, 8, 58719672, 33, 41951068, 17, 45271600, 33, 45271600, 33, 45271600, 
  33, 45271600, 33, 45271600, 33, 45271600, 33, 45271600, 33, 45271600, 33, 
  513, 8, 9436245, 34, 45271600, 33, 58727864, 36, 4097, 1, 45271600, 33, 
  41951068, 17, 45271600, 33, 513, 8, 45271600, 33, 58727864, 36, 45271600, 
  33, 513, 8, 4097, 1, 45271600, 33, 45271600, 33, 4097, 1, 45271600, 33, 
  41951068, 17, 4097, 1, 45271600, 33, 45271600, 33, 45271600, 33, 513, 8, 
  45271600, 33, 45271600, 33, 45271600, 33, 45271600, 33, 45271600, 33, 
  45271600, 33, 45271600, 33, 45271600, 33, 45271600, 33, 45271600, 33, 
  28483029, 40, 45260440, 39, 45260440, 39, 45271600, 33, 52247917, 19, 
  45271600, 33, 52247917, 19, 45271600, 33, 45271600, 33, 45271600, 33, 
  52247917, 19, 52247917, 19, 10150423, 10, 52247917, 19, 10150423, 10, 513, 
  8, 45271600, 33, 45271600, 33, 45271600, 33, 45271600, 33, 45271600, 33, 
  45271600, 33, 45271600, 33, 45271600, 33, 8193, 2, 9436245, 34, 45271600, 
  33, 45271600, 33, 45271600, 33, 45271600, 33, 45271600, 33 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grpperm.gi", -106955520 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grpperm.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grpperm.gi");
elif COM_RESULT = 3  then
Revision.grpperm_gi:="@(#)$Id: grpperm.gi,v 4.155.2.2 2004/10/21 22:07:29 gap Exp $";
InstallTrueMethod(CanEasilyTestMembership,IsPermGroup);
InstallTrueMethod(CanEasilyComputePcgs,IsPermGroup and IsSolvableGroup);
InstallTrueMethod(CanComputeSizeAnySubgroup,IsPermGroup);
InstallMethod(AsSubgroup,"perm groups",IsIdenticalObj,[IsPermGroup,IsPermGroup],0,COM_FUN(1));
InstallGlobalFunction(IndependentGeneratorsAbelianPPermGroup,COM_FUN(2));
InstallMethod(IndependentGeneratorsOfAbelianGroup,"for perm group",[IsPermGroup and IsAbelian],COM_FUN(3));
InstallGlobalFunction(OrbitPerms,COM_FUN(4));
InstallGlobalFunction(OrbitsPerms,COM_FUN(5));
SmallestMovedPointPerms:=COM_FUN(6);
InstallMethod(SmallestMovedPoint,"for a collection of permutations",true,[IsPermCollection],0,SmallestMovedPointPerms);
InstallMethod(SmallestMovedPoint,"for an empty list",true,[IsList and IsEmpty],0,SmallestMovedPointPerms);
LargestMovedPointPerms:=COM_FUN(7);
InstallMethod(LargestMovedPoint,"for a collection of permutations",true,[IsPermCollection],0,LargestMovedPointPerms);
InstallMethod(LargestMovedPoint,"for an empty list",true,[IsList and IsEmpty],0,LargestMovedPointPerms);
InstallGlobalFunction(MovedPointsPerms,COM_FUN(8));
InstallMethod(MovedPoints,"for a collection of permutations",true,[IsPermCollection],0,MovedPointsPerms);
InstallMethod(MovedPoints,"for an empty list",true,[IsList and IsEmpty],0,MovedPointsPerms);
InstallMethod(MovedPoints,"for a permutation",true,[IsPerm],0,COM_FUN(9));
NrMovedPointsPerms:=COM_FUN(10);
InstallMethod(NrMovedPoints,"for a collection of permutations",true,[IsPermCollection],0,NrMovedPointsPerms);
InstallMethod(NrMovedPoints,"for an empty list",true,[IsList and IsEmpty],0,NrMovedPointsPerms);
InstallMethod(LargestMovedPoint,"for a permutation group",true,[IsPermGroup],0,COM_FUN(11));
InstallMethod(SmallestMovedPoint,"for a permutation group",true,[IsPermGroup],0,COM_FUN(12));
InstallMethod(MovedPoints,"for a permutation group",true,[IsPermGroup],0,COM_FUN(13));
InstallMethod(NrMovedPoints,"for a permutation group",true,[IsPermGroup],0,COM_FUN(14));
InstallMethod(BaseOfGroup,"for a permutation group",true,[IsPermGroup],0,COM_FUN(15));
InstallMethod(Size,"for a permutation group",true,[IsPermGroup],0,COM_FUN(16));
BindGlobal("ElementNumber_PermGroup",COM_FUN(17));
BindGlobal("NumberElement_PermGroup",COM_FUN(18));
InstallMethod(Enumerator,"for a permutation group",[IsPermGroup],COM_FUN(19));
InstallMethod(Random,"for a permutation group",[IsPermGroup],10,COM_FUN(20));
InstallMethod(\in,"for a permutation, and a permutation group",true,[IsPerm,IsPermGroup and HasGeneratorsOfGroup],0,COM_FUN(21));
BindGlobal("DoClosurePrmGp",COM_FUN(22));
BindGlobal("PG_EMPTY_OPT",rec());
InstallOtherMethod(ClosureGroup,"permgroup, elements, options",true,[IsPermGroup,IsList and IsPermCollection,IsRecord],0,DoClosurePrmGp);
InstallOtherMethod(ClosureGroup,"empty list",true,[IsPermGroup,IsList and IsEmpty],0,COM_FUN(23));
InstallMethod(ClosureGroup,"permgroup, element",true,[IsPermGroup,IsPerm],0,COM_FUN(24));
InstallMethod(ClosureGroup,"permgroup, elements",true,[IsPermGroup,IsList and IsPermCollection],0,COM_FUN(25));
InstallOtherMethod(ClosureGroup,"permgroup, element, options",true,[IsPermGroup,IsPerm,IsRecord],0,COM_FUN(26));
InstallOtherMethod(ClosureGroup,"permgroup, permgroup, options",true,[IsPermGroup,IsPermGroup,IsRecord],0,COM_FUN(27));
InstallOtherMethod(ClosureGroup,"empty list and options",true,[IsPermGroup,IsList and IsEmpty,IsRecord],0,COM_FUN(28));
BindGlobal("DoNormalClosurePermGroup",COM_FUN(29));
InstallMethod(NormalClosureOp,"subgroup of perm group",IsIdenticalObj,[IsPermGroup,IsPermGroup],0,COM_FUN(30));
InstallMethod(ConjugateGroup,"<P>, <g>",true,[IsPermGroup,IsPerm],0,COM_FUN(31));
InstallMethod(CommutatorSubgroup,"permgroups",IsIdenticalObj,[IsPermGroup,IsPermGroup],0,COM_FUN(32));
InstallMethod(DerivedSubgroup,"permgrps",true,[IsPermGroup],0,COM_FUN(33));
InstallMethod(IsSimpleGroup,"for permgrp",true,[IsPermGroup],0,COM_FUN(34));
InstallMethod(IsSolvableGroup,"for permgrp",true,[IsPermGroup],0,COM_FUN(35));
InstallMethod(IsNilpotentGroup,"for permgrp",true,[IsPermGroup],0,COM_FUN(36));
InstallOtherMethod(PcgsCentralSeries,"for permgrp",true,[IsPermGroup],0,COM_FUN(37));
InstallOtherMethod(PcgsPCentralSeriesPGroup,"for permgrp",true,[IsPermGroup],0,COM_FUN(38));
InstallMethod(DerivedSeriesOfGroup,"for permgrp",true,[IsPermGroup],0,COM_FUN(39));
InstallMethod(LowerCentralSeriesOfGroup,"for permgrp",true,[IsPermGroup],0,COM_FUN(40));
InstallOtherMethod(ElementaryAbelianSeries,"perm group",true,[IsPermGroup and IsFinite],RankFilter(IsPermGroup and CanEasilyComputePcgs and IsFinite)-RankFilter(IsPermGroup and IsFinite),COM_FUN(41));
InstallMethod(PCentralSeriesOp,"for permgrp",true,[IsPermGroup,IsPosInt],0,COM_FUN(42));
InstallMethod(SylowSubgroupOp,"permutation groups",true,[IsPermGroup,IsPosInt],0,COM_FUN(43));
InstallGlobalFunction(SylowSubgroupPermGroup,COM_FUN(44));
InstallMethod(Socle,"for permgrp",true,[IsPermGroup],0,COM_FUN(45));
InstallMethod(FrattiniSubgroup,"for permgrp",true,[IsPermGroup],0,COM_FUN(46));
InstallMethod(OmegaOp,"in abelian perm groups",true,[IsPermGroup,IsPosInt,IsPosInt],0,COM_FUN(47));
InstallGlobalFunction(MinimizeExplicitTransversal,COM_FUN(48));
BindGlobal("RightTransversalPermGroupConstructor",COM_FUN(49));
DeclareRepresentation("IsRightTransversalPermGroupRep",IsRightTransversalRep,["stabChainGroup","stabChainSubgroup"]);
InstallMethod(\[\],"for right transversal of perm. group, and pos. integer",true,[IsList and IsRightTransversalPermGroupRep,IsPosInt],0,COM_FUN(50));
InstallMethod(PositionCanonical,"for right transversal of perm. group, and permutation",IsCollsElms,[IsList and IsRightTransversalPermGroupRep,IsPerm],0,COM_FUN(51));
InstallMethod(RightTransversalOp,"for two perm. groups",IsIdenticalObj,[IsPermGroup,IsPermGroup],0,COM_FUN(52));
MAX_SIZE_TRANSVERSAL:=100000;
InstallGlobalFunction(AddCosetInfoStabChain,COM_FUN(53));
InstallGlobalFunction(NumberCoset,COM_FUN(54));
InstallGlobalFunction(CosetNumber,COM_FUN(55));
InstallGlobalFunction(ApproximateSuborbitsStabilizerPermGroup,COM_FUN(56));
InstallMethod(AllBlocks,"generic",[IsPermGroup],COM_FUN(57));
InstallGlobalFunction(SignPermGroup,COM_FUN(58));
CreateAllCycleStructures:=COM_FUN(59);
InstallGlobalFunction(CycleStructuresGroup,COM_FUN(60));
InstallMethod(SmallGeneratingSet,"random and generators subset, randsims",true,[IsPermGroup],0,COM_FUN(61));
InstallMethod(MinimalGeneratingSet,"solvable perm group via pc",true,[IsPermGroup],0,COM_FUN(62));
DeclareGlobalFunction("GeneratorsSmallestStab");
InstallGlobalFunction(GeneratorsSmallestStab,COM_FUN(63));
InstallMethod(GeneratorsSmallest,"perm group via minimal stab chain",[IsPermGroup],COM_FUN(64));
InstallMethod(LargestElementGroup,"perm group via minimal stab chain",[IsPermGroup],COM_FUN(65));
InstallMethod(KnowsHowToDecompose,"perm group and generators: always true",IsIdenticalObj,[IsPermGroup,IsList],ReturnTrue);
InstallMethod(ViewObj,"for a permutation group",true,[IsPermGroup and HasGeneratorsOfGroup],0,COM_FUN(66));
InstallMethod(AsList,"permgp: AsSSortedList",true,[IsPermGroup],0,AsSSortedList);
InstallMethod(AsSSortedList,"via stabchain",true,[IsPermGroup],0,COM_FUN(67));
InstallMethod(AsSSortedListNonstored,"via stabchain",true,[IsPermGroup],0,COM_FUN(68));
InstallMethod(ONanScottType,"primitive permgroups",true,[IsPermGroup],0,COM_FUN(69));
InstallMethod(SocleTypePrimitiveGroup,"primitive permgroups",true,[IsPermGroup],0,COM_FUN(70));
BindGlobal("STGSelFunc",COM_FUN(71));
InstallGlobalFunction(DiagonalSocleAction,COM_FUN(72));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grpperm.gi"

#F  file="lib/gpprmsya.gi" crc=-31668017
RANK_FILTER_LIST  := [ 513, 8, 32008881, 37, 32008881, 37, 65767820, 5, 
  32008881, 37, 1, 0, 1, 0, 5, 1, 32008881, 37, 52247917, 19, 32008881, 37, 
  32008881, 37, 32008881, 37, 67108760, 5, 45273522, 34, 45271600, 33, 
  45273522, 34, 45271600, 33, 513, 8, 58604539, 37, 58604539, 37, 45271600, 
  33, 58604539, 37, 58604539, 37, 65767820, 5, 58604539, 37, 52247917, 19, 5, 
  1, 58604539, 37, 513, 8, 58604539, 37, 45271600, 33, 32008881, 37, 
  45271600, 33, 65767820, 5, 58604539, 37, 1, 0, 1, 0, 5, 1, 58604539, 37, 
  52247917, 19, 58604539, 37, 58604539, 37, 58604539, 37, 67108760, 5, 
  58604539, 37, 32008881, 37, 58604539, 37, 32008881, 37, 45271600, 33, 
  58604539, 37, 45271600, 33, 58604539, 37, 4097, 1, 45271600, 33 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/gpprmsya.gi", -31668017 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/gpprmsya.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/gpprmsya.gi");
elif COM_RESULT = 3  then
Revision.gpprmsya_gi:="@(#)$Id: gpprmsya.gi,v 4.38.2.2 2004/02/04 02:48:57 gap Exp $";
if not IsBound(TRANSDEGREES) then
TRANSDEGREES:=0;
fi;
InstallMethod(\in,"alternating",true,[IsPerm,IsNaturalAlternatingGroup],0,COM_FUN(1));
InstallMethod(Random,"alternating group: floyd's algorithm",true,[IsNaturalAlternatingGroup],10,COM_FUN(2));
InstallOtherMethod(RepresentativeActionOp,"natural alternating group",true,[IsNaturalAlternatingGroup,IsObject,IsObject,IsFunction],2*RankFilter(IsMultiplicativeElementWithInverse),COM_FUN(3));
InstallMethod(SylowSubgroupOp,"alternating",true,[IsNaturalAlternatingGroup,IsPosInt],0,COM_FUN(4));
InstallMethod(ConjugacyClasses,"alternating",true,[IsNaturalAlternatingGroup],0,COM_FUN(5));
InstallMethod(IsomorphismFpGroup,"alternating group",true,[IsNaturalAlternatingGroup],10,COM_FUN(6));
InstallOtherMethod(IsomorphismFpGroup,"alternating group,name",true,[IsNaturalAlternatingGroup,IsString],10,COM_FUN(7));
PermNatAnTestDetect:=COM_FUN(8);
BindGlobal("DoSnAnGiantTest",COM_FUN(9));
BindGlobal("PermgpContainsAn",COM_FUN(10));
InstallMethod(IsNaturalAlternatingGroup,"knows size",true,[IsPermGroup and HasSize],0,COM_FUN(11));
InstallMethod(IsNaturalAlternatingGroup,"comprehensive",true,[IsPermGroup],0,COM_FUN(12));
InstallMethod(IsNaturalSymmetricGroup,"knows size",true,[IsPermGroup and HasSize],0,COM_FUN(13));
InstallMethod(IsNaturalSymmetricGroup,"comprehensive",true,[IsPermGroup],0,COM_FUN(14));
InstallMethod(\in,"perm in natsymmetric group",true,[IsPerm,IsNaturalSymmetricGroup],0,COM_FUN(15));
InstallMethod(IsSubset,"permgrp of natsymmetric group",true,[IsNaturalSymmetricGroup,IsPermGroup],SUM_FLAGS,COM_FUN(16));
InstallMethod(Size,true,[IsNaturalSymmetricGroup],0,COM_FUN(17));
InstallMethod(Random,"symmetric group: floyd's algorithm",true,[IsNaturalSymmetricGroup],10,COM_FUN(18));
InstallOtherMethod(StabilizerOp,"symmetric group",true,[IsNaturalSymmetricGroup,IsPosInt,IsFunction],RankFilter(IsMultiplicativeElementWithInverse),COM_FUN(19));
InstallMethod(CentralizerOp,"element in natural symmetric group",IsCollsElms,[IsNaturalSymmetricGroup,IsPerm],0,COM_FUN(20));
BindGlobal("OneNormalizerfixedBlockSystem",COM_FUN(21));
BindGlobal("NormalizerParentSA",COM_FUN(22));
BindGlobal("DoNormalizerSA",COM_FUN(23));
InstallMethod(NormalizerOp,"subgp of natural symmetric group",IsIdenticalObj,[IsNaturalSymmetricGroup,IsPermGroup],0,DoNormalizerSA);
InstallMethod(NormalizerOp,"subgp of natural alternating group",IsIdenticalObj,[IsNaturalAlternatingGroup,IsPermGroup],0,DoNormalizerSA);
BindGlobal("SubgpConjSymmgp",COM_FUN(24));
InstallOtherMethod(RepresentativeActionOp,"for natural symmetric group",true,[IsNaturalSymmetricGroup,IsObject,IsObject,IsFunction],2*RankFilter(IsMultiplicativeElementWithInverse),COM_FUN(25));
InstallMethod(SylowSubgroupOp,"symmetric",true,[IsNaturalSymmetricGroup,IsPosInt],0,COM_FUN(26));
InstallMethod(ConjugacyClasses,"symmetric",true,[IsNaturalSymmetricGroup],0,COM_FUN(27));
InstallMethod(IsomorphismFpGroup,"alternating group",true,[IsNaturalSymmetricGroup],0,COM_FUN(28));
InstallOtherMethod(IsomorphismFpGroup,"symmetric group,name",true,[IsNaturalSymmetricGroup,IsString],0,COM_FUN(29));
InstallMethod(ViewObj,"for natural symmetric group",true,[IsNaturalSymmetricGroup],0,COM_FUN(30));
InstallMethod(ViewObj,"for natural alternating group",true,[IsNaturalAlternatingGroup],0,COM_FUN(31));
InstallMethod(PrintObj,"for natural symmetric group",true,[IsNaturalSymmetricGroup],0,COM_FUN(32));
InstallMethod(PrintObj,"for natural alternating group",true,[IsNaturalAlternatingGroup],0,COM_FUN(33));
InstallMethod(SymmetricParentGroup,"symm(moved pts)",true,[IsPermGroup],0,COM_FUN(34));
InstallMethod(SymmetricParentGroup,"natural symmetric group",true,[IsNaturalSymmetricGroup],0,IdFunc);
InstallMethod(OrbitStabilizingParentGroup,"direct product of S_n's",true,[IsPermGroup],0,COM_FUN(35));
InstallOtherMethod(StabChainOp,"symmetric group",true,[IsNaturalSymmetricGroup,IsRecord],0,COM_FUN(36));
InstallMethod(AlternatingSubgroup,"for perm groups",true,[IsPermGroup],0,COM_FUN(37));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/gpprmsya.gi"

#F  file="lib/gprdperm.gi" crc=115635240
RANK_FILTER_LIST  := [ 50339616, 17, 45271600, 33, 3328035, 34, 3328035, 34, 
  52247917, 19, 20284461, 23, 20284461, 23, 65767820, 5, 20284461, 23, 
  65767820, 5, 20284461, 23, 20284461, 23, 20284461, 23, 3328035, 34, 
  52247917, 19, 56118725, 23, 56118725, 23, 65767820, 5, 56118725, 23, 
  65767820, 5, 56118725, 23, 56118725, 23, 56118725, 23, 45271600, 33, 
  45271600, 33, 1829479, 17, 1829479, 17, 28494309, 34, 52247917, 19, 
  45128570, 23, 45128570, 23, 65767820, 5, 45128570, 23, 65767820, 5, 
  45128570, 23, 45128570, 23, 45128570, 23, 45271600, 33, 45271600, 33, 
  45271600, 33, 45271600, 33, 48034737, 8, 45271315, 34, 52247917, 19, 
  40568921, 23, 14028962, 24, 65767820, 5, 14028962, 24, 65767820, 5, 
  40568921, 23, 40568921, 23, 45271315, 34, 45271600, 33, 1829479, 17, 
  45271600, 33, 11717018, 34, 52247917, 19, 11717018, 34 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/gprdperm.gi", 115635240 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/gprdperm.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/gprdperm.gi");
elif COM_RESULT = 3  then
Revision.gprdperm_gi:="@(#)$Id: gprdperm.gi,v 4.37.2.2 2005/01/06 08:22:04 gap Exp $";
InstallMethod(DirectProductOp,"for a list of permutation groups, and a permutation group",IsCollsElms,[IsList and IsPermCollColl,IsPermGroup],0,COM_FUN(1));
InstallMethod(Size,"for a permutation group that knows to be a direct product",true,[IsPermGroup and HasDirectProductInfo],0,COM_FUN(2));
DeclareRepresentation("IsEmbeddingDirectProductPermGroup",IsAttributeStoringRep and IsGroupHomomorphism and IsInjective and IsSPGeneralMapping,["component"]);
DeclareRepresentation("IsEmbeddingWreathProductPermGroup",IsAttributeStoringRep and IsGroupHomomorphism and IsInjective and IsSPGeneralMapping,["component"]);
DeclareRepresentation("IsEmbeddingImprimitiveWreathProductPermGroup",IsEmbeddingWreathProductPermGroup,["component"]);
DeclareRepresentation("IsEmbeddingProductActionWreathProductPermGroup",IsEmbeddingWreathProductPermGroup and IsGroupGeneralMappingByAsGroupGeneralMap\
pingByImages,["component"]);
InstallMethod(Embedding,"perm direct product",true,[IsPermGroup and HasDirectProductInfo,IsPosInt],0,COM_FUN(3));
InstallMethod(Source,"perm direct product embedding",true,[IsEmbeddingDirectProductPermGroup],0,COM_FUN(4));
InstallMethod(ImagesRepresentative,"perm direct product embedding",FamSourceEqFamElm,[IsEmbeddingDirectProductPermGroup,IsMultiplicativeElementWithInverse],0,COM_FUN(5));
InstallMethod(PreImagesRepresentative,"perm direct product embedding",FamRangeEqFamElm,[IsEmbeddingDirectProductPermGroup,IsMultiplicativeElementWithInverse],COM_FUN(6));
InstallMethod(ImagesSource,"perm direct product embedding",true,[IsEmbeddingDirectProductPermGroup],0,COM_FUN(7));
InstallMethod(ViewObj,"for embedding into direct product",true,[IsEmbeddingDirectProductPermGroup],0,COM_FUN(8));
InstallMethod(PrintObj,"for embedding into direct product",true,[IsEmbeddingDirectProductPermGroup],0,COM_FUN(9));
DeclareRepresentation("IsProjectionDirectProductPermGroup",IsAttributeStoringRep and IsGroupHomomorphism and IsSurjective and IsSPGeneralMapping,["component"]);
InstallMethod(Projection,"perm direct product",true,[IsPermGroup and HasDirectProductInfo,IsPosInt],0,COM_FUN(10));
InstallMethod(Range,"perm direct product projection",true,[IsProjectionDirectProductPermGroup],0,COM_FUN(11));
InstallMethod(ImagesRepresentative,"perm direct product projection",FamSourceEqFamElm,[IsProjectionDirectProductPermGroup,IsMultiplicativeElementWithInverse],0,COM_FUN(12));
InstallMethod(PreImagesRepresentative,"perm direct product projection",FamRangeEqFamElm,[IsProjectionDirectProductPermGroup,IsMultiplicativeElementWithInverse],0,COM_FUN(13));
InstallMethod(KernelOfMultiplicativeGeneralMapping,"perm direct product projection",true,[IsProjectionDirectProductPermGroup],0,COM_FUN(14));
InstallMethod(ViewObj,"for projection from a direct product",true,[IsProjectionDirectProductPermGroup],0,COM_FUN(15));
InstallMethod(PrintObj,"for projection from a direct product",true,[IsProjectionDirectProductPermGroup],0,COM_FUN(16));
InstallGlobalFunction(SubdirectDiagonalPerms,COM_FUN(17));
InstallMethod(SubdirectProductOp,"permgroup",true,[IsPermGroup,IsPermGroup,IsGroupHomomorphism,IsGroupHomomorphism],0,COM_FUN(18));
DeclareRepresentation("IsProjectionSubdirectProductPermGroup",IsAttributeStoringRep and IsGroupHomomorphism and IsSurjective and IsSPGeneralMapping,["component"]);
InstallMethod(Projection,"perm subdirect product",true,[IsPermGroup and HasSubdirectProductInfo,IsPosInt],0,COM_FUN(19));
InstallMethod(Range,"perm subdirect product projection",true,[IsProjectionSubdirectProductPermGroup],0,COM_FUN(20));
InstallMethod(ImagesRepresentative,"perm subdirect product projection",FamSourceEqFamElm,[IsProjectionSubdirectProductPermGroup,IsMultiplicativeElementWithInverse],0,COM_FUN(21));
InstallMethod(PreImagesRepresentative,"perm subdirect product projection",FamRangeEqFamElm,[IsProjectionSubdirectProductPermGroup,IsMultiplicativeElementWithInverse],0,COM_FUN(22));
InstallMethod(KernelOfMultiplicativeGeneralMapping,"perm subdirect product projection",true,[IsProjectionSubdirectProductPermGroup],0,COM_FUN(23));
InstallMethod(ViewObj,"for projection from subdirect product",true,[IsProjectionSubdirectProductPermGroup],0,COM_FUN(24));
InstallMethod(PrintObj,"for projection from subdirect product",true,[IsProjectionSubdirectProductPermGroup],0,COM_FUN(25));
InstallGlobalFunction(WreathProductImprimitiveAction,COM_FUN(26));
InstallMethod(WreathProduct,"permgroups: imprimitive",true,[IsPermGroup,IsPermGroup],0,WreathProductImprimitiveAction);
InstallOtherMethod(WreathProduct,"permgroups and action",true,[IsPermGroup,IsPermGroup,IsSPGeneralMapping],0,WreathProductImprimitiveAction);
InstallMethod(Embedding,"perm wreath product",true,[IsPermGroup and HasWreathProductInfo,IsPosInt],0,COM_FUN(27));
InstallMethod(Source,"perm wreath product embedding",true,[IsEmbeddingWreathProductPermGroup],0,COM_FUN(28));
InstallMethod(ImagesRepresentative,"imprim perm wreath product embedding",FamSourceEqFamElm,[IsEmbeddingImprimitiveWreathProductPermGroup,IsMultiplicativeElementWithInverse],0,COM_FUN(29));
InstallMethod(PreImagesRepresentative,"imprim perm wreath product embedding",FamRangeEqFamElm,[IsEmbeddingImprimitiveWreathProductPermGroup,IsMultiplicativeElementWithInverse],0,COM_FUN(30));
InstallMethod(ViewObj,"for embedding into wreath product",true,[IsEmbeddingWreathProductPermGroup],0,COM_FUN(31));
InstallMethod(PrintObj,"for embedding into wreath product",true,[IsEmbeddingWreathProductPermGroup],0,COM_FUN(32));
InstallOtherMethod(Projection,"perm wreath product",true,[IsPermGroup and HasWreathProductInfo],0,COM_FUN(33));
InstallGlobalFunction(WreathProductProductAction,COM_FUN(34));
InstallMethod(SemidirectProduct,"generic method for permutation groups",true,[IsPermGroup,IsGroupHomomorphism,IsPermGroup],0,COM_FUN(35));
InstallMethod(Embedding,"generic method for perm semidirect products",true,[IsPermGroup and HasSemidirectProductInfo,IsPosInt],0,COM_FUN(36));
InstallOtherMethod(Projection,"generic method for perm semidirect products",true,[IsPermGroup and HasSemidirectProductInfo],0,COM_FUN(37));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/gprdperm.gi"

#F  file="lib/gprdpc.gi" crc=-99879880
RANK_FILTER_LIST  := [ 8193, 2, 12585763, 33, 37751077, 34, 52247917, 19, 
  37751077, 34, 52247917, 19, 50331469, 25, 1829479, 17, 50331469, 25, 
  12585763, 33, 4097, 1, 12585763, 33, 1829479, 17, 46140060, 34, 52247917, 
  19, 46140060, 34, 12585763, 33, 12585763, 33, 1829479, 17, 1829479, 17 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/gprdpc.gi", -99879880 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/gprdpc.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/gprdpc.gi");
elif COM_RESULT = 3  then
Revision.gprdpc_gi:="@(#)$Id: gprdpc.gi,v 4.24.4.2 2004/03/04 22:25:02 gap Exp $";
InstallMethod(DirectProductOp,"for a list (of pc groups), and a pc group",true,[IsList,IsPcGroup],0,COM_FUN(1));
InstallMethod(Embedding,"of pc group and integer",true,[IsPcGroup and HasDirectProductInfo,IsPosInt],0,COM_FUN(2));
InstallMethod(Projection,"of pc group and integer",true,[IsPcGroup and HasDirectProductInfo,IsPosInt],0,COM_FUN(3));
InstallMethod(SemidirectProduct,"generic method for pc groups",true,[CanEasilyComputePcgs,IsGroupHomomorphism,CanEasilyComputePcgs],0,COM_FUN(4));
InstallOtherMethod(SemidirectProduct,"generic method for pc groups",true,[IsPcGroup,IsRecord],0,COM_FUN(5));
InstallOtherMethod(SemidirectProduct,"generic method for pc groups",true,[IsPcGroup,IsGroupHomomorphism],0,COM_FUN(6));
InstallMethod(Embedding,"of semidirect pc group and integer",true,[IsPcGroup and HasSemidirectProductInfo,IsPosInt],0,COM_FUN(7));
InstallOtherMethod(Projection,"of semidirect pc group",true,[IsPcGroup and HasSemidirectProductInfo],0,COM_FUN(8));
InstallGlobalFunction(SubdirProdPcGroups,COM_FUN(9));
InstallMethod(SubdirectProductOp,"pcgroup",true,[IsPcGroup,IsPcGroup,IsGroupHomomorphism,IsGroupHomomorphism],0,COM_FUN(10));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/gprdpc.gi"

#F  file="lib/oprt.gi" crc=-97063366
RANK_FILTER_LIST  := [ 53660808, 21, 4063233, 1, 8193, 2, 8193, 2, 5, 1, 
  35312242, 6, 53660808, 21, 35312242, 6, 56249649, 9, 35312242, 6, 35312242, 
  6, 35312242, 6, 53660808, 21, 8193, 2, 8193, 2, 8193, 2, 8193, 2, 5, 1, 
  53660808, 21, 35312242, 6, 8193, 2, 8193, 2, 8193, 2, 5, 1, 53660808, 21, 
  8193, 2, 8193, 2, 8193, 2, 5, 1, 3515604, 9, 3515604, 9, 27190439, 10, 
  7031207, 10, 7031207, 10, 53660808, 21, 4063233, 1, 1, 0, 8193, 2, 8193, 2, 
  5, 1, 53660808, 21, 35312242, 6, 1, 0, 8193, 2, 8193, 2, 5, 1, 53660808, 
  21, 1, 0, 8193, 2, 8193, 2, 5, 1, 7031207, 10, 7031207, 10, 7031207, 10, 
  7031207, 10, 7031207, 10, 7031207, 10, 7031207, 10, 7031207, 10, 7033129, 
  12, 7033129, 12, 50134401, 11, 50134401, 11, 1, 0, 7033129, 12, 1, 0, 
  7031207, 10, 1, 0, 35316086, 7, 1, 0, 7061959, 11, 1, 0, 7277223, 11, 1, 0, 
  8015271, 11, 1, 0, 50134401, 11, 35312242, 6, 35312242, 6, 47349671, 22, 
  47349671, 22, 47349671, 22, 47349671, 22, 46447636, 24, 47349671, 22, 
  53660808, 21, 53660808, 21, 4063233, 1, 1, 0, 8193, 2, 8193, 2, 5, 1, 
  53660808, 21, 1, 0, 8193, 2, 8193, 2, 5, 1, 53660808, 21, 4063233, 1, 1, 0, 
  8193, 2, 8193, 2, 5, 1, 53660808, 21, 1, 0, 8193, 2, 8193, 2, 5, 1, 
  53660808, 21, 4063233, 1, 1, 0, 8193, 2, 8193, 2, 5, 1, 53660808, 21, 1, 0, 
  8193, 2, 8193, 2, 5, 1, 15425860, 29, 1, 0, 1, 0, 8193, 2, 8193, 2, 4097, 
  1, 53660808, 21, 1, 0, 1, 0, 8193, 2, 8193, 2, 4097, 1, 53660808, 21, 
  16784689, 3, 8193, 2, 8193, 2, 5, 1, 53660808, 21, 4063233, 1, 8193, 2, 
  8193, 2, 5, 1, 53660808, 21, 41951068, 17, 8193, 2, 8193, 2, 5, 1, 
  53660808, 21, 53660808, 21, 4063233, 1, 8193, 2, 8193, 2, 5, 1, 53660808, 
  21, 41951068, 17, 8193, 2, 8193, 2, 5, 1, 53660808, 21, 53660808, 21, 8193, 
  2, 8193, 2, 8193, 2, 8193, 2, 5, 1, 53660808, 21, 8193, 2, 8193, 2, 8193, 
  2, 5, 1, 53660808, 21, 8193, 2, 8193, 2, 8193, 2, 5, 1, 53660808, 21, 
  4063233, 1, 8193, 2, 8193, 2, 5, 1, 53660808, 21, 35312242, 6, 8193, 2, 
  8193, 2, 5, 1, 53660808, 21, 4063233, 1, 8193, 2, 8193, 2, 5, 1, 53660808, 
  21, 35312242, 6, 8193, 2, 8193, 2, 5, 1, 1, 0, 8193, 2, 5, 1, 1, 0, 8193, 
  2, 1, 0, 5, 1, 1, 0, 8193, 2, 1, 0, 5, 1, 1, 0, 1, 0, 5, 1, 1, 0, 8193, 2, 
  5, 1, 53660808, 21, 8193, 2, 8193, 2, 8193, 2, 5, 1, 53660808, 21, 8193, 2, 
  8193, 2, 8193, 2, 8193, 2, 5, 1, 53660808, 21, 41951068, 17, 8193, 2, 8193, 
  2, 8193, 2, 5, 1, 53660808, 21, 8193, 2, 8193, 2, 8193, 2, 5, 1, 53660808, 
  21, 8193, 2, 8193, 2, 8193, 2, 8193, 2, 5, 1, 53660808, 21, 4063233, 1, 1, 
  0, 8193, 2, 8193, 2, 5, 1, 53660808, 21, 1, 0, 8193, 2, 8193, 2, 5, 1, 
  53660808, 21, 4063233, 1, 8193, 2, 8193, 2, 5, 1, 53660808, 21, 4063233, 1, 
  8193, 2, 8193, 2, 5, 1, 1, 0, 8193, 2, 1, 0, 5, 1, 1, 0, 1, 0, 5, 1, 1, 0, 
  8193, 2, 5, 1, 65767820, 5, 4063233, 1, 5, 1, 53650608, 26, 4063233, 1, 5, 
  1, 53660808, 21, 4063233, 1, 8193, 2, 8193, 2, 5, 1, 53660808, 21, 4063233, 
  1, 8193, 2, 8193, 2, 5, 1, 53660808, 21, 41951068, 17, 8193, 2, 8193, 2, 5, 
  1, 53660808, 21, 4063233, 1, 8193, 2, 8193, 2, 5, 1, 53660808, 21, 1025, 1, 
  53660808, 21, 4063233, 1, 8193, 2, 8193, 2, 5, 1, 53660808, 21, 4063233, 1, 
  8193, 2, 8193, 2, 5, 1, 53660808, 21, 41951068, 17, 8193, 2, 8193, 2, 5, 1, 
  53660808, 21, 8193, 2, 8193, 2, 41951068, 17, 5, 1, 53660808, 21, 4063233, 
  1, 8193, 2, 8193, 2, 5, 1, 53660808, 21, 8193, 2, 1, 0, 1, 0, 5, 1, 
  53660808, 21, 1, 0, 1, 0, 5, 1, 53660808, 21, 4063233, 1, 1, 0, 8193, 2, 
  8193, 2, 5, 1, 53660808, 21, 1, 0, 8193, 2, 8193, 2, 5, 1, 53660808, 21, 
  4063233, 1, 8193, 2, 8193, 2, 5, 1, 53660808, 21, 40093620, 27, 8193, 2, 
  8193, 2, 5, 1, 53660808, 21, 41951068, 17, 8193, 2, 8193, 2, 5, 1, 
  35312242, 6, 11306557, 7, 35312242, 6, 35312242, 6, 47349671, 22, 65767820, 
  5, 26413291, 23, 65767820, 5, 26413291, 23, 47349671, 22, 31980624, 24, 
  65767820, 5, 19398012, 23, 55180923, 23, 65767820, 5, 20971131, 23, 513, 8, 
  20971131, 23, 1, 0, 4063233, 1, 5, 1, 53660808, 21, 53660808, 21, 53660808, 
  21 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/oprt.gi", -97063366 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/oprt.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/oprt.gi");
elif COM_RESULT = 3  then
Revision.oprt_gi:="@(#)$Id: oprt.gi,v 4.179 2003/11/20 20:34:33 gap Exp $";
InstallMethod(ExternalSet,"G, D, gens, acts, act",true,OrbitsishReq,0,COM_FUN(1));
InstallGlobalFunction(ExternalSetByFilterConstructor,COM_FUN(2));
InstallGlobalFunction(ExternalSetByTypeConstructor,COM_FUN(3));
InstallMethod(RestrictedExternalSet,"restrict the acting domain",true,[IsExternalSet,IsGroup],0,COM_FUN(4));
InstallMethod(Enumerator,"external set -> HomeEnumerator",true,[IsExternalSet],0,HomeEnumerator);
InstallMethod(FunctionAction,"ExternalSetByActorsRep",true,[IsExternalSetByActorsRep],0,COM_FUN(5));
InstallMethod(PrintObj,"External Set",true,[IsExternalSet],0,COM_FUN(6));
InstallMethod(ViewObj,"External Set",true,[IsExternalSet],0,COM_FUN(7));
InstallMethod(Representative,"External Set",true,[IsExternalSet],0,COM_FUN(8));
InstallMethod(ExternalSubsetOp,"G, D, start, gens, acts, act",true,[IsGroup,IsList,IsList,IsList,IsList,IsFunction],0,COM_FUN(9));
InstallOtherMethod(ExternalSubsetOp,"G, xset, start, gens, acts, act",true,[IsGroup,IsExternalSet,IsList,IsList,IsList,IsFunction],0,COM_FUN(10));
InstallOtherMethod(ExternalSubsetOp,"G, start, gens, acts, act",true,[IsGroup,IsList,IsList,IsList,IsFunction],0,COM_FUN(11));
InstallMethod(ViewObj,"for external subset",true,[IsExternalSubset],0,COM_FUN(12));
InstallMethod(PrintObj,"for external subset",true,[IsExternalSubset],0,COM_FUN(13));
InstallMethod(Enumerator,"for external subset with home enumerator",[IsExternalSubset and HasHomeEnumerator],COM_FUN(14));
InstallMethod(Enumerator,"for external orbit: compute orbit",true,[IsExternalOrbit],0,COM_FUN(15));
InstallMethod(Random,"for external orbit: via acting domain",true,[IsExternalOrbit],0,COM_FUN(16));
InstallMethod(ExternalOrbitOp,"G, D, pnt, gens, acts, act",true,OrbitishReq,0,COM_FUN(17));
InstallOtherMethod(ExternalOrbitOp,"G, xset, pnt, gens, acts, act",true,[IsGroup,IsExternalSet,IsObject,IsList,IsList,IsFunction],0,COM_FUN(18));
InstallOtherMethod(ExternalOrbitOp,"G, pnt, gens, acts, act",true,[IsGroup,IsObject,IsList,IsList,IsFunction],0,COM_FUN(19));
InstallMethod(ViewObj,"for external orbit",true,[IsExternalOrbit],0,COM_FUN(20));
InstallMethod(PrintObj,"for external orbit",true,[IsExternalOrbit],0,COM_FUN(21));
InstallMethod(AsList,"external orbit",true,[IsExternalOrbit],0,COM_FUN(22));
InstallMethod(AsSSortedList,"external orbit",true,[IsExternalOrbit],0,COM_FUN(23));
InstallMethod(\=,"xorbs",IsIdenticalObj,[IsExternalOrbit,IsExternalOrbit],0,COM_FUN(24));
InstallMethod(\<,"xorbs, via AsSSortedList",IsIdenticalObj,[IsExternalOrbit,IsExternalOrbit],0,COM_FUN(25));
InstallMethod(\=,"xorbs which know their size",IsIdenticalObj,[IsExternalOrbit and HasSize,IsExternalOrbit and HasSize],0,COM_FUN(26));
InstallMethod(\=,"xorbs with canonicalRepresentativeDeterminator",IsIdenticalObj,[IsExternalOrbit and HasCanonicalRepresentativeDeterminatorOfExternalSet,IsExternalOrbit and HasCanonicalRepresentativeDeterminatorOfExternalSet],0,COM_FUN(27));
InstallMethod(\in,"very small xorbs: test in AsList",IsElmsColls,[IsObject,IsExternalOrbit and HasSize],0,COM_FUN(28));
InstallMethod(\in,"xorb: RepresentativeAction",IsElmsColls,[IsObject,IsExternalOrbit],0,COM_FUN(29));
InstallMethod(\in,"xset: Test representative equal",IsElmsColls,[IsObject,IsExternalSet and HasRepresentative],10,COM_FUN(30));
InstallMethod(\in,"xorb: HasEnumerator",IsElmsColls,[IsObject,IsExternalOrbit and HasEnumerator],0,COM_FUN(31));
InstallMethod(\in,"xorb HasAsList",IsElmsColls,[IsObject,IsExternalOrbit and HasAsList],1,COM_FUN(32));
InstallMethod(\in,"xorb HasAsSSortedList",IsElmsColls,[IsObject,IsExternalOrbit and HasAsSSortedList],2,COM_FUN(33));
InstallMethod(\in,"by CanonicalRepresentativeDeterminator",IsElmsColls,[IsObject,IsExternalOrbit and HasCanonicalRepresentativeDeterminatorOfExternalSet],1,COM_FUN(34));
InstallGlobalFunction(ActionHomomorphism,COM_FUN(35));
InstallGlobalFunction(ActionHomomorphismConstructor,COM_FUN(36));
InstallMethod(ActionHomomorphismAttr,"call OpHomConstructor",true,[IsExternalSet],0,COM_FUN(37));
InstallMethod(SurjectiveActionHomomorphismAttr,"call Ac.Hom.Constructor",true,[IsExternalSet],0,COM_FUN(38));
VPActionHom:=COM_FUN(39);
InstallMethod(ViewObj,"for action homomorphism",true,[IsActionHomomorphism],0,VPActionHom);
InstallMethod(PrintObj,"for action homomorphism",true,[IsActionHomomorphism],0,VPActionHom);
InstallMethod(Source,"action homomorphism",true,[IsActionHomomorphism],0,COM_FUN(40));
InstallMethod(Range,"ophom: S(domain)",true,[IsActionHomomorphism],0,COM_FUN(41));
InstallMethod(Range,"surjective action homomorphism",[IsActionHomomorphism and IsSurjective],COM_FUN(42));
InstallMethod(RestrictedMapping,"action homomorphism",CollFamSourceEqFamElms,[IsActionHomomorphism,IsGroup],0,COM_FUN(43));
InstallGlobalFunction(Action,COM_FUN(44));
InstallMethod(OrbitOp,"G, D, pnt, [ 1gen ], [ 1act ], act",true,OrbitishReq,20,COM_FUN(45));
InstallOtherMethod(OrbitOp,"G, pnt, [ 1gen ], [ 1act ], act",true,[IsGroup,IsObject,IsList,IsList,IsFunction],20,COM_FUN(46));
InstallMethod(OrbitOp,"with domain",true,OrbitishReq,0,COM_FUN(47));
InstallOtherMethod(OrbitOp,"standard orbit algorithm:list",true,[IsGroup,IsObject,IsList,IsList,IsFunction],0,COM_FUN(48));
InstallGlobalFunction(OrbitByPosOp,COM_FUN(49));
InstallMethod(OrbitStabilizerOp,"`OrbitStabilizerAlgorithm' with domain",true,OrbitishReq,0,COM_FUN(50));
InstallOtherMethod(OrbitStabilizerOp,"`OrbitStabilizerAlgorithm' without domain",true,[IsGroup,IsObject,IsList,IsList,IsFunction],0,COM_FUN(51));
InstallMethod(OrbitStabilizerAlgorithm,"use stabilizer size",true,[IsGroup and IsFinite and CanComputeSizeAnySubgroup,IsObject,IsObject,IsList,IsList,IsRecord],0,COM_FUN(52));
InstallMethod(OrbitStabilizerAlgorithm,"collect stabilizer generators",true,[IsGroup,IsObject,IsObject,IsList,IsList,IsRecord],0,COM_FUN(53));
BindGlobal("OrbitsByPosOp",COM_FUN(54));
InstallMethod(OrbitsDomain,"for quick position domains",true,[IsGroup,IsList and IsQuickPositionList,IsList,IsList,IsFunction],0,OrbitsByPosOp);
InstallMethod(OrbitsDomain,"for arbitrary domains",true,OrbitsishReq,0,COM_FUN(55));
InstallMethod(OrbitsDomain,"empty domain",true,[IsGroup,IsList and IsEmpty,IsList,IsList,IsFunction],0,COM_FUN(56));
InstallOtherMethod(OrbitsDomain,"group without domain",true,[IsGroup],0,COM_FUN(57));
InstallMethod(Orbits,"for arbitrary domains",true,OrbitsishReq,0,COM_FUN(58));
InstallMethod(OrbitsDomain,"empty domain",true,[IsGroup,IsList and IsEmpty,IsList,IsList,IsFunction],0,COM_FUN(59));
InstallOtherMethod(Orbits,"group without domain",true,[IsGroup],0,COM_FUN(60));
InstallMethod(SparseActionHomomorphismOp,"domain given",true,[IsGroup,IsList,IsList,IsList,IsList,IsFunction],0,COM_FUN(61));
InstallGlobalFunction(DoSparseActionHomomorphism,COM_FUN(62));
InstallOtherMethod(SparseActionHomomorphismOp,"no domain given",true,[IsGroup,IsList,IsList,IsList,IsFunction],0,COM_FUN(63));
InstallOtherMethod(SortedSparseActionHomomorphismOp,"no domain given",true,[IsGroup,IsList,IsList,IsList,IsFunction],0,COM_FUN(64));
InstallMethod(ExternalOrbits,"G, D, gens, acts, act",true,OrbitsishReq,0,COM_FUN(65));
InstallOtherMethod(ExternalOrbits,"G, xset, gens, acts, act",true,[IsGroup,IsExternalSet,IsList,IsList,IsFunction],0,COM_FUN(66));
BindGlobal("ExtOrbStabDom",COM_FUN(67));
InstallMethod(ExternalOrbitsStabilizers,"arbitrary domain",true,OrbitsishReq,0,COM_FUN(68));
InstallOtherMethod(ExternalOrbitsStabilizers,"external set",true,[IsGroup,IsExternalSet,IsList,IsList,IsFunction],0,COM_FUN(69));
InstallGlobalFunction(Permutation,COM_FUN(70));
InstallMethod(PermutationOp,"object on list",true,[IsObject,IsList,IsFunction],0,COM_FUN(71));
InstallGlobalFunction(PermutationCycle,COM_FUN(72));
InstallMethod(PermutationCycleOp,"of object in list",true,[IsObject,IsList,IsObject,IsFunction],0,COM_FUN(73));
InstallGlobalFunction(Cycle,COM_FUN(74));
InstallMethod(CycleOp,"of object in list",true,[IsObject,IsList,IsObject,IsFunction],0,COM_FUN(75));
CycleByPosOp:=COM_FUN(76);
InstallOtherMethod(CycleOp,true,[IsObject,IsObject,IsFunction],0,COM_FUN(77));
InstallGlobalFunction(Cycles,COM_FUN(78));
InstallMethod(CyclesOp,true,[IsObject,IsList,IsFunction],1,COM_FUN(79));
InstallOtherMethod(BlocksOp,"G, D, gens, acts, act",true,[IsGroup,IsList,IsList,IsList,IsFunction],0,COM_FUN(80));
InstallMethod(BlocksOp,"G, D, seed, gens, acts, act",true,[IsGroup,IsList,IsList,IsList,IsList,IsFunction],0,COM_FUN(81));
InstallMethod(BlocksOp,"G, [  ], seed, gens, acts, act",true,[IsGroup,IsList and IsEmpty,IsList,IsList,IsList,IsFunction],20,COM_FUN(82));
InstallOtherMethod(MaximalBlocksOp,"G, D, gens, acts, act",true,[IsGroup,IsList,IsList,IsList,IsFunction],0,COM_FUN(83));
InstallMethod(MaximalBlocksOp,"G, D, seed, gens, acts, act",true,[IsGroup,IsList,IsList,IsList,IsList,IsFunction],0,COM_FUN(84));
InstallMethod(OrbitLengthOp,"compute orbit",true,OrbitishReq,0,COM_FUN(85));
InstallOtherMethod(OrbitLengthOp,"compute orbit",true,[IsGroup,IsObject,IsList,IsList,IsFunction],0,COM_FUN(86));
InstallMethod(OrbitLengths,"compute orbits",true,OrbitsishReq,0,COM_FUN(87));
InstallMethod(OrbitLengthsDomain,"compute orbits",true,OrbitsishReq,0,COM_FUN(88));
InstallGlobalFunction(CycleLength,COM_FUN(89));
InstallMethod(CycleLengthOp,true,[IsObject,IsList,IsObject,IsFunction],0,COM_FUN(90));
InstallOtherMethod(CycleLengthOp,true,[IsObject,IsObject,IsFunction],0,COM_FUN(91));
InstallGlobalFunction(CycleLengths,COM_FUN(92));
InstallMethod(CycleLengthsOp,true,[IsObject,IsList,IsFunction],0,COM_FUN(93));
InstallGlobalFunction(CycleIndex,COM_FUN(94));
InstallOtherMethod(CycleIndexOp,"element",true,[IsMultiplicativeElementWithInverse,IsListOrCollection,IsFunction],0,COM_FUN(95));
InstallMethod(CycleIndexOp,"finite group",true,[IsGroup and IsFinite,IsListOrCollection,IsFunction],0,COM_FUN(96));
InstallMethod(IsTransitive,"compare with orbit of element",true,OrbitsishReq,0,COM_FUN(97));
InstallMethod(Transitivity,"of the image of an ophom",true,OrbitsishReq,0,COM_FUN(98));
InstallMethod(Transitivity,"G, [  ], gens, perms, act",true,[IsGroup,IsList and IsEmpty,IsList,IsList,IsFunction],20,COM_FUN(99));
InstallMethod(IsPrimitive,"transitive and no blocks",true,OrbitsishReq,0,COM_FUN(100));
InstallOtherMethod(SetEarns,"never set fail",true,[IsGroup,IsBool],0,COM_FUN(101));
InstallMethod(IsPrimitiveAffine,"primitive and earns",true,OrbitsishReq,0,COM_FUN(102));
InstallMethod(IsSemiRegular,"via ophom",true,OrbitsishReq,0,COM_FUN(103));
InstallMethod(IsSemiRegular,"G, [  ], gens, perms, act",true,[IsGroup,IsList and IsEmpty,IsList,IsList,IsFunction],20,COM_FUN(104));
InstallMethod(IsSemiRegular,"G, D, gens, [  ], act",true,[IsGroup,IsList,IsList,IsList and IsEmpty,IsFunction],20,COM_FUN(105));
InstallMethod(IsRegular,"transitive and semiregular",true,OrbitsishReq,0,COM_FUN(106));
InstallGlobalFunction(RepresentativeAction,COM_FUN(107));
InstallMethod(RepresentativeActionOp,"ignore domain",true,[IsGroup,IsList,IsObject,IsObject,IsFunction],0,COM_FUN(108));
InstallOtherMethod(RepresentativeActionOp,"orbit algorithm: trace transversal",true,[IsGroup,IsObject,IsObject,IsFunction],0,COM_FUN(109));
InstallGlobalFunction(Stabilizer,COM_FUN(110));
InstallMethod(StabilizerOp,"`OrbitStabilizerAlgorithm' with domain",true,OrbitishReq,0,COM_FUN(111));
InstallOtherMethod(StabilizerOp,"`OrbitStabilizerAlgorithm' without domain",true,[IsGroup,IsObject,IsList,IsList,IsFunction],0,COM_FUN(112));
InstallMethod(RankAction,"via ophom",true,OrbitsishReq,0,COM_FUN(113));
InstallMethod(RankAction,"G, ints, gens, perms, act",true,[IsGroup,IsList and IsCyclotomicCollection,IsList,IsList,IsFunction],0,COM_FUN(114));
InstallMethod(RankAction,"G, [  ], gens, perms, act",true,[IsGroup,IsList and IsEmpty,IsList,IsList,IsFunction],20,COM_FUN(115));
InstallMethod(CanonicalRepresentativeOfExternalSet,"smallest element",true,[IsExternalSet],0,COM_FUN(116));
InstallMethod(CanonicalRepresentativeOfExternalSet,"by CanonicalRepresentativeDeterminator",true,[IsExternalSet and HasCanonicalRepresentativeDeterminatorOfExternalSet],0,COM_FUN(117));
InstallMethod(ActorOfExternalSet,true,[IsExternalSet],0,COM_FUN(118));
InstallMethod(StabilizerOfExternalSet,"stabilizer of the represenattive",true,[IsExternalSet],0,COM_FUN(119));
InstallGlobalFunction(ImageElmActionHomomorphism,COM_FUN(120));
InstallMethod(ImagesRepresentative,"for action hom",FamSourceEqFamElm,[IsActionHomomorphism,IsMultiplicativeElementWithInverse],0,ImageElmActionHomomorphism);
InstallMethod(ImagesRepresentative,"for action hom that is `ByAsGroup'",FamSourceEqFamElm,[IsGroupGeneralMappingByAsGroupGeneralMappingByImages and IsActionHomomorphism,\
IsMultiplicativeElementWithInverse],0,COM_FUN(121));
InstallMethod(MappingGeneratorsImages,"for action hom that is `ByAsGroup'",true,[IsGroupGeneralMappingByAsGroupGeneralMappingByImages and IsActionHomomorphism],0,COM_FUN(122));
InstallMethod(KernelOfMultiplicativeGeneralMapping,"for action homomorphism",true,[IsActionHomomorphism],0,COM_FUN(123));
InstallMethod(ImagesRepresentative,"using `RepresentativeAction'",FamSourceEqFamElm,[IsActionHomomorphismByBase and HasImagesSource,IsMultiplicativeElementWithInverse],0,COM_FUN(124));
InstallMethod(ImagesSource,"actionHomomorphismByBase",true,[IsActionHomomorphismByBase],0,COM_FUN(125));
InstallMethod(ImagesRepresentative,"restricted perm",FamSourceEqFamElm,[IsActionHomomorphismSubset,IsMultiplicativeElementWithInverse],0,COM_FUN(126));
InstallMethod(PreImagesRepresentative,"IsLinearActionHomomorphism",FamRangeEqFamElm,[IsLinearActionHomomorphism,IsPerm],0,COM_FUN(127));
InstallMethod(LinearActionBasis,"find basis in domain",true,[IsLinearActionHomomorphism],0,COM_FUN(128));
InstallMethod(DomainForAction,"default: fail",true,[IsObject,IsListOrCollection,IsFunction],0,COM_FUN(129));
InstallMethod(AbelianSubfactorAction,"generic:use modulo pcgs",true,[IsGroup,IsGroup,IsGroup],0,COM_FUN(130));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/oprt.gi"

#F  file="lib/oprtperm.gi" crc=14246730
RANK_FILTER_LIST  := [ 45271600, 33, 17, 18, 8193, 2, 8193, 2, 5, 1, 
  45271600, 33, 17, 18, 8193, 2, 8193, 2, 5, 1, 53660808, 21, 40093620, 27, 
  8193, 2, 58727864, 36, 5, 1, 53660808, 21, 40093620, 27, 8193, 2, 58727864, 
  36, 5, 1, 513, 8, 17, 18, 5, 1, 575, 9, 17, 18, 513, 8, 17, 18, 5, 1, 575, 
  9, 17, 18, 53660808, 21, 40093620, 27, 41951068, 17, 8193, 2, 58727864, 36, 
  5, 1, 53660808, 21, 40093620, 27, 40093620, 27, 8193, 2, 58727864, 36, 5, 
  1, 53660808, 21, 40093620, 27, 8193, 2, 58727864, 36, 5, 1, 53660808, 21, 
  40093620, 27, 41942876, 3, 8193, 2, 58727864, 36, 5, 1, 53660808, 21, 8193, 
  2, 8193, 2, 8193, 2, 5, 1, 45271600, 33, 8193, 2, 8193, 2, 8193, 2, 5, 1, 
  45271600, 33, 40093620, 27, 8193, 2, 8193, 2, 5, 1, 53660808, 21, 40093620, 
  27, 8193, 2, 58727864, 36, 5, 1, 45271600, 33, 45273522, 34, 65767820, 5, 
  45271600, 33, 1, 0, 1, 0, 5, 1, 65767820, 5, 16514503, 23, 45271600, 33, 1, 
  0, 8193, 2, 8193, 2, 5, 1 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/oprtperm.gi", 14246730 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/oprtperm.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/oprtperm.gi");
elif COM_RESULT = 3  then
Revision.oprtperm_gi:="@(#)$Id: oprtperm.gi,v 4.73 2003/07/28 16:27:09 gap Exp $";
InstallOtherMethod(OrbitOp,"G, int, gens, perms, act = `OnPoints'",true,[IsPermGroup,IsInt,IsList,IsList,IsFunction],0,COM_FUN(1));
InstallOtherMethod(OrbitStabilizerOp,"permgroup",true,[IsPermGroup,IsInt,IsList,IsList,IsFunction],0,COM_FUN(2));
ORBS_PERMGP_PTS:=COM_FUN(3);
InstallMethod(Orbits,"permgroup on points",true,[IsGroup,IsList and IsCyclotomicCollection,IsList,IsList and IsPermCollection,IsFunction],0,ORBS_PERMGP_PTS);
InstallMethod(OrbitsDomain,"permgroup on points",true,[IsGroup,IsList and IsCyclotomicCollection,IsList,IsList and IsPermCollection,IsFunction],0,ORBS_PERMGP_PTS);
InstallOtherMethod(CycleOp,"perm, int, act",true,[IsPerm,IsInt,IsFunction],0,COM_FUN(4));
InstallOtherMethod(CycleOp,"perm, int",true,[IsPerm and IsInternalRep,IsInt],0,COM_FUN(5));
InstallOtherMethod(CycleLengthOp,"perm, int, act",true,[IsPerm,IsInt,IsFunction],0,COM_FUN(6));
InstallOtherMethod(CycleLengthOp,"perm, int",true,[IsPerm and IsInternalRep,IsInt],0,CycleLengthPermInt);
InstallMethod(BlocksOp,"permgroup on integers",[IsGroup,IsList and IsCyclotomicCollection,IsList and IsEmpty,IsList,IsList and IsPermCollection,IsFunction],COM_FUN(7));
InstallMethod(BlocksOp,"integers, with seed",true,[IsGroup,IsList and IsCyclotomicCollection,IsList and IsCyclotomicCollection,IsList,IsList and IsPermCollection,IsFunction],0,COM_FUN(8));
InstallOtherMethod(RepresentativesMinimalBlocksOp,"permgrp on points",true,[IsGroup,IsList and IsCyclotomicCollection,IsList,IsList and IsPermCollection,IsFunction],0,COM_FUN(9));
InstallOtherMethod(RepresentativesMinimalBlocksOp,"G, domain, noseed, gens, perms, act",true,[IsGroup,IsList and IsCyclotomicCollection,IsEmpty,IsList,IsList and IsPermCollection,IsFunction],0,COM_FUN(10));
InstallOtherMethod(RepresentativesMinimalBlocksOp,"general case: translate",true,[IsGroup,IsList,IsList,IsList,IsFunction],-1,COM_FUN(11));
InstallMethod(Earns,"G, ints, gens, perms, act",true,[IsPermGroup,IsList,IsList,IsList,IsFunction],0,COM_FUN(12));
InstallMethod(Transitivity,"permgroup on numbers",true,[IsPermGroup,IsList and IsCyclotomicCollection,IsList,IsList,IsFunction],0,COM_FUN(13));
InstallMethod(IsSemiRegular,"permgroup on numbers",true,[IsGroup,IsList and IsCyclotomicCollection,IsList,IsList and IsPermCollection,IsFunction],0,COM_FUN(14));
InstallOtherMethod(IsRegular,"permgroup",true,[IsPermGroup],0,COM_FUN(15));
InstallOtherMethod(IsRegular,"permgroup with known size",true,[IsPermGroup and HasSize],0,COM_FUN(16));
InstallTrueMethod(IsSemiRegular,IsPermGroup and IsRegular);
InstallTrueMethod(IsTransitive,IsPermGroup and IsRegular);
InstallTrueMethod(IsRegular,IsPermGroup and IsSemiRegular and IsTransitive);
InstallOtherMethod(RepresentativeActionOp,"permgrp",true,[IsPermGroup,IsObject,IsObject,IsFunction],2*RankFilter(IsMultiplicativeElementWithInverse),COM_FUN(17));
InstallOtherMethod(StabilizerOp,"permutation group",true,[IsPermGroup,IsObject,IsList,IsList,IsFunction],RankFilter(IsMultiplicativeElementWithInverse)+RankFilter(IsSolvableGroup),COM_FUN(18));
InstallGlobalFunction(StabilizerOfBlockNC,COM_FUN(19));
InstallGlobalFunction(OnSetsSets,COM_FUN(20));
InstallGlobalFunction(OnSetsDisjointSets,COM_FUN(21));
InstallGlobalFunction(OnSetsTuples,COM_FUN(22));
InstallGlobalFunction(OnTuplesSets,COM_FUN(23));
InstallGlobalFunction(OnTuplesTuples,COM_FUN(24));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/oprtperm.gi"

#F  file="lib/oprtpcgs.gi" crc=-104585623
RANK_FILTER_LIST  := [ 53660808, 21, 8193, 2, 1, 0, 50817374, 23, 8193, 2, 5, 
  1, 53660808, 21, 1, 0, 50817374, 23, 8193, 2, 5, 1, 53660808, 21, 1, 0, 1, 
  0, 39812596, 21, 8193, 2, 4097, 1, 21093619, 11, 21093619, 11, 21093619, 
  11, 21093619, 11, 53660808, 21, 8193, 2, 1, 0, 50817374, 23, 8193, 2, 5, 1, 
  53660808, 21, 1, 0, 50817374, 23, 8193, 2, 5, 1, 53660808, 21, 8193, 2, 1, 
  0, 1, 0, 50817374, 23, 8193, 2, 5, 1, 53660808, 21, 8193, 2, 1, 0, 
  50817374, 23, 8193, 2, 5, 1, 53660808, 21, 1, 0, 50817374, 23, 8193, 2, 5, 
  1, 36883397, 25, 1, 0, 8193, 2, 8193, 2, 5, 1, 36883397, 25, 4063233, 1, 1, 
  0, 8193, 2, 8193, 2, 5, 1, 36883397, 25, 1, 0, 50817374, 23, 8193, 2, 5, 1, 
  36883397, 25, 1, 0, 1, 0, 50817374, 23, 8193, 2, 5, 1 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/oprtpcgs.gi", -104585623 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/oprtpcgs.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/oprtpcgs.gi");
elif COM_RESULT = 3  then
Revision.oprtpcgs_gi:="@(#)$Id: oprtpcgs.gi,v 4.47 2002/04/15 10:05:06 sal Exp $";
InstallGlobalFunction(Pcs_OrbitStabilizer,COM_FUN(1));
InstallGlobalFunction(Pcgs_OrbitStabilizer,COM_FUN(2));
InstallGlobalFunction(StabilizerPcgs,COM_FUN(3));
BindGlobal("Pcgs_MutableOrbitStabilizerOp",COM_FUN(4));
InstallMethod(OrbitStabilizerOp,"G, D, pnt, pcgs, acts, act",true,[IsGroup,IsList,IsObject,IsPrimeOrdersPcgs,IsList,IsFunction],0,COM_FUN(5));
InstallOtherMethod(OrbitStabilizerOp,"G, pnt, pcgs, acts, act",true,[IsGroup,IsObject,IsPrimeOrdersPcgs,IsList,IsFunction],0,COM_FUN(6));
InstallMethod(OrbitStabilizerAlgorithm,"for pcgs",true,[IsGroup,IsObject,IsObject,IsPcgs,IsList,IsRecord],0,COM_FUN(7));
InstallGlobalFunction(SetCanonicalRepresentativeOfExternalOrbitByPcgs,COM_FUN(8));
InstallMethod(Enumerator,"<xorb by pcgs>",true,[IsExternalOrbit and IsExternalSetByPcgs],0,COM_FUN(9));
InstallMethod(CanonicalRepresentativeOfExternalSet,"via `ActorOfExternalSet'",true,[IsExternalOrbit and IsExternalSetByPcgs],0,COM_FUN(10));
InstallMethod(ActorOfExternalSet,true,[IsExternalOrbit and IsExternalSetByPcgs],0,COM_FUN(11));
InstallMethod(StabilizerOfExternalSet,true,[IsExternalOrbit and IsExternalSetByPcgs],0,COM_FUN(12));
BindGlobal("DoPcgsOrbitOp",COM_FUN(13));
InstallMethod(OrbitOp,"via prime order pcgs, with domain",true,[IsGroup,IsList,IsObject,IsPrimeOrdersPcgs,IsList,IsFunction],0,DoPcgsOrbitOp);
InstallOtherMethod(OrbitOp,"action via prime order pcgs",true,[IsGroup,IsObject,IsPrimeOrdersPcgs,IsList,IsFunction],0,COM_FUN(14));
InstallOtherMethod(RepresentativeActionOp,true,[IsGroup,IsList,IsObject,IsObject,IsPrimeOrdersPcgs,IsList,IsFunction],0,COM_FUN(15));
InstallMethod(StabilizerOp,"G, D, pnt, pcgs, acts, act, calling `Pcgs_MutableOrbitStabilizerOp'",true,[IsGroup,IsList,IsObject,IsPrimeOrdersPcgs,IsList,IsFunction],0,COM_FUN(16));
InstallOtherMethod(StabilizerOp,"G, pnt, pcgs, acts, act, calling `Pcgs_MutableOrbitStabilizerOp'",true,[IsGroup,IsObject,IsPrimeOrdersPcgs,IsList,IsFunction],0,COM_FUN(17));
InstallOtherMethod(StabilizerOp,"G (solv.), pnt, gens, gens, act",true,[IsGroup and CanEasilyComputePcgs,IsObject,IsList,IsList,IsFunction],0,COM_FUN(18));
InstallMethod(StabilizerOp,"G (solv.), D,pnt, gens, gens, act",true,[IsGroup and CanEasilyComputePcgs,IsListOrCollection,IsObject,IsList,IsList,IsFunction],0,COM_FUN(19));
InstallOtherMethod(StabilizerOp,"G (solv.), pnt, gens, gens, act",true,[IsGroup and CanEasilyComputePcgs,IsObject,IsPrimeOrdersPcgs,IsList,IsFunction],0,COM_FUN(20));
InstallOtherMethod(StabilizerOp,"G (solv.), D,pnt, gens, gens, act",true,[IsGroup and CanEasilyComputePcgs,IsObject,IsObject,IsPrimeOrdersPcgs,IsList,IsFunction],0,COM_FUN(21));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/oprtpcgs.gi"

#F  file="lib/partitio.gi" crc=-32415795
RANK_FILTER_LIST  := [  ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/partitio.gi", -32415795 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/partitio.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/partitio.gi");
elif COM_RESULT = 3  then
Revision.partitio_gi:="@(#)$Id: partitio.gi,v 4.19 2003/06/03 21:07:16 gap Exp $";
InstallGlobalFunction(Partition,COM_FUN(1));
InstallGlobalFunction(IsPartition,COM_FUN(2));
InstallGlobalFunction(NumberCells,COM_FUN(3));
InstallGlobalFunction(Cell,COM_FUN(4));
InstallGlobalFunction(Cells,COM_FUN(5));
InstallGlobalFunction(CellNoPoint,COM_FUN(6));
InstallGlobalFunction(CellNoPoints,COM_FUN(7));
InstallGlobalFunction(PointInCellNo,COM_FUN(8));
InstallGlobalFunction(Fixcells,COM_FUN(9));
BindGlobal("SplitCellTestfun1",COM_FUN(10));
BindGlobal("SplitCellTestfun2",COM_FUN(11));
InstallGlobalFunction(SplitCell,COM_FUN(12));
InstallGlobalFunction(IsolatePoint,COM_FUN(13));
InstallGlobalFunction(UndoRefinement,COM_FUN(14));
InstallGlobalFunction(FixpointCellNo,COM_FUN(15));
InstallGlobalFunction(FixcellPoint,COM_FUN(16));
InstallGlobalFunction(FixcellsCell,COM_FUN(17));
InstallGlobalFunction(TrivialPartition,COM_FUN(18));
InstallGlobalFunction(OrbitsPartition,COM_FUN(19));
InstallGlobalFunction(SmallestPrimeDivisor,COM_FUN(20));
InstallGlobalFunction(CollectedPartition,COM_FUN(21));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/partitio.gi"

#F  file="lib/stbc.gi" crc=-65634076
RANK_FILTER_LIST  := [ 1, 0, 53660808, 21, 45271600, 33, 40093620, 27, 
  45271600, 33, 41951068, 17, 11716463, 62, 4097, 1, 45271600, 33, 4097, 1, 
  45271600, 33, 4097, 1, 40093620, 27, 8193, 2, 4097, 1, 53660808, 21, 513, 
  8, 45271600, 33, 4097, 1 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/stbc.gi", -65634076 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/stbc.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/stbc.gi");
elif COM_RESULT = 3  then
Revision.stbc_gi:="@(#)$Id: stbc.gi,v 4.72.2.1 2005/04/26 14:19:39 gap Exp $";
InstallGlobalFunction(StabChain,COM_FUN(1));
InstallMethod(StabChainImmutable,"use StabChainMutable",true,[IsObject],0,StabChainMutable);
InstallMethod(StabChainMutable,"call StabChainOp",true,[IsGroup],0,COM_FUN(2));
InstallOtherMethod(StabChainOp,"with base",true,[IsPermGroup,IsList and IsCyclotomicCollection],0,COM_FUN(3));
InstallOtherMethod(StabChainOp,"empty base",true,[IsPermGroup,IsList and IsEmpty],0,COM_FUN(4));
InstallMethod(StabChainOp,"trivial group",[IsPermGroup and IsTrivial,IsRecord],COM_FUN(5));
InstallMethod(StabChainOp,"group and option",[IsPermGroup,IsRecord],COM_FUN(6));
InstallGlobalFunction(CopyStabChain,COM_FUN(7));
InstallMethod(StabChainOptions,true,[IsPermGroup],0,COM_FUN(8));
InstallValue(DefaultStabChainOptions,rec(reduced:=true,random:=1000,tryPcgs:=true));
InstallGlobalFunction(CopyOptionsDefaults,COM_FUN(9));
InstallGlobalFunction(StabChainBaseStrongGenerators,COM_FUN(10));
InstallGlobalFunction(GroupStabChain,COM_FUN(11));
InstallGlobalFunction(DepthSchreierTrees,COM_FUN(12));
InstallGlobalFunction(AddGeneratorsExtendSchreierTree,COM_FUN(13));
InstallGlobalFunction(ChooseNextBasePoint,COM_FUN(14));
InstallGlobalFunction(StabChainStrong,COM_FUN(15));
InstallGlobalFunction(StabChainForcePoint,COM_FUN(16));
InstallGlobalFunction(StabChainSwap,COM_FUN(17));
InstallGlobalFunction(InsertElmList,COM_FUN(18));
InstallGlobalFunction(RemoveElmList,COM_FUN(19));
InstallGlobalFunction(LabsLims,COM_FUN(20));
InstallGlobalFunction(ConjugateStabChain,COM_FUN(21));
InstallGlobalFunction(ChangeStabChain,COM_FUN(22));
InstallGlobalFunction(ExtendStabChain,COM_FUN(23));
InstallGlobalFunction(ReduceStabChain,COM_FUN(24));
InstallGlobalFunction(EmptyStabChain,COM_FUN(25));
InstallGlobalFunction(InitializeSchreierTree,COM_FUN(26));
InstallGlobalFunction(InsertTrivialStabilizer,COM_FUN(27));
InstallGlobalFunction(RemoveStabChain,COM_FUN(28));
InstallGlobalFunction(BasePoint,COM_FUN(29));
InstallGlobalFunction(IsInBasicOrbit,COM_FUN(30));
InstallGlobalFunction(IsFixedStabilizer,COM_FUN(31));
InstallGlobalFunction(InverseRepresentative,COM_FUN(32));
InstallGlobalFunction(QuickInverseRepresentative,COM_FUN(33));
InstallGlobalFunction(InverseRepresentativeWord,COM_FUN(34));
InstallGlobalFunction(SiftedPermutation,COM_FUN(35));
InstallGlobalFunction(MinimalElementCosetStabChain,COM_FUN(36));
InstallMethod(MembershipTestKnownBase,"stabchain, base, word",true,[IsRecord,IsList and IsCyclotomicCollection,IsList],0,COM_FUN(37));
InstallOtherMethod(MembershipTestKnownBase,true,[IsRecord,IsGroup,IsPerm],0,COM_FUN(38));
InstallGlobalFunction(BaseStabChain,COM_FUN(39));
InstallGlobalFunction(SizeStabChain,COM_FUN(40));
InstallGlobalFunction(StrongGeneratorsStabChain,COM_FUN(41));
InstallGlobalFunction(IndicesStabChain,COM_FUN(42));
InstallGlobalFunction(ListStabChain,COM_FUN(43));
InstallGlobalFunction(OrbitStabChain,COM_FUN(44));
InstallMethod(MinimalStabChain,"Perm",true,[IsPermGroup],0,COM_FUN(45));
InstallGlobalFunction(SCMinSmaGens,COM_FUN(46));
InstallGlobalFunction(LargestElementStabChain,COM_FUN(47));
InstallGlobalFunction(ElementsStabChain,COM_FUN(48));
InstallMethod(ViewObj,"stabilizer chain records",true,[IsRecord],0,COM_FUN(49));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/stbc.gi"

#F  file="lib/stbcbckt.gi" crc=16670037
RANK_FILTER_LIST  := [ 513, 8, 23148260, 9, 17, 18, 23148260, 9, 1, 0, 
  23148260, 9, 23148260, 9, 1, 0, 46296519, 9, 46296519, 9, 45271600, 33, 
  45271600, 33, 45271600, 33, 45271600, 33, 45271600, 33, 45271600, 33, 513, 
  8, 45271600, 33, 45271600, 33, 45271600, 33, 513, 8, 45271600, 33, 
  45271600, 33, 45271600, 33, 45271600, 33 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/stbcbckt.gi", 16670037 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/stbcbckt.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/stbcbckt.gi");
elif COM_RESULT = 3  then
Revision.stbcbckt_gi:="@(#)$Id: stbcbckt.gi,v 4.83.2.1 2004/06/21 19:38:19 gap Exp $";
if not IsBound(LARGE_TASK) then
LARGE_TASK:=false;
fi;
DeclareRepresentation("IsSlicedPerm",IsPerm,["length","word","lftObj","opr"]);
InstallGlobalFunction(AsPerm,COM_FUN(1));
InstallMethod(\^,"sliced perm",true,[IsPerm,IsSlicedPerm],0,COM_FUN(2));
InstallMethod(\^,"sliced perm",true,[IsInt,IsSlicedPerm],0,COM_FUN(3));
InstallOtherMethod(\/,"sliced perm",true,[IsObject,IsSlicedPerm],0,COM_FUN(4));
InstallMethod(PrintObj,"sliced perm",true,[IsSlicedPerm],0,COM_FUN(5));
DeclareRepresentation("IsSlicedPermInv",IsPerm,["length","word","lftObj","opr"]);
InstallOtherMethod(\^,"sliced perm",true,[IsObject,IsSlicedPermInv],0,COM_FUN(6));
InstallMethod(PrintObj,"sliced perm",true,[IsSlicedPermInv],0,COM_FUN(7));
InstallGlobalFunction(PreImageWord,COM_FUN(8));
InstallGlobalFunction(ExtendedT,COM_FUN(9));
InstallGlobalFunction(MeetPartitionStrat,COM_FUN(10));
InstallGlobalFunction(StratMeetPartition,COM_FUN(11));
InstallGlobalFunction(SuboLiBli,COM_FUN(12));
InstallGlobalFunction(SuboSiBli,COM_FUN(13));
InstallGlobalFunction(SuboTruePos,COM_FUN(14));
InstallGlobalFunction(SuboUniteBlist,COM_FUN(15));
InstallGlobalFunction(ConcatSubos,COM_FUN(16));
InstallGlobalFunction(Suborbits,COM_FUN(17));
InstallGlobalFunction(OrbitalPartition,COM_FUN(18));
InstallGlobalFunction(EmptyRBase,COM_FUN(19));
InstallGlobalFunction(IsTrivialRBase,COM_FUN(20));
InstallGlobalFunction(AddRefinement,COM_FUN(21));
InstallGlobalFunction(ProcessFixpoint,COM_FUN(22));
InstallGlobalFunction(RegisterRBasePoint,COM_FUN(23));
InstallGlobalFunction(NextRBasePoint,COM_FUN(24));
InstallGlobalFunction(RRefine,COM_FUN(25));
InstallGlobalFunction(PBIsMinimal,COM_FUN(26));
InstallGlobalFunction(SubtractBlistOrbitStabChain,COM_FUN(27));
InstallGlobalFunction(PartitionBacktrack,COM_FUN(28));
InstallValue(Refinements,rec());
InstallGlobalFunction(Refinements_ProcessFixpoint,COM_FUN(29));
Refinements.ProcessFixpoint:=Refinements_ProcessFixpoint;
InstallGlobalFunction(Refinements_Intersection,COM_FUN(30));
Refinements.Intersection:=Refinements_Intersection;
InstallGlobalFunction(Refinements_Centralizer,COM_FUN(31));
Refinements.Centralizer:=Refinements_Centralizer;
InstallGlobalFunction(Refinements__MakeBlox,COM_FUN(32));
Refinements._MakeBlox:=Refinements__MakeBlox;
InstallGlobalFunction(Refinements_SplitOffBlock,COM_FUN(33));
Refinements.SplitOffBlock:=Refinements_SplitOffBlock;
InstallGlobalFunction(Refinements__RegularOrbit1,COM_FUN(34));
Refinements._RegularOrbit1:=Refinements__RegularOrbit1;
InstallGlobalFunction(Refinements_RegularOrbit2,COM_FUN(35));
Refinements.RegularOrbit2:=Refinements_RegularOrbit2;
InstallGlobalFunction(Refinements_RegularOrbit3,COM_FUN(36));
Refinements.RegularOrbit3:=Refinements_RegularOrbit3;
InstallGlobalFunction(Refinements_Suborbits0,COM_FUN(37));
Refinements.Suborbits0:=Refinements_Suborbits0;
InstallGlobalFunction(Refinements_Suborbits1,COM_FUN(38));
Refinements.Suborbits1:=Refinements_Suborbits1;
InstallGlobalFunction(Refinements_Suborbits2,COM_FUN(39));
Refinements.Suborbits2:=Refinements_Suborbits2;
InstallGlobalFunction(Refinements_Suborbits3,COM_FUN(40));
Refinements.Suborbits3:=Refinements_Suborbits3;
InstallGlobalFunction(Refinements_TwoClosure,COM_FUN(41));
Refinements.TwoClosure:=Refinements_TwoClosure;
InstallGlobalFunction(NextLevelRegularGroups,COM_FUN(42));
InstallGlobalFunction(RBaseGroupsBloxPermGroup,COM_FUN(43));
InstallGlobalFunction(RepOpSetsPermGroup,COM_FUN(44));
InstallGlobalFunction(RepOpElmTuplesPermGroup,COM_FUN(45));
InstallGlobalFunction(IsomorphismPermGroups,COM_FUN(46));
InstallGlobalFunction(AutomorphismGroupPermGroup,COM_FUN(47));
InstallMethod(NormalizerOp,"perm group",IsIdenticalObj,[IsPermGroup,IsPermGroup],0,AutomorphismGroupPermGroup);
InstallOtherMethod(Normalizer,"perm group",true,[IsPermGroup,IsPermGroup,IsPermGroup],0,AutomorphismGroupPermGroup);
InstallGlobalFunction(ElementProperty,COM_FUN(48));
InstallGlobalFunction(SubgroupProperty,COM_FUN(49));
InstallGlobalFunction(PartitionStabilizerPermGroup,COM_FUN(50));
InstallMethod(CentralizerOp,"perm group,elm",IsCollsElms,[IsPermGroup,IsPerm],0,COM_FUN(51));
InstallMethod(CentralizerOp,"perm group, perm group",IsIdenticalObj,[IsPermGroup,IsPermGroup],0,COM_FUN(52));
InstallOtherMethod(Centralizer,"with given subgroup",true,[IsPermGroup,IsPerm,IsPermGroup],0,COM_FUN(53));
InstallMethod(Intersection2,"perm groups",IsIdenticalObj,[IsPermGroup,IsPermGroup],0,COM_FUN(54));
TwoClosurePermGroup:=COM_FUN(55);
InstallMethod(TwoClosure,"permutation group",true,[IsPermGroup],0,TwoClosurePermGroup);
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/stbcbckt.gi"

#F  file="lib/stbcrand.gi" crc=-129690646
RANK_FILTER_LIST  := [  ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/stbcrand.gi", -129690646 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/stbcrand.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/stbcrand.gi");
elif COM_RESULT = 3  then
Revision.stbcrand_gi:="@(#)$Id: stbcrand.gi,v 4.28.2.4 2005/05/10 14:13:39 gap Exp $";
InstallGlobalFunction(StabChainRandomPermGroup,COM_FUN(1));
InstallGlobalFunction(SCRMakeStabStrong,COM_FUN(2));
InstallGlobalFunction(SCRStrongGenTest,COM_FUN(3));
InstallGlobalFunction(SCRSift,COM_FUN(4));
InstallGlobalFunction(SCRStrongGenTest2,COM_FUN(5));
InstallGlobalFunction(SCRNotice,COM_FUN(6));
InstallGlobalFunction(SCRExtend,COM_FUN(7));
InstallGlobalFunction(SCRSchTree,COM_FUN(8));
InstallGlobalFunction(SCRRandomPerm,COM_FUN(9));
InstallGlobalFunction(SCRRandomString,COM_FUN(10));
InstallGlobalFunction(SCRRandomSubproduct,COM_FUN(11));
InstallGlobalFunction(SCRExtendRecord,COM_FUN(12));
InstallGlobalFunction(SCRRestoredRecord,COM_FUN(13));
InstallGlobalFunction(VerifyStabilizer,COM_FUN(14));
InstallGlobalFunction(VerifySGS,COM_FUN(15));
InstallGlobalFunction(ExtensionOnBlocks,COM_FUN(16));
InstallGlobalFunction(ClosureRandomPermGroup,COM_FUN(17));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/stbcrand.gi"

#F  file="lib/clas.gi" crc=-76356875
RANK_FILTER_LIST  := [ 46285749, 11, 46285749, 11, 46285749, 11, 46285749, 
  11, 53660808, 21, 1, 0, 53660808, 21, 1, 0, 53660808, 21, 22489565, 12, 
  22489565, 12, 22489565, 12, 22489565, 12, 22489565, 12, 22489565, 12, 
  22489565, 12, 53660808, 21, 53660808, 21, 53660808, 21, 53660808, 21, 1, 0, 
  64308129, 11, 64308129, 11, 1, 0, 64308129, 11, 22489565, 12, 64308129, 11, 
  64308129, 11, 64308129, 11, 64308129, 11, 64308129, 11, 64308129, 11, 
  53660808, 21, 50331469, 25 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/clas.gi", -76356875 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/clas.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/clas.gi");
elif COM_RESULT = 3  then
Revision.clas_gi:="@(#)$Id: clas.gi,v 4.71 2003/05/19 16:02:37 gap Exp $";
BindGlobal("ElementNumber_ExternalOrbitByStabilizer",COM_FUN(1));
BindGlobal("NumberElement_ExternalOrbitByStabilizer",COM_FUN(2));
InstallMethod(Enumerator,"xorb by stabilizer",[IsExternalOrbitByStabilizerRep],COM_FUN(3));
InstallMethod(AsList,"xorb by stabilizer",[IsExternalOrbitByStabilizerRep],COM_FUN(4));
InstallMethod(IsFinite,"method for an ext. orbit by stabilizer",[IsExternalOrbitByStabilizerRep],COM_FUN(5));
InstallMethod(Size,"method for an ext. orbit by stabilizer",[IsExternalOrbitByStabilizerRep],COM_FUN(6));
InstallMethod(ConjugacyClass,"class of element",IsCollsElms,[IsGroup,IsObject],COM_FUN(7));
InstallOtherMethod(ConjugacyClass,"class of element and centralizer",IsCollsElmsColls,[IsGroup,IsObject,IsGroup],COM_FUN(8));
InstallMethod(HomeEnumerator,[IsConjugacyClassGroupRep],COM_FUN(9));
InstallMethod(PrintObj,[IsConjugacyClassGroupRep],COM_FUN(10));
InstallMethod(ViewObj,[IsConjugacyClassGroupRep],COM_FUN(11));
InstallMethod(Size,"for a conjugacy class",[IsConjugacyClassGroupRep],COM_FUN(12));
InstallMethod(IsFinite,"for a conjugacy class",[IsConjugacyClassGroupRep],COM_FUN(13));
InstallOtherMethod(Centralizer,[IsConjugacyClassGroupRep],StabilizerOfExternalSet);
InstallMethod(StabilizerOfExternalSet,[IsConjugacyClassGroupRep],10,COM_FUN(14));
InstallGlobalFunction(ConjugacyClassesTry,COM_FUN(15));
InstallGlobalFunction(ConjugacyClassesByRandomSearch,COM_FUN(16));
InstallGlobalFunction(ConjugacyClassesByOrbits,COM_FUN(17));
InstallMethod(ConjugacyClasses,"test options",[IsGroup],GETTER_FLAGS-1,COM_FUN(18));
DEFAULT_CLASS_ORBIT_LIMIT:=500;
InstallGlobalFunction(ConjugacyClassesForSmallGroup,COM_FUN(19));
InstallMethod(ConjugacyClasses,"for groups: try random search",[IsGroup],COM_FUN(20));
InstallMethod(ConjugacyClasses,"try solvable method",[IsGroup],COM_FUN(21));
InstallMethod(RationalClass,IsCollsElms,[IsGroup,IsObject],COM_FUN(22));
InstallMethod(\=,IsIdenticalObj,[IsRationalClassGroupRep,IsRationalClassGroupRep],COM_FUN(23));
InstallMethod(\in,IsElmsColls,[IsObject,IsRationalClassGroupRep],COM_FUN(24));
InstallMethod(HomeEnumerator,[IsConjugacyClassGroupRep],COM_FUN(25));
InstallMethod(PrintObj,[IsRationalClassGroupRep],COM_FUN(26));
InstallMethod(Size,"method for a rational class",[IsRationalClassGroupRep],COM_FUN(27));
InstallGlobalFunction(DecomposedRationalClass,COM_FUN(28));
BindGlobal("ElementNumber_RationalClassGroup",COM_FUN(29));
BindGlobal("NumberElement_RationalClassGroup",COM_FUN(30));
InstallMethod(Enumerator,[IsRationalClassGroupRep],COM_FUN(31));
InstallOtherMethod(CentralizerOp,[IsRationalClassGroupRep],StabilizerOfExternalSet);
InstallMethod(AsList,[IsRationalClassGroupRep],COM_FUN(32));
InstallOtherMethod(GaloisGroup,[IsRationalClassGroupRep],COM_FUN(33));
InstallGlobalFunction(GroupByPrimeResidues,COM_FUN(34));
InstallMethod(RationalClasses,"trial",[IsGroup],COM_FUN(35));
InstallGlobalFunction(RationalClassesTry,COM_FUN(36));
InstallMethod(RationalClasses,"solvable",[CanEasilyComputePcgs],20,COM_FUN(37));
InstallGlobalFunction(RationalClassesInEANS,COM_FUN(38));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/clas.gi"

#F  file="lib/claspcgs.gi" crc=-102857703
RANK_FILTER_LIST  := [ 22489565, 12 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/claspcgs.gi", -102857703 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/claspcgs.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/claspcgs.gi");
elif COM_RESULT = 3  then
Revision.claspcgs_gi:="@(#)$Id: claspcgs.gi,v 4.70 2003/05/19 16:02:37 gap Exp $";
InstallGlobalFunction(SubspaceVectorSpaceGroup,COM_FUN(1));
InstallGlobalFunction(KernelHcommaC,COM_FUN(2));
InstallGlobalFunction(CentralStepClEANS,COM_FUN(3));
InstallGlobalFunction(CorrectConjugacyClass,COM_FUN(4));
InstallGlobalFunction(GeneralStepClEANS,COM_FUN(5));
InstallGlobalFunction(ClassesSolvableGroup,COM_FUN(6));
InstallGlobalFunction(CentralizerSizeLimitConsiderFunction,COM_FUN(7));
InstallMethod(ActorOfExternalSet,true,[IsConjugacyClassGroupRep],0,COM_FUN(8));
InstallGlobalFunction(RationalClassesSolvableGroup,COM_FUN(9));
InstallGlobalFunction(OrderModK,COM_FUN(10));
BindGlobal("OldSubspaceVectorSpaceGroup",COM_FUN(11));
BindGlobal("OldKernelHcommaC",COM_FUN(12));
InstallGlobalFunction(CentralStepConjugatingElement,COM_FUN(13));
InstallGlobalFunction(CentralStepRatClPGroup,COM_FUN(14));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/claspcgs.gi"

#F  file="lib/clasperm.gi" crc=27070
RANK_FILTER_LIST  := [ 42005116, 13, 42005116, 13, 42005116, 13, 513, 8, 
  42005116, 13, 61507378, 12, 64308129, 11, 61507378, 12, 61507378, 12, 513, 
  8, 61507378, 12, 45271600, 33, 20276790, 34 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/clasperm.gi", 27070 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/clasperm.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/clasperm.gi");
elif COM_RESULT = 3  then
Revision.clasperm_gi:="@(#)$Id: clasperm.gi,v 4.36 2003/05/23 16:17:59 gap Exp $";
BindGlobal("NumberElement_ConjugacyClassPermGroup",COM_FUN(1));
InstallMethod(Enumerator,[IsConjugacyClassPermGroupRep],COM_FUN(2));
InstallMethod(\=,"classes for perm group",IsIdenticalObj,[IsConjugacyClassPermGroupRep,IsConjugacyClassPermGroupRep],COM_FUN(3));
InstallMethod(\in,"perm class rep",IsElmsColls,[IsPerm,IsConjugacyClassPermGroupRep],COM_FUN(4));
BindGlobal("NumberElement_RationalClassPermGroup",COM_FUN(5));
InstallMethod(Enumerator,[IsRationalClassPermGroupRep],COM_FUN(6));
InstallOtherMethod(CentralizerOp,[IsRationalClassGroupRep],StabilizerOfExternalSet);
InstallMethod(\=,IsIdenticalObj,[IsRationalClassPermGroupRep,IsRationalClassPermGroupRep],COM_FUN(7));
InstallMethod(\in,true,[IsPerm,IsRationalClassPermGroupRep],0,COM_FUN(8));
InstallGlobalFunction(CompleteGaloisGroupPElement,COM_FUN(9));
InstallGlobalFunction(RatClasPElmArrangeClasses,COM_FUN(10));
InstallGlobalFunction(SortRationalClasses,COM_FUN(11));
InstallGlobalFunction(FusionRationalClassesPSubgroup,COM_FUN(12));
InstallGlobalFunction(RationalClassesPElements,COM_FUN(13));
InstallGlobalFunction(RationalClassesPermGroup,COM_FUN(14));
InstallMethod(RationalClasses,"perm group",[IsPermGroup],COM_FUN(15));
InstallMethod(ConjugacyClasses,"perm group",[IsPermGroup and HasRationalClasses],COM_FUN(16));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/clasperm.gi"

#F  file="lib/clashom.gi" crc=52367979
RANK_FILTER_LIST  := [ 45271600, 33 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/clashom.gi", 52367979 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/clashom.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/clashom.gi");
elif COM_RESULT = 3  then
Revision.clashom_gi:="@(#)$Id: clashom.gi,v 4.51 2003/10/30 15:28:26 gap Exp $";
BindGlobal("GeneralStepClEANSNonsolv",COM_FUN(1));
BindGlobal("CentralStelClEANSNonsolv",COM_FUN(2));
AutomorphismRepresentingGroup:=COM_FUN(3);
BindGlobal("ClassRepsPermutedTuples",COM_FUN(4));
InstallGlobalFunction(ConjugacyClassesSubwreath,COM_FUN(5));
InstallGlobalFunction(ConjugacyClassesFittingFreeGroup,COM_FUN(6));
InstallGlobalFunction(ConjugacyClassesViaRadical,COM_FUN(7));
InstallMethod(ConjugacyClasses,"perm group",true,[IsPermGroup],0,COM_FUN(8));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/clashom.gi"

#F  file="lib/csetgrp.gi" crc=78138548
RANK_FILTER_LIST  := [ 44158107, 11, 53660808, 21, 53660808, 21, 53660808, 
  21, 53660808, 21, 1, 0, 53660808, 21, 53660808, 21, 1, 0, 53660808, 21, 
  52247917, 19, 44702872, 8, 44702872, 8, 44702872, 8, 44702872, 8, 44702872, 
  8, 44702872, 8, 65767820, 5, 44702872, 8, 44702872, 8, 44702872, 8, 
  44702872, 8, 53660808, 21, 1, 0, 53662730, 23, 1, 0, 44158107, 11, 
  44158107, 11, 44158107, 11, 44158107, 11, 44158107, 11, 44158107, 11, 
  44158107, 11, 65767820, 5, 53660808, 21, 1, 0, 53660808, 21, 53660808, 21, 
  53660808, 21, 53660808, 21, 53660808, 21, 53660808, 21, 53660808, 21, 
  53660808, 21, 34839782, 10, 52247917, 19, 34839782, 10, 65767820, 5, 
  53660808, 21, 53660808, 21, 45271600, 33, 45271600, 33, 12585763, 33, 
  12585763, 33, 53660808, 21, 20105671, 49 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/csetgrp.gi", 78138548 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/csetgrp.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/csetgrp.gi");
elif COM_RESULT = 3  then
Revision.csetgrp_gi:="@(#)$Id: csetgrp.gi,v 4.54 2003/04/14 16:07:16 gap Exp $";
DeclareRepresentation("IsRightCosetDefaultRep",IsComponentObjectRep and IsAttributeStoringRep and IsRightCoset,[]);
BindGlobal("NumberElement_RightCoset",COM_FUN(1));
BindGlobal("ElementNumber_RightCoset",COM_FUN(2));
InstallMethod(Enumerator,"for a right coset",[IsRightCoset],COM_FUN(3));
DeclareRepresentation("IsDoubleCosetDefaultRep",IsComponentObjectRep and IsAttributeStoringRep and IsDoubleCoset,[]);
InstallMethod(ComputedAscendingChains,"init",true,[IsGroup],0,COM_FUN(4));
InstallGlobalFunction(AscendingChain,COM_FUN(5));
InstallGlobalFunction(IntermediateGroup,COM_FUN(6));
InstallGlobalFunction(RefinedChain,COM_FUN(7));
InstallMethod(AscendingChainOp,"generic",IsIdenticalObj,[IsGroup,IsGroup],0,COM_FUN(8));
InstallMethod(DoubleCoset,"generic",IsCollsElmsColls,[IsGroup,IsObject,IsGroup],0,COM_FUN(9));
InstallOtherMethod(DoubleCoset,"with size",true,[IsGroup,IsObject,IsGroup,IsPosInt],0,COM_FUN(10));
InstallMethod(\=,"DoubleCosets",IsIdenticalObj,[IsDoubleCoset,IsDoubleCoset],0,COM_FUN(11));
InstallMethod(PrintObj,"DoubleCoset",true,[IsDoubleCoset],0,COM_FUN(12));
InstallMethod(Random,"double coset",true,[IsDoubleCoset],0,COM_FUN(13));
InstallMethod(PseudoRandom,"double coset",true,[IsDoubleCoset],0,COM_FUN(14));
InstallMethod(RepresentativesContainedRightCosets,"generic",true,[IsDoubleCoset],0,COM_FUN(15));
InstallMethod(\in,"double coset",IsElmsColls,[IsMultiplicativeElementWithInverse,IsDoubleCoset],0,COM_FUN(16));
InstallMethod(Size,"double coset",true,[IsDoubleCoset],0,COM_FUN(17));
InstallMethod(AsList,"double coset",true,[IsDoubleCoset],0,COM_FUN(18));
BindGlobal("ElementNumber_DoubleCoset",COM_FUN(19));
BindGlobal("NumberElement_DoubleCoset",COM_FUN(20));
InstallMethod(Enumerator,"for a double coset",[IsDoubleCoset],COM_FUN(21));
RightCosetCanonicalRepresentativeDeterminator:=COM_FUN(22);
InstallMethod(RightCoset,"generic",IsCollsElms,[IsGroup,IsObject],0,COM_FUN(23));
InstallMethod(RightCoset,"use subgroup size",IsCollsElms,[IsGroup and HasSize,IsObject],0,COM_FUN(24));
InstallMethod(PrintObj,"RightCoset",true,[IsRightCoset],0,COM_FUN(25));
InstallMethod(ViewObj,"RightCoset",true,[IsRightCoset],0,COM_FUN(26));
InstallMethod(Random,"RightCoset",true,[IsRightCoset],0,COM_FUN(27));
InstallMethod(PseudoRandom,"RightCoset",true,[IsRightCoset],0,COM_FUN(28));
InstallMethod(\=,"RightCosets",IsIdenticalObj,[IsRightCoset,IsRightCoset],0,COM_FUN(29));
InstallOtherMethod(\*,"RightCosets",IsCollsElms,[IsRightCoset,IsMultiplicativeElementWithInverse],0,COM_FUN(30));
InstallGlobalFunction(DoubleCosets,COM_FUN(31));
InstallGlobalFunction(RightCosets,COM_FUN(32));
InstallMethod(CanonicalRightCosetElement,"generic",IsCollsElms,[IsGroup,IsObject],0,COM_FUN(33));
BindGlobal("CalcDoubleCosets",COM_FUN(34));
InstallMethod(DoubleCosetsNC,"generic",true,[IsGroup,IsGroup,IsGroup],0,COM_FUN(35));
InstallMethod(DoubleCosetRepsAndSizes,"generic",true,[IsGroup,IsGroup,IsGroup],0,CalcDoubleCosets);
DeclareRepresentation("IsRightTransversalViaCosetsRep",IsRightTransversalRep,["group","subgroup","cosets"]);
InstallMethod(RightTransversalOp,"generic, use RightCosets",IsIdenticalObj,[IsGroup,IsGroup],0,COM_FUN(36));
InstallMethod(\[\],"rt via coset",true,[IsList and IsRightTransversalViaCosetsRep,IsPosInt],0,COM_FUN(37));
InstallMethod(PositionCanonical,"rt via coset",IsCollsElms,[IsList and IsRightTransversalViaCosetsRep,IsMultiplicativeElementWithInverse],0,COM_FUN(38));
InstallMethod(RightCosetsNC,"generic: orbit",IsIdenticalObj,[IsGroup,IsGroup],0,COM_FUN(39));
InstallMethod(RightCosetsNC,"perm groups, use RightTransversal",IsIdenticalObj,[IsPermGroup,IsPermGroup],0,COM_FUN(40));
InstallMethod(RightCosetsNC,"pc groups, use RightTransversal",IsIdenticalObj,[IsPcGroup,IsPcGroup],0,COM_FUN(41));
InstallMethod(RightTransversalOp,"for trivial subgroup, call `EnumeratorSorted' for the big group",IsIdenticalObj,[IsGroup,IsGroup and IsTrivial],100,COM_FUN(42));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/csetgrp.gi"

#F  file="lib/csetperm.gi" crc=50382523
RANK_FILTER_LIST  := [ 45271600, 33, 45271600, 33, 45271600, 33, 513, 8, 
  35768899, 39, 35768899, 39 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/csetperm.gi", 50382523 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/csetperm.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/csetperm.gi");
elif COM_RESULT = 3  then
Revision.csetperm_gi:="@(#)$Id: csetperm.gi,v 4.12 2002/09/20 22:27:45 gap Exp $";
InstallMethod(AscendingChainOp,"PermGroup",IsIdenticalObj,[IsPermGroup,IsPermGroup],0,COM_FUN(1));
InstallMethod(CanonicalRightCosetElement,"Perm",IsCollsElms,[IsPermGroup,IsPerm],0,COM_FUN(2));
InstallMethod(\<,"RightCosets of perm group",IsIdenticalObj,[IsRightCoset and IsPermCollection,IsRightCoset and IsPermCollection],0,COM_FUN(3));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/csetperm.gi"

#F  file="lib/csetpc.gi" crc=-88305231
RANK_FILTER_LIST  := [ 12585763, 33, 1, 0, 12585763, 33, 12585763, 33, 
  12585763, 33, 12585763, 33, 53660808, 21, 62914336, 26, 53660808, 21, 
  2563452, 10, 52247917, 19, 2563452, 10, 2563452, 10, 65767820, 5 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/csetpc.gi", -88305231 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/csetpc.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/csetpc.gi");
elif COM_RESULT = 3  then
Revision.csetpc_gi:="@(#)$Id: csetpc.gi,v 4.38 2003/01/30 18:38:05 gap Exp $";
InstallMethod(CanonicalRightCosetElement,"Pc",IsCollsElms,[IsPcGroup,IsObject],0,COM_FUN(1));
BindGlobal("DoubleCosetsPcGroup",COM_FUN(2));
InstallMethod(DoubleCosetRepsAndSizes,"Pc",true,[IsPcGroup,IsPcGroup,IsPcGroup],0,COM_FUN(3));
DeclareRepresentation("IsRightTransversalPcGroupRep",IsRightTransversalRep,["transversal","canonReps"]);
DoRightTransversalPc:=COM_FUN(4);
InstallMethod(RightTransversalOp,"pc groups",IsIdenticalObj,[IsPcGroup,IsGroup],0,DoRightTransversalPc);
InstallMethod(RightTransversalOp,"pc groups",IsIdenticalObj,[CanEasilyComputePcgs and HasPcgs,IsGroup],0,DoRightTransversalPc);
InstallMethod(\[\],"for Pc transversals",true,[IsList and IsRightTransversalPcGroupRep,IsPosInt],0,COM_FUN(5));
InstallMethod(AsList,"for Pc transversals",true,[IsList and IsRightTransversalPcGroupRep],0,COM_FUN(6));
InstallMethod(PositionCanonical,"RT",IsCollsElms,[IsList and IsRightTransversalPcGroupRep,IsMultiplicativeElementWithInverse],0,COM_FUN(7));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/csetpc.gi"

#F  file="lib/factgrp.gi" crc=10548730
RANK_FILTER_LIST  := [ 53660808, 21, 53660808, 21, 53660808, 21, 53660808, 
  21, 53660808, 21, 53660808, 21, 15881342, 222, 53660808, 21, 15881342, 222, 
  53660808, 21, 53660808, 21, 53660808, 21, 45271600, 33, 53650608, 26, 
  53660808, 21, 53660808, 21, 53660808, 21, 45271600, 33, 45271600, 33, 
  15881342, 222, 53660808, 21, 53660808, 21, 53660808, 21, 45271600, 33, 
  45271600, 33 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/factgrp.gi", 10548730 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/factgrp.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/factgrp.gi");
elif COM_RESULT = 3  then
Revision.factgrp_gi:="@(#)$Id: factgrp.gi,v 4.52 2003/09/17 21:37:28 gap Exp $";
InstallMethod(NaturalHomomorphismsPool,true,[IsGroup],0,COM_FUN(1));
InstallGlobalFunction(AddNaturalHomomorphismsPool,COM_FUN(2));
InstallGlobalFunction(LockNaturalHomomorphismsPool,COM_FUN(3));
InstallGlobalFunction(UnlockNaturalHomomorphismsPool,COM_FUN(4));
InstallGlobalFunction(KnownNaturalHomomorphismsPool,COM_FUN(5));
InstallGlobalFunction(GetNaturalHomomorphismsPool,COM_FUN(6));
InstallGlobalFunction(DegreeNaturalHomomorphismsPool,COM_FUN(7));
InstallGlobalFunction(CloseNaturalHomomorphismsPool,COM_FUN(8));
DoFactorCosetAction:=COM_FUN(9);
InstallMethod(FactorCosetAction,"by right transversal operation",IsIdenticalObj,[IsGroup,IsGroup],0,COM_FUN(10));
InstallOtherMethod(FactorCosetAction,"by right transversal operation, given kernel",IsFamFamFam,[IsGroup,IsGroup,IsGroup],0,COM_FUN(11));
InstallMethod(FactorCosetAction,"by right transversal operation, Niceo",IsIdenticalObj,[IsGroup and IsHandledByNiceMonomorphism,IsGroup],0,COM_FUN(12));
InstallOtherMethod(FactorCosetAction,"by right transversal operation, given kernel, Niceo",IsFamFamFam,[IsGroup and IsHandledByNiceMonomorphism,IsGroup,IsGroup],0,COM_FUN(13));
InstallMethod(DoCheapActionImages,true,[IsGroup],0,Ignore);
InstallMethod(DoCheapActionImages,true,[IsPermGroup],0,COM_FUN(14));
InstallGlobalFunction(ImproveActionDegreeByBlocks,COM_FUN(15));
InstallGlobalFunction(SmallerDegreePermutationRepresentation,COM_FUN(16));
BADINDEX:=1000;
GenericFindActionKernel:=COM_FUN(17);
InstallMethod(FindActionKernel,"generic for finite groups",IsIdenticalObj,[IsGroup and IsFinite,IsGroup],0,COM_FUN(18));
InstallMethod(FindActionKernel,"general case: can't do",IsIdenticalObj,[IsGroup,IsGroup],0,COM_FUN(19));
InstallMethod(FindActionKernel,"perm",IsIdenticalObj,[IsPermGroup,IsPermGroup],0,COM_FUN(20));
InstallMethod(FindActionKernel,"Niceo",IsIdenticalObj,[IsGroup and IsHandledByNiceMonomorphism,IsGroup],0,COM_FUN(21));
InstallMethod(NaturalHomomorphismByNormalSubgroupOp,"search for operation",IsIdenticalObj,[IsGroup,IsGroup],0,COM_FUN(22));
NH_TRYPCGS_LIMIT:=30000;
InstallMethod(NaturalHomomorphismByNormalSubgroupOp,"test if known/try solvable factor for permutation groups",IsIdenticalObj,[IsPermGroup,IsPermGroup],0,COM_FUN(23));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/factgrp.gi"

#F  file="lib/grpreps.gi" crc=122460261
RANK_FILTER_LIST  := [ 53660808, 21, 25270276, 48, 53660808, 21, 25259116, 
  53, 17, 18 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grpreps.gi", 122460261 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grpreps.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grpreps.gi");
elif COM_RESULT = 3  then
Revision.grpreps_gi:="@(#)$Id: grpreps.gi,v 4.9 2002/04/15 10:04:53 sal Exp $";
InstallGlobalFunction(RegularModuleByGens,COM_FUN(1));
InstallMethod(RegularModule,"generic method for groups",true,[IsGroup,IsField],0,COM_FUN(2));
InstallMethod(IrreducibleModules,"generic method for groups and finite field",true,[IsGroup,IsField and IsFinite,IsInt],0,COM_FUN(3));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grpreps.gi"

#F  file="lib/grppcrep.gi" crc=-129659297
RANK_FILTER_LIST  := [ 36883397, 25, 25259116, 53, 17, 18, 36883397, 25, 
  25259116, 53, 17, 18 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grppcrep.gi", -129659297 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grppcrep.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grppcrep.gi");
elif COM_RESULT = 3  then
Revision.grppcrep_gi:="@(#)$Id: grppcrep.gi,v 4.20 2002/04/15 10:04:52 sal Exp $";
MappedVector:=COM_FUN(1);
BlownUpMatrix:=COM_FUN(2);
InstallGlobalFunction(BlownUpModule,COM_FUN(3));
InstallGlobalFunction(ConjugatedModule,COM_FUN(4));
InstallGlobalFunction(FpOfModules,COM_FUN(5));
InstallGlobalFunction(EquivalenceType,COM_FUN(6));
InstallGlobalFunction(IsEquivalentByFp,COM_FUN(7));
InstallGlobalFunction(GaloisConjugates,COM_FUN(8));
InstallGlobalFunction(TrivialModule,COM_FUN(9));
InstallGlobalFunction(InducedModule,COM_FUN(10));
InstallGlobalFunction(InducedModuleByFieldReduction,COM_FUN(11));
InstallGlobalFunction(ExtensionsOfModule,COM_FUN(12));
InstallGlobalFunction(InitAbsAndIrredModules,COM_FUN(13));
InstallGlobalFunction(LiftAbsAndIrredModules,COM_FUN(14));
InstallGlobalFunction(AbsAndIrredModules,COM_FUN(15));
InstallMethod(AbsolutIrreducibleModules,"generic method for groups with pcgs",true,[IsGroup and CanEasilyComputePcgs,IsField and IsFinite,IsInt],0,COM_FUN(16));
InstallMethod(IrreducibleModules,"generic method for groups with pcgs",true,[IsGroup and CanEasilyComputePcgs,IsField and IsFinite,IsInt],0,COM_FUN(17));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grppcrep.gi"

#F  file="lib/grpprmcs.gi" crc=94121059
RANK_FILTER_LIST  := [ 45271600, 33, 45271600, 33, 52247917, 19, 45271600, 
  33, 45271600, 33, 53660808, 21, 53660808, 21, 53660808, 21, 53660808, 21, 
  8193, 2, 53660808, 21, 53660808, 21, 8193, 2 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grpprmcs.gi", 94121059 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grpprmcs.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grpprmcs.gi");
elif COM_RESULT = 3  then
Revision.grpprmcs_gi:="@(#)$Id: grpprmcs.gi,v 4.48 2003/05/28 19:17:02 gap Exp $";
GInverses:=COM_FUN(1);
InstallGlobalFunction(DisplayCompositionSeries,COM_FUN(2));
InstallMethod(CompositionSeries,"for a permutation group",true,[IsPermGroup],0,COM_FUN(3));
InstallGlobalFunction(NonPerfectCSPG,COM_FUN(4));
InstallGlobalFunction(PerfectCSPG,COM_FUN(5));
InstallGlobalFunction(CasesCSPG,COM_FUN(6));
InstallGlobalFunction(FindNormalCSPG,COM_FUN(7));
InstallGlobalFunction(FindRegularNormalCSPG,COM_FUN(8));
InstallGlobalFunction(NinKernelCSPG,COM_FUN(9));
InstallGlobalFunction(RegularNinKernelCSPG,COM_FUN(10));
InstallGlobalFunction(NormalizerStabCSPG,COM_FUN(11));
InstallGlobalFunction(TransStabCSPG,COM_FUN(12));
InstallGlobalFunction(PullbackKernelCSPG,COM_FUN(13));
InstallGlobalFunction(PullbackCSPG,COM_FUN(14));
InstallGlobalFunction(CosetRepAsWord,COM_FUN(15));
InstallGlobalFunction(ImageInWord,COM_FUN(16));
InstallGlobalFunction(SiftAsWord,COM_FUN(17));
InstallGlobalFunction(InverseAsWord,COM_FUN(18));
InstallGlobalFunction(RandomElmAsWord,COM_FUN(19));
InstallMethod(PCoreOp,"for a permutation group, and a positive integer",true,[IsPermGroup,IsPosInt],0,COM_FUN(20));
InstallMethod(RadicalGroup," for a permutation group",true,[IsPermGroup],0,COM_FUN(21));
InstallMethod(Centre,"for a permutation group",[IsPermGroup],COM_FUN(22));
InstallGlobalFunction(CentralizerNormalCSPG,COM_FUN(23));
InstallGlobalFunction(CentralizerNormalTransCSPG,COM_FUN(24));
InstallGlobalFunction(CentralizerTransSymmCSPG,COM_FUN(25));
InstallGlobalFunction(IntersectionNormalClosurePermGroup,COM_FUN(26));
InstallGlobalFunction(ActionAbelianCSPG,COM_FUN(27));
InstallGlobalFunction(ImageOnAbelianCSPG,COM_FUN(28));
InstallGlobalFunction(ChiefSeriesOfGroup,COM_FUN(29));
InstallMethod(ChiefSeries,"generic method for a group",true,[IsGroup],0,ChiefSeriesOfGroup);
InstallMethod(ChiefSeriesUnderAction,"generic method for two groups",true,[IsGroup,IsGroup],0,ChiefSeriesOfGroup);
InstallMethod(ChiefSeriesThrough,"generic method for a group and a list",true,[IsGroup,IsList],0,ChiefSeriesOfGroup);
InstallOtherMethod(ChiefSeriesThrough,"generic method for two groups and a list",true,[IsGroup,IsGroup,IsList],0,ChiefSeriesOfGroup);
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grpprmcs.gi"

#F  file="lib/grpnames.gi" crc=-26407120
RANK_FILTER_LIST  := [ 53660808, 21, 53660808, 21, 53660808, 21, 53660808, 
  21, 53660808, 21, 53660808, 21, 53660808, 21, 53660808, 21, 53660808, 21, 
  53660808, 21, 53660808, 21, 53660808, 21, 53660808, 21, 53660808, 21, 
  53660808, 21, 53660808, 21, 53660808, 21, 53660808, 21, 53660808, 21, 
  53660808, 21, 53660808, 21, 53660808, 21, 55261123, 22 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grpnames.gi", -26407120 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grpnames.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grpnames.gi");
elif COM_RESULT = 3  then
Revision.grpnames_gi:="@(#)$Id: grpnames.gi,v 4.9.2.2 2005/05/03 13:53:45 stefan Exp $";
InstallMethod(DirectFactorsOfGroup,"generic method",true,[IsGroup],0,COM_FUN(1));
InstallMethod(SemidirectFactorsOfGroup,"generic method",true,[IsGroup],0,COM_FUN(2));
InstallMethod(DecompositionTypesOfGroup,"generic method",true,[IsGroup],0,COM_FUN(3));
InstallMethod(IsDihedralGroup,"generic method",true,[IsGroup],0,COM_FUN(4));
InstallMethod(IsQuaternionGroup,"generic method",true,[IsGroup],0,COM_FUN(5));
InstallMethod(IsQuasiDihedralGroup,"generic method",true,[IsGroup],0,COM_FUN(6));
InstallMethod(IsAlternatingGroup,"generic method",true,[IsGroup],0,COM_FUN(7));
InstallMethod(AlternatingDegree,"generic method, dispatch to `IsAlternatingGroup'",true,[IsGroup],0,COM_FUN(8));
InstallOtherMethod(IsNaturalAlternatingGroup,"for non-permutation group",true,[IsGroup],0,COM_FUN(9));
InstallMethod(IsSymmetricGroup,"generic method",true,[IsGroup],0,COM_FUN(10));
InstallOtherMethod(IsNaturalSymmetricGroup,"for non-permutation group",true,[IsGroup],0,COM_FUN(11));
InstallMethod(SymmetricDegree,"generic method, dispatch to `IsSymmetricGroup'",true,[IsGroup],0,COM_FUN(12));
InstallGlobalFunction(SizeGL,COM_FUN(13));
InstallGlobalFunction(SizeSL,COM_FUN(14));
InstallGlobalFunction(SizePSL,COM_FUN(15));
InstallGlobalFunction(LinearGroupParameters,COM_FUN(16));
InstallMethod(IsPSL,"generic method for finite groups",true,[IsGroup],0,COM_FUN(17));
InstallMethod(PSLDegree,"generic method for finite groups",true,[IsGroup],0,COM_FUN(18));
InstallMethod(PSLUnderlyingField,"generic method for finite groups",true,[IsGroup],0,COM_FUN(19));
InstallMethod(IsSL,"generic method for finite groups",true,[IsGroup],0,COM_FUN(20));
InstallMethod(SLDegree,"generic method for finite groups",true,[IsGroup],0,COM_FUN(21));
InstallMethod(SLUnderlyingField,"generic method for finite groups",true,[IsGroup],0,COM_FUN(22));
InstallMethod(IsGL,"generic method for finite groups",true,[IsGroup],0,COM_FUN(23));
InstallMethod(GLDegree,"generic method for finite groups",true,[IsGroup],0,COM_FUN(24));
InstallMethod(GLUnderlyingField,"generic method for finite groups",true,[IsGroup],0,COM_FUN(25));
InstallMethod(StructureDescription,"for finite groups",true,[IsGroup],0,COM_FUN(26));
InstallMethod(ViewObj,"for groups with known structure description",true,[IsGroup and HasStructureDescription],SUM_FLAGS,COM_FUN(27));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grpnames.gi"

#F  file="lib/onecohom.gi" crc=41251423
RANK_FILTER_LIST  := [ 4097, 1, 53460738, 20, 4097, 1, 8193, 2, 4097, 1, 
  53460738, 20, 4097, 1, 8193, 2, 4097, 1, 12585763, 33, 4063233, 1, 4097, 1, 
  39812596, 21, 4097, 1, 8193, 2, 4097, 1, 8193, 2, 4097, 1, 12585763, 33, 
  4063233, 1, 4097, 1, 53660808, 21, 4063233, 1 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/onecohom.gi", 41251423 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/onecohom.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/onecohom.gi");
elif COM_RESULT = 3  then
Revision.onecohom_gi:="@(#)$Id: onecohom.gi,v 4.43.2.1 2004/02/10 18:34:23 gap Exp $";
InstallGlobalFunction(TriangulizedGeneratorsByMatrix,COM_FUN(1));
OCAddGeneratorsPcgs:=COM_FUN(2);
OCAddGeneratorsGeneral:=COM_FUN(3);
InstallGlobalFunction(OCAddGenerators,COM_FUN(4));
InstallGlobalFunction(OCAddMatrices,COM_FUN(5));
InstallGlobalFunction(OCAddToFunctions,COM_FUN(6));
InstallMethod(OCAddToFunctions2,"pc group",true,[IsRecord,IsModuloPcgs],2,COM_FUN(7));
InstallMethod(OCAddToFunctions2,"generic",true,[IsRecord,IsList],0,COM_FUN(8));
OCAddCentralizer:=COM_FUN(9);
InstallGlobalFunction(OCOneCoboundaries,COM_FUN(10));
InstallGlobalFunction(OCConjugatingWord,COM_FUN(11));
InstallMethod(OCAddRelations,"pc group",true,[IsRecord,IsModuloPcgs],0,COM_FUN(12));
InstallMethod(OCAddRelations,"perm group",true,[IsRecord,IsList],0,COM_FUN(13));
BindGlobal("OCTestRelations",COM_FUN(14));
InstallMethod(OCNormalRelations,"pc group",true,[IsRecord,IsPcGroup,IsListOrCollection],0,COM_FUN(15));
InstallMethod(OCAddSumMatrices,"pc group",true,[IsRecord,IsPcgs],0,COM_FUN(16));
InstallMethod(OCAddSumMatrices,"perm group",true,[IsRecord,IsList],0,COM_FUN(17));
InstallGlobalFunction(OCEquationMatrix,COM_FUN(18));
InstallMethod(OCAddBigMatrices,"general",true,[IsRecord,IsList],0,COM_FUN(19));
InstallGlobalFunction(OCSmallEquationMatrix,COM_FUN(20));
InstallGlobalFunction(OCEquationVector,COM_FUN(21));
InstallGlobalFunction(OCSmallEquationVector,COM_FUN(22));
InstallMethod(OCAddComplement,"pc group",true,[IsRecord,IsPcGroup,IsListOrCollection],0,COM_FUN(23));
InstallMethod(OCAddComplement,"generic",true,[IsRecord,IsGroup,IsListOrCollection],0,COM_FUN(24));
InstallGlobalFunction(OCOneCocycles,COM_FUN(25));
InstallGlobalFunction(OneCoboundaries,COM_FUN(26));
InstallGlobalFunction(OneCocycles,COM_FUN(27));
InstallGlobalFunction(ComplementclassesEA,COM_FUN(28));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/onecohom.gi"

#F  file="lib/grppccom.gi" crc=-76127841
RANK_FILTER_LIST  := [ 50331469, 25, 50331469, 25, 53660808, 21, 53660808, 
  21, 53660808, 21, 53660808, 21, 53660808, 21 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grppccom.gi", -76127841 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grppccom.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grppccom.gi");
elif COM_RESULT = 3  then
Revision.grppccom_gi:="@(#)$Id: grppccom.gi,v 4.35 2002/04/15 10:04:51 sal Exp $";
BindGlobal("HomomorphismsSeries",COM_FUN(1));
OCTestRelators:=COM_FUN(2);
InstallGlobalFunction(COAffineBlocks,COM_FUN(3));
InstallGlobalFunction(CONextCentralizer,COM_FUN(4));
InstallGlobalFunction(CONextCocycles,COM_FUN(5));
InstallGlobalFunction(CONextCentral,COM_FUN(6));
InstallGlobalFunction(CONextComplements,COM_FUN(7));
InstallGlobalFunction(COComplements,COM_FUN(8));
InstallGlobalFunction(COComplementsMain,COM_FUN(9));
InstallMethod(ComplementclassesSolvableNC,"pc groups",IsIdenticalObj,[CanEasilyComputePcgs,CanEasilyComputePcgs],0,COM_FUN(10));
InstallMethod(Complementclasses,"solvable normal subgroup",IsIdenticalObj,[IsGroup,IsGroup],0,COM_FUN(11));
InstallMethod(Complementclasses,"tell that the normal subgroup must be solvable",IsIdenticalObj,[IsGroup,IsGroup],-2*RankFilter(IsGroup),COM_FUN(12));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grppccom.gi"

#F  file="lib/grpcompl.gi" crc=19600646
RANK_FILTER_LIST  := [ 53660808, 21, 53660808, 21 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grpcompl.gi", 19600646 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grpcompl.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grpcompl.gi");
elif COM_RESULT = 3  then
Revision.grpcompl_gi:="@(#)$Id: grpcompl.gi,v 4.13 2002/04/15 10:04:44 sal Exp $";
ComplementclassesSolvableWBG:=COM_FUN(1);
InstallMethod(ComplementclassesSolvableNC,"using cohomology",IsIdenticalObj,[IsGroup,IsGroup],1,ComplementclassesSolvableWBG);
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grpcompl.gi"

#F  file="lib/twocohom.gi" crc=126774423
RANK_FILTER_LIST  := [ 12585763, 33, 1, 0, 12585763, 33, 1, 0, 12585763, 33, 
  1, 0 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/twocohom.gi", 126774423 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/twocohom.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/twocohom.gi");
elif COM_RESULT = 3  then
Revision.twocohom_gi:="@(#)$Id: twocohom.gi,v 4.18 2002/04/15 10:05:25 sal Exp $";
InstallGlobalFunction(CollectedWordSQ,COM_FUN(1));
InstallGlobalFunction(CollectorSQ,COM_FUN(2));
InstallGlobalFunction(AddEquationsSQ,COM_FUN(3));
InstallGlobalFunction(SolutionSQ,COM_FUN(4));
InstallGlobalFunction(TwoCocyclesSQ,COM_FUN(5));
InstallGlobalFunction(TwoCoboundariesSQ,COM_FUN(6));
InstallGlobalFunction(TwoCohomologySQ,COM_FUN(7));
InstallMethod(TwoCocycles,"generic method for pc groups",true,[IsPcGroup,IsObject],0,COM_FUN(8));
InstallMethod(TwoCoboundaries,"generic method for pc groups",true,[IsPcGroup,IsObject],0,COM_FUN(9));
InstallMethod(TwoCohomology,"generic method for pc groups",true,[IsPcGroup,IsObject],0,COM_FUN(10));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/twocohom.gi"

#F  file="lib/grppcext.gi" crc=96437112
RANK_FILTER_LIST  := [ 50331469, 25, 1, 0, 63198130, 7, 50331469, 25, 1, 0, 
  63198130, 7, 50331469, 25, 1, 0, 50331469, 25, 4097, 1, 53660808, 21, 
  50331469, 25, 1, 0, 50331469, 25, 1, 0, 50331469, 25, 50331469, 25, 1, 0, 
  17, 18, 50331469, 25, 17, 18 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grppcext.gi", 96437112 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grppcext.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grppcext.gi");
elif COM_RESULT = 3  then
Revision.grppcext_gi:="@(#)$Id: grppcext.gi,v 4.55 2003/04/09 16:25:45 gap Exp $";
InstallGlobalFunction(FpGroupPcGroupSQ,COM_FUN(1));
InstallGlobalFunction(MappedPcElement,COM_FUN(2));
InstallGlobalFunction(ExtensionSQ,COM_FUN(3));
BindGlobal("FastExtSQ",COM_FUN(4));
InstallMethod(Extension,"generic method for pc groups",true,[CanEasilyComputePcgs,IsObject,IsVector],0,COM_FUN(5));
InstallMethod(ExtensionNC,"generic method for pc groups",true,[CanEasilyComputePcgs,IsObject,IsVector],0,COM_FUN(6));
InstallMethod(Extensions,"generic method for pc groups",true,[CanEasilyComputePcgs,IsObject],0,COM_FUN(7));
RelVectorToCocycle:=COM_FUN(8);
OnRelVector:=COM_FUN(9);
CocycleToRelVector:=COM_FUN(10);
OnCocycle:=COM_FUN(11);
IsCocycle:=COM_FUN(12);
InstallGlobalFunction(CompatiblePairs,COM_FUN(13));
IsCompatiblePair:=COM_FUN(14);
MatrixOperationOfCP:=COM_FUN(15);
MatrixOperationOfCPGroup:=COM_FUN(16);
InstallMethod(ExtensionRepresentatives,"generic method for pc groups",true,[CanEasilyComputePcgs,IsRecord,IsGroup],0,COM_FUN(17));
MyIntCoefficients:=COM_FUN(18);
MatOrbsApprox:=COM_FUN(19);
MatOrbs:=COM_FUN(20);
NonSplitExtensions:=COM_FUN(21);
InstallMethod(SplitExtension,"generic method for pc groups",true,[CanEasilyComputePcgs,IsObject],0,COM_FUN(22));
InstallOtherMethod(SplitExtension,"generic method for pc groups",true,[CanEasilyComputePcgs,IsObject,CanEasilyComputePcgs],0,COM_FUN(23));
ConjugatingElement:=COM_FUN(24);
InstallMethod(TopExtensionsByAutomorphism,"generic method for groups",true,[CanEasilyComputePcgs,IsObject,IsInt],0,COM_FUN(25));
InstallMethod(CyclicTopExtensions,"generic method for pc groups",true,[CanEasilyComputePcgs,IsInt],0,COM_FUN(26));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grppcext.gi"

#F  file="lib/randiso.gi" crc=-86586200
RANK_FILTER_LIST  := [ 12585763, 33, 53660808, 21 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/randiso.gi", -86586200 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/randiso.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/randiso.gi");
elif COM_RESULT = 3  then
Revision.randiso_gi:="@(#)$Id: randiso.gi,v 1.24 2002/04/15 10:05:13 sal Exp $";
FingerprintFF:=COM_FUN(1);
InstallMethod(OmegaAndLowerPCentralSeries,"omega and lower central",true,[IsPcGroup],0,COM_FUN(2));
InstallMethod(OmegaAndLowerPCentralSeries,"general case: warn that no method available",true,[IsGroup],0,COM_FUN(3));
RelatorsCode:=COM_FUN(4);
InstallGlobalFunction(PcGroupCode,COM_FUN(5));
InstallGlobalFunction(CodePcgs,COM_FUN(6));
InstallGlobalFunction(CodePcGroup,COM_FUN(7));
InstallGlobalFunction(PcGroupCodeRec,COM_FUN(8));
RandomByPcs:=COM_FUN(9);
IsLinearlyIndependent:=COM_FUN(10);
FindLayer:=COM_FUN(11);
RandomPcgsSylowSubgroup:=COM_FUN(12);
InstallGlobalFunction(RandomSpecialPcgsCoded,COM_FUN(13));
InstallGlobalFunction(RandomIsomorphismTest,COM_FUN(14));
InstallGlobalFunction(ReducedByIsomorphisms,COM_FUN(15));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/randiso.gi"

#F  file="lib/randiso2.gi" crc=-122091834
RANK_FILTER_LIST  := [  ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/randiso2.gi", -122091834 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/randiso2.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/randiso2.gi");
elif COM_RESULT = 3  then
Revision.randiso2_gi:="@(#)$Id: randiso2.gi,v 1.23 2002/04/15 10:05:13 sal Exp $";
EvalFpCoc:=COM_FUN(1);
CocGroup:=COM_FUN(2);
DiffCoc:=COM_FUN(3);
SplitUpSublistsByFpFunc:=COM_FUN(4);
CodeGenerators:=COM_FUN(5);
IsomorphismSolvableSmallGroups:=COM_FUN(6);
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/randiso2.gi"

#F  file="lib/grppcfp.gi" crc=81937906
RANK_FILTER_LIST  := [ 36883397, 25, 67108760, 5, 36883397, 25, 67108760, 5, 
  53660808, 21, 39812596, 21, 67108760, 5 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grppcfp.gi", 81937906 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grppcfp.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grppcfp.gi");
elif COM_RESULT = 3  then
Revision.grppcfp_gi:="@(#)$Id: grppcfp.gi,v 4.44.2.2 2004/04/27 16:39:43 gap Exp $";
InstallGlobalFunction(PcGroupFpGroup,COM_FUN(1));
InstallGlobalFunction(PcGroupFpGroupNC,COM_FUN(2));
InstallGlobalFunction(IsomorphismFpGroupByPcgs,COM_FUN(3));
InstallOtherMethod(IsomorphismFpGroupByCompositionSeries,"pc groups",true,[IsGroup and CanEasilyComputePcgs,IsString],0,COM_FUN(4));
InstallOtherMethod(IsomorphismFpGroup,"pc groups",true,[IsGroup and CanEasilyComputePcgs,IsString],0,COM_FUN(5));
InstallMethod(IsomorphismFpGroupByGeneratorsNC,"pcgs",IsFamFamX,[IsGroup,IsPcgs,IsString],0,COM_FUN(6));
InstallGlobalFunction(InitEpimorphismSQ,COM_FUN(7));
InstallGlobalFunction(LiftEpimorphismSQ,COM_FUN(8));
InstallGlobalFunction(BlowUpCocycleSQ,COM_FUN(9));
InstallGlobalFunction(TryModuleSQ,COM_FUN(10));
InstallGlobalFunction(AllModulesSQ,COM_FUN(11));
InstallGlobalFunction(TryLayerSQ,COM_FUN(12));
InstallGlobalFunction(EAPrimeLayerSQ,COM_FUN(13));
InstallGlobalFunction(SolvableQuotient,COM_FUN(14));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grppcfp.gi"

#F  file="lib/schur.gi" crc=113572822
RANK_FILTER_LIST  := [ 58923477, 23, 53660808, 21, 53660808, 21, 53660808, 
  21, 53660808, 21, 8193, 2, 53660808, 21 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/schur.gi", 113572822 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/schur.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/schur.gi");
elif COM_RESULT = 3  then
Revision.schur_gi:="@(#)$Id: schur.gi,v 4.18 2002/04/15 10:05:16 sal Exp $";
BindGlobal("SchurCoverFP",COM_FUN(1));
InstallMethod(SchurCover,"of fp group",true,[IsSubgroupFpGroup],0,SchurCoverFP);
InstallMethod(EpimorphismSchurCover,"generic, via fp group",true,[IsGroup],0,COM_FUN(2));
BindGlobal("CommutGenImgs",COM_FUN(3));
InstallGlobalFunction(SchuMu,COM_FUN(4));
InstallMethod(AbelianInvariantsMultiplier,"via Sylow Subgroups",true,[IsGroup],0,COM_FUN(5));
BindGlobal("PositiveExponentsPresentationFpHom",COM_FUN(6));
InstallGlobalFunction(CorestEval,COM_FUN(7));
InstallGlobalFunction(RelatorFixedMultiplier,COM_FUN(8));
BindGlobal("MulExt",COM_FUN(9));
DoMulExt:=COM_FUN(10);
InstallMethod(EpimorphismSchurCover,"Holt's algorithm",true,[IsGroup],0,DoMulExt);
InstallOtherMethod(EpimorphismSchurCover,"Holt's algorithm, primes",true,[IsGroup,IsList],0,DoMulExt);
InstallMethod(SchurCover,"general: Holt's algorithm",true,[IsGroup],0,COM_FUN(11));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/schur.gi"

#F  file="lib/grpnice.gi" crc=-47285033
RANK_FILTER_LIST  := [ 53660808, 21, 44568071, 13, 15881342, 222, 15881342, 
  222, 1829479, 17, 53660808, 21, 15881342, 222, 36126208, 238, 30969596, 
  223, 15881342, 222, 15881342, 222, 15881342, 222, 65767820, 5, 15881342, 
  222, 15881342, 223, 15881342, 223, 15881342, 223, 15881342, 223, 1, 0, 
  15881342, 223, 15881342, 223, 15881342, 223, 15881342, 223, 65767820, 5, 
  15881342, 223, 15881342, 223, 15881342, 223, 15881342, 223, 15881342, 223, 
  30969596, 224, 65767820, 5, 15881342, 223, 15881342, 223, 15881342, 223, 
  15881342, 223, 15881342, 223, 15881342, 223, 15881342, 223, 15881342, 223, 
  15881342, 223, 15881342, 223, 15881342, 223, 8193, 2, 15881342, 223, 
  15881342, 223, 15881342, 223, 15881342, 223, 15881342, 223, 15881342, 223, 
  15881342, 223, 15881342, 223, 15881342, 223, 15881342, 223, 15881342, 223, 
  15881342, 223, 15881342, 223, 15881342, 223, 15881342, 223, 15881342, 223, 
  15881342, 223, 15881342, 223, 15881342, 223, 15881342, 223, 67108760, 5, 
  15881342, 223, 8193, 2, 67108760, 5, 15881342, 223, 15881342, 223, 
  15881342, 223, 15881342, 223, 15881342, 223, 15881342, 223, 15881342, 223, 
  15881342, 223, 15881342, 223, 15881342, 223, 15881342, 223, 15881342, 223, 
  15881342, 223, 15881342, 223, 52247917, 19, 15881342, 223, 52247917, 19, 
  15881342, 223, 17, 18, 32769, 4, 15881342, 223, 15881342, 223, 15881342, 
  223, 15881342, 223, 53660808, 21, 15881342, 223, 15881342, 223, 15881342, 
  223, 15881342, 223, 52247917, 19, 15881342, 223, 15881342, 223, 65767820, 
  5, 65767820, 5, 5, 1, 15881342, 223, 53660808, 21, 15881342, 223, 53660808, 
  21, 8193, 2, 8193, 2, 51119912, 14, 63192531, 18, 65767820, 5, 39327706, 
  22, 43296134, 22 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grpnice.gi", -47285033 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grpnice.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grpnice.gi");
elif COM_RESULT = 3  then
Revision.grpnice_gi:="@(#)$Id: grpnice.gi,v 4.71.2.1 2004/10/27 17:23:52 gap Exp $";
InstallMethod(SetNiceMonomorphism,"set `IsNiceomorphism' property",true,[IsGroup,IsGroupGeneralMapping],SUM_FLAGS+10,COM_FUN(1));
InstallGlobalFunction(RestrictedNiceMonomorphism,COM_FUN(2));
InstallMethod(GeneratorsOfMagmaWithInverses,true,[IsGroup and IsHandledByNiceMonomorphism],0,COM_FUN(3));
InstallMethod(SmallGeneratingSet,true,[IsGroup and IsHandledByNiceMonomorphism],0,COM_FUN(4));
InstallMethod(GroupByNiceMonomorphism,true,[IsGroupHomomorphism,IsGroup],0,COM_FUN(5));
InstallMethod(NiceObject,true,[IsGroup and IsHandledByNiceMonomorphism],0,COM_FUN(6));
InstallMethod(NiceMonomorphism,"for subgroups that get the nice monomorphism by their parent",true,[IsGroup and IsHandledByNiceMonomorphism and HasParent],RankFilter(IsFinite and IsMatrixGroup),COM_FUN(7));
InstallMethod(NiceMonomorphism,"regular action",true,[IsGroup and IsHandledByNiceMonomorphism],0,COM_FUN(8));
PropertyMethodByNiceMonomorphismCollColl(\=,[IsGroup,IsGroup]);
InstallMethod(\in,"by nice monomorphism",IsElmsColls,[IsMultiplicativeElementWithInverse,IsGroup and IsHandledByNiceMonomorphism],0,COM_FUN(9));
InstallTrueMethod(CanEasilyTestMembership,IsHandledByNiceMonomorphism);
AttributeMethodByNiceMonomorphism(AbelianInvariants,[IsGroup]);
SubgroupMethodByNiceMonomorphismCollColl(CentralizerOp,[IsGroup,IsGroup]);
SubgroupMethodByNiceMonomorphismCollElm(CentralizerOp,[IsGroup,IsObject]);
GroupSeriesMethodByNiceMonomorphism(ChiefSeries,[IsGroup]);
GroupMethodByNiceMonomorphismCollColl(ClosureGroup,[IsGroup,IsGroup]);
GroupMethodByNiceMonomorphismCollElm(ClosureGroup,[IsGroup,IsMultiplicativeElementWithInverse]);
AttributeMethodByNiceMonomorphism(CommutatorFactorGroup,[IsGroup]);
GroupMethodByNiceMonomorphismCollColl(CommutatorSubgroup,[IsGroup,IsGroup]);
GroupSeriesMethodByNiceMonomorphism(CompositionSeries,[IsGroup]);
InstallMethod(ConjugacyClasses,"via niceomorphism",true,[IsGroup and IsHandledByNiceMonomorphism],0,COM_FUN(10));
GroupMethodByNiceMonomorphismCollElm(ConjugateGroup,[IsGroup and HasParent,IsMultiplicativeElementWithInverse]);
GroupMethodByNiceMonomorphismCollColl(CoreOp,[IsGroup,IsGroup]);
AttributeMethodByNiceMonomorphism(DerivedLength,[IsGroup]);
GroupSeriesMethodByNiceMonomorphism(DerivedSeriesOfGroup,[IsGroup]);
SubgroupMethodByNiceMonomorphism(DerivedSubgroup,[IsGroup]);
GroupSeriesMethodByNiceMonomorphism(ElementaryAbelianSeries,[IsGroup]);
GroupSeriesMethodByNiceMonomorphism(ElementaryAbelianSeriesLargeSteps,[IsGroup]);
AttributeMethodByNiceMonomorphism(Exponent,[IsGroup]);
SubgroupMethodByNiceMonomorphism(FittingSubgroup,[IsGroup]);
SubgroupMethodByNiceMonomorphism(FrattiniSubgroup,[IsGroup]);
InstallMethod(HallSubgroupOp,"via niceomorphism",true,[IsGroup and IsHandledByNiceMonomorphism,IsList],0,COM_FUN(11));
AttributeMethodByNiceMonomorphismCollColl(IndexOp,[IsGroup,IsGroup]);
AttributeMethodByNiceMonomorphismCollColl(IndexNC,[IsGroup,IsGroup]);
GroupMethodByNiceMonomorphismCollColl(Intersection2,[IsGroup,IsGroup]);
PropertyMethodByNiceMonomorphism(IsCyclic,[IsGroup]);
PropertyMethodByNiceMonomorphism(IsMonomialGroup,[IsGroup]);
PropertyMethodByNiceMonomorphism(IsNilpotentGroup,[IsGroup]);
PropertyMethodByNiceMonomorphismCollColl(IsNormalOp,[IsGroup,IsGroup]);
PropertyMethodByNiceMonomorphism(IsPerfectGroup,[IsGroup]);
PropertyMethodByNiceMonomorphism(IsSimpleGroup,[IsGroup]);
PropertyMethodByNiceMonomorphism(IsSolvableGroup,[IsGroup]);
PropertyMethodByNiceMonomorphismCollColl(IsSubset,[IsGroup,IsGroup]);
PropertyMethodByNiceMonomorphism(IsSupersolvableGroup,[IsGroup]);
InstallMethod(IsomorphismPermGroup,"via niceomorphisms",true,[IsGroup and IsHandledByNiceMonomorphism],-NICE_FLAGS+5,COM_FUN(12));
InstallMethod(IsomorphismPcGroup,"via niceomorphisms",true,[IsGroup and IsHandledByNiceMonomorphism],0,COM_FUN(13));
InstallOtherMethod(IsomorphismFpGroup,"via niceomorphism",true,[IsGroup and IsHandledByNiceMonomorphism,IsString],0,COM_FUN(14));
InstallMethod(IsomorphismFpGroupByGeneratorsNC,"via niceomorphism/w. gens",IsFamFamX,[IsGroup and IsHandledByNiceMonomorphism,IsList,IsString],0,COM_FUN(15));
GroupSeriesMethodByNiceMonomorphism(JenningsSeries,[IsGroup]);
GroupSeriesMethodByNiceMonomorphism(LowerCentralSeriesOfGroup,[IsGroup]);
SubgroupsMethodByNiceMonomorphism(MaximalSubgroupClassReps,[IsGroup]);
SubgroupsMethodByNiceMonomorphism(NormalSubgroups,[IsGroup]);
GroupMethodByNiceMonomorphismCollColl(NormalClosureOp,[IsGroup,IsGroup]);
GroupMethodByNiceMonomorphismCollColl(NormalIntersection,[IsGroup,IsGroup]);
SubgroupMethodByNiceMonomorphismCollColl(NormalizerOp,[IsGroup,IsGroup]);
AttributeMethodByNiceMonomorphism(NrConjugacyClasses,[IsGroup]);
AttributeMethodByNiceMonomorphismCollColl(NrConjugacyClassesInSupergroup,[IsGroup,IsGroup]);
GroupSeriesMethodByNiceMonomorphismCollOther(PCentralSeriesOp,[IsGroup,IsPosInt]);
SubgroupMethodByNiceMonomorphismCollOther(PCoreOp,[IsGroup,IsPosInt]);
InstallMethod(PowerMapOfGroup,"via niceomorphism",true,[IsGroup and IsHandledByNiceMonomorphism,IsInt,IsHomogeneousList],0,COM_FUN(16));
SubgroupMethodByNiceMonomorphism(RadicalGroup,[IsGroup]);
InstallMethod(Random,"handled by nice monomorphism",true,[IsGroup and IsHandledByNiceMonomorphism],0,COM_FUN(17));
InstallMethod(RationalClasses,"via niceomorphism",true,[IsGroup and IsHandledByNiceMonomorphism],0,COM_FUN(18));
InstallMethod(RightCosetsNC,"via niceomorphism",true,[IsGroup and IsHandledByNiceMonomorphism,IsGroup],0,COM_FUN(19));
AttributeMethodByNiceMonomorphism(Size,[IsGroup]);
GroupSeriesMethodByNiceMonomorphismCollColl(SubnormalSeriesOp,[IsGroup,IsGroup]);
SubgroupMethodByNiceMonomorphismCollOther(SylowSubgroupOp,[IsGroup,IsPosInt]);
GroupSeriesMethodByNiceMonomorphism(UpperCentralSeriesOfGroup,[IsGroup]);
InstallOtherMethod(RepresentativeActionOp,"nice group on elements",IsCollsElmsElmsX,[IsHandledByNiceMonomorphism and IsGroup,IsMultiplicativeElementWithInverse,IsMultiplicativeElementWithInverse,IsFunction],10,COM_FUN(20));
InstallMethod(NaturalHomomorphismByNormalSubgroupOp,IsIdenticalObj,[IsHandledByNiceMonomorphism and IsGroup,IsGroup],0,COM_FUN(21));
InstallMethod(GroupGeneralMappingByImages,"from a group handled by a niceomorphism",true,[IsGroup and IsHandledByNiceMonomorphism,IsGroup,IsList,IsList],0,COM_FUN(22));
InstallMethod(AsGroupGeneralMappingByImages,"for Niceomorphisms: avoid recursion",true,[IsGroupGeneralMapping and IsNiceMonomorphism],NICE_FLAGS,COM_FUN(23));
InstallMethod(PreImagesRepresentative,"for PBG-Niceo",FamRangeEqFamElm,[IsPreimagesByAsGroupGeneralMappingByImages and IsNiceMonomorphism,IsMultiplicativeElementWithInverse],0,COM_FUN(24));
InstallMethod(NiceMonomorphism,"if a canonical nice monomorphism is already known",true,[IsGroup and HasCanonicalNiceMonomorphism],100,CanonicalNiceMonomorphism);
InstallMethod(CanonicalNiceMonomorphism,"test canonicity of existing niceo",true,[IsGroup and HasNiceMonomorphism],0,COM_FUN(25));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grpnice.gi"

#F  file="lib/morpheus.gi" crc=83123119
RANK_FILTER_LIST  := [ 33310588, 23, 53660808, 21, 53660808, 21, 5111479, 24, 
  513, 8, 53650608, 26, 53660808, 21, 7394293, 38, 66135390, 232, 59314600, 
  30, 53660808, 21, 53650608, 26, 53650608, 26, 53650608, 26 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/morpheus.gi", 83123119 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/morpheus.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/morpheus.gi");
elif COM_RESULT = 3  then
Revision.morpheus_gi:="@(#)$Id: morpheus.gi,v 4.105.2.2 2004/04/30 01:48:42 gap Exp $";
MORPHEUSELMS:=50000;
InstallMethod(AutomorphismDomain,"use source of one",true,[IsGroupOfAutomorphisms],0,COM_FUN(1));
DeclareRepresentation("IsActionHomomorphismAutomGroup",IsActionHomomorphismByBase,["basepos"]);
InstallMethod(IsGroupOfAutomorphisms,"test generators and one",true,[IsGroup],0,COM_FUN(2));
InstallMethod(IsGroupOfAutomorphismsFiniteGroup,"default",true,[IsGroup],0,COM_FUN(3));
InstallGlobalFunction(AssignNiceMonomorphismAutomorphismGroup,COM_FUN(4));
InstallGlobalFunction(NiceMonomorphismAutomGroup,COM_FUN(5));
InstallMethod(PreImagesRepresentative,"AutomGroup Niceomorphism",FamRangeEqFamElm,[IsActionHomomorphismAutomGroup,IsPerm],0,COM_FUN(6));
InstallGlobalFunction(MorFroWords,COM_FUN(7));
InstallGlobalFunction(MorRatClasses,COM_FUN(8));
InstallGlobalFunction(MorMaxFusClasses,COM_FUN(9));
BindGlobal("SomeVerbalSubgroups",COM_FUN(10));
MorClassOrbs:=COM_FUN(11);
InstallGlobalFunction(MorClassLoop,COM_FUN(12));
InstallGlobalFunction(MorFindGeneratingSystem,COM_FUN(13));
InstallGlobalFunction(Morphium,COM_FUN(14));
InstallGlobalFunction(AutomorphismGroupAbelianGroup,COM_FUN(15));
InstallGlobalFunction(IsomorphismAbelianGroups,COM_FUN(16));
InstallMethod(AutomorphismGroup,"for groups",true,[IsGroup and IsFinite],0,COM_FUN(17));
RedispatchOnCondition(AutomorphismGroup,true,[IsGroup],[IsGroup and IsFinite],0);
InstallMethod(AutomorphismGroup,"finite abelian groups",true,[IsGroup and IsFinite and IsAbelian],0,AutomorphismGroupAbelianGroup);
InstallMethod(NiceMonomorphism,"for automorphism groups",true,[IsGroupOfAutomorphismsFiniteGroup],0,COM_FUN(18));
InstallMethod(InnerAutomorphismsAutomorphismGroup,"for automorphism groups",true,[IsAutomorphismGroup and IsFinite],0,COM_FUN(19));
InstallGlobalFunction(IsomorphismGroups,COM_FUN(20));
InstallMethod(GQuotients,"for groups which can compute element orders",true,[IsGroup,IsGroup and IsFinite],1,COM_FUN(21));
InstallMethod(IsomorphicSubgroups,"for finite groups",true,[IsGroup and IsFinite,IsGroup and IsFinite],1,COM_FUN(22));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/morpheus.gi"

#F  file="lib/grplatt.gi" crc=108286104
RANK_FILTER_LIST  := [ 53660808, 21, 53660808, 21, 53660808, 21, 7601547, 11, 
  7601547, 11, 53660808, 21, 7601547, 11, 7601547, 11, 7601547, 11, 52247917, 
  19, 7601547, 11, 52247917, 19, 7601547, 11, 7601547, 11, 7601547, 11, 
  53660808, 21, 30408105, 3, 53660808, 21, 30408105, 3, 30408105, 3, 
  53660808, 21, 53660808, 21, 16514503, 23, 53660808, 21, 53660808, 21, 
  40499806, 22, 30408105, 3, 30408105, 3, 53660808, 21, 53660808, 21, 
  53660808, 21, 12585763, 33, 45271600, 33, 53660808, 21, 53660808, 21, 
  53660808, 21, 53660808, 21, 53660808, 21 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grplatt.gi", 108286104 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grplatt.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grplatt.gi");
elif COM_RESULT = 3  then
Revision.grplatt_gi:="@(#)$Id: grplatt.gi,v 4.70 2003/02/18 04:59:13 gap Exp $";
InstallMethod(Zuppos,"group",true,[IsGroup],0,COM_FUN(1));
InstallMethod(ConjugacyClassSubgroups,IsIdenticalObj,[IsGroup,IsGroup],0,COM_FUN(2));
InstallMethod(\=,IsIdenticalObj,[IsConjugacyClassSubgroupsRep,IsConjugacyClassSubgroupsRep],0,COM_FUN(3));
InstallMethod(\in,IsElmsColls,[IsGroup,IsConjugacyClassSubgroupsRep],0,COM_FUN(4));
InstallOtherMethod(AsList,"for classes of subgroups",true,[IsConjugacyClassSubgroupsRep],0,COM_FUN(5));
InstallMethod(ClassElementLattice,"for classes of subgroups",true,[IsConjugacyClassSubgroupsRep,IsPosInt],0,COM_FUN(6));
InstallOtherMethod(\[\],"for classes of subgroups",true,[IsConjugacyClassSubgroupsRep,IsPosInt],0,ClassElementLattice);
InstallMethod(StabilizerOfExternalSet,true,[IsConjugacyClassSubgroupsRep],10,COM_FUN(7));
InstallOtherMethod(NormalizerOp,true,[IsConjugacyClassSubgroupsRep],0,StabilizerOfExternalSet);
InstallMethod(PrintObj,true,[IsConjugacyClassSubgroupsRep],0,COM_FUN(8));
InstallMethod(ConjugacyClassesSubgroups,"group",true,[IsGroup],0,COM_FUN(9));
InstallOtherMethod(ConjugacyClassesSubgroups,"lattice",true,[IsLatticeSubgroupsRep],0,COM_FUN(10));
SOLVABILITY_IMPLYING_FUNCTIONS:=[IsSolvableGroup,IsNilpotentGroup,IsPGroup,IsCyclic];
InstallGlobalFunction(LatticeByCyclicExtension,COM_FUN(11));
InstallMethod(LatticeSubgroups,"cyclic extension",true,[IsGroup],0,LatticeByCyclicExtension);
InstallMethod(ViewObj,"lattice",true,[IsLatticeSubgroupsRep],0,COM_FUN(12));
InstallMethod(PrintObj,"lattice",true,[IsLatticeSubgroupsRep],0,COM_FUN(13));
InstallMethod(ConjugacyClassesPerfectSubgroups,"generic",true,[IsGroup],0,COM_FUN(14));
InstallMethod(PerfectResiduum,"for groups",true,[IsGroup],0,COM_FUN(15));
InstallMethod(RepresentativesPerfectSubgroups,"solvable",true,[IsSolvableGroup],0,COM_FUN(16));
BindGlobal("RepsPerfSimpSub",COM_FUN(17));
InstallMethod(RepresentativesPerfectSubgroups,"using Holt/Plesken library",true,[IsGroup],0,COM_FUN(18));
InstallMethod(RepresentativesSimpleSubgroups,"using Holt/Plesken library",true,[IsGroup],0,COM_FUN(19));
InstallMethod(RepresentativesSimpleSubgroups,"if perfect subs are known",true,[IsGroup and HasRepresentativesPerfectSubgroups],0,COM_FUN(20));
InstallMethod(MaximalSubgroupsLattice,"cyclic extension",true,[IsLatticeSubgroupsRep],0,COM_FUN(21));
InstallMethod(MinimalSupergroupsLattice,"cyclic extension",true,[IsLatticeSubgroupsRep],0,COM_FUN(22));
InstallMethod(MaximalSubgroupClassReps,"using lattice",true,[IsGroup],0,COM_FUN(23));
InstallMethod(ConjugacyClassesMaximalSubgroups,"use MaximalSubgroupClassReps",true,[IsGroup],0,COM_FUN(24));
InstallMethod(MaximalSubgroups,"expand list",true,[IsGroup],0,COM_FUN(25));
NormalSubgroupsCalc:=COM_FUN(26);
InstallMethod(NormalSubgroups,"homomorphism principle pc groups",true,[IsPcGroup],0,NormalSubgroupsCalc);
InstallMethod(NormalSubgroups,"homomorphism principle perm groups",true,[IsPermGroup],0,NormalSubgroupsCalc);
InstallMethod(Socle,"from normal subgroups",true,[IsGroup],0,COM_FUN(27));
InstallMethod(IntermediateSubgroups,"blocks for coset operation",IsIdenticalObj,[IsGroup,IsGroup],0,COM_FUN(28));
InstallMethod(IntermediateSubgroups,"normal case",IsIdenticalObj,[IsGroup,IsGroup],1,COM_FUN(29));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grplatt.gi"

#F  file="lib/oprtglat.gi" crc=-130584427
RANK_FILTER_LIST  := [ 53660808, 21, 8193, 2, 1025, 1, 45271600, 33, 8193, 2, 
  1025, 1, 12585763, 33, 8193, 2, 1025, 1, 53660808, 21, 4097, 1, 1025, 1, 
  53660808, 21, 8193, 2, 53660808, 21, 8193, 2, 8193, 2, 5, 1, 53660808, 21, 
  53660808, 21, 8193, 2, 8193, 2, 5, 1 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/oprtglat.gi", -130584427 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/oprtglat.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/oprtglat.gi");
elif COM_RESULT = 3  then
Revision.oprtglat_gi:="@(#)$Id: oprtglat.gi,v 4.12 2002/04/15 10:05:06 sal Exp $";
InstallGlobalFunction(GroupOnSubgroupsOrbit,COM_FUN(1));
InstallGlobalFunction(MinimumGroupOnSubgroupsOrbit,COM_FUN(2));
InstallMethod(SubgroupsOrbitsAndNormalizers,"generic on list",true,[IsGroup,IsList,IsBool],0,COM_FUN(3));
InstallMethod(SubgroupsOrbitsAndNormalizers,"perm group on list",true,[IsPermGroup,IsList,IsBool],0,COM_FUN(4));
InstallMethod(SubgroupsOrbitsAndNormalizers,"pc group on list",true,[IsPcGroup,IsList,IsBool],0,COM_FUN(5));
InstallMethod(SubgroupsOrbitsAndNormalizers,"generic on record with list",true,[IsGroup,IsRecord,IsBool],0,COM_FUN(6));
InstallMethod(StabilizerOp,"with domain, use normalizer",true,[IsGroup,IsList,IsGroup,IsList,IsList,IsFunction],200,COM_FUN(7));
InstallOtherMethod(StabilizerOp,"use normalizer",true,[IsGroup,IsGroup,IsList,IsList,IsFunction],200,COM_FUN(8));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/oprtglat.gi"

#F  file="lib/grppclat.gi" crc=28682200
RANK_FILTER_LIST  := [ 53660808, 21 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grppclat.gi", 28682200 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grppclat.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grppclat.gi");
elif COM_RESULT = 3  then
Revision.grppclat_gi:="@(#)$Id: grppclat.gi,v 4.59 2003/04/09 16:25:45 gap Exp $";
InstallGlobalFunction(InvariantElementaryAbelianSeries,COM_FUN(1));
InstallGlobalFunction(InducedAutomorphism,COM_FUN(2));
InstallGlobalFunction(InvariantSubgroupsElementaryAbelianGroup,COM_FUN(3));
InstallGlobalFunction(ActionSubspacesElementaryAbelianGroup,COM_FUN(4));
HasInvariantConjugateSubgroup:=COM_FUN(5);
InstallGlobalFunction(SubgroupsSolvableGroup,COM_FUN(6));
InstallMethod(LatticeSubgroups,"elementary abelian extension",true,[IsGroup],1,COM_FUN(7));
InstallGlobalFunction(SizeConsiderFunction,COM_FUN(8));
InstallGlobalFunction(ExactSizeConsiderFunction,COM_FUN(9));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grppclat.gi"

#F  file="lib/grppcaut.gi" crc=-78853831
RANK_FILTER_LIST  := [ 36873197, 30, 36873062, 28 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grppcaut.gi", -78853831 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grppcaut.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grppcaut.gi");
elif COM_RESULT = 3  then
Revision.grppcaut_gi:="@(#)$Id: grppcaut.gi,v 4.50 2003/06/06 21:13:16 gap Exp $";
CheckAuto:=COM_FUN(1);
InducedActionFactor:=COM_FUN(2);
CoefficientsOfVector:=COM_FUN(3);
StabilizerByMatrixOperation:=COM_FUN(4);
TransferPcgsInfo:=COM_FUN(5);
BlockStabilizer:=COM_FUN(6);
InducedActionAutGroup:=COM_FUN(7);
if not IsBound(MyFingerprint) then
MyFingerprint:=false;
fi;
FingerprintSmall:=COM_FUN(8);
FingerprintMedium:=COM_FUN(9);
FingerprintLarge:=COM_FUN(10);
Fingerprint:=COM_FUN(11);
NormalizingReducedGL:=COM_FUN(12);
CocycleSQ:=COM_FUN(13);
InduciblePairs:=COM_FUN(14);
MatricesOfRelator:=COM_FUN(15);
VectorOfRelator:=COM_FUN(16);
LiftInduciblePair:=COM_FUN(17);
AutomorphismGroupElAbGroup:=COM_FUN(18);
AutomorphismGroupSolvableGroup:=COM_FUN(19);
AutomorphismGroupFrattFreeGroup:=COM_FUN(20);
InstallMethod(AutomorphismGroup,"finite solvable groups",true,[IsGroup and IsFinite and CanEasilyComputePcgs],0,COM_FUN(21));
InstallMethod(AutomorphismGroup,"finite frattini free solvable groups",true,[IsGroup and IsFinite and IsFrattiniFree],0,COM_FUN(22));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grppcaut.gi"

#F  file="lib/grpmat.gi" crc=54565586
RANK_FILTER_LIST  := [ 36137368, 31, 8193, 2, 36137368, 31, 62261318, 34, 
  46859606, 34, 36137368, 31, 302013, 32, 50334133, 34, 36137368, 31, 
  36137368, 31, 36137368, 31, 36126208, 239, 36126208, 239, 36126208, 239, 
  36126208, 239, 36126208, 239, 36126208, 239, 58412696, 30, 302013, 32, 
  36137368, 31, 36137368, 31, 36137368, 31, 302013, 32, 58412696, 30, 
  56535772, 33, 58412696, 30, 4599548, 33, 49585440, 16, 53865321, 19, 
  53865321, 19, 38983364, 26, 44568071, 13, 10222957, 17, 58412696, 30, 
  10222957, 17, 58412696, 30, 19900471, 32 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grpmat.gi", 54565586 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grpmat.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grpmat.gi");
elif COM_RESULT = 3  then
Revision.grpmat_gi:="@(#)$Id: grpmat.gi,v 4.60.2.3 2004/10/25 16:09:07 gap Exp $";
InstallMethod(KnowsHowToDecompose,"matrix groups",[IsMatrixGroup,IsList],ReturnFalse);
InstallMethod(DefaultFieldOfMatrixGroup,"using 'FieldOfMatrixGroup'",[IsMatrixGroup],FieldOfMatrixGroup);
InstallMethod(DefaultFieldOfMatrixGroup,"for matrix group over the cyclotomics",[IsMatrixGroup and IsCyclotomicCollCollColl],COM_FUN(1));
InstallMethod(DefaultFieldOfMatrixGroup,"for a matrix group over an s.c. algebra",[IsMatrixGroup and IsSCAlgebraObjCollCollColl],COM_FUN(2));
InstallMethod(FieldOfMatrixGroup,"for a matrix group",[IsMatrixGroup],COM_FUN(3));
InstallMethod(DimensionOfMatrixGroup,"from generators",[IsMatrixGroup and HasGeneratorsOfGroup],COM_FUN(4));
InstallMethod(DimensionOfMatrixGroup,"from one",[IsMatrixGroup and HasOne],1,COM_FUN(5));
InstallOtherMethod(One,"for matrix group, call `IdentityMat'",[IsMatrixGroup],COM_FUN(6));
InstallMethod(TransposedMatrixGroup,[IsMatrixGroup],COM_FUN(7));
InstallGlobalFunction(NaturalActedSpace,COM_FUN(8));
BindGlobal("BasisVectorsForMatrixAction",COM_FUN(9));
BindGlobal("DoSparseLinearActionOnFaithfulSubset",COM_FUN(10));
BindGlobal("NicomorphismOfGeneralMatrixGroup",COM_FUN(11));
InstallMethod(IsomorphismPermGroup,"matrix group",true,[IsMatrixGroup],10,COM_FUN(12));
InstallMethod(NiceMonomorphism,"use NicomorphismOfGeneralMatrixGroup",[IsMatrixGroup and IsFinite],COM_FUN(13));
InstallMethod(CanonicalNiceMonomorphism,[IsMatrixGroup and IsFinite],COM_FUN(14));
InstallGlobalFunction(ProjectiveActionHomomorphismMatrixGroup,COM_FUN(15));
InstallMethod(GeneratorsSmallest,"matrix group via niceo",[IsMatrixGroup and IsFinite],COM_FUN(16));
InstallOtherMethod(MinimalStabChain,"matrix group via niceo",[IsMatrixGroup and IsFinite],COM_FUN(17));
InstallOtherMethod(LargestElementGroup,"matrix group via niceo",[IsMatrixGroup and IsFinite],COM_FUN(18));
InstallMethod(CanonicalRightCosetElement,"finite matric group",IsCollsElms,[IsMatrixGroup and IsFinite,IsMatrix],COM_FUN(19));
InstallMethod(ViewObj,"for a matrix group with stored generators",[IsMatrixGroup and HasGeneratorsOfGroup],COM_FUN(20));
InstallMethod(ViewObj,"for a matrix group",[IsMatrixGroup],COM_FUN(21));
InstallMethod(PrintObj,"for a matrix group",[IsMatrixGroup],COM_FUN(22));
InstallMethod(IsGeneralLinearGroup,"try natural",[IsMatrixGroup],COM_FUN(23));
InstallMethod(IsSubgroupSL,"determinant test for generators",[IsMatrixGroup and HasGeneratorsOfGroup],COM_FUN(24));
InstallMethod(\in,"respecting bilinear form",IsElmsColls,[IsMatrix,IsFullSubgroupGLorSLRespectingBilinearForm],NICE_FLAGS,COM_FUN(25));
InstallMethod(\in,"respecting sesquilinear form",IsElmsColls,[IsMatrix,IsFullSubgroupGLorSLRespectingSesquilinearForm],NICE_FLAGS,COM_FUN(26));
InstallMethod(IsGeneratorsOfMagmaWithInverses,"for a list of matrices",[IsRingElementCollCollColl],COM_FUN(27));
InstallMethod(GroupWithGenerators,"list of matrices",[IsFFECollCollColl],COM_FUN(28));
InstallMethod(GroupWithGenerators,"list of matrices with identity",IsCollsElms,[IsFFECollCollColl,IsMultiplicativeElementWithInverse and IsFFECollColl],COM_FUN(29));
InstallMethod(IsConjugatorIsomorphism,"for a matrix group general mapping",[IsGroupGeneralMapping],1,COM_FUN(30));
InstallGlobalFunction(AffineActionByMatrixGroup,COM_FUN(31));
DeclareFilter("IsBlowUpIsomorphism",IsSPGeneralMapping and IsBijective);
InstallMethod(ImagesRepresentative,"for a blow up isomorphism, and a matrix in the source",FamSourceEqFamElm,[IsBlowUpIsomorphism,IsMatrix],COM_FUN(32));
InstallMethod(PreImagesRepresentative,"for a blow up isomorphism, and a matrix in the range",FamRangeEqFamElm,[IsBlowUpIsomorphism,IsMatrix],COM_FUN(33));
InstallGlobalFunction("BlowUpIsomorphism",COM_FUN(34));
InstallMethod(InvariantBilinearForm,"for a matrix group with known `InvariantQuadraticForm'",[IsMatrixGroup and HasInvariantQuadraticForm],COM_FUN(35));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grpmat.gi"

#F  file="lib/grpffmat.gi" crc=109461765
RANK_FILTER_LIST  := [ 22893809, 34, 57928553, 19, 22882649, 242, 22882649, 
  242, 22882649, 242, 64825629, 246, 22882499, 248, 58412696, 30, 64825629, 
  246, 58412696, 30, 22882499, 248, 64825629, 246, 22882499, 248, 64825629, 
  246, 22882499, 248, 28484709, 243, 53650458, 245, 58250155, 241, 4810329, 
  243 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grpffmat.gi", 109461765 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grpffmat.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grpffmat.gi");
elif COM_RESULT = 3  then
Revision.grpffmat_gi:="@(#)$Id: grpffmat.gi,v 4.45 2003/05/30 08:26:14 gap Exp $";
InstallMethod(FieldOfMatrixGroup,true,[IsFFEMatrixGroup],0,COM_FUN(1));
InstallMethod(FieldOfMatrixList,"finite field matrices",true,[IsListOrCollection and IsFFECollCollColl],0,COM_FUN(2));
InstallMethod(IsNaturalGL,"size comparison",true,[IsFFEMatrixGroup and IsFinite],0,COM_FUN(3));
InstallMethod(IsNaturalSL,"size comparison",true,[IsFFEMatrixGroup and IsFinite],0,COM_FUN(4));
InstallGlobalFunction(NicomorphismOfFFEMatrixGroup,COM_FUN(5));
InstallMethod(NiceMonomorphism,"falling back on GL",true,[IsFFEMatrixGroup and IsFinite],0,COM_FUN(6));
InstallGlobalFunction(ProjectiveActionOnFullSpace,COM_FUN(7));
InstallMethod(Size,"general linear group",true,[IsFFEMatrixGroup and IsFinite and IsNaturalGL],0,COM_FUN(8));
InstallMethod(Size,"natural SL",true,[IsFFEMatrixGroup and IsNaturalSL and IsFinite],0,COM_FUN(9));
InstallMethod(\in,"general linear group",IsElmsColls,[IsMatrix,IsFFEMatrixGroup and IsFinite and IsNaturalGL],0,COM_FUN(10));
InstallMethod(\in,"special linear group",IsElmsColls,[IsMatrix,IsFFEMatrixGroup and IsFinite and IsNaturalSL],0,COM_FUN(11));
SizePolynomialUnipotentClassGL:=COM_FUN(12);
InstallGlobalFunction(ConjugacyClassesOfNaturalGroup,COM_FUN(13));
InstallMethod(ConjugacyClasses,"for natural gl",true,[IsFFEMatrixGroup and IsFinite and IsNaturalGL],0,COM_FUN(14));
InstallMethod(ConjugacyClasses,"for natural sl",true,[IsFFEMatrixGroup and IsFinite and IsNaturalSL],0,COM_FUN(15));
InstallMethod(Random,"for natural GL",true,[IsFFEMatrixGroup and IsFinite and IsNaturalGL],0,COM_FUN(16));
InstallMethod(Random,"for natural SL",true,[IsFFEMatrixGroup and IsFinite and IsNaturalSL],0,COM_FUN(17));
InstallGlobalFunction(Phi2,COM_FUN(18));
InstallGlobalFunction(NrConjugacyClassesGL,COM_FUN(19));
InstallGlobalFunction(NrConjugacyClassesSLIsogeneous,COM_FUN(20));
InstallGlobalFunction(NrConjugacyClassesSL,COM_FUN(21));
InstallGlobalFunction(NrConjugacyClassesPGL,COM_FUN(22));
InstallGlobalFunction(NrConjugacyClassesPSL,COM_FUN(23));
InstallGlobalFunction(NrConjugacyClassesGU,COM_FUN(24));
InstallGlobalFunction(NrConjugacyClassesSUIsogeneous,COM_FUN(25));
InstallGlobalFunction(NrConjugacyClassesSU,COM_FUN(26));
InstallGlobalFunction(NrConjugacyClassesPGU,COM_FUN(27));
InstallGlobalFunction(NrConjugacyClassesPSU,COM_FUN(28));
InstallMethod(NrConjugacyClasses,"for natural GL",true,[IsGroup and IsFinite and IsNaturalGL],0,COM_FUN(29));
InstallMethod(NrConjugacyClasses,"for natural SL",true,[IsGroup and IsFinite and IsNaturalSL],0,COM_FUN(30));
InstallMethod(NrConjugacyClasses,"for GU(n,q)",true,[IsGroup and IsFinite and IsFullSubgroupGLorSLRespectingSesquilinearForm],0,COM_FUN(31));
InstallMethod(NrConjugacyClasses,"for natural SU",true,[IsGroup and IsFinite and IsFullSubgroupGLorSLRespectingSesquilinearForm and IsSubgroupSL],0,COM_FUN(32));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grpffmat.gi"

#F  file="lib/grpramat.gi" crc=40188293
RANK_FILTER_LIST  := [ 62261318, 34, 62261318, 34, 36137368, 31, 36137368, 
  31, 26708926, 42, 62261318, 34, 26708926, 42, 62261318, 34, 62261318, 34, 
  62261318, 34, 62261318, 34, 51874825, 38, 62261318, 34, 62261318, 34, 
  62261318, 34, 62261318, 34, 58412696, 30, 62261318, 34, 62261318, 34, 
  62261318, 34, 62261318, 34, 62261318, 34, 62261318, 34, 62261318, 34, 
  62261318, 34, 62261318, 34, 62261318, 34, 62261318, 34, 62261318, 34, 1, 0, 
  62261318, 34, 1, 0, 62261318, 34, 52247917, 19, 62261318, 34, 62261318, 34, 
  62261318, 34 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grpramat.gi", 40188293 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grpramat.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grpramat.gi");
elif COM_RESULT = 3  then
Revision.grpramat_gi:="@(#)$Id: grpramat.gi,v 4.25 2003/07/31 17:17:17 gap Exp $";
InstallMethod(IsRationalMatrixGroup,[IsCyclotomicMatrixGroup],COM_FUN(1));
InstallTrueMethod(IsRationalMatrixGroup,IsIntegerMatrixGroup);
InstallMethod(IsIntegerMatrixGroup,[IsCyclotomicMatrixGroup],COM_FUN(2));
InstallMethod(GeneralLinearGroupCons,"some generators for GL_n(Z)",[IsMatrixGroup,IsPosInt,IsIntegers],COM_FUN(3));
InstallMethod(SpecialLinearGroupCons,"some generators for SL_n(Z)",[IsMatrixGroup,IsPosInt,IsIntegers],COM_FUN(4));
InstallMethod(NormalizerOp,IsIdenticalObj,[IsNaturalGLnZ,IsCyclotomicMatrixGroup],COM_FUN(5));
InstallMethod(CentralizerOp,IsIdenticalObj,[IsNaturalGLnZ,IsCyclotomicMatrixGroup],COM_FUN(6));
InstallValue(CrystGroupDefaultAction,RightAction);
InstallGlobalFunction(SetCrystGroupDefaultAction,COM_FUN(7));
InstallMethod(IsBravaisGroup,[IsCyclotomicMatrixGroup],COM_FUN(8));
InstallMethod(InvariantLattice,"for rational matrix groups",[IsCyclotomicMatrixGroup],COM_FUN(9));
InstallMethod(IsFinite,"cyclotomic matrix group",[IsCyclotomicMatrixGroup],COM_FUN(10));
InstallMethod(IsFinite,"via Minkowski kernel (short but not too efficient)",[IsIntegerMatrixGroup],COM_FUN(11));
InstallMethod(Size,"cyclotomic matrix group not known to be finite",[IsCyclotomicMatrixGroup],COM_FUN(12));
InstallMethod(NiceMonomorphism,"for a (nonrational) cyclotomic matrix group",[IsCyclotomicMatrixGroup],COM_FUN(13));
InstallMethod(IsHandledByNiceMonomorphism,"for a cyclotomic matrix group",[IsCyclotomicMatrixGroup],IsFinite);
InstallMethod(IsomorphismPermGroup,"cyclotomic matrix group",[IsCyclotomicMatrixGroup],10,COM_FUN(14));
RedispatchOnCondition(\in,true,[IsMatrix,IsCyclotomicMatrixGroup],[IsObject,IsFinite],0);
RedispatchOnCondition(\=,IsIdenticalObj,[IsCyclotomicMatrixGroup,IsCyclotomicMatrixGroup],[IsFinite,IsFinite],0);
RedispatchOnCondition(IndexOp,IsIdenticalObj,[IsCyclotomicMatrixGroup,IsCyclotomicMatrixGroup],[IsFinite,IsFinite],0);
RedispatchOnCondition(IndexNC,IsIdenticalObj,[IsCyclotomicMatrixGroup,IsCyclotomicMatrixGroup],[IsFinite,IsFinite],0);
RedispatchOnCondition(NormalizerOp,IsIdenticalObj,[IsCyclotomicMatrixGroup,IsCyclotomicMatrixGroup],[IsFinite,IsFinite],0);
RedispatchOnCondition(NormalClosureOp,IsIdenticalObj,[IsCyclotomicMatrixGroup,IsCyclotomicMatrixGroup],[IsFinite,IsFinite],0);
RedispatchOnCondition(CentralizerOp,true,[IsCyclotomicMatrixGroup,IsObject],[IsFinite],0);
RedispatchOnCondition(ClosureGroup,true,[IsCyclotomicMatrixGroup,IsObject],[IsFinite],0);
RedispatchOnCondition(SylowSubgroupOp,true,[IsCyclotomicMatrixGroup,IsPosInt],[IsFinite],0);
RedispatchOnCondition(ConjugacyClasses,true,[IsCyclotomicMatrixGroup],[IsFinite],0);
RedispatchOnCondition(IsomorphismPcGroup,true,[IsCyclotomicMatrixGroup],[IsFinite],0);
RedispatchOnCondition(CompositionSeries,true,[IsCyclotomicMatrixGroup],[IsFinite],0);
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grpramat.gi"

#F  file="lib/grpfp.gi" crc=39425900
RANK_FILTER_LIST  := [ 27273315, 2, 45943350, 7, 26656748, 9, 26656748, 9, 
  26656748, 9, 26656748, 9, 26656748, 9, 26656748, 9, 26656748, 9, 25640940, 
  7, 27273315, 2, 25640940, 7, 25640940, 7, 25640940, 7, 25640940, 7, 
  25640940, 7, 25640940, 7, 25640940, 7, 25640940, 7, 27273315, 2, 27273315, 
  2, 27273315, 2, 27273315, 2, 27273315, 2, 25640940, 7, 1015809, 2, 
  26193897, 16, 8193, 2, 25640940, 7, 58923477, 23, 65767820, 5, 58923477, 
  23, 65767820, 5, 32042524, 24, 58923477, 23, 58923477, 23, 58923477, 23, 
  7450445, 24, 32042524, 24, 32042524, 24, 58923477, 23, 58923477, 23, 
  58909558, 26, 58923477, 23, 58909558, 26, 32042524, 24, 58923477, 23, 
  66358293, 24, 66358293, 24, 58923477, 23, 58923477, 23, 66358293, 24, 
  58923477, 23, 66358293, 24, 58923477, 23, 66358293, 24, 58923477, 23, 
  58923477, 23, 58923477, 23, 22591567, 24, 40757522, 24, 40227927, 24, 
  58923477, 23, 66358293, 24, 23118868, 30, 8126465, 2, 23118868, 30, 
  41942876, 3, 66358293, 24, 58923477, 23, 66358293, 24, 58923477, 23, 
  58923477, 23, 58909558, 26, 58923477, 23, 39302389, 22, 39302389, 22, 
  53647849, 23, 39302389, 22, 53647849, 23, 30163350, 22, 58923477, 23, 
  58909558, 26, 35426019, 25, 65767820, 5, 32042524, 24, 65767820, 5, 
  58923477, 23, 40227927, 24, 58923477, 23, 58923477, 23, 58923477, 23, 
  32042524, 24, 58923477, 23, 58923477, 23, 32042524, 24, 32042524, 24, 
  47130778, 25, 65767820, 5, 50514273, 26, 65767820, 5, 6902852, 24, 
  58923477, 23, 58923477, 23, 8193, 2, 66358293, 24, 58914239, 30, 66358293, 
  24, 53660808, 21, 53660808, 21, 45271600, 33, 67108760, 5, 34781414, 38, 
  67108760, 5, 18265952, 35, 67108760, 5, 45271600, 33, 67108760, 5, 
  45271600, 33, 8193, 2, 67108760, 5, 53660808, 21, 8193, 2, 67108760, 5, 
  45271600, 33, 8193, 2, 67108760, 5, 45271600, 33, 8193, 2, 58909558, 26, 
  58923477, 23, 52247917, 19, 58909558, 26, 58923477, 23, 52247917, 19, 8193, 
  2, 58923477, 23, 52247917, 19, 58923477, 23, 58923477, 23, 52247917, 19, 
  58923477, 23, 58923477, 23, 32042524, 24, 32042524, 24, 58909558, 26, 
  32042524, 24, 66358293, 24, 66358293, 24, 66358293, 24, 58923477, 23, 
  12785623, 24, 53650608, 26, 52910221, 24, 27273315, 2, 66358293, 24, 
  58923477, 23, 58923477, 23, 58923477, 23, 58923477, 23, 32042524, 24, 
  58923477, 23, 58923477, 23, 58923477, 23, 58909558, 26, 53650608, 26, 
  58923477, 23, 53650608, 26, 66358293, 24, 66358293, 24, 58923477, 23, 
  66358293, 24, 66358293, 24, 58909558, 26, 58923477, 23, 58923477, 23, 
  58909558, 26, 58923477, 23, 58923477, 23, 58909558, 26, 58923477, 23, 
  58923477, 23, 58923477, 23, 58923477, 23, 20455065, 10, 52247917, 19, 
  20455065, 10, 65767820, 5 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grpfp.gi", 39425900 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grpfp.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grpfp.gi");
elif COM_RESULT = 3  then
Revision.grpfp_gi:="@(#)$Id: grpfp.gi,v 4.203.2.6 2005/02/21 20:31:17 gap Exp $";
InstallMethod(ElementOfFpGroup,"for a family of f.p. group elements, and an assoc. word",true,[IsElementOfFpGroupFamily,IsAssocWordWithInverse],0,COM_FUN(1));
InstallMethod(PrintObj,"for an element of an f.p. group (default repres.)",true,[IsElementOfFpGroup and IsPackedElementDefaultRep],0,COM_FUN(2));
InstallMethod(ViewObj,"for an element of an f.p. group (default repres.)",true,[IsElementOfFpGroup and IsPackedElementDefaultRep],0,COM_FUN(3));
InstallMethod(String,"for an element of an f.p. group (default repres.)",true,[IsElementOfFpGroup and IsPackedElementDefaultRep],0,COM_FUN(4));
InstallMethod(LaTeXObj,"for an element of an f.p. group (default repres.)",true,[IsElementOfFpGroup and IsPackedElementDefaultRep],0,COM_FUN(5));
InstallMethod(UnderlyingElement,"for an element of an f.p. group (default repres.)",true,[IsElementOfFpGroup and IsPackedElementDefaultRep],0,COM_FUN(6));
InstallMethod(ExtRepOfObj,"for an element of an f.p. group (default repres.)",true,[IsElementOfFpGroup and IsPackedElementDefaultRep],0,COM_FUN(7));
InstallOtherMethod(Length,"for an element of an f.p. group (default repres.)",true,[IsElementOfFpGroup and IsPackedElementDefaultRep],0,COM_FUN(8));
InstallMethod(InverseOp,"for an element of an f.p. group",true,[IsElementOfFpGroup],0,COM_FUN(9));
InstallOtherMethod(One,"for a family of f.p. group elements",true,[IsElementOfFpGroupFamily],0,COM_FUN(10));
InstallMethod(One,"for an f.p. group element",true,[IsElementOfFpGroup],0,COM_FUN(11));
InstallMethod(OneOp,"for an f.p. group element",true,[IsElementOfFpGroup],0,COM_FUN(12));
InstallGlobalFunction(SetReducedMultiplication,COM_FUN(13));
BindGlobal("Gpword2MSword",COM_FUN(14));
BindGlobal("MSword2gpword",COM_FUN(15));
InstallMethod(\*,"for two f.p. group elements",IsIdenticalObj,[IsElementOfFpGroup,IsElementOfFpGroup],0,COM_FUN(16));
InstallMethod(\=,"for two f.p. group elements",IsIdenticalObj,[IsElementOfFpGroup,IsElementOfFpGroup],0,COM_FUN(17));
InstallMethod(\<,"for two f.p. group elements",IsIdenticalObj,[IsElementOfFpGroup,IsElementOfFpGroup],0,COM_FUN(18));
InstallMethod(FpElmEqualityMethod,"via perm rep.",true,[IsElementOfFpGroupFamily],1,COM_FUN(19));
InstallMethod(FpElmComparisonMethod,"via perm rep.",true,[IsElementOfFpGroupFamily],1,COM_FUN(20));
InstallMethod(FpElmKBRWS,"via Knuth-Bendix",true,[IsElementOfFpGroupFamily],0,COM_FUN(21));
InstallMethod(FpElmEqualityMethod,"via Knuth-Bendix",true,[IsElementOfFpGroupFamily],0,COM_FUN(22));
InstallMethod(FpElmComparisonMethod,"via Knuth-Bendix",true,[IsElementOfFpGroupFamily],0,COM_FUN(23));
InstallMethod(Order,"fp group element",[IsElementOfFpGroup],0,COM_FUN(24));
InstallOtherMethod(MappedWord,"for fp group element",IsElmsCollsX,[IsPackedElementDefaultRep,IsElementOfFpGroupCollection and IsList,IsList],0,COM_FUN(25));
InstallMethod(FpGrpMonSmgOfFpGrpMonSmgElement,"for an element of an fp group",true,[IsElementOfFpGroup],0,COM_FUN(26));
InstallGlobalFunction(IndexCosetTab,COM_FUN(27));
InstallMethod(PseudoRandom,"subgroups fp group: force generators",true,[IsSubgroupFpGroup],0,COM_FUN(28));
InstallGlobalFunction(SubgroupOfWholeGroupByCosetTable,COM_FUN(29));
InstallGlobalFunction(SubgroupOfWholeGroupByQuotientSubgroup,COM_FUN(30));
InstallGlobalFunction(TracedCosetFpGroup,COM_FUN(31));
InstallMethod(\in,"subgroup of fp group",IsElmsColls,[IsMultiplicativeElementWithInverse,IsSubgroupFpGroup],0,COM_FUN(32));
InstallMethod(\in,"subgroup of fp group by quotient rep",IsElmsColls,[IsMultiplicativeElementWithInverse,IsSubgroupFpGroup and IsSubgroupOfWholeGroupByQuotientRep],0,COM_FUN(33));
InstallMethod(\=,"subgroups of fp group",IsIdenticalObj,[IsSubgroupFpGroup,IsSubgroupFpGroup],0,COM_FUN(34));
InstallMethod(IsSubset,"subgroups of fp group: test generators",IsIdenticalObj,[IsSubgroupFpGroup,IsSubgroupFpGroup and HasGeneratorsOfGroup],0,COM_FUN(35));
InstallMethod(IsSubset,"subgroups of fp group by quot. rep",IsIdenticalObj,[IsSubgroupFpGroup and IsSubgroupOfWholeGroupByQuotientRep,IsSubgroupFpGroup and IsSubgroupOfWholeGroupByQuotientRep],0,COM_FUN(36));
InstallMethod(IsSubset,"subgp fp group: via quotient rep",IsIdenticalObj,[IsSubgroupFpGroup,IsSubgroupFpGroup],0,COM_FUN(37));
InstallMethod(CanComputeIsSubset,"whole fp family group",IsIdenticalObj,[IsSubgroupFpGroup and IsWholeFamily,IsSubgroupFpGroup],0,COM_FUN(38));
InstallMethod(IsNormalOp,"subgroups of fp group by quot. rep in full fp grp.",IsIdenticalObj,[IsSubgroupFpGroup and IsWholeFamily,IsSubgroupFpGroup and IsSubgroupOfWholeGroupByQuotientRep],0,COM_FUN(39));
InstallMethod(IsFinitelyGeneratedGroup,"subgroups of fp group",true,[IsSubgroupFpGroup],0,COM_FUN(40));
InstallMethod(GeneratorsOfGroup,"for whole family f.p. group",true,[IsSubgroupFpGroup and IsGroupOfFamily],0,COM_FUN(41));
InstallMethod(AbelianInvariants,"for a finitely presented group",true,[IsSubgroupFpGroup and IsGroupOfFamily],0,COM_FUN(42));
InstallMethod(AbelianInvariants,"for a subgroup of a finitely presented group",true,[IsSubgroupFpGroup],0,COM_FUN(43));
InstallMethod(IsPerfectGroup,"for a (subgroup of a) finitely presented group",true,[IsSubgroupFpGroup],0,COM_FUN(44));
InstallMethod(DerivedSubgroup,"for a finitely presented group",true,[IsSubgroupFpGroup and IsGroupOfFamily],0,COM_FUN(45));
InstallMethod(DerivedSubgroup,"subgroup of a finitely presented group",true,[IsSubgroupFpGroup],0,COM_FUN(46));
InstallMethod(CosetTable,"for finitely presented groups",true,[IsSubgroupFpGroup and IsGroupOfFamily,IsSubgroupFpGroup],0,COM_FUN(47));
InstallMethod(CosetTableNormalClosure,"for finitely presented groups",true,[IsSubgroupFpGroup and IsGroupOfFamily,IsSubgroupFpGroup],0,COM_FUN(48));
InstallGlobalFunction(CosetTableFromGensAndRels,COM_FUN(49));
BindGlobal("GTC_CosetTableFromGensAndRels",COM_FUN(50));
GAPTCENUM.CosetTableFromGensAndRels:=GTC_CosetTableFromGensAndRels;
InstallMethod(TryCosetTableInWholeGroup,"for finitely presented groups",true,[IsSubgroupFpGroup],0,COM_FUN(51));
InstallMethod(CosetTableInWholeGroup,"for finitely presented groups",true,[IsSubgroupFpGroup],0,COM_FUN(52));
InstallMethod(CosetTableInWholeGroup,"from augmented table Rrs",true,[IsSubgroupFpGroup and HasAugmentedCosetTableRrsInWholeGroup],0,COM_FUN(53));
InstallMethod(CosetTableInWholeGroup,"from augmented table Mtc",true,[IsSubgroupFpGroup and HasAugmentedCosetTableMtcInWholeGroup],0,COM_FUN(54));
InstallMethod(CosetTableInWholeGroup,"ByQuoSubRep",true,[IsSubgroupOfWholeGroupByQuotientRep],0,COM_FUN(55));
InstallMethod(CosetTableNormalClosureInWholeGroup,"for finitely presented groups",true,[IsSubgroupFpGroup],0,COM_FUN(56));
InstallGlobalFunction(StandardizeTable,COM_FUN(57));
InstallGlobalFunction(StandardizeTable2,COM_FUN(58));
InstallMethod(Display,"for finitely presented groups",true,[IsSubgroupFpGroup and IsGroupOfFamily],0,COM_FUN(59));
InstallGlobalFunction(FactorGroupFpGroupByRels,COM_FUN(60));
BindGlobal("FactorFreeGroupByRelators",COM_FUN(61));
InstallOtherMethod(\/,"for free groups and relators",IsIdenticalObj,[IsFreeGroup,IsCollection],0,FactorFreeGroupByRelators);
InstallOtherMethod(\/,"for a free group and an empty list of relators",true,[IsFreeGroup,IsEmpty],0,FactorFreeGroupByRelators);
InstallMethod(FreeGeneratorsOfFpGroup,"for a finitely presented group",true,[IsSubgroupFpGroup and IsGroupOfFamily],0,COM_FUN(62));
InstallMethod(FreeGeneratorsOfWholeGroup,"for a finitely presented group",true,[IsSubgroupFpGroup],0,COM_FUN(63));
InstallMethod(FreeGroupOfFpGroup,"for a finitely presented group",true,[IsSubgroupFpGroup and IsGroupOfFamily],0,COM_FUN(64));
InstallMethod(IndexNC,"for finitely presented groups",[IsSubgroupFpGroup,IsSubgroupFpGroup],COM_FUN(65));
InstallMethod(IndexOp,"for finitely presented group in whole group",IsIdenticalObj,[IsSubgroupFpGroup and IsWholeFamily,IsSubgroupFpGroup],COM_FUN(66));
InstallMethod(CanComputeIndex,"subgroups fp groups",IsIdenticalObj,[IsGroup and HasIndexInWholeGroup,IsGroup and HasIndexInWholeGroup],ReturnTrue);
InstallMethod(CanComputeIndex,"subgroup of full fp groups",IsIdenticalObj,[IsGroup and IsWholeFamily,IsGroup and HasIndexInWholeGroup],ReturnTrue);
InstallMethod(CanComputeIndex,"subgroup of full fp groups",IsIdenticalObj,[IsGroup and IsWholeFamily,IsGroup and HasCosetTableInWholeGroup],ReturnTrue);
InstallMethod(IndexInWholeGroup,"for subgroups of fp groups",[IsSubgroupFpGroup],COM_FUN(67));
InstallMethod(IndexInWholeGroup,"for full fp group",[IsSubgroupFpGroup and IsWholeFamily],COM_FUN(68));
InstallMethod(ConjugateGroup,"subgroups of fp group with coset table",IsCollsElms,[IsSubgroupFpGroup and HasCosetTableInWholeGroup,IsMultiplicativeElementWithInverse],0,COM_FUN(69));
InstallMethod(ConjugateGroup,"subgroups of fp group by quotient",IsCollsElms,[IsSubgroupFpGroup and IsSubgroupOfWholeGroupByQuotientRep,IsMultiplicativeElementWithInverse],0,COM_FUN(70));
InstallMethod(AsSubgroupOfWholeGroupByQuotient,"create",true,[IsSubgroupFpGroup],0,COM_FUN(71));
InstallMethod(AsSubgroupOfWholeGroupByQuotient,"is already",true,[IsSubgroupOfWholeGroupByQuotientRep],0,COM_FUN(72));
InstallGlobalFunction(DefiningQuotientHomomorphism,COM_FUN(73));
InstallMethod(CoreOp,"subgroups of fp group: use quotient rep",IsIdenticalObj,[IsSubgroupFpGroup,IsSubgroupFpGroup],0,COM_FUN(74));
InstallMethod(CoreOp,"subgroups of fp group by quotient",IsIdenticalObj,[IsSubgroupFpGroup,IsSubgroupFpGroup and IsSubgroupOfWholeGroupByQuotientRep],0,COM_FUN(75));
InstallMethod(Intersection2,"subgroups of fp group",IsIdenticalObj,[IsSubgroupFpGroup,IsSubgroupFpGroup],0,COM_FUN(76));
InstallMethod(Intersection2,"subgroups of fp group by quotient",IsIdenticalObj,[IsSubgroupFpGroup and IsSubgroupOfWholeGroupByQuotientRep,IsSubgroupFpGroup and IsSubgroupOfWholeGroupByQuotientRep],0,COM_FUN(77));
InstallMethod(ClosureGroup,"subgrp fp: by quotient subgroup",IsCollsElms,[IsSubgroupFpGroup and HasParent and IsSubgroupOfWholeGroupByQuotientRep,IsMultiplicativeElementWithInverse],0,COM_FUN(78));
InstallMethod(ClosureGroup,"subgrp fp: Has coset table",IsCollsElms,[IsSubgroupFpGroup and HasParent and HasCosetTableInWholeGroup,IsMultiplicativeElementWithInverse],0,COM_FUN(79));
InstallMethod(ClosureGroup,"for subgroup of fp group, and subgroup",IsIdenticalObj,[IsSubgroupFpGroup and HasParent,IsSubgroupFpGroup],0,COM_FUN(80));
InstallMethod(KnowsHowToDecompose,"fp groups: Say yes if finite index",IsIdenticalObj,[IsSubgroupFpGroup,IsList],0,COM_FUN(81));
InstallMethod(IsAbelian,"for finitely presented groups",true,[IsSubgroupFpGroup and IsGroupOfFamily],0,COM_FUN(82));
InstallMethod(IsAbelian,"finite fp grp",true,[IsSubgroupFpGroup and HasSize and IsFinite],0,COM_FUN(83));
InstallMethod(IsTrivial,"for finitely presented groups",true,[IsSubgroupFpGroup and IsGroupOfFamily],0,COM_FUN(84));
InstallOtherMethod(IsomorphismFpGroup,"supply name",true,[IsGroup],0,COM_FUN(85));
InstallGlobalFunction(IsomorphismFpGroupByGenerators,COM_FUN(86));
InstallOtherMethod(IsomorphismFpGroupByCompositionSeries,"supply name",true,[IsGroup],0,COM_FUN(87));
InstallOtherMethod(IsomorphismFpGroup,"for perm groups",true,[IsPermGroup,IsString],0,COM_FUN(88));
InstallOtherMethod(IsomorphismFpGroup,"for simple solvable permutation groups",true,[IsPermGroup and IsSimpleGroup and IsSolvableGroup,IsString],0,COM_FUN(89));
InstallOtherMethod(IsomorphismFpGroup,"for simple permutation groups",true,[IsPermGroup and IsSimpleGroup,IsString],0,COM_FUN(90));
InstallOtherMethod(IsomorphismFpGroupByCompositionSeries,"for permutation groups",true,[IsPermGroup,IsString],0,COM_FUN(91));
InstallOtherMethod(IsomorphismFpGroupByGeneratorsNC,"for perm groups",IsFamFamX,[IsPermGroup,IsList,IsString],0,COM_FUN(92));
InstallMethod(IsomorphismFpGroupByGeneratorsNC,"via cokernel",IsFamFamX,[IsGroup,IsList,IsString],0,COM_FUN(93));
InstallMethod(IsomorphismFpGroupBySubnormalSeries,"for groups",true,[IsPermGroup,IsList,IsString],0,COM_FUN(94));
InstallOtherMethod(IsomorphismFpGroupBySubnormalSeries,"for groups",true,[IsPermGroup,IsList],0,COM_FUN(95));
BindGlobal("DoLowIndexSubgroupsFpGroup",COM_FUN(96));
InstallMethod(LowIndexSubgroupsFpGroup,"subgroups of full fp group",IsFamFamX,[IsSubgroupFpGroup and IsWholeFamily,IsSubgroupFpGroup,IsPosInt],0,DoLowIndexSubgroupsFpGroup);
InstallOtherMethod(LowIndexSubgroupsFpGroup,"subgroups of full fp group, with exclusion list",IsFamFamXY,[IsSubgroupFpGroup and IsWholeFamily,IsSubgroupFpGroup,IsPosInt,IsList],0,DoLowIndexSubgroupsFpGroup);
InstallOtherMethod(LowIndexSubgroupsFpGroup,"supply trivial subgroup",true,[IsSubgroupFpGroup,IsPosInt],0,COM_FUN(97));
InstallMethod(LowIndexSubgroupsFpGroup,"subgroups of fp group",IsFamFamX,[IsSubgroupFpGroup,IsSubgroupFpGroup,IsPosInt],0,COM_FUN(98));
InstallMethod(NormalizerOp,"subgroups of fp group: find stabilizing cosets",IsIdenticalObj,[IsSubgroupFpGroup,IsSubgroupFpGroup],0,COM_FUN(99));
InstallMethod(NormalizerOp,"subgroups of fp group by quot. rep",IsIdenticalObj,[IsSubgroupFpGroup and IsSubgroupOfWholeGroupByQuotientRep,IsSubgroupFpGroup and IsSubgroupOfWholeGroupByQuotientRep],0,COM_FUN(100));
InstallMethod(NormalizerOp,"in whole group by quot. rep",IsIdenticalObj,[IsSubgroupFpGroup and IsWholeFamily,IsSubgroupFpGroup and IsSubgroupOfWholeGroupByQuotientRep],0,COM_FUN(101));
InstallGlobalFunction(MostFrequentGeneratorFpGroup,COM_FUN(102));
InstallGlobalFunction(RelatorRepresentatives,COM_FUN(103));
InstallMethod(RelatorsOfFpGroup,"for finitely presented group",true,[IsSubgroupFpGroup and IsGroupOfFamily],0,COM_FUN(104));
InstallMethod(IndicesInvolutaryGenerators,"for finitely presented group",true,[IsSubgroupFpGroup and IsGroupOfFamily],0,COM_FUN(105));
InstallGlobalFunction(RelsSortedByStartGen,COM_FUN(106));
BindGlobal("FinIndexCyclicSubgroupGenerator",COM_FUN(107));
InstallMethod(Size,"for finitely presented groups",true,[IsSubgroupFpGroup and IsGroupOfFamily],0,COM_FUN(108));
InstallMethod(Size,"subgroups of finitely presented groups",true,[IsSubgroupFpGroup],0,COM_FUN(109));
InstallMethod(Size,"infinite abelianization",true,[IsSubgroupFpGroup and HasAbelianInvariants],0,COM_FUN(110));
InstallGlobalFunction(IsomorphismPermGroupOrFailFpGroup,COM_FUN(111));
InstallMethod(IsomorphismPermGroup,"for full finitely presented groups",true,[IsGroup and IsSubgroupFpGroup and IsGroupOfFamily],RankFilter(IsFinite and IsGroup),COM_FUN(112));
InstallOtherMethod(IsomorphismPermGroup,"for family of fp words",true,[IsElementOfFpGroupFamily],0,COM_FUN(113));
InstallMethod(FactorCosetAction,"for full fp group on subgroup",IsIdenticalObj,[IsSubgroupFpGroup and IsGroupOfFamily,IsSubgroupFpGroup],5,COM_FUN(114));
InstallMethod(FactorCosetAction,"for subgroups of an fp group",IsIdenticalObj,[IsSubgroupFpGroup,IsSubgroupFpGroup],0,COM_FUN(115));
InstallMethod(FactorCosetAction,"subgrp in quotient Rep",IsIdenticalObj,[IsSubgroupFpGroup,IsSubgroupFpGroup and IsSubgroupOfWholeGroupByQuotientRep],0,COM_FUN(116));
InstallGlobalFunction(SubgroupGeneratorsCosetTable,COM_FUN(117));
InstallMethod(GeneratorsOfGroup,"subgroup fp, via augmented coset table",true,[IsSubgroupFpGroup],0,COM_FUN(118));
InstallMethod(IntermediateSubgroups,"fp group via quotient subgroups",IsIdenticalObj,[IsSubgroupFpGroup,IsSubgroupFpGroup],0,COM_FUN(119));
InstallMethod(GQuotients,"whole fp group to finite group",true,[IsSubgroupFpGroup and IsWholeFamily,IsGroup and IsFinite],1,COM_FUN(120));
InstallMethod(GQuotients,"subgroup of an fp group",true,[IsSubgroupFpGroup,IsGroup and IsFinite],1,COM_FUN(121));
InstallMethod(IsomorphismFpSemigroup,"for fp groups",true,[IsFpGroup],0,COM_FUN(122));
InstallMethod(IsomorphismFpMonoid,"for an fp group",true,[IsFpGroup],0,COM_FUN(123));
InstallMethod(ViewObj,"fp group",true,[IsSubgroupFpGroup],10,COM_FUN(124));
InstallMethod(StoredExcludedOrders,"fp group",true,[IsSubgroupFpGroup and IsGroupOfFamily],0,COM_FUN(125));
InstallGlobalFunction(ExcludedOrders,COM_FUN(126));
RedispatchOnCondition(CompositionSeries,true,[IsFpGroup],[IsFinite],0);
InstallMethod(NormalClosureOp,"whole fp group with normal subgroup",IsIdenticalObj,[IsSubgroupFpGroup and IsWholeFamily,IsSubgroupFpGroup],0,COM_FUN(127));
InstallMethod(LowerCentralSeriesOfGroup,"fp group",true,[IsSubgroupFpGroup],0,COM_FUN(128));
CoSuFp:=COM_FUN(129);
InstallMethod(CommutatorSubgroup,"whole fp group with normal subgroup",IsIdenticalObj,[IsSubgroupFpGroup and IsWholeFamily,IsSubgroupFpGroup],0,CoSuFp);
InstallMethod(CommutatorSubgroup,"normal subgroup with whole fp group",IsIdenticalObj,[IsSubgroupFpGroup,IsSubgroupFpGroup and IsWholeFamily],0,COM_FUN(130));
InstallMethod(CommutatorSubgroup,"normal subgroup with whole fp group",IsIdenticalObj,[IsSubgroupFpGroup,IsSubgroupFpGroup],0,COM_FUN(131));
DeclareRepresentation("IsRightTransversalFpGroupRep",IsRightTransversalRep,["group","subgroup","table","iso","reps"]);
InstallMethod(RightTransversalOp,"via coset table",IsIdenticalObj,[IsSubgroupFpGroup,IsSubgroupFpGroup],0,COM_FUN(132));
InstallMethod(\[\],"right transversal fp group",true,[IsList and IsRightTransversalFpGroupRep,IsPosInt],0,COM_FUN(133));
InstallMethod(PositionCanonical,"right transversal fp gp.",IsCollsElms,[IsList and IsRightTransversalFpGroupRep,IsMultiplicativeElementWithInverse],0,COM_FUN(134));
InstallGlobalFunction(NewmanInfinityCriterion,COM_FUN(135));
InstallGlobalFunction(FibonacciGroup,COM_FUN(136));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grpfp.gi"

#F  file="lib/sgpres.gi" crc=112275568
RANK_FILTER_LIST  := [ 58923477, 23, 58923477, 23, 40757522, 24, 58923477, 
  23, 66358293, 24, 58923477, 23, 53660808, 21, 53660808, 21, 58923477, 23, 
  58923477, 23, 29784823, 5, 52247917, 19, 29784823, 5, 52247917, 19, 
  29784824, 6, 52247917, 19, 1, 0, 29784824, 6, 52247917, 19 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/sgpres.gi", 112275568 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/sgpres.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/sgpres.gi");
elif COM_RESULT = 3  then
Revision.sgpres_gi:="@(#)$Id: sgpres.gi,v 4.61.2.1 2003/12/31 02:21:12 gap Exp $";
InstallGlobalFunction(AbelianInvariantsNormalClosureFpGroupRrs,COM_FUN(1));
InstallGlobalFunction(AbelianInvariantsSubgroupFpGroupMtc,COM_FUN(2));
InstallGlobalFunction(AbelianInvariantsSubgroupFpGroupRrs,COM_FUN(3));
InstallGlobalFunction(AugmentedCosetTableInWholeGroup,COM_FUN(4));
InstallMethod(AugmentedCosetTableMtcInWholeGroup,"subgroup of fp group",true,[IsSubgroupFpGroup],0,COM_FUN(5));
InstallMethod(AugmentedCosetTableRrsInWholeGroup,"subgroup of fp group",true,[IsSubgroupFpGroup],0,COM_FUN(6));
InstallMethod(AugmentedCosetTableRrsInWholeGroup,"use Mtc table",true,[IsSubgroupFpGroup and HasAugmentedCosetTableMtcInWholeGroup],0,AugmentedCosetTableMtcInWholeGroup);
InstallMethod(AugmentedCosetTableNormalClosureInWholeGroup,"subgroup of fp group",true,[IsSubgroupFpGroup],0,COM_FUN(7));
InstallGlobalFunction(AugmentedCosetTableMtc,COM_FUN(8));
InstallGlobalFunction(AugmentedCosetTableRrs,COM_FUN(9));
InstallMethod(AugmentedCosetTableNormalClosure,"for finitely presented groups",true,[IsSubgroupFpGroup and IsGroupOfFamily,IsSubgroupFpGroup],0,COM_FUN(10));
InstallMethod(CosetTableBySubgroup,"coset action",IsIdenticalObj,[IsGroup,IsGroup],0,COM_FUN(11));
InstallMethod(CosetTableBySubgroup,"use `CosetTableInWholeGroup",IsIdenticalObj,[IsSubgroupFpGroup,IsSubgroupFpGroup],0,COM_FUN(12));
InstallGlobalFunction(CanonicalRelator,COM_FUN(13));
InstallGlobalFunction(CheckCosetTableFpGroup,COM_FUN(14));
InstallGlobalFunction(IsStandardized,COM_FUN(15));
DeclareRepresentation("IsPresentationDefaultRep",IsComponentObjectRep and IsAttributeStoringRep,[]);
InstallMethod(\.,"for a presentation in default representation",true,[IsPresentation and IsPresentationDefaultRep,IsPosInt],0,COM_FUN(16));
InstallMethod(IsBound\.,"for a presentation in default representation",true,[IsPresentation and IsPresentationDefaultRep,IsPosInt],0,COM_FUN(17));
InstallMethod(\.\:\=,"for a mutable presentation in default representation",true,[IsPresentation and IsPresentationDefaultRep and IsMutable,IsPosInt,IsObject],0,COM_FUN(18));
InstallMethod(Unbind\.,"for a mutable presentation in default representation",true,[IsPresentation and IsPresentationDefaultRep and IsMutable,IsPosInt],0,COM_FUN(19));
InstallGlobalFunction(PresentationAugmentedCosetTable,COM_FUN(20));
InstallGlobalFunction(PresentationNormalClosureRrs,COM_FUN(21));
InstallGlobalFunction(PresentationSubgroupMtc,COM_FUN(22));
InstallGlobalFunction(PresentationSubgroupRrs,COM_FUN(23));
InstallGlobalFunction(ReducedRrsWord,COM_FUN(24));
InstallGlobalFunction(RelatorMatrixAbelianizedNormalClosureRrs,COM_FUN(25));
RelatorMatrixAbelianizedNormalClosure:=RelatorMatrixAbelianizedNormalClosureRrs;
InstallGlobalFunction(RelatorMatrixAbelianizedSubgroupMtc,COM_FUN(26));
InstallGlobalFunction(RelatorMatrixAbelianizedSubgroupRrs,COM_FUN(27));
InstallGlobalFunction(RenumberTree,COM_FUN(28));
InstallGlobalFunction(RewriteAbelianizedSubgroupRelators,COM_FUN(29));
InstallGlobalFunction(RewriteSubgroupRelators,COM_FUN(30));
InstallGlobalFunction(SortRelsSortedByStartGen,COM_FUN(31));
InstallGlobalFunction(SpanningTree,COM_FUN(32));
InstallGlobalFunction(RewriteWord,COM_FUN(33));
InstallGlobalFunction(DecodedTreeEntry,COM_FUN(34));
InstallGlobalFunction(GeneratorTranslationAugmentedCosetTable,COM_FUN(35));
InstallGlobalFunction(SecondaryGeneratorWordsAugmentedCosetTable,COM_FUN(36));
InstallGlobalFunction(CopiedAugmentedCosetTable,COM_FUN(37));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/sgpres.gi"

#F  file="lib/tietze.gi" crc=65017620
RANK_FILTER_LIST  := [ 29784823, 5, 29784823, 5, 55999958, 2 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/tietze.gi", 65017620 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/tietze.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/tietze.gi");
elif COM_RESULT = 3  then
Revision.tietze_gi:="@(#)$Id: tietze.gi,v 4.58 2002/04/15 10:05:24 sal Exp $";
TzTestInitialSetup:=COM_FUN(1);
InstallGlobalFunction(AddGenerator,COM_FUN(2));
InstallGlobalFunction(AddRelator,COM_FUN(3));
InstallGlobalFunction(DecodeTree,COM_FUN(4));
InstallGlobalFunction(FpGroupPresentation,COM_FUN(5));
InstallGlobalFunction(PresentationFpGroup,COM_FUN(6));
InstallMethod(PrintObj,"for a presentation in default representation",true,[IsPresentation and IsPresentationDefaultRep],0,COM_FUN(7));
InstallMethod(ShallowCopy,"for a presentation in default representation",true,[IsPresentation and IsPresentationDefaultRep],0,StructuralCopy);
InstallGlobalFunction(PresentationRegularPermutationGroup,COM_FUN(8));
InstallGlobalFunction(PresentationRegularPermutationGroupNC,COM_FUN(9));
InstallGlobalFunction(PresentationViaCosetTable,COM_FUN(10));
InstallGlobalFunction(RelsViaCosetTable,COM_FUN(11));
InstallGlobalFunction(RemoveRelator,COM_FUN(12));
InstallGlobalFunction(SimplifiedFpGroup,COM_FUN(13));
InstallGlobalFunction(AbstractWordTietzeWord,COM_FUN(14));
InstallGlobalFunction(TzCheckRecord,COM_FUN(15));
InstallGlobalFunction(TzEliminate,COM_FUN(16));
InstallGlobalFunction(TzEliminateFromTree,COM_FUN(17));
InstallGlobalFunction(TzEliminateGen,COM_FUN(18));
InstallGlobalFunction(TzEliminateGen1,COM_FUN(19));
InstallGlobalFunction(TzEliminateGens,COM_FUN(20));
InstallGlobalFunction(TzFindCyclicJoins,COM_FUN(21));
InstallGlobalFunction(TzGeneratorExponents,COM_FUN(22));
InstallGlobalFunction(TzGo,COM_FUN(23));
InstallGlobalFunction(TzGoGo,COM_FUN(24));
InstallGlobalFunction(TzHandleLength1Or2Relators,COM_FUN(25));
InstallGlobalFunction(GeneratorsOfPresentation,COM_FUN(26));
InstallGlobalFunction(TzInitGeneratorImages,COM_FUN(27));
InstallGlobalFunction(OldGeneratorsOfPresentation,COM_FUN(28));
InstallGlobalFunction(TzImagesOldGens,COM_FUN(29));
InstallGlobalFunction(TzPreImagesNewGens,COM_FUN(30));
InstallGlobalFunction(TzMostFrequentPairs,COM_FUN(31));
InstallGlobalFunction(TzNewGenerator,COM_FUN(32));
InstallGlobalFunction(TzPrint,COM_FUN(33));
InstallGlobalFunction(TzPrintGeneratorImages,COM_FUN(34));
InstallGlobalFunction(TzPrintGenerators,COM_FUN(35));
InstallGlobalFunction(TzPrintLengths,COM_FUN(36));
InstallMethod(TzOptions,"set default values",true,[IsPresentation],0,COM_FUN(37));
InstallGlobalFunction(TzPrintOptions,COM_FUN(38));
InstallGlobalFunction(TzPrintPairs,COM_FUN(39));
InstallGlobalFunction(TzPrintPresentation,COM_FUN(40));
InstallGlobalFunction(TzPrintRelators,COM_FUN(41));
InstallGlobalFunction(TzPrintStatus,COM_FUN(42));
InstallGlobalFunction(TzRelator,COM_FUN(43));
InstallGlobalFunction(TzRemoveGenerators,COM_FUN(44));
InstallGlobalFunction(TzSearch,COM_FUN(45));
InstallGlobalFunction(TzSearchEqual,COM_FUN(46));
InstallGlobalFunction(TzSort,COM_FUN(47));
InstallGlobalFunction(TzSubstitute,COM_FUN(48));
InstallGlobalFunction(TzSubstituteCyclicJoins,COM_FUN(49));
InstallGlobalFunction(TzSubstituteWord,COM_FUN(50));
InstallGlobalFunction(TzUpdateGeneratorImages,COM_FUN(51));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/tietze.gi"

#F  file="lib/ghomfp.gi" crc=106832173
RANK_FILTER_LIST  := [ 54525323, 30, 65767820, 5, 54525323, 30, 29522433, 31, 
  22182161, 29, 22028087, 29, 22028087, 29, 65767820, 5, 22028087, 29, 
  65767820, 5, 22028087, 29, 65767820, 5, 24644242, 24, 22028087, 29, 
  13623442, 28, 53660808, 21, 44568071, 13, 1829479, 17, 45869191, 34, 
  8381117, 22, 65767820, 5, 58923477, 23, 67108760, 5, 58923477, 23, 
  63988552, 12, 67108760, 5, 58923477, 23, 58923477, 23, 58923477, 23, 
  58923477, 23, 32042524, 24, 58923477, 23, 58909558, 26, 58909558, 26, 
  58923477, 23, 58923477, 23, 58923477, 23, 14679570, 24, 14679570, 24, 
  14679570, 24, 14679570, 24, 65767820, 5, 14679570, 24, 65767820, 5 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/ghomfp.gi", 106832173 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/ghomfp.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/ghomfp.gi");
elif COM_RESULT = 3  then
Revision.ghomfp_gi:="@(#)$Id: ghomfp.gi,v 4.41 2003/09/02 17:03:32 gap Exp $";
InstallMethod(ImagesRepresentative,"map from fp group or free group, use 'MappedWord'",FamSourceEqFamElm,[IsFromFpGroupStdGensGeneralMappingByImages,IsMultiplicativeElementWithInverse],0,COM_FUN(1));
InstallMethod(IsSingleValued,"map from fp group or free group, given on std. gens: test relators",true,[IsFromFpGroupStdGensGeneralMappingByImages],0,COM_FUN(2));
InstallMethod(IsSingleValued,"map from fp group or free group to perm, given on std. gens: test relators",true,[IsFromFpGroupStdGensGeneralMappingByImages and IsToPermGroupGeneralMappingByImages],0,COM_FUN(3));
InstallMethod(KernelOfMultiplicativeGeneralMapping,"from fp/free group, std. gens., to perm group",true,[IsFromFpGroupGeneralMapping and IsToPermGroupGeneralMappingByImages],0,COM_FUN(4));
InstallGlobalFunction(SecondaryImagesAugmentedCosetTable,COM_FUN(5));
InstallGlobalFunction(TrySecondaryImages,COM_FUN(6));
InstallMethod(CosetTableFpHom,"for fp homomorphisms",true,[IsFromFpGroupGeneralMappingByImages and IsGroupGeneralMappingByImages],0,COM_FUN(7));
InstallMethod(ImagesRepresentative,"map from (sub)fp group, rewrite",FamSourceEqFamElm,[IsFromFpGroupGeneralMappingByImages and IsGroupGeneralMappingByImages,IsMultiplicativeElementWithInverse],0,COM_FUN(8));
InstallMethod(ImagesRepresentative,"map from (sub)fp group, rewrite",FamSourceEqFamElm,[IsFromFpGroupGeneralMappingByImages and IsGroupGeneralMappingByImages,IsMultiplicativeElementWithInverse],0,COM_FUN(9));
InstallMethod(ImagesRepresentative,"simple tests on equal words to check whether the `generators' are mapped",FamSourceEqFamElm,[IsFromFpGroupGeneralMappingByImages and IsGroupGeneralMappingByImages,IsMultiplicativeElementWithInverse],1,COM_FUN(10));
InstallMethod(KernelOfMultiplicativeGeneralMapping,"hom from fp grp",true,[IsFromFpGroupGeneralMapping and IsGroupGeneralMapping],0,COM_FUN(11));
InstallMethod(CoKernelOfMultiplicativeGeneralMapping,"GHBI from fp grp",true,[IsFromFpGroupGeneralMappingByImages and IsGroupGeneralMappingByImages],0,COM_FUN(12));
BindGlobal("WreathElm",COM_FUN(13));
InstallGlobalFunction(KuKGenerators,COM_FUN(14));
BindGlobal("InducedRepFpGroup",COM_FUN(15));
BindGlobal("IsTransPermStab1",COM_FUN(16));
InstallMethod(PreImagesSet,"map from (sub)group of fp group",CollFamRangeEqFamElms,[IsFromFpGroupHomomorphism,IsGroup],0,COM_FUN(17));
InstallMethod(IsConjugatorIsomorphism,"for a f.p. group general mapping",true,[IsGroupGeneralMapping],1,COM_FUN(18));
InstallMethod(CompositionMapping2,"for gp. hom. and fp. hom, transferring the coset table",FamSource1EqFamRange2,[IsGroupHomomorphism,IsGroupHomomorphism and IsFromFpGroupGeneralMappingByImages and HasCosetTableFpHom],0,COM_FUN(19));
InstallMethod(PreImagesRepresentative,"hom. to standard generators of fp group, using 'MappedWord'",FamRangeEqFamElm,[IsToFpGroupHomomorphismByImages,IsMultiplicativeElementWithInverse],1,COM_FUN(20));
InstallOtherMethod(IsomorphismFpGroup,"subgroups of fp group",true,[IsSubgroupFpGroup,IsString],0,COM_FUN(21));
InstallMethod(IsomorphismFpGroupByGeneratorsNC,"subgroups of fp group",IsFamFamX,[IsSubgroupFpGroup,IsList and IsMultiplicativeElementWithInverseCollection,IsString],0,COM_FUN(22));
InstallMethod(IsomorphismSimplifiedFpGroup,"using tietze transformations",true,[IsSubgroupFpGroup],0,COM_FUN(23));
InstallMethod(NaturalHomomorphismByNormalSubgroupOp,"for subgroups of fp groups",IsIdenticalObj,[IsSubgroupFpGroup,IsSubgroupFpGroup],0,COM_FUN(24));
InstallMethod(NaturalHomomorphismByNormalSubgroupOp,"for subgroups of fp groups by quotient rep.",IsIdenticalObj,[IsSubgroupFpGroup,IsSubgroupFpGroup and IsSubgroupOfWholeGroupByQuotientRep],0,COM_FUN(25));
InstallMethod(NaturalHomomorphismByNormalSubgroupOp,"trivial image fp case",IsIdenticalObj,[IsSubgroupFpGroup,IsSubgroupFpGroup and IsWholeFamily],0,COM_FUN(26));
InstallMethod(MaximalAbelianQuotient,"whole fp group",true,[IsSubgroupFpGroup and IsWholeFamily],0,COM_FUN(27));
InstallMethod(MaximalAbelianQuotient,"for subgroups of finitely presented groups",true,[IsSubgroupFpGroup],0,COM_FUN(28));
DeclareRepresentation("IsModuloPcgsFpGroupRep",IsModuloPcgs and IsPcgsDefaultRep,["hom","impcgs","groups"]);
InstallMethod(ModuloPcgs,"subgroups fp",true,[IsSubgroupFpGroup,IsSubgroupFpGroup],0,COM_FUN(29));
InstallMethod(NumeratorOfModuloPcgs,"fp",true,[IsModuloPcgsFpGroupRep],0,COM_FUN(30));
InstallMethod(DenominatorOfModuloPcgs,"fp",true,[IsModuloPcgsFpGroupRep],0,COM_FUN(31));
InstallMethod(RelativeOrders,"fp",true,[IsModuloPcgsFpGroupRep],0,COM_FUN(32));
InstallMethod(RelativeOrderOfPcElement,"fp",IsCollsElms,[IsModuloPcgsFpGroupRep,IsMultiplicativeElementWithInverse],0,COM_FUN(33));
InstallMethod(ExponentsOfPcElement,"fp",IsCollsElms,[IsModuloPcgsFpGroupRep,IsMultiplicativeElementWithInverse],0,COM_FUN(34));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/ghomfp.gi"

#F  file="lib/addgphom.gi" crc=121327775
RANK_FILTER_LIST  := [  ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/addgphom.gi", 121327775 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/addgphom.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/addgphom.gi");
elif COM_RESULT = 3  then
Revision.addgphom_gi:="@(#)$Id: addgphom.gi,v 1.2 2002/04/15 10:04:22 sal Exp $";
InstallGlobalFunction(GroupToAdditiveGroupHomomorphismByFunction,COM_FUN(1));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/addgphom.gi"

#F  file="lib/hash.gi" crc=24556858
RANK_FILTER_LIST  := [ 8126465, 2, 8126465, 2, 5, 1, 8126465, 2, 8126465, 2, 
  5, 1, 11598115, 9, 11598115, 9, 56639939, 18, 29359425, 17, 11598115, 9, 
  29360099, 2, 8126465, 2, 8126465, 2, 5, 1, 18891157, 18, 1, 0, 58719523, 
  18, 1, 0, 1, 0, 7519, 18, 1, 0, 1, 0, 18891158, 19, 1, 0, 1, 0, 40958213, 
  10, 40958213, 10, 40958213, 10, 58720197, 3, 8126465, 2, 8126465, 2, 5, 1, 
  19929638, 12, 1, 0, 37690948, 20, 1, 0, 1, 0, 37690948, 20, 1, 0, 1, 0, 
  37690948, 20, 1, 0, 1, 0, 37691622, 12, 37691622, 12, 37691622, 12 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/hash.gi", 24556858 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/hash.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/hash.gi");
elif COM_RESULT = 3  then
Revision.hash_gi:="@(#)$Id: hash.gi,v 4.17 2002/04/15 10:04:53 sal Exp $";
DeclareInfoClass("InfoHashTables");
InstallMethod(HashTable,true,[IsCollection,IsCollection,IsFunction],-1,COM_FUN(1));
InstallMethod(SingleValuedHashTable,true,[IsCollection,IsCollection,IsFunction],-1,COM_FUN(2));
DeclareRepresentation("IsHashTable",IsComponentObjectRep,["source","range","hashFunc","entries","table"]);
InstallMethod(Source,true,[IsHashTable and IsGeneralMapping],0,COM_FUN(3));
InstallMethod(Range,true,[IsHashTable and IsGeneralMapping],0,COM_FUN(4));
InstallMethod(ViewObj,"for mutable flexible hash table",true,[IsHashTable and IsFlexibleGeneralMapping and IsMutable],0,COM_FUN(5));
InstallMethod(ViewObj,"for mutable extensible hash table",true,[IsHashTable and IsExtensibleGeneralMapping and IsMutable],0,COM_FUN(6));
InstallMethod(ViewObj,"for immutable hash table",true,[IsHashTable and IsGeneralMapping],0,COM_FUN(7));
InstallMethod(PrintObj,"for a hash table",true,[IsHashTable],0,COM_FUN(8));
ListHashParams:=rec(BASIC_HASH_RANGE:=16,HASH_GROW_MARGIN:=5/4,HASH_GROW_FACTOR:=3/2,HASH_SHRINK_MARGIN:=3,HASH_SHRINK_FACTOR:=2);
DeclareRepresentation("IsListHashTable",IsHashTable,[]);
InstallMethod(ShrinkableHashTable,true,[IsCollection,IsCollection,IsFunction],0,COM_FUN(9));
ResizeListHashTable:=COM_FUN(10);
InstallMethod(ImagesElm,FamSourceEqFamElm,[IsListHashTable and IsFlexibleGeneralMapping,IsObject],0,COM_FUN(11));
InstallMethod(AddImage,FamMapFamSourceFamRange,[IsListHashTable and IsExtensibleGeneralMapping and IsMutable,IsObject,IsObject],0,COM_FUN(12));
InstallMethod(AddImageNC,FamMapFamSourceFamRange,[IsList and IsExtensibleGeneralMapping and IsMutable,IsObject,IsObject],0,COM_FUN(13));
InstallMethod(DeleteImage,FamMapFamSourceFamRange,[IsListHashTable and IsFlexibleGeneralMapping and IsMutable,IsObject,IsObject],0,COM_FUN(14));
InstallMethod(IsSingleValued,true,[IsListHashTable and IsGeneralMapping],0,COM_FUN(15));
InstallMethod(ImagesSource,true,[IsListHashTable and IsGeneralMapping],0,COM_FUN(16));
InstallMethod(PreImagesRange,true,[IsListHashTable and IsGeneralMapping],0,COM_FUN(17));
InstallMethod(ShallowCopy,true,[IsListHashTable],0,COM_FUN(18));
FlatHashParams:=rec(BASIC_HASH_RANGE:=50,HASH_GROW_MARGIN:=3/2,HASH_GROW_FACTOR:=2);
DeclareRepresentation("IsFlatHashTable",IsHashTable,["tabSize"]);
InstallMethod(SingleValuedHashTable,true,[IsCollection,IsCollection,IsFunction\
],0,COM_FUN(19));
ResizeFlatHashTable:=COM_FUN(20);
InstallMethod(ImagesElm,FamSourceEqFamElm,[IsFlatHashTable and IsGeneralMapping and IsSingleValued,IsObject],0,COM_FUN(21));
InstallMethod(AddImage,FamMapFamSourceFamRange,[IsFlatHashTable and IsExtensiblePartialMapping and IsMutable,IsObject,IsObject],0,COM_FUN(22));
InstallMethod(AddImageNC,FamMapFamSourceFamRange,[IsFlatHashTable and IsExtensiblePartialMapping and IsMutable,IsObject,IsObject],0,COM_FUN(23));
InstallMethod(SetImage,FamMapFamSourceFamRange,[IsFlatHashTable and IsExtensiblePartialMapping and IsMutable,IsObject,IsObject],0,COM_FUN(24));
InstallMethod(ImagesSource,true,[IsFlatHashTable and IsSingleValued],0,COM_FUN(25));
InstallMethod(PreImagesRange,true,[IsFlatHashTable and IsSingleValued],0,COM_FUN(26));
InstallMethod(ShallowCopy,true,[IsFlatHashTable and IsSingleValued],0,COM_FUN(27));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/hash.gi"

#F  file="lib/dict.gi" crc=72824647
RANK_FILTER_LIST  := [ 16385, 3, 1, 0, 786433, 8, 1, 0, 28311298, 8, 1, 0, 1, 
  0, 47710089, 6, 1, 0, 46137270, 10, 1, 0, 1, 0, 56622595, 7, 1, 0, 
  28311298, 8, 1, 0, 47710089, 6, 1, 0, 28311298, 8, 1, 0, 50331319, 8, 1, 0, 
  1, 0, 25165660, 6, 1, 0, 25165660, 6, 1, 0, 50331319, 8, 1, 0, 67108475, 7, 
  67108475, 7, 67108760, 5, 67108760, 5, 67108475, 7, 67108475, 7, 67108475, 
  7, 67108475, 7, 28376463, 7, 17, 18, 28376463, 7, 17, 18, 1, 0, 28376463, 
  7, 28376463, 7, 16449016, 7, 16449016, 7, 67108760, 5, 67108760, 5, 
  16449016, 7, 44825883, 7, 44825883, 7, 44825883, 7, 44825883, 7, 1, 0, 
  44825883, 7, 1, 0, 1, 0, 44825883, 7, 44825883, 7, 11927043, 5, 11927043, 
  5, 1, 0, 11927043, 5, 1, 0, 1, 0, 11270761, 8, 1, 0, 1, 0, 11927043, 5, 1, 
  0, 11927043, 5, 1, 0, 11270761, 8, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 63594985, 
  49, 1, 0, 1, 0, 31628240, 40, 1, 0, 31628240, 40, 1, 0, 6493436, 29, 1, 0, 
  52247917, 19, 1, 0, 575, 9, 1, 0, 13508182, 9, 1, 0, 44853173, 28, 1, 0, 
  29883862, 2 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/dict.gi", 72824647 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/dict.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/dict.gi");
elif COM_RESULT = 3  then
Revision.dict_gi:="@(#)$Id: dict.gi,v 4.25 2003/04/16 20:44:28 gap Exp $";
InstallMethod(PositionFirstComponent,"for dense list",true,[IsDenseList,IsObject],0,COM_FUN(1));
InstallMethod(PositionFirstComponent,"for sorted list",true,[IsSSortedList,IsObject],0,COM_FUN(2));
BindGlobal("DictionaryByList",COM_FUN(3));
BindGlobal("DictionaryBySort",COM_FUN(4));
InstallOtherMethod(AddDictionary,"for lookup list dictionaries",true,[IsListLookupDictionary,IsObject,IsObject],0,COM_FUN(5));
InstallMethod(AddDictionary,"for list dictionaries",true,[IsListDictionary,IsObject],0,COM_FUN(6));
InstallOtherMethod(AddDictionary,"for lookup sort dictionaries",true,[IsSortLookupDictionary,IsObject,IsObject],0,COM_FUN(7));
InstallMethod(AddDictionary,"for sort dictionaries",true,[IsSortDictionary,IsObject],0,COM_FUN(8));
InstallMethod(KnowsDictionary,"for list lookup dictionaries",true,[IsListLookupDictionary,IsObject],0,COM_FUN(9));
InstallMethod(KnowsDictionary,"for list dictionaries",true,[IsListDictionary,IsObject],0,COM_FUN(10));
InstallMethod(LookupDictionary,"for list dictionaries",true,[IsListLookupDictionary,IsObject],0,COM_FUN(11));
InstallGlobalFunction(DictionaryByPosition,COM_FUN(12));
InstallOtherMethod(AddDictionary,"for lookup position dictionaries",true,[IsPositionLookupDictionary,IsObject,IsObject],0,COM_FUN(13));
InstallMethod(AddDictionary,"for position dictionaries",true,[IsPositionDictionary,IsObject],0,COM_FUN(14));
InstallMethod(KnowsDictionary,"for position dictionaries",true,[IsPositionDictionary,IsObject],0,COM_FUN(15));
InstallMethod(LookupDictionary,"for position dictionaries",true,[IsPositionLookupDictionary,IsObject],0,COM_FUN(16));
InstallGlobalFunction(NewDictionary,COM_FUN(17));
MaxHashViewSize:=10;
LastHashIndex:=-1;
InstallGlobalFunction(DenseHashTable,COM_FUN(18));
InstallMethod(ViewObj,"for dense hash tables",true,[IsDenseHashRep],0,COM_FUN(19));
InstallMethod(PrintHashWithNames,"for dense hash tables",true,[IsDenseHashRep,IsString,IsString],0,COM_FUN(20));
InstallMethod(PrintObj,"for dense hash tables",true,[IsDenseHashRep],0,COM_FUN(21));
InstallMethod(Size,"for dense hash tables",true,[IsDenseHashRep],0,COM_FUN(22));
InstallMethod(Enumerator,"for dense hash tables",true,[IsDenseHashRep],0,COM_FUN(23));
InstallMethod(HashKeyEnumerator,"for dense hash tables",true,[IsDenseHashRep],0,COM_FUN(24));
InstallMethod(GetHashEntry,"for dense hash tables",true,[IsHash and IsDenseHashRep,IsObject and IsInt],0,COM_FUN(25));
InstallMethod(AddHashEntry,"for dense hash tables",true,[IsHash and IsDenseHashRep,IsObject and IsInt,IsObject],0,COM_FUN(26));
InstallMethod(Random,"for dense hash tables",true,[IsHash and IsDenseHashRep],100,COM_FUN(27));
InstallMethod(RandomHashKey,"for dense hash tables",true,[IsHash and IsDenseHashRep],100,COM_FUN(28));
DefaultHashLength:=2^7;
InstallGlobalFunction(SparseHashTable,COM_FUN(29));
InstallMethod(ViewObj,"for sparse hash tables",true,[IsSparseHashRep],0,COM_FUN(30));
InstallMethod(PrintHashWithNames,"for sparse hash tables",true,[IsSparseHashRep,IsString,IsString],0,COM_FUN(31));
InstallMethod(PrintObj,"for sparse hash tables",true,[IsSparseHashRep],0,COM_FUN(32));
InstallMethod(Size,"for sparse hash tables",true,[IsHash and IsSparseHashRep],0,COM_FUN(33));
InstallMethod(Enumerator,"for sparse hash tables",true,[IsHash and IsSparseHashRep],0,COM_FUN(34));
InstallMethod(HashKeyEnumerator,"for sparse hash tables",true,[IsHash and IsSparseHashRep],0,COM_FUN(35));
BindGlobal("HASH_RANGE",[0..10000]);
InstallGlobalFunction(GetHashEntryIndex,COM_FUN(36));
InstallMethod(GetHashEntry,"for sparse hash tables",true,[IsHash and IsSparseHashRep,IsObject],0,COM_FUN(37));
InstallGlobalFunction(DoubleHashArraySize,COM_FUN(38));
InstallMethod(AddHashEntry,"for sparse hash tables",true,[IsHash and IsSparseHashRep,IsObject,IsObject],0,COM_FUN(39));
InstallMethod(Random,"for sparse hash tables",true,[IsHash and IsSparseHashRep],100,COM_FUN(40));
InstallMethod(RandomHashKey,"for sparse hash tables",true,[IsHash and IsSparseHashRep],100,COM_FUN(41));
InstallGlobalFunction(HashFunct,COM_FUN(42));
InstallMethod(GetHashEntryAtLastIndex,"for hash table",true,[IsHash],0,COM_FUN(43));
InstallMethod(SetHashEntryAtLastIndex,"for hash table",true,[IsHash,IsObject],0,COM_FUN(44));
InstallMethod(SetHashEntry,"for hash table",true,[IsHash,IsObject,IsObject],0,COM_FUN(45));
BindGlobal("HashDictAddDictionary",COM_FUN(46));
InstallOtherMethod(AddDictionary,"for hash tables",true,[IsHash and IsSparseHashRep and TableHasIntKeyFun,IsObject,IsObject],0,HashDictAddDictionary);
InstallGlobalFunction(DoubleHashDictSize,COM_FUN(47));
InstallOtherMethod(AddDictionary,"for hash tables, no value given",true,[IsHash,IsObject],0,COM_FUN(48));
InstallMethod(KnowsDictionary,"for hash tables",true,[IsHash,IsObject],0,COM_FUN(49));
InstallMethod(LookupDictionary,"for hash tables",true,[IsHash and IsSparseHashRep and TableHasIntKeyFun,IsObject],0,COM_FUN(50));
InstallMethod(DenseIntKey,"default fail",true,[IsObject,IsObject],0,ReturnFail);
InstallMethod(SparseIntKey,"defaults to DenseIntKey",true,[IsObject,IsObject],0,DenseIntKey);
InstallMethod(DenseIntKey,"for finite Gaussian row spaces",true,[IsFFECollColl and IsGaussianRowSpace,IsObject],0,COM_FUN(51));
InstallMethod(DenseIntKey,"for matrices over finite field vector spaces",true,[IsObject,IsFFECollColl and IsMatrix],0,COM_FUN(52));
InstallMethod(SparseIntKey,"for matrices over finite field vector spaces",true,[IsObject,IsFFECollColl and IsMatrix],0,COM_FUN(53));
InstallMethod(SparseIntKey,"for row spaces over finite fields",true,[IsObject,IsVectorSpace and IsRowSpace],0,COM_FUN(54));
InstallMethod(DenseIntKey,"integers",true,[IsObject,IsPosInt],0,COM_FUN(55));
InstallMethod(SparseIntKey,"permutations, arbitrary domain",true,[IsObject,IsInternalRep and IsPerm],0,COM_FUN(56));
InstallMethod(SparseIntKey,"kernel pc group elements",true,[IsObject,IsElementFinitePolycyclicGroup and IsDataObjectRep and IsNBitsPcWordRep],0,COM_FUN(57));
InstallMethod(SparseIntKey,"pcgs element lists: i.e. pcgs",true,[IsObject,IsElementFinitePolycyclicGroupCollection and IsList],0,COM_FUN(58));
InstallMethod(DenseIntKey,"transformations, arbitrary domain",true,[IsObject,IsTransformationRep],0,COM_FUN(59));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/dict.gi"

#F  file="lib/trans.gi" crc=69648460
RANK_FILTER_LIST  := [ 24247466, 6, 54132287, 8, 24247466, 6, 24247466, 6, 
  17, 18, 24247466, 6, 4063233, 1, 54132287, 8, 24247466, 6, 24247466, 6, 
  24247466, 6, 54132287, 8, 513, 8, 513, 8, 52247917, 19, 513, 8, 52247917, 
  19, 11792316, 12, 49346896, 7, 24247466, 6, 54132287, 8, 54132287, 8, 
  54132287, 8, 513, 8, 513, 8, 54132287, 8, 49346896, 7, 24247466, 6, 
  24247466, 6, 49346896, 7, 54132287, 8, 54132287, 8, 54132287, 8, 54132287, 
  8, 54132287, 8, 17, 18, 54132287, 8, 24247466, 6, 24247466, 6, 37386938, 
  19, 24247466, 6, 7665924, 21 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/trans.gi", 69648460 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/trans.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/trans.gi");
elif COM_RESULT = 3  then
Revision.trans_gi:="@(#)$Id: trans.gi,v 4.16 2003/05/23 16:17:59 gap Exp $";
InstallGlobalFunction(Transformation,COM_FUN(1));
InstallGlobalFunction(TransformationNC,COM_FUN(2));
InstallGlobalFunction(IdentityTransformation,COM_FUN(3));
InstallGlobalFunction(RandomTransformation,COM_FUN(4));
InstallMethod(ImageSetOfTransformation,"<trans>",true,[IsTransformation],0,COM_FUN(5));
InstallMethod(ImageListOfTransformation,"<trans>",true,[IsTransformation and IsTransformationRep],0,COM_FUN(6));
InstallMethod(RankOfTransformation,"<trans>",true,[IsTransformation],0,COM_FUN(7));
InstallMethod(PreimagesOfTransformation,"<trans>",true,[IsTransformation,IsInt],0,COM_FUN(8));
InstallMethod(RestrictedTransformation,"for transformation",true,[IsTransformation,IsListOrCollection],0,COM_FUN(9));
InstallMethod(KernelOfTransformation,"<trans>",true,[IsTransformation and IsTransformationRep],0,COM_FUN(10));
InstallMethod(PermLeftQuoTransformation,"for two transformations",true,[IsTransformation,IsTransformation],0,COM_FUN(11));
InstallGlobalFunction(TransformationData,COM_FUN(12));
InstallGlobalFunction(TransformationType,COM_FUN(13));
InstallGlobalFunction(TransformationFamily,COM_FUN(14));
InstallMethod(PrintObj,"for transformations",true,[IsTransformation],0,COM_FUN(15));
InstallMethod(DegreeOfTransformation,"for a transformation",true,[IsTransformation and IsTransformationRep],0,COM_FUN(16));
InstallMethod(AsTransformation,"for a permutation",true,[IsPerm],0,COM_FUN(17));
InstallOtherMethod(AsTransformation,"for a permutation and degree",true,[IsPerm,IsPosInt],0,COM_FUN(18));
InstallOtherMethod(AsTransformationNC,"for a permutation and degree",true,[IsPerm,IsPosInt],0,COM_FUN(19));
InstallOtherMethod(AsTransformation,"for binary relations on points",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(20));
InstallMethod(TransformationRelation,"for relation over [1..n]",true,[IsGeneralMapping],0,COM_FUN(21));
InstallMethod(BinaryRelationTransformation,"for a transformation",true,[IsTransformation],0,COM_FUN(22));
InstallMethod(\*,"trans * trans",IsIdenticalObj,[IsTransformation and IsTransformationRep,IsTransformation and IsTransformationRep],0,COM_FUN(23));
InstallMethod(\*,"trans * perm",true,[IsTransformation and IsTransformationRep,IsPerm],0,COM_FUN(24));
InstallMethod(\*,"trans * perm",true,[IsPerm,IsTransformation and IsTransformationRep],0,COM_FUN(25));
InstallMethod(\*,"binary relation * trans",true,[IsGeneralMapping,IsTransformation],0,COM_FUN(26));
InstallMethod(\*,"trans * binary relation",true,[IsTransformation,IsGeneralMapping],0,COM_FUN(27));
InstallMethod(\<,"<trans> < <trans>",IsIdenticalObj,[IsTransformation and IsTransformationRep,IsTransformation and IsTransformationRep],0,COM_FUN(28));
InstallMethod(One,"One(<trans>)",true,[IsTransformation and IsTransformationRep],0,COM_FUN(29));
InstallMethod(\=,"for two transformations of the same set",IsIdenticalObj,[IsTransformation and IsTransformationRep,IsTransformation and IsTransformationRep],0,COM_FUN(30));
InstallOtherMethod(\^,"i ^ trans",true,[IsInt,IsTransformation and IsTransformationRep],0,COM_FUN(31));
InstallMethod(InverseOp,"Inverse operation of transformations",true,[IsTransformation],0,COM_FUN(32));
InstallMethod(\^,"for transformations and negative integers",true,[IsTransformation,IsInt and IsNegRat],0,COM_FUN(33));
InstallMethod(\^,"for transformations and zero",true,[IsTransformation,IsZeroCyc],0,COM_FUN(34));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/trans.gi"

#F  file="lib/fastendo.gi" crc=74599438
RANK_FILTER_LIST  := [ 15980598, 13, 49534745, 16, 49534745, 16, 49534745, 
  16, 15980598, 13, 49534745, 16, 49534745, 16, 15980598, 13, 49534745, 16, 
  49534745, 16, 49534745, 16, 15980598, 13, 15980598, 13, 49534745, 16, 
  49534745, 16, 49534745, 16, 15980598, 13, 49534745, 16, 49534745, 16, 
  15980598, 13, 49534745, 16, 1, 0 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/fastendo.gi", 74599438 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/fastendo.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/fastendo.gi");
elif COM_RESULT = 3  then
Revision.fastendo_gi:="@(#)$Id: fastendo.gi,v 4.3 2002/04/15 10:04:39 sal Exp $";
DeclareRepresentation("IsTransformationRepOfEndo",IsComponentObjectRep and IsAttributeStoringRep,["transformation"]);
BindGlobal("EndoMappingByTransformation",COM_FUN(1));
InstallMethod(TransformationRepresentation,"for an endo general mapping",true,[IsEndoMapping],0,COM_FUN(2));
InstallMethod(TransformationRepresentation,"for an endo general mapping",true,[IsEndoMapping and IsTransformationRepOfEndo],0,COM_FUN(3));
InstallMethod(CompositionMapping2,"IsTransformationRepOfEndo, IsTransformationRepOfEndo",IsIdenticalObj,[IsTransformationRepOfEndo and IsEndoMapping,IsTransformationRepOfEndo and IsEndoMapping],0,COM_FUN(4));
InstallMethod(CompositionMapping2,"IsEndoMapping, IsTransformationRepOfEndo",IsIdenticalObj,[IsEndoMapping,IsTransformationRepOfEndo and IsEndoMapping],0,COM_FUN(5));
InstallMethod(CompositionMapping2,"IsTransformationRepOfEndo, IsEndoMapping",IsIdenticalObj,[IsTransformationRepOfEndo and IsEndoMapping,IsEndoMapping],0,COM_FUN(6));
InstallMethod(\=,"IsTransformationRepOfEndo, IsTransformationRepOfEndo",IsIdenticalObj,[IsTransformationRepOfEndo and IsEndoMapping,IsTransformationRepOfEndo and IsEndoMapping],0,COM_FUN(7));
InstallMethod(\=,"IsTransformationRepOfEndo, IsEndoMapping",IsIdenticalObj,[IsTransformationRepOfEndo and IsEndoMapping,IsEndoMapping],0,COM_FUN(8));
InstallMethod(\=,"IsEndoMapping, IsTransformationRepOfEndo",IsIdenticalObj,[IsEndoMapping,IsTransformationRepOfEndo and IsEndoMapping],0,COM_FUN(9));
InstallMethod(\<,"IsTransformationRepOfEndo, IsTransformationRepOfEndo",IsIdenticalObj,[IsEndoMapping and IsTransformationRepOfEndo,IsEndoMapping and IsTransformationRepOfEndo],0,COM_FUN(10));
InstallMethod(\<,"IsEndoMapping, IsTransformationRepOfEndo",IsIdenticalObj,[IsEndoMapping,IsEndoMapping and IsTransformationRepOfEndo],0,COM_FUN(11));
InstallMethod(\<,"IsTransformationRepOfEndo, IsEndoMapping",IsIdenticalObj,[IsEndoMapping and IsTransformationRepOfEndo,IsEndoMapping],0,COM_FUN(12));
InstallMethod(ImagesElm,"IsTransformationRepOfEndo",FamSourceEqFamElm,[IsTransformationRepOfEndo and IsEndoMapping,IsObject],0,COM_FUN(13));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/fastendo.gi"

#F  file="lib/fpsemi.gi" crc=-38909162
RANK_FILTER_LIST  := [ 25267135, 2, 47284410, 5, 1014954, 7, 67108025, 5, 
  67108025, 5, 67108025, 5, 67108025, 5, 67108025, 5, 67108025, 5, 67108025, 
  5, 67108025, 5, 67108025, 5, 67108025, 5, 12582043, 18, 14977290, 32, 
  8557431, 17, 14977290, 32, 8557431, 17, 12582043, 18, 8557431, 17, 
  54709084, 19, 42112373, 18, 12582043, 18, 8557431, 17, 12582043, 18, 
  42127042, 14, 8557431, 17, 42127042, 14 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/fpsemi.gi", -38909162 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/fpsemi.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/fpsemi.gi");
elif COM_RESULT = 3  then
Revision.fpsemi_gi:="@(#)$Id: fpsemi.gi,v 4.14 2002/04/15 10:04:40 sal Exp $";
InstallMethod(ElementOfFpSemigroup,"for a family of f.p. semigroup elements, and an assoc. word",true,[IsElementOfFpSemigroupFamily,IsAssocWord],0,COM_FUN(1));
InstallMethod(UnderlyingElement,"for an element of an f.p. semigroup (default repres.)",true,[IsElementOfFpSemigroup and IsPackedElementDefaultRep],0,COM_FUN(2));
InstallMethod(FpSemigroupOfElementOfFpSemigroup,"for an element of an fp semigroup",true,[IsElementOfFpSemigroup],0,COM_FUN(3));
InstallMethod(\*,"for two elements of a f.p. semigroup",IsIdenticalObj,[IsElementOfFpSemigroup,IsElementOfFpSemigroup],0,COM_FUN(4));
InstallMethod(\<,"for two elements of a f.p. semigroup",IsIdenticalObj,[IsElementOfFpSemigroup,IsElementOfFpSemigroup],0,COM_FUN(5));
InstallMethod(\=,"for two elements of a f.p. semigroup",IsIdenticalObj,[IsElementOfFpSemigroup,IsElementOfFpSemigroup],0,COM_FUN(6));
InstallMethod(PrintObj,"for an f.p. semigroup element",true,[IsElementOfFpSemigroup],0,COM_FUN(7));
InstallMethod(String,"for an f.p. semigroup element",true,[IsElementOfFpSemigroup],0,COM_FUN(8));
InstallMethod(FpGrpMonSmgOfFpGrpMonSmgElement,"for an element of an fp semigroup",true,[IsElementOfFpSemigroup],0,COM_FUN(9));
InstallGlobalFunction(FactorFreeSemigroupByRelations,COM_FUN(10));
InstallMethod(HomomorphismFactorSemigroup,"for a free semigroup and a congruence",true,[IsFreeSemigroup,IsSemigroupCongruence],0,COM_FUN(11));
InstallMethod(HomomorphismFactorSemigroup,"for an fp semigroup and a congruence",true,[IsFpSemigroup,IsSemigroupCongruence],0,COM_FUN(12));
InstallMethod(FreeSemigroupOfFpSemigroup,"for a finitely presented semigroup",true,[IsSubsemigroupFpSemigroup and IsWholeFamily],0,COM_FUN(13));
InstallMethod(Size,"for a free semigroup",true,[IsFreeSemigroup],0,COM_FUN(14));
InstallMethod(FreeGeneratorsOfFpSemigroup,"for a finitely presented semigroup",true,[IsSubsemigroupFpSemigroup and IsWholeFamily],0,COM_FUN(15));
InstallMethod(ViewObj,"for a free semigroup with generators",true,[IsSemigroup and IsFreeSemigroup and HasGeneratorsOfMagma],0,COM_FUN(16));
InstallMethod(ViewObj,"for a fp semigroup with generators",true,[IsSubsemigroupFpSemigroup and IsWholeFamily and IsSemigroup and HasGeneratorsOfMagma],0,COM_FUN(17));
InstallOtherMethod(RelationsOfFpSemigroup,"method for a free semigroup",true,[IsFreeSemigroup],0,COM_FUN(18));
InstallMethod(RelationsOfFpSemigroup,"for finitely presented semigroup",true,[IsSubsemigroupFpSemigroup and IsWholeFamily],0,COM_FUN(19));
BindGlobal("FreeSemigroupNatHomByGeneratorsNC",COM_FUN(20));
InstallMethod(NaturalHomomorphismByGenerators,"for a free semigroup and semigroup",true,[IsFreeSemigroup,IsSemigroup and HasGeneratorsOfMagma],0,COM_FUN(21));
InstallMethod(NaturalHomomorphismByGenerators,"for an fp semigroup and semigroup",true,[IsFpSemigroup,IsSemigroup and HasGeneratorsOfSemigroup],0,COM_FUN(22));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/fpsemi.gi"

#F  file="lib/fpmon.gi" crc=-15885006
RANK_FILTER_LIST  := [ 32710791, 2, 30506834, 6, 42747946, 8, 41732138, 6, 
  41732138, 6, 41732138, 6, 41732138, 6, 41732138, 6, 41732138, 6, 32710791, 
  2, 41732138, 6, 41732138, 6, 41732138, 6, 41732138, 6, 41732138, 6, 
  41732138, 6, 55322505, 21, 21768523, 20, 21768523, 20, 50331049, 22, 
  21768523, 20, 50331049, 22, 39845139, 26, 21768523, 20, 14977290, 32, 
  50331049, 22, 21063809, 17, 21768523, 20, 21063809, 17, 21768523, 20 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/fpmon.gi", -15885006 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/fpmon.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/fpmon.gi");
elif COM_RESULT = 3  then
Revision.fpmon_gi:="@(#)$Id: fpmon.gi,v 4.7 2002/04/15 10:04:40 sal Exp $";
InstallMethod(ElementOfFpMonoid,"for a family of f.p. monoid elements, and an assoc. word",true,[IsElementOfFpMonoidFamily,IsAssocWordWithOne],0,COM_FUN(1));
InstallMethod(UnderlyingElement,"for an element of an fp monoid (default repres.)",true,[IsElementOfFpMonoid and IsPackedElementDefaultRep],0,COM_FUN(2));
InstallMethod(\*,"for two elements of a fp monoid",IsIdenticalObj,[IsElementOfFpMonoid,IsElementOfFpMonoid],0,COM_FUN(3));
InstallMethod(\<,"for two elements of a f.p. monoid",IsIdenticalObj,[IsElementOfFpMonoid,IsElementOfFpMonoid],0,COM_FUN(4));
InstallMethod(\=,"for two elements of a f.p. monoid",IsIdenticalObj,[IsElementOfFpMonoid,IsElementOfFpMonoid],0,COM_FUN(5));
InstallOtherMethod(One,"for a family of fp monoid elements",true,[IsElementOfFpMonoidFamily],0,COM_FUN(6));
InstallMethod(One,"for an fp monoid element",true,[IsElementOfFpMonoid],0,COM_FUN(7));
InstallMethod(OneOp,"for an fp monoid element",true,[IsElementOfFpMonoid],0,COM_FUN(8));
InstallMethod(PrintObj,"for an fp monoid element",true,[IsElementOfFpMonoid],0,COM_FUN(9));
InstallMethod(String,"for an fp monoid element",true,[IsElementOfFpMonoid],0,COM_FUN(10));
InstallMethod(FpMonoidOfElementOfFpMonoid,"for an fp monoid element",true,[IsElementOfFpMonoid],0,COM_FUN(11));
InstallMethod(FpGrpMonSmgOfFpGrpMonSmgElement,"for an element of an fp monoid",true,[IsElementOfFpMonoid],0,COM_FUN(12));
InstallGlobalFunction(FactorFreeMonoidByRelations,COM_FUN(13));
InstallMethod(ViewObj,"for a fp monoid with generators",true,[IsSubmonoidFpMonoid and IsWholeFamily and IsMonoid and HasGeneratorsOfMagma],0,COM_FUN(14));
InstallMethod(FreeGeneratorsOfFpMonoid,"for a finitely presented monoid",true,[IsSubmonoidFpMonoid and IsWholeFamily],0,COM_FUN(15));
InstallMethod(FreeMonoidOfFpMonoid,"for a finitely presented monoid",true,[IsSubmonoidFpMonoid and IsWholeFamily],0,COM_FUN(16));
InstallOtherMethod(RelationsOfFpMonoid,"method for a free monoid",true,[IsFreeMonoid],0,COM_FUN(17));
InstallMethod(RelationsOfFpMonoid,"for finitely presented monoid",true,[IsSubmonoidFpMonoid and IsWholeFamily],0,COM_FUN(18));
InstallOtherMethod(HomomorphismFactorSemigroup,"for a free monoid and a congruence",true,[IsFreeMonoid,IsMagmaCongruence],0,COM_FUN(19));
InstallMethod(HomomorphismFactorSemigroup,"for an fp monoid and a congruence",true,[IsFpMonoid,IsSemigroupCongruence],0,COM_FUN(20));
BindGlobal("FreeMonoidNatHomByGeneratorsNC",COM_FUN(21));
InstallMethod(NaturalHomomorphismByGenerators,"for a free monoid and monoid",true,[IsFreeMonoid,IsMonoid and HasGeneratorsOfMagmaWithOne],0,COM_FUN(22));
InstallMethod(NaturalHomomorphismByGenerators,"for an fp monoid and monoid",true,[IsFpMonoid,IsMonoid and HasGeneratorsOfMonoid],0,COM_FUN(23));
InstallMethod(IsomorphismFpSemigroup,"for an fp monoid",true,[IsFpMonoid],0,COM_FUN(24));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/fpmon.gi"

#F  file="lib/rwssmg.gi" crc=37120317
RANK_FILTER_LIST  := [ 8557431, 17, 21768523, 20, 8557431, 17, 25165015, 1, 
  21768523, 20, 25165015, 1, 8557431, 17, 5, 1, 67108850, 2, 23453846, 4, 
  26708512, 4, 23453846, 4, 47284410, 5, 26708512, 4, 47284410, 5, 23453846, 
  4, 26708512, 4 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/rwssmg.gi", 37120317 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/rwssmg.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/rwssmg.gi");
elif COM_RESULT = 3  then
Revision.rwssmg_gi:="@(#)$Id: rwssmg.gi,v 4.19.2.1 2004/10/31 22:55:42 gap Exp $";
BindGlobal("ReducedConfluentRwsFromKbrwsNC",COM_FUN(1));
InstallMethod(ReducedConfluentRewritingSystem,"for an fp semigroup",true,[IsFpSemigroup],0,COM_FUN(2));
InstallMethod(ReducedConfluentRewritingSystem,"for an fp monoid",true,[IsFpMonoid],0,COM_FUN(3));
InstallOtherMethod(ReducedConfluentRewritingSystem,"for an fp semigroup and an ordering on the underlying free semigroup",true,[IsFpSemigroup,IsOrdering],0,COM_FUN(4));
InstallOtherMethod(ReducedConfluentRewritingSystem,"for an fp monoid and an ordering on the underlying free monoid",true,[IsFpMonoid,IsOrdering],0,COM_FUN(5));
InstallOtherMethod(ReducedConfluentRewritingSystem,"for an fp semigroup and an order on the underlying free semigroup",true,[IsFpSemigroup,IsFunction],0,COM_FUN(6));
InstallMethod(IsConfluent,"for a monoid or a semigroup rewriting system",true,[IsRewritingSystem],0,COM_FUN(7));
InstallMethod(ViewObj,"for a semigroup rewriting system",true,[IsRewritingSystem and IsBuiltFromSemigroup],0,COM_FUN(8));
InstallMethod(ViewObj,"for a monoid rewriting system",true,[IsRewritingSystem and IsBuiltFromMonoid],0,COM_FUN(9));
InstallGlobalFunction(ReduceLetterRepWordsRewSys,REDUCE_LETREP_WORDS_REW_SYS);
InstallGlobalFunction(ReduceWordUsingRewritingSystem,COM_FUN(10));
InstallMethod(ReducedForm,"for a semigroup rewriting system and a word on the underlying free semigroup\
",true,[IsRewritingSystem and IsBuiltFromSemigroup,IsAssocWord],0,COM_FUN(11));
InstallMethod(ReducedForm,"for a monoid rewriting system and a word on the underlying free monoid",true,[IsRewritingSystem and IsBuiltFromMonoid,IsAssocWord],0,COM_FUN(12));
InstallMethod(FreeSemigroupOfRewritingSystem,"for a semigroup rewriting system",true,[IsRewritingSystem and IsBuiltFromSemigroup],0,COM_FUN(13));
InstallMethod(FreeMonoidOfRewritingSystem,"for a monoid rewriting system",true,[IsRewritingSystem and IsBuiltFromMonoid],0,COM_FUN(14));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/rwssmg.gi"

#F  file="lib/kbsemi.gi" crc=108966069
RANK_FILTER_LIST  := [ 37831266, 6, 37831266, 6, 8193, 2, 61285141, 8, 
  64539807, 8, 37831266, 6, 25267135, 2, 25165015, 1, 32710791, 2, 25165015, 
  1, 8557431, 17, 25165015, 1, 21768523, 20, 25165015, 1, 8557431, 17, 5, 1, 
  21768523, 20, 5, 1, 21768523, 20, 8557431, 17, 26708512, 4, 23453846, 4, 
  37831265, 5, 37831265, 5, 37831265, 5, 37831265, 5, 64540391, 5, 61285725, 
  5, 37831265, 5, 37831265, 5, 37831265, 5 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/kbsemi.gi", 108966069 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/kbsemi.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/kbsemi.gi");
elif COM_RESULT = 3  then
Revision.kbsemi_gi:="@(#)$Id: kbsemi.gi,v 4.36 2002/09/24 21:57:31 gap Exp $";
DeclareRepresentation("IsKnuthBendixRewritingSystemRep",IsComponentObjectRep,["family","tzrules","pairs2check","reduced","ordering"]);
InstallGlobalFunction(CreateKnuthBendixRewritingSystem,COM_FUN(1));
InstallMethod(ReduceRules,"for a Knuth Bendix rewriting system",true,[IsKnuthBendixRewritingSystem and IsKnuthBendixRewritingSystemRep and IsMutab\
le],0,COM_FUN(2));
InstallOtherMethod(AddRuleReduced,"for a Knuth Bendix rewriting system and a rule",true,[IsKnuthBendixRewritingSystem and IsMutable and IsKnuthBendixRewritingSystemR\
ep,IsList],0,COM_FUN(3));
InstallGlobalFunction(MakeKnuthBendixRewritingSystemConfluent,COM_FUN(4));
BindGlobal("KBOverlaps",COM_FUN(5));
BindGlobal("GKB_MakeKnuthBendixRewritingSystemConfluent",COM_FUN(6));
GAPKB_REW.MakeKnuthBendixRewritingSystemConfluent:=GKB_MakeKnuthBendixRewritingSystemConfluent;
InstallMethod(MakeConfluent,"for Knuth Bendix Rewriting System",true,[IsKnuthBendixRewritingSystem and IsKnuthBendixRewritingSystemRep and IsMutable and IsBuiltFromSemigroup],0,COM_FUN(7));
InstallMethod(MakeConfluent,"for Knuth Bendix Rewriting System",true,[IsKnuthBendixRewritingSystem and IsKnuthBendixRewritingSystemRep and IsMutable and IsBuiltFromMonoid],0,COM_FUN(8));
InstallMethod(IsReduced,"for a Knuth Bendix rewriting system",true,[IsKnuthBendixRewritingSystem and IsKnuthBendixRewritingSystemRep and IsMutab\
le],0,COM_FUN(9));
InstallMethod(KnuthBendixRewritingSystem,"for a family of words of an fp semigroup and on ordering on that family",tru\
e,[IsElementOfFpSemigroupFamily,IsOrdering],0,COM_FUN(10));
InstallMethod(KnuthBendixRewritingSystem,"for a family of words of an fp monoid and on ordering on that family",true,[IsElementOfFpMonoidFamily,IsOrdering],0,COM_FUN(11));
InstallOtherMethod(KnuthBendixRewritingSystem,"for an fp semigroup and an order on the family of words of the underlying fr\
ee semigroup",true,[IsFpSemigroup,IsOrdering],0,COM_FUN(12));
InstallOtherMethod(KnuthBendixRewritingSystem,"for an fp monoid and an order on the family of words of the underlying free \
monoid",true,[IsFpMonoid,IsOrdering],0,COM_FUN(13));
InstallOtherMethod(KnuthBendixRewritingSystem,"for an fp semigroup and a function",true,[IsFpSemigroup,IsFunction],0,COM_FUN(14));
InstallOtherMethod(KnuthBendixRewritingSystem,"for an fp monoid and a function",true,[IsFpMonoid,IsFunction],0,COM_FUN(15));
InstallOtherMethod(KnuthBendixRewritingSystem,"for an fp monoid",true,[IsFpMonoid],0,COM_FUN(16));
InstallOtherMethod(KnuthBendixRewritingSystem,"for an fp semigroup",true,[IsFpSemigroup],0,COM_FUN(17));
InstallMethod(MonoidOfRewritingSystem,"for a Knuth Bendix rewriting system",true,[IsRewritingSystem and IsBuiltFromMonoid],0,COM_FUN(18));
InstallMethod(SemigroupOfRewritingSystem,"for a Knuth Bendix rewriting system",true,[IsRewritingSystem and IsBuiltFromSemigroup],0,COM_FUN(19));
InstallMethod(Rules,"for a Knuth Bendix rewriting system",true,[IsKnuthBendixRewritingSystem and IsKnuthBendixRewritingSystemRep],0,COM_FUN(20));
InstallMethod(TzRules,"for a Knuth Bendix rewriting system",true,[IsKnuthBendixRewritingSystem and IsKnuthBendixRewritingSystemRep],0,COM_FUN(21));
InstallMethod(OrderingOfRewritingSystem,"for a Knuth Bendix rewriting system",true,[IsKnuthBendixRewritingSystem and IsKnuthBendixRewritingSystemRep],0,COM_FUN(22));
InstallMethod(FamilyForRewritingSystem,"for a Knuth Bendix rewriting system",true,[IsKnuthBendixRewritingSystem and IsKnuthBendixRewritingSystemRep],0,COM_FUN(23));
InstallMethod(ViewObj,"for a Knuth Bendix rewriting system",true,[IsKnuthBendixRewritingSystem and IsBuiltFromMonoid],0,COM_FUN(24));
InstallMethod(ViewObj,"for a Knuth Bendix rewriting system",true,[IsKnuthBendixRewritingSystem and IsBuiltFromSemigroup],0,COM_FUN(25));
InstallMethod(ShallowCopy,"for a Knuth Bendix rewriting system",true,[IsKnuthBendixRewritingSystem and IsKnuthBendixRewritingSystemRep],0,COM_FUN(26));
InstallMethod(\=,"for two Knuth-Bendix rewriting systems",IsIdenticalObj,[IsKnuthBendixRewritingSystem and IsKnuthBendixRewritingSystemRep,IsKnuthBendixRewritingSystem and IsKnuthBendixRewritingSystemRep],0,COM_FUN(27));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/kbsemi.gi"

#F  file="lib/tcsemi.gi" crc=64284814
RANK_FILTER_LIST  := [ 43515245, 22, 8557431, 17, 8557431, 17, 43515245, 22 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/tcsemi.gi", 64284814 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/tcsemi.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/tcsemi.gi");
elif COM_RESULT = 3  then
Revision.tcsemi_gi:="@(#)$Id: tcsemi.gi,v 4.8 2002/04/15 10:05:24 sal Exp $";
DeclareInfoClass("SemigroupToddCoxeterInfo");
InstallMethod(CosetTableOfFpSemigroup,"for a right congruence on an fp semigroup",true,[IsRightMagmaCongruence],0,COM_FUN(1));
InstallMethod(IsomorphismTransformationSemigroup,"<fp-semigroup>",true,[IsFpSemigroup],0,COM_FUN(2));
InstallMethod(HomomorphismTransformationSemigroup,"for an f.p. semigroup, and a right congruence",true,[IsFpSemigroup,IsRightMagmaCongruence],0,COM_FUN(3));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/tcsemi.gi"

#F  file="lib/semirel.gi" crc=78178998
RANK_FILTER_LIST  := [ 45668567, 21, 45668567, 21, 45668567, 21, 45668567, 
  21, 45668567, 21, 45668567, 21, 1, 0, 1, 0, 1, 0, 31315761, 24, 993, 2, 1, 
  0, 8560940, 15, 8560940, 15, 8560940, 15, 8560940, 15, 8560940, 15, 
  24771859, 6, 24771859, 6, 24771859, 6, 24771859, 6, 24771859, 6, 24771859, 
  6, 8560940, 15, 8560940, 15, 8560940, 15, 8560940, 15, 8560940, 15, 
  24205464, 8, 8560940, 15, 1, 0, 8560940, 15, 1, 0, 8560940, 15, 1, 0, 
  8560940, 15, 1, 0, 8560940, 15, 1, 0, 31089017, 25, 1, 0, 35569110, 23, 1, 
  0, 31089017, 25, 24205464, 8, 24205464, 8, 1, 0, 24205464, 8, 8193, 2, 
  31089017, 25, 24205464, 8, 43413563, 8, 24205464, 8, 24205464, 8, 44407831, 
  8, 44407831, 8, 44407831, 8, 43413563, 8, 43413563, 8, 57067990, 16, 
  57067990, 16, 57067990, 16, 57067990, 16, 57067990, 16, 58903013, 15, 
  58903013, 15, 58903013, 15, 58903013, 15, 58903013, 15, 8572100, 13, 
  8572100, 13, 8572100, 13, 8572100, 13, 8572100, 13, 8572100, 13, 1, 0, 
  8572100, 13, 1, 0, 8572100, 13, 1, 0, 8572100, 13, 1, 0, 8572100, 13, 1, 0, 
  1, 0, 24205464, 8, 8193, 2, 35569110, 23, 21154142, 18, 21154142, 18, 
  21154142, 18, 21154142, 18, 21154142, 18, 8572100, 13, 8572100, 13, 
  8572100, 13, 8572100, 13, 8572100, 13 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/semirel.gi", 78178998 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/semirel.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/semirel.gi");
elif COM_RESULT = 3  then
Revision.semirel_gi:="@(#)$Id: semirel.gi,v 4.30 2002/10/03 11:46:40 gap Exp $";
InstallMethod(IsGreensRelation,"for equivalence relations",true,[IsEquivalenceRelation],0,COM_FUN(1));
InstallMethod(IsGreensRRelation,"for a Green's equivalence class",true,[IsEquivalenceRelation],0,COM_FUN(2));
InstallMethod(IsGreensLRelation,"for a Green's equivalence class",true,[IsEquivalenceRelation],0,COM_FUN(3));
InstallMethod(IsGreensJRelation,"for a Green's equivalence class",true,[IsEquivalenceRelation],0,COM_FUN(4));
InstallMethod(IsGreensDRelation,"for a Green's equivalence class",true,[IsEquivalenceRelation],0,COM_FUN(5));
InstallMethod(IsGreensHRelation,"for a Green's equivalence class",true,[IsEquivalenceRelation],0,COM_FUN(6));
DeclareProperty("IsFiniteSemigroupGreensRelation",IsEquivalenceRelation);
InstallMethod(GreensRRelation,"for generic finite semigroups",true,[IsSemigroup and HasIsFinite and IsFinite],0,COM_FUN(7));
InstallMethod(GreensLRelation,"for generic finite semigroups",true,[IsSemigroup and HasIsFinite and IsFinite],0,COM_FUN(8));
InstallMethod(GreensJRelation,"for generic finite semigroups",true,[IsSemigroup and HasIsFinite and IsFinite],0,COM_FUN(9));
InstallMethod(GreensHRelation,"for generic finite semigroups",true,[IsSemigroup and IsFinite],0,COM_FUN(10));
InstallMethod(GreensDRelation,"for generic finite semigroups",true,[IsSemigroup and IsFinite],0,COM_FUN(11));
InstallMethod(IsGreensClass,"for equivalence classes",true,[IsEquivalenceClass],0,COM_FUN(12));
InstallMethod(IsGreensLClass,"for a Green's equivalence class",true,[IsEquivalenceClass],0,COM_FUN(13));
InstallMethod(IsGreensRClass,"for a Green's equivalence class",true,[IsEquivalenceClass],0,COM_FUN(14));
InstallMethod(IsGreensJClass,"for a Green's equivalence class",true,[IsEquivalenceClass],0,COM_FUN(15));
InstallMethod(IsGreensHClass,"for a Green's equivalence class",true,[IsEquivalenceClass],0,COM_FUN(16));
InstallMethod(IsGreensDClass,"for a Green's equivalence class",true,[IsEquivalenceClass],0,COM_FUN(17));
InstallMethod(GreensRClasses,"for generic finite semigroups",true,[IsSemigroup and HasIsFinite and IsFinite],0,COM_FUN(18));
InstallMethod(GreensLClasses,"for generic finite semigroups",true,[IsSemigroup and HasIsFinite and IsFinite],0,COM_FUN(19));
InstallMethod(GreensDClasses,"for generic finite semigroups",true,[IsSemigroup and HasIsFinite and IsFinite],0,COM_FUN(20));
InstallMethod(GreensHClasses,"for generic finite semigroups",true,[IsSemigroup and HasIsFinite and IsFinite],0,COM_FUN(21));
InstallMethod(GreensJClasses,"for generic finite semigroups",true,[IsSemigroup and HasIsFinite and IsFinite],0,COM_FUN(22));
InstallMethod(GreensHClasses,"for an Green's Class",true,[IsGreensClass],0,COM_FUN(23));
InstallMethod(GreensRClassOfElement,"for a Green's equivalence class",true,[IsSemigroup and HasIsFinite and IsFinite,IsObject],0,COM_FUN(24));
InstallMethod(GreensLClassOfElement,"for a Green's equivalence class",true,[IsSemigroup and HasIsFinite and IsFinite,IsObject],0,COM_FUN(25));
InstallMethod(GreensJClassOfElement,"for a Green's equivalence class",true,[IsSemigroup and HasIsFinite and IsFinite,IsObject],0,COM_FUN(26));
InstallMethod(GreensHClassOfElement,"for a Green's equivalence class",true,[IsSemigroup and HasIsFinite and IsFinite,IsObject],0,COM_FUN(27));
InstallMethod(GreensDClassOfElement,"for a Green's equivalence class",true,[IsSemigroup and HasIsFinite and IsFinite,IsObject],0,COM_FUN(28));
InstallMethod(EquivalenceClassOfElementNC,"for a Green's relation",true,[IsGreensRelation and IsFiniteSemigroupGreensRelation,IsObject],1,COM_FUN(29));
InstallMethod(EquivalenceClassOfElement,"for a Green's relation",true,[IsGreensRelation,IsObject],1,COM_FUN(30));
InstallMethod(EquivalenceClasses,"for a Green's relation",true,[IsGreensRelation and IsFiniteSemigroupGreensRelation],0,COM_FUN(31));
InstallMethod(\=,"for Green's equivalence classes",true,[IsGreensClass,IsGreensClass],0,COM_FUN(32));
InstallMethod(\in,"for Green's equivalence classes",true,[IsObject,IsGreensClass],0,COM_FUN(33));
InstallMethod(\in,"for Green's relation",true,[IsList,IsGreensRelation and IsFiniteSemigroupGreensRelation],0,COM_FUN(34));
InstallMethod(Enumerator,"for a Green's equivalence class",true,[IsGreensClass],0,COM_FUN(35));
InstallMethod(IsRegularDClass,"for a Green's D class",true,[IsGreensDClass],0,COM_FUN(36));
InstallMethod(IsGreensLessThanOrEqual,"for two Green's equivalence classes",true,[IsGreensClass,IsGreensClass],0,COM_FUN(37));
InstallMethod(RClassOfHClass,"for a Green's H class",true,[IsGreensHClass],0,COM_FUN(38));
InstallMethod(LClassOfHClass,"for a Green's H class",true,[IsGreensHClass],0,COM_FUN(39));
InstallMethod(IsGroupHClass,"for generic H class",true,[IsGreensHClass],0,COM_FUN(40));
InstallMethod(GroupHClassOfGreensDClass,"for finite H classes",true,[IsGreensDClass],0,COM_FUN(41));
InstallMethod(EggBoxOfDClass,"for a Green's D class",true,[IsGreensDClass],0,COM_FUN(42));
InstallGlobalFunction(DisplayEggBoxOfDClass,COM_FUN(43));
InstallMethod(GreensRRelation,"for transformation semigroups",true,[IsSemigroup and IsTransformationSemigroup],0,COM_FUN(44));
InstallMethod(GreensLRelation,"for transformation semigroups",true,[IsSemigroup and IsTransformationSemigroup],0,COM_FUN(45));
InstallMethod(GreensJRelation,"for transformation semigroups",true,[IsSemigroup and IsTransformationSemigroup],0,COM_FUN(46));
InstallMethod(GreensDRelation,"for transformation semigroups",true,[IsSemigroup and IsTransformationSemigroup],0,COM_FUN(47));
InstallMethod(GreensHRelation,"for transformation semigroups",true,[IsSemigroup and IsTransformationSemigroup],0,COM_FUN(48));
InstallMethod(GreensRRelation,"for full transformation semigroups",true,[IsSemigroup and IsFullTransformationSemigroup],0,COM_FUN(49));
InstallMethod(GreensLRelation,"for full transformation semigroups",true,[IsSemigroup and IsFullTransformationSemigroup],0,COM_FUN(50));
InstallMethod(GreensJRelation,"for full transformation semigroups",true,[IsSemigroup and IsFullTransformationSemigroup],0,COM_FUN(51));
InstallMethod(GreensDRelation,"for full transformation semigroups",true,[IsSemigroup and IsFullTransformationSemigroup],0,COM_FUN(52));
InstallMethod(GreensHRelation,"for full transformation semigroups",true,[IsSemigroup and IsFullTransformationSemigroup],0,COM_FUN(53));
InstallMethod(GreensRRelation,"for generic semigroups",true,[IsSemigroup],0,COM_FUN(54));
InstallMethod(GreensLRelation,"for generic semigroups",true,[IsSemigroup],0,COM_FUN(55));
InstallMethod(GreensJRelation,"for generic semigroups",true,[IsSemigroup],0,COM_FUN(56));
InstallMethod(GreensDRelation,"for generic semigroups",true,[IsSemigroup],0,COM_FUN(57));
InstallMethod(GreensHRelation,"for generic semigroups",true,[IsSemigroup],0,COM_FUN(58));
InstallMethod(GreensRClassOfElement,"for generic semigroups",true,[IsSemigroup,IsObject],0,COM_FUN(59));
InstallMethod(GreensLClassOfElement,"for generic semigroups",true,[IsSemigroup,IsObject],0,COM_FUN(60));
InstallMethod(GreensJClassOfElement,"for generic semigroups",true,[IsSemigroup,IsObject],0,COM_FUN(61));
InstallMethod(GreensDClassOfElement,"for generic semigroups",true,[IsSemigroup,IsObject],0,COM_FUN(62));
InstallMethod(GreensHClassOfElement,"for generic semigroups",true,[IsSemigroup,IsObject],0,COM_FUN(63));
InstallMethod(\in,"for Greens classes and generic semigroups",true,[IsObject,IsGreensClass],0,COM_FUN(64));
InstallMethod(\in,"for Greens relations and generic semigroups",true,[IsList,IsGreensRelation],0,COM_FUN(65));
InstallMethod(GreensRRelation,"for free semigroups",true,[IsSemigroup and IsFreeSemigroup],0,COM_FUN(66));
InstallMethod(GreensLRelation,"for free semigroups",true,[IsSemigroup and IsFreeSemigroup],0,COM_FUN(67));
InstallMethod(GreensJRelation,"for free semigroups",true,[IsSemigroup and IsFreeSemigroup],0,COM_FUN(68));
InstallMethod(GreensDRelation,"for free semigroups",true,[IsSemigroup and IsFreeSemigroup],0,COM_FUN(69));
InstallMethod(GreensHRelation,"for free semigroups",true,[IsSemigroup and IsFreeSemigroup],0,COM_FUN(70));
RedispatchOnCondition(GreensRRelation,true,[IsSemigroup],[IsFinite],0);
RedispatchOnCondition(GreensLRelation,true,[IsSemigroup],[IsFinite],0);
RedispatchOnCondition(GreensJRelation,true,[IsSemigroup],[IsFinite],0);
RedispatchOnCondition(GreensDRelation,true,[IsSemigroup],[IsFinite],0);
RedispatchOnCondition(GreensHRelation,true,[IsSemigroup],[IsFinite],0);
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/semirel.gi"

#F  file="lib/semitran.gi" crc=100494634
RANK_FILTER_LIST  := [ 23514053, 17, 23514053, 17, 57067990, 18, 2070810, 8, 
  58745145, 14, 8572100, 13, 15180905, 18, 8572100, 13, 1, 0, 50330914, 15 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/semitran.gi", 100494634 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/semitran.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/semitran.gi");
elif COM_RESULT = 3  then
Revision.semitran_gi:="@(#)$Id: semitran.gi,v 4.11 2002/04/15 10:05:22 sal Exp $";
InstallTrueMethod(IsTransformationMonoid,IsMonoid and IsTransformationCollection);
InstallMethod(IsTransformationMonoid,"for a transformation semigroup",true,[IsTransformationSemigroup and HasGeneratorsOfSemigroup],0,COM_FUN(1));
InstallMethod(AsMonoid,"for transformation semigroup",true,[IsTransformationSemigroup and HasGeneratorsOfSemigroup],0,COM_FUN(2));
InstallTrueMethod(IsFinite,IsTransformationSemigroup);
InstallMethod(DegreeOfTransformationSemigroup,"degree of a trans semigroup",true,[IsTransformationSemigroup],0,COM_FUN(3));
InstallOtherMethod(IsomorphismPermGroup,"for a Green's group H class of a semigroup",true,[IsGreensHClass and IsEquivalenceClass],0,COM_FUN(4));
InstallMethod(IsomorphismTransformationSemigroup,"for a generic semigroup with multiplicative neutral element",true,[IsSemigroup and HasMultiplicativeNeutralElement],0,COM_FUN(5));
InstallMethod(IsomorphismTransformationSemigroup,"for a generic semigroup",true,[IsSemigroup],0,COM_FUN(6));
InstallMethod(IsomorphismTransformationSemigroup,"for a semigroup of general mappings",true,[IsSemigroup and IsGeneralMappingCollection and HasGeneratorsOfSemigroup],0,COM_FUN(7));
InstallGlobalFunction(FullTransformationSemigroup,COM_FUN(8));
InstallMethod(IsFullTransformationSemigroup,"for semigroups",true,[IsSemigroup],0,COM_FUN(9));
InstallMethod(\in,"for full transformation semigroups",true,[IsObject,IsFullTransformationSemigroup],0,COM_FUN(10));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/semitran.gi"

#F  file="lib/reesmat.gi" crc=-132233884
RANK_FILTER_LIST  := [ 3806291, 14, 3806291, 14, 3806291, 14, 3806291, 14, 
  45232277, 15, 45232277, 15, 45232277, 15, 45232277, 15, 17790268, 15, 
  4052190, 15, 43413563, 8, 45218358, 17, 3792372, 16, 45218358, 17, 3792372, 
  16, 34175468, 5, 57372691, 4, 45232277, 15, 3806291, 14, 45232277, 15, 
  3806291, 14, 34175468, 5, 34175468, 5, 57372691, 4, 57372691, 4, 34175468, 
  5, 34175468, 5, 57372691, 4, 57372691, 4, 34175468, 5, 34175468, 5, 
  57372691, 4, 57372691, 4 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/reesmat.gi", -132233884 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/reesmat.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/reesmat.gi");
elif COM_RESULT = 3  then
Revision.reesmat_gi:="@(#)$Id: reesmat.gi,v 4.21 2003/12/12 09:23:02 gap Exp $";
DeclareRepresentation("IsReesMatrixSemigroupElementRep",IsComponentObjectRep and IsAttributeStoringRep,rec());
InstallGlobalFunction(ReesMatrixSemigroupElement,COM_FUN(1));
InstallGlobalFunction(ReesZeroMatrixSemigroupElement,COM_FUN(2));
InstallMethod(SandwichMatrixOfReesZeroMatrixSemigroup,"for a subsemigroup of a Rees zero matrix semigroup",[IsSubsemigroupReesZeroMatrixSemigroup],COM_FUN(3));
InstallMethod(RowsOfReesZeroMatrixSemigroup,"for a subsemigroup of a Rees zero matrix semigroup",[IsSubsemigroupReesZeroMatrixSemigroup],COM_FUN(4));
InstallMethod(ColumnsOfReesZeroMatrixSemigroup,"for a subsemigroup of a Rees zero matrix semigroup",[IsSubsemigroupReesZeroMatrixSemigroup],COM_FUN(5));
InstallMethod(UnderlyingSemigroupOfReesZeroMatrixSemigroup,"for a subsemigroup of a Rees zero matrix semigroup",[IsSubsemigroupReesZeroMatrixSemigroup],COM_FUN(6));
InstallMethod(SandwichMatrixOfReesMatrixSemigroup,"for a subsemigroup of a Rees matrix semigroup",[IsSubsemigroupReesMatrixSemigroup],COM_FUN(7));
InstallMethod(RowsOfReesMatrixSemigroup,"for a subsemigroup of a Rees matrix semigroup",[IsSubsemigroupReesMatrixSemigroup],COM_FUN(8));
InstallMethod(ColumnsOfReesMatrixSemigroup,"for a subsemigroup of a Rees matrix semigroup",[IsSubsemigroupReesMatrixSemigroup],COM_FUN(9));
InstallMethod(UnderlyingSemigroupOfReesMatrixSemigroup,"for a subsemigroup of a Rees matrix semigroup",[IsSubsemigroupReesMatrixSemigroup],COM_FUN(10));
InstallGlobalFunction(ReesMatrixSemigroup,COM_FUN(11));
InstallGlobalFunction(ReesZeroMatrixSemigroup,COM_FUN(12));
BindGlobal("BuildIsomorphismReesMatrixSemigroupWithMap",COM_FUN(13));
InstallMethod(IsomorphismReesMatrixSemigroup,"for a finite simple semigroup",[IsSimpleSemigroup],COM_FUN(14));
InstallMethod(IsomorphismReesMatrixSemigroup,"for a finite 0-simple semigroup",[IsZeroSimpleSemigroup],COM_FUN(15));
InstallMethod(AssociatedReesMatrixSemigroupOfDClass,"for d class",[IsGreensDClass],COM_FUN(16));
BindGlobal("ReesMatrixSemigroupEnumeratorGetElement",COM_FUN(17));
BindGlobal("ReesZeroMatrixSemigroupEnumeratorGetElement",COM_FUN(18));
BindGlobal("ElementNumber_ReesMatrixSemigroupEnumerator",COM_FUN(19));
BindGlobal("IsBound_ReesMatrixSemigroupEnumerator",COM_FUN(20));
InstallMethod(Enumerator,"for a Rees matrix semigroup",[IsReesMatrixSemigroup],COM_FUN(21));
InstallMethod(Enumerator,"for a Rees zero matrix semigroup",[IsReesZeroMatrixSemigroup],COM_FUN(22));
InstallMethod(Size,"for a Rees matrix semigroup",[IsReesMatrixSemigroup],COM_FUN(23));
InstallMethod(Size,"for a Rees zero matrix semigroup",[IsReesZeroMatrixSemigroup],COM_FUN(24));
InstallMethod(PrintObj,"for elements of Rees matrix semigroups",[IsReesMatrixSemigroupElement],COM_FUN(25));
InstallMethod(PrintObj,"for elements of Rees zero matrix semigroups",[IsReesZeroMatrixSemigroupElement],COM_FUN(26));
InstallMethod(ViewObj,"for Rees matrix semigroups",[IsSubsemigroupReesMatrixSemigroup],COM_FUN(27));
InstallMethod(ViewObj,"for Rees zero matrix semigroups",[IsSubsemigroupReesZeroMatrixSemigroup],COM_FUN(28));
InstallMethod(PrintObj,"for Rees matrix semigroups",[IsSubsemigroupReesMatrixSemigroup],COM_FUN(29));
InstallMethod(PrintObj,"for Rees zero matrix semigroups",[IsSubsemigroupReesZeroMatrixSemigroup],COM_FUN(30));
InstallMethod(\*,"for two elements of a Rees matrix semigroup",IsIdenticalObj,[IsReesMatrixSemigroupElement,IsReesMatrixSemigroupElement],0,COM_FUN(31));
InstallMethod(\*,"for two elements of a Rees zero matrix semigroup",IsIdenticalObj,[IsReesZeroMatrixSemigroupElement,IsReesZeroMatrixSemigroupElement],0,COM_FUN(32));
InstallMethod(\<,"for two elements of a Rees matrix semigroup",IsIdenticalObj,[IsReesMatrixSemigroupElement,IsReesMatrixSemigroupElement],0,COM_FUN(33));
InstallMethod(\<,"for two elements of a Rees zero matrix semigroup",IsIdenticalObj,[IsReesZeroMatrixSemigroupElement,IsReesZeroMatrixSemigroupElement],0,COM_FUN(34));
InstallMethod(\=,"for two elements of a Rees matrix semigroup",IsIdenticalObj,[IsReesMatrixSemigroupElement,IsReesMatrixSemigroupElement],COM_FUN(35));
InstallMethod(\=,"for two elements of a Rees zero matrix semigroup",IsIdenticalObj,[IsReesZeroMatrixSemigroupElement,IsReesZeroMatrixSemigroupElement],COM_FUN(36));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/reesmat.gi"

#F  file="lib/semiquo.gi" crc=-58365229
RANK_FILTER_LIST  := [ 8572100, 13, 14977290, 32, 31194672, 14 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/semiquo.gi", -58365229 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/semiquo.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/semiquo.gi");
elif COM_RESULT = 3  then
Revision.semiquo_gi:="@(#)$Id: semiquo.gi,v 4.13 2002/04/15 10:05:22 sal Exp $";
InstallGlobalFunction(HomomorphismQuotientSemigroup,COM_FUN(1));
InstallMethod(HomomorphismFactorSemigroup,"for a semigroup and a congruence",true,[IsSemigroup,IsSemigroupCongruence],0,COM_FUN(2));
InstallMethod(ViewObj,"for a quotient semigroup with generators",true,[IsQuotientSemigroup],0,COM_FUN(3));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/semiquo.gi"

#F  file="lib/proto.gi" crc=-108208693
RANK_FILTER_LIST  := [  ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/proto.gi", -108208693 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/proto.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/proto.gi");
elif COM_RESULT = 3  then
Revision.proto_gi:="@(#)$Id: proto.gi,v 4.4 2002/04/15 10:05:13 sal Exp $";
InstallGlobalFunction(ArithmeticElementCreator,COM_FUN(1));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/proto.gi"

#F  file="lib/orders.gi" crc=-80929785
RANK_FILTER_LIST  := [ 1985, 1, 25165015, 1, 1985, 1, 5, 1, 1985, 1, 5, 1, 
  8193, 2, 1985, 1, 5, 1, 1985, 1, 5, 1, 8193, 2, 59852609, 2, 27430364, 2, 
  25165015, 1, 1, 0, 1, 0, 25165015, 1, 1, 0, 1, 0, 25165015, 1, 1, 0, 1, 0, 
  6026984, 2, 6026984, 2, 59481587, 13, 6026984, 2, 8193, 2, 12582043, 18, 
  50331049, 22, 12582043, 18, 59481587, 13, 50331049, 22, 59481587, 13, 
  12582043, 18, 8193, 2, 50331049, 22, 8193, 2, 6026984, 2, 6026984, 2, 
  59481587, 13, 6026984, 2, 8193, 2, 12582043, 18, 50331049, 22, 12582043, 
  18, 59481587, 13, 50331049, 22, 59481587, 13, 12582043, 18, 8193, 2, 
  50331049, 22, 8193, 2, 6026984, 2, 59481587, 13, 8193, 2, 6026984, 2, 8193, 
  2, 8193, 2, 12582043, 18, 59481587, 13, 8193, 2, 50331049, 22, 59481587, 
  13, 8193, 2, 12582043, 18, 8193, 2, 8193, 2, 50331049, 22, 8193, 2, 8193, 
  2, 6026984, 2, 6026984, 2, 59481587, 13, 6026984, 2, 8193, 2, 12582043, 18, 
  50331049, 22, 12582043, 18, 59481587, 13, 50331049, 22, 59481587, 13, 
  12582043, 18, 8193, 2, 50331049, 22, 8193, 2, 6026984, 2, 8193, 2, 6026984, 
  2, 8193, 2, 8193, 2, 6025000, 2, 59481587, 13, 8193, 2, 50331049, 22, 8193, 
  2, 8193, 2, 12582043, 18, 8193, 2, 50331049, 22, 8193, 2, 12582043, 18, 
  8193, 2, 8193, 2, 50331049, 22, 8193, 2, 8193, 2 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/orders.gi", -80929785 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/orders.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/orders.gi");
elif COM_RESULT = 3  then
Revision.orders_gi:="@(#)$Id: orders.gi,v 4.13 2002/04/15 10:05:11 sal Exp $";
InstallMethod(OrderingsFamily,"for a family",true,[IsFamily],0,COM_FUN(1));
InstallMethod(ViewObj,"for an ordering",true,[IsOrdering],0,COM_FUN(2));
BindGlobal("CreateOrderingByLtFunction",COM_FUN(3));
BindGlobal("CreateOrderingByLteqFunction",COM_FUN(4));
InstallMethod(OrderingByLessThanFunctionNC,"for a family and a function",true,[IsFamily,IsFunction],0,COM_FUN(5));
InstallOtherMethod(OrderingByLessThanFunctionNC,"for a family, a function, and a list of properties",true,[IsFamily,IsFunction,IsList],0,COM_FUN(6));
InstallMethod(OrderingByLessThanOrEqualFunctionNC,"for a family and a function",true,[IsFamily,IsFunction],0,COM_FUN(7));
InstallOtherMethod(OrderingByLessThanOrEqualFunctionNC,"for a family, a function, and a list of properties",true,[IsFamily,IsFunction,IsList],0,COM_FUN(8));
InstallMethod(LessThanOrEqualFunction,"for an ordering which has a a LessThanFunction",true,[IsOrdering and HasLessThanFunction],0,COM_FUN(9));
InstallMethod(LessThanFunction,"for an ordering which has a a LessThanOrEqualFunction",true,[IsOrdering and HasLessThanOrEqualFunction],0,COM_FUN(10));
InstallMethod(IsLessThanUnder,"for an ordering ",true,[IsOrdering,IsObject,IsObject],0,COM_FUN(11));
InstallMethod(IsLessThanOrEqualUnder,"for an ordering and two objects ",true,[IsOrdering,IsObject,IsObject],0,COM_FUN(12));
InstallMethod(IsIncomparableUnder,"for an ordering",true,[IsOrdering,IsObject,IsObject],0,COM_FUN(13));
BindGlobal("LexicographicOrderingNC",COM_FUN(14));
InstallOtherMethod(LexicographicOrdering,"for a family of words of a free semigroup or free monoid",true,[IsFamily and IsAssocWordFamily],0,COM_FUN(15));
InstallMethod(LexicographicOrdering,"for a family of words of a free semigroup or free monoid and a list of gener\
ators",true,[IsFamily and IsAssocWordFamily,IsList and IsAssocWordCollection],0,COM_FUN(16));
InstallOtherMethod(LexicographicOrdering,"for a family of words of a free semigroup or free monoid and a list",true,[IsFamily and IsAssocWordFamily,IsList],0,COM_FUN(17));
InstallOtherMethod(LexicographicOrdering,"for a free semigroup",true,[IsFreeSemigroup],0,COM_FUN(18));
InstallOtherMethod(LexicographicOrdering,"for a free monoid",true,[IsFreeMonoid],0,COM_FUN(19));
InstallOtherMethod(LexicographicOrdering,"for a free semigroup and a list of generators",IsElmsColls,[IsFreeSemigroup,IsList and IsAssocWordCollection],0,COM_FUN(20));
InstallOtherMethod(LexicographicOrdering,"for a free monoid and a list of generators",IsElmsColls,[IsFreeMonoid,IsList and IsAssocWordCollection],0,COM_FUN(21));
InstallOtherMethod(LexicographicOrdering,"for a free semigroup and a list",true,[IsFreeSemigroup,IsList],0,COM_FUN(22));
InstallOtherMethod(LexicographicOrdering,"for a free monoid and a list",true,[IsFreeMonoid,IsList],0,COM_FUN(23));
BindGlobal("ShortLexOrderingNC",COM_FUN(24));
InstallOtherMethod(ShortLexOrdering,"for a family of words of a free semigroup or free  monoid",true,[IsFamily and IsAssocWordFamily],0,COM_FUN(25));
InstallMethod(ShortLexOrdering,"for a family of words of a free semigroup or free monoid and a list of gener\
ators",true,[IsFamily and IsAssocWordFamily,IsList and IsAssocWordCollection],0,COM_FUN(26));
InstallOtherMethod(ShortLexOrdering,"for a family of free words of a free semigroup or free  monoid and a list",true,[IsFamily and IsAssocWordFamily,IsList],0,COM_FUN(27));
InstallOtherMethod(ShortLexOrdering,"for a free semigroup",true,[IsFreeSemigroup],0,COM_FUN(28));
InstallOtherMethod(ShortLexOrdering,"for a free monoid",true,[IsFreeMonoid],0,COM_FUN(29));
InstallOtherMethod(ShortLexOrdering,"for a free semigroup and a list of generators in the required order",IsElmsColls,[IsFreeSemigroup,IsList and IsAssocWordCollection],0,COM_FUN(30));
InstallOtherMethod(ShortLexOrdering,"for a free monoid and a list of generators in the required order ",IsElmsColls,[IsFreeMonoid,IsList and IsAssocWordCollection],0,COM_FUN(31));
InstallOtherMethod(ShortLexOrdering,"for a free semigroup and a list",true,[IsFreeSemigroup,IsList],0,COM_FUN(32));
InstallOtherMethod(ShortLexOrdering,"for a free monoid and a list",true,[IsFreeMonoid,IsList],0,COM_FUN(33));
InstallGlobalFunction(IsShortLexLessThanOrEqual,COM_FUN(34));
BindGlobal("WeightLexOrderingNC",COM_FUN(35));
InstallMethod(WeightLexOrdering,"for a family of words of a free semigroup or free monoid, a list of generato\
rs and a list of weights",true,[IsFamily and IsAssocWordFamily,IsList and IsAssocWordCollection,IsList],0,COM_FUN(36));
InstallOtherMethod(WeightLexOrdering,"for a family of words of a free semigroup or free monoid, and two lists",true,[IsFamily and IsAssocWordFamily,IsList,IsList],0,COM_FUN(37));
InstallOtherMethod(WeightLexOrdering,"for a free semigroup, a list of generators and a list of weights",true,[IsFreeSemigroup,IsList and IsAssocWordCollection,IsList],0,COM_FUN(38));
InstallOtherMethod(WeightLexOrdering,"for a free monoid, a list of generators and a list of weights",true,[IsFreeMonoid,IsList and IsAssocWordCollection,IsList],0,COM_FUN(39));
InstallOtherMethod(WeightLexOrdering,"for a free semigroup, a list giving ordering on generators and a list of wei\
ghts",true,[IsFreeSemigroup,IsList,IsList],0,COM_FUN(40));
InstallOtherMethod(WeightLexOrdering,"for a free monoid, a list giving ordering on generators and a list of weight\
s",true,[IsFreeMonoid,IsList,IsList],0,COM_FUN(41));
BindGlobal("BasicWreathProductOrderingNC",COM_FUN(42));
InstallOtherMethod(BasicWreathProductOrdering,"for a family of words of a free semigroup or free monoid and a list",true,[IsAssocWordFamily and IsFamily],0,COM_FUN(43));
InstallMethod(BasicWreathProductOrdering,"for a family of words of a free semigroup or free monoid and a list of gener\
ators",true,[IsAssocWordFamily and IsFamily,IsList and IsAssocWordCollection],0,COM_FUN(44));
InstallMethod(BasicWreathProductOrdering,"for a family of words of a free semigroup or free monoid and a list",true,[IsAssocWordFamily and IsFamily,IsList],0,COM_FUN(45));
InstallOtherMethod(BasicWreathProductOrdering,"for a free semigroup",true,[IsFreeSemigroup],0,COM_FUN(46));
InstallOtherMethod(BasicWreathProductOrdering,"for a free monoid",true,[IsFreeMonoid],0,COM_FUN(47));
InstallOtherMethod(BasicWreathProductOrdering,"for a free semigroup and a list of generators",true,[IsFreeSemigroup,IsList and IsAssocWordCollection],0,COM_FUN(48));
InstallOtherMethod(BasicWreathProductOrdering,"for a free monoid and a list of generators",true,[IsFreeMonoid,IsList and IsAssocWordCollection],0,COM_FUN(49));
InstallOtherMethod(BasicWreathProductOrdering,"for a free semigroup and a list",true,[IsFreeSemigroup,IsList],0,COM_FUN(50));
InstallOtherMethod(BasicWreathProductOrdering,"for a free monoid and a list",true,[IsFreeMonoid,IsList],0,COM_FUN(51));
InstallGlobalFunction(IsBasicWreathLessThanOrEqual,COM_FUN(52));
InstallOtherMethod(WreathProductOrdering,"for a family of words of a free semigroup or free monoid and a list",true,[IsAssocWordFamily and IsFamily,IsList],0,COM_FUN(53));
InstallMethod(WreathProductOrdering,"for a family of words of a free semigroup or free monoid and a list",true,[IsAssocWordFamily and IsFamily,IsList,IsList],0,COM_FUN(54));
InstallOtherMethod(WreathProductOrdering,"for a family of associative words, a list of generators and a list with the \
levels of the generators",true,[IsAssocWordFamily,IsList and IsAssocWordCollection,IsList],0,COM_FUN(55));
InstallOtherMethod(WreathProductOrdering,"for a free monoid and a list",true,[IsFreeMonoid,IsList,IsList],0,COM_FUN(56));
InstallOtherMethod(WreathProductOrdering,"for a free semigroup",true,[IsFreeSemigroup,IsList],0,COM_FUN(57));
InstallOtherMethod(WreathProductOrdering,"for a free monoid",true,[IsFreeMonoid,IsList],0,COM_FUN(58));
InstallOtherMethod(WreathProductOrdering,"for a free semigroup and a list",true,[IsFreeSemigroup,IsList,IsList],0,COM_FUN(59));
InstallOtherMethod(WreathProductOrdering,"for a free monoid and a list",true,[IsFreeMonoid,IsList,IsList],0,COM_FUN(60));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/orders.gi"

#F  file="lib/other.gi" crc=-23912072
RANK_FILTER_LIST  := [ 45271600, 33, 67108760, 5 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/other.gi", -23912072 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/other.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/other.gi");
elif COM_RESULT = 3  then
Revision.other_gi:="@(#)$Id: other.gi,v 4.1 2000/08/17 10:58:08 ahulpke Exp $";
InstallMethod(MagmaInputString,"perm group",true,[IsPermGroup,IsString],0,COM_FUN(1));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/other.gi"

#F  file="lib/gasman.gi" crc=57630443
RANK_FILTER_LIST  := [  ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/gasman.gi", 57630443 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/gasman.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/gasman.gi");
elif COM_RESULT = 3  then
Revision.gasman_gi:="@(#)$Id: gasman.gi,v 4.1.2.1 2004/04/22 15:30:25 gap Exp $";
InstallGlobalFunction(GasmanStatistics,COM_FUN(1));
InstallGlobalFunction(GasmanMessageStatus,COM_FUN(2));
InstallGlobalFunction(SetGasmanMessageStatus,COM_FUN(3));
InstallGlobalFunction(GasmanLimits,COM_FUN(4));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/gasman.gi"

#F  file="lib/utils.gi" crc=64660844
RANK_FILTER_LIST  := [ 8193, 2, 50104931, 6, 8193, 2, 1829479, 17, 17, 18, 
  50104931, 6, 8193, 2, 1829479, 17, 23269910, 25, 11576548, 36, 22893809, 
  34, 11576548, 36, 22893809, 34, 11576548, 36, 22893809, 34, 58412696, 30, 
  58412696, 30, 45271600, 33, 22893809, 34, 22893809, 34, 3481142, 46, 
  56700288, 9, 43327840, 42, 43327840, 42, 6114740, 43, 53660808, 21, 
  22893809, 34, 45271600, 33, 7404493, 29, 3481142, 46, 43746373, 42, 
  28566055, 16, 11576548, 36, 23269910, 25, 22893809, 34, 23269910, 25, 
  22893809, 34, 23269910, 25, 22893809, 34, 23269910, 25 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/utils.gi", 64660844 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/utils.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/utils.gi");
elif COM_RESULT = 3  then
Revision.utils_gi:="@(#)$Id: utils.gi,v 4.14 2002/04/15 10:05:26 sal Exp $";
InstallGlobalFunction(UseSubsetRelationNC,COM_FUN(1));
InstallMethod(ImageUnderWord,"for basic images",true,[IsList,IsWordWithInverse,IsList,IsGroupHomomorphism],0,COM_FUN(2));
InstallMethod(ImageUnderWord,"for integers",true,[IsInt,IsWordWithInverse,IsList,IsGroupHomomorphism],0,COM_FUN(3));
InstallMethod(UnderlyingField,"for vector space",true,[IsVectorSpace],0,COM_FUN(4));
InstallMethod(UnderlyingField,"for matrix algebra",true,[IsAlgebra],0,COM_FUN(5));
InstallMethod(UnderlyingField,"for matrix group",true,[IsFFEMatrixGroup],0,COM_FUN(6));
InstallMethod(MatrixDimension,"for matrix algebra",true,[IsAlgebra],0,COM_FUN(7));
InstallMethod(MatrixDimension,"for matrix group",true,[IsFFEMatrixGroup],0,DimensionOfMatrixGroup);
InstallMethod(UnderlyingVectorSpace,"for matrix algebra",true,[IsAlgebra],0,COM_FUN(8));
InstallMethod(UnderlyingVectorSpace,"for matrix group",true,[IsFFEMatrixGroup],0,COM_FUN(9));
InstallMethod(UnderlyingVectorSpace,"for matrix",true,[IsMatrix],0,COM_FUN(10));
InstallMethod(FixedPointSpace,"for matrix",true,[IsMatrix],0,COM_FUN(11));
InstallMethod(PermMatrixGroup,"for perm group",true,[IsPermGroup],0,COM_FUN(12));
InstallMethod(EnvelopingAlgebra,"for matrix group",true,[IsFFEMatrixGroup],0,COM_FUN(13));
InstallMethod(SpanOfMatrixGroup,"for matrix group",true,[IsFFEMatrixGroup],0,COM_FUN(14));
InstallMethod(IsUniformMatrixGroup,"for cyclic matrix p-group",true,[IsFFEMatrixGroup and IsCyclic and IsPGroup],0,COM_FUN(15));
InstallMethod(PreBasis,"for vector space homomorphisms",true,[IsVectorSpaceHomomorphism],0,COM_FUN(16));
InstallGlobalFunction(PullBack,COM_FUN(17));
InstallGlobalFunction(ImageMat,COM_FUN(18));
InstallGlobalFunction(ExtendToBasis,COM_FUN(19));
InstallGlobalFunction(ProjectionOntoVectorSubspace,COM_FUN(20));
InstallGlobalFunction(IsomorphismToFullRowSpace,COM_FUN(21));
InstallGlobalFunction(ProjectionOntoFullRowSpace,COM_FUN(22));
InstallGlobalFunction(RandomSubprod,COM_FUN(23));
InstallGlobalFunction(RandomNormalSubproduct,COM_FUN(24));
InstallGlobalFunction(RandomCommutatorSubproduct,COM_FUN(25));
InstallMethod(IsCharacteristicMatrixPGroup,"for matrix p-group",true,[IsFFEMatrixGroup and IsPGroup],0,COM_FUN(26));
InstallMethod(IsNoncharacteristicMatrixPGroup,"for matrix p-group",true,[IsFFEMatrixGroup and IsPGroup],0,COM_FUN(27));
InstallImmediateMethod(IsNoncharacteristicMatrixPGroup,IsPGroup and HasIsCharacteristicMatrixPGroup,0,COM_FUN(28));
InstallMethod(SizeUpperBound,"for groups",true,[IsGroup],SUM_FLAGS,COM_FUN(29));
InstallMethod(SizeUpperBound,"for matrix groups",true,[IsFFEMatrixGroup],0,COM_FUN(30));
InstallMethod(SizeUpperBound,"for perm groups",true,[IsPermGroup],0,COM_FUN(31));
InstallGlobalFunction(DecomposeEltIntoPElts,COM_FUN(32));
InstallMethod(PGroupGeneratorsOfAbelianGroup,"for abelian groups",true,[IsGroup and IsAbelian],0,COM_FUN(33));
InstallMethod(GeneratorOfCyclicGroup,"for cyclic matrix p-group",true,[IsFFEMatrixGroup and IsCyclic and IsPGroup],0,COM_FUN(34));
InstallMethod(IndependentGeneratorsOfAbelianMatrixGroup,"for abelian matrix group",true,[IsGroup and IsFFEMatrixGroup and IsAbelian],0,COM_FUN(35));
InstallMethod(IndependentGeneratorsOfAbelianMatrixGroup,"for additive groups",true,[IsAdditiveGroup],0,COM_FUN(36));
InstallGlobalFunction(IsInCenter,COM_FUN(37));
DeclareSynonym("IsInCentre",IsInCenter);
InstallGlobalFunction(UnipotentSubgroup,COM_FUN(38));
InstallMethod(NaturalHomomorphismByInvariantSubspace,"for matrix algebra",true,[IsAlgebra,IsVectorSpace],0,COM_FUN(39));
InstallMethod(NaturalHomomorphismByInvariantSubspace,"for matrix group",true,[IsFFEMatrixGroup,IsVectorSpace],0,COM_FUN(40));
InstallMethod(NaturalHomomorphismByFixedPointSubspace,"for matrix group",true,[IsFFEMatrixGroup,IsVectorSpace],0,COM_FUN(41));
InstallMethod(NaturalHomomorphismByHomVW,"for matrix group",true,[IsFFEMatrixGroup,IsVectorSpace],0,COM_FUN(42));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/utils.gi"

#F  file="lib/quogphom.gi" crc=-78973730
RANK_FILTER_LIST  := [ 1829479, 17, 1829479, 17, 38539970, 18, 63631867, 23, 
  63631867, 23, 63631867, 23, 63631867, 23, 63631867, 23, 38539970, 18, 
  38539970, 18, 38539970, 18, 38539970, 18, 38539970, 18, 38539970, 18, 
  50638373, 46, 23325485, 33, 23325485, 33, 50638373, 46, 38539970, 18, 
  38539970, 18, 38539970, 18, 38539970, 18, 23101411, 47, 23101411, 47, 
  7665924, 21, 23101411, 47, 23101411, 47, 7665924, 21, 47746203, 47, 
  11143308, 47, 38539970, 18, 38539970, 18, 50638373, 46, 50638373, 46, 
  39884237, 21, 39884237, 21, 23101411, 47, 23101411, 47, 60704792, 21, 
  38539970, 18, 38539970, 18, 58824982, 20, 20696653, 49, 20696653, 49, 
  23101411, 47, 23101411, 47, 29392837, 49, 29392837, 49, 23101411, 47, 
  23101411, 47, 23101411, 47, 23101411, 47, 23101411, 47, 23101411, 47, 
  38539970, 18, 38539970, 18, 38539970, 18, 50638373, 46, 39884237, 21, 
  23101411, 47, 38539970, 18, 38539970, 18, 38539970, 18, 38539970, 18, 17, 
  18, 38539970, 18, 38539970, 18, 38539970, 18, 23101411, 47, 15589197, 18, 
  17, 18, 39884237, 21, 17, 18, 39884237, 21, 58824982, 20, 41942189, 46, 
  48233615, 48, 48233615, 48, 56929799, 48, 56929799, 48, 39884749, 21, 
  39884749, 21, 41942189, 46, 17, 18, 41942189, 46, 19663577, 29, 29843786, 
  43, 49346896, 7, 63631867, 23, 63631867, 23 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/quogphom.gi", -78973730 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/quogphom.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/quogphom.gi");
elif COM_RESULT = 3  then
Revision.quogphom_gi:="@(#)$Id: quogphom.gi,v 4.15 2002/08/30 16:09:42 gap Exp $";
InstallMethod(HomCosetFamily,"for homomorphisms",true,[IsGroupHomomorphism],0,COM_FUN(1));
InstallGlobalFunction(HomCoset,[IsGroupHomomorphism,IsAssociativeElement],COM_FUN(2));
InstallGlobalFunction(HomCosetWithImage,COM_FUN(3));
InstallMethod(QuotientGroupHom,"for group homomorphisms",true,[IsGroupHomomorphism],0,COM_FUN(4));
InstallGlobalFunction(QuotientGroupByHomomorphism,COM_FUN(5));
InstallGlobalFunction(QuotientGroupByImages,COM_FUN(6));
InstallGlobalFunction(QuotientGroupByImagesNC,COM_FUN(7));
InstallGlobalFunction(IsTrivialHomCoset,COM_FUN(8));
InstallMethod(Homomorphism,"for hom cosets",true,[IsHomCoset],0,COM_FUN(9));
InstallMethod(Homomorphism,"for quotient groups",true,[IsHomQuotientGroup],0,COM_FUN(10));
InstallMethod(Source,"for quotient groups",true,[IsHomQuotientGroup],0,COM_FUN(11));
InstallMethod(Range,"for quotient groups",true,[IsHomQuotientGroup],0,COM_FUN(12));
InstallMethod(ImagesSource,"for quotient groups",true,[IsHomQuotientGroup],0,COM_FUN(13));
InstallOtherMethod(ONE,"for quotient groups",true,[IsHomQuotientGroup],2*SUM_FLAGS,COM_FUN(14));
InstallMethod(SourceElt,"for hom cosets",true,[IsHomCoset],0,COM_FUN(15));
InstallMethod(ImageElt,"for hom cosets",true,[IsHomCoset],0,COM_FUN(16));
StringImType:=COM_FUN(17);
InstallMethod(ViewObj,"for hom coset",true,[IsHomCoset],0,COM_FUN(18));
InstallMethod(PrintObj,"for hom coset",true,[IsHomCoset],0,COM_FUN(19));
InstallMethod(EQ,"for hom cosets",IsIdenticalObj,[IsHomCoset,IsHomCoset],0,COM_FUN(20));
InstallMethod(EQ,"for hom coset matrix rep or add. rep. and identity",true,[IsHomCosetToMatrix,IsMatrix and IsOne],0,COM_FUN(21));
InstallMethod(EQ,"for hom coset matrix rep or add. rep. and identity",true,[IsMatrix and IsOne,IsHomCosetToMatrix],0,COM_FUN(22));
InstallMethod(LT,"for hom cosets",IsIdenticalObj,[IsHomCoset,IsHomCoset],0,COM_FUN(23));
InstallMethod(ONE,"for hom coset",true,[IsHomCoset],0,COM_FUN(24));
InstallMethod(One,"for hom coset",true,[IsHomCoset],0,COM_FUN(25));
InstallMethod(ONE,"for hom coset in additive rep",true,[IsHomCosetToAdditiveElt],2*SUM_FLAGS,COM_FUN(26));
InstallMethod(One,"for hom coset in additive rep",true,[IsHomCosetToAdditiveElt],2*SUM_FLAGS,COM_FUN(27));
InstallMethod(PROD,"for zero * additive hom coset rep",true,[IsZeroCyc,IsHomCosetToAdditiveElt],SUM_FLAGS,COM_FUN(28));
InstallMethod(PROD,"for additive hom coset rep * zero",true,[IsHomCosetToAdditiveElt,IsZeroCyc],SUM_FLAGS,COM_FUN(29));
InstallMethod(ZeroSameMutability,"for additive hom coset",true,[IsOrdinaryMatrix and IsHomCosetToAdditiveElt],0,COM_FUN(30));
InstallMethod(ZeroMutable,"for additive hom coset",true,[IsObject and IsAdditiveElement and IsOrdinaryMatrix and IsHomCosetToAdditive\
Elt],0,COM_FUN(31));
PROD_HOM_COSET:=COM_FUN(32);
InstallMethod(PROD,"for hom cosets",IsIdenticalObj,[IsHomCoset,IsHomCoset],0,PROD_HOM_COSET);
InstallMethod(PROD,"for hom cosets to matrix groups",IsIdenticalObj,[IsHomCosetToMatrix,IsHomCosetToMatrix],0,PROD_HOM_COSET);
InstallMethod(PROD,"for hom cosets to permutation groups",IsIdenticalObj,[IsHomCosetToPerm,IsHomCosetToPerm],0,PROD_HOM_COSET);
InstallMethod(PROD,"for hom cosets to additive groups",IsIdenticalObj,[IsHomCosetToAdditiveElt,IsHomCosetToAdditiveElt],0,PROD_HOM_COSET);
InstallMethod(PROD,"for vector and hom coset",true,[IsRowVector and IsRingElementList,IsHomCoset],0,COM_FUN(33));
InstallMethod(PROD,"for hom coset and vector",true,[IsHomCoset,IsVector and IsRingElementList],0,COM_FUN(34));
InstallMethod(SUM,"for hom cosets to additive groups",IsIdenticalObj,[IsMatrix and IsHomCosetOfMatrix and IsHomCosetToAdditiveElt,IsMatrix and IsHomCosetOfMatrix and IsHomCosetToAdditiveElt],0,PROD_HOM_COSET);
InstallMethod(SUM,"for hom cosets to additive groups",IsIdenticalObj,[IsHomCosetToAdditiveElt,IsHomCosetToAdditiveElt],0,PROD_HOM_COSET);
InstallMethod(DIFF,"for hom cosets to additive groups",IsIdenticalObj,[IsHomCosetOfMatrix and IsHomCosetToAdditiveElt,IsHomCosetOfMatrix and IsHomCosetToAdditiveElt],0,COM_FUN(35));
InstallMethod(DIFF,"for hom cosets to additive groups",IsIdenticalObj,[IsHomCosetToAdditiveElt,IsHomCosetToAdditiveElt],0,COM_FUN(36));
InstallMethod(AdditiveInverseOp,"unary minus for hom coset in additive rep",tr\
ue,[IsHomCosetToAdditiveElt],0,COM_FUN(37));
InstallMethod(AdditiveInverseOp,"unary minus for hom coset in additive rep",tr\
ue,[IsHomCosetToAdditiveElt],0,COM_FUN(38));
InstallMethod(INV,"unary minus for hom coset in additive rep",true,[IsHomCosetToAdditiveElt],0,COM_FUN(39));
InstallMethod(Inverse,"for unary hom coset in additive rep",true,[IsHomCosetToAdditiveElt],0,COM_FUN(40));
InstallMethod(QUO,"for hom cosets",IsIdenticalObj,[IsHomCoset,IsHomCoset],0,COM_FUN(41));
INV_HOM_COSET:=COM_FUN(42);
InstallMethod(INV,"unary minus for hom coset",true,[IsHomCoset],0,INV_HOM_COSET);
InstallMethod(INV,"for hom cosets to matrix groups",true,[IsHomCosetToMatrix],0,INV_HOM_COSET);
InstallMethod(INV,"for hom cosets to permutation groups",true,[IsHomCosetToPerm],0,INV_HOM_COSET);
InstallMethod(INV,"for hom cosets to additive groups",true,[IsHomCosetToAdditiveElt],0,INV_HOM_COSET);
InstallMethod(Inverse,"for hom coset",true,[IsHomCoset],0,COM_FUN(43));
InstallMethod(POW,"for hom cosets",IsIdenticalObj,[IsHomCoset,IsHomCoset],1,COM_FUN(44));
InstallMethod(POW,"for hom cosets to integer power",true,[IsHomCoset,IsInt],1,COM_FUN(45));
InstallMethod(COMM,"for hom cosets",IsIdenticalObj,[IsHomCoset,IsHomCoset],0,COM_FUN(46));
InstallMethod(Order,"for hom coset",true,[IsHomCoset],NICE_FLAGS,COM_FUN(47));
InstallMethod(Order,"for hom coset in additive rep",true,[IsHomCosetToAdditiveElt],NICE_FLAGS,COM_FUN(48));
InstallMethod(CanonicalElt,"for hom cosets",true,[IsRightCoset and IsHomCoset],0,COM_FUN(49));
InstallMethod(POW,"for integer and perm hom coset",true,[IsInt,IsHomCosetToPerm],0,COM_FUN(50));
InstallMethod(QUO,"for integer and perm hom coset",true,[IsInt,IsHomCosetToPerm],0,COM_FUN(51));
InstallMethod(POW,"for vector and matrix hom coset",true,[IsVector and IsRingElementList,IsMatrix and IsHomCosetToMatrix and IsRingElementTable],0,COM_FUN(52));
InstallMethod(SUM,"for two matrix hom cosets",true,[IsMatrix and IsHomCosetToMatrix and IsHomCosetOfMatrix,IsMatrix and IsHomCosetToMatrix and IsHomCosetOfMatrix],0,COM_FUN(53));
InstallMethod(DIFF,"for two matrix hom cosets",true,[IsHomCosetToMatrix and IsHomCosetOfMatrix,IsHomCosetToMatrix and IsHomCosetOfMatrix],0,COM_FUN(54));
InstallMethod(SmallestMovedPointPerm,"for hom coset to permutation",true,[IsPerm and IsHomCosetToPerm],0,COM_FUN(55));
InstallMethod(LargestMovedPointPerm,"for hom coset to permutation",true,[IsPerm and IsHomCosetToPerm],0,COM_FUN(56));
InstallMethod(ELM_LIST,"for hom coset to matrix",true,[IsMatrix and IsHomCosetToMatrix,IsInt],0,COM_FUN(57));
InstallMethod(Length,"for hom coset to matrix",true,[IsMatrix and IsHomCosetToMatrix],0,COM_FUN(58));
InstallMethod(Length,"for hom coset to tuple",true,[IsTuple and IsHomCosetToTuple],0,COM_FUN(59));
InstallMethod(DefaultFieldOfMatrix,"for hom coset",true,[IsMatrix and IsHomCoset],0,COM_FUN(60));
GroupFromAdditiveGroup:=COM_FUN(61);
InstallMethod(ImagesSet,"for general mapping, and quotient group with bad family relation",true,[IsGeneralMapping,IsHomQuotientGroup],-8,COM_FUN(62));
InstallMethod(PreOrbishProcessing,[IsHomQuotientGroup],COM_FUN(63));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/quogphom.gi"

#F  file="lib/gptransv.gi" crc=-38640320
RANK_FILTER_LIST  := [ 53887212, 5, 53888097, 5, 53888097, 5, 53888097, 5, 
  53888097, 5, 53888097, 5, 53888097, 5, 53887212, 5, 53887212, 5, 53888097, 
  5, 62947299, 4, 53887212, 5, 62947299, 4, 28451495, 6, 28451495, 6, 
  28451495, 6, 28451495, 6, 28450610, 6, 28451495, 6, 28451495, 6, 28450610, 
  6, 62947299, 4, 28450610, 6, 62947299, 4, 26285316, 5, 26285316, 5, 
  26285316, 5, 26285316, 5, 26285316, 5, 26285316, 5, 26285316, 5, 26285316, 
  5, 62947299, 4, 26285316, 5, 62947299, 4, 38035262, 5, 38035262, 5, 
  38035262, 5, 38035262, 5, 38035262, 5, 38035262, 5, 38035262, 5, 62947299, 
  4, 38035262, 5, 62947299, 4, 17923287, 6, 17923287, 6, 17923287, 6, 
  17923287, 6, 17923287, 6, 17923287, 6, 62947299, 4, 17923287, 6, 62947299, 
  4 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/gptransv.gi", -38640320 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/gptransv.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/gptransv.gi");
elif COM_RESULT = 3  then
Revision.gptransv_gi:="@(#)$Id: gptransv.gi,v 4.7 2002/04/15 10:04:43 sal Exp $";
InstallMethod(Size,"for Schreier trees",true,[IsRightTransversal and IsTransvBySchreierTree],0,COM_FUN(1));
InstallMethod(ViewObj,"for Schreier trees",true,[IsTransvBySchreierTree],0,COM_FUN(2));
InstallMethod(PrintObj,"for Schreier trees",true,[IsTransvBySchreierTree],0,COM_FUN(3));
InstallGlobalFunction(SchreierTransversal,COM_FUN(4));
InstallMethod(OrbitGenerators,"for Schreier trees",true,[IsTransvBySchreierTree],0,COM_FUN(5));
InstallMethod(OrbitGeneratorsInv,"for Schreier trees",true,[IsTransvBySchreierTree],0,COM_FUN(6));
InstallMethod(BasePointOfSchreierTransversal,"for Schreier trees",true,[IsTransvBySchreierTree],0,COM_FUN(7));
ApplyGeneratorsToPoint:=COM_FUN(8);
ApplyGeneratorsToPointsList:=COM_FUN(9);
InstallGlobalFunction(ExtendSchreierTransversal,COM_FUN(10));
InstallGlobalFunction(ExtendSchreierTransversalShortCube,COM_FUN(11));
InstallGlobalFunction(ExtendSchreierTransversalShortTree,COM_FUN(12));
InstallGlobalFunction(CompleteSchreierTransversal,COM_FUN(13));
RecurseSchreierTree:=COM_FUN(14);
InstallMethod(One,"for Schreier trees",true,[IsTransvBySchreierTree],NICE_FLAGS,COM_FUN(15));
InstallMethod(Random,"for Schreier trees",true,[IsRightTransversal and IsTransvBySchreierTree],NICE_FLAGS,COM_FUN(16));
InstallMethod(Enumerator,"for Schreier trees",true,[IsRightTransversal and IsTransvBySchreierTree],NICE_FLAGS,COM_FUN(17));
InstallMethod(SiftOneLevel,"for Schreier trees",true,[IsTransvBySchreierTree,IsAssociativeElement],0,COM_FUN(18));
InstallMethod(TransversalElt,"for Schreier trees",true,[IsRightTransversal and IsTransvBySchreierTree,IsAssociativeElement],0,COM_FUN(19));
InstallGlobalFunction(SchreierTreeDepth,COM_FUN(20));
SchreierTreeInternalConsistencyCheck:=COM_FUN(21);
CheckSchreierTreeInternalConsistency:=COM_FUN(22);
InstallGlobalFunction(HomTransversal,COM_FUN(23));
InstallMethod(ViewObj,"for hom transversal",true,[IsTransvByHomomorphism],0,COM_FUN(24));
InstallMethod(PrintObj,"for hom transversals",true,[IsTransvByHomomorphism],0,COM_FUN(25));
InstallMethod(Homomorphism,"for hom transversals",true,[IsTransvByHomomorphism],0,COM_FUN(26));
InstallMethod(ImageGroup,"for hom transversals",true,[IsTransvByHomomorphism],0,COM_FUN(27));
InstallMethod(Size,"for hom transversals",true,[IsRightTransversal and IsTransvByHomomorphism],0,COM_FUN(28));
InstallMethod(Random,"for hom transversals",true,[IsTransvByHomomorphism],NICE_FLAGS,COM_FUN(29));
InstallMethod(Enumerator,"for hom transversals",true,[IsTransvByHomomorphism],NICE_FLAGS,COM_FUN(30));
InstallMethod(TransversalElt,"for hom transversals",true,[IsRightTransversal and IsTransvByHomomorphism,IsAssociativeElement],0,COM_FUN(31));
InstallMethod(SiftOneLevel,"for hom transversals",true,[IsRightTransversal and IsTransvByHomomorphism,IsAssociativeElement],0,COM_FUN(32));
InstallGlobalFunction(DirProdTransversal,COM_FUN(33));
InstallMethod(Projection,"for dir prod transversals",true,[IsTransvByDirProd],0,COM_FUN(34));
InstallMethod(Injection,"for dir prod transversals",true,[IsTransvByDirProd],0,COM_FUN(35));
InstallMethod(ViewObj,"for dir prod transversals",true,[IsTransvByDirProd],0,COM_FUN(36));
InstallMethod(PrintObj,"for dir prod transversals",true,[IsTransvByDirProd],0,COM_FUN(37));
InstallMethod(Size,"for dir prod transversals",true,[IsTransvByDirProd],0,COM_FUN(38));
InstallMethod(Enumerator,"for dir prod transversals",true,[IsTransvByDirProd],0,COM_FUN(39));
InstallMethod(Random,"for dir prod transversals",true,[IsTransvByDirProd],0,COM_FUN(40));
InstallMethod(TransversalElt,"for dir prod transversals",true,[IsTransvByDirProd,IsAssociativeElement],0,COM_FUN(41));
InstallMethod(SiftOneLevel,"for dir prod transversals",true,[IsTransvByDirProd,IsAssociativeElement],0,COM_FUN(42));
InstallGlobalFunction(TransversalByTrivial,COM_FUN(43));
InstallMethod(ViewObj,"for transversal by trivial subgroup",true,[IsTransvByTrivSubgrp],0,COM_FUN(44));
InstallMethod(PrintObj,"for transversal by trivial subgroup",true,[IsTransvByTrivSubgrp],0,COM_FUN(45));
InstallMethod(Enumerator,"for transversal by trivial subgroup",true,[IsTransvByTrivSubgrp],0,COM_FUN(46));
InstallMethod(Iterator,"for transversal by trivial subgroup",true,[IsTransvByTrivSubgrp],0,COM_FUN(47));
InstallMethod(Size,"for transversal by trivial subgroup",true,[IsTransvByTrivSubgrp],0,COM_FUN(48));
InstallMethod(Random,"for transversal by trivial subgroup",true,[IsTransvByTrivSubgrp],0,COM_FUN(49));
InstallMethod(TransversalElt,"for transversal by trivial subgroup",true,[IsTransvByTrivSubgrp,IsAssociativeElement],0,COM_FUN(50));
InstallMethod(SiftOneLevel,"for transversal by trivial subgroup",true,[IsTransvByTrivSubgrp,IsAssociativeElement],0,COM_FUN(51));
InstallGlobalFunction(TransversalBySiftFunction,COM_FUN(52));
InstallMethod(ViewObj,"for transversal by sift subgroup",true,[IsTransvBySiftFunct],0,COM_FUN(53));
InstallMethod(PrintObj,"for transversal by sift subgroup",true,[IsTransvBySiftFunct],0,COM_FUN(54));
InstallMethod(Enumerator,"for transversal by sift subgroup",true,[IsTransvBySiftFunct],0,COM_FUN(55));
InstallMethod(Size,"for transversal by sift subgroup",true,[IsTransvBySiftFunct],0,COM_FUN(56));
InstallMethod(Random,"for transversal by sift subgroup",true,[IsTransvBySiftFunct],0,COM_FUN(57));
InstallMethod(TransversalElt,"for transversal by sift subgroup",true,[IsTransvBySiftFunct,IsAssociativeElement],0,COM_FUN(58));
InstallMethod(SiftOneLevel,"for transversal by sift subgroup",true,[IsTransvBySiftFunct,IsAssociativeElement],0,COM_FUN(59));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/gptransv.gi"

#F  file="lib/grpchain.gi" crc=91275829
RANK_FILTER_LIST  := [ 28888200, 25, 24300095, 23, 60641975, 36, 65767820, 5, 
  24300095, 23, 57853837, 51, 24300095, 23, 24300095, 23, 57853837, 51, 
  24300095, 23, 57853837, 51, 53660808, 21, 58247953, 23, 62947299, 4, 
  58247953, 23, 62947299, 4, 53660808, 21, 62947299, 4, 58247953, 23, 
  38455211, 50, 4901469, 22, 62947299, 4, 4901814, 24, 62947299, 4, 58247953, 
  23, 20105671, 49 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grpchain.gi", 91275829 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grpchain.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grpchain.gi");
elif COM_RESULT = 3  then
Revision.grpchain_gi:="@(#)$Id: grpchain.gi,v 4.9 2002/04/15 10:04:44 sal Exp $";
NthChainSubgroup:=COM_FUN(1);
NthSchreierTransversalOfChainSubgroup:=COM_FUN(2);
NthFundamentalOrbit:=COM_FUN(3);
NthSiftOneLevel:=COM_FUN(4);
SiftedWord:=COM_FUN(5);
CompleteChain:=COM_FUN(6);
InstallMethod(ChainSubgroup,"for chain type groups",true,[IsGroup and IsChainTypeGroup and HasChainSubgroup],NICE_FLAGS,COM_FUN(7));
InstallMethod(ChainSubgroup,"for chain type groups",true,[IsGroup and IsChainTypeGroup],NICE_FLAGS,COM_FUN(8));
InstallMethod(ChainSubgroup,"for chain type groups",true,[IsGroup and IsFFEMatrixGroup and IsChainTypeGroup],NICE_FLAGS+1,COM_FUN(9));
InstallMethod(IN,"for chain type group",true,[IsMultiplicativeElementWithInverse,IsGroup and IsChainTypeGroup],NICE_FLAGS,COM_FUN(10));
InstallMethod(Size,"for chain type group",true,[IsGroup and IsChainTypeGroup and IsTrivial],NICE_FLAGS+10,COM_FUN(11));
InstallMethod(Size,"for chain type group",true,[IsGroup and IsChainTypeGroup],NICE_FLAGS+10,COM_FUN(12));
InstallMethod(Random,"for chain type group",true,[IsGroup and IsChainTypeGroup],NICE_FLAGS,COM_FUN(13));
InstallMethod(Random,"for trivial chain type group",true,[IsGroup and IsChainTypeGroup and IsTrivial],NICE_FLAGS,COM_FUN(14));
InstallMethod(Enumerator,"for chain type group",true,[IsGroup and IsChainTypeGroup],NICE_FLAGS,COM_FUN(15));
InstallMethod(Enumerator,"for trivial chain type group",true,[IsGroup and IsChainTypeGroup and IsTrivial],NICE_FLAGS,COM_FUN(16));
InstallMethod(GeneratingSetIsComplete,"for group",true,[IsGroup],0,COM_FUN(17));
InstallMethod(SiftOneLevel,"for group with chain and element",true,[IsGroup and HasChainSubgroup,IsAssociativeElement],0,COM_FUN(18));
InstallMethod(Sift,"for group with chain and element",true,[IsGroup and HasChainSubgroup,IsAssociativeElement],0,COM_FUN(19));
InstallMethod(Sift,"for group without chain and element",true,[IsGroup,IsAssociativeElement],0,COM_FUN(20));
InstallGlobalFunction(SizeOfChainOfGroup,COM_FUN(21));
InstallGlobalFunction(ChainStatistics,COM_FUN(22));
InstallGlobalFunction(TransversalOfChainSubgroup,COM_FUN(23));
InstallGlobalFunction(HasChainHomomorphicImage,COM_FUN(24));
InstallGlobalFunction(ChainHomomorphicImage,COM_FUN(25));
InstallGlobalFunction(StrongGens,COM_FUN(26));
InstallGlobalFunction(ChainSubgroupByStabiliser,COM_FUN(27));
ChainSubgroupByStabilizer:=ChainSubgroupByStabiliser;
InstallMethod(BaseOfGroup,"for group with chain",true,[IsGroup and HasChainSubgroup],40,COM_FUN(28));
InstallMethod(BaseOfGroup,"for trivial group",true,[IsTrivial and IsGroup and IsInChain],40,COM_FUN(29));
InstallMethod(ExtendedGroup,"for group in chain",true,[IsGroup and IsInChain,IsAssociativeElement],0,COM_FUN(30));
InstallMethod(ExtendedGroup,"for group in chain",true,[IsGroup and IsInChain and GeneratingSetIsComplete,IsAssociativeElement],0,COM_FUN(31));
InstallMethod(OrbitGeneratorsOfGroup,"for groups with chain",true,[IsGroup and HasChainSubgroup],0,COM_FUN(32));
InstallMethod(OrbitGeneratorsOfGroup,"for trivial groups",true,[IsGroup and IsTrivial],0,COM_FUN(33));
InstallGlobalFunction(ChainSubgroupByHomomorphism,COM_FUN(34));
InstallGlobalFunction(ChainSubgroupByProjectionFunction,COM_FUN(35));
InstallGlobalFunction(QuotientGroupByChainHomomorphicImage,COM_FUN(36));
InstallGlobalFunction(ChainSubgroupByDirectProduct,COM_FUN(37));
InstallGlobalFunction(ChainSubgroupByPSubgroupOfAbelian,COM_FUN(38));
InstallGlobalFunction(ChainSubgroupByTrivialSubgroup,COM_FUN(39));
InstallGlobalFunction(ChainSubgroupBySiftFunction,COM_FUN(40));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grpchain.gi"

#F  file="lib/rss.gi" crc=131917315
RANK_FILTER_LIST  := [ 22893809, 34, 22893809, 34 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/rss.gi", 131917315 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/rss.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/rss.gi");
elif COM_RESULT = 3  then
Revision.rss_gi:="@(#)$Id: rss.gi,v 4.6 2002/04/15 10:05:15 sal Exp $";
InstallGlobalFunction(SetValueOption,COM_FUN(1));
InstallGlobalFunction(ReturnPopOptions,COM_FUN(2));
InstallGlobalFunction(RandomSchreierSims,COM_FUN(3));
InstallGlobalFunction(ChangedBaseGroup,COM_FUN(4));
InstallGlobalFunction(RSSDefaultOptions,COM_FUN(5));
InstallGlobalFunction(SiftForStrongGenerator,COM_FUN(6));
InstallGlobalFunction(StopNumConsecSiftToOne,COM_FUN(7));
InstallGlobalFunction(StopNumSift,COM_FUN(8));
InstallGlobalFunction(StopSize,COM_FUN(9));
InstallGlobalFunction(ReturnNextBasePoint,COM_FUN(10));
InstallGlobalFunction(PermNewBasePoint,COM_FUN(11));
InstallGlobalFunction(MatrixNewBasePoint,COM_FUN(12));
InstallMethod(EspaceBasePoints,"for a matrix group",true,[IsFFEMatrixGroup],0,COM_FUN(13));
InstallMethod(EvectBasePoints,"for a matrix group",true,[IsFFEMatrixGroup],0,COM_FUN(14));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/rss.gi"

#F  file="lib/basicim.gi" crc=60167661
RANK_FILTER_LIST  := [ 50104931, 6, 8193, 2, 8193, 2, 8193, 2, 1829479, 17, 
  53660328, 25, 62947299, 4, 58247953, 23, 1829479, 17, 8193, 2, 62947299, 4, 
  67108160, 5, 67108160, 5, 67108160, 5, 67108160, 5, 67108160, 5, 67108160, 
  5, 67108160, 5, 67108160, 5, 67108160, 5, 67108160, 5, 67108160, 5, 
  67108160, 5, 67108160, 5, 67108160, 5, 67108160, 5, 67108160, 5, 67108160, 
  5, 67108160, 5, 67108160, 5, 67108160, 5, 67108160, 5, 67108160, 5, 
  67108160, 5, 67108160, 5, 17, 18, 17, 18, 67108160, 5, 67108160, 5, 
  67108160, 5, 24300095, 23 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/basicim.gi", 60167661 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/basicim.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/basicim.gi");
elif COM_RESULT = 3  then
Revision.basicim_gi:="@(#)$Id: basicim.gi,v 4.3 2002/04/15 10:04:26 sal Exp $";
InstallTrueMethod(IsGeneratorsOfMagmaWithInverses,IsBasicImageEltRepCollection\
);
InstallGlobalFunction(ConvertToSiftGroup,COM_FUN(1));
InstallGlobalFunction(BasicImageGroup,COM_FUN(2));
InstallMethod(BasicImageGroupElement,"for basic image group elt",true,[IsWordWithInverse,IsList,IsList,IsList,IsGroupHomomorphism],0,COM_FUN(3));
InstallMethod(BasicImageGroupElement,"for basic image group elt",true,[IsBasicImageGroup,IsAssociativeElement],0,COM_FUN(4));
InstallMethod(BasicImageGroupElement,"for basic image group elt",true,[IsGroup and HasChainSubgroup,IsGroupHomomorphism,IsList,IsAssociativeElement\
],0,COM_FUN(5));
InstallMethod(Word,"for basic image group elt",true,[IsBasicImageEltRep],0,COM_FUN(6));
InstallMethod(BaseOfElt,"for basic image group elt",true,[IsBasicImageEltRep],0,COM_FUN(7));
InstallMethod(BaseImage,"for basic image group elt",true,[IsBasicImageEltRep],0,COM_FUN(8));
InstallMethod(OrbitGenerators,"for basic image group elt",true,[IsBasicImageEltRep],0,COM_FUN(9));
InstallMethod(HomFromFree,"for basic image group elt",true,[IsBasicImageEltRep],0,COM_FUN(10));
InstallMethod(FreeGroupOfElt,"for basic image group elt",true,[IsBasicImageEltRep],0,COM_FUN(11));
InstallMethod(ViewObj,"for basic image group elt",true,[IsBasicImageEltRep],0,COM_FUN(12));
InstallMethod(PrintObj,"for basic image group elt",true,[IsBasicImageEltRep],0,COM_FUN(13));
InstallMethod(ConvertBasicImageGroupElement,"for basic image elt",true,[IsBasicImageEltRep],0,COM_FUN(14));
InstallMethod(EQ,"for basic image group elts",true,[IsBasicImageEltRep,IsBasicImageEltRep],0,COM_FUN(15));
InstallMethod(LT,"for basic image group elts",true,[IsBasicImageEltRep,IsBasicImageEltRep],0,COM_FUN(16));
InstallMethod(ONE,"for basic image group elt",true,[IsBasicImageEltRep],0,COM_FUN(17));
InstallMethod(One,"for basic image group elt",true,[IsBasicImageEltRep],0,COM_FUN(18));
InstallMethod(PROD,"for basic image group elts",true,[IsBasicImageEltRep,IsBasicImageEltRep],0,COM_FUN(19));
InstallMethod(INV,"for basic image group elt",true,[IsBasicImageEltRep],0,COM_FUN(20));
InstallMethod(Inverse,"for basic image group elt",true,[IsBasicImageEltRep],0,COM_FUN(21));
InstallMethod(QUO,"for basic image group elts",true,[IsBasicImageEltRep,IsBasicImageEltRep],0,COM_FUN(22));
InstallMethod(POW,"for basic image group elts",true,[IsBasicImageEltRep,IsBasicImageEltRep],1,COM_FUN(23));
InstallMethod(POW,"for basic image group elt and integer",true,[IsBasicImageEltRep,IsInt],1,COM_FUN(24));
InstallMethod(POW,"for integer and basic image group elt",true,[IsInt,IsBasicImageEltRep],1,COM_FUN(25));
InstallMethod(COMM,"for basic image group elts",true,[IsBasicImageEltRep,IsBasicImageEltRep],0,COM_FUN(26));
InstallMethod(Presentation,"for chain type groups",true,[IsGroup and IsChainTypeGroup],0,COM_FUN(27));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/basicim.gi"

#F  file="lib/solmxgrp.gi" crc=68602053
RANK_FILTER_LIST  := [ 53660808, 21, 41048155, 29, 7404493, 29, 32754749, 48, 
  28566055, 16, 1987750, 48, 1987750, 48, 64180404, 44, 3481142, 46, 
  43746373, 42, 64180404, 44, 33553743, 7, 35542345, 46, 40891200, 46, 
  22893809, 34, 3481142, 46, 17375552, 31, 3481142, 46, 358717, 32, 3481142, 
  46, 3481142, 46, 3481142, 46, 65767820, 5, 3481142, 46, 57134628, 47, 
  65767820, 5, 1987750, 48, 1987750, 48, 23101411, 47, 43746373, 42, 
  32754749, 48, 53660808, 21, 53660808, 21, 36461010, 27 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/solmxgrp.gi", 68602053 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/solmxgrp.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/solmxgrp.gi");
elif COM_RESULT = 3  then
Revision.solmxgrp_gi:="@(#)$Id: solmxgrp.gi,v 4.16 2002/04/15 10:05:22 sal Exp $";
InstallGlobalFunction(SetIsCyclicWithSize,COM_FUN(1));
InstallGlobalFunction(ConjugateMatrixActionToLinearAction,COM_FUN(2));
ConjugateMatrixGroupToLinearGroup:=COM_FUN(3);
InstallMethod(MakeHomChain,"for arbitrary group",true,[IsGroup],0,COM_FUN(4));
InstallMethod(MakeHomChain,"for nilpotent group with chain",true,[IsGroup and IsNilpotentGroup and HasChainSubgroup],0,COM_FUN(5));
InstallMethod(MakeHomChain,"for abelian group",true,[IsGroup and IsAbelian],0,COM_FUN(6));
InstallGlobalFunction(BasisOfHomCosetAddMatrixGroupFnc,COM_FUN(7));
InstallMethod(BasisOfHomCosetAddMatrixGroup,"by linear algebra",true,[IsGroup and IsQuotientToAdditiveGroup],0,BasisOfHomCosetAddMatrixGroupFnc);
InstallMethod(BasisOfHomCosetAddMatrixGroup,"by linear algebra",true,[IsAdditiveGroup],0,BasisOfHomCosetAddMatrixGroupFnc);
InstallGlobalFunction(SiftVector,COM_FUN(8));
InstallMethod(SiftFunction,"for abelian quotient to additive group (by lin. algebra)",true,[IsGroup and IsFFEMatrixGroup and IsQuotientToAdditiveGroup],0,COM_FUN(9));
InstallMethod(MakeHomChain,"by linear algebra",true,[IsGroup and IsFFEMatrixGroup and IsQuotientToAdditiveGroup],0,COM_FUN(10));
ManageableQuotientOfAbelianPGroup:=COM_FUN(11);
InstallMethod(MakeHomChain,"for abelian p-group",true,[IsGroup and IsFFEMatrixGroup and IsAbelian and IsPGroup],0,COM_FUN(12));
InstallMethod(MakeHomChain,"for cyclic p-groups",true,[IsGroup and IsFFEMatrixGroup and IsCyclic and IsPGroup],0,COM_FUN(13));
InstallMethod(InvariantSubspaceOrCyclicGroup,"for abelian group",true,[IsFFEMatrixGroup and IsAbelian],0,COM_FUN(14));
InstallMethod(InvariantSubspaceOrCyclicGroup,"for abelian p-group",true,[IsFFEMatrixGroup and IsAbelian and IsPGroup],0,COM_FUN(15));
InstallMethod(InvariantSubspaceOrCyclicGroup,"for trivial group",true,[IsTrivial],0,COM_FUN(16));
InstallMethod(InvariantSubspaceOrCyclicGroup,"for abelian char. p-group",true,[IsFFEMatrixGroup and IsAbelian and IsPGroup and IsCharacteristicMatrixPGroup\
],0,COM_FUN(17));
InstallMethod(InvariantSubspaceOrCyclicGroup,"for abelian non-char. p-group",true,[IsFFEMatrixGroup and IsAbelian and IsPGroup and IsNoncharacteristicMatrixPGr\
oup],0,COM_FUN(18));
InstallMethod(InvariantSubspaceOrUniformCyclicPGroup,"for matrix group",true,[IsFFEMatrixGroup],0,COM_FUN(19));
InstallMethod(SiftFunction,"for cyclic matrix p-groups",true,[IsGroup and IsFFEMatrixGroup and IsCyclic and IsPGroup],0,COM_FUN(20));
NormalClosureByChain:=COM_FUN(21);
InstallMethod(KernelOfHomQuotientGroup,"for abelian quotient group via presentation",true,[IsHomQuotientGroup and IsAbelian],0,COM_FUN(22));
CanFindGeneratorOfCyclicGroup:=COM_FUN(23);
InstallMethod(Size,"for cyclic matrix p-group",true,[IsFFEMatrixGroup and IsCyclic and IsPGroup],NICE_FLAGS+10,COM_FUN(24));
InstallMethod(Size,"for cyclic 1-gen. group",true,[IsGroup and IsCyclic and HasGeneratorOfCyclicGroup],NICE_FLAGS+10,COM_FUN(25));
InstallMethod(Random,"for cyclic matrix p-group",true,[IsFFEMatrixGroup and IsCyclic and IsPGroup],0,COM_FUN(26));
InstallMethod(TrivialQuotientSubgroup,"for cyclic matrix p-group via presentation (assuming sift fnc)",true,[IsFFEMatrixGroup and IsCyclic and IsPGroup],0,COM_FUN(27));
InstallMethod(Enumerator,"for cyclic matrix p-group",true,[IsFFEMatrixGroup and IsCyclic and IsPGroup],NICE_FLAGS,COM_FUN(28));
InstallMethod(IN,"for cyclic matrix p-group",true,[IsMultiplicativeElementWithInverse,IsFFEMatrixGroup and IsCyclic and IsPGroup],NICE_FLAGS,COM_FUN(29));
InstallMethod(Sift,"for cyclic matrix p-group",true,[IsFFEMatrixGroup and IsCyclic and IsPGroup and HasGeneratorOfCyclicGroup,IsMultiplicativeElementWithInverse],0,COM_FUN(30));
EnumerateIndependentAbelianProducts:=COM_FUN(31);
InstallMethod(Enumerator,"for quotient to additive group",true,[IsGroup and IsFFEMatrixGroup and IsQuotientToAdditiveGroup],2*SUM_FLAGS+46,COM_FUN(32));
InstallMethod(Sift,"for quotient to additive group",true,[IsGroup and IsFFEMatrixGroup and IsQuotientToAdditiveGroup,IsHomCosetToAdditiveElt],0,COM_FUN(33));
InstallMethod(TrivialQuotientSubgroup,"for abelian matrix group via presentation (assuming Sift fnc)",true,[IsFFEMatrixGroup and IsAbelian],0,COM_FUN(34));
InstallMethod(TrivialQuotientSubgroup,"for additive quotient group via presentation",true,[IsQuotientToAdditiveGroup],0,COM_FUN(35));
InstallMethod(CanFindNilpotentClassTwoElement,"compute elt or fail",true,[IsGroup],0,COM_FUN(36));
InstallMethod(NilpotentClassTwoElement,"by calling CanFindNilpotentClassTwoElement()",true,[IsGroup],0,COM_FUN(37));
InstallGlobalFunction(NaturalHomomorphismByNilpotentClassTwoElement,COM_FUN(38));
ManageableQuotientOfNilpotentGroup:=COM_FUN(39);
InstallMethod(MakeHomChain,"for nilpotent group",true,[IsGroup and IsNilpotentGroup],0,COM_FUN(40));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/solmxgrp.gi"

