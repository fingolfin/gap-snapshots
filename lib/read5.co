#I  file="lib/read5.g"

#F  file="lib/rvecempt.gi" crc=-119755004
RANK_FILTER_LIST  := [ 1985, 1, 19746956, 28, 19746956, 28, 19746956, 28, 
  7665940, 19, 19746956, 28, 19746956, 28, 8126465, 2, 8126465, 2, 19746956, 
  28, 19746956, 28, 19746956, 28, 19746956, 28, 19746956, 28, 32505602, 3, 
  19746956, 28, 19746956, 28, 32505602, 3, 17, 18, 19746956, 28, 19746956, 
  28, 17, 18, 19746956, 28, 19746956, 28 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/rvecempt.gi", -119755004 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/rvecempt.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/rvecempt.gi");
elif COM_RESULT = 3  then
Revision.rvecempt_gi:="@(#)$Id: rvecempt.gi,v 4.10 2002/04/15 10:05:15 sal Exp $";
DeclareRepresentation("IsEmptyRowVectorRep",IsPositionalObjectRep and IsConstantTimeAccessList,[]);
InstallMethod(EmptyRowVector,"for a family",true,[IsFamily],0,COM_FUN(1));
InstallMethod(ViewObj,"for an empty row vector",true,[IsRowVector and IsEmpty and IsEmptyRowVectorRep],0,COM_FUN(2));
InstallMethod(Length,"for an empty row vector",true,[IsRowVector and IsEmpty and IsEmptyRowVectorRep],0,COM_FUN(3));
InstallMethod(IsBound\[\],"for an empty row vector, and a positive integer",true,[IsRowVector and IsEmpty and IsEmptyRowVectorRep,IsPosInt],0,COM_FUN(4));
InstallMethod(ShallowCopy,"for an empty row vector",true,[IsRowVector and IsEmpty and IsEmptyRowVectorRep],0,COM_FUN(5));
InstallMethod(\=,"for an empty row vector, and a collection in the same family",IsIdenticalObj,[IsRowVector and IsEmpty and IsEmptyRowVectorRep,IsCollection],0,COM_FUN(6));
InstallMethod(\=,"for a collection, and an empty row vector in the same family",IsIdenticalObj,[IsCollection,IsRowVector and IsEmpty and IsEmptyRowVectorRep],0,COM_FUN(7));
InstallMethod(\+,"for two empty row vectors in the same family",IsIdenticalObj,[IsRowVector and IsEmpty and IsEmptyRowVectorRep,IsRowVector and IsEmpty and IsEmptyRowVectorRep],0,COM_FUN(8));
InstallMethod(AdditiveInverseOp,"for empty row vector",true,[IsRowVector and IsEmpty and IsEmptyRowVectorRep],0,IdFunc);
InstallMethod(ZeroOp,"for empty row vector",true,[IsRowVector and IsEmpty and IsEmptyRowVectorRep],0,IdFunc);
InstallMethod(\*,"for multiplicative element, and empty row vector",IsElmsColls,[IsMultiplicativeElement,IsRowVector and IsEmpty and IsEmptyRowVectorRep],0,COM_FUN(9));
InstallMethod(\*,"for empty row vector, and multiplicative element",IsCollsElms,[IsRowVector and IsEmpty and IsEmptyRowVectorRep,IsMultiplicativeElement],0,COM_FUN(10));
InstallMethod(\*,"for integer, and empty row vector",true,[IsInt,IsRowVector and IsEmpty and IsEmptyRowVectorRep],0,COM_FUN(11));
InstallMethod(\*,"for empty row vector, and integer",true,[IsRowVector and IsEmpty and IsEmptyRowVectorRep,IsInt],0,COM_FUN(12));
InstallMethod(\*,"for two empty row vectors in the same family",IsIdenticalObj,[IsRowVector and IsEmpty and IsEmptyRowVectorRep,IsRowVector and IsEmpty and IsEmptyRowVectorRep],0,COM_FUN(13));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/rvecempt.gi"

#F  file="lib/ratfun1.gi" crc=89076896
RANK_FILTER_LIST  := [  ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/ratfun1.gi", 89076896 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/ratfun1.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/ratfun1.gi");
elif COM_RESULT = 3  then
Revision.ratfun1_gi:="@(#)$Id: ratfun1.gi,v 4.17.2.2 2007/07/24 17:07:02 gap Exp $";
LAUR_POL_BY_EXTREP:=COM_FUN(1);
EXTREP_POLYNOMIAL_LAURENT:=COM_FUN(2);
UNIVARTEST_RATFUN:=COM_FUN(3);
EXTREP_COEFFS_LAURENT:=COM_FUN(4);
UNIV_FUNC_BY_EXTREP:=COM_FUN(5);
MONOM_REV_LEX:=COM_FUN(6);
ZIPPED_SUM_LISTS_LIB:=COM_FUN(7);
ZIPPED_PRODUCT_LISTS:=COM_FUN(8);
BindGlobal("ZippedListQuotient",COM_FUN(9));
ADDITIVE_INV_RATFUN:=COM_FUN(10);
ADDITIVE_INV_POLYNOMIAL:=COM_FUN(11);
SMALLER_RATFUN:=COM_FUN(12);
SUM_COEF_POLYNOMIAL:=COM_FUN(13);
QUOTIENT_POLYNOMIALS_EXT:=COM_FUN(14);
SUM_LAURPOLS:=COM_FUN(15);
DIFF_LAURPOLS:=COM_FUN(16);
PRODUCT_LAURPOLS:=COM_FUN(17);
GCD_COEFFS:=COM_FUN(18);
QUOTREM_LAURPOLS_LISTS:=COM_FUN(19);
ADDCOEFFS_GENERIC_3:=COM_FUN(20);
PRODUCT_COEFFS_GENERIC_LISTS:=COM_FUN(21);
REMOVE_OUTER_COEFFS_GENERIC:=COM_FUN(22);
PRODUCT_UNIVFUNCS:=COM_FUN(23);
QUOT_UNIVFUNCS:=COM_FUN(24);
SUM_UNIVFUNCS:=COM_FUN(25);
DIFF_UNIVFUNCS:=COM_FUN(26);
SPECIALIZED_EXTREP_POL:=COM_FUN(27);
TRY_GCD_CANCEL_EXTREP_POL:=COM_FUN(28);
DEGREE_INDET_EXTREP_POL:=COM_FUN(29);
LEAD_COEF_POL_IND_EXTREP:=COM_FUN(30);
POL_COEFFS_POL_EXTREP:=COM_FUN(31);
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/ratfun1.gi"

#F  file="lib/matrix.gi" crc=11065051
RANK_FILTER_LIST  := [ 30225050, 20, 58412696, 30, 58412696, 30, 58412696, 
  30, 41942876, 3, 58412696, 30, 58412696, 30, 52658351, 31, 63198130, 7, 
  52658351, 31, 41951068, 17, 52658351, 31, 58412696, 30, 52658351, 31, 8193, 
  2, 52658351, 31, 52658351, 31, 52658351, 31, 31628240, 40, 58412696, 30, 
  24813784, 47, 58412696, 30, 24813784, 47, 24813784, 47, 58412696, 30, 
  58412696, 30, 7665940, 19, 24813784, 47, 24644793, 32, 7665940, 19, 
  24813784, 47, 24813784, 47, 24644793, 32, 7665940, 19, 24813784, 47, 
  24644793, 32, 7665940, 19, 24813784, 47, 24644793, 32, 7665940, 19, 
  24813784, 47, 24644793, 32, 7665940, 19, 24644793, 32, 9783814, 43, 
  64969216, 43, 58412696, 30, 58412696, 30, 58412696, 30, 58412696, 30, 
  31628240, 40, 43551717, 40, 58412696, 30, 41942876, 3, 58412696, 30, 
  58412696, 30, 41942876, 3, 41942876, 3, 41942876, 3, 24644794, 34, 
  64969217, 45, 58412696, 30, 58412696, 30, 58412696, 30, 40557768, 30, 
  58412697, 32, 6553496, 27, 49151311, 17, 49151311, 17, 40557768, 30, 
  58412696, 30, 58412696, 30, 8193, 2, 33246032, 32, 8193, 2, 58412697, 32, 
  24644793, 32, 24644794, 34, 24644793, 32, 24644794, 34, 24644793, 32, 
  24813784, 47, 58412696, 30, 24813784, 47, 58412696, 30, 24813784, 47, 
  58412696, 30, 24813784, 47, 58412696, 30, 24813784, 47, 58412696, 30, 
  64969216, 43, 58412697, 32, 58412696, 30, 58412697, 32, 58412696, 30, 
  58412696, 30, 58412697, 32, 8193, 2, 8193, 2, 8193, 2, 58412696, 30, 8193, 
  2, 58412696, 30, 58412696, 30, 17, 18, 58412696, 30, 58412696, 30, 
  24644794, 34, 65077941, 14, 24644793, 32, 65077940, 12, 58412696, 30, 
  58412696, 30, 58412697, 32, 41951068, 17, 58412696, 30, 7665940, 19, 
  58412696, 30, 58412696, 30, 4063233, 1, 58412696, 30, 58412696, 30, 
  30408555, 2, 54525338, 2, 15204278, 2, 60817109, 2, 17, 18, 8193, 2, 17, 
  18, 17, 18, 30408555, 2, 17, 18, 17, 18, 54525338, 2, 17, 18, 30408555, 2, 
  17, 18, 54525338, 2, 8193, 2, 8193, 2, 8193, 2, 8193, 2, 8193, 2, 8193, 2, 
  8193, 2, 8193, 2, 8193, 2, 8193, 2, 8193, 2, 8193, 2, 8193, 2 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/matrix.gi", 11065051 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/matrix.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/matrix.gi");
elif COM_RESULT = 3  then
Revision.matrix_gi:="@(#)$Id: matrix.gi,v 4.159.2.7 2006/08/22 10:35:54 gap Exp $";
InstallMethod(Zero,[IsRectangularTable and IsAdditiveElementWithZeroCollColl],ZERO_ATTR_MAT);
InstallGlobalFunction(PrintArray,COM_FUN(1));
InstallMethod(Display,"for a matrix",[IsMatrix],PrintArray);
InstallMethod(IsGeneralizedCartanMatrix,"for a matrix",[IsMatrix],COM_FUN(2));
InstallMethod(IsDiagonalMat,"for a matrix",[IsMatrix],COM_FUN(3));
InstallOtherMethod(IsDiagonalMat,[IsEmpty],ReturnTrue);
InstallMethod(IsUpperTriangularMat,"for a matrix",[IsMatrix],COM_FUN(4));
InstallMethod(IsLowerTriangularMat,"for a matrix",[IsMatrix],COM_FUN(5));
InstallGlobalFunction(DiagonalOfMat,COM_FUN(6));
DeclareRepresentation("IsNullMapMatrix",IsMatrix,[]);
BindGlobal("NullMapMatrix",Objectify(NewType(ListsFamily,IsNullMapMatrix),[]));
InstallMethod(Length,"for null map matrix",[IsNullMapMatrix],COM_FUN(7));
InstallMethod(\*,"for vector and null map matrix",[IsVector,IsNullMapMatrix],COM_FUN(8));
InstallOtherMethod(\*,"for empty list and null map matrix",[IsList and IsEmpty,IsNullMapMatrix],COM_FUN(9));
InstallMethod(\*,"for matrix and null map matrix",[IsMatrix,IsNullMapMatrix],COM_FUN(10));
InstallOtherMethod(\*,"for list and null map matrix",[IsList,IsNullMapMatrix],COM_FUN(11));
InstallMethod(ViewObj,"for null map matrix",[IsNullMapMatrix],COM_FUN(12));
InstallMethod(PrintObj,"for null map matrix",[IsNullMapMatrix],COM_FUN(13));
Matrix_OrderPolynomialInner:=COM_FUN(14);
Matrix_OrderPolynomialSameField:=COM_FUN(15);
Matrix_CharacteristicPolynomialSameField:=COM_FUN(16);
Matrix_MinimalPolynomialSameField:=COM_FUN(17);
InstallMethod(Display,"for matrix of FFEs",[IsFFECollColl and IsMatrix],COM_FUN(18));
InstallMethod(CharacteristicPolynomial,"supply field and indeterminate 1",[IsMatrix],COM_FUN(19));
InstallOtherMethod(CharacteristicPolynomial,"supply indeterminate 1",[IsField,IsMatrix],COM_FUN(20));
InstallMethod(CharacteristicPolynomial,"supply indeterminate 1",COM_FUN(21),[IsField,IsField,IsMatrix],COM_FUN(22));
InstallMethod(CharacteristicPolynomial,"supply field",[IsMatrix,IsPosInt],COM_FUN(23));
InstallOtherMethod(CharacteristicPolynomial,"check default field, print error if ambiguous",IsElmsCollsX,[IsField,IsOrdinaryMatrix,IsPosInt],COM_FUN(24));
InstallMethod(CharacteristicPolynomial,"spinning over field",COM_FUN(25),[IsField,IsField,IsOrdinaryMatrix,IsPosInt],COM_FUN(26));
InstallMethod(CharacteristicPolynomialMatrixNC,"spinning over field",IsElmsCollsX,[IsField,IsOrdinaryMatrix,IsPosInt],Matrix_CharacteristicPolynomialSameField);
InstallMethod(MinimalPolynomial,"spinning over field",IsElmsCollsX,[IsField,IsOrdinaryMatrix,IsPosInt],COM_FUN(27));
InstallMethod(MinimalPolynomialMatrixNC,"spinning over field",IsElmsCollsX,[IsField,IsOrdinaryMatrix,IsPosInt],Matrix_MinimalPolynomialSameField);
OrderMatLimit:=1000;
InstallOtherMethod(Order,"generic method for ordinary matrices",[IsOrdinaryMatrix],COM_FUN(28));
InstallGlobalFunction(OrderMatTrial,COM_FUN(29));
InstallMethod(Order,"for a matrix of cyclotomics, with Minkowski kernel",[IsOrdinaryMatrix and IsCyclotomicCollColl],COM_FUN(30));
InstallMethod(Order,"ordinary matrix of finite field elements",true,[IsOrdinaryMatrix and IsFFECollColl],0,COM_FUN(31));
InstallMethod(IsZero,"method for a matrix",[IsMatrix],COM_FUN(32));
InstallMethod(BaseMatDestructive,"generic method for matrices",[IsMatrix],COM_FUN(33));
InstallMethod(BaseMat,"generic method for matrices",[IsMatrix],COM_FUN(34));
InstallMethod(DefaultFieldOfMatrix,"default method for a matrix (return `fail')",[IsMatrix],ReturnFail);
InstallMethod(DefaultFieldOfMatrix,"method for a matrix over a finite field",[IsMatrix and IsFFECollColl],COM_FUN(35));
InstallMethod(DefaultFieldOfMatrix,"method for a matrix over the cyclotomics",[IsMatrix and IsCyclotomicCollColl],COM_FUN(36));
InstallMethod(DepthOfUpperTriangularMatrix,[IsMatrix],COM_FUN(37));
InstallOtherMethod(SumIntersectionMat,[IsEmpty,IsMatrix],COM_FUN(38));
InstallOtherMethod(SumIntersectionMat,[IsMatrix,IsEmpty],COM_FUN(39));
InstallOtherMethod(SumIntersectionMat,IsIdenticalObj,[IsEmpty,IsEmpty],COM_FUN(40));
InstallMethod(DeterminantMatDestructive,"fraction-free method",[IsOrdinaryMatrix and IsMutable],COM_FUN(41));
InstallMethod(DeterminantMatDestructive,"non fraction free",[IsOrdinaryMatrix and IsFFECollColl and IsMutable],COM_FUN(42));
InstallMethod(DeterminantMat,"for matrices",[IsMatrix],COM_FUN(43));
InstallMethod(DeterminantMatDivFree,"Division-free method",[IsMatrix],COM_FUN(44));
InstallMethod(DimensionsMat,[IsMatrix],COM_FUN(45));
InstallMethod(DiagonalizeMat,"method for general Euclidean Ring",true,[IsEuclideanRing,IsMatrix and IsMutable],0,COM_FUN(46));
InstallOtherMethod(EuclideanDegree,"laurent,ring",IsCollsElms,[IsPolynomialRing,IsLaurentPolynomial],0,COM_FUN(47));
InstallOtherMethod(EuclideanDegree,"laurent",true,[IsLaurentPolynomial],0,DegreeOfLaurentPolynomial);
InstallGlobalFunction(ElementaryDivisorsMatDestructive,COM_FUN(48));
InstallMethod(ElementaryDivisorsMat,"generic method for euclidean rings",[IsEuclideanRing,IsMatrix],COM_FUN(49));
InstallOtherMethod(ElementaryDivisorsMat,"compatibility method for integers",[IsMatrix],COM_FUN(50));
InstallMethod(MutableCopyMat,"generic method",[IsList],COM_FUN(51));
InstallMethod(MutableTransposedMat,"generic method",[IsRectangularTable and IsMatrix],COM_FUN(52));
InstallOtherMethod(MutableTransposedMat,"for arbitrary lists of lists",[IsList],COM_FUN(53));
InstallMethod(MutableTransposedMatDestructive,"generic method",[IsMatrix and IsMutable],COM_FUN(54));
InstallMethod(NullspaceMat,"generic method for ordinary matrices",[IsOrdinaryMatrix],COM_FUN(55));
InstallMethod(NullspaceMatDestructive,"generic method for ordinary matrices",[IsOrdinaryMatrix and IsMutable],COM_FUN(56));
InstallMethod(TriangulizedNullspaceMat,"generic method for ordinary matrices",[IsOrdinaryMatrix],COM_FUN(57));
InstallMethod(TriangulizedNullspaceMatDestructive,"generic method for ordinary matrices",[IsOrdinaryMatrix and IsMutable],COM_FUN(58));
InstallMethod(TriangulizedNullspaceMatNT,"generic method",[IsOrdinaryMatrix],COM_FUN(59));
InstallMethod(GeneralisedEigenvalues,"for a matrix",[IsField,IsMatrix],COM_FUN(60));
InstallMethod(GeneralisedEigenspaces,"for a matrix",[IsField,IsMatrix],COM_FUN(61));
InstallMethod(Eigenvalues,"for a matrix",[IsField,IsMatrix],COM_FUN(62));
InstallMethod(Eigenspaces,"for a matrix",[IsField,IsMatrix],COM_FUN(63));
InstallMethod(Eigenvectors,"for a matrix",[IsField,IsMatrix],COM_FUN(64));
InstallMethod(ProjectiveOrder,"ordinary matrix of finite field elements",[IsOrdinaryMatrix and IsFFECollColl],COM_FUN(65));
InstallMethod(RankMatDestructive,"generic method for mutable matrices",[IsMatrix and IsMutable],COM_FUN(66));
InstallMethod(RankMat,"generic method for matrices",[IsMatrix],COM_FUN(67));
InstallMethod(SemiEchelonMatDestructive,"generic method for matrices",[IsMatrix and IsMutable],COM_FUN(68));
InstallMethod(SemiEchelonMat,"generic method for matrices",[IsMatrix],COM_FUN(69));
InstallMethod(SemiEchelonMatTransformation,"generic method for matrices",[IsMatrix],COM_FUN(70));
InstallMethod(SemiEchelonMatTransformationDestructive,"generic method for matrices",[IsMatrix and IsMutable],COM_FUN(71));
InstallGlobalFunction(SemiEchelonMatsNoCo,COM_FUN(72));
InstallMethod(SemiEchelonMats,"for list of matrices",[IsList],COM_FUN(73));
InstallMethod(SemiEchelonMatsDestructive,"for list of matrices",[IsList],COM_FUN(74));
InstallOtherMethod(TransposedMat,"generic method for matrices and lists",[IsList],MutableTransposedMat);
InstallMethod(TransposedMatDestructive,"generic method for matrices",[IsMatrix],MutableTransposedMatDestructive);
InstallOtherMethod(TransposedMatDestructive,"method for empty matrices",[IsList],COM_FUN(75));
InstallMethod(IsMonomialMatrix,"generic method for matrices",[IsMatrix],COM_FUN(76));
InstallMethod(InverseMatMod,"generic method for matrix and integer",IsCollCollsElms,[IsMatrix,IsInt],COM_FUN(77));
InstallMethod(KroneckerProduct,"generic method for matrices",IsIdenticalObj,[IsMatrix,IsMatrix],COM_FUN(78));
InstallMethod(SolutionMatDestructive,"generic method",IsCollsElms,[IsOrdinaryMatrix and IsMutable,IsRowVector and IsMutable],COM_FUN(79));
InstallMethod(SolutionMat,"generic method for ordinary matrix and vector",IsCollsElms,[IsOrdinaryMatrix,IsRowVector],COM_FUN(80));
InstallMethod(SumIntersectionMat,IsIdenticalObj,[IsMatrix,IsMatrix],COM_FUN(81));
InstallMethod(TriangulizeMat,"generic method for mutable matrices",[IsMatrix and IsMutable],COM_FUN(82));
InstallOtherMethod(TriangulizeMat,"for an empty list",[IsList and IsEmpty],COM_FUN(83));
InstallMethod(UpperSubdiagonal,[IsMatrix,IsPosInt],COM_FUN(84));
InstallGlobalFunction(BaseFixedSpace,COM_FUN(85));
InstallGlobalFunction(BaseSteinitzVectors,COM_FUN(86));
InstallGlobalFunction(BlownUpMat,COM_FUN(87));
InstallGlobalFunction(BlownUpVector,COM_FUN(88));
InstallGlobalFunction(IdentityMat,COM_FUN(89));
InstallGlobalFunction(NullMat,COM_FUN(90));
InstallGlobalFunction(NullspaceModQ,COM_FUN(91));
InstallGlobalFunction(BasisNullspaceModN,COM_FUN(92));
InstallGlobalFunction(PermutationMat,COM_FUN(93));
InstallGlobalFunction(DiagonalMat,COM_FUN(94));
InstallGlobalFunction(ReflectionMat,COM_FUN(95));
InstallGlobalFunction(RandomInvertibleMat,COM_FUN(96));
InstallGlobalFunction(RandomMat,COM_FUN(97));
InstallGlobalFunction(RandomUnimodularMat,COM_FUN(98));
InstallGlobalFunction(SimultaneousEigenvalues,COM_FUN(99));
InstallGlobalFunction(FlatBlockMat,COM_FUN(100));
InstallGlobalFunction(DirectSumMat,COM_FUN(101));
InstallGlobalFunction(TraceMat,COM_FUN(102));
InstallOtherMethod(Trace,"generic method for matrices",[IsMatrix],TraceMat);
InstallMethod(JordanDecomposition,"method for matrices",[IsMatrix],COM_FUN(103));
InstallGlobalFunction(OnSubspacesByCanonicalBasis,COM_FUN(104));
InstallMethod(FieldOfMatrixList,"generic: form field",[IsListOrCollection],COM_FUN(105));
InstallMethod(LaTeXObj,"matrix",[IsMatrix],COM_FUN(106));
InstallMethod(BaseOrthogonalSpaceMat,"for a matrix",[IsMatrix],COM_FUN(107));
InstallMethod(BaseField,"for a compressed gf2 matrix",[IsGF2MatrixRep],COM_FUN(108));
InstallMethod(BaseField,"for a compressed 8bit matrix",[Is8BitMatrixRep],COM_FUN(109));
InstallMethod(BaseField,"for a compressed gf2 vector",[IsGF2VectorRep],COM_FUN(110));
InstallMethod(BaseField,"for a compressed 8bit vector",[Is8BitVectorRep],COM_FUN(111));
InstallMethod(ZeroVector,"for a length and a nonempty vector",[IsInt,IsList],COM_FUN(112));
InstallMethod(ZeroMatrix,"for a compressed gf2 matrix",[IsInt,IsInt,IsGF2MatrixRep],COM_FUN(113));
InstallMethod(ZeroMatrix,"for a compressed 8bit matrix",[IsInt,IsInt,Is8BitMatrixRep],COM_FUN(114));
InstallMethod(IdentityMatrix,"for a compressed gf2 matrix",[IsInt,IsGF2MatrixRep],COM_FUN(115));
InstallMethod(IdentityMatrix,"for a compressed 8bit matrix",[IsInt,Is8BitMatrixRep],COM_FUN(116));
InstallMethod(CopySubVector,"generic method",[IsList,IsList,IsList,IsList],COM_FUN(117));
InstallMethod(CopySubMatrix,"generic method",[IsList,IsList,IsList,IsList,IsList,IsList],COM_FUN(118));
InstallMethod(ExtractSubMatrix,"generic method",[IsList,IsList,IsList],COM_FUN(119));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/matrix.gi"

#F  file="lib/matint.gi" crc=19769948
RANK_FILTER_LIST  := [ 58412696, 30, 8193, 2, 41942876, 3, 58412696, 30, 
  8193, 2, 41942876, 3, 58412697, 32, 41942876, 3, 58412696, 30, 8193, 2, 
  41942876, 3, 58412696, 30, 8193, 2, 41942876, 3, 58412696, 30, 8193, 2, 
  41942876, 3, 58412696, 30, 8193, 2, 41942876, 3, 54525188, 39, 58412697, 
  32, 43551717, 40, 41942876, 3, 43551717, 40, 43551717, 40, 41942876, 3, 1, 
  0, 1, 0, 41942876, 3, 43551717, 40, 43551717, 40, 43551717, 40, 41951068, 
  17, 43551717, 40, 43551717, 40, 26132143, 27, 41942876, 3, 1, 0, 43551717, 
  40, 26132143, 27, 26123951, 20, 41951068, 17 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/matint.gi", 19769948 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/matint.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/matint.gi");
elif COM_RESULT = 3  then
Revision.matint_gi:="$Id: matint.gi,v 4.28.2.3 2004/03/17 11:49:50 gap Exp $";
BindGlobal("MATINTsplit",COM_FUN(1));
BindGlobal("MATINTrgcd",COM_FUN(2));
BindGlobal("MATINTmgcdex",COM_FUN(3));
BindGlobal("MATINTbezout",COM_FUN(4));
InstallGlobalFunction(SNFofREF,COM_FUN(5));
BindGlobal("BITLISTS_NFIM",[[false,false,false,false,false],[true,false,false,false,false],[false,true,false,false,false],[true,true,false,false,false],[false,false,true,false,false],[true,false,true,false,false],[false,true,true,false,false],[true,true,true,false,false],[false,false,false,true,false],[true,false,false,true,false],[false,true,false,true,false],[true,true,false,true,false],[false,false,true,true,false],[true,false,true,true,false],[false,true,true,true,false],[true,true,true,true,false],[false,false,false,false,true],[true,false,false,false,true],[false,true,false,false,true],[true,true,false,false,true],[false,false,true,false,true],[true,false,true,false,true],[false,true,true,false,true],[true,true,true,false,true],[false,false,false,true,true],[true,false,false,true,true],[false,true,false,true,true],[true,true,false,true,true],[false,false,true,true,true],[true,false,true,true,true],[false,true,true,true,true],[true,true,true,true,true]]);
BindGlobal("DoNFIM",COM_FUN(6));
InstallGlobalFunction(NormalFormIntMat,COM_FUN(7));
InstallMethod(TriangulizedIntegerMat,"dispatch",true,[IsMatrix],0,COM_FUN(8));
InstallOtherMethod(TriangulizedIntegerMat,"empty matrix",true,[IsList],0,COM_FUN(9));
InstallOtherMethod(TriangulizedIntegerMat,"empty",true,[IsEmpty],0,Immutable);
InstallMethod(TriangulizedIntegerMatTransform,"dispatch",true,[IsMatrix],0,COM_FUN(10));
InstallOtherMethod(TriangulizedIntegerMatTransform,"empty matrix",true,[IsList\
],0,COM_FUN(11));
InstallOtherMethod(TriangulizedIntegerMatTransform,"empty",true,[IsEmpty],0,COM_FUN(12));
InstallMethod(TriangulizeIntegerMat,"dispatch",true,[IsMatrix and IsMutable],0,COM_FUN(13));
InstallOtherMethod(TriangulizeIntegerMat,"empty",true,[IsEmpty],0,Immutable);
InstallMethod(HermiteNormalFormIntegerMat,"dispatch",true,[IsMatrix],0,COM_FUN(14));
InstallOtherMethod(HermiteNormalFormIntegerMat,"empty matrix",true,[IsList],0,COM_FUN(15));
InstallOtherMethod(HermiteNormalFormIntegerMat,"empty",true,[IsEmpty],0,Immutable);
InstallMethod(HermiteNormalFormIntegerMatTransform,"dispatch",true,[IsMatrix],\
0,COM_FUN(16));
InstallOtherMethod(HermiteNormalFormIntegerMatTransform,"empty matrix",true,[IsList],0,COM_FUN(17));
InstallOtherMethod(HermiteNormalFormIntegerMatTransform,"empty",true,[IsEmpty],0,COM_FUN(18));
InstallMethod(SmithNormalFormIntegerMat,"dispatch",true,[IsMatrix],0,COM_FUN(19));
InstallOtherMethod(SmithNormalFormIntegerMat,"empty matrix",true,[IsList],0,COM_FUN(20));
InstallOtherMethod(SmithNormalFormIntegerMat,"empty",true,[IsEmpty],0,Immutable);
InstallMethod(SmithNormalFormIntegerMatTransforms,"dispatch",true,[IsMatrix],0,COM_FUN(21));
InstallOtherMethod(SmithNormalFormIntegerMatTransforms,"empty matrix",true,[IsList],0,COM_FUN(22));
InstallOtherMethod(SmithNormalFormIntegerMatTransforms,"empty",true,[IsEmpty],0,COM_FUN(23));
InstallGlobalFunction(DiagonalizeIntMat,COM_FUN(24));
InstallMethod(DiagonalizeMat,"over the integers",[IsIntegers,IsMatrix and IsMutable],COM_FUN(25));
InstallMethod(BaseIntMat,"use HNF",true,[IsMatrix and IsCyclotomicCollColl],0,COM_FUN(26));
InstallOtherMethod(BaseIntMat,"empty",true,[IsEmpty],0,Immutable);
InstallMethod(BaseIntersectionIntMats,"use HNF",true,[IsMatrix and IsCyclotomicCollColl,IsMatrix and IsCyclotomicCollColl],0,COM_FUN(27));
InstallOtherMethod(BaseIntersectionIntMats,"emptyL",true,[IsEmpty,IsObject],0,COM_FUN(28));
InstallOtherMethod(BaseIntersectionIntMats,"emptyR",true,[IsObject,IsEmpty],0,COM_FUN(29));
InstallMethod(ComplementIntMat,"use HNF and SNF",true,[IsMatrix and IsCyclotomicCollColl,IsMatrix and IsCyclotomicCollColl],0,COM_FUN(30));
InstallOtherMethod(ComplementIntMat,"empty submodule",true,[IsMatrix and IsCyclotomicCollColl,IsList and IsEmpty],0,COM_FUN(31));
InstallMethod(NullspaceIntMat,"use HNF",true,[IsMatrix and IsCyclotomicCollColl],0,COM_FUN(32));
InstallMethod(SolutionIntMat,"use HNF",true,[IsMatrix and IsCyclotomicCollColl,IsList and IsCyclotomicCollection],0,COM_FUN(33));
InstallOtherMethod(SolutionIntMat,"empty",true,[IsEmpty,IsObject],0,COM_FUN(34));
InstallMethod(SolutionNullspaceIntMat,"use HNF",true,[IsMatrix and IsCyclotomicCollColl,IsList and IsCyclotomicCollection],0,COM_FUN(35));
InstallGlobalFunction(DeterminantIntMat,COM_FUN(36));
InstallMethod(AbelianInvariantsOfList,[IsCyclotomicCollection],COM_FUN(37));
InstallOtherMethod(AbelianInvariantsOfList,[IsList and IsEmpty],COM_FUN(38));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/matint.gi"

#F  file="lib/matblock.gi" crc=82739808
RANK_FILTER_LIST  := [ 21625086, 34, 21625086, 34, 7665940, 19, 21625086, 34, 
  58412696, 30, 21625086, 34, 21625086, 34, 21625086, 34, 21625086, 34, 
  21625086, 34, 3694085, 3, 3694085, 3, 21625086, 34, 21625086, 34, 21625086, 
  34, 21625086, 34, 21625086, 34, 65077940, 12, 65077940, 12, 21625086, 34, 
  21625086, 34, 64918210, 8, 64918210, 8, 21625086, 34, 21625086, 34, 17, 18, 
  17, 18, 21625086, 34, 6764107, 45, 257, 15, 257, 15, 6764107, 45, 21625086, 
  34, 7388169, 4, 7388169, 4, 21625086, 34, 21625086, 34, 21625086, 34, 
  21625086, 34, 21625086, 34, 21625086, 34 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/matblock.gi", 82739808 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/matblock.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/matblock.gi");
elif COM_RESULT = 3  then
Revision.matblock_gi:="@(#)$Id: matblock.gi,v 4.16 2002/04/15 10:05:00 sal Exp $";
DeclareRepresentation("IsBlockMatrixRep",IsComponentObjectRep,["blocks","zero","nrb","ncb","rpb","cpb"]);
InstallGlobalFunction(BlockMatrix,COM_FUN(1));
InstallMethod(Length,"for an ordinary block matrix",[IsOrdinaryMatrix and IsBlockMatrixRep],COM_FUN(2));
InstallMethod(\[\],"for an ordinary block matrix and a positive integer",[IsOrdinaryMatrix and IsBlockMatrixRep,IsPosInt],COM_FUN(3));
InstallMethod(TransposedMat,"for an ordinary block matrix",[IsOrdinaryMatrix and IsBlockMatrixRep],COM_FUN(4));
InstallMethod(MatrixByBlockMatrix,[IsMatrix],COM_FUN(5));
InstallGlobalFunction(AsBlockMatrix,COM_FUN(6));
InstallMethod(\=,"for two ordinary block matrices",IsIdenticalObj,[IsOrdinaryMatrix and IsBlockMatrixRep,IsOrdinaryMatrix and IsBlockMatrixRep],COM_FUN(7));
InstallMethod(\+,"for two ordinary block matrices",IsIdenticalObj,[IsOrdinaryMatrix and IsBlockMatrixRep,IsOrdinaryMatrix and IsBlockMatrixRep],COM_FUN(8));
InstallOtherMethod(\+,"for an ordinary block matrix, and a grv",IsIdenticalObj,[IsOrdinaryMatrix and IsBlockMatrixRep,IsGeneralizedRowVector],COM_FUN(9));
InstallOtherMethod(\+,"for a grv, and an ordinary block matrix",IsIdenticalObj,[IsGeneralizedRowVector,IsOrdinaryMatrix and IsBlockMatrixRep],COM_FUN(10));
InstallMethod(AdditiveInverseOp,"for an ordinary block matrix",[IsOrdinaryMatrix and IsBlockMatrixRep],COM_FUN(11));
InstallMethod(\*,"for two ordinary block matrices",IsIdenticalObj,[IsOrdinaryMatrix and IsBlockMatrixRep,IsOrdinaryMatrix and IsBlockMatrixRep],6,COM_FUN(12));
InstallMethod(\*,"for ordinary block matrix and vector",IsCollsElms,[IsOrdinaryMatrix and IsBlockMatrixRep,IsRowVector],COM_FUN(13));
InstallMethod(\*,"for vector and ordinary block matrix",IsElmsColls,[IsRowVector,IsOrdinaryMatrix and IsBlockMatrixRep],COM_FUN(14));
InstallMethod(\*,"for ordinary block matrix and ring element",IsCollCollsElms,[IsOrdinaryMatrix and IsBlockMatrixRep,IsRingElement],COM_FUN(15));
InstallMethod(\*,"for ring element and ordinary block matrix",IsElmsCollColls,[IsRingElement,IsOrdinaryMatrix and IsBlockMatrixRep],COM_FUN(16));
InstallMethod(\*,"for ordinary block matrix and integer",[IsOrdinaryMatrix and IsBlockMatrixRep,IsInt],COM_FUN(17));
InstallMethod(\*,"for integer and ordinary block matrix",[IsInt,IsOrdinaryMatrix and IsBlockMatrixRep],COM_FUN(18));
InstallMethod(\*,"for ordinary block matrix of integers and ffe",[IsOrdinaryMatrix and IsBlockMatrixRep and IsCyclotomicCollColl,IsFFE],COM_FUN(19));
InstallMethod(\*,"for ffe and ordinary block matrix of integers",[IsFFE,IsOrdinaryMatrix and IsBlockMatrixRep and IsCyclotomicCollColl],COM_FUN(20));
InstallOtherMethod(\*,"for an ordinary block matrix, and a mgrv",IsIdenticalObj,[IsOrdinaryMatrix and IsBlockMatrixRep,IsMultiplicativeGeneralizedRowVector],COM_FUN(21));
InstallOtherMethod(\*,"for a mgrv, and an ordinary block matrix",IsIdenticalObj,[IsMultiplicativeGeneralizedRowVector,IsOrdinaryMatrix and IsBlockMatrixRep],COM_FUN(22));
InstallOtherMethod(OneOp,"for an ordinary block matrix",[IsOrdinaryMatrix and IsBlockMatrixRep],3,COM_FUN(23));
InstallOtherMethod(InverseOp,"for an ordinary block matrix",[IsOrdinaryMatrix and IsBlockMatrixRep],COM_FUN(24));
InstallMethod(ViewObj,"for an ordinary block matrix",[IsOrdinaryMatrix and IsBlockMatrixRep],COM_FUN(25));
InstallMethod(PrintObj,"for an ordinary block matrix",[IsOrdinaryMatrix and IsBlockMatrixRep],COM_FUN(26));
InstallMethod(DimensionsMat,"for an ordinary block matrix",[IsOrdinaryMatrix and IsBlockMatrixRep],COM_FUN(27));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/matblock.gi"

#F  file="lib/tuples.gi" crc=3270622
RANK_FILTER_LIST  := [ 8126465, 2, 41951068, 17, 8193, 2, 17176921, 4, 8193, 
  2, 8588461, 15, 8588461, 15, 8588461, 15, 8588461, 15, 8588461, 15, 
  8588461, 15, 8588461, 15, 17176921, 4, 8193, 2, 53888097, 17, 7665940, 19, 
  53888097, 17, 8588461, 15, 8588461, 15, 8588461, 15, 8588461, 15, 34353841, 
  16, 8588461, 15, 17, 18, 8588461, 15, 8588461, 15, 8588461, 15, 8588461, 
  15, 8588461, 15, 62914276, 5, 62914276, 5, 8588461, 15, 8588461, 15, 
  62914276, 5, 62914276, 5, 8588461, 15, 8588461, 15, 1, 0, 1, 0, 8588461, 
  15, 8588461, 15, 1, 0, 1, 0, 8588461, 15 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/tuples.gi", 3270622 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/tuples.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/tuples.gi");
elif COM_RESULT = 3  then
Revision.tuples_gi:="@(#)$Id: tuples.gi,v 4.29.4.1 2005/10/14 08:45:40 gap Exp $";
DeclareInfoClass("InfoTuples");
DeclareRepresentation("IsDefaultTupleRep",IsPositionalObjectRep and IsTuple,[]);
BindGlobal("EmptyTuplesFamily",NewFamily("TuplesFamily([])",IsTuple,IsTuple));
EmptyTuplesFamily!.defaultTupleType:=NewType(EmptyTuplesFamily,IsDefaultTupleRep);
SetComponentsOfTuplesFamily(EmptyTuplesFamily,[]);
InstallValue(TUPLES_FAMILIES,[[EmptyTuplesFamily]]);
InstallMethod(TuplesFamily,"for a collection (of families)",COM_FUN(1),[IsCollection],COM_FUN(2));
InstallOtherMethod(TuplesFamily,"for an empty list",[IsList and IsEmpty],COM_FUN(3));
InstallMethod(Tuple,"for a list",[IsList],COM_FUN(4));
InstallOtherMethod(Tuple,"for a tuples family, and a list",[IsTupleFamily,IsList],COM_FUN(5));
InstallMethod(PrintObj,"for a tuple",[IsTuple],COM_FUN(6));
InstallMethod(ViewObj,"for a tuple (call `PrintObj')",[IsTuple],PrintObj);
InstallMethod(\<,"for two tuples",IsIdenticalObj,[IsTuple,IsTuple],COM_FUN(7));
InstallMethod(\=,"for two tuples",IsIdenticalObj,[IsTuple,IsTuple],COM_FUN(8));
InstallMethod(CanEasilyCompareElements,"for tuple",[IsTuple],COM_FUN(9));
InstallMethod(TupleNC,"for a tuples family, and a list",[IsTupleFamily,IsList],COM_FUN(10));
InstallMethod(\[\],"for a tuple in default representation, and a positive integer",[IsDefaultTupleRep,IsPosInt],COM_FUN(11));
InstallMethod(Length,"for a tuple in default representation",[IsDefaultTupleRep],COM_FUN(12));
InstallMethod(InverseOp,"for a tuple",[IsTuple],COM_FUN(13));
InstallMethod(OneOp,"for a tuple",[IsTuple],COM_FUN(14));
InstallMethod(\*,"for two tuples",[IsTuple,IsTuple],COM_FUN(15));
InstallMethod(IsGeneratorsOfMagmaWithInverses,"for list of tuples",[CategoryCollections(IsTuple)],COM_FUN(16));
InstallMethod(\^,"for tuple, and integer",[IsTuple,IsInt],COM_FUN(17));
InstallMethod(AdditiveInverseOp,"for a tuple",[IsTuple],COM_FUN(18));
InstallMethod(ZeroOp,"for a tuple",[IsTuple],COM_FUN(19));
InstallMethod(\+,"for two tuples",[IsTuple,IsTuple],COM_FUN(20));
InstallOtherMethod(\+,"for a tuple, and a default list",[IsTuple,IsListDefault],SUM_SCL_LIST_DEFAULT);
InstallOtherMethod(\+,"for a default list, and a tuple",[IsListDefault,IsTuple],SUM_LIST_SCL_DEFAULT);
InstallOtherMethod(\*,"for a tuple, and a default list",[IsTuple,IsListDefault],PROD_SCL_LIST_DEFAULT);
InstallOtherMethod(\*,"for a default list, and a tuple",[IsListDefault,IsTuple],PROD_LIST_SCL_DEFAULT);
InstallOtherMethod(\+,"for a tuple, and a non-list",[IsTuple,IsObject],COM_FUN(21));
InstallOtherMethod(\+,"for a non-list, and a tuple",[IsObject,IsTuple],COM_FUN(22));
InstallOtherMethod(\*,"for a tuple, and a non-list",[IsTuple,IsObject],COM_FUN(23));
InstallOtherMethod(\*,"for a non-list, and a tuple",[IsObject,IsTuple],COM_FUN(24));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/tuples.gi"

#F  file="lib/domain.gi" crc=-113678274
RANK_FILTER_LIST  := [ 8134657, 5, 23214719, 5, 23214719, 5, 8134657, 5, 
  23214719, 5, 23214719, 5, 8134657, 5, 23214719, 5, 23214719, 5, 8134657, 5, 
  23214719, 5, 23214719, 5, 1985, 1, 41951068, 17, 1985, 1, 8134657, 5, 
  8126465, 2, 23461727, 8, 23214719, 5, 24199775, 8, 23277215, 8, 53391227, 
  6, 53391227, 6, 23214719, 5, 1, 0, 23214719, 5, 23460735, 6, 53391227, 6, 
  56768461, 10, 23214719, 5, 16458856, 6, 23214719, 5, 23214719, 5, 8112546, 
  4, 23214719, 5, 23214719, 5, 8112546, 4 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/domain.gi", -113678274 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/domain.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/domain.gi");
elif COM_RESULT = 3  then
Revision.domain_gi:="@(#)$Id: domain.gi,v 4.49 2003/04/15 15:45:37 gap Exp $";
InstallMethod(\=,"for a list and a domain",IsIdenticalObj,[IsCollection and IsList,IsDomain],COM_FUN(1));
InstallMethod(\=,"for a domain and a list",IsIdenticalObj,[IsDomain,IsCollection and IsList],COM_FUN(2));
InstallMethod(\=,"for two domains",IsIdenticalObj,[IsDomain,IsDomain],COM_FUN(3));
InstallMethod(\<,"for a list and a domain",IsIdenticalObj,[IsCollection and IsList,IsDomain],COM_FUN(4));
InstallMethod(\<,"for a domain and a list",IsIdenticalObj,[IsDomain,IsCollection and IsList],COM_FUN(5));
InstallMethod(SetParent,"method that calls 'UseSubsetRelation'",IsIdenticalObj,[IsDomain,IsDomain],COM_FUN(6));
InstallGlobalFunction(Domain,COM_FUN(7));
InstallMethod(DomainByGenerators,"for family and empty list",[IsFamily,IsList and IsEmpty],COM_FUN(8));
InstallMethod(DomainByGenerators,"for family and list & collection",[IsFamily,IsCollection and IsList],COM_FUN(9));
InstallOtherMethod(DomainByGenerators,"for a collection",[IsCollection],COM_FUN(10));
InstallImmediateMethod(GeneratorsOfDomain,IsDomain and HasAsList and IsAttributeStoringRep,0,AsList);
InstallMethod(GeneratorsOfDomain,"for a domain (delegate to `AsList')",[IsDomain],AsList);
InstallImmediateMethod(AsList,IsDomain and HasAsSSortedList and IsAttributeStoringRep,0,AsSSortedList);
InstallImmediateMethod(Enumerator,IsDomain and HasEnumeratorSorted and IsAttributeStoringRep,0,EnumeratorSorted);
InstallMethod(AsList,"for a domain with stored domain generators",[IsDomain and HasGeneratorsOfDomain],COM_FUN(11));
InstallMethod(Enumerator,"for a domain with stored domain generators",[IsDomain and HasGeneratorsOfDomain],COM_FUN(12));
InstallMethod(EnumeratorSorted,"for a domain",[IsDomain],COM_FUN(13));
InstallMethod(\in,"for a domain, and an element",IsElmsColls,[IsObject,IsDomain],COM_FUN(14));
InstallMethod(Representative,"for a domain with known elements list",[IsDomain and HasAsList],RepresentativeFromGenerators(AsList));
InstallMethod(Representative,"for a domain with known domain generators",[IsDomain and HasGeneratorsOfDomain],RepresentativeFromGenerators(GeneratorsOfDomain));
InstallMethod(Size,"for a trivial domain",[IsDomain and IsTrivial],COM_FUN(15));
InstallMethod(IsSubset,"test whether domain is parent of the other",IsIdenticalObj,[IsDomain,IsDomain and HasParent],SUM_FLAGS,COM_FUN(16));
InstallMethod(CanComputeIsSubset,"default for domains: no unless identical",[IsDomain,IsDomain],COM_FUN(17));
InstallMethod(Intersection2,"whole family and domain",IsIdenticalObj,[IsCollection and IsWholeFamily,IsDomain],SUM_FLAGS,COM_FUN(18));
InstallMethod(Intersection2,"domain and whole family",IsIdenticalObj,[IsDomain,IsCollection and IsWholeFamily],SUM_FLAGS,COM_FUN(19));
InstallGlobalFunction(InstallAccessToGenerators,COM_FUN(20));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/domain.gi"

#F  file="lib/mapping.gi" crc=90855095
RANK_FILTER_LIST  := [ 1985, 1, 63580652, 7, 54568942, 11, 63580652, 7, 
  63580652, 7, 63580652, 7, 49871490, 8, 49871490, 8, 49871490, 8, 49871490, 
  8, 63580652, 7, 63580652, 7, 63580652, 7, 63580652, 7, 54568942, 11, 
  63580652, 7, 63580652, 7, 63580652, 7, 63580652, 7, 63580652, 7, 4477190, 
  17, 4477190, 17, 63580652, 7, 63580652, 7, 63580652, 7, 63580652, 7, 
  63580652, 7, 1, 0, 63580652, 7, 63580652, 7, 63580652, 7, 63580652, 7, 
  5814748, 10, 61777542, 9, 1, 0, 53618730, 11, 63580652, 7, 1, 0, 54568942, 
  11, 1, 0, 52995968, 8, 1, 0, 38301828, 9, 1, 0, 63580652, 7, 8126465, 2, 
  63580652, 7, 41951068, 17, 63580652, 7, 15346171, 9, 60052424, 8, 1, 0, 
  52995968, 8, 1, 0, 63580652, 7, 1, 0, 53618730, 11, 1, 0, 63580652, 7, 1, 
  0, 38301828, 9, 1, 0, 63580652, 7, 8126465, 2, 63580652, 7, 41951068, 17, 
  63580652, 7, 61777542, 9, 60052424, 8, 1, 0, 52995968, 8, 1, 0, 63580652, 
  7, 57815567, 22, 63580652, 7, 20637180, 22, 63580652, 7, 57569506, 22, 
  34353841, 16, 57569506, 22, 34353841, 16, 57568514, 20, 57568514, 20, 
  57568514, 20, 57568514, 20, 57568514, 20, 57568514, 20, 8588461, 15, 
  57568514, 20, 57568514, 20, 38883056, 11 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/mapping.gi", 90855095 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/mapping.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/mapping.gi");
elif COM_RESULT = 3  then
Revision.mapping_gi:="@(#)$Id: mapping.gi,v 4.67 2003/03/20 12:07:33 gap Exp $";
InstallMethod(FamiliesOfGeneralMappingsAndRanges,"for a family (return empty list)",true,[IsFamily],0,COM_FUN(1));
InstallGlobalFunction(GeneralMappingsFamily,COM_FUN(2));
InstallMethod(PrintObj,"for a general mapping",true,[IsGeneralMapping],0,COM_FUN(3));
InstallMethod(PrintObj,"for a mapping",true,[IsMapping],0,COM_FUN(4));
InstallOtherMethod(IsOne,"for general mapping",true,[IsGeneralMapping],0,COM_FUN(5));
InstallOtherMethod(IsZero,"for general mapping",true,[IsGeneralMapping],0,COM_FUN(6));
InstallOtherMethod(IsEndoGeneralMapping,"for general mapping",true,[IsGeneralMapping],0,COM_FUN(7));
InstallGlobalFunction(Image,COM_FUN(8));
InstallGlobalFunction(Images,COM_FUN(9));
InstallGlobalFunction(PreImage,COM_FUN(10));
InstallGlobalFunction(PreImages,COM_FUN(11));
InstallGlobalFunction(CompositionMapping,COM_FUN(12));
InstallImmediateMethod(IsInjective,IsGeneralMapping and HasInverseGeneralMapping,0,COM_FUN(13));
InstallImmediateMethod(IsSingleValued,IsGeneralMapping and HasInverseGeneralMapping,0,COM_FUN(14));
InstallImmediateMethod(IsSurjective,IsGeneralMapping and HasInverseGeneralMapping,0,COM_FUN(15));
InstallImmediateMethod(IsTotal,IsGeneralMapping and HasInverseGeneralMapping,0,COM_FUN(16));
InstallMethod(IsTotal,"for a general mapping",true,[IsGeneralMapping],0,COM_FUN(17));
InstallMethod(IsSurjective,"for a general mapping",true,[IsGeneralMapping],0,COM_FUN(18));
InstallMethod(IsSingleValued,"for a general mapping",true,[IsGeneralMapping],0,COM_FUN(19));
InstallMethod(IsInjective,"for a general mapping",true,[IsGeneralMapping],0,COM_FUN(20));
InstallMethod(IsInjective,"for a mapping",true,[IsGeneralMapping and IsTotal and IsSingleValued],0,COM_FUN(21));
InstallMethod(\=,"for two general mappings",IsIdenticalObj,[IsGeneralMapping,IsGeneralMapping],0,COM_FUN(22));
InstallMethod(\<,"for two general mappings",IsIdenticalObj,[IsGeneralMapping,IsGeneralMapping],0,COM_FUN(23));
InstallOtherMethod(\+,"for general mapping and zero mapping",IsIdenticalObj,[IsGeneralMapping,IsGeneralMapping and IsZero],0,COM_FUN(24));
InstallOtherMethod(\+,"for zero mapping and general mapping",IsIdenticalObj,[IsGeneralMapping and IsZero,IsGeneralMapping],0,COM_FUN(25));
InstallMethod(\*,"for two general mappings",FamSource2EqFamRange1,[IsGeneralMapping,IsGeneralMapping],0,COM_FUN(26));
InstallMethod(\^,"for two general mappings",FamSourceRgtEqFamsLft,[IsGeneralMapping,IsGeneralMapping],0,COM_FUN(27));
InstallOtherMethod(\^,"for element in the source, and general mapping",FamElmEqFamSource,[IsObject,IsGeneralMapping],0,COM_FUN(28));
InstallOtherMethod(OneOp,"for a general mapping",true,[IsGeneralMapping],0,COM_FUN(29));
InstallOtherMethod(ZeroOp,"for a general mapping",true,[IsGeneralMapping],0,COM_FUN(30));
InstallMethod(InverseOp,"for a general mapping",true,[IsGeneralMapping],0,COM_FUN(31));
InstallMethod(\*,"for zero and total general mapping",FamElmEqFamRange,[IsRingElement and IsZero,IsGeneralMapping and IsTotal],0,COM_FUN(32));
InstallOtherMethod(\/,"for element, and inj. & surj. general mapping",FamElmEqFamRange,[IsObject,IsGeneralMapping and IsInjective and IsSurjective],0,COM_FUN(33));
InstallOtherMethod(ImageElm,"for general mapping, and element",FamSourceEqFamElm,[IsGeneralMapping,IsObject],0,COM_FUN(34));
InstallMethod(ImageElm,"for mapping, and element",FamSourceEqFamElm,[IsGeneralMapping and IsTotal and IsSingleValued,IsObject],0,ImagesRepresentative);
InstallMethod(ImagesElm,"for non s.p. general mapping, and element",FamSourceEqFamElm,[IsNonSPGeneralMapping,IsObject],0,COM_FUN(35));
InstallMethod(ImagesElm,"for constant time access general mapping, and element",FamSourceEqFamElm,[IsGeneralMapping and IsConstantTimeAccessGeneralMapping,IsObject],0,COM_FUN(36));
InstallMethod(ImagesSet,"for general mapping, and finite collection",CollFamSourceEqFamElms,[IsGeneralMapping,IsCollection],0,COM_FUN(37));
InstallMethod(ImagesSet,"for general mapping, and empty list",true,[IsGeneralMapping,IsList and IsEmpty],0,COM_FUN(38));
InstallMethod(ImagesSource,"for general mapping",true,[IsGeneralMapping],0,COM_FUN(39));
InstallMethod(ImagesSource,"for surjective general mapping (delegate to `Range')",true,[IsGeneralMapping and IsSurjective],SUM_FLAGS,Range);
InstallMethod(ImagesRepresentative,"for s.p. general mapping, and element",FamSourceEqFamElm,[IsSPGeneralMapping,IsObject],0,COM_FUN(40));
InstallMethod(ImagesRepresentative,"for non s.p. general mapping, and element",FamSourceEqFamElm,[IsNonSPGeneralMapping,IsObject],0,COM_FUN(41));
InstallOtherMethod(PreImageElm,"for general mapping, and element",FamRangeEqFamElm,[IsGeneralMapping,IsObject],0,COM_FUN(42));
InstallMethod(PreImageElm,"for inj. & surj. general mapping, and element",FamRangeEqFamElm,[IsGeneralMapping and IsInjective and IsSurjective,IsObject],0,PreImagesRepresentative);
InstallMethod(PreImagesElm,"for general mapping with finite source, and element",FamRangeEqFamElm,[IsGeneralMapping,IsObject],0,COM_FUN(43));
InstallMethod(PreImagesElm,"for constant time access general mapping, and element",FamRangeEqFamElm,[IsGeneralMapping and IsConstantTimeAccessGeneralMapping,IsObject],0,COM_FUN(44));
InstallMethod(PreImagesSet,"for general mapping, and finite collection",CollFamRangeEqFamElms,[IsGeneralMapping,IsCollection],0,COM_FUN(45));
InstallMethod(PreImagesSet,"for general mapping, and empty list",true,[IsGeneralMapping,IsList and IsEmpty],0,COM_FUN(46));
InstallMethod(PreImagesRange,"for general mapping",true,[IsGeneralMapping],0,COM_FUN(47));
InstallMethod(PreImagesRange,"for total general mapping (delegate to `Source')",true,[IsGeneralMapping and IsTotal],SUM_FLAGS,Source);
InstallMethod(PreImagesRepresentative,"for s.p. general mapping, and element",FamRangeEqFamElm,[IsSPGeneralMapping,IsObject],0,COM_FUN(48));
InstallMethod(PreImagesRepresentative,"for total non-s.p. general mapping, and element",FamRangeEqFamElm,[IsNonSPGeneralMapping,IsObject],0,COM_FUN(49));
InstallGlobalFunction(GeneralMappingByElements,COM_FUN(50));
InstallMethod(UnderlyingRelation,"for a general mapping",true,[IsGeneralMapping],0,COM_FUN(51));
InstallMethod(SetUnderlyingGeneralMapping,"for an underlying relation and a general mapping",true,[IsDomain and IsTupleCollection and HasAsList and IsAttributeStoringRep,IsGeneralMapping],0,COM_FUN(52));
InstallMethod(SetUnderlyingGeneralMapping,"for an underlying relation and a general mapping",true,[IsDomain and IsTupleCollection and HasGeneratorsOfDomain and IsAttributeStoringRep,IsGeneralMapping],0,COM_FUN(53));
InstallMethod(SetAsList,"for an underlying relation and a list of tuples",IsIdenticalObj,[IsDomain and IsTupleCollection and HasUnderlyingGeneralMapping and IsAttributeStoringRep,IsTupleCollection],0,COM_FUN(54));
InstallMethod(SetGeneratorsOfDomain,"for an underlying relation and a list of tuples",IsIdenticalObj,[IsDomain and IsTupleCollection and HasUnderlyingGeneralMapping and IsAttributeStoringRep,IsTupleCollection],0,COM_FUN(55));
InstallMethod(\=,"for two underlying relations of general mappings",IsIdenticalObj,[IsDomain and IsTupleCollection and HasUnderlyingGeneralMapping,IsDomain and IsTupleCollection and HasUnderlyingGeneralMapping],0,COM_FUN(56));
InstallMethod(\<,"for two underlying relations of general mappings",IsIdenticalObj,[IsDomain and IsTupleCollection and HasUnderlyingGeneralMapping,IsDomain and IsTupleCollection and HasUnderlyingGeneralMapping],0,COM_FUN(57));
InstallMethod(IsFinite,"for an underlying relation of a general mapping",true,[IsDomain and IsTupleCollection and HasUnderlyingGeneralMapping],0,COM_FUN(58));
InstallMethod(Enumerator,"for an underlying relation of a general mapping",true,[IsDomain and IsTupleCollection and HasUnderlyingGeneralMapping],0,COM_FUN(59));
InstallMethod(\in,"for an element and an underlying relation of a general mapping",IsElmsColls,[IsTuple,IsDomain and IsTupleCollection and HasUnderlyingGeneralMapping],0,COM_FUN(60));
InstallMethod(Size,"for an underlying relation of a general mapping",true,[IsDomain and IsTupleCollection and HasUnderlyingGeneralMapping],0,COM_FUN(61));
InstallMethod(IsGeneratorsOfMagmaWithInverses,"for a collection of general mappings",true,[IsGeneralMappingCollection],0,COM_FUN(62));
InstallGlobalFunction(CopyMappingAttributes,COM_FUN(63));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/mapping.gi"

#F  file="lib/mapprep.gi" crc=-93012272
RANK_FILTER_LIST  := [ 37139086, 10, 37139086, 10, 63580652, 7, 63580652, 7, 
  37302171, 10, 37302171, 10, 37302171, 10, 37302171, 10, 37302171, 10, 1, 0, 
  37302171, 10, 8126465, 2, 37302171, 10, 1, 0, 37302171, 10, 1, 0, 37302171, 
  10, 8126465, 2, 37302171, 10, 1, 0, 52903471, 16, 52903471, 16, 48528285, 
  16, 48528285, 16, 37302171, 10, 37302171, 10, 14225748, 14, 1, 0, 14225748, 
  14, 1, 0, 14225748, 14, 1, 0, 14225748, 14, 1, 0, 28451495, 19, 1, 0, 
  28451495, 19, 1, 0, 28451495, 19, 1, 0, 28451495, 19, 14225748, 14, 
  14225748, 14, 28451495, 19, 28451495, 19, 24865335, 10, 63580652, 7, 
  34507034, 9, 34507034, 9, 34507034, 9, 34507034, 9, 34507034, 9, 34507034, 
  9, 34507034, 9, 34507034, 9, 25495324, 13, 1, 0, 34507034, 9, 1, 0, 
  34507034, 9, 8126465, 2, 34507034, 9, 1, 0, 24545112, 13, 1, 0, 34507034, 
  9, 1, 0, 34507034, 9, 8126465, 2, 38035262, 9, 1, 0, 34507034, 9, 34507034, 
  9, 8126465, 2, 28493441, 17, 17, 18, 28493441, 17, 1, 0, 28493441, 17, 1, 
  0, 28493441, 17, 8126465, 2, 28493441, 17, 28493441, 17, 1, 0, 28493441, 
  17, 1, 0, 28493441, 17, 1, 0, 28493441, 17, 8126465, 2, 28493441, 17, 1, 0, 
  28493441, 17, 28493441, 17, 63580652, 7, 28493441, 17, 28493441, 17, 
  63580652, 7, 8126465, 2, 3341512, 14, 4477190, 17, 7665940, 19, 4477190, 
  17, 4477190, 17, 1, 0, 4477190, 17, 1, 0, 4477190, 17, 8126465, 2, 4477190, 
  17, 1, 0, 4477190, 17, 1, 0, 4477190, 17, 8126465, 2, 4477190, 17, 1, 0, 
  4477190, 17, 4477190, 17, 63580652, 7, 4477190, 17, 4477190, 17, 9553377, 
  11, 4477190, 17, 4477190, 17 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/mapprep.gi", -93012272 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/mapprep.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/mapprep.gi");
elif COM_RESULT = 3  then
Revision.mapprep_gi:="@(#)$Id: mapprep.gi,v 4.40 2002/05/16 13:39:29 stefan Exp $";
DeclareRepresentation("IsDefaultGeneralMappingRep",IsGeneralMapping and HasSource and HasRange,[]);
InstallGlobalFunction(TypeOfDefaultGeneralMapping,COM_FUN(1));
InstallMethod(Range,"for default general mapping",true,[IsGeneralMapping and IsDefaultGeneralMappingRep],GETTER_FLAGS+1,COM_FUN(2));
InstallMethod(Source,"for default general mapping",true,[IsGeneralMapping and IsDefaultGeneralMappingRep],GETTER_FLAGS+1,COM_FUN(3));
InstallGlobalFunction(ConstituentsCompositionMapping,COM_FUN(4));
InstallMethod(CompositionMapping2,"for two general mappings",FamSource1EqFamRange2,[IsGeneralMapping,IsGeneralMapping],0,COM_FUN(5));
InstallMethod(IsInjective,"for a composition mapping",true,[IsCompositionMappingRep],0,COM_FUN(6));
InstallMethod(IsSingleValued,"for a composition mapping",true,[IsCompositionMappingRep],0,COM_FUN(7));
InstallMethod(IsSurjective,"for a composition mapping",true,[IsCompositionMappingRep],0,COM_FUN(8));
InstallMethod(IsTotal,"for a composition mapping",true,[IsCompositionMappingRep],0,COM_FUN(9));
InstallMethod(ImagesElm,"for a composition mapping, and an element",FamSourceEqFamElm,[IsCompositionMappingRep,IsObject],0,COM_FUN(10));
InstallMethod(ImagesSet,"for a composition mapping, and an collection",CollFamSourceEqFamElms,[IsCompositionMappingRep,IsCollection],0,COM_FUN(11));
InstallMethod(ImagesRepresentative,"for a composition mapping, and an element",FamSourceEqFamElm,[IsCompositionMappingRep,IsObject],0,COM_FUN(12));
InstallMethod(PreImagesElm,"for a composition mapping, and an element",FamRangeEqFamElm,[IsCompositionMappingRep,IsObject],0,COM_FUN(13));
InstallMethod(PreImagesSet,"for a composition mapping, and an collection",CollFamRangeEqFamElms,[IsCompositionMappingRep,IsCollection],0,COM_FUN(14));
InstallMethod(PreImagesRepresentative,"for a composition mapping, and an element",FamRangeEqFamElm,[IsCompositionMappingRep,IsObject],0,COM_FUN(15));
InstallMethod(KernelOfAdditiveGeneralMapping,"for a composition mapping that resp. add. and add.inv.",true,[IsGeneralMapping and IsCompositionMappingRep and RespectsAddition and RespectsAdditiveInverses],0,COM_FUN(16));
InstallMethod(CoKernelOfAdditiveGeneralMapping,"for a composition mapping that resp. add. and add.inv.",true,[IsGeneralMapping and IsCompositionMappingRep and RespectsAddition and RespectsAdditiveInverses],0,COM_FUN(17));
InstallMethod(KernelOfMultiplicativeGeneralMapping,"for a composition mapping that resp. mult. and inv.",true,[IsGeneralMapping and IsCompositionMappingRep and RespectsMultiplication and RespectsInverses],0,COM_FUN(18));
InstallMethod(CoKernelOfMultiplicativeGeneralMapping,"for a composition mapping that resp. mult. and inv.",true,[IsGeneralMapping and IsCompositionMappingRep and RespectsMultiplication and RespectsInverses],0,COM_FUN(19));
InstallMethod(ViewObj,"for a composition mapping",true,[IsCompositionMappingRep],100,COM_FUN(20));
InstallMethod(PrintObj,"for a composition mapping",true,[IsCompositionMappingRep],100,COM_FUN(21));
DeclareRepresentation("IsMappingByFunctionRep",IsMapping and IsAttributeStoringRep,["fun"]);
DeclareRepresentation("IsMappingByFunctionWithInverseRep",IsMappingByFunctionRep and IsBijective,["fun","invFun"]);
DeclareRepresentation("IsNonSPMappingByFunctionRep",IsNonSPGeneralMapping and IsMappingByFunctionRep,[]);
DeclareRepresentation("IsNonSPMappingByFunctionWithInverseRep",IsMappingByFunctionWithInverseRep and IsNonSPMappingByFunctionRep,["fun","invFun"]);
DeclareRepresentation("IsSPMappingByFunctionRep",IsSPGeneralMapping and IsMappingByFunctionRep,[]);
DeclareRepresentation("IsSPMappingByFunctionWithInverseRep",IsMappingByFunctionWithInverseRep and IsSPMappingByFunctionRep,["fun","invFun"]);
InstallGlobalFunction(MappingByFunction,COM_FUN(22));
InstallMethod(ImageElm,"for mapping by function",FamSourceEqFamElm,[IsMappingByFunctionRep,IsObject],0,COM_FUN(23));
InstallMethod(ImagesElm,"for mapping by function",FamSourceEqFamElm,[IsMappingByFunctionRep,IsObject],0,COM_FUN(24));
InstallMethod(ImagesRepresentative,"for mapping by function",FamSourceEqFamElm,[IsMappingByFunctionRep,IsObject],0,COM_FUN(25));
InstallMethod(PreImagesRepresentative,"for mapping by function",FamRangeEqFamElm,[IsMappingByFunctionRep,IsObject],0,COM_FUN(26));
InstallMethod(PreImageElm,"for mapping by function",FamRangeEqFamElm,[IsMappingByFunctionWithInverseRep,IsObject],0,COM_FUN(27));
InstallMethod(PreImagesElm,"for mapping by function",FamRangeEqFamElm,[IsMappingByFunctionWithInverseRep,IsObject],0,COM_FUN(28));
InstallMethod(PreImagesRepresentative,"for mapping by function with inverse",FamRangeEqFamElm,[IsMappingByFunctionWithInverseRep,IsObject],0,COM_FUN(29));
InstallMethod(InverseGeneralMapping,"for mapping by function",true,[IsMappingByFunctionWithInverseRep],0,COM_FUN(30));
InstallMethod(ViewObj,"for mapping by function",true,[IsMappingByFunctionRep],0,COM_FUN(31));
InstallMethod(PrintObj,"for mapping by function",true,[IsMappingByFunctionRep],0,COM_FUN(32));
InstallMethod(ViewObj,"for mapping by function with inverse",true,[IsMappingByFunctionWithInverseRep],0,COM_FUN(33));
InstallMethod(PrintObj,"for mapping by function with inverse",true,[IsMappingByFunctionWithInverseRep],0,COM_FUN(34));
DeclareRepresentation("IsInverseGeneralMappingRep",IsNonSPGeneralMapping,[]);
InstallImmediateMethod(InverseGeneralMapping,IsGeneralMapping and HasInverse and IsAttributeStoringRep,0,COM_FUN(35));
InstallMethod(InverseGeneralMapping,"for a general mapping",true,[IsGeneralMapping],0,COM_FUN(36));
InstallMethod(IsSingleValued,"for an inverse mapping",true,[IsGeneralMapping and IsInverseGeneralMappingRep],0,COM_FUN(37));
InstallMethod(IsInjective,"for an inverse mapping",true,[IsGeneralMapping and IsInverseGeneralMappingRep],0,COM_FUN(38));
InstallMethod(IsSurjective,"for an inverse mapping",true,[IsGeneralMapping and IsInverseGeneralMappingRep],0,COM_FUN(39));
InstallMethod(IsTotal,"for an inverse mapping",true,[IsGeneralMapping and IsInverseGeneralMappingRep],0,COM_FUN(40));
InstallMethod(CoKernelOfAdditiveGeneralMapping,"for an inverse mapping",true,[IsGeneralMapping and IsInverseGeneralMappingRep],0,COM_FUN(41));
InstallMethod(KernelOfAdditiveGeneralMapping,"for an inverse mapping",true,[IsGeneralMapping and IsInverseGeneralMappingRep],0,COM_FUN(42));
InstallMethod(CoKernelOfMultiplicativeGeneralMapping,"for an inverse mapping",true,[IsGeneralMapping and IsInverseGeneralMappingRep],0,COM_FUN(43));
InstallMethod(KernelOfMultiplicativeGeneralMapping,"for an inverse mapping",true,[IsGeneralMapping and IsInverseGeneralMappingRep],0,COM_FUN(44));
InstallMethod(ImageElm,"for an inverse mapping and an element",FamSourceEqFamElm,[IsMapping and IsInverseGeneralMappingRep,IsObject],0,COM_FUN(45));
InstallMethod(ImagesElm,"for an inverse mapping and an element",FamSourceEqFamElm,[IsGeneralMapping and IsInverseGeneralMappingRep,IsObject],0,COM_FUN(46));
InstallMethod(ImagesSet,"for an inverse mapping and a collection",CollFamSourceEqFamElms,[IsGeneralMapping and IsInverseGeneralMappingRep,IsCollection],0,COM_FUN(47));
InstallMethod(ImagesRepresentative,"for an inverse mapping and an element",FamSourceEqFamElm,[IsGeneralMapping and IsInverseGeneralMappingRep,IsObject],0,COM_FUN(48));
InstallMethod(PreImageElm,"for an inj. & surj. inverse mapping, and an element",FamRangeEqFamElm,[IsGeneralMapping and IsInverseGeneralMappingRep and IsInjective and IsSurjective,IsObject],0,COM_FUN(49));
InstallMethod(PreImagesElm,"for an inverse mapping and an element",FamRangeEqFamElm,[IsGeneralMapping and IsInverseGeneralMappingRep,IsObject],0,COM_FUN(50));
InstallMethod(PreImagesSet,"for an inverse mapping and a collection",CollFamRangeEqFamElms,[IsGeneralMapping and IsInverseGeneralMappingRep,IsCollection],0,COM_FUN(51));
InstallMethod(PreImagesRepresentative,"for an inverse mapping and an element",FamRangeEqFamElm,[IsInverseGeneralMappingRep,IsObject],0,COM_FUN(52));
InstallMethod(ViewObj,"for an inverse mapping",true,[IsGeneralMapping and IsInverseGeneralMappingRep],100,COM_FUN(53));
InstallMethod(PrintObj,"for an inverse mapping",true,[IsGeneralMapping and IsInverseGeneralMappingRep],100,COM_FUN(54));
BindGlobal("ImmediateImplicationsIdentityMapping",COM_FUN(55));
InstallMethod(IdentityMapping,"for a collection",true,[IsCollection],0,COM_FUN(56));
InstallMethod(\^,"for identity mapping and integer",true,[IsGeneralMapping and IsOne,IsInt],SUM_FLAGS,COM_FUN(57));
InstallMethod(ImageElm,"for identity mapping and object",FamSourceEqFamElm,[IsGeneralMapping and IsOne,IsObject],SUM_FLAGS,COM_FUN(58));
InstallMethod(ImagesElm,"for identity mapping and object",FamSourceEqFamElm,[IsGeneralMapping and IsOne,IsObject],SUM_FLAGS,COM_FUN(59));
InstallMethod(ImagesSet,"for identity mapping and collection",CollFamSourceEqFamElms,[IsGeneralMapping and IsOne,IsCollection],SUM_FLAGS,COM_FUN(60));
InstallMethod(ImagesSource,"for identity mapping",true,[IsGeneralMapping and IsOne],SUM_FLAGS,COM_FUN(61));
InstallMethod(ImagesRepresentative,"for identity mapping and object",FamSourceEqFamElm,[IsGeneralMapping and IsOne,IsObject],SUM_FLAGS,COM_FUN(62));
InstallMethod(PreImageElm,"for identity mapping and object",FamRangeEqFamElm,[IsGeneralMapping and IsOne,IsObject],SUM_FLAGS,COM_FUN(63));
InstallMethod(PreImagesElm,"for identity mapping and object",FamRangeEqFamElm,[IsGeneralMapping and IsOne,IsObject],SUM_FLAGS,COM_FUN(64));
InstallMethod(PreImagesSet,"for identity mapping and collection",CollFamRangeEqFamElms,[IsGeneralMapping and IsOne,IsCollection],SUM_FLAGS,COM_FUN(65));
InstallMethod(PreImagesRepresentative,"for identity mapping and object",FamRangeEqFamElm,[IsGeneralMapping and IsOne,IsObject],SUM_FLAGS,COM_FUN(66));
InstallMethod(ViewObj,"for identity mapping",true,[IsGeneralMapping and IsOne],SUM_FLAGS,COM_FUN(67));
InstallMethod(PrintObj,"for identity mapping",true,[IsGeneralMapping and IsOne],SUM_FLAGS,COM_FUN(68));
InstallMethod(CompositionMapping2,"for general mapping and identity mapping",FamSource1EqFamRange2,[IsGeneralMapping,IsGeneralMapping and IsOne],SUM_FLAGS+1,COM_FUN(69));
InstallMethod(CompositionMapping2,"for identity mapping and general mapping",FamSource1EqFamRange2,[IsGeneralMapping and IsOne,IsGeneralMapping],SUM_FLAGS+1,COM_FUN(70));
BindGlobal("ImmediateImplicationsZeroMapping",COM_FUN(71));
InstallMethod(ZeroMapping,"for collection and additive-magma-with-zero",true,[IsCollection,IsAdditiveMagmaWithZero],0,COM_FUN(72));
InstallMethod(\^,"for zero mapping and positive integer",true,[IsGeneralMapping and IsZero,IsPosInt],SUM_FLAGS,COM_FUN(73));
InstallMethod(ImagesSource,"for zero mapping",true,[IsGeneralMapping and IsZero],SUM_FLAGS,COM_FUN(74));
InstallMethod(ImageElm,"for zero mapping and object",FamSourceEqFamElm,[IsGeneralMapping and IsZero,IsObject],SUM_FLAGS,COM_FUN(75));
InstallMethod(ImagesElm,"for zero mapping and object",FamSourceEqFamElm,[IsGeneralMapping and IsZero,IsObject],SUM_FLAGS,COM_FUN(76));
InstallMethod(ImagesSet,"for zero mapping and collection",CollFamSourceEqFamElms,[IsGeneralMapping and IsZero,IsCollection],SUM_FLAGS,COM_FUN(77));
InstallMethod(ImagesRepresentative,"for zero mapping and object",FamSourceEqFamElm,[IsGeneralMapping and IsZero,IsObject],SUM_FLAGS,COM_FUN(78));
InstallMethod(PreImagesElm,"for zero mapping and object",FamRangeEqFamElm,[IsGeneralMapping and IsZero,IsObject],SUM_FLAGS,COM_FUN(79));
InstallMethod(PreImagesSet,"for zero mapping and collection",CollFamRangeEqFamElms,[IsGeneralMapping and IsZero,IsCollection],SUM_FLAGS,COM_FUN(80));
InstallMethod(PreImagesRepresentative,"for zero mapping and object",FamRangeEqFamElm,[IsGeneralMapping and IsZero,IsObject],SUM_FLAGS,COM_FUN(81));
InstallMethod(ViewObj,"for zero mapping",true,[IsGeneralMapping and IsZero],SUM_FLAGS,COM_FUN(82));
InstallMethod(PrintObj,"for zero mapping",true,[IsGeneralMapping and IsZero],SUM_FLAGS,COM_FUN(83));
InstallMethod(CompositionMapping2,"for general mapping and zero mapping",FamSource1EqFamRange2,[IsGeneralMapping,IsGeneralMapping and IsZero],SUM_FLAGS,COM_FUN(84));
InstallMethod(CompositionMapping2,"for zero mapping and single-valued gen. mapping that resp. zero",FamSource1EqFamRange2,[IsGeneralMapping and IsZero,IsGeneralMapping and IsSingleValued and RespectsZero],SUM_FLAGS,COM_FUN(85));
InstallMethod(IsInjective,"for zero mapping",true,[IsGeneralMapping and IsZero],0,COM_FUN(86));
InstallMethod(IsSurjective,"for zero mapping",true,[IsGeneralMapping and IsZero],0,COM_FUN(87));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/mapprep.gi"

#F  file="lib/mapphomo.gi" crc=52552515
RANK_FILTER_LIST  := [ 63580652, 7, 63580652, 7, 63580652, 7, 56077421, 11, 
  27241101, 13, 56077421, 11, 48867861, 13, 11226115, 13, 11226115, 13, 
  7697887, 14, 1, 0, 7697887, 14, 29419057, 18, 33431468, 20, 29419057, 18, 
  7697887, 14, 1, 0, 7697887, 14, 29419057, 18, 33431468, 20, 29419057, 18, 
  63580652, 7, 63580652, 7, 63580652, 7, 21835728, 11, 60108287, 13, 
  29841145, 21, 21835728, 11, 14626168, 13, 15601301, 13, 15601301, 13, 
  12073073, 14, 1, 0, 12073073, 14, 63241866, 16, 12073073, 14, 1, 0, 
  12073073, 14, 63241866, 16, 63580652, 7, 45428403, 15, 45428403, 15, 
  35666708, 16, 48094768, 22, 35666708, 16, 48094768, 22, 63580652, 7, 
  20744286, 18, 59785924, 34, 28163477, 20, 55224093, 36, 20744286, 18, 
  59785924, 34, 28163477, 20, 55224093, 36, 56371092, 9, 56371092, 9, 
  41448670, 11, 41448670, 11, 48867861, 13, 48867861, 13, 4016555, 15, 
  4016555, 15, 61443883, 11, 61443883, 11, 14626168, 13, 14626168, 13, 
  8391741, 15, 8391741, 15, 60578198, 17, 60578198, 17, 889470, 19, 889470, 
  19, 31985376, 17, 31985376, 17, 17062954, 19, 17062954, 19, 24482145, 21, 
  24482145, 21 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/mapphomo.gi", 52552515 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/mapphomo.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/mapphomo.gi");
elif COM_RESULT = 3  then
Revision.mapphomo_gi:="@(#)$Id: mapphomo.gi,v 4.30 2003/08/23 18:59:19 gap Exp $";
InstallMethod(RespectsMultiplication,"method for a general mapping",[IsGeneralMapping],COM_FUN(1));
InstallMethod(RespectsOne,"method for a general mapping",[IsGeneralMapping],COM_FUN(2));
InstallMethod(RespectsInverses,"method for a general mapping",[IsGeneralMapping],COM_FUN(3));
InstallMethod(KernelOfMultiplicativeGeneralMapping,"method for a finite general mapping",[IsGeneralMapping and RespectsMultiplication and RespectsOne],COM_FUN(4));
InstallMethod(KernelOfMultiplicativeGeneralMapping,"method for an injective gen. mapping that respects mult. and one",[IsGeneralMapping and RespectsMultiplication and RespectsOne and IsInjective],SUM_FLAGS,COM_FUN(5));
InstallMethod(CoKernelOfMultiplicativeGeneralMapping,"method for a finite general mapping",[IsGeneralMapping and RespectsMultiplication and RespectsOne],COM_FUN(6));
InstallMethod(CoKernelOfMultiplicativeGeneralMapping,"method for a single-valued gen. mapping that respects mult. and one",[IsGeneralMapping and RespectsMultiplication and RespectsOne and IsSingleValued],SUM_FLAGS,COM_FUN(7));
InstallMethod(IsSingleValued,"method for a gen. mapping that respects mult. and inverses",[IsGeneralMapping and RespectsMultiplication and RespectsInverses],COM_FUN(8));
InstallMethod(IsInjective,"method for a gen. mapping that respects mult. and one",[IsGeneralMapping and RespectsMultiplication and RespectsInverses],COM_FUN(9));
InstallMethod(ImagesElm,"method for s.p. general mapping respecting mult. & inv., and element",FamSourceEqFamElm,[IsSPGeneralMapping and RespectsMultiplication and RespectsInverses,IsObject],COM_FUN(10));
InstallMethod(ImagesSet,"method for s.p. general mapping respecting mult. & inv., and group",CollFamSourceEqFamElms,[IsSPGeneralMapping and RespectsMultiplication and RespectsInverses,IsGroup],COM_FUN(11));
InstallMethod(ImagesSet,"method for injective s.p. mapping respecting mult. & inv., and group",CollFamSourceEqFamElms,[IsSPGeneralMapping and IsMapping and IsInjective and RespectsMultiplication and RespectsInverses,IsGroup],COM_FUN(12));
InstallMethod(PreImagesElm,"method for s.p. general mapping respecting mult. & inv., and element",FamRangeEqFamElm,[IsSPGeneralMapping and RespectsMultiplication and RespectsInverses,IsObject],COM_FUN(13));
InstallMethod(PreImagesSet,"method for s.p. general mapping respecting mult. & inv., and group",CollFamRangeEqFamElms,[IsSPGeneralMapping and RespectsMultiplication and RespectsInverses,IsGroup],COM_FUN(14));
InstallMethod(PreImagesSet,"method for injective s.p. mapping respecting mult. & inv., and group",CollFamRangeEqFamElms,[IsSPGeneralMapping and IsMapping and IsInjective and RespectsMultiplication and RespectsInverses,IsGroup],COM_FUN(15));
InstallMethod(RespectsAddition,"method for a general mapping",[IsGeneralMapping],COM_FUN(16));
InstallMethod(RespectsZero,"method for a general mapping",[IsGeneralMapping],COM_FUN(17));
InstallMethod(RespectsAdditiveInverses,"method for a general mapping",[IsGeneralMapping],COM_FUN(18));
InstallMethod(KernelOfAdditiveGeneralMapping,"method for a finite general mapping",[IsGeneralMapping and RespectsAddition and RespectsZero],COM_FUN(19));
InstallMethod(KernelOfAdditiveGeneralMapping,"method for an injective gen. mapping that respects add. and zero",[IsGeneralMapping and RespectsAddition and RespectsZero and IsInjective],SUM_FLAGS,COM_FUN(20));
InstallMethod(KernelOfAdditiveGeneralMapping,"method for zero mapping",[IsGeneralMapping and RespectsAddition and RespectsZero and IsZero],SUM_FLAGS,Source);
InstallMethod(CoKernelOfAdditiveGeneralMapping,"method for a finite general mapping",[IsGeneralMapping and RespectsAddition and RespectsZero],COM_FUN(21));
InstallMethod(CoKernelOfAdditiveGeneralMapping,"method for a single-valued gen. mapping that respects add. and zero",[IsGeneralMapping and RespectsAddition and RespectsZero and IsSingleValued],SUM_FLAGS,COM_FUN(22));
InstallMethod(IsSingleValued,"method for a gen. mapping that respects add. and add. inverses",[IsGeneralMapping and RespectsAddition and RespectsAdditiveInverses],COM_FUN(23));
InstallMethod(IsInjective,"method for a gen. mapping that respects add. and add. inverses",[IsGeneralMapping and RespectsAddition and RespectsAdditiveInverses],COM_FUN(24));
InstallMethod(ImagesElm,"method for s.p. gen. mapping respecting add. & add.inv., and element",FamSourceEqFamElm,[IsSPGeneralMapping and RespectsAddition and RespectsAdditiveInverses,IsObject],COM_FUN(25));
InstallMethod(ImagesSet,"method for s.p. gen. mapping resp. add. & add.inv., and add. group",CollFamSourceEqFamElms,[IsSPGeneralMapping and RespectsAddition and RespectsAdditiveInverses,IsAdditiveGroup],COM_FUN(26));
InstallMethod(PreImagesElm,"method for s.p. gen. mapping respecting add. & add.inv., and element",FamRangeEqFamElm,[IsSPGeneralMapping and RespectsAddition and RespectsAdditiveInverses,IsObject],COM_FUN(27));
InstallMethod(PreImagesSet,"method for s.p. gen. mapping resp. add. & add.inv., and add. group",CollFamRangeEqFamElms,[IsSPGeneralMapping and RespectsAddition and RespectsAdditiveInverses,IsAdditiveGroup],COM_FUN(28));
InstallMethod(RespectsScalarMultiplication,"method for a general mapping",[IsGeneralMapping],COM_FUN(29));
InstallMethod(KernelOfAdditiveGeneralMapping,"method for a finite linear mapping",[IsGeneralMapping and RespectsAddition and RespectsZero and RespectsScalarMultiplication],COM_FUN(30));
InstallMethod(CoKernelOfAdditiveGeneralMapping,"method for a finite linear mapping",[IsGeneralMapping and RespectsAddition and RespectsZero and RespectsScalarMultiplication],COM_FUN(31));
InstallMethod(ImagesSet,"method for linear mapping and left module",CollFamSourceEqFamElms,[IsSPGeneralMapping and RespectsAddition and RespectsAdditiveInverses and RespectsScalarMultiplication,IsLeftModule],COM_FUN(32));
InstallMethod(PreImagesSet,"method for linear mapping and left module",CollFamRangeEqFamElms,[IsSPGeneralMapping and RespectsAddition and RespectsAdditiveInverses and RespectsScalarMultiplication,IsLeftModule],COM_FUN(33));
InstallMethod(IsFieldHomomorphism,"method for a general mapping",[IsGeneralMapping],COM_FUN(34));
InstallMethod(ImagesSet,"method for algebra hom. and FLMLOR",CollFamSourceEqFamElms,[IsSPGeneralMapping and RespectsAddition and RespectsAdditiveInverses and RespectsScalarMultiplication and RespectsMultipli\
cation,IsFLMLOR],COM_FUN(35));
InstallMethod(ImagesSet,"method for algebra-with-one hom. and FLMLOR-with-one",CollFamSourceEqFamElms,[IsSPGeneralMapping and RespectsAddition and RespectsAdditiveInverses and RespectsScalarMultiplication and RespectsMultiplication and RespectsOne,IsFLMLORWithOne],COM_FUN(36));
InstallMethod(PreImagesSet,"method for algebra hom. and FLMLOR",CollFamRangeEqFamElms,[IsSPGeneralMapping and RespectsAddition and RespectsAdditiveInverses and RespectsScalarMultiplication and RespectsMultipli\
cation,IsFLMLOR],COM_FUN(37));
InstallMethod(PreImagesSet,"method for algebra-with-one hom. and FLMLOR-with-one",CollFamRangeEqFamElms,[IsSPGeneralMapping and RespectsAddition and RespectsAdditiveInverses and RespectsScalarMultiplication and RespectsMultiplication and RespectsOne,IsFLMLORWithOne],COM_FUN(38));
InstallEqMethodForMappingsFromGenerators(IsObject,AsList,IsObject,"");
InstallEqMethodForMappingsFromGenerators(IsMagma,GeneratorsOfMagma,RespectsMultiplication," that respect mult.");
InstallEqMethodForMappingsFromGenerators(IsMagmaWithOne,GeneratorsOfMagmaWithOne,RespectsMultiplication and RespectsOne," that respect mult. and one");
InstallEqMethodForMappingsFromGenerators(IsMagmaWithInverses,GeneratorsOfMagmaWithInverses,RespectsMultiplication and RespectsInverses," that respect mult. and inv.");
InstallEqMethodForMappingsFromGenerators(IsAdditiveMagma,GeneratorsOfAdditiveMagma,RespectsAddition," that respect add.");
InstallEqMethodForMappingsFromGenerators(IsAdditiveMagmaWithZero,GeneratorsOfAdditiveMagmaWithZero,RespectsAddition and RespectsZero," that respect add. and zero");
InstallEqMethodForMappingsFromGenerators(IsAdditiveGroup,GeneratorsOfAdditiveGroup,RespectsAddition and RespectsAdditiveInverses," that respect add. and add. inv.");
InstallEqMethodForMappingsFromGenerators(IsRing,GeneratorsOfRing,RespectsMultiplication and RespectsAddition and RespectsAdditiveInverses," that respect mult.,add.,add.inv.");
InstallEqMethodForMappingsFromGenerators(IsRingWithOne,GeneratorsOfRingWithOne,RespectsMultiplication and RespectsOne and RespectsAddition and RespectsAdditiveInverses," that respect mult.,one,add.,add.inv.");
InstallEqMethodForMappingsFromGenerators(IsLeftModule,GeneratorsOfLeftModule,RespectsAddition and RespectsAdditiveInverses and RespectsScalarMultiplication," that respect add.,add.inv.,scal. mult.");
InstallEqMethodForMappingsFromGenerators(IsLeftOperatorRing,GeneratorsOfLeftOperatorRing,RespectsAddition and RespectsAdditiveInverses and RespectsMultiplication and RespectsScalarMultiplication," that respect add.,add.inv.,mult.,scal. mult.");
InstallEqMethodForMappingsFromGenerators(IsLeftOperatorRingWithOne,GeneratorsOfLeftOperatorRingWithOne,RespectsAddition and RespectsAdditiveInverses and RespectsMultiplication and RespectsOne and RespectsScalarMultiplication," that respect add.,add.inv.,mult.,one,scal. mult.");
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/mapphomo.gi"

#F  file="lib/relation.gi" crc=-13112907
RANK_FILTER_LIST  := [ 33103423, 9, 33103423, 9, 33103423, 9, 33103423, 9, 
  33103423, 9, 33103423, 9, 33103423, 9, 33103423, 9, 33103423, 9, 33103423, 
  9, 33103423, 9, 62913316, 11, 33103423, 9, 51026709, 12, 51026709, 12, 
  51026709, 12, 51026709, 12, 51026709, 12, 51026709, 12, 51026709, 12, 
  51026709, 12, 51026709, 12, 51026709, 12, 51026709, 12, 7665940, 19, 
  51026709, 12, 7665940, 19, 33103423, 9, 51026709, 12, 51026709, 12, 8193, 
  2, 51026709, 12, 51026709, 12, 51026709, 12, 51026709, 12, 51026709, 12, 
  63734282, 6, 51026709, 12, 51026709, 12, 63734282, 6, 51026709, 12, 513, 8, 
  513, 8, 51026709, 12, 51026709, 12, 4063233, 1, 4063233, 1, 51026709, 12, 
  51026709, 12, 51026709, 12, 51026709, 12, 51026709, 12, 7665940, 19, 
  51026709, 12, 4063233, 1, 51026709, 12, 51026709, 12, 30666573, 21, 
  51026709, 12, 51026709, 12, 51026709, 12, 7208616, 21, 7208616, 21, 
  7208616, 21, 7208616, 21, 7208616, 21, 7208616, 21, 7208616, 21, 7208616, 
  21, 8193, 2, 61734403, 22, 7208616, 21, 1, 0, 7208616, 21, 1, 0, 61734403, 
  22, 1, 0, 61734403, 22, 1, 0, 7208616, 21, 7208616, 21, 7208616, 21, 
  8126465, 2, 7208616, 21, 1, 0, 7208616, 21, 1, 0, 16776512, 6, 1, 0, 
  16776512, 6, 16776512, 6, 16776512, 6, 16776512, 6, 16776512, 6, 16776512, 
  6 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/relation.gi", -13112907 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/relation.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/relation.gi");
elif COM_RESULT = 3  then
Revision.relation_gi:="@(#)$Id: relation.gi,v 4.53 2002/05/29 12:32:09 gap Exp $";
DeclareRepresentation("IsBinaryRelationDefaultRep",IsAttributeStoringRep,[]);
DeclareRepresentation("IsBinaryRelationOnPointsRep",IsAttributeStoringRep,[]);
DeclareRepresentation("IsEquivalenceRelationDefaultRep",IsAttributeStoringRep,[]);
DeclareRepresentation("IsEquivalenceClassDefaultRep",IsAttributeStoringRep and IsComponentObjectRep,rec());
InstallGlobalFunction(IdentityBinaryRelation,COM_FUN(1));
InstallGlobalFunction(EmptyBinaryRelation,COM_FUN(2));
InstallGlobalFunction(BinaryRelationByElements,COM_FUN(3));
InstallMethod(IsReflexiveBinaryRelation,"reflexive test binary relation",true,[IsBinaryRelation],0,COM_FUN(4));
InstallMethod(IsSymmetricBinaryRelation,"symmetric test binary relation",true,[IsBinaryRelation],0,COM_FUN(5));
InstallMethod(IsTransitiveBinaryRelation,"transitive test binary relation",true,[IsBinaryRelation],0,COM_FUN(6));
InstallMethod(IsAntisymmetricBinaryRelation,"test for Antisymmetry of a binary relation",true,[IsBinaryRelation],0,COM_FUN(7));
InstallMethod(IsPreOrderBinaryRelation,"test for whether a binary relation is a preorder",true,[IsBinaryRelation],0,COM_FUN(8));
InstallMethod(IsPartialOrderBinaryRelation,"test for whether a binary relation is a partial order",true,[IsBinaryRelation],0,COM_FUN(9));
InstallMethod(IsLatticeOrderBinaryRelation,"test for whether a binary relation is a lattice order",true,[IsBinaryRelation],0,COM_FUN(10));
InstallMethod(IsEquivalenceRelation,"test for equivalence relation",true,[IsBinaryRelation],0,COM_FUN(11));
InstallMethod(ReflexiveClosureBinaryRelation,"for binary relation",true,[IsBinaryRelation],0,COM_FUN(12));
InstallMethod(SymmetricClosureBinaryRelation,"for binary relation",true,[IsBinaryRelation],0,COM_FUN(13));
InstallMethod(TransitiveClosureBinaryRelation,"for binary relation",true,[IsBinaryRelation],0,COM_FUN(14));
InstallMethod(HasseDiagramBinaryRelation,"for binary relation",true,[IsBinaryRelation and IsPartialOrderBinaryRelation],0,COM_FUN(15));
InstallGlobalFunction(PartialOrderByOrderingFunction,COM_FUN(16));
InstallMethod(StronglyConnectedComponents,"for general binary relations",true,[IsBinaryRelation],0,COM_FUN(17));
DeclareSynonym("ImagesListOfBinaryRelation",Successors);
DeclareSynonym("BinaryRelationByListOfImages",BinaryRelationOnPoints);
DeclareSynonym("BinaryRelationByListOfImagesNC",BinaryRelationOnPointsNC);
InstallGlobalFunction(BinaryRelationOnPointsNC,COM_FUN(18));
InstallGlobalFunction(BinaryRelationOnPoints,COM_FUN(19));
InstallGlobalFunction(AsBinaryRelationOnPoints,COM_FUN(20));
InstallGlobalFunction(RandomBinaryRelationOnPoints,COM_FUN(21));
InstallMethod(IsReflexiveBinaryRelation,"for binary relations on points",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(22));
InstallMethod(IsSymmetricBinaryRelation,"for binary relations on points",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(23));
InstallMethod(IsTransitiveBinaryRelation,"for binary relations on points",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(24));
InstallMethod(IsAntisymmetricBinaryRelation,"for binary relations on points",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(25));
InstallMethod(IsPreOrderBinaryRelation,"for binary relations on points",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(26));
InstallMethod(IsPartialOrderBinaryRelation,"for binary relations on points",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(27));
InstallMethod(IsEquivalenceRelation,"for binary relations on points",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(28));
InstallMethod(ReflexiveClosureBinaryRelation,"for binary relations on points",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(29));
InstallMethod(SymmetricClosureBinaryRelation,"for binary relations on points",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(30));
InstallMethod(TransitiveClosureBinaryRelation,"for binary relations on points",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(31));
InstallMethod(ImagesElm,"for binary relations over [1..n] with images list",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep,IsPosInt],0,COM_FUN(32));
InstallMethod(PreImagesElm,"for binary rels over [1..n] with images list",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep,IsPosInt],0,COM_FUN(33));
InstallMethod(Successors,"for a generic relation",true,[IsBinaryRelation],0,COM_FUN(34));
InstallMethod(\=,"for binary relss over [1..n] with images list",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep,IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(35));
InstallMethod(\in,"for binary rels over [1..n] with images list",true,[IsList,IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(36));
InstallMethod(\<,"for binary rels over [1..n] with images list",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep,IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(37));
InstallMethod(\*,"for binary relations on points",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep,IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(38));
InstallOtherMethod(\*,"for transformation and binary relation on points",true,[IsTransformation,IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(39));
InstallOtherMethod(\*,"for binary relation on points and transformation",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep,IsTransformation],0,COM_FUN(40));
InstallOtherMethod(\*,"for binary relation on points and permutation",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep,IsPerm],0,COM_FUN(41));
InstallOtherMethod(\*,"for permutation and binary relation on points",true,[IsPerm,IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(42));
InstallOtherMethod(\*,"for binary relation on points and list",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep,IsListOrCollection],0,COM_FUN(43));
InstallOtherMethod(\*,"for list and binary relation on points",true,[IsListOrCollection,IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(44));
InstallMethod(\+,"for binary relations on points",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep,IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(45));
InstallMethod(\-,"for binary relations on points",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep,IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(46));
InstallMethod(\^,"for binary relation on points and a positive int",true,[IsPosInt,IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(47));
InstallMethod(POW,"for binary relation on points and a set of integers",true,[IsListOrCollection,IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(48));
InstallMethod(POW,"for binary relation on points and Zero",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep,IsZeroCyc],0,COM_FUN(49));
InstallMethod(InverseOp,"for binary relation on points and a set of integers",\
true,[IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(50));
InstallMethod(One,"for binary relation on points and a set of integers",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(51));
InstallMethod(PrintObj,"for a binary relation on  n points",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(52));
InstallGlobalFunction(EquivalenceRelationByPartition,COM_FUN(53));
InstallGlobalFunction(EquivalenceRelationByPartitionNC,COM_FUN(54));
InstallGlobalFunction(EquivalenceRelationByRelation,COM_FUN(55));
InstallGlobalFunction(EquivalenceRelationByProperty,COM_FUN(56));
InstallGlobalFunction(EquivalenceRelationByPairsNC,COM_FUN(57));
InstallGlobalFunction(EquivalenceRelationByPairs,COM_FUN(58));
InstallMethod(EquivalenceRelationPartition,"compute the partition for an arbitrary equiv rel",true,[IsEquivalenceRelation],0,COM_FUN(59));
InstallMethod(JoinEquivalenceRelations,"join of two equivalence relations",true,[IsEquivalenceRelation,IsEquivalenceRelation],0,COM_FUN(60));
InstallMethod(MeetEquivalenceRelations,"meet of two equivalence relations",true,[IsEquivalenceRelation,IsEquivalenceRelation],0,COM_FUN(61));
InstallMethod(GeneratorsOfEquivalenceRelationPartition,"generators for an equivalence with a partition",true,[IsEquivalenceRelation],0,COM_FUN(62));
InstallMethod(\=,"for eqivalence relations",IsIdenticalObj,[IsEquivalenceRelation,IsEquivalenceRelation],0,COM_FUN(63));
InstallMethod(\in,"for eq relation with partition",true,[IsList,IsEquivalenceRelation and HasEquivalenceRelationPartition],1,COM_FUN(64));
InstallMethod(ImagesRepresentative,"equivalence relations",FamSourceEqFamElm,[IsEquivalenceRelation,IsObject],0,COM_FUN(65));
InstallMethod(PreImagesRepresentative,"equivalence relations",FamRangeEqFamElm,[IsEquivalenceRelation,IsObject],0,COM_FUN(66));
InstallMethod(ImagesElm,"for equivalence relation with partition and element",FamSourceEqFamElm,[IsEquivalenceRelation and HasEquivalenceRelationPartition,IsObject],0,COM_FUN(67));
InstallMethod(PreImagesElm,"equivalence relations with parition and element",FamRangeEqFamElm,[IsEquivalenceRelation and HasEquivalenceRelationPartition,IsObject],0,COM_FUN(68));
InstallMethod(PrintObj,"for an equivalence relation",true,[IsEquivalenceRelation],0,COM_FUN(69));
InstallMethod(EquivalenceClasses,"wraparound to call 2-argument version",true,[IsEquivalenceRelation],0,COM_FUN(70));
InstallOtherMethod(EquivalenceClasses,"for a generic equivalence relation",true,[IsEquivalenceRelation,IsCollection],0,COM_FUN(71));
InstallMethod(EquivalenceClassOfElementNC,"no check",true,[IsEquivalenceRelation,IsObject],0,COM_FUN(72));
InstallMethod(EquivalenceClassOfElement,"with checking",true,[IsEquivalenceRelation,IsObject],0,COM_FUN(73));
InstallMethod(PrintObj,"for an eq. class",true,[IsEquivalenceClass],0,COM_FUN(74));
InstallMethod(\in,"for element and equivalence class",true,[IsObject,IsEquivalenceClass],0,COM_FUN(75));
InstallMethod(Enumerator,"for equivalence classes",true,[IsEquivalenceClass],0,COM_FUN(76));
InstallMethod(\=,"for two equivalence classes",IsIdenticalObj,[IsEquivalenceClass,IsEquivalenceClass],0,COM_FUN(77));
InstallMethod(\<,"for two equivalence classes",IsIdenticalObj,[IsEquivalenceClass,IsEquivalenceClass],0,COM_FUN(78));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/relation.gi"

#F  file="lib/magma.gi" crc=62026947
RANK_FILTER_LIST  := [ 15635848, 11, 63850528, 12, 9120974, 14, 24755962, 17, 
  15635848, 11, 63850528, 12, 9120974, 14, 24755962, 17, 9120974, 14, 
  24755962, 17, 15635848, 11, 60045706, 14, 5316152, 16, 20951140, 19, 
  15635848, 11, 11831026, 13, 43104550, 15, 29419057, 18, 15635848, 11, 
  32505602, 3, 416560, 13, 32505602, 3, 15635848, 11, 15635848, 11, 416560, 
  13, 15635848, 11, 15635848, 11, 1, 0, 1, 0, 15635848, 11, 11831026, 13, 
  63720617, 15, 15635848, 11, 8126465, 2, 1985, 1, 8193, 2, 8126465, 2, 1985, 
  1, 8193, 2, 8115305, 4, 1985, 1, 67105912, 7, 46909372, 13, 15635848, 11, 
  9120974, 14, 24755962, 17, 9120959, 18, 24755947, 18, 28015173, 14, 
  24755962, 17, 24755947, 18, 14329680, 17, 62544360, 17, 63850528, 12, 
  9120974, 14, 24755962, 17, 61105177, 16, 40153509, 14, 15635848, 11, 
  26617308, 14, 15635848, 11, 1025, 1, 15635848, 11, 46909372, 14, 40153509, 
  15, 46909372, 14, 13354235, 47, 15636840, 13, 15635848, 11, 15635848, 11, 
  46909372, 14, 46909372, 14, 33223879, 17, 33223879, 17, 15635848, 11, 
  15635848, 11, 46909372, 14, 46909372, 14, 33223879, 17, 33223879, 17, 
  15635848, 11, 8126465, 2, 23214719, 5, 8126465, 2 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/magma.gi", 62026947 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/magma.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/magma.gi");
elif COM_RESULT = 3  then
Revision.magma_gi:="@(#)$Id: magma.gi,v 4.59.2.2 2005/08/24 14:13:19 gap Exp $";
InstallMethod(PrintObj,"for a magma",true,[IsMagma],0,COM_FUN(1));
InstallMethod(PrintObj,"for a magma with generators",true,[IsMagma and HasGeneratorsOfMagma],0,COM_FUN(2));
InstallMethod(PrintObj,"for a magma-with-one with generators",true,[IsMagmaWithOne and HasGeneratorsOfMagmaWithOne],0,COM_FUN(3));
InstallMethod(PrintObj,"for a magma-with-inverses with generators",true,[IsMagmaWithInverses and HasGeneratorsOfMagmaWithInverses],0,COM_FUN(4));
InstallMethod(ViewObj,"for a magma",true,[IsMagma],0,COM_FUN(5));
InstallMethod(ViewObj,"for a magma with generators",true,[IsMagma and HasGeneratorsOfMagma],0,COM_FUN(6));
InstallMethod(ViewObj,"for a magma-with-one with generators",true,[IsMagmaWithOne and HasGeneratorsOfMagmaWithOne],0,COM_FUN(7));
InstallMethod(ViewObj,"for a magma-with-inverses with generators",true,[IsMagmaWithInverses and HasGeneratorsOfMagmaWithInverses],0,COM_FUN(8));
InstallImmediateMethod(IsTrivial,IsMagmaWithOne and HasGeneratorsOfMagmaWithOne,0,COM_FUN(9));
InstallImmediateMethod(IsTrivial,IsMagmaWithInverses and HasGeneratorsOfMagmaWithInverses,0,COM_FUN(10));
InstallMethod(IsAssociative,"for a magma",true,[IsMagma],0,COM_FUN(11));
InstallImmediateMethod(IsCommutative,IsMagma and IsAssociative and HasGeneratorsOfMagma,0,COM_FUN(12));
InstallImmediateMethod(IsCommutative,IsMagmaWithOne and IsAssociative and HasGeneratorsOfMagmaWithOne,0,COM_FUN(13));
InstallImmediateMethod(IsCommutative,IsMagmaWithInverses and IsAssociative and HasGeneratorsOfMagmaWithInverses,0,COM_FUN(14));
InstallMethod(IsCommutative,"for a magma",true,[IsMagma],0,IsCommutativeFromGenerators(GeneratorsOfDomain));
InstallMethod(IsCommutative,"for an associative magma",true,[IsMagma and IsAssociative],0,IsCommutativeFromGenerators(GeneratorsOfMagma));
InstallMethod(IsCommutative,"for an associative magma with one",true,[IsMagmaWithOne and IsAssociative],0,IsCommutativeFromGenerators(GeneratorsOfMagmaWithOne));
InstallMethod(IsCommutative,"for an associative magma with inverses",true,[IsMagmaWithInverses and IsAssociative],0,IsCommutativeFromGenerators(GeneratorsOfMagmaWithInverses));
InstallMethod(CentralizerOp,"for a magma, and a mult. element",IsCollsElms,[IsMagma,IsMultiplicativeElement],0,COM_FUN(15));
InstallMethod(CentralizerOp,"for a commutative magma, and a mult. element",IsCollsElms,[IsMagma and IsCommutative,IsMultiplicativeElement],SUM_FLAGS,COM_FUN(16));
InstallMethod(CentralizerOp,"for two magmas",IsIdenticalObj,[IsMagma,IsMagma],0,COM_FUN(17));
InstallMethod(CentralizerOp,"for two magmas, the first being commutative",IsIdenticalObj,[IsMagma and IsCommutative,IsMagma],SUM_FLAGS,COM_FUN(18));
InstallOtherMethod(CentralizerOp,"dummy to ignore optional third argument",true,[IsMagma,IsObject,IsObject],0,COM_FUN(19));
InstallMethod(Centre,"generic method for a magma",[IsMagma],COM_FUN(20));
InstallMethod(Centre,"for an associative magma",[IsMagma and IsAssociative],COM_FUN(21));
InstallMethod(Centre,"for an associative and commutative magma",[IsMagma and IsAssociative and IsCommutative],SUM_FLAGS,IdFunc);
InstallMethod(Idempotents,"for finite magmas",true,[IsMagma],0,COM_FUN(22));
InstallGlobalFunction(Magma,COM_FUN(23));
InstallGlobalFunction(Submagma,COM_FUN(24));
InstallGlobalFunction(SubmagmaNC,COM_FUN(25));
InstallGlobalFunction(MagmaWithOne,COM_FUN(26));
InstallGlobalFunction(SubmagmaWithOne,COM_FUN(27));
InstallGlobalFunction(SubmagmaWithOneNC,COM_FUN(28));
InstallGlobalFunction(MagmaWithInverses,COM_FUN(29));
InstallGlobalFunction(SubmagmaWithInverses,COM_FUN(30));
InstallGlobalFunction(SubmagmaWithInversesNC,COM_FUN(31));
InstallMethod(MagmaByGenerators,"for collection",true,[IsCollection],0,COM_FUN(32));
InstallOtherMethod(MagmaByGenerators,"for family and list",true,[IsFamily,IsList],0,COM_FUN(33));
InstallMethod(MagmaWithOneByGenerators,"for collection",true,[IsCollection],0,COM_FUN(34));
InstallOtherMethod(MagmaWithOneByGenerators,"for family and list",true,[IsFamily,IsList],0,COM_FUN(35));
MakeMagmaWithInversesByFiniteGenerators:=COM_FUN(36);
InstallMethod(MagmaWithInversesByGenerators,"for collection",true,[IsCollection and IsFinite],0,COM_FUN(37));
InstallOtherMethod(MagmaWithInversesByGenerators,"for family and list",true,[IsFamily,IsList and IsFinite],0,COM_FUN(38));
InstallMethod(TrivialSubmagmaWithOne,"for magma-with-one",true,[IsMagmaWithOne],0,COM_FUN(39));
InstallMethod(GeneratorsOfMagma,"generic method for a magma (take domain generators)",true,[IsMagma],0,GeneratorsOfDomain);
InstallMethod(GeneratorsOfMagma,"for a magma-with-one with known generators",true,[IsMagmaWithOne and HasGeneratorsOfMagmaWithOne],0,COM_FUN(40));
InstallMethod(GeneratorsOfMagma,"for a magma-with-inverses with known generators",true,[IsMagmaWithInverses and HasGeneratorsOfMagmaWithInverses],0,COM_FUN(41));
InstallMethod(GeneratorsOfMagma,"for a magma-with-one with generators, all elms. of finite order",true,[IsMagmaWithOne and HasGeneratorsOfMagmaWithOne and IsFiniteOrderElementCollection],0,COM_FUN(42));
InstallMethod(GeneratorsOfMagma,"for a magma-with-inv. with gens., all elms. of finite order",true,[IsMagmaWithInverses and HasGeneratorsOfMagmaWithInverses and IsFiniteOrderElementCollection],0,COM_FUN(43));
InstallMethod(GeneratorsOfMagmaWithOne,"for a magma-with-one with known magma generators (take them)",true,[IsMagmaWithOne and HasGeneratorsOfMagma],0,GeneratorsOfMagma);
InstallMethod(GeneratorsOfMagmaWithOne,"for a magma-with-inverses with generators",true,[IsMagmaWithInverses and HasGeneratorsOfMagmaWithInverses],0,COM_FUN(44));
InstallMethod(GeneratorsOfMagmaWithOne,"for a magma-with-inv. with gens., all elms. of finite order",true,[IsMagmaWithInverses and HasGeneratorsOfMagmaWithInverses and IsFiniteOrderElementCollection],0,GeneratorsOfMagmaWithInverses);
InstallMethod(GeneratorsOfMagmaWithInverses,"for a magma-with-inverses with known magma generators (take them)",true,[IsMagmaWithInverses and HasGeneratorsOfMagma],0,GeneratorsOfMagma);
InstallMethod(GeneratorsOfMagmaWithInverses,"for a magma-with-inverses with known magma-with-one gen.s (take them)",true,[IsMagmaWithInverses and HasGeneratorsOfMagmaWithOne],0,GeneratorsOfMagmaWithOne);
InstallMethod(Representative,"for magma with generators",true,[IsMagma and HasGeneratorsOfMagma],0,RepresentativeFromGenerators(GeneratorsOfMagma));
InstallMethod(Representative,"for magma-with-one with generators",true,[IsMagmaWithOne and HasGeneratorsOfMagmaWithOne],0,RepresentativeFromGenerators(GeneratorsOfMagmaWithOne));
InstallMethod(Representative,"for magma-with-inverses with generators",true,[IsMagmaWithInverses and HasGeneratorsOfMagmaWithInverses],0,RepresentativeFromGenerators(GeneratorsOfMagmaWithInverses));
InstallMethod(Representative,"for magma-with-one with known one",true,[IsMagmaWithOne and HasOne],SUM_FLAGS,One);
InstallMethod(Representative,"for magma-with-one with stored parent",[IsMagmaWithOne and HasParentAttr],COM_FUN(45));
InstallMethod(MultiplicativeNeutralElement,"for a magma",true,[IsMagma],0,COM_FUN(46));
InstallTrueMethod(HasMultiplicativeNeutralElement,IsMagmaWithOne);
InstallMethod(MultiplicativeNeutralElement,"for a magma-with-one",true,[HasMultiplicativeNeutralElement and IsMagmaWithOne],GETTER_FLAGS+1,One);
InstallMethod(SetMultiplicativeNeutralElement,"for a magma-with-one",true,[IsMagma,IsBool],0,COM_FUN(47));
InstallOtherMethod(One,"for a magma",true,[IsMagma],0,COM_FUN(48));
InstallOtherMethod(One,"partial method for a magma-with-one (ask family)",true,[IsMagmaWithOne],100,COM_FUN(49));
InstallOtherMethod(One,"for a magma-with-one that has a parent",true,[IsMagmaWithOne and HasParent],SUM_FLAGS,COM_FUN(50));
InstallOtherMethod(One,"for a magma-with-one",true,[IsMagmaWithOne],0,COM_FUN(51));
BindGlobal("EnumeratorOfTrivialMagmaWithOne",COM_FUN(52));
InstallMethod(Enumerator,"for trivial magma-with-one",true,[IsMagmaWithOne and IsTrivial],0,EnumeratorOfTrivialMagmaWithOne);
BindGlobal("ClosureMagmaDefault",COM_FUN(53));
BindGlobal("EnumeratorOfMagma",COM_FUN(54));
InstallMethod(Enumerator,"generic method for a magma",true,[IsMagma and IsAttributeStoringRep],0,EnumeratorOfMagma);
InstallMethod(IsCentral,"for two magmas",IsIdenticalObj,[IsMagma,IsMagma],0,IsCentralFromGenerators(GeneratorsOfMagma,GeneratorsOfMagma));
InstallMethod(IsCentral,"for two magmas-with-one",IsIdenticalObj,[IsMagmaWithOne,IsMagmaWithOne],0,IsCentralFromGenerators(GeneratorsOfMagmaWithOne,GeneratorsOfMagmaWithOne));
InstallMethod(IsCentral,"for two magmas-with-inverses",IsIdenticalObj,[IsMagmaWithInverses,IsMagmaWithInverses],0,IsCentralFromGenerators(GeneratorsOfMagmaWithInverses,GeneratorsOfMagmaWithInverses));
InstallMethod(IsSubset,"for two magmas",IsIdenticalObj,[IsMagma,IsMagma],0,COM_FUN(55));
InstallMethod(IsSubset,"for two magmas with one",IsIdenticalObj,[IsMagmaWithOne,IsMagmaWithOne],0,COM_FUN(56));
InstallMethod(IsSubset,"for two magmas with inverses",IsIdenticalObj,[IsMagmaWithInverses,IsMagmaWithInverses],0,COM_FUN(57));
InstallMethod(AsMagma,"for a magma (return the argument)",true,[IsMagma],100,IdFunc);
InstallMethod(AsMagma,"generic method for collections",true,[IsCollection],0,COM_FUN(58));
InstallMethod(AsSubmagma,"generic method for a domain and a collection",IsIdenticalObj,[IsDomain,IsCollection],0,COM_FUN(59));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/magma.gi"

#F  file="lib/mgmideal.gi" crc=88540656
RANK_FILTER_LIST  := [ 49189965, 13, 49190280, 14, 12560535, 13, 6411829, 14, 
  46114652, 15, 762915, 16, 49189965, 13, 49190280, 14, 12560535, 13, 
  6411829, 14, 46114652, 15, 762915, 16, 15635848, 11, 8126465, 2, 15635848, 
  11, 8126465, 2, 15635848, 11, 8126465, 2, 23214719, 5, 8126465, 2, 
  46115644, 17, 6411829, 14, 49190280, 14 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/mgmideal.gi", 88540656 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/mgmideal.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/mgmideal.gi");
elif COM_RESULT = 3  then
Revision.mgmideal_gi:="@(#)$Id: mgmideal.gi,v 4.8 2002/04/15 10:05:03 sal Exp $";
InstallMethod(PrintObj,"for a left magma ideal",true,[IsLeftMagmaIdeal],0,COM_FUN(1));
InstallMethod(PrintObj,"for a left magma ideal with known generators",true,[IsLeftMagmaIdeal and HasGeneratorsOfLeftMagmaIdeal],0,COM_FUN(2));
InstallMethod(PrintObj,"for a right magma ideal",true,[IsRightMagmaIdeal],0,COM_FUN(3));
InstallMethod(PrintObj,"for a right magma ideal with known generators",true,[IsRightMagmaIdeal and HasGeneratorsOfRightMagmaIdeal],0,COM_FUN(4));
InstallMethod(PrintObj,"for a magma ideal",true,[IsMagmaIdeal],0,COM_FUN(5));
InstallMethod(PrintObj,"for a magma ideal with known generators",true,[IsMagmaIdeal and HasGeneratorsOfMagmaIdeal],0,COM_FUN(6));
InstallMethod(ViewObj,"for a LeftMagmaIdeal",true,[IsLeftMagmaIdeal],0,COM_FUN(7));
InstallMethod(ViewObj,"for a LeftMagmaIdeal with generators",true,[IsLeftMagmaIdeal and HasGeneratorsOfLeftMagmaIdeal],0,COM_FUN(8));
InstallMethod(ViewObj,"for a RightMagmaIdeal",true,[IsRightMagmaIdeal],0,COM_FUN(9));
InstallMethod(ViewObj,"for a RightMagmaIdeal with generators",true,[IsRightMagmaIdeal and HasGeneratorsOfRightMagmaIdeal],0,COM_FUN(10));
InstallMethod(ViewObj,"for a MagmaIdeal",true,[IsMagmaIdeal],0,COM_FUN(11));
InstallMethod(ViewObj,"for a MagmaIdeal with generators",true,[IsMagmaIdeal and HasGeneratorsOfMagmaIdeal],0,COM_FUN(12));
InstallMethod(LeftMagmaIdealByGenerators,"for a collection of magma elements",IsIdenticalObj,[IsMagma,IsCollection],0,COM_FUN(13));
InstallMethod(RightMagmaIdealByGenerators,"for a collection of magma elements",IsIdenticalObj,[IsMagma,IsCollection],0,COM_FUN(14));
InstallMethod(MagmaIdealByGenerators,"for a collection of magma elements",IsIdenticalObj,[IsMagma,IsCollection],0,COM_FUN(15));
InstallMethod(AsLeftMagmaIdeal,"generic method for a domain and a collection",IsIdenticalObj,[IsDomain,IsCollection],0,COM_FUN(16));
BindGlobal("EnumeratorOfMagmaIdeal",COM_FUN(17));
InstallMethod(Enumerator,"generic method for a magma ideal",true,[IsMagma and IsAttributeStoringRep and IsMagmaIdeal],0,EnumeratorOfMagmaIdeal);
InstallMethod(AsSSortedList,"for a right magma ideal",true,[IsRightMagmaIdeal and HasGeneratorsOfRightMagmaIdeal],0,COM_FUN(18));
InstallMethod(AsSSortedList,"for a left magma ideal",true,[IsLeftMagmaIdeal and HasGeneratorsOfLeftMagmaIdeal],0,COM_FUN(19));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/mgmideal.gi"

#F  file="lib/mgmhom.gi" crc=31481831
RANK_FILTER_LIST  := [  ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/mgmhom.gi", 31481831 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/mgmhom.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/mgmhom.gi");
elif COM_RESULT = 3  then
Revision.mgmhom_gi:="@(#)$Id: mgmhom.gi,v 4.3 2002/04/15 10:05:03 sal Exp $";
InstallGlobalFunction(MagmaHomomorphismByFunctionNC,COM_FUN(1));
InstallGlobalFunction(MagmaIsomorphismByFunctionsNC,COM_FUN(2));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/mgmhom.gi"

#F  file="lib/mgmadj.gi" crc=-15449892
RANK_FILTER_LIST  := [ 55480986, 14, 32505602, 3, 15635848, 11, 32505602, 3, 
  60045706, 14, 32505602, 3, 59505594, 7, 9174291, 6, 15635848, 11, 15635848, 
  11, 55480986, 14, 9174291, 6, 9174291, 6, 9174291, 6, 9174291, 6, 9174291, 
  6, 9174291, 6, 9174291, 6 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/mgmadj.gi", -15449892 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/mgmadj.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/mgmadj.gi");
elif COM_RESULT = 3  then
Revision.mgmadj_gi:="@(#)$Id: mgmadj.gi,v 4.8 2002/04/15 10:05:03 sal Exp $";
InstallMethod(IsMultiplicativeZero,"generic method for an element and a magma with multiplicative zero",IsCollsElms,[IsMagma and HasMultiplicativeZero,IsMultiplicativeElement],0,COM_FUN(1));
InstallMethod(IsMultiplicativeZero,"generic method for an element and a magma",IsCollsElms,[IsMagma,IsMultiplicativeElement],0,COM_FUN(2));
InstallMethod(IsMultiplicativeZero,"generic method for an element of a semigroup, given generators",IsCollsElms,[IsSemigroup and HasGeneratorsOfSemigroup,IsMultiplicativeElement],0,COM_FUN(3));
DeclareRepresentation("IsMagmaWithMultiplicativeZeroAdjoinedElementRep",IsComponentObjectRep and IsMultiplicativeElementWithZero,["IsTheZero","UnderlyingElement"]);
InstallMethod(OneOp,"for an element of a magma with zero adjoined",true,[IsMultiplicativeElementWithOne and IsMagmaWithMultiplicativeZeroAdjoinedElementRep],0,COM_FUN(4));
InstallMethod(MultiplicativeZeroOp,"for an element of a magma with zero adjoined",true,[IsMagmaWithMultiplicativeZeroAdjoinedElementRep],0,COM_FUN(5));
InstallOtherMethod(MultiplicativeZero,"for a magma",true,[IsMagma],0,COM_FUN(6));
InstallMethod(InjectionZeroMagma,"method for a magma",true,[IsMagma],0,COM_FUN(7));
InstallMethod(Size,"method for a magma with a zero adjoined",true,[IsMagma and HasMultiplicativeZero],0,COM_FUN(8));
InstallMethod(\*,"for two elements of a magma with zero adjoined",IsIdenticalObj,[IsMagmaWithMultiplicativeZeroAdjoinedElementRep,IsMagmaWithMultiplicativeZeroAdjoinedElementRep],0,COM_FUN(9));
InstallMethod(\=,"for two elements of a magma with zero adjoined",IsIdenticalObj,[IsMagmaWithMultiplicativeZeroAdjoinedElementRep,IsMagmaWithMultiplicativeZeroAdjoinedElementRep],0,COM_FUN(10));
InstallMethod(\<,"for elements of magmas with 0 adjoined",IsIdenticalObj,[IsMagmaWithMultiplicativeZeroAdjoinedElementRep,IsMagmaWithMultiplicativeZeroAdjoinedElementRep],0,COM_FUN(11));
InstallMethod(PrintObj,"for elements of magmas with 0 adjoined",true,[IsMagmaWithMultiplicativeZeroAdjoinedElementRep],0,COM_FUN(12));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/mgmadj.gi"

#F  file="lib/mgmcong.gi" crc=-97637533
RANK_FILTER_LIST  := [ 25165675, 22, 40142184, 27, 67108595, 22, 14977185, 
  27, 67108700, 26, 14977290, 27, 25165675, 22, 40142184, 27, 67108595, 22, 
  14977185, 27, 67108700, 26, 14977290, 27, 15635848, 11, 8193, 2, 15635848, 
  11, 41951068, 17, 15635848, 11, 8193, 2, 15635848, 11, 41951068, 17, 
  15635848, 11, 8193, 2, 15635848, 11, 41951068, 17, 67108700, 26, 14977110, 
  10, 14977110, 10, 65308413, 11, 25165675, 22, 67108595, 22, 67108700, 26, 
  67108700, 26, 67108700, 26, 67108700, 26, 67108700, 26, 1, 0, 14977110, 10, 
  14977110, 10, 67108700, 26, 1, 0, 25165675, 22, 1, 0, 67108595, 22, 1, 0, 
  67108700, 26, 1, 0, 25165675, 22, 1, 0, 67108595, 22, 1, 0, 67108700, 26, 
  1, 0, 25165675, 22, 1, 0, 67108595, 22, 1, 0 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/mgmcong.gi", -97637533 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/mgmcong.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/mgmcong.gi");
elif COM_RESULT = 3  then
Revision.mgmcong_gi:="@(#)$Id: mgmcong.gi,v 4.19 2002/04/15 10:05:03 sal Exp $";
InstallMethod(PrintObj,"for a left magma congruence",true,[IsLeftMagmaCongruence],0,COM_FUN(1));
InstallMethod(PrintObj,"for a left magma congruence with known generating pairs",true,[IsLeftMagmaCongruence and HasGeneratingPairsOfMagmaCongruence],0,COM_FUN(2));
InstallMethod(PrintObj,"for a right magma congruence",true,[IsRightMagmaCongruence],0,COM_FUN(3));
InstallMethod(PrintObj,"for a right magma congruence with known generating pairs",true,[IsRightMagmaCongruence and HasGeneratingPairsOfMagmaCongruence],0,COM_FUN(4));
InstallMethod(PrintObj,"for a magma congruence",true,[IsMagmaCongruence],0,COM_FUN(5));
InstallMethod(PrintObj,"for a magma Congruence with known generating pairs",true,[IsMagmaCongruence and HasGeneratingPairsOfMagmaCongruence],0,COM_FUN(6));
InstallMethod(ViewObj,"for a LeftMagmaCongruence",true,[IsLeftMagmaCongruence],0,COM_FUN(7));
InstallMethod(ViewObj,"for a LeftMagmaCongruence with known generating pairs",true,[IsLeftMagmaCongruence and HasGeneratingPairsOfMagmaCongruence],0,COM_FUN(8));
InstallMethod(ViewObj,"for a RightMagmaCongruence",true,[IsRightMagmaCongruence],0,COM_FUN(9));
InstallMethod(ViewObj,"for a RightMagmaCongruence with generators",true,[IsRightMagmaCongruence and HasGeneratingPairsOfMagmaCongruence],0,COM_FUN(10));
InstallMethod(ViewObj,"for a magma congruence",true,[IsMagmaCongruence],0,COM_FUN(11));
InstallMethod(ViewObj,"for a magma congruence with generating pairs",true,[IsMagmaCongruence and HasGeneratingPairsOfMagmaCongruence],0,COM_FUN(12));
InstallGlobalFunction(LR2MagmaCongruenceByGeneratingPairsCAT,COM_FUN(13));
InstallGlobalFunction(LR2MagmaCongruenceByPartitionNCCAT,COM_FUN(14));
InstallMethod(LeftMagmaCongruenceByGeneratingPairs,"for a magma and a list of pairs of its elements",IsElmsColls,[IsMagma,IsList],0,COM_FUN(15));
InstallMethod(LeftMagmaCongruenceByGeneratingPairs,"for a magma and an empty list",true,[IsMagma,IsList and IsEmpty],0,COM_FUN(16));
InstallMethod(RightMagmaCongruenceByGeneratingPairs,"for a magma and a list of pairs of its elements",IsElmsColls,[IsMagma,IsList],0,COM_FUN(17));
InstallMethod(RightMagmaCongruenceByGeneratingPairs,"for a magma and an empty list",true,[IsMagma,IsList and IsEmpty],0,COM_FUN(18));
InstallMethod(MagmaCongruenceByGeneratingPairs,"for a magma and a list of pairs of its elements",IsElmsColls,[IsMagma,IsList],0,COM_FUN(19));
InstallMethod(MagmaCongruenceByGeneratingPairs,"for a magma and an empty list",true,[IsMagma,IsList and IsEmpty],0,COM_FUN(20));
InstallMethod(EquivalenceClasses,"for magma congruences",true,[IsMagmaCongruence],0,COM_FUN(21));
InstallMethod(\*,"for two magma congruence classes",IsIdenticalObj,[IsCongruenceClass,IsCongruenceClass],0,COM_FUN(22));
InstallOtherMethod(One,"One(<congruence class>)",true,[IsCongruenceClass and IsMultiplicativeElementWithOne],0,COM_FUN(23));
BindGlobal("MagmaCongruencePartition",COM_FUN(24));
InstallMethod(EquivalenceRelationPartition,"for a left congruence on a magma",true,[IsLeftMagmaCongruence],0,COM_FUN(25));
InstallMethod(EquivalenceRelationPartition,"for a right congruence on a magma",true,[IsRightMagmaCongruence],0,COM_FUN(26));
InstallMethod(EquivalenceRelationPartition,"for a congruence on a magma",true,[IsMagmaCongruence],0,COM_FUN(27));
InstallMethod(JoinMagmaCongruences,"for magma congruences",true,[IsMagmaCongruence,IsMagmaCongruence],0,COM_FUN(28));
InstallMethod(MeetMagmaCongruences,"for magma congruences",true,[IsMagmaCongruence,IsMagmaCongruence],0,COM_FUN(29));
InstallMethod(\in,"for a magma congruence class",true,[IsObject,IsCongruenceClass],0,COM_FUN(30));
InstallMethod(Enumerator,"for a magma congruence class",true,[IsCongruenceClass],0,COM_FUN(31));
InstallMethod(EquivalenceClassOfElementNC,"for magma congruence with no check",true,[IsMagmaCongruence,IsObject],0,COM_FUN(32));
InstallMethod(EquivalenceClassOfElementNC,"for magma congruence with no check",true,[IsLeftMagmaCongruence,IsObject],0,COM_FUN(33));
InstallMethod(EquivalenceClassOfElementNC,"for magma congruence with no check",true,[IsRightMagmaCongruence,IsObject],0,COM_FUN(34));
InstallMethod(EquivalenceClassOfElement,"for magma congruence with checking",t\
rue,[IsMagmaCongruence,IsObject],0,COM_FUN(35));
InstallMethod(EquivalenceClassOfElement,"for left magma congruence with checki\
ng",true,[IsLeftMagmaCongruence,IsObject],0,COM_FUN(36));
InstallMethod(EquivalenceClassOfElement,"for right magma congruence with check\
ing",true,[IsRightMagmaCongruence,IsObject],0,COM_FUN(37));
InstallMethod(ImagesElm,"for magma congruence and element",FamSourceEqFamElm,[IsMagmaCongruence,IsObject],0,COM_FUN(38));
InstallMethod(ImagesElm,"for magma congruence and element",FamSourceEqFamElm,[IsLeftMagmaCongruence,IsObject],0,COM_FUN(39));
InstallMethod(ImagesElm,"for magma congruence and element",FamSourceEqFamElm,[IsRightMagmaCongruence,IsObject],0,COM_FUN(40));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/mgmcong.gi"

#F  file="lib/semigrp.gi" crc=-116779329
RANK_FILTER_LIST  := [ 11819866, 15, 11819866, 15, 11831026, 13, 60045706, 
  14, 11831026, 13, 60045706, 14, 11831026, 13, 8126465, 2, 11831026, 13, 
  8126465, 2, 23214719, 5, 8126465, 2, 60045706, 14, 60045706, 14, 58647841, 
  14, 11831026, 13, 29419057, 21, 45384768, 22, 60045706, 14, 58647841, 14, 
  11831026, 13, 11819866, 15, 11831026, 13, 11831026, 13, 11831026, 13, 8193, 
  2, 11831026, 13, 41951068, 17, 11831026, 13, 54779227, 32, 11831026, 13, 
  8193, 2, 11831026, 13, 41951068, 17, 11831026, 13, 41942876, 3, 11831026, 
  13, 8193, 2, 11831026, 13, 54779227, 32, 11831026, 13, 62947299, 4, 
  11831026, 13 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/semigrp.gi", -116779329 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/semigrp.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/semigrp.gi");
elif COM_RESULT = 3  then
Revision.semigrp_gi:="@(#)$Id: semigrp.gi,v 4.45.2.2 2006/02/27 12:08:28 sal Exp $";
InstallMethod(CayleyGraphSemigroup,"for generic finite semigroups",[IsSemigroup and IsFinite],COM_FUN(1));
InstallMethod(CayleyGraphDualSemigroup,"for generic finite semigroups",[IsSemigroup and IsFinite],COM_FUN(2));
InstallMethod(PrintObj,"for a semigroup",[IsSemigroup],COM_FUN(3));
InstallMethod(PrintObj,"for a semigroup with known generators",[IsSemigroup and HasGeneratorsOfMagma],COM_FUN(4));
InstallMethod(ViewObj,"for a semigroup",[IsSemigroup],COM_FUN(5));
InstallMethod(ViewObj,"for a semigroup with generators",[IsSemigroup and HasGeneratorsOfMagma],COM_FUN(6));
InstallMethod(DisplaySemigroup,"for finite semigroups",[IsSemigroup],COM_FUN(7));
InstallMethod(SemigroupByGenerators,"for a collection",[IsCollection],COM_FUN(8));
InstallMethod(AsSemigroup,"for a semigroup",[IsSemigroup],100,IdFunc);
InstallMethod(AsSemigroup,"generic method for collections",[IsCollection],COM_FUN(9));
InstallGlobalFunction(Semigroup,COM_FUN(10));
InstallMethod(AsSubsemigroup,"generic method for a domain and a collection",IsIdenticalObj,[IsDomain,IsCollection],COM_FUN(11));
InstallMethod(Enumerator,"for a generic semigroup",[IsSemigroup and HasGeneratorsOfSemigroup],COM_FUN(12));
InstallTrueMethod(IsSimpleSemigroup,IsGroup);
InstallTrueMethod(IsSimpleSemigroup,IsSemigroup and IsTrivial);
InstallMethod(IsSimpleSemigroup,"for semigroup with generators",[IsSemigroup and HasGeneratorsOfSemigroup],COM_FUN(13));
InstallMethod(IsSimpleSemigroup,"for a semigroup with a MultiplicativeNeutralElement",[IsSemigroup and HasMultiplicativeNeutralElement],COM_FUN(14));
InstallMethod(IsSimpleSemigroup,"for a semigroup",[IsSemigroup],COM_FUN(15));
InstallTrueMethod(IsZeroSimpleSemigroup,IsZeroGroup);
InstallMethod(IsZeroSimpleSemigroup,"for a ZeroGroup",[IsGroup],ReturnFalse);
InstallMethod(IsZeroSimpleSemigroup,"for a trivial semigroup",[IsSemigroup and IsTrivial],ReturnFalse);
InstallMethod(IsZeroSimpleSemigroup,"for a semigroup with generators",[IsSemigroup and HasGeneratorsOfSemigroup],COM_FUN(16));
InstallMethod(IsZeroSimpleSemigroup,"for a semigroup with a MultiplicativeNeutralElement",[IsSemigroup and HasMultiplicativeNeutralElement],COM_FUN(17));
InstallMethod(IsZeroSimpleSemigroup,"for a semigroup",[IsSemigroup],COM_FUN(18));
InstallMethod(ANonReesCongruenceOfSemigroup,"for a semigroup",[IsSemigroup and IsFinite],COM_FUN(19));
RedispatchOnCondition(ANonReesCongruenceOfSemigroup,true,[IsSemigroup],[IsFinite],0);
InstallMethod(IsReesCongruenceSemigroup,"for a (possibly infinite) semigroup",[IsSemigroup],COM_FUN(20));
InstallMethod(HomomorphismFactorSemigroupByClosure,"for a semigroup and generating pairs of a congruence",IsElmsColls,[IsSemigroup,IsList],COM_FUN(21));
InstallMethod(HomomorphismFactorSemigroupByClosure,"for a semigroup and empty list",[IsSemigroup,IsList and IsEmpty],COM_FUN(22));
InstallMethod(FactorSemigroup,"for a semigroup and a congruence",[IsSemigroup,IsSemigroupCongruence],COM_FUN(23));
InstallMethod(FactorSemigroupByClosure,"for a semigroup and generating pairs of a congruence",IsElmsColls,[IsSemigroup,IsList],COM_FUN(24));
InstallMethod(FactorSemigroupByClosure,"for a semigroup and empty list",[IsSemigroup,IsEmpty and IsList],COM_FUN(25));
InstallOtherMethod(\/,"for a semigroup and an empty list",[IsSemigroup,IsEmpty],FactorSemigroupByClosure);
InstallOtherMethod(\/,"for semigroup and list of pairs",IsElmsColls,[IsSemigroup,IsList],FactorSemigroupByClosure);
InstallOtherMethod(\/,"for a semigroup and a congruence",[IsSemigroup,IsSemigroupCongruence],FactorSemigroup);
InstallMethod(IsRegularSemigroupElement,"for generic semigroup",IsCollsElms,[IsSemigroup,IsAssociativeElement],COM_FUN(26));
InstallMethod(IsRegularSemigroup,"for generic semigroup",[IsSemigroup],COM_FUN(27));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/semigrp.gi"

#F  file="lib/semicong.gi" crc=129261989
RANK_FILTER_LIST  := [ 11831026, 13, 8193, 2, 11831026, 13, 41951068, 17, 
  11831026, 13, 8193, 2, 11831026, 13, 41951068, 17, 11831026, 13, 8193, 2, 
  11831026, 13, 41951068, 17, 25165675, 22, 67108595, 22, 67108700, 26, 
  54779227, 32, 30532122, 24, 45509591, 29, 32844214, 24, 47821683, 29, 
  54779227, 32, 54778867, 33, 30532122, 24, 45509591, 29, 32844214, 24, 
  47821683, 29, 54779227, 32, 54778867, 33 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/semicong.gi", 129261989 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/semicong.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/semicong.gi");
elif COM_RESULT = 3  then
Revision.semicong_gi:="@(#)$Id: semicong.gi,v 4.16 2002/04/15 10:05:21 sal Exp $";
InstallMethod(LeftSemigroupCongruenceByGeneratingPairs,"for a Semigroup  and a list of pairs of its elements",IsElmsColls,[IsSemigroup,IsList],0,COM_FUN(1));
InstallMethod(LeftSemigroupCongruenceByGeneratingPairs,"for a Semigroup and an empty list",true,[IsSemigroup,IsList and IsEmpty],0,COM_FUN(2));
InstallMethod(RightSemigroupCongruenceByGeneratingPairs,"for a Semigroup and a list of pairs of its elements",IsElmsColls,[IsSemigroup,IsList],0,COM_FUN(3));
InstallMethod(RightSemigroupCongruenceByGeneratingPairs,"for a Semigroup and an empty list",true,[IsSemigroup,IsList and IsEmpty],0,COM_FUN(4));
InstallMethod(SemigroupCongruenceByGeneratingPairs,"for a semigroup and a list of pairs of its elements",IsElmsColls,[IsSemigroup,IsList],0,COM_FUN(5));
InstallMethod(SemigroupCongruenceByGeneratingPairs,"for a semigroup and an empty list",true,[IsSemigroup,IsList and IsEmpty],0,COM_FUN(6));
InstallMethod(IsLeftSemigroupCongruence,"test whether a left magma congruence is a semigroup a congruence",true,[IsLeftMagmaCongruence],0,COM_FUN(7));
InstallMethod(IsRightSemigroupCongruence,"test whether a right magma congruence is a semigroup a congruence",true,[IsRightMagmaCongruence],0,COM_FUN(8));
InstallMethod(IsSemigroupCongruence,"test whether a magma congruence is a semigroup a congruence",true,[IsMagmaCongruence],0,COM_FUN(9));
InstallMethod(IsReesCongruence,"for a semigroup congruence",true,[IsSemigroupCongruence],0,COM_FUN(10));
InstallMethod(PrintObj,"for a left semigroup congruence",true,[IsLeftSemigroupCongruence],0,COM_FUN(11));
InstallMethod(PrintObj,"for a left semigroup congruence with known generating pairs",true,[IsLeftSemigroupCongruence and HasGeneratingPairsOfMagmaCongruence],0,COM_FUN(12));
InstallMethod(PrintObj,"for a right semigroup congruence",true,[IsRightSemigroupCongruence],0,COM_FUN(13));
InstallMethod(PrintObj,"for a right semigroup congruence with known generating pairs",true,[IsRightSemigroupCongruence and HasGeneratingPairsOfMagmaCongruence],0,COM_FUN(14));
InstallMethod(PrintObj,"for a semigroup congruence",true,[IsSemigroupCongruence],0,COM_FUN(15));
InstallMethod(PrintObj,"for a semigroup Congruence with known generating pairs",true,[IsSemigroupCongruence and HasGeneratingPairsOfMagmaCongruence],0,COM_FUN(16));
InstallMethod(ViewObj,"for a LeftSemigroupCongruence",true,[IsLeftSemigroupCongruence],0,COM_FUN(17));
InstallMethod(ViewObj,"for a LeftSemigroupCongruence with known generating pairs",true,[IsLeftSemigroupCongruence and HasGeneratingPairsOfMagmaCongruence],0,COM_FUN(18));
InstallMethod(ViewObj,"for a RightSemigrouCongruence",true,[IsRightSemigroupCongruence],0,COM_FUN(19));
InstallMethod(ViewObj,"for a RightSemigroupCongruence with generators",true,[IsRightSemigroupCongruence and HasGeneratingPairsOfMagmaCongruence],0,COM_FUN(20));
InstallMethod(ViewObj,"for a semigroup congruence",true,[IsSemigroupCongruence],0,COM_FUN(21));
InstallMethod(ViewObj,"for a semigroup Congruence with known generating pairs",true,[IsSemigroupCongruence and HasGeneratingPairsOfMagmaCongruence],0,COM_FUN(22));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/semicong.gi"

#F  file="lib/smgideal.gi" crc=-4430550
RANK_FILTER_LIST  := [ 51886386, 16, 264115, 16, 20949025, 19, 35793060, 16, 
  27261537, 16, 55311245, 18, 12559875, 17, 12559875, 17, 34317017, 18, 
  12559875, 17, 34317017, 18 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/smgideal.gi", -4430550 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/smgideal.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/smgideal.gi");
elif COM_RESULT = 3  then
Revision.smgideal_gi:="@(#)$Id: smgideal.gi,v 4.14.2.1 2005/05/19 07:11:00 gap Exp $";
InstallImmediateMethod(IsLeftSemigroupIdeal,IsLeftMagmaIdeal and HasLeftActingDomain and IsAttributeStoringRep,0,COM_FUN(1));
InstallImmediateMethod(IsRightSemigroupIdeal,IsRightMagmaIdeal and HasRightActingDomain and IsAttributeStoringRep,0,COM_FUN(2));
InstallImmediateMethod(IsSemigroupIdeal,IsMagmaIdeal and HasActingDomain and IsAttributeStoringRep,0,COM_FUN(3));
BindGlobal("RightSemigroupIdealEnumeratorDataGetElement",COM_FUN(4));
BindGlobal("LeftSemigroupIdealEnumeratorDataGetElement",COM_FUN(5));
BindGlobal("SemigroupIdealEnumeratorDataGetElement",COM_FUN(6));
BindGlobal("ElementNumber_SemigroupIdealEnumerator",COM_FUN(7));
BindGlobal("NumberElement_SemigroupIdealEnumerator",COM_FUN(8));
InstallGlobalFunction(IsBound_RightSemigroupIdealEnumerator,COM_FUN(9));
InstallGlobalFunction(IsBound_LeftSemigroupIdealEnumerator,COM_FUN(10));
BindGlobal("IsBound_SemigroupIdealEnumerator",COM_FUN(11));
BindGlobal("Length_SemigroupIdealEnumerator",COM_FUN(12));
BindGlobal("Membership_SemigroupIdealEnumerator",COM_FUN(13));
InstallGlobalFunction(EnumeratorOfSemigroupIdeal,COM_FUN(14));
InstallMethod(Enumerator,"for a right semigroup ideal",[IsRightSemigroupIdeal and HasGeneratorsOfRightMagmaIdeal],COM_FUN(15));
InstallMethod(Enumerator,"for a left semigroup ideal",[IsLeftSemigroupIdeal and HasGeneratorsOfLeftMagmaIdeal],COM_FUN(16));
InstallMethod(Enumerator,"for a semigroup ideal",[IsSemigroupIdeal and HasGeneratorsOfMagmaIdeal],COM_FUN(17));
InstallMethod(ReesCongruenceOfSemigroupIdeal,"for a two sided semigroup congruence",[IsMagmaIdeal and IsSemigroupIdeal],COM_FUN(18));
InstallMethod(PrintObj,"for a semigroup ideal",[IsMagmaIdeal and IsSemigroupIdeal],COM_FUN(19));
InstallMethod(PrintObj,"for a semigroup ideal with known generators",[IsMagmaIdeal and IsSemigroupIdeal and HasGeneratorsOfMagmaIdeal],COM_FUN(20));
InstallMethod(ViewObj,"for a semigroup ideal",[IsMagmaIdeal and IsSemigroupIdeal],COM_FUN(21));
InstallMethod(ViewObj,"for a semigroup ideal with known generators",[IsMagmaIdeal and IsSemigroupIdeal and HasGeneratorsOfMagmaIdeal],COM_FUN(22));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/smgideal.gi"

#F  file="lib/monoid.gi" crc=-46178486
RANK_FILTER_LIST  := [ 43104550, 16, 5316152, 17, 43104550, 16, 5316152, 17, 
  8126465, 2, 8126465, 2, 50331304, 4, 41942876, 3, 50331304, 4, 5317144, 19, 
  43104550, 16, 8126465, 2, 23214719, 5, 8126465, 2, 43104550, 16 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/monoid.gi", -46178486 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/monoid.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/monoid.gi");
elif COM_RESULT = 3  then
Revision.monoid_gi:="@(#)$Id: monoid.gi,v 4.29 2002/04/15 10:05:04 sal Exp $";
InstallMethod(PrintObj,"for monoid",true,[IsMonoid],0,COM_FUN(1));
InstallMethod(PrintObj,"for monoid with known generators",true,[IsMonoid and HasGeneratorsOfMonoid],0,COM_FUN(2));
InstallMethod(ViewObj,"for a monoid",true,[IsMonoid],0,COM_FUN(3));
InstallMethod(ViewObj,"for a monoid with generators",true,[IsMonoid and HasGeneratorsOfMagmaWithOne],0,COM_FUN(4));
InstallOtherMethod(MonoidByGenerators,"for a collection",true,[IsCollection],0,COM_FUN(5));
InstallOtherMethod(MonoidByGenerators,"for collection and identity",IsCollsElms,[IsCollection,IsMultiplicativeElementWithOne],0,COM_FUN(6));
InstallOtherMethod(MonoidByGenerators,"for empty collection and identity",true,[IsEmpty,IsMultiplicativeElementWithOne],0,COM_FUN(7));
InstallImmediateMethod(GeneratorsOfSemigroup,IsMonoid and HasGeneratorsOfMonoid and IsAttributeStoringRep,0,COM_FUN(8));
InstallMethod(AsMonoid,"for a monoid",true,[IsMonoid],100,IdFunc);
InstallMethod(AsMonoid,"generic method for a collection",true,[IsCollection],0,COM_FUN(9));
InstallMethod(AsSubmonoid,"generic method for a domain and a collection",IsIdenticalObj,[IsDomain,IsCollection],0,COM_FUN(10));
InstallMethod(IsCommutative,"for associative magma-with-one",true,[IsMagmaWithOne and IsAssociative],0,IsCommutativeFromGenerators(GeneratorsOfMagmaWithOne));
InstallGlobalFunction(Monoid,COM_FUN(11));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/monoid.gi"

#F  file="lib/grp.gi" crc=-10316628
RANK_FILTER_LIST  := [ 20951140, 22, 20951140, 22, 29419057, 21, 29419057, 
  21, 29419057, 21, 29419057, 21, 14705310, 27, 60357228, 29, 29419057, 21, 
  26406676, 25, 29407897, 26, 29419057, 21, 29419057, 21, 29419057, 21, 
  29420979, 23, 29419057, 21, 29419057, 21, 29419057, 21, 29419057, 21, 
  29419057, 21, 29419057, 21, 8126465, 2, 29419057, 21, 29419057, 21, 
  29419057, 21, 29407897, 26, 29419057, 21, 29407897, 26, 29419057, 21, 
  29419057, 21, 29419057, 21, 67105912, 7, 29407897, 26, 29419057, 21, 8193, 
  2, 29419057, 21, 5731852, 30, 14705310, 27, 29407897, 26, 29419057, 21, 
  29419057, 21, 29419057, 21, 29419057, 21, 29419057, 21, 18541677, 24, 
  29419057, 21, 14199769, 29, 29419057, 21, 7665940, 19, 7665940, 19, 
  29419057, 21, 29407897, 26, 29419057, 21, 26404754, 23, 29419057, 21, 
  29419057, 21, 29407897, 26, 29407897, 26, 29407897, 26, 29407897, 26, 
  29419057, 21, 29419057, 21, 7665940, 19, 7665940, 19, 29419057, 21, 
  29419057, 21, 29419057, 21, 29419057, 21, 65767820, 5, 23685791, 22, 
  65767820, 5, 29405138, 23, 65767820, 5, 29419057, 21, 29419057, 21, 
  29405138, 23, 29419057, 21, 29419057, 21, 8126465, 2, 29419057, 21, 
  41951068, 17, 29419057, 21, 29419057, 21, 29419057, 21, 65767820, 5, 
  29419057, 21, 65767820, 5, 22663194, 22, 65767820, 5, 29419057, 21, 
  65767820, 5, 29419057, 21, 29419057, 21, 29419057, 21, 29419057, 21, 
  29419057, 21, 29419057, 21, 29419057, 21, 29419057, 21, 29419057, 21, 
  29419057, 21, 29419057, 21, 65767820, 5, 65767820, 5, 29419057, 21, 
  29419057, 21, 29419057, 21, 29419057, 21, 29419057, 21, 29419057, 21, 
  29419057, 21, 29419057, 21, 7665940, 19, 18357733, 9, 18357733, 9, 
  18357733, 9, 29419057, 21, 29419057, 21, 29419057, 21, 29419057, 21, 
  29419057, 21, 29419057, 21, 29419057, 21, 65767820, 5, 29419057, 21, 
  29419057, 21, 29419057, 21, 7665940, 19, 29419057, 21, 60357228, 29, 
  60357228, 29, 29419057, 21, 7665940, 19, 29419057, 21, 7665940, 19, 
  29419057, 21, 29419057, 21, 29419057, 21, 29419057, 21, 29419057, 21, 
  7665940, 19, 14705310, 27, 7665940, 19, 29419057, 21, 29419057, 21, 
  29419057, 21, 29419057, 21, 29419057, 21, 29419057, 21, 29419057, 21, 
  29419057, 21, 29420049, 23, 29419057, 21, 29419057, 21, 1, 0, 29419057, 21, 
  29419057, 21, 29419057, 21, 20951140, 22, 29419057, 21, 20951140, 22, 
  20953062, 24, 29419057, 21, 67108760, 5, 8126465, 2, 8126465, 2, 65767820, 
  5, 41951068, 17, 65767820, 5, 8126465, 2, 8126465, 2, 65767820, 5, 
  41951068, 17, 65767820, 5, 29419057, 21, 8193, 2, 4063233, 1, 36853873, 22, 
  36853873, 22, 1, 0, 36853873, 22, 36853873, 22, 32505602, 3, 32505602, 3, 
  7665940, 19, 20951140, 22, 7665940, 19, 29419057, 21, 29419057, 21, 
  12209393, 27, 29407897, 26, 29407342, 227, 20951140, 22, 29419057, 21, 
  29419057, 21, 29419057, 21, 17, 18, 32769, 4, 62973024, 30, 17, 18, 32769, 
  4, 11895617, 31, 17, 18, 32769, 4, 29419057, 21, 8193, 2, 29419057, 21, 
  41942876, 3, 29419057, 21, 20951140, 22, 29419057, 21, 29419057, 21, 
  29419057, 21, 29419057, 21, 60909105, 22, 60909105, 22, 17481453, 6, 
  20951140, 22, 29419057, 21 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grp.gi", -10316628 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grp.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grp.gi");
elif COM_RESULT = 3  then
Revision.grp_gi:="@(#)$Id: grp.gi,v 4.204.2.13 2007/08/27 21:28:40 gap Exp $";
InstallImmediateMethod(IsFinitelyGeneratedGroup,IsGroup and HasGeneratorsOfGroup,0,COM_FUN(1));
InstallImmediateMethod(IsCyclic,IsGroup and HasGeneratorsOfGroup,0,COM_FUN(2));
InstallMethod(IsCyclic,"generic method for groups",[IsGroup],COM_FUN(3));
InstallOtherMethod(MinimalGeneratingSet,"cyclic groups",true,[IsGroup],0,COM_FUN(4));
InstallMethod(IsElementaryAbelian,"generic method for groups",[IsGroup],COM_FUN(5));
InstallMethod(IsPGroup,"generic method (check order of the group or of generators)",[IsGroup],COM_FUN(6));
InstallMethod(IsPGroup,"for nilpotent groups",[IsGroup and IsNilpotentGroup],COM_FUN(7));
InstallMethod(PrimePGroup,"generic method, check the group order",[IsPGroup],COM_FUN(8));
InstallMethod(IsNilpotentGroup,"generic method for groups",[IsGroup],COM_FUN(9));
InstallImmediateMethod(IsPerfectGroup,IsGroup and IsSolvableGroup and HasSize,0,COM_FUN(10));
InstallMethod(IsPerfectGroup,"method for finite groups",[IsGroup and IsFinite],COM_FUN(11));
InstallMethod(IsPerfectGroup,"generic method for groups",[IsGroup],COM_FUN(12));
InstallMethod(IsSporadicSimpleGroup,"for a group",[IsGroup],COM_FUN(13));
InstallMethod(IsSimpleGroup,"generic method for groups",[IsGroup],COM_FUN(14));
InstallImmediateMethod(IsSolvableGroup,IsGroup and HasSize,10,COM_FUN(15));
InstallMethod(IsSolvableGroup,"generic method for groups",[IsGroup],COM_FUN(16));
InstallMethod(IsSupersolvableGroup,"generic method for groups",[IsGroup],COM_FUN(17));
InstallMethod(IsPolycyclicGroup,"generic method for groups",true,[IsGroup],0,COM_FUN(18));
InstallMethod(IsTrivial,[IsGroup],COM_FUN(19));
InstallMethod(AbelianInvariants,"generic method for groups",[IsGroup],COM_FUN(20));
InstallMethod(AsGroup,[IsGroup],100,IdFunc);
InstallMethod(AsGroup,"generic method for collections",[IsCollection],COM_FUN(21));
InstallMethod(ChiefSeries,"method for a group (delegate to `ChiefSeriesUnderAction'",[IsGroup],COM_FUN(22));
InstallMethod(CommutatorFactorGroup,"generic method for groups",[IsGroup],COM_FUN(23));
InstallMethod(MaximalAbelianQuotient,"not fp group",true,[IsGroup],0,COM_FUN(24));
InstallMethod(CompositionSeries,"using DerivedSubgroup",[IsGroup and IsFinite],COM_FUN(25));
InstallMethod(DerivedLength,"generic method for groups",[IsGroup],COM_FUN(26));
InstallMethod(HirschLength,"generic method for finite groups",[IsGroup and IsFinite],COM_FUN(27));
InstallMethod(DerivedSeriesOfGroup,"generic method for groups",[IsGroup],COM_FUN(28));
InstallMethod(DerivedSubgroup,"generic method for groups",[IsGroup],COM_FUN(29));
InstallMethod(DimensionsLoewyFactors,"for a group (that must be a finite p-group)",[IsGroup],COM_FUN(30));
InstallOtherMethod(ElementaryAbelianSeries,"method for lists",[IsList and IsFinite],COM_FUN(31));
InstallMethod(ElementaryAbelianSeries,"generic method for groups",[IsGroup and IsFinite],COM_FUN(32));
DoEASLS:=COM_FUN(33);
InstallMethod(ElementaryAbelianSeriesLargeSteps,"remove spurious factors",[IsGroup],DoEASLS);
InstallOtherMethod(ElementaryAbelianSeriesLargeSteps,"remove spurious factors",[IsList],DoEASLS);
InstallMethod(Exponent,"generic method for groups",[IsGroup],COM_FUN(34));
InstallMethod(Exponent,"method for abelian groups with generators",[IsGroup and IsAbelian and HasGeneratorsOfGroup],COM_FUN(35));
InstallMethod(FittingSubgroup,"for nilpotent group",[IsGroup and IsNilpotentGroup],0,IdFunc);
InstallMethod(FittingSubgroup,"generic method for groups",[IsGroup and IsFinite],COM_FUN(36));
RedispatchOnCondition(FittingSubgroup,true,[IsGroup],[IsFinite],0);
InstallMethod(FrattiniSubgroup,"generic method for groups",[IsGroup],0,COM_FUN(37));
InstallMethod(JenningsSeries,"generic method for groups",[IsGroup],COM_FUN(38));
InstallMethod(LowerCentralSeriesOfGroup,"generic method for groups",[IsGroup],COM_FUN(39));
InstallMethod(NilpotencyClassOfGroup,"generic",[IsGroup],0,COM_FUN(40));
InstallImmediateMethod(NrConjugacyClasses,IsGroup and HasConjugacyClasses and IsAttributeStoringRep,0,COM_FUN(41));
InstallMethod(NrConjugacyClasses,"generic method for groups",[IsGroup],COM_FUN(42));
InstallGlobalFunction(Omega,COM_FUN(43));
InstallMethod(IndependentGeneratorsOfAbelianGroup,"finite abelian group",true,[IsGroup and IsAbelian],0,COM_FUN(44));
InstallMethod(OmegaOp,"method for a p-group (abelian)",[IsGroup,IsPosInt,IsPosInt],COM_FUN(45));
InstallMethod(ComputedOmegas,[IsGroup],0,COM_FUN(46));
InstallMethod(RadicalGroup,"factor out Fitting subgroup",[IsGroup and IsFinite],COM_FUN(47));
RedispatchOnCondition(RadicalGroup,true,[IsGroup],[IsFinite],0);
InstallMethod(RadicalGroup,"solvable group is its own radical",[IsGroup and IsSolvableGroup],100,IdFunc);
InstallMethod(GeneratorsSmallest,"generic method for groups",[IsGroup],COM_FUN(48));
InstallMethod(LargestElementGroup,"use `EnumeratorSorted'",true,[IsGroup],COM_FUN(49));
InstallGlobalFunction(SupersolvableResiduumDefault,COM_FUN(50));
InstallMethod(SupersolvableResiduum,"method for finite groups (call `SupersolvableResiduumDefault')",[IsGroup and IsFinite],COM_FUN(51));
InstallMethod(ComplementSystem,"generic method for finite groups",[IsGroup and IsFinite],COM_FUN(52));
InstallMethod(SylowSystem,"generic method for finite groups",[IsGroup and IsFinite],COM_FUN(53));
InstallMethod(HallSystem,"generic method for finite groups",[IsGroup and IsFinite],COM_FUN(54));
InstallMethod(UpperCentralSeriesOfGroup,"generic method for groups",[IsGroup],COM_FUN(55));
InstallGlobalFunction(Agemo,COM_FUN(56));
InstallMethod(AgemoOp,"generic method for groups",[IsGroup,IsPosInt,IsPosInt],COM_FUN(57));
InstallMethod(ComputedAgemos,[IsGroup],0,COM_FUN(58));
InstallGlobalFunction(AgemoAbove,COM_FUN(59));
InstallMethod(AsSubgroup,"generic method for groups",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(60));
InstallGlobalFunction(ClosureGroupDefault,COM_FUN(61));
InstallGlobalFunction(ClosureGroupAddElm,COM_FUN(62));
InstallGlobalFunction(ClosureGroupCompare,COM_FUN(63));
InstallGlobalFunction(ClosureGroupIntest,COM_FUN(64));
InstallMethod(ClosureGroup,"generic method for group and element",IsCollsElms,[IsGroup,IsMultiplicativeElementWithInverse],COM_FUN(65));
InstallMethod(ClosureGroup,"groups with cheap membership test",IsCollsElms,[IsGroup and CanEasilyTestMembership,IsMultiplicativeElementWithInverse],ClosureGroupIntest);
InstallMethod(ClosureGroup,"method for group that contains the whole family",IsCollsElms,[IsGroup and IsWholeFamily,IsMultiplicativeElementWithInverse],SUM_FLAGS,COM_FUN(66));
InstallMethod(ClosureGroup,"generic method for two groups",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(67));
InstallMethod(ClosureGroup,"for two groups, the bigger conatining the whole family",IsIdenticalObj,[IsGroup and IsWholeFamily,IsGroup],SUM_FLAGS,COM_FUN(68));
InstallMethod(ClosureGroup,"for group and element list",IsIdenticalObj,[IsGroup,IsCollection],COM_FUN(69));
InstallMethod(ClosureGroup,"for group and empty element list",[IsGroup,IsList and IsEmpty],COM_FUN(70));
InstallGlobalFunction(ClosureSubgroupNC,COM_FUN(71));
InstallGlobalFunction(ClosureSubgroup,COM_FUN(72));
InstallMethod(CommutatorSubgroup,"generic method for two groups",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(73));
InstallOtherMethod(\^,"generic method for groups and element",IsCollsElms,[IsGroup,IsMultiplicativeElementWithInverse],ConjugateGroup);
InstallMethod(ConjugateGroup,"<G>, <g>",IsCollsElms,[IsGroup,IsMultiplicativeElementWithInverse],COM_FUN(74));
InstallMethod(ConjugateSubgroup,"for group with parent, and group element",IsCollsElms,[IsGroup and HasParent,IsMultiplicativeElementWithInverse],COM_FUN(75));
InstallOtherMethod(ConjugateSubgroup,"for group without parent",IsCollsElms,[IsGroup,IsMultiplicativeElementWithInverse],ConjugateGroup);
InstallMethod(CoreOp,"generic method for two groups",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(76));
InstallGlobalFunction(FactorGroup,COM_FUN(77));
InstallMethod(FactorGroupNC,"generic method for two groups",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(78));
InstallOtherMethod(\/,"generic method for two groups",IsIdenticalObj,[IsGroup,IsGroup],FactorGroup);
InstallMethod(IndexOp,"generic method for two groups",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(79));
InstallMethod(IndexNC,"generic method for two groups",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(80));
InstallMethod(IsConjugate,"group elements",IsCollsElmsElms,[IsGroup,IsMultiplicativeElementWithInverse,IsMultiplicativeElementWithInverse],COM_FUN(81));
InstallMethod(IsConjugate,"subgroups",IsFamFamFam,[IsGroup,IsGroup,IsGroup],COM_FUN(82));
InstallMethod(IsNormalOp,"generic method for two groups",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(83));
InstallMethod(IsCharacteristicSubgroup,"generic method for two groups",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(84));
InstallMethod(IsPNilpotentOp,"generic method for a (finite) group and a prime integer",[IsGroup,IsPosInt],COM_FUN(85));
InstallGlobalFunction(IsSubgroup,COM_FUN(86));
DeclareRepresentation("IsRightTransversalRep",IsAttributeStoringRep and IsRightTransversal,["group","subgroup"]);
InstallMethod(PrintObj,"for right transversal",[IsList and IsRightTransversalRep],COM_FUN(87));
InstallMethod(ViewObj,"for right transversal",[IsList and IsRightTransversalRep],COM_FUN(88));
InstallMethod(Length,"for right transversal",[IsList and IsRightTransversalRep],COM_FUN(89));
InstallMethod(NormalClosureOp,"generic method for two groups",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(90));
InstallMethod(NormalIntersection,"generic method for two groups",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(91));
InstallMethod(NormalizerOp,"generic method for two groups",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(92));
InstallMethod(NormalizerOp,"generic method for group and Element",IsCollsElms,[IsGroup,IsMultiplicativeElementWithInverse],COM_FUN(93));
InstallMethod(NrConjugacyClassesInSupergroup,"generic method for two groups",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(94));
InstallMethod(PCentralSeriesOp,"generic method for group and prime",[IsGroup,IsPosInt],COM_FUN(95));
InstallOtherMethod(PCentralSeries,"pGroup",[IsGroup],COM_FUN(96));
InstallMethod(PClassPGroup,"generic method for group",[IsPGroup],COM_FUN(97));
InstallMethod(RankPGroup,"generic method for group",[IsPGroup],COM_FUN(98));
InstallMethod(PRumpOp,"generic method for group and prime",[IsGroup,IsPosInt],COM_FUN(99));
InstallMethod(PCoreOp,"generic method for group and prime",[IsGroup,IsPosInt],COM_FUN(100));
InstallMethod(SubnormalSeriesOp,"generic method for two groups",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(101));
InstallMethod(IsSubnormal,"generic method for two groups",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(102));
InstallMethod(SylowSubgroupOp,"generic method for group and prime",[IsGroup,IsPosInt],COM_FUN(103));
InstallMethod(SylowSubgroupOp,"method for a nilpotent group, and a prime",[IsGroup and IsNilpotentGroup,IsPosInt],COM_FUN(104));
InstallMethod(\=,"generic method for two groups",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(105));
InstallMethod(IsCentral,"generic method for two groups",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(106));
InstallMethod(IsSubset,"generic method for two groups",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(107));
InstallMethod(Intersection2,"generic method for two groups",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(108));
EnumeratorOfGroup:=COM_FUN(109);
InstallMethod(Enumerator,"generic method for a group",[IsGroup and IsAttributeStoringRep],EnumeratorOfGroup);
InstallMethod(AsSSortedListNonstored,"generic method for groups",true,[IsGroup],0,EnumeratorOfGroup);
InstallMethod(CentralizerOp,"generic method for group and object",IsCollsElms,[IsGroup,IsObject],COM_FUN(110));
InstallMethod(CentralizerOp,"generic method for two groups",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(111));
InstallGlobalFunction(IsomorphismTypeInfoFiniteSimpleGroup,COM_FUN(112));
InstallMethod(PrintObj,"for a group",[IsGroup],COM_FUN(113));
InstallMethod(PrintObj,"for a group with generators",[IsGroup and HasGeneratorsOfGroup],COM_FUN(114));
InstallMethod(ViewObj,"for a group",[IsGroup],COM_FUN(115));
InstallMethod(ViewObj,"for a group with generators",[IsGroup and HasGeneratorsOfMagmaWithInverses],COM_FUN(116));
InstallMethod(ViewObj,"for a group with generators and size",[IsGroup and HasGeneratorsOfMagmaWithInverses and HasSize],COM_FUN(117));
InstallMethod(GroupString,"for a group",[IsGroup,IsString],COM_FUN(118));
InstallMethod(GroupWithGenerators,"generic method for collection",[IsCollection],COM_FUN(119));
InstallMethod(GroupWithGenerators,"generic method for collection and identity element",IsCollsElms,[IsCollection,IsMultiplicativeElementWithInverse],COM_FUN(120));
InstallMethod(GroupWithGenerators,"method for empty list and element",[IsList and IsEmpty,IsMultiplicativeElementWithInverse],COM_FUN(121));
InstallMethod(GroupByGenerators,"delegate to `GroupWithGenerators'",[IsCollection],GroupWithGenerators);
InstallMethod(GroupByGenerators,"delegate to `GroupWithGenerators'",IsCollsElms,[IsCollection,IsMultiplicativeElementWithInverse],GroupWithGenerators);
InstallMethod(GroupByGenerators,"delegate to `GroupWithGenerators'",[IsList and IsEmpty,IsMultiplicativeElementWithInverse],GroupWithGenerators);
InstallMethod(IsCommutative,"generic method for groups",[IsGroup],IsCommutativeFromGenerators(GeneratorsOfGroup));
InstallMethod(IsGeneratorsOfMagmaWithInverses,"for an empty list",[IsList],COM_FUN(122));
InstallMethod(IsGeneratorsOfMagmaWithInverses,"for a list or collection",[IsListOrCollection],COM_FUN(123));
InstallGlobalFunction(Group,COM_FUN(124));
InstallGlobalFunction(SubgroupByProperty,COM_FUN(125));
InstallMethod(PrintObj,"subgroup by property",[IsGroup and HasElementTestFunction],0,COM_FUN(126));
InstallMethod(ViewObj,"subgroup by property",[IsGroup and HasElementTestFunction],0,COM_FUN(127));
InstallMethod(\in,"subgroup by property",[IsObject,IsGroup and HasElementTestFunction],0,COM_FUN(128));
InstallMethod(GeneratorsOfGroup,"Schreier generators",[IsGroup and HasElementTestFunction],0,COM_FUN(129));
InstallGlobalFunction(SubgroupShell,COM_FUN(130));
InstallMethod(PrimePowerComponents,"generic method",[IsMultiplicativeElement],COM_FUN(131));
InstallMethod(PrimePowerComponent,"generic method",[IsMultiplicativeElement,IsPosInt],COM_FUN(132));
InstallMethod(\.,"group generators",true,[IsGroup and HasGeneratorsOfGroup,IsPosInt],COM_FUN(133));
InstallGlobalFunction(NormalSubgroupsAbove,COM_FUN(134));
InstallMethod(NormalSubgroups,"generic class union",true,[IsGroup],COM_FUN(135));
InstallMethod(MaximalNormalSubgroups,"generic search",[IsGroup],COM_FUN(136));
InstallMethod(MinimalNormalSubgroups,"generic search in NormalSubgroups",[IsGroup and IsFinite and HasNormalSubgroups],COM_FUN(137));
InstallMethod(MinimalNormalSubgroups,"compute from conjugacy classes",[IsGroup and IsFinite],COM_FUN(138));
InstallMethod(MinimalNormalSubgroups,"handled by nice monomorphism",true,[IsGroup and IsHandledByNiceMonomorphism and IsFinite],0,COM_FUN(139));
InstallMethod(SmallGeneratingSet,"generators subset",[IsGroup and HasGeneratorsOfGroup],COM_FUN(140));
InstallMethod(\<,"groups by smallest generating sets",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(141));
InstallGlobalFunction(PowerMapOfGroupWithInvariants,COM_FUN(142));
InstallMethod(PowerMapOfGroup,"method for a group",[IsGroup,IsInt,IsHomogeneousList],COM_FUN(143));
InstallMethod(PowerMapOfGroup,"method for a permutation group",[IsGroup and IsPermCollection,IsInt,IsHomogeneousList],COM_FUN(144));
InstallMethod(PowerMapOfGroup,"method for a matrix group",[IsGroup and IsRingElementCollCollColl,IsInt,IsHomogeneousList],COM_FUN(145));
InstallMethod(KnowsHowToDecompose,"generic: just groups of order < 1000",IsIdenticalObj,[IsGroup,IsList],COM_FUN(146));
InstallOtherMethod(KnowsHowToDecompose,"trivial group",true,[IsGroup,IsEmpty],COM_FUN(147));
InstallMethod(KnowsHowToDecompose,"group: use GeneratorsOfGroup",[IsGroup],COM_FUN(148));
InstallGlobalFunction(HasAbelianFactorGroup,COM_FUN(149));
InstallGlobalFunction(HasElementaryAbelianFactorGroup,COM_FUN(150));
BindGlobal("Group_InitPseudoRandom",COM_FUN(151));
InstallGlobalFunction(Group_PseudoRandom,COM_FUN(152));
InstallMethod(PseudoRandom,"product replacement",[IsGroup and HasGeneratorsOfGroup],Group_PseudoRandom);
InstallMethod(ConjugateSubgroups,"generic",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(153));
InstallTrueMethod(CanComputeSize,HasSize);
InstallMethod(CanComputeIndex,"by default impossible unless identical",IsIdenticalObj,[IsGroup,IsGroup],COM_FUN(154));
InstallMethod(CanComputeIndex,"if sizes can be computed",IsIdenticalObj,[IsGroup and CanComputeSize,IsGroup and CanComputeSize],COM_FUN(155));
InstallMethod(CanComputeIsSubset,"if membership test works",IsIdenticalObj,[IsDomain and CanEasilyTestMembership,IsGroup and HasGeneratorsOfGroup],ReturnTrue);
InstallSubsetMaintenance(CanComputeSizeAnySubgroup,IsGroup and CanComputeSizeAnySubgroup,IsGroup);
InstallGlobalFunction(Factorization,COM_FUN(156));
InstallOtherMethod(Order,"for a group",[IsGroup],Size);
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grp.gi"

#F  file="lib/addmagma.gi" crc=62805062
RANK_FILTER_LIST  := [ 10550997, 12, 29425635, 13, 41090788, 15, 4521700, 17, 
  10550997, 12, 29425635, 13, 41090788, 15, 4521700, 17, 41090788, 15, 
  4521700, 17, 3341512, 14, 8126465, 2, 1985, 1, 8193, 2, 8126465, 2, 1985, 
  1, 8193, 2, 8126465, 2, 1985, 1, 8193, 2, 22217142, 17, 33882295, 19, 
  41090788, 15, 4521700, 17, 4521700, 17, 29425635, 13, 41090788, 15, 
  4521700, 17, 23667443, 18, 63694528, 15, 10550997, 12, 10550997, 12, 
  3341512, 14, 63694528, 15, 3341512, 14, 36895254, 19, 10551989, 14, 
  10550997, 12, 10550997, 12, 3341512, 14, 3341512, 14, 63241866, 16, 
  63241866, 16, 63241866, 16, 30505985, 3, 63241866, 16, 63241866, 16 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/addmagma.gi", 62805062 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/addmagma.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/addmagma.gi");
elif COM_RESULT = 3  then
Revision.addmagma_gi:="@(#)$Id: addmagma.gi,v 4.24 2002/09/03 15:24:14 gap Exp $";
InstallMethod(PrintObj,"for an add. magma",[IsAdditiveMagma],COM_FUN(1));
InstallMethod(PrintObj,"for an add. magma with generators",[IsAdditiveMagma and HasGeneratorsOfAdditiveMagma],COM_FUN(2));
InstallMethod(PrintObj,"for an add. magma-with-zero with generators",[IsAdditiveMagmaWithZero and HasGeneratorsOfAdditiveMagmaWithZero],COM_FUN(3));
InstallMethod(PrintObj,"for an add. magma-with-inverses with generators",[IsAdditiveGroup and HasGeneratorsOfAdditiveGroup],COM_FUN(4));
InstallMethod(ViewObj,"for an add. magma",[IsAdditiveMagma],COM_FUN(5));
InstallMethod(ViewObj,"for an add. magma with generators",[IsAdditiveMagma and HasGeneratorsOfAdditiveMagma],COM_FUN(6));
InstallMethod(ViewObj,"for an add. magma-with-zero with generators",[IsAdditiveMagmaWithZero and HasGeneratorsOfAdditiveMagmaWithZero],COM_FUN(7));
InstallMethod(ViewObj,"for an add. magma-with-inverses with generators",[IsAdditiveGroup and HasGeneratorsOfAdditiveGroup],COM_FUN(8));
InstallImmediateMethod(IsTrivial,IsAdditiveMagmaWithZero and HasGeneratorsOfAdditiveMagmaWithZero,0,COM_FUN(9));
InstallImmediateMethod(IsTrivial,IsAdditiveGroup and HasGeneratorsOfAdditiveGroup,0,COM_FUN(10));
InstallGlobalFunction(AdditiveMagma,COM_FUN(11));
InstallGlobalFunction(SubadditiveMagma,COM_FUN(12));
InstallGlobalFunction(SubadditiveMagmaNC,COM_FUN(13));
InstallGlobalFunction(AdditiveMagmaWithZero,COM_FUN(14));
InstallGlobalFunction(SubadditiveMagmaWithZero,COM_FUN(15));
InstallGlobalFunction(SubadditiveMagmaWithZeroNC,COM_FUN(16));
InstallGlobalFunction(AdditiveGroup,COM_FUN(17));
InstallGlobalFunction(SubadditiveGroup,COM_FUN(18));
InstallGlobalFunction(SubadditiveGroupNC,COM_FUN(19));
InstallMethod(TrivialSubadditiveMagmaWithZero,"for add.-magma-with-zero",[IsAdditiveMagmaWithZero],COM_FUN(20));
InstallMethod(AdditiveMagmaByGenerators,"for collection",[IsCollection],COM_FUN(21));
InstallOtherMethod(AdditiveMagmaByGenerators,"for family and list",[IsFamily,IsList],COM_FUN(22));
InstallMethod(AdditiveMagmaWithZeroByGenerators,"for collection",[IsCollection],COM_FUN(23));
InstallOtherMethod(AdditiveMagmaWithZeroByGenerators,"for family and list",[IsFamily,IsList],COM_FUN(24));
InstallMethod(AdditiveGroupByGenerators,"for collection",[IsCollection],COM_FUN(25));
InstallOtherMethod(AdditiveGroupByGenerators,"for family and list",[IsFamily,IsList],COM_FUN(26));
InstallImmediateMethod(GeneratorsOfAdditiveMagmaWithZero,IsAdditiveMagmaWithZero and HasGeneratorsOfAdditiveMagma and IsAttributeStoringRep,0,COM_FUN(27));
InstallImmediateMethod(GeneratorsOfAdditiveGroup,IsAdditiveGroup and HasGeneratorsOfAdditiveMagmaWithZero and IsAttributeStoringRep,0,COM_FUN(28));
InstallMethod(GeneratorsOfAdditiveMagma,[IsAdditiveMagmaWithZero and HasGeneratorsOfAdditiveMagmaWithZero],COM_FUN(29));
InstallMethod(GeneratorsOfAdditiveMagma,[IsAdditiveGroup and HasGeneratorsOfAdditiveGroup],COM_FUN(30));
InstallMethod(GeneratorsOfAdditiveMagmaWithZero,[IsAdditiveGroup and HasGeneratorsOfAdditiveGroup],COM_FUN(31));
InstallMethod(Representative,"for additive magma with known generators",[IsAdditiveMagma and HasGeneratorsOfAdditiveMagma],RepresentativeFromGenerators(GeneratorsOfAdditiveMagma));
InstallMethod(Representative,"for additive-magma-with-zero with known generators",[IsAdditiveMagmaWithZero and HasGeneratorsOfAdditiveMagmaWithZero],RepresentativeFromGenerators(GeneratorsOfAdditiveMagmaWithZero));
InstallMethod(Representative,"for additive-magma-with-inverses with known generators",[IsAdditiveGroup and HasGeneratorsOfAdditiveGroup],RepresentativeFromGenerators(GeneratorsOfAdditiveGroup));
InstallMethod(Representative,"for additive-magma-with-zero with known zero",[IsAdditiveMagmaWithZero and HasZero],SUM_FLAGS,Zero);
InstallMethod(Representative,"for additive-magma-with-zero with stored parent",[IsAdditiveMagmaWithZero and HasParentAttr],COM_FUN(32));
InstallMethod(AdditiveNeutralElement,[IsAdditiveMagma],COM_FUN(33));
InstallOtherMethod(Zero,"for additive magma",[IsAdditiveMagma],COM_FUN(34));
InstallOtherMethod(Zero,"for additive magma with zero (look at family)",[IsAdditiveMagmaWithZero],SUM_FLAGS,COM_FUN(35));
InstallOtherMethod(Zero,"for an add. magma-with-zero with parent (ask the parent)",[IsAdditiveMagmaWithZero and HasParent],COM_FUN(36));
InstallOtherMethod(Zero,"for additive magma with zero",[IsAdditiveMagmaWithZero],COM_FUN(37));
EnumeratorOfTrivialAdditiveMagmaWithZero:=COM_FUN(38);
InstallMethod(Enumerator,"for trivial add. magma-with-zero",[IsAdditiveMagmaWithZero and IsTrivial],EnumeratorOfTrivialAdditiveMagmaWithZero);
BindGlobal("ClosureAdditiveMagmaDefault",COM_FUN(39));
BindGlobal("EnumeratorOfAdditiveMagma",COM_FUN(40));
InstallMethod(Enumerator,"generic method for an add. magma",[IsAdditiveMagma and IsAttributeStoringRep],EnumeratorOfAdditiveMagma);
InstallMethod(IsSubset,"for two additive magmas",IsIdenticalObj,[IsAdditiveMagma,IsAdditiveMagma],COM_FUN(41));
InstallMethod(IsSubset,"for two additive magmas with zero",IsIdenticalObj,[IsAdditiveMagmaWithZero,IsAdditiveMagmaWithZero],COM_FUN(42));
InstallMethod(IsSubset,"for two additive magmas with inverses",IsIdenticalObj,[IsAdditiveGroup,IsAdditiveGroup],COM_FUN(43));
InstallMethod(ClosureAdditiveGroup,"for add. group and element",IsCollsElms,[IsAdditiveGroup,IsAdditiveElement],COM_FUN(44));
InstallOtherMethod(ClosureAdditiveGroup,"for two add. groups",IsIdenticalObj,[IsAdditiveGroup,IsAdditiveGroup],COM_FUN(45));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/addmagma.gi"

#F  file="lib/addcoset.gi" crc=28663516
RANK_FILTER_LIST  := [ 63241866, 16, 30505985, 3, 36699906, 14, 36699906, 14, 
  63241866, 16, 30505985, 3, 30505985, 3, 63241866, 16, 67108745, 12, 
  30505985, 3, 30505985, 3, 67108745, 12, 67108745, 12, 67108745, 12, 
  67108745, 12, 67108745, 12, 67108745, 12, 67108745, 12, 67108745, 12, 
  63241866, 16, 63241866, 16, 67108745, 12, 30505985, 3, 67108745, 12, 
  67108745, 12, 67108745, 12, 67108745, 12, 67108745, 12 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/addcoset.gi", 28663516 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/addcoset.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/addcoset.gi");
elif COM_RESULT = 3  then
Revision.addcoset_gi:="@(#)$Id: addcoset.gi,v 4.7 2002/04/15 10:04:22 sal Exp $";
DeclareRepresentation("IsAdditiveCosetDefaultRep",IsPositionalObjectRep,[1,2]);
InstallMethod(AdditiveCoset,"for additive group and additive element",IsCollsElms,[IsAdditiveGroup,IsAdditiveElement],0,COM_FUN(1));
InstallMethod(AdditivelyActingDomain,"for additive coset in default repres.",true,[IsAdditiveCoset and IsAdditiveCosetDefaultRep],SUM_FLAGS,COM_FUN(2));
InstallMethod(Representative,"for additive coset in default repres.",true,[IsAdditiveCoset and IsAdditiveCosetDefaultRep],SUM_FLAGS,COM_FUN(3));
InstallOtherMethod(\+,"for additive group and additive element",IsCollsElms,[IsAdditiveGroup,IsAdditiveElement],0,COM_FUN(4));
InstallOtherMethod(\+,"for additive element and additive group",IsElmsColls,[IsAdditiveElement,IsAdditiveGroup],0,COM_FUN(5));
InstallMethod(\+,"for additive coset and additive element",IsCollsElms,[IsAdditiveCoset,IsAdditiveElement],0,COM_FUN(6));
InstallMethod(\+,"for additive element and additive coset",IsElmsColls,[IsAdditiveElement,IsAdditiveCoset],0,COM_FUN(7));
InstallMethod(Enumerator,"for an additive coset",true,[IsAdditiveCoset],0,COM_FUN(8));
InstallMethod(IsFinite,"for an additive coset",true,[IsAdditiveCoset],0,COM_FUN(9));
InstallMethod(Random,"for an additive coset",true,[IsAdditiveCoset],0,COM_FUN(10));
InstallMethod(Size,"for an additive coset",true,[IsAdditiveCoset],0,COM_FUN(11));
InstallMethod(\=,"for two additive cosets",IsIdenticalObj,[IsAdditiveCoset,IsAdditiveCoset],0,COM_FUN(12));
InstallMethod(\=,"for additive coset and additive group",IsIdenticalObj,[IsAdditiveCoset,IsAdditiveGroup],0,COM_FUN(13));
InstallMethod(\=,"for additive group and additive coset",IsIdenticalObj,[IsAdditiveGroup,IsAdditiveCoset],0,COM_FUN(14));
InstallMethod(\in,"for additive element and additive coset",IsElmsColls,[IsAdditiveElement,IsAdditiveCoset],0,COM_FUN(15));
InstallMethod(Intersection2,"for two additive cosets",IsIdenticalObj,[IsAdditiveCoset,IsAdditiveCoset],0,COM_FUN(16));
InstallMethod(PrintObj,"for an additive coset",true,[IsAdditiveCoset],0,COM_FUN(17));
InstallMethod(ViewObj,"for an additive coset",true,[IsAdditiveCoset],0,COM_FUN(18));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/addcoset.gi"

#F  file="lib/ring.gi" crc=85210880
RANK_FILTER_LIST  := [ 50997183, 26, 47677574, 27, 46435352, 29, 39797094, 
  30, 50997183, 26, 47677574, 27, 46435352, 29, 39797094, 30, 61594698, 29, 
  50997183, 26, 51729872, 29, 50997183, 26, 47192361, 28, 47192361, 28, 
  42630530, 31, 42630530, 31, 51729872, 29, 47192361, 28, 42630530, 31, 
  32103976, 29, 59386888, 29, 8647946, 32, 43116735, 32, 50997183, 26, 
  39797094, 30, 47677574, 27, 39797094, 30, 50997183, 26, 1, 0, 1, 0, 
  8126465, 2, 8126465, 2, 8126465, 2, 50997183, 26, 64918210, 8, 64918210, 8, 
  64918210, 8, 64918210, 8, 50997183, 26, 47677574, 27, 46435352, 29, 
  39797094, 30, 47677574, 27, 39797094, 30, 47677574, 27, 50997183, 26, 
  50997183, 26, 64918210, 8, 46435352, 29, 64918210, 8, 50983264, 28, 
  64918210, 8, 50997183, 26, 50997183, 26, 46435352, 29, 46435352, 29, 
  50983264, 28, 8126465, 2, 50997183, 26, 8126465, 2, 64918210, 8, 64918210, 
  8, 50997183, 26, 64918210, 8, 64918210, 8, 64918210, 8, 34219637, 27, 
  64918210, 8, 50997183, 26, 64918210, 8, 50997183, 26, 64918210, 8, 
  64918210, 8, 50997183, 26, 64918210, 8, 64918210, 8, 64918210, 8, 64918210, 
  8, 64918210, 8, 64918210, 8, 64918210, 8, 40557768, 31, 64918210, 8, 
  64918210, 8, 64918210, 8, 64918210, 8, 40557768, 31, 64918210, 8, 64918210, 
  8, 64918210, 8, 64918210, 8, 64918210, 8, 64918210, 8, 64918210, 8, 
  40557768, 31, 64918210, 8, 64918210, 8, 64918210, 8, 64918210, 8, 17, 18, 
  64918210, 8, 50997183, 26, 64918210, 8, 17, 18, 64918210, 8, 64918210, 8, 
  64918210, 8, 40557768, 31, 64918210, 8, 64918210, 8, 64918210, 8, 64918210, 
  8, 40557768, 31, 64918210, 8, 64918210, 8, 64918210, 8, 64918210, 8, 
  40557768, 31, 64918210, 8, 64918210, 8, 47677574, 27, 47677574, 27 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/ring.gi", 85210880 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/ring.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/ring.gi");
elif COM_RESULT = 3  then
Revision.ring_gi:="@(#)$Id: ring.gi,v 4.49 2002/04/15 10:05:15 sal Exp $";
InstallMethod(PrintObj,"for a ring",true,[IsRing],0,COM_FUN(1));
InstallMethod(PrintObj,"for a ring with generators",true,[IsRing and HasGeneratorsOfRing],0,COM_FUN(2));
InstallMethod(PrintObj,"for a ring-with-one",true,[IsRingWithOne],0,COM_FUN(3));
InstallMethod(PrintObj,"for a ring-with-one with generators",true,[IsRingWithOne and HasGeneratorsOfRingWithOne],0,COM_FUN(4));
InstallMethod(ViewObj,"for a ring",true,[IsRing],0,COM_FUN(5));
InstallMethod(ViewObj,"for a ring with known generators",true,[IsRing and HasGeneratorsOfRing],0,COM_FUN(6));
InstallMethod(ViewObj,"for a ring-with-one",true,[IsRingWithOne],0,COM_FUN(7));
InstallMethod(ViewObj,"for a ring-with-one with known generators",true,[IsRingWithOne and HasGeneratorsOfRingWithOne],0,COM_FUN(8));
InstallImmediateMethod(IsAnticommutative,IsRing and IsCommutative and HasCharacteristic,0,COM_FUN(9));
InstallMethod(IsAnticommutative,"generic method for rings",true,[IsRing],0,COM_FUN(10));
InstallImmediateMethod(IsZeroSquaredRing,IsRing and IsAnticommutative and HasCharacteristic,0,COM_FUN(11));
InstallMethod(IsZeroSquaredRing,"for a ring",true,[IsRing],0,COM_FUN(12));
InstallMethod(IsCentral,"for two associative rings",IsIdenticalObj,[IsRing and IsAssociative,IsRing and IsAssociative],0,IsCentralFromGenerators(GeneratorsOfRing,GeneratorsOfRing));
InstallMethod(IsCentral,"for two associative rings-with-one",IsIdenticalObj,[IsRingWithOne and IsAssociative,IsRingWithOne and IsAssociative],0,IsCentralFromGenerators(GeneratorsOfRingWithOne,GeneratorsOfRingWithOne));
InstallImmediateMethod(IsCommutative,IsRing and IsAnticommutative and HasCharacteristic,0,COM_FUN(13));
InstallMethod(IsCommutative,"for an associative ring",true,[IsRing and IsAssociative],0,IsCommutativeFromGenerators(GeneratorsOfRing));
InstallMethod(IsCommutative,"for an associative ring-with-one",true,[IsRingWithOne and IsAssociative],0,IsCommutativeFromGenerators(GeneratorsOfRingWithOne));
InstallImmediateMethod(GeneratorsOfRing,IsRing and HasGeneratorsOfMagma and IsAttributeStoringRep,0,GeneratorsOfMagma);
InstallImmediateMethod(GeneratorsOfRing,IsRing and HasGeneratorsOfAdditiveMagmaWithInverses and IsAttributeStoringRep,0,GeneratorsOfAdditiveMagmaWithInverses);
InstallImmediateMethod(GeneratorsOfRingWithOne,IsRingWithOne and HasGeneratorsOfMagmaWithOne and IsAttributeStoringRep,0,GeneratorsOfMagmaWithOne);
InstallImmediateMethod(GeneratorsOfRingWithOne,IsRingWithOne and HasGeneratorsOfRing and IsAttributeStoringRep,0,GeneratorsOfRing);
InstallMethod(GeneratorsOfRing,"for a ring",true,[IsRing],0,GeneratorsOfMagma);
InstallMethod(GeneratorsOfRing,"for a ring-with-one with generators",true,[IsRingWithOne and HasGeneratorsOfRingWithOne],0,COM_FUN(14));
InstallMethod(Representative,"for a ring with generators",true,[IsRing and HasGeneratorsOfRing],0,RepresentativeFromGenerators(GeneratorsOfRing));
InstallMethod(Representative,"for a ring-with-one with generators",true,[IsRingWithOne and HasGeneratorsOfRingWithOne],0,RepresentativeFromGenerators(GeneratorsOfRingWithOne));
InstallOtherMethod(InterpolatedPolynomial,true,[IsRing,IsObject,IsObject],0,COM_FUN(15));
InstallMethod(RingByGenerators,"for a collection",true,[IsCollection],0,COM_FUN(16));
InstallMethod(DefaultRingByGenerators,"for a collection",true,[IsCollection],0,RingByGenerators);
InstallGlobalFunction(Ring,COM_FUN(17));
InstallGlobalFunction(DefaultRing,COM_FUN(18));
InstallGlobalFunction(Subring,COM_FUN(19));
InstallGlobalFunction(SubringNC,COM_FUN(20));
InstallGlobalFunction(SubringWithOne,COM_FUN(21));
InstallGlobalFunction(SubringWithOneNC,COM_FUN(22));
InstallMethod(RingWithOneByGenerators,"for a collection",true,[IsCollection],0,COM_FUN(23));
InstallGlobalFunction(RingWithOne,COM_FUN(24));
InstallMethod(IsAssociated,"for ring and two ring elements",IsCollsElmsElms,[IsRing,IsRingElement,IsRingElement],0,COM_FUN(25));
InstallOtherMethod(IsAssociated,"for two ring elements",IsIdenticalObj,[IsRingElement,IsRingElement],0,COM_FUN(26));
InstallMethod(IsSubset,"for two rings",IsIdenticalObj,[IsRing,IsRing and HasGeneratorsOfRing],0,COM_FUN(27));
InstallMethod(IsSubset,"for two rings-with-one",IsIdenticalObj,[IsRingWithOne,IsRingWithOne and HasGeneratorsOfRingWithOne],0,COM_FUN(28));
EnumeratorOfRing:=COM_FUN(29);
InstallMethod(Enumerator,"generic method for a ring with known generators",true,[IsRing and HasGeneratorsOfRing],0,EnumeratorOfRing);
InstallMethod(Enumerator,"generic method for a ring-with-one with known generators",true,[IsRingWithOne and HasGeneratorsOfRingWithOne],0,EnumeratorOfRing);
InstallMethod(Size,"characteristic zero ring is infinite",true,[IsRing and HasGeneratorsOfRing],0,COM_FUN(30));
InstallMethod(IsIntegralRing,"for a ring",true,[IsRing],0,COM_FUN(31));
InstallMethod(ClosureRing,"for a ring and a ring element",IsCollsElms,[IsRing,IsRingElement],0,COM_FUN(32));
InstallMethod(ClosureRing,"for a ring-with-one and a ring element",IsCollsElms,[IsRingWithOne,IsRingElement],0,COM_FUN(33));
InstallMethod(ClosureRing,"for a ring containing the whole family, and a ring element",IsCollsElms,[IsRing and IsWholeFamily,IsRingElement],SUM_FLAGS,COM_FUN(34));
InstallMethod(ClosureRing,"for two rings",IsIdenticalObj,[IsRing,IsRing],0,COM_FUN(35));
InstallMethod(ClosureRing,"for two rings-with-one",IsIdenticalObj,[IsRingWithOne,IsRingWithOne],0,COM_FUN(36));
InstallMethod(ClosureRing,"for a ring cont. the whole family, and a collection",IsIdenticalObj,[IsRing and IsWholeFamily,IsCollection],SUM_FLAGS,COM_FUN(37));
InstallMethod(ClosureRing,"for ring and collection of elements",IsIdenticalObj,[IsRing,IsCollection],0,COM_FUN(38));
InstallOtherMethod(Quotient,"for two ring elements (delegate to three argument version",IsIdenticalObj,[IsRingElement,IsRingElement],0,COM_FUN(39));
InstallMethod(Quotient,"for a ring and two ring elements",IsCollsElmsElms,[IsRing,IsRingElement,IsRingElement],0,COM_FUN(40));
InstallOtherMethod(IsUnit,"for a ring element",true,[IsRingElement],0,COM_FUN(41));
InstallMethod(IsUnit,"for a ring with known units and a ring element",IsCollsElms,[IsRing and HasUnits,IsRingElement],0,COM_FUN(42));
InstallMethod(IsUnit,"for a ring and a ring element",IsCollsElms,[IsRing,IsRingElement],0,COM_FUN(43));
InstallMethod(Units,"for a (finite) ring",true,[IsRing],0,COM_FUN(44));
InstallOtherMethod(StandardAssociate,"for a ring element",true,[IsRingElement],0,COM_FUN(45));
InstallOtherMethod(Associates,"for a ring element",true,[IsRingElement],0,COM_FUN(46));
InstallMethod(Associates,"for a ring and a ring element",IsCollsElms,[IsRing,IsRingElement],0,COM_FUN(47));
InstallOtherMethod(IsPrime,"for a ring element",true,[IsRingElement],0,COM_FUN(48));
InstallOtherMethod(IsIrreducibleRingElement,"for a ring element",true,[IsRingElement],0,COM_FUN(49));
InstallOtherMethod(Factors,"for a ring element",true,[IsRingElement],0,COM_FUN(50));
InstallOtherMethod(EuclideanDegree,"for a ring element",true,[IsRingElement],0,COM_FUN(51));
InstallOtherMethod(EuclideanRemainder,"for two ring elements",IsIdenticalObj,[IsRingElement,IsRingElement],0,COM_FUN(52));
InstallMethod(EuclideanRemainder,"for a Euclidean ring and two ring elements",IsCollsElmsElms,[IsEuclideanRing,IsRingElement,IsRingElement],0,COM_FUN(53));
InstallOtherMethod(EuclideanQuotient,"for two ring elements",IsIdenticalObj,[IsRingElement,IsRingElement],0,COM_FUN(54));
InstallMethod(EuclideanQuotient,"for a Euclidean ring and two ring elements",IsCollsElmsElms,[IsEuclideanRing,IsRingElement,IsRingElement],0,COM_FUN(55));
InstallOtherMethod(QuotientRemainder,"for two ring elements",IsIdenticalObj,[IsRingElement,IsRingElement],0,COM_FUN(56));
InstallOtherMethod(QuotientMod,"for three ring elements",COM_FUN(57),[IsRingElement,IsRingElement,IsRingElement],0,COM_FUN(58));
InstallMethod(QuotientMod,"for a Euclidean ring and three ring elements",IsCollsElmsElmsElms,[IsEuclideanRing,IsRingElement,IsRingElement,IsRingElement],0,COM_FUN(59));
InstallOtherMethod(PowerMod,"for ring element, integer, and ring element",true,[IsRingElement,IsInt,IsRingElement],0,COM_FUN(60));
InstallMethod(PowerMod,"for Euclidean ring, ring element, integer, and ring element",true,[IsRing,IsRingElement,IsInt,IsRingElement],0,COM_FUN(61));
InstallGlobalFunction(Gcd,COM_FUN(62));
InstallOtherMethod(GcdOp,"for two ring elements",IsIdenticalObj,[IsRingElement,IsRingElement],0,COM_FUN(63));
InstallMethod(GcdOp,"for a Euclidean ring and two ring elements",IsCollsElmsElms,[IsEuclideanRing,IsRingElement,IsRingElement],0,COM_FUN(64));
InstallGlobalFunction(GcdRepresentation,COM_FUN(65));
InstallOtherMethod(GcdRepresentationOp,"for two ring elements",IsIdenticalObj,[IsRingElement,IsRingElement],0,COM_FUN(66));
InstallMethod(GcdRepresentationOp,"for a Euclidean ring and two ring elements",IsCollsElmsElms,[IsEuclideanRing,IsRingElement,IsRingElement],0,COM_FUN(67));
InstallGlobalFunction(Lcm,COM_FUN(68));
InstallOtherMethod(LcmOp,"for two ring elements",IsIdenticalObj,[IsRingElement,IsRingElement],0,COM_FUN(69));
InstallMethod(LcmOp,"for a Euclidean ring and two ring elements",IsCollsElmsElms,[IsEuclideanRing,IsRingElement,IsRingElement],0,COM_FUN(70));
InstallMethod(\=,"for two rings with known generators",IsIdenticalObj,[IsRing and HasGeneratorsOfRing,IsRing and HasGeneratorsOfRing],0,COM_FUN(71));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/ring.gi"

#F  file="lib/ideal.gi" crc=-31914055
RANK_FILTER_LIST  := [ 50997183, 26, 8126465, 2, 50997183, 26, 8126465, 2, 
  50997183, 26, 8126465, 2, 14706608, 29, 11987059, 29, 10102134, 28, 
  36316924, 28, 49423839, 29, 10102134, 28, 36316924, 28, 49423839, 29, 
  4858984, 27, 25830624, 27, 56239373, 27, 61482523, 27, 53617798, 27, 
  56239373, 27, 61482523, 27, 53617798, 27, 52045414, 29, 57288564, 29, 
  49423839, 29, 49423839, 29, 4858984, 27, 4858984, 27, 25830624, 27, 
  25830624, 27, 46802264, 28, 46802264, 28, 64918210, 8, 50997183, 26, 
  50997183, 26, 64918210, 8, 4858984, 27, 50997183, 26, 50997183, 26, 
  25830624, 27, 50997183, 26, 50997183, 26, 50997183, 26, 50997183, 26, 
  50997183, 26, 50997183, 26 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/ideal.gi", -31914055 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/ideal.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/ideal.gi");
elif COM_RESULT = 3  then
Revision.ideal_gi:="@(#)$Id: ideal.gi,v 4.8.4.1 2005/03/31 13:23:24 gap Exp $";
InstallGlobalFunction(TwoSidedIdeal,COM_FUN(1));
InstallGlobalFunction(TwoSidedIdealNC,COM_FUN(2));
InstallGlobalFunction(LeftIdeal,COM_FUN(3));
InstallGlobalFunction(LeftIdealNC,COM_FUN(4));
InstallGlobalFunction(RightIdeal,COM_FUN(5));
InstallGlobalFunction(RightIdealNC,COM_FUN(6));
InstallMethod(TwoSidedIdealByGenerators,"for ring and collection",IsIdenticalObj,[IsRing,IsCollection],0,COM_FUN(7));
InstallMethod(LeftIdealByGenerators,"for ring and collection",IsIdenticalObj,[IsRing,IsCollection],0,COM_FUN(8));
InstallMethod(RightIdealByGenerators,"for ring and collection",IsIdenticalObj,[IsRing,IsCollection],0,COM_FUN(9));
InstallImmediateMethod(IsIdealInParent,IsLeftIdealInParent and HasParent,10,COM_FUN(10));
InstallImmediateMethod(IsIdealInParent,IsRightIdealInParent and HasParent,10,COM_FUN(11));
InstallMethod(PrintObj,"for a left ideal with known generators",true,[IsRing and HasLeftActingRingOfIdeal and HasGeneratorsOfLeftIdeal],0,COM_FUN(12));
InstallMethod(PrintObj,"for a right ideal with known generators",true,[IsRing and HasRightActingRingOfIdeal and HasGeneratorsOfRightIdeal],0,COM_FUN(13));
InstallMethod(PrintObj,"for a two-sided ideal with known generators",true,[IsRing and HasLeftActingRingOfIdeal and HasRightActingRingOfIdeal and HasGeneratorsOfTwoSidedIdeal],0,COM_FUN(14));
InstallMethod(ViewObj,"for a left ideal with known generators",true,[IsRing and HasLeftActingRingOfIdeal and HasGeneratorsOfLeftIdeal],100,COM_FUN(15));
InstallMethod(ViewObj,"for a right ideal with known generators",true,[IsRing and HasRightActingRingOfIdeal and HasGeneratorsOfRightIdeal],100,COM_FUN(16));
InstallMethod(ViewObj,"for a two-sided ideal with known generators",true,[IsRing and HasLeftActingRingOfIdeal and HasRightActingRingOfIdeal and HasGeneratorsOfTwoSidedIdeal],100,COM_FUN(17));
InstallOtherMethod(Zero,"for a left ideal",true,[IsRing and HasLeftActingRingOfIdeal],0,COM_FUN(18));
InstallOtherMethod(Zero,"for a right ideal",true,[IsRing and HasRightActingRingOfIdeal],0,COM_FUN(19));
EnumeratorOfIdeal:=COM_FUN(20);
InstallMethod(Enumerator,"generic method for a left ideal with known generators",true,[IsRing and HasGeneratorsOfLeftIdeal],0,EnumeratorOfIdeal);
InstallMethod(Enumerator,"generic method for a right ideal with known generators",true,[IsRing and HasGeneratorsOfRightIdeal],0,EnumeratorOfIdeal);
InstallMethod(Enumerator,"generic method for a two-sided ideal with known generators",true,[IsRing and HasGeneratorsOfIdeal],0,EnumeratorOfIdeal);
GeneratorsOfRingForIdeal:=COM_FUN(21);
InstallMethod(GeneratorsOfRing,"generic method for a left ideal with known generators",true,[IsRing and HasGeneratorsOfLeftIdeal],0,GeneratorsOfRingForIdeal);
InstallMethod(GeneratorsOfRing,"generic method for a right ideal with known generators",true,[IsRing and HasGeneratorsOfRightIdeal],0,GeneratorsOfRingForIdeal);
InstallMethod(GeneratorsOfRing,"generic method for a two-sided ideal with known generators",true,[IsRing and HasGeneratorsOfTwoSidedIdeal],0,GeneratorsOfRingForIdeal);
InstallMethod(GeneratorsOfTwoSidedIdeal,"for a two-sided ideal with known `GeneratorsOfLeftIdeal'",true,[IsRing and HasLeftActingRingOfIdeal and HasRightActingRingOfIdeal and HasGeneratorsOfLeftIdeal],0,GeneratorsOfLeftIdeal);
InstallMethod(GeneratorsOfTwoSidedIdeal,"for a two-sided ideal with known `GeneratorsOfRightIdeal'",true,[IsRing and HasLeftActingRingOfIdeal and HasRightActingRingOfIdeal and HasGeneratorsOfRightIdeal],0,GeneratorsOfRightIdeal);
InstallMethod(GeneratorsOfLeftIdeal,"for an ideal with known `GeneratorsOfTwoSidedIdeal'",true,[IsRing and HasLeftActingRingOfIdeal and HasRightActingRingOfIdeal and HasGeneratorsOfTwoSidedIdeal],0,GeneratorsOfRing);
InstallMethod(GeneratorsOfRightIdeal,"for an ideal with known `GeneratorsOfTwoSidedIdeal'",true,[IsRing and HasLeftActingRingOfIdeal and HasRightActingRingOfIdeal and HasGeneratorsOfTwoSidedIdeal],0,GeneratorsOfRing);
InstallMethod(\+,"method for two left ideals",IsIdenticalObj,[IsRing and HasLeftActingRingOfIdeal,IsRing and HasLeftActingRingOfIdeal],0,COM_FUN(22));
InstallMethod(\+,"method for two right ideals",IsIdenticalObj,[IsRing and HasRightActingRingOfIdeal,IsRing and HasRightActingRingOfIdeal],0,COM_FUN(23));
InstallMethod(\+,"method for two two-sided ideals",IsIdenticalObj,[IsRing and HasLeftActingRingOfIdeal and HasRightActingRingOfIdeal,IsRing and HasLeftActingRingOfIdeal and HasRightActingRingOfIdeal],0,COM_FUN(24));
InstallMethod(\*,"for ring element and ring (construct a right ideal)",IsElmsColls,[IsRingElement,IsRing],0,COM_FUN(25));
InstallMethod(\*,"for ring and ring element (construct a left ideal)",IsCollsElms,[IsRing,IsRingElement],0,COM_FUN(26));
InstallMethod(\*,"for left ideal and ring (construct a two-sided ideal)",IsIdenticalObj,[IsRing and HasLeftActingRingOfIdeal,IsRing],0,COM_FUN(27));
InstallMethod(\*,"for ring and right ideal (construct a two-sided ideal)",IsCollsElms,[IsRing,IsRing and HasRightActingRingOfIdeal],0,COM_FUN(28));
InstallMethod(AsLeftIdeal,"for two rings",IsIdenticalObj,[IsRing,IsRing],0,COM_FUN(29));
InstallMethod(AsRightIdeal,"for two rings",IsIdenticalObj,[IsRing,IsRing],0,COM_FUN(30));
InstallMethod(AsTwoSidedIdeal,"for two rings",IsIdenticalObj,[IsRing,IsRing],0,COM_FUN(31));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/ideal.gi"

#F  file="lib/module.gi" crc=-64859979
RANK_FILTER_LIST  := [ 50997183, 26, 8126465, 2, 50997183, 26, 32769, 4, 1, 
  0, 50997183, 26, 8126465, 2, 50997183, 26, 48094768, 22, 16777714, 25, 
  8193, 2, 50790197, 23, 49792331, 19, 33623353, 19, 48094768, 22, 63198130, 
  7, 48094768, 22, 48094768, 22, 48094768, 22, 48094768, 22, 48094768, 22, 
  16776722, 23 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/module.gi", -64859979 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/module.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/module.gi");
elif COM_RESULT = 3  then
Revision.module_gi:="@(#)$Id: module.gi,v 4.41 2002/04/15 10:05:04 sal Exp $";
InstallMethod(LeftModuleByGenerators,"for ring and collection",true,[IsRing,IsCollection],0,COM_FUN(1));
InstallMethod(LeftModuleByGenerators,"for ring, homogeneous list, and vector",true,[IsRing,IsHomogeneousList,IsObject],0,COM_FUN(2));
InstallMethod(AsLeftModule,"generic method for a ring and a collection",true,[IsRing,IsCollection],0,COM_FUN(3));
InstallMethod(AsLeftModule," for a ring and a left module",true,[IsRing,IsLeftModule],0,COM_FUN(4));
InstallMethod(SetGeneratorsOfLeftModule,"method that checks for `IsFiniteDimensional'",IsIdenticalObj,[IsFreeLeftModule and IsAttributeStoringRep,IsList],0,COM_FUN(5));
InstallMethod(Characteristic,"for a left module with known left acting domain",true,[IsLeftModule and HasLeftActingDomain],0,COM_FUN(6));
InstallMethod(Representative,"for left operator additive group with known generators",true,[IsLeftOperatorAdditiveGroup and HasGeneratorsOfLeftOperatorAdditiveGroup],0,RepresentativeFromGenerators(GeneratorsOfLeftOperatorAdditiveGroup));
InstallMethod(Representative,"for right operator additive group with known generators",true,[IsRightOperatorAdditiveGroup and HasGeneratorsOfRightOperatorAdditiveGroup],0,RepresentativeFromGenerators(GeneratorsOfRightOperatorAdditiveGroup));
InstallMethod(ClosureLeftModule,"for left module and vector",IsCollsElms,[IsLeftModule,IsVector],0,COM_FUN(7));
InstallOtherMethod(ClosureLeftModule,"for two left modules",IsIdenticalObj,[IsLeftModule,IsLeftModule],0,COM_FUN(8));
InstallOtherMethod(\+,"for two left modules",IsIdenticalObj,[IsLeftModule,IsLeftModule],0,COM_FUN(9));
InstallGlobalFunction(Submodule,COM_FUN(10));
InstallGlobalFunction(SubmoduleNC,COM_FUN(11));
InstallMethod(TrivialSubadditiveMagmaWithZero,"generic method for left modules",true,[IsLeftModule],0,COM_FUN(12));
InstallMethod(DimensionOfVectors,"generic method for left modules",true,[IsFreeLeftModule],0,COM_FUN(13));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/module.gi"

#F  file="lib/modfree.gi" crc=77356917
RANK_FILTER_LIST  := [ 16776722, 23, 16776722, 23, 16776722, 23, 16776722, 
  23, 63198130, 7, 50331049, 25, 16776647, 24, 16776722, 23, 16828906, 24, 
  16776722, 23, 16776722, 23, 16776722, 23, 16776722, 23, 16776722, 23, 
  16776722, 23, 16776722, 23, 16776722, 23, 16828906, 24, 33554840, 26, 
  16776722, 23, 16776722, 23, 33553848, 24, 63198130, 7, 16776722, 23, 32769, 
  4, 16828906, 24, 24602411, 24, 16776722, 23, 24602411, 24, 16776722, 23 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/modfree.gi", 77356917 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/modfree.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/modfree.gi");
elif COM_RESULT = 3  then
Revision.modfree_gi:="@(#)$Id: modfree.gi,v 4.40 2003/05/24 09:30:36 gap Exp $";
InstallMethod(\=,"for two free left modules (at least one fin. dim.)",IsIdenticalObj,[IsFreeLeftModule,IsFreeLeftModule],COM_FUN(1));
InstallMethod(\<,"for two free left modules",IsIdenticalObj,[IsFreeLeftModule,IsFreeLeftModule],COM_FUN(2));
InstallMethod(\in,"for vector and fin. dim. free left module",IsElmsColls,[IsVector,IsFreeLeftModule and IsFiniteDimensional],COM_FUN(3));
InstallImmediateMethod(IsFinite,IsFreeLeftModule and HasIsFiniteDimensional,0,COM_FUN(4));
InstallMethod(IsFinite,"for a free left module",[IsFreeLeftModule],COM_FUN(5));
InstallImmediateMethod(IsTrivial,IsFreeLeftModule and HasDimension,0,COM_FUN(6));
InstallMethod(IsTrivial,"for a free left module",[IsFreeLeftModule],COM_FUN(7));
InstallMethod(Size,"for a free left module",[IsFreeLeftModule],COM_FUN(8));
AsListOfFreeLeftModule:=COM_FUN(9);
InstallMethod(AsList,"for a free left module",[IsFreeLeftModule],AsListOfFreeLeftModule);
InstallMethod(AsSSortedList,"for a free left module",[IsFreeLeftModule],AsListOfFreeLeftModule);
InstallMethod(Random,"for a free left module",[IsFreeLeftModule],COM_FUN(10));
BindGlobal("GeneratorsOverIntersection",COM_FUN(11));
InstallMethod(IsSubset,"for two free left modules",IsIdenticalObj,[IsFreeLeftModule,IsFreeLeftModule],COM_FUN(12));
InstallMethod(Dimension,"for a free left module",[IsFreeLeftModule],COM_FUN(13));
InstallMethod(IsFiniteDimensional,"for a free left module with known dimension",[IsFreeLeftModule and HasDimension],COM_FUN(14));
InstallImmediateMethod(GeneratorsOfLeftModule,IsFreeLeftModule and HasBasis and IsAttributeStoringRep,0,COM_FUN(15));
InstallMethod(Enumerator,"for free left module (delegate to 'EnumeratorByBasis')",[IsFreeLeftModule],COM_FUN(16));
InstallMethod(Iterator,"for free left module (delegate to 'IteratorByBasis')",[IsFreeLeftModule],COM_FUN(17));
InstallMethod(ClosureLeftModule,"for free left module and vector",IsCollsElms,[IsFreeLeftModule and HasBasis,IsVector],COM_FUN(18));
InstallGlobalFunction(FreeLeftModule,COM_FUN(19));
InstallMethod(UseBasis,"for a free left module and a homog. list",[IsFreeLeftModule,IsHomogeneousList],COM_FUN(20));
InstallMethod(ViewObj,"for free left module with known dimension",[IsFreeLeftModule and HasDimension],COM_FUN(21));
InstallMethod(ViewObj,"for free left module with known generators",[IsFreeLeftModule and HasGeneratorsOfLeftModule],COM_FUN(22));
InstallMethod(ViewObj,"for free left module",[IsFreeLeftModule],COM_FUN(23));
InstallMethod(PrintObj,"for free left module with known generators",[IsFreeLeftModule and HasGeneratorsOfLeftModule],COM_FUN(24));
InstallMethod(PrintObj,"for free left module",[IsFreeLeftModule],COM_FUN(25));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/modfree.gi"

#F  file="lib/modulrow.gi" crc=133039391
RANK_FILTER_LIST  := [ 50997183, 26, 17, 18, 16776722, 23, 16776722, 23, 
  33559284, 48, 33559284, 48, 33559284, 48, 33559284, 48, 33559284, 48, 
  33559284, 48, 65077940, 12, 33559284, 48, 48038575, 16, 33559284, 48, 
  33559284, 48, 10597734, 16, 65077940, 12, 62163887, 7, 48038575, 16, 
  10597734, 16 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/modulrow.gi", 133039391 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/modulrow.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/modulrow.gi");
elif COM_RESULT = 3  then
Revision.modulrow_gi:="@(#)$Id: modulrow.gi,v 4.38 2003/06/04 17:45:08 gap Exp $";
InstallGlobalFunction(FullRowModule,COM_FUN(1));
InstallOtherMethod(\^,"for ring and integer (delegate to `FullRowModule')",[IsRing,IsInt],FullRowModule);
InstallMethod(IsRowModule,"for a free left module",[IsFreeLeftModule],COM_FUN(2));
InstallMethod(IsFullRowModule,"for free left (row) module",[IsFreeLeftModule],COM_FUN(3));
InstallMethod(Dimension,"for full row module",[IsFreeLeftModule and IsFullRowModule],DimensionOfVectors);
InstallMethod(Random,"for full row module",[IsFreeLeftModule and IsFullRowModule],COM_FUN(4));
InstallMethod(Representative,"for full row module",[IsFreeLeftModule and IsFullRowModule],COM_FUN(5));
InstallMethod(GeneratorsOfLeftModule,"for full row module",[IsFreeLeftModule and IsFullRowModule],COM_FUN(6));
InstallMethod(ViewObj,"for full row module",[IsFreeLeftModule and IsFullRowModule],COM_FUN(7));
InstallMethod(PrintObj,"for full row module",[IsFreeLeftModule and IsFullRowModule],COM_FUN(8));
InstallMethod(\in,"for full row module",IsElmsColls,[IsRowVector,IsFreeLeftModule and IsFullRowModule],COM_FUN(9));
InstallMethod(BasisVectors,"for canonical basis of a full row module",[IsBasis and IsCanonicalBasis and IsCanonicalBasisFullRowModule],COM_FUN(10));
InstallMethod(CanonicalBasis,"for a full row module",[IsFreeLeftModule and IsFullRowModule],COM_FUN(11));
InstallMethod(Basis,"for full row module (delegate to `CanonicalBasis')",[IsFreeLeftModule and IsFullRowModule],CANONICAL_BASIS_FLAGS,CanonicalBasis);
InstallMethod(Coefficients,"for canonical basis of a full row module",IsCollsElms,[IsBasis and IsCanonicalBasisFullRowModule,IsRowVector],COM_FUN(12));
InstallMethod(IsCanonicalBasisFullRowModule,"for a basis",[IsBasis],COM_FUN(13));
BindGlobal("NumberElement_FiniteFullRowModule",COM_FUN(14));
BindGlobal("PosVecEnumFF",COM_FUN(15));
BindGlobal("ElementNumber_FiniteFullRowModule",COM_FUN(16));
BindGlobal("NumberElement_InfiniteFullRowModule",COM_FUN(17));
BindGlobal("ElementNumber_InfiniteFullRowModule",COM_FUN(18));
InstallMethod(EnumeratorByBasis,"for enumerator via canonical basis of a full row module",[IsBasis and IsCanonicalBasis and IsCanonicalBasisFullRowModule],COM_FUN(19));
BindGlobal("NextIterator_FiniteFullRowModule",COM_FUN(20));
BindGlobal("IsDoneIterator_FiniteFullRowModule",COM_FUN(21));
BindGlobal("ShallowCopy_FiniteFullRowModule",COM_FUN(22));
BindGlobal("NextIterator_InfiniteFullRowModule",COM_FUN(23));
BindGlobal("ShallowCopy_InfiniteFullRowModule",COM_FUN(24));
InstallMethod(IteratorByBasis,"for canonical basis of a full row module",[IsBasis and IsCanonicalBasisFullRowModule],COM_FUN(25));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/modulrow.gi"

#F  file="lib/modulmat.gi" crc=13007432
RANK_FILTER_LIST  := [ 50997183, 26, 26132143, 27, 16776722, 23, 16776722, 
  23, 16796171, 48, 16796171, 48, 16796171, 48, 16796171, 48, 16796171, 48, 
  16796171, 48, 1, 0, 16796171, 48, 27559794, 16, 16796171, 48, 16796171, 48, 
  57227832, 16, 58412696, 30, 62163887, 7 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/modulmat.gi", 13007432 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/modulmat.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/modulmat.gi");
elif COM_RESULT = 3  then
Revision.modulmat_gi:="@(#)$Id: modulmat.gi,v 4.20 2002/04/15 10:05:04 sal Exp $";
InstallGlobalFunction(FullMatrixModule,COM_FUN(1));
InstallOtherMethod(\^,"for ring and list of integers (delegate to `FullMatrixModule')",[IsRing,IsCyclotomicCollection and IsList],COM_FUN(2));
InstallMethod(IsMatrixModule,"for a free left module",[IsFreeLeftModule],COM_FUN(3));
InstallMethod(IsFullMatrixModule,"for matrix module",[IsFreeLeftModule],COM_FUN(4));
InstallMethod(Dimension,"for full matrix module",[IsFreeLeftModule and IsFullMatrixModule],COM_FUN(5));
InstallMethod(Random,"for full matrix module",[IsFreeLeftModule and IsFullMatrixModule],COM_FUN(6));
InstallMethod(Representative,"for full matrix module",[IsFreeLeftModule and IsFullMatrixModule],COM_FUN(7));
InstallGlobalFunction(StandardGeneratorsOfFullMatrixModule,COM_FUN(8));
InstallMethod(GeneratorsOfLeftModule,"for full matrix module",[IsFreeLeftModule and IsFullMatrixModule],StandardGeneratorsOfFullMatrixModule);
InstallMethod(ViewObj,"for full matrix module",[IsFreeLeftModule and IsFullMatrixModule],COM_FUN(9));
InstallMethod(PrintObj,"for full matrix module",[IsFreeLeftModule and IsFullMatrixModule],COM_FUN(10));
InstallMethod(\in,"for full matrix module",IsElmsColls,[IsObject,IsFreeLeftModule and IsFullMatrixModule],COM_FUN(11));
InstallMethod(BasisVectors,"for canonical basis of a full matrix module",[IsBasis and IsCanonicalBasis and IsCanonicalBasisFullMatrixModule],COM_FUN(12));
InstallMethod(CanonicalBasis,[IsFreeLeftModule and IsFullMatrixModule],COM_FUN(13));
InstallMethod(Basis,"for full matrix module (delegate to `CanonicalBasis')",[IsFreeLeftModule and IsFullMatrixModule],CANONICAL_BASIS_FLAGS,CanonicalBasis);
InstallMethod(Coefficients,"for canonical basis of a full matrix module",IsCollsElms,[IsBasis and IsCanonicalBasisFullMatrixModule,IsMatrix],COM_FUN(14));
InstallMethod(IsCanonicalBasisFullMatrixModule,"for a basis",[IsBasis],COM_FUN(15));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/modulmat.gi"

#F  file="lib/basis.gi" crc=-123615838
RANK_FILTER_LIST  := [ 21269860, 10, 3444083, 10, 62163887, 7, 62163887, 7, 
  7665940, 19, 62163887, 7, 1, 0, 17, 18, 62163887, 7, 62163887, 7, 32769, 4, 
  62163887, 7, 32769, 4, 21268868, 8, 62163887, 7, 40929743, 10, 14715883, 9, 
  32494889, 9, 21268868, 8, 62163887, 7, 40929743, 10, 14715883, 9, 32494889, 
  9, 47638844, 26, 16776722, 23, 62163887, 7, 32769, 4, 8193, 2, 8193, 2, 
  62163887, 7, 62163887, 7, 62163887, 7, 1346209, 13, 63198130, 7, 16776722, 
  23, 32769, 4, 16776722, 23, 32769, 4, 16776347, 27, 16776347, 27, 1, 0, 
  16776347, 27, 1, 0, 16776347, 27, 33608770, 27, 33608770, 27, 1, 0, 
  33608770, 27, 1, 0, 50496895, 13, 50496895, 13, 50496895, 13, 50496895, 13, 
  63198130, 7, 16803294, 26, 50496895, 13, 16803294, 26, 16803294, 26, 32769, 
  4, 16803294, 26, 32769, 4, 24628983, 27, 59812496, 37, 56007674, 39, 
  34728382, 39, 44593208, 39, 63198130, 7, 16803294, 26, 50330464, 30, 
  16776722, 23, 41951068, 17, 16776722, 23, 41951068, 17, 16776722, 23, 
  41951068, 17, 16776722, 23, 41951068, 17, 36997883, 18, 36997883, 18, 
  63198130, 7, 36997883, 18, 41951068, 17, 36997883, 18, 63198130, 7, 
  7637410, 10, 7637410, 10, 63198130, 7, 7637410, 10, 32769, 4, 7637410, 10 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/basis.gi", -123615838 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/basis.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/basis.gi");
elif COM_RESULT = 3  then
Revision.basis_gi:="@(#)$Id: basis.gi,v 4.67.2.1 2007/08/30 08:17:03 gap Exp $";
InstallImmediateMethod(IsSmallList,IsBasis and HasBasisVectors and IsAttributeStoringRep,0,COM_FUN(1));
InstallImmediateMethod(IsSmallList,IsBasis and HasUnderlyingLeftModule and IsAttributeStoringRep,0,COM_FUN(2));
InstallMethod(IsCanonicalBasis,"for a basis",[IsBasis],COM_FUN(3));
InstallMethod(\[\],"for a basis and a positive integer",[IsBasis,IsPosInt],COM_FUN(4));
InstallMethod(Position,"for a basis, an object, and a nonnegative integer",[IsBasis,IsObject,IsInt],COM_FUN(5));
InstallMethod(Length,"for a basis",[IsBasis],COM_FUN(6));
DeclareRepresentation("IsRelativeBasisDefaultRep",IsAttributeStoringRep,["basis","basechangeMatrix"]);
InstallTrueMethod(IsFinite,IsBasis and IsRelativeBasisDefaultRep);
InstallMethod(RelativeBasis,"for a basis and a homogeneous list",IsIdenticalObj,[IsBasis,IsHomogeneousList],COM_FUN(7));
InstallMethod(RelativeBasisNC,"for a basis and a homogeneous list",IsIdenticalObj,[IsBasis,IsHomogeneousList],COM_FUN(8));
InstallMethod(PrintObj,"for a basis with basis vectors",[IsBasis and HasBasisVectors],COM_FUN(9));
InstallMethod(PrintObj,"for a basis",[IsBasis],COM_FUN(10));
InstallMethod(PrintObj,"for a semi-echelonized basis with basis vectors",[IsBasis and HasBasisVectors and IsSemiEchelonized],COM_FUN(11));
InstallMethod(PrintObj,"for a semi-echelonized basis",[IsBasis and IsSemiEchelonized],COM_FUN(12));
InstallMethod(PrintObj,"for a canonical basis",[IsBasis and IsCanonicalBasis],SUM_FLAGS,COM_FUN(13));
InstallMethod(ViewObj,"for a basis with basis vectors",[IsBasis and HasBasisVectors],COM_FUN(14));
InstallMethod(ViewObj,"for a basis",[IsBasis],COM_FUN(15));
InstallMethod(ViewObj,"for a semi-echelonized basis with basis vectors",[IsBasis and HasBasisVectors and IsSemiEchelonized],COM_FUN(16));
InstallMethod(ViewObj,"for a semi-echelonized basis",[IsBasis and IsSemiEchelonized],COM_FUN(17));
InstallMethod(ViewObj,"for a canonical basis",[IsBasis and IsCanonicalBasis],SUM_FLAGS,COM_FUN(18));
InstallImmediateMethod(Basis,IsFreeLeftModule and HasCanonicalBasis and IsAttributeStoringRep,0,CanonicalBasis);
InstallMethod(CanonicalBasis,"default method, return `fail'",[IsFreeLeftModule],ReturnFail);
InstallMethod(LinearCombination,"for a basis and a homogeneous list",[IsBasis,IsHomogeneousList],COM_FUN(19));
InstallOtherMethod(LinearCombination,"for two lists",[IsList,IsList],COM_FUN(20));
BindGlobal("ElementNumber_Basis",COM_FUN(21));
BindGlobal("NumberElement_Basis",COM_FUN(22));
InstallMethod(EnumeratorByBasis,"for basis of a finite dimensional left module",[IsBasis],COM_FUN(23));
BindGlobal("IsDoneIterator_Basis",COM_FUN(24));
BindGlobal("NextIterator_Basis",COM_FUN(25));
BindGlobal("ShallowCopy_Basis",COM_FUN(26));
InstallMethod(IteratorByBasis,"for basis of a finite dimensional left module",[IsBasis],COM_FUN(27));
InstallMethod(StructureConstantsTable,"for a basis",[IsBasis],COM_FUN(28));
InstallMethod(Coefficients,"for relative basis and vector",IsCollsElms,[IsBasis and IsRelativeBasisDefaultRep,IsVector],COM_FUN(29));
InstallMethod(Basis,"method returning a relative basis",IsIdenticalObj,[IsFreeLeftModule,IsHomogeneousList],COM_FUN(30));
InstallMethod(BasisNC,"method returning a relative basis",IsIdenticalObj,[IsFreeLeftModule,IsHomogeneousList],COM_FUN(31));
InstallGlobalFunction("InstallHandlingByNiceBasis",COM_FUN(32));
InstallGlobalFunction("CheckForHandlingByNiceBasis",COM_FUN(33));
InstallHandlingByNiceBasis("IsGenericFiniteSpace",rec(detect:=COM_FUN(34),NiceFreeLeftModuleInfo:=COM_FUN(35),NiceVector:=COM_FUN(36),UglyVector:=COM_FUN(37)));
InstallMethod(NiceFreeLeftModule,"for generic finite space (use that this is a full row module)",[IsFreeLeftModule and IsGenericFiniteSpace],COM_FUN(38));
InstallHandlingByNiceBasis("IsSpaceOfRationalFunctions",rec(detect:=COM_FUN(39),NiceFreeLeftModuleInfo:=COM_FUN(40),NiceVector:=COM_FUN(41),UglyVector:=COM_FUN(42)));
InstallMethod(NiceBasis,"for basis by nice basis",[IsBasisByNiceBasis],COM_FUN(43));
InstallMethod(NiceBasisNC,"for basis by nice basis",[IsBasisByNiceBasis],COM_FUN(44));
InstallMethod(BasisVectors,"for basis by nice basis",[IsBasisByNiceBasis],COM_FUN(45));
InstallMethod(Coefficients,"for basis handled by nice basis, and vector",IsCollsElms,[IsBasisByNiceBasis,IsVector],COM_FUN(46));
InstallMethod(CanonicalBasis,"for free module that is handled by a nice basis",[IsFreeLeftModule and IsHandledByNiceBasis],COM_FUN(47));
InstallMethod(IsCanonicalBasis,"for a basis handled by a nice basis",[IsBasisByNiceBasis],COM_FUN(48));
BasisForFreeModuleByNiceBasis:=COM_FUN(49);
InstallMethod(Basis,"for free module that is handled by a nice basis",[IsFreeLeftModule and IsHandledByNiceBasis],BasisForFreeModuleByNiceBasis);
InstallMethod(Basis,"for free module that is handled by a nice basis, and hom. list",IsIdenticalObj,[IsFreeLeftModule and IsHandledByNiceBasis,IsHomogeneousList],COM_FUN(50));
InstallMethod(BasisNC,"for free module that is handled by a nice basis, and hom. list",IsIdenticalObj,[IsFreeLeftModule and IsHandledByNiceBasis,IsHomogeneousList],COM_FUN(51));
InstallMethod(NiceFreeLeftModule,"for free module that is handled by a nice basis",[IsFreeLeftModule and HasGeneratorsOfLeftModule and IsHandledByNiceBasis],COM_FUN(52));
BindGlobal("NiceFreeLeftModuleForFLMLOR",COM_FUN(53));
InstallMethod(NiceFreeLeftModule,"for FLMLOR that is handled by a nice basis",[IsFLMLOR and IsHandledByNiceBasis],COM_FUN(54));
InstallMethod(NiceFreeLeftModule,"for associative FLMLOR that is handled by a nice basis",[IsFLMLOR and IsAssociative and IsHandledByNiceBasis],COM_FUN(55));
InstallMethod(NiceFreeLeftModule,"for anticommutative FLMLOR that is handled by a nice basis",[IsFLMLOR and IsAnticommutative and IsHandledByNiceBasis],COM_FUN(56));
InstallMethod(NiceFreeLeftModule,"for commutative FLMLOR that is handled by a nice basis",[IsFLMLOR and IsCommutative and IsHandledByNiceBasis],COM_FUN(57));
InstallMethod(\in,"for vector and free left module that is handled by a nice basis",IsElmsColls,[IsVector,IsFreeLeftModule and IsHandledByNiceBasis],COM_FUN(58));
InstallMethod(Basis,"for trivial free left module",[IsFreeLeftModule and IsTrivial],COM_FUN(59));
InstallMethod(Basis,"for free left module and empty list",[IsFreeLeftModule,IsList and IsEmpty],COM_FUN(60));
InstallMethod(BasisNC,"for free left module and empty list",[IsFreeLeftModule,IsList and IsEmpty],COM_FUN(61));
InstallMethod(SemiEchelonBasis,"for free left module and empty list",[IsFreeLeftModule,IsList and IsEmpty],COM_FUN(62));
InstallMethod(SemiEchelonBasisNC,"for free left module and empty list",[IsFreeLeftModule,IsList and IsEmpty],COM_FUN(63));
InstallMethod(BasisVectors,"for empty basis",[IsBasis and IsEmpty],SUM_FLAGS,COM_FUN(64));
InstallMethod(Coefficients,"for empty basis and vector",IsCollsElms,[IsBasis and IsEmpty,IsVector],SUM_FLAGS,COM_FUN(65));
InstallMethod(LinearCombination,"for empty basis and empty list",[IsBasis and IsEmpty,IsList and IsEmpty],SUM_FLAGS,COM_FUN(66));
InstallMethod(SiftedVector,"for empty basis and vector",IsCollsElms,[IsBasis and IsEmpty,IsVector],SUM_FLAGS,COM_FUN(67));
DeclareRepresentation("IsBasisWithReplacedLeftModuleRep",IsAttributeStoringRep,["basisWithWrongModule"]);
InstallGlobalFunction(BasisWithReplacedLeftModule,COM_FUN(68));
InstallMethod(BasisVectors,"for a basis with replaced left module",[IsBasis and IsBasisWithReplacedLeftModuleRep],COM_FUN(69));
InstallMethod(Coefficients,"for a basis with replaced left module, and a vector",IsCollsElms,[IsBasis and IsBasisWithReplacedLeftModuleRep,IsVector],COM_FUN(70));
InstallMethod(LinearCombination,"for a basis with replaced left module, and a hom. list",[IsBasis and IsBasisWithReplacedLeftModuleRep,IsHomogeneousList],COM_FUN(71));
InstallMethod(IsCanonicalBasis,"for a basis with replaced left module, and a vector",[IsBasis and IsBasisWithReplacedLeftModuleRep],COM_FUN(72));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/basis.gi"

#F  file="lib/basismut.gi" crc=103375615
RANK_FILTER_LIST  := [ 41269723, 1, 41269723, 1, 41269723, 1, 16776722, 23, 
  50997183, 26, 8126465, 2, 50997183, 26, 8193, 2, 1, 0, 66435487, 3, 
  66435487, 3, 66435487, 3, 66435488, 5, 63198130, 7, 66435487, 3, 63198130, 
  7, 66435487, 3, 24492372, 3, 24492372, 3, 24492372, 3, 24492372, 3, 
  24492373, 5, 63198130, 7, 24492372, 3, 63198130, 7, 24492372, 3 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/basismut.gi", 103375615 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/basismut.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/basismut.gi");
elif COM_RESULT = 3  then
Revision.basismut_gi:="@(#)$Id: basismut.gi,v 4.23 2003/07/04 15:26:23 gap Exp $";
InstallMethod(ShallowCopy,"generic method for mutable basis",true,[IsMutableBasis],0,COM_FUN(1));
InstallMethod(NrBasisVectors,"generic method for mutable basis",true,[IsMutableBasis],0,COM_FUN(2));
InstallMethod(ImmutableBasis,"for mutable basis, and free left module",IsIdenticalObj,[IsMutableBasis,IsFreeLeftModule],0,COM_FUN(3));
DeclareRepresentation("IsMutableBasisByImmutableBasisRep",IsComponentObjectRep,["immutableBasis","leftActingDomain"]);
InstallMethod(MutableBasis,"generic method for ring and collection",true,[IsRing,IsCollection],0,COM_FUN(4));
InstallOtherMethod(MutableBasis,"generic method for ring, list, and object",true,[IsRing,IsList,IsObject],0,COM_FUN(5));
InstallMethod(ViewObj,"for mutable basis represented by an immutable basis",true,[IsMutableBasis and IsMutableBasisByImmutableBasisRep],0,COM_FUN(6));
InstallMethod(PrintObj,"for mutable basis represented by an immutable basis",true,[IsMutableBasis and IsMutableBasisByImmutableBasisRep],0,COM_FUN(7));
InstallOtherMethod(BasisVectors,"for mutable basis represented by an immutable basis",true,[IsMutableBasis and IsMutableBasisByImmutableBasisRep],0,COM_FUN(8));
InstallMethod(CloseMutableBasis,"for mutable basis represented by an immutable basis, and vector",IsCollsElms,[IsMutableBasis and IsMutable and IsMutableBasisByImmutableBasisRep,IsVector],0,COM_FUN(9));
InstallMethod(IsContainedInSpan,"for mutable basis represented by an immutable basis, and vector",IsCollsElms,[IsMutableBasis and IsMutableBasisByImmutableBasisRep,IsVector],0,COM_FUN(10));
InstallMethod(ImmutableBasis,"for mutable basis represented by an immutable basis",true,[IsMutableBasis and IsMutableBasisByImmutableBasisRep],0,COM_FUN(11));
DeclareRepresentation("IsMutableBasisViaNiceMutableBasisRep",IsComponentObjectRep,["leftModule","niceMutableBasis","zero"]);
InstallGlobalFunction(MutableBasisViaNiceMutableBasisMethod2,COM_FUN(12));
InstallGlobalFunction(MutableBasisViaNiceMutableBasisMethod3,COM_FUN(13));
InstallMethod(ViewObj,"for mutable basis represented by a nice mutable basis",true,[IsMutableBasis and IsMutableBasisViaNiceMutableBasisRep],0,COM_FUN(14));
InstallMethod(PrintObj,"for mutable basis represented by a nice mutable basis",true,[IsMutableBasis and IsMutableBasisViaNiceMutableBasisRep],0,COM_FUN(15));
InstallOtherMethod(BasisVectors,"for mutable basis represented by a nice mutable basis",true,[IsMutableBasis and IsMutableBasisViaNiceMutableBasisRep],0,COM_FUN(16));
InstallMethod(NrBasisVectors,"for mutable basis represented by a nice mutable basis",true,[IsMutableBasis and IsMutableBasisViaNiceMutableBasisRep],0,COM_FUN(17));
InstallMethod(CloseMutableBasis,"for mutable basis repres. by a nice mutable basis, and vector",IsCollsElms,[IsMutableBasis and IsMutable and IsMutableBasisViaNiceMutableBasisRep,IsVector],0,COM_FUN(18));
InstallMethod(IsContainedInSpan,"for mutable basis repres. by a nice mutable basis, and vector",IsCollsElms,[IsMutableBasis and IsMutableBasisViaNiceMutableBasisRep,IsVector],0,COM_FUN(19));
InstallMethod(ImmutableBasis,"for mutable basis represented by a nice mutable basis",true,[IsMutableBasis and IsMutableBasisViaNiceMutableBasisRep],0,COM_FUN(20));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/basismut.gi"

#F  file="lib/vspc.gi" crc=-108732929
RANK_FILTER_LIST  := [ 46137587, 9, 1, 0, 52780217, 7, 56482656, 25, 8126465, 
  2, 40033072, 46, 56482656, 25, 64308345, 26, 6201250, 26, 56482656, 25, 
  64308345, 26, 56482656, 25, 56482656, 25, 8126465, 2, 56482656, 25, 
  56482656, 25, 56482656, 25, 56482656, 25, 6150903, 26, 63198130, 7, 
  57570105, 10, 57570105, 10, 57570105, 10, 57570105, 10, 56482656, 25, 17, 
  18, 56482656, 25, 63580652, 7 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/vspc.gi", -108732929 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/vspc.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/vspc.gi");
elif COM_RESULT = 3  then
Revision.vspc_gi:="@(#)$Id: vspc.gi,v 4.43.2.4 2005/11/29 15:44:32 gap Exp $";
InstallOtherMethod(SetLeftActingDomain,"method to set also 'IsLeftActedOnByDivisionRing'",[IsAttributeStoringRep and IsLeftActedOnByRing,IsObject],0,COM_FUN(1));
InstallMethod(IsLeftActedOnByDivisionRing,"method for external left set that is left acted on by a ring",[IsExtLSet and IsLeftActedOnByRing],COM_FUN(2));
InstallGlobalFunction(VectorSpace,COM_FUN(3));
InstallMethod(AsSubspace,"for a vector space and a collection",[IsVectorSpace,IsCollection],COM_FUN(4));
InstallMethod(AsLeftModule,"method for a division ring and a vector space",[IsDivisionRing,IsVectorSpace],COM_FUN(5));
InstallMethod(ViewObj,"for vector space with known generators",[IsVectorSpace and HasGeneratorsOfLeftModule],COM_FUN(6));
InstallMethod(ViewObj,"for vector space with known dimension",[IsVectorSpace and HasDimension],1,COM_FUN(7));
InstallMethod(ViewObj,"for vector space",[IsVectorSpace],COM_FUN(8));
InstallMethod(PrintObj,"method for vector space with left module generators",[IsVectorSpace and HasGeneratorsOfLeftModule],COM_FUN(9));
InstallMethod(PrintObj,"method for vector space",[IsVectorSpace],COM_FUN(10));
InstallOtherMethod(\/,"method for vector space and collection",IsIdenticalObj,[IsVectorSpace,IsCollection],COM_FUN(11));
InstallOtherMethod(\/,"generic method for two vector spaces",IsIdenticalObj,[IsVectorSpace,IsVectorSpace],COM_FUN(12));
InstallGlobalFunction(Intersection2Spaces,COM_FUN(13));
InstallMethod(Intersection2,"method for two vector spaces",IsIdenticalObj,[IsVectorSpace,IsVectorSpace],Intersection2Spaces(AsLeftModule,SubspaceNC,VectorSpace));
InstallMethod(ClosureLeftModule,"method for a vector space with basis, and a vector",IsCollsElms,[IsVectorSpace and HasBasis,IsVector],COM_FUN(14));
DeclareRepresentation("IsSubspacesVectorSpaceDefaultRep",IsComponentObjectRep,["dimension","structure"]);
InstallMethod(PrintObj,"method for a subspaces domain",[IsSubspacesVectorSpace and IsSubspacesVectorSpaceDefaultRep],COM_FUN(15));
InstallMethod(Size,"method for a subspaces domain",[IsSubspacesVectorSpace and IsSubspacesVectorSpaceDefaultRep],COM_FUN(16));
InstallMethod(Enumerator,"method for a subspaces domain",[IsSubspacesVectorSpace and IsSubspacesVectorSpaceDefaultRep],COM_FUN(17));
BindGlobal("IsDoneIterator_Subspaces",COM_FUN(18));
BindGlobal("NextIterator_Subspaces",COM_FUN(19));
BindGlobal("ShallowCopy_Subspaces",COM_FUN(20));
InstallMethod(Iterator,"for a subspaces domain",[IsSubspacesVectorSpace and IsSubspacesVectorSpaceDefaultRep],COM_FUN(21));
InstallMethod(Subspaces,"for a vector space, and an integer",[IsVectorSpace,IsInt],COM_FUN(22));
InstallMethod(Subspaces,"for a vector space",[IsVectorSpace],COM_FUN(23));
InstallGlobalFunction(IsSubspace,COM_FUN(24));
InstallMethod(IsVectorSpaceHomomorphism,[IsGeneralMapping],COM_FUN(25));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/vspc.gi"

#F  file="lib/vspcrow.gi" crc=-53052491
RANK_FILTER_LIST  := [ 40033072, 46, 58412696, 30, 40033072, 46, 41951068, 
  17, 65077940, 12, 40033072, 46, 58412696, 30, 65077940, 12, 11390103, 27, 
  11390103, 27, 1, 0, 11390103, 27, 1, 0, 62163362, 15, 65077940, 12, 
  62163362, 15, 65077940, 12, 62163362, 15, 65077940, 12, 62163887, 7, 
  16173166, 29, 58412696, 30, 16173166, 29, 58412696, 30, 65077940, 12, 
  31603731, 30, 31603731, 30, 31603731, 30, 58412696, 30, 31603731, 30, 
  58412696, 30, 62465853, 33, 31603731, 30, 31603731, 30, 58412696, 30, 
  31603731, 30, 58412696, 30, 62163362, 15, 16173166, 29, 65077940, 12, 
  40033072, 46, 58412696, 30, 31603731, 30, 31603731, 30, 31603731, 30, 
  31603731, 30, 31603731, 30, 65157983, 31, 31603731, 30, 31603731, 30, 
  51096037, 29, 48094768, 22, 22930668, 51, 24015838, 11, 22930668, 51, 17, 
  18, 22930668, 51, 67108760, 5, 22930668, 51, 50997183, 26, 58412696, 30, 
  50997183, 26, 8193, 2, 65077940, 12, 41269543, 3, 41269543, 3, 41269543, 3, 
  41269544, 5, 65077940, 12, 41269543, 3, 65077940, 12, 41269543, 3, 
  41269543, 3, 65077940, 12, 59219357, 23, 31603731, 30 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/vspcrow.gi", -53052491 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/vspcrow.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/vspcrow.gi");
elif COM_RESULT = 3  then
Revision.vspcrow_gi:="@(#)$Id: vspcrow.gi,v 4.91.2.3 2005/11/26 06:59:01 gap Exp $";
InstallMethod(LeftModuleByGenerators,"for division ring and matrix over it",IsElmsColls,[IsDivisionRing,IsMatrix],COM_FUN(1));
InstallMethod(LeftModuleByGenerators,"for division ring, empty list, and row vector",[IsDivisionRing,IsList and IsEmpty,IsRowVector],COM_FUN(2));
InstallMethod(LeftModuleByGenerators,"for division ring, matrix over it, and row vector",[IsDivisionRing,IsMatrix,IsRowVector],COM_FUN(3));
InstallHandlingByNiceBasis("IsNonGaussianRowSpace",rec(detect:=COM_FUN(4),NiceFreeLeftModuleInfo:=COM_FUN(5),NiceVector:=COM_FUN(6),UglyVector:=COM_FUN(7)));
DeclareRepresentation("IsSemiEchelonBasisOfGaussianRowSpaceRep",IsAttributeStoringRep,["heads"]);
InstallTrueMethod(IsSmallList,IsList and IsSemiEchelonBasisOfGaussianRowSpaceRep);
InstallMethod(LinearCombination,IsCollsElms,[IsBasis and IsSemiEchelonBasisOfGaussianRowSpaceRep,IsRowVector],COM_FUN(8));
InstallMethod(Coefficients,"for semi-ech. basis of a Gaussian row space, and a row vector",IsCollsElms,[IsBasis and IsSemiEchelonBasisOfGaussianRowSpaceRep,IsRowVector],COM_FUN(9));
BindGlobal("SiftedVectorForGaussianRowSpace",COM_FUN(10));
InstallMethod(SiftedVector,"for semi-ech. basis of Gaussian row space, and row vector",IsCollsElms,[IsBasis and IsSemiEchelonBasisOfGaussianRowSpaceRep,IsRowVector],COM_FUN(11));
HeadsInfoOfSemiEchelonizedMat:=COM_FUN(12);
InstallMethod(IsSemiEchelonized,"for basis of a Gaussian row space",[IsBasis],COM_FUN(13));
InstallOtherMethod(\*,IsIdenticalObj,[IsRowSpace,IsMatrix],COM_FUN(14));
InstallOtherMethod(\^,IsIdenticalObj,[IsRowSpace,IsMatrix],COM_FUN(15));
InstallMethod(\in,"for row vector and Gaussian row space",IsElmsColls,[IsRowVector,IsGaussianRowSpace],COM_FUN(16));
InstallMethod(Basis,"for Gaussian row space (construct a semi-echelonized basis)",[IsGaussianRowSpace],SemiEchelonBasis);
InstallMethod(Basis,"for Gaussian row space and matrix (try semi-echelonized)",IsIdenticalObj,[IsGaussianRowSpace,IsMatrix],COM_FUN(17));
InstallMethod(BasisNC,"for Gaussian row space and matrix (try semi-echelonized)",IsIdenticalObj,[IsGaussianRowSpace,IsMatrix],COM_FUN(18));
InstallImmediateMethod(SemiEchelonBasis,IsGaussianRowSpace and HasCanonicalBasis and IsAttributeStoringRep,20,CanonicalBasis);
InstallMethod(SemiEchelonBasis,"for Gaussian row space",[IsGaussianRowSpace],COM_FUN(19));
InstallMethod(SemiEchelonBasis,"for Gaussian row space and matrix",IsIdenticalObj,[IsGaussianRowSpace,IsMatrix],COM_FUN(20));
InstallMethod(SemiEchelonBasisNC,"for Gaussian row space and matrix",IsIdenticalObj,[IsGaussianRowSpace,IsMatrix],COM_FUN(21));
InstallMethod(BasisVectors,"for semi-ech. basis of a Gaussian row space",[IsBasis and IsSemiEchelonBasisOfGaussianRowSpaceRep],COM_FUN(22));
InstallOtherMethod(Zero,"for a row space",[IsRowSpace],COM_FUN(23));
InstallMethod(IsZero,"for row vector",[IsRowVector],COM_FUN(24));
InstallMethod(AsLeftModule,"for division ring and matrix",IsElmsColls,[IsDivisionRing,IsMatrix],COM_FUN(25));
InstallOtherMethod(\+,"for two Gaussian row spaces",IsIdenticalObj,[IsGaussianRowSpace,IsGaussianRowSpace],COM_FUN(26));
InstallMethod(Intersection2,"for two Gaussian row spaces",IsIdenticalObj,[IsGaussianRowSpace,IsGaussianRowSpace],COM_FUN(27));
InstallMethod(NormedRowVectors,"for Gaussian row space",[IsGaussianRowSpace],COM_FUN(28));
InstallMethod(CanonicalBasis,"for Gaussian row space with known semi-ech. basis",[IsGaussianRowSpace and HasSemiEchelonBasis],COM_FUN(29));
InstallMethod(CanonicalBasis,"for Gaussian row space",[IsGaussianRowSpace],COM_FUN(30));
InstallMethod(IsFullRowModule,"for Gaussian row space",[IsGaussianRowSpace],COM_FUN(31));
InstallMethod(IsFullRowModule,"for non-Gaussian row space",[IsVectorSpace and IsNonGaussianRowSpace],ReturnFalse);
InstallOtherMethod(IsFullRowModule,"for arbitrary free left module",[IsLeftModule],COM_FUN(32));
InstallMethod(CanonicalBasis,"for a full row space",[IsFullRowModule and IsVectorSpace],COM_FUN(33));
DeclareRepresentation("IsSubspacesFullRowSpaceDefaultRep",IsSubspacesVectorSpaceDefaultRep,[]);
BindGlobal("IsDoneIterator_SubspacesDim",COM_FUN(34));
BindGlobal("NextIterator_SubspacesDim",COM_FUN(35));
BindGlobal("ShallowCopy_SubspacesDim",COM_FUN(36));
BindGlobal("IsDoneIterator_SubspacesAll",COM_FUN(37));
BindGlobal("NextIterator_SubspacesAll",COM_FUN(38));
BindGlobal("ShallowCopy_SubspacesAll",COM_FUN(39));
InstallMethod(Iterator,"for subspaces collection of a (finite) full row module",[IsSubspacesVectorSpace and IsSubspacesFullRowSpaceDefaultRep],COM_FUN(40));
InstallMethod(Subspaces,"for (Gaussian) full row space",[IsFullRowModule and IsVectorSpace,IsInt],COM_FUN(41));
InstallOtherMethod(Subspaces,"for (Gaussian) full row space",[IsFullRowModule and IsVectorSpace,IsString],COM_FUN(42));
InstallMethod(Subspaces,[IsFullRowModule and IsVectorSpace],COM_FUN(43));
DeclareRepresentation("IsMutableBasisOfGaussianRowSpaceRep",IsComponentObjectRep,["heads","basisVectors","leftActingDomain","zero"]);
InstallMethod(MutableBasis,"method to construct mutable bases of row spaces",IsElmsColls,[IsRing,IsMatrix],COM_FUN(44));
InstallOtherMethod(MutableBasis,"method to construct mutable bases of row spaces",IsIdenticalObjObjXObj,[IsRing,IsList,IsRowVector],COM_FUN(45));
InstallMethod(ViewObj,"for a mutable basis of a Gaussian row space",[IsMutableBasis and IsMutableBasisOfGaussianRowSpaceRep],COM_FUN(46));
InstallMethod(PrintObj,"for a mutable basis of a Gaussian row space",[IsMutableBasis and IsMutableBasisOfGaussianRowSpaceRep],COM_FUN(47));
InstallOtherMethod(BasisVectors,"for a mutable basis of a Gaussian row space",[IsMutableBasis and IsMutableBasisOfGaussianRowSpaceRep],COM_FUN(48));
InstallMethod(CloseMutableBasis,"for a mut. basis of a Gaussian row space, and a row vector",IsCollsElms,[IsMutableBasis and IsMutable and IsMutableBasisOfGaussianRowSpaceRep,IsRowVector],COM_FUN(49));
InstallMethod(IsContainedInSpan,"for a mut. basis of a Gaussian row space, and a row vector",IsCollsElms,[IsMutableBasis and IsMutableBasisOfGaussianRowSpaceRep,IsRowVector],COM_FUN(50));
InstallMethod(ImmutableBasis,"for a mutable basis of a Gaussian row space",[IsMutableBasis and IsMutableBasisOfGaussianRowSpaceRep],COM_FUN(51));
InstallOtherMethod(SiftedVector,"for mutable basis of Gaussian row space, and row vector",IsCollsElms,[IsMutableBasis and IsMutableBasisOfGaussianRowSpaceRep,IsRowVector],COM_FUN(52));
InstallGlobalFunction(OnLines,COM_FUN(53));
InstallMethod(NormedRowVector,"for a row vector of scalars",[IsRowVector and IsScalarCollection],COM_FUN(54));
BindGlobal("ElementNumber_ExtendedVectors",COM_FUN(55));
BindGlobal("NumberElement_ExtendedVectors",COM_FUN(56));
BindGlobal("NumberElement_ExtendedVectorsFF",COM_FUN(57));
BindGlobal("Length_ExtendedVectors",COM_FUN(58));
BindGlobal("PrintObj_ExtendedVectors",COM_FUN(59));
BindGlobal("ExtendedVectors",COM_FUN(60));
BindGlobal("ElementNumber_NormedRowVectors",COM_FUN(61));
BindGlobal("NumberElement_NormedRowVectors",COM_FUN(62));
BindGlobal("Length_NormedRowVectors",COM_FUN(63));
BindGlobal("PrintObj_NormedRowVectors",COM_FUN(64));
BindGlobal("EnumeratorOfNormedRowVectors",COM_FUN(65));
InstallMethod(OrthogonalSpaceInFullRowSpace,"dual space for Gaussian row space",[IsGaussianRowSpace],COM_FUN(66));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/vspcrow.gi"

#F  file="lib/vspcmat.gi" crc=3570240
RANK_FILTER_LIST  := [ 6003484, 27, 6003484, 27, 1, 0, 6003484, 27, 1, 0, 
  62163527, 15, 58412696, 30, 62163527, 15, 58412696, 30, 62163887, 7, 
  44893019, 30, 44893019, 30, 32769, 4, 44893019, 30, 32769, 4, 8646262, 33, 
  44893019, 30, 44893019, 30, 32769, 4, 44893019, 30, 32769, 4, 62163527, 15, 
  29462454, 29, 44893019, 30, 44893019, 30, 45709418, 29, 48094768, 22, 
  16794739, 48, 50997183, 26, 8126465, 2, 40033072, 46, 67108070, 16, 
  50997183, 26, 32769, 4, 58412696, 30, 41269003, 3, 41269003, 3, 41269003, 
  3, 41269004, 5, 58412696, 30, 41269003, 3, 58412696, 30, 41269003, 3, 
  58412696, 30, 41269003, 3 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/vspcmat.gi", 3570240 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/vspcmat.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/vspcmat.gi");
elif COM_RESULT = 3  then
Revision.vspcmat_gi:="@(#)$Id: vspcmat.gi,v 4.37 2002/08/23 14:35:10 gap Exp $";
InstallHandlingByNiceBasis("IsNonGaussianMatrixSpace",rec(detect:=COM_FUN(1),NiceFreeLeftModuleInfo:=ReturnFalse,NiceVector:=COM_FUN(2),UglyVector:=COM_FUN(3)));
DeclareRepresentation("IsSemiEchelonBasisOfGaussianMatrixSpaceRep",IsAttributeStoringRep,["heads"]);
InstallTrueMethod(IsSmallList,IsList and IsSemiEchelonBasisOfGaussianMatrixSpaceRep);
InstallMethod(Coefficients,"for semi-ech. basis of a Gaussian matrix space, and a matrix",IsCollsElms,[IsBasis and IsSemiEchelonBasisOfGaussianMatrixSpaceRep,IsMatrix],COM_FUN(4));
BindGlobal("SiftedVectorForGaussianMatrixSpace",COM_FUN(5));
InstallMethod(SiftedVector,"for semi-ech. basis of Gaussian matrix space, and matrix",IsCollsElms,[IsBasis and IsSemiEchelonBasisOfGaussianMatrixSpaceRep,IsMatrix],COM_FUN(6));
BindGlobal("HeadsInfoOfSemiEchelonizedMats",COM_FUN(7));
InstallMethod(IsSemiEchelonized,"for basis (of a Gaussian matrix space)",[IsBasis],COM_FUN(8));
InstallMethod(Basis,"for Gaussian matrix space (construct a semi-echelonized basis)",[IsGaussianMatrixSpace],SemiEchelonBasis);
InstallMethod(Basis,"for Gaussian matrix space and list of matrices (try semi-ech.)",IsIdenticalObj,[IsGaussianMatrixSpace,IsHomogeneousList],COM_FUN(9));
InstallMethod(BasisNC,"for Gaussian matrix space and list of matrices (try semi-ech.)",IsIdenticalObj,[IsGaussianMatrixSpace,IsHomogeneousList],COM_FUN(10));
InstallImmediateMethod(SemiEchelonBasis,IsGaussianMatrixSpace and HasCanonicalBasis and IsAttributeStoringRep,20,CanonicalBasis);
InstallMethod(SemiEchelonBasis,"for Gaussian matrix space",[IsGaussianMatrixSpace],COM_FUN(11));
InstallMethod(SemiEchelonBasis,"for Gaussian matrix space and list of matrices",IsIdenticalObj,[IsGaussianMatrixSpace,IsHomogeneousList],COM_FUN(12));
InstallMethod(SemiEchelonBasisNC,"for Gaussian matrix space and list of matrices",IsIdenticalObj,[IsGaussianMatrixSpace,IsHomogeneousList],COM_FUN(13));
InstallMethod(BasisVectors,"for semi-ech. basis of a Gaussian matrix space",[IsBasis and IsSemiEchelonBasisOfGaussianMatrixSpaceRep],COM_FUN(14));
InstallOtherMethod(Zero,"for a matrix space",[IsMatrixSpace],COM_FUN(15));
InstallMethod(CanonicalBasis,"for Gaussian matrix space",[IsGaussianMatrixSpace],COM_FUN(16));
InstallMethod(IsFullMatrixModule,"for Gaussian matrix space",[IsGaussianMatrixSpace],COM_FUN(17));
InstallMethod(IsFullMatrixModule,"for non-Gaussian matrix space",[IsVectorSpace and IsNonGaussianMatrixSpace],ReturnFalse);
InstallOtherMethod(IsFullMatrixModule,"for arbitrary free left module",[IsLeftModule],COM_FUN(18));
InstallMethod(CanonicalBasis,"for full matrix space",[IsFullMatrixModule],COM_FUN(19));
DeclareRepresentation("IsMutableBasisOfGaussianMatrixSpaceRep",IsComponentObjectRep,["heads","basisVectors","leftActingDomain","zero"]);
InstallMethod(MutableBasis,"to construct mutable bases of Gaussian matrix spaces",IsElmsCollColls,[IsRing,IsCollection],COM_FUN(20));
InstallMethod(MutableBasis,"to construct a mutable basis of a Lie matrix space",IsElmsCollLieColls,[IsDivisionRing,IsLieObjectCollection],COM_FUN(21));
InstallOtherMethod(MutableBasis,"to construct mutable bases of matrix spaces",COM_FUN(22),[IsRing,IsHomogeneousList,IsMatrix],COM_FUN(23));
InstallMethod(ViewObj,"for a mutable basis of a Gaussian matrix space",[IsMutableBasis and IsMutableBasisOfGaussianMatrixSpaceRep],COM_FUN(24));
InstallMethod(PrintObj,"for a mutable basis of a Gaussian matrix space",[IsMutableBasis and IsMutableBasisOfGaussianMatrixSpaceRep],COM_FUN(25));
InstallOtherMethod(BasisVectors,"for a mutable basis of a Gaussian matrix space",[IsMutableBasis and IsMutableBasisOfGaussianMatrixSpaceRep],COM_FUN(26));
InstallMethod(CloseMutableBasis,"for a mut. basis of a Gaussian matrix space, and a matrix",IsCollsElms,[IsMutableBasis and IsMutable and IsMutableBasisOfGaussianMatrixSpaceRep,IsMatrix],COM_FUN(27));
InstallMethod(IsContainedInSpan,"for a mut. basis of a Gaussian matrix space, and a matrix",IsCollsElms,[IsMutableBasis and IsMutableBasisOfGaussianMatrixSpaceRep,IsMatrix],COM_FUN(28));
InstallOtherMethod(SiftedVector,"for mutable basis of Gaussian matrix space, and matrix",IsCollsElms,[IsMutableBasis and IsMutableBasisOfGaussianMatrixSpaceRep,IsMatrix],COM_FUN(29));
InstallMethod(ImmutableBasis,"for a mutable basis of a Gaussian matrix space",[IsMutableBasis and IsMutableBasisOfGaussianMatrixSpaceRep],COM_FUN(30));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/vspcmat.gi"

#F  file="lib/vspchom.gi" crc=-94587569
RANK_FILTER_LIST  := [ 16776722, 23, 16776722, 23, 32769, 4, 32769, 4, 
  16776722, 23, 16776722, 23, 8193, 2, 8193, 2, 39194456, 23, 63580172, 23, 
  63580172, 23, 63580172, 23, 63580172, 23, 63580172, 23, 63580172, 23, 
  63580172, 23, 1, 0, 63580172, 23, 1, 0, 63580172, 23, 63580172, 23, 
  54568462, 27, 32505602, 3, 63580172, 23, 63580172, 23, 30183226, 19, 
  39194456, 23, 63580172, 23, 63580652, 7, 63580652, 7, 63580172, 23, 
  54568462, 27, 54568942, 11, 54568942, 11, 54568462, 27, 62163887, 7, 
  58412696, 30, 62163887, 7, 60565280, 23, 60565280, 23, 60565280, 23, 1, 0, 
  60565280, 23, 1, 0, 60565280, 23, 60565280, 23, 16776722, 23, 50330464, 30, 
  16776722, 23, 16776722, 23, 32505602, 3, 60565280, 23, 60565280, 23, 
  30183226, 19, 27167854, 27, 51553570, 27, 54568942, 11, 54568942, 11, 
  51553570, 27, 51553570, 27, 54568462, 27, 54568462, 27, 51553570, 27, 
  47840096, 29, 47840096, 29, 1, 0, 47840096, 29, 1, 0, 38883056, 11, 
  38883056, 11, 38883056, 11, 55659777, 32, 36318390, 34, 36318390, 34, 
  36318390, 34, 36318390, 34, 36318390, 34, 36318390, 34, 36318390, 34, 
  63580652, 7, 36318390, 34, 62163887, 7, 51907218, 9, 51907218, 9, 63580652, 
  7, 51907218, 9, 51553570, 27, 64544214, 25, 40033072, 46, 16776722, 23, 
  16776722, 23, 40033072, 46, 16776722, 23 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/vspchom.gi", -94587569 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/vspchom.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/vspchom.gi");
elif COM_RESULT = 3  then
Revision.vspchom_gi:="@(#)$Id: vspchom.gi,v 4.38.4.3 2007/08/30 08:10:50 gap Exp $";
DeclareRepresentation("IsLinearGeneralMappingByImagesDefaultRep",IsAttributeStoringRep,["basisimage","preimagesbasisimage","corelations","basispreimage","imagesbasispreimage","relations","generators","genimages"]);
InstallTrueMethod(IsAdditiveElementWithInverse,IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep);
InstallTrueMethod(IsLeftModuleGeneralMapping,IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep);
InstallMethod(LeftModuleGeneralMappingByImages,"for two free left modules and two homogeneous lists",[IsFreeLeftModule,IsFreeLeftModule,IsHomogeneousList,IsHomogeneousList],COM_FUN(1));
InstallMethod(LeftModuleHomomorphismByImagesNC,"for two left modules and two lists",[IsFreeLeftModule,IsFreeLeftModule,IsList,IsList],COM_FUN(2));
InstallGlobalFunction(LeftModuleHomomorphismByImages,COM_FUN(3));
InstallMethod(AsLeftModuleGeneralMappingByImages,"for a linear g.m.b.i.",[IsLeftModuleGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep],IdFunc);
InstallMethod(ImagesSource,"for a linear g.m.b.i.",[IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep],COM_FUN(4));
InstallMethod(PreImagesRange,"for a linear g.m.b.i.",[IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep],COM_FUN(5));
BindGlobal("MakeImagesInfoLinearGeneralMappingByImages",COM_FUN(6));
BindGlobal("MakePreImagesInfoLinearGeneralMappingByImages",COM_FUN(7));
InstallMethod(CoKernelOfAdditiveGeneralMapping,"for left module g.m.b.i.",[IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep],COM_FUN(8));
InstallMethod(IsSingleValued,"for left module g.m.b.i.",[IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep],COM_FUN(9));
InstallMethod(KernelOfAdditiveGeneralMapping,"for left module g.m.b.i.",[IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep],COM_FUN(10));
InstallMethod(IsInjective,"for left module g.m.b.i.",[IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep],COM_FUN(11));
InstallMethod(ImagesRepresentative,"for left module g.m.b.i., and element",FamSourceEqFamElm,[IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep,IsObject],COM_FUN(12));
InstallMethod(PreImagesRepresentative,"for left module g.m.b.i., and element",FamRangeEqFamElm,[IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep,IsObject],COM_FUN(13));
InstallMethod(ViewObj,"for a left module g.m.b.i",[IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep],COM_FUN(14));
InstallMethod(PrintObj,"for a left module g.m.b.i",[IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep],COM_FUN(15));
InstallMethod(PrintObj,"for a left module hom. b.i",[IsMapping and IsLinearGeneralMappingByImagesDefaultRep],COM_FUN(16));
InstallMethod(\*,"for scalar and linear g.m.b.i.",[IsMultiplicativeElement,IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep],COM_FUN(17));
InstallMethod(AdditiveInverseOp,"for linear g.m.b.i.",[IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep],COM_FUN(18));
InstallMethod(CompositionMapping2,"for left module hom. and linear g.m.b.i.",FamSource1EqFamRange2,[IsLeftModuleHomomorphism,IsLeftModuleGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep],COM_FUN(19));
InstallOtherMethod(\+,"for linear g.m.b.i. and general mapping",IsIdenticalObj,[IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep,IsGeneralMapping],COM_FUN(20));
InstallOtherMethod(\+,"for general mapping and linear g.m.b.i.",IsIdenticalObj,[IsGeneralMapping,IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep],COM_FUN(21));
InstallOtherMethod(\+,"for linear m.b.i. and mapping",IsIdenticalObj,[IsMapping and IsLinearGeneralMappingByImagesDefaultRep,IsMapping],COM_FUN(22));
InstallOtherMethod(\+,"for mapping and linear m.b.i.",IsIdenticalObj,[IsMapping,IsMapping and IsLinearGeneralMappingByImagesDefaultRep],COM_FUN(23));
DeclareRepresentation("IsLinearMappingByMatrixDefaultRep",IsAttributeStoringRep,["basissource","basisrange","matrix","basisimage","preimagesbasisimage","relations"]);
InstallTrueMethod(IsAdditiveElementWithInverse,IsGeneralMapping and IsLinearMappingByMatrixDefaultRep);
InstallTrueMethod(IsLeftModuleGeneralMapping,IsGeneralMapping and IsLinearMappingByMatrixDefaultRep);
InstallMethod(LeftModuleHomomorphismByMatrix,"for two bases of free left modules and a matrix",[IsBasis,IsMatrix,IsBasis],COM_FUN(24));
BindGlobal("MakePreImagesInfoLinearMappingByMatrix",COM_FUN(25));
InstallMethod(KernelOfAdditiveGeneralMapping,"for left module m.b.m.",[IsGeneralMapping and IsLinearMappingByMatrixDefaultRep],COM_FUN(26));
InstallMethod(IsInjective,"for left module m.b.m.",[IsGeneralMapping and IsLinearMappingByMatrixDefaultRep],COM_FUN(27));
InstallMethod(ImagesRepresentative,"for left module m.b.m., and element",FamSourceEqFamElm,[IsGeneralMapping and IsLinearMappingByMatrixDefaultRep,IsObject],COM_FUN(28));
InstallMethod(PreImagesRepresentative,"for left module m.b.m., and element",FamRangeEqFamElm,[IsGeneralMapping and IsLinearMappingByMatrixDefaultRep,IsObject],COM_FUN(29));
InstallMethod(ViewObj,"for a left module m.b.m.",[IsGeneralMapping and IsLinearMappingByMatrixDefaultRep],COM_FUN(30));
InstallMethod(PrintObj,"for a left module m.b.m.",[IsGeneralMapping and IsLinearMappingByMatrixDefaultRep],COM_FUN(31));
InstallMethod(NaturalHomomorphismBySubspace,"for left module and trivial left module",IsIdenticalObj,[IsFreeLeftModule,IsFreeLeftModule and IsTrivial],SUM_FLAGS,COM_FUN(32));
InstallGlobalFunction(NaturalHomomorphismBySubspaceOntoFullRowSpace,COM_FUN(33));
InstallMethod(NaturalHomomorphismBySubspace,"for two finite dimensional free left modules",IsIdenticalObj,[IsFreeLeftModule,IsFreeLeftModule],NaturalHomomorphismBySubspaceOntoFullRowSpace);
InstallMethod(\*,"for scalar and linear m.b.m.",[IsMultiplicativeElement,IsGeneralMapping and IsLinearMappingByMatrixDefaultRep],COM_FUN(34));
InstallMethod(AdditiveInverseOp,"for linear m.b.m.",[IsGeneralMapping and IsLinearMappingByMatrixDefaultRep],COM_FUN(35));
InstallMethod(CompositionMapping2,"for left module hom. and linear m.b.m.",FamSource1EqFamRange2,[IsLeftModuleHomomorphism,IsLeftModuleHomomorphism and IsLinearMappingByMatrixDefaultRep],COM_FUN(36));
BindGlobal("SumOfMBMAndMapping",COM_FUN(37));
BindGlobal("SumOfMappingAndMBM",COM_FUN(38));
InstallOtherMethod(\+,"for linear m.b.m. and mapping",IsIdenticalObj,[IsMapping and IsLinearMappingByMatrixDefaultRep,IsMapping],SumOfMBMAndMapping);
InstallOtherMethod(\+,"for mapping and linear m.b.m.",IsIdenticalObj,[IsMapping,IsMapping and IsLinearMappingByMatrixDefaultRep],SumOfMappingAndMBM);
InstallMethod(\+,"for linear m.b.m. and linear m.b.i.",IsIdenticalObj,[IsMapping and IsLinearMappingByMatrixDefaultRep,IsMapping and IsLinearGeneralMappingByImagesDefaultRep],SumOfMBMAndMapping);
InstallMethod(\+,"for linear m.b.i. and linear m.b.m.",IsIdenticalObj,[IsMapping and IsLinearGeneralMappingByImagesDefaultRep,IsMapping and IsLinearMappingByMatrixDefaultRep],SumOfMappingAndMBM);
InstallHandlingByNiceBasis("IsLinearMappingsModule",rec(detect:=COM_FUN(39),NiceFreeLeftModuleInfo:=COM_FUN(40),NiceVector:=COM_FUN(41),UglyVector:=COM_FUN(42)));
InstallOtherMethod(RingByGenerators,"for a list of linear mappings of finite vector spaces",[IsGeneralMappingCollection],COM_FUN(43));
InstallOtherMethod(DefaultRingByGenerators,"for a list of linear mappings of vector spaces",[IsGeneralMappingCollection],COM_FUN(44));
InstallOtherMethod(RingWithOneByGenerators,"for a list of linear mappings of finite vector spaces",[IsGeneralMappingCollection],COM_FUN(45));
InstallMethod(IsFullHomModule,"for space of linear mappings",[IsFreeLeftModule and IsGeneralMappingCollection],COM_FUN(46));
InstallMethod(Dimension,"for full hom space of linear mappings",[IsFreeLeftModule and IsGeneralMappingCollection and IsFullHomModule],COM_FUN(47));
InstallMethod(Random,"for full hom space of linear mappings",[IsFreeLeftModule and IsGeneralMappingCollection and IsFullHomModule],COM_FUN(48));
InstallMethod(Representative,"for full hom space of linear mappings",[IsFreeLeftModule and IsGeneralMappingCollection and IsFullHomModule],COM_FUN(49));
BindGlobal("StandardGeneratorsOfFullHomModule",COM_FUN(50));
InstallMethod(GeneratorsOfLeftModule,"for full hom space of linear mappings",[IsFreeLeftModule and IsGeneralMappingCollection and IsFullHomModule],StandardGeneratorsOfFullHomModule);
InstallMethod(NiceFreeLeftModule,"for full hom space of linear mappings",[IsFreeLeftModule and IsGeneralMappingCollection and IsFullHomModule],COM_FUN(51));
BindGlobal("ViewFullHomModule",COM_FUN(52));
InstallMethod(ViewObj,"for full hom space of linear mappings",[IsFreeLeftModule and IsGeneralMappingCollection and IsFullHomModule],SUM_FLAGS,ViewFullHomModule);
InstallMethod(PrintObj,"for full hom space of linear mappings",[IsFreeLeftModule and IsGeneralMappingCollection and IsFullHomModule],SUM_FLAGS,ViewFullHomModule);
InstallMethod(\in,"for full hom space of linear mappings",IsElmsColls,[IsGeneralMapping,IsFreeLeftModule and IsGeneralMappingCollection and IsFullHomModule],COM_FUN(53));
InstallMethod(IsPseudoCanonicalBasisFullHomModule,"for a basis of a full hom module",[IsBasis],COM_FUN(54));
InstallMethod(BasisVectors,"for pseudo canonical basis of a full hom module",[IsBasis and IsPseudoCanonicalBasisFullHomModule],COM_FUN(55));
InstallOtherMethod(Coefficients,"for pseudo canon. basis of a full hom module, and lin. mapping",IsCollsElms,[IsBasis and IsPseudoCanonicalBasisFullHomModule,IsGeneralMapping],COM_FUN(56));
InstallMethod(Coefficients,"for pseudo can. basis of full hom module, and lin. m.b.m.",IsCollsElms,[IsBasis and IsPseudoCanonicalBasisFullHomModule,IsMapping and IsLinearMappingByMatrixDefaultRep],COM_FUN(57));
InstallMethod(Basis,"for full hom space of linear mappings",[IsFreeLeftModule and IsFullHomModule],100,COM_FUN(58));
InstallMethod(Hom,"for division ring and two free left modules",[IsDivisionRing,IsFreeLeftModule,IsFreeLeftModule],COM_FUN(59));
InstallMethod(End,"for division ring and space of linear mappings",[IsDivisionRing,IsFreeLeftModule],COM_FUN(60));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/vspchom.gi"

#F  file="lib/zlattice.gi" crc=-33974426
RANK_FILTER_LIST  := [ 65077940, 12, 65077940, 12, 58412696, 30, 7665940, 19 
 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/zlattice.gi", -33974426 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/zlattice.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/zlattice.gi");
elif COM_RESULT = 3  then
Revision.zlattice_gi:="@(#)$Id: zlattice.gi,v 4.16.4.1 2006/04/18 09:07:27 gap Exp $";
InstallMethod(ScalarProduct,"method for two row vectors",IsIdenticalObj,[IsRowVector,IsRowVector],COM_FUN(1));
InstallGlobalFunction(StandardScalarProduct,COM_FUN(2));
InstallMethod(InverseMatMod,"method for a matrix, and an integer",[IsMatrix,IsPosInt],COM_FUN(3));
InstallGlobalFunction(PadicCoefficients,COM_FUN(4));
InstallGlobalFunction(LinearIndependentColumns,COM_FUN(5));
InstallGlobalFunction(DecompositionInt,COM_FUN(6));
InstallGlobalFunction(IntegralizedMat,COM_FUN(7));
InstallGlobalFunction(Decomposition,COM_FUN(8));
InstallGlobalFunction(LLLReducedBasis,COM_FUN(9));
InstallGlobalFunction(LLLReducedGramMat,COM_FUN(10));
InstallGlobalFunction(ShortestVectors,COM_FUN(11));
InstallGlobalFunction(OrthogonalEmbeddings,COM_FUN(12));
InstallGlobalFunction(LLLint,COM_FUN(13));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/zlattice.gi"

#F  file="lib/mgmring.gi" crc=-1579849
RANK_FILTER_LIST  := [ 6296069, 5, 8193, 2, 1985, 1, 64918210, 8, 32769, 4, 
  32769, 4, 66648126, 13, 66648126, 13, 8585363, 11, 8585363, 11, 8585363, 
  11, 8585363, 11, 8585363, 11, 8585363, 11, 8585363, 11, 8585363, 11, 
  8585363, 11, 8585363, 11, 8585363, 11, 64918210, 8, 8585363, 11, 33, 17, 
  64918210, 8, 8585363, 11, 33, 17, 8585363, 11, 8585363, 11, 32505602, 3, 
  8585363, 11, 8585363, 11, 32505602, 3, 32505602, 3, 8585363, 11, 8585363, 
  11, 32505602, 3, 8585363, 11, 32505602, 3, 32505602, 3, 8585363, 11, 
  8585363, 11, 64918210, 8, 8585363, 11, 17, 18, 8585363, 11, 8585363, 11, 
  33629170, 36, 33629170, 36, 33629170, 36, 46003196, 12, 1574018, 12, 
  33629170, 36, 33629170, 36, 33629170, 36, 33629170, 36, 1032, 39, 33629170, 
  36, 33629170, 36, 448378, 38, 8585363, 11, 50368545, 35, 33629170, 36, 
  33629170, 36, 33629170, 36, 33629170, 36, 13429662, 39, 50997183, 26, 
  33629170, 36, 21882140, 25, 64918210, 8, 21882140, 25, 64918210, 8, 
  21882140, 25, 1574018, 12, 21882140, 25, 1574018, 12, 15635848, 11, 
  33629170, 36, 40749867, 19, 32505602, 3, 40749867, 19, 32505602, 3, 
  40749867, 19, 1574018, 12, 40749867, 19, 1574018, 12, 8585363, 11, 
  34341449, 4, 8193, 2, 26344978, 27, 26344978, 27, 1, 0, 26344978, 27, 1, 0, 
  4783649, 5, 8193, 2, 2391345, 36, 2391345, 36, 2391345, 36, 2391345, 36, 
  17170725, 16 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/mgmring.gi", -1579849 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/mgmring.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/mgmring.gi");
elif COM_RESULT = 3  then
Revision.mgmring_gi:="@(#)$Id: mgmring.gi,v 4.58.2.2 2005/07/20 15:53:43 gap Exp $";
DeclareRepresentation("IsMagmaRingObjDefaultRep",IsPositionalObjectRep,[1,2]);
InstallMethod(NormalizedElementOfMagmaRingModuloRelations,"for a family of elements in a *free* magma ring, and a list",[IsElementOfFreeMagmaRingFamily,IsList],COM_FUN(1));
BindGlobal("FMRRemoveZero",COM_FUN(2));
InstallMethod(ElementOfMagmaRing,"for family, ring element, and two homogeneous lists",[IsFamily,IsRingElement,IsHomogeneousList,IsHomogeneousList],COM_FUN(3));
InstallMethod(ZeroCoefficient,"for magma ring element in default repr.",[IsElementOfMagmaRingModuloRelations and IsMagmaRingObjDefaultRep],COM_FUN(4));
InstallMethod(CoefficientsAndMagmaElements,"for magma ring element in default repr.",[IsElementOfMagmaRingModuloRelations and IsMagmaRingObjDefaultRep],COM_FUN(5));
InstallMethod(PrintObj,"for magma ring element",[IsElementOfMagmaRingModuloRelations],COM_FUN(6));
InstallMethod(\=,"for two free magma ring elements",IsIdenticalObj,[IsElementOfMagmaRingModuloRelations,IsElementOfMagmaRingModuloRelations],COM_FUN(7));
InstallMethod(\<,"for two free magma ring elements",IsIdenticalObj,[IsElementOfMagmaRingModuloRelations,IsElementOfMagmaRingModuloRelations],COM_FUN(8));
InstallMethod(\+,"for two magma ring elements",IsIdenticalObj,[IsElementOfMagmaRingModuloRelations,IsElementOfMagmaRingModuloRelations],COM_FUN(9));
InstallMethod(AdditiveInverseOp,"for magma ring element",[IsElementOfMagmaRingModuloRelations],COM_FUN(10));
InstallMethod(\*,"for two magma ring elements",IsIdenticalObj,[IsElementOfMagmaRingModuloRelations,IsElementOfMagmaRingModuloRelations],COM_FUN(11));
ElmTimesRingElm:=COM_FUN(12);
InstallMethod(\*,"for magma ring element, and ring element",IsMagmaRingsRings,[IsElementOfMagmaRingModuloRelations,IsRingElement],ElmTimesRingElm);
InstallMethod(\*,"for magma ring element, and rational",[IsElementOfMagmaRingModuloRelations,IsRat],ElmTimesRingElm);
RingElmTimesElm:=COM_FUN(13);
InstallMethod(\*,"for ring element, and magma ring element",IsRingsMagmaRings,[IsRingElement,IsElementOfMagmaRingModuloRelations],RingElmTimesElm);
InstallMethod(\*,"for rational, and magma ring element",[IsRat,IsElementOfMagmaRingModuloRelations],RingElmTimesElm);
InstallOtherMethod(InverseOp,"for magma ring element",[IsElementOfMagmaRingModuloRelations],COM_FUN(14));
InstallMethod(\*,"for magma element and magma ring element",IsMagmasMagmaRings,[IsMultiplicativeElement,IsElementOfMagmaRingModuloRelations],COM_FUN(15));
InstallMethod(\*,"for magma ring element and magma element",IsMagmaRingsMagmas,[IsElementOfMagmaRingModuloRelations,IsMultiplicativeElement],COM_FUN(16));
InstallOtherMethod(\+,"for magma element and magma ring element",IsMagmasMagmaRings,[IsMultiplicativeElement,IsElementOfMagmaRingModuloRelations],COM_FUN(17));
InstallOtherMethod(\+,"for magma ring element and magma element",IsMagmaRingsMagmas,[IsElementOfMagmaRingModuloRelations,IsMultiplicativeElement],COM_FUN(18));
InstallOtherMethod(\-,"for magma ring element and magma element",IsMagmaRingsMagmas,[IsElementOfMagmaRingModuloRelations,IsMultiplicativeElement],COM_FUN(19));
InstallOtherMethod(\-,"for magma ring element and magma element",IsMagmasMagmaRings,[IsMultiplicativeElement,IsElementOfMagmaRingModuloRelations],COM_FUN(20));
ElmDivRingElm:=COM_FUN(21);
InstallOtherMethod(\/,"for magma ring element, and ring element",IsMagmaRingsRings,[IsElementOfMagmaRingModuloRelations,IsRingElement],ElmDivRingElm);
InstallMethod(\/,"for magma ring element, and integer",[IsElementOfMagmaRingModuloRelations,IsInt],ElmDivRingElm);
InstallMethod(OneOp,"for magma ring element",[IsElementOfMagmaRingModuloRelations],COM_FUN(22));
InstallMethod(ZeroOp,"for magma ring element",[IsElementOfMagmaRingModuloRelations],COM_FUN(23));
InstallMethod(IsGroupRing,"for free magma ring",[IsFreeMagmaRing],COM_FUN(24));
InstallMethod(PrintObj,"for a free magma ring",[IsFreeMagmaRing],COM_FUN(25));
InstallGlobalFunction(FreeMagmaRing,COM_FUN(26));
InstallGlobalFunction(GroupRing,COM_FUN(27));
InstallMethod(AugmentationIdeal,"for a free magma ring",[IsFreeMagmaRing],COM_FUN(28));
DeclareRepresentation("IsCanonicalBasisFreeMagmaRingRep",IsCanonicalBasis and IsAttributeStoringRep,["zerovector"]);
InstallMethod(Coefficients,"for canon. basis of a free magma ring, and a vector",IsCollsElms,[IsCanonicalBasisFreeMagmaRingRep,IsElementOfFreeMagmaRing],COM_FUN(29));
InstallMethod(Basis,"for a free magma ring (delegate to `CanonicalBasis')",[IsFreeMagmaRing],CANONICAL_BASIS_FLAGS,CanonicalBasis);
InstallMethod(CanonicalBasis,"for a free magma ring",[IsFreeMagmaRing],COM_FUN(30));
InstallMethod(IsFinite,"for a free magma ring",[IsFreeMagmaRing],COM_FUN(31));
InstallMethod(IsFiniteDimensional,"for a free magma ring",[IsFreeMagmaRing],COM_FUN(32));
InstallMethod(IsFiniteDimensional,"for a left module of free magma ring elements",[IsFreeLeftModule and IsElementOfFreeMagmaRingCollection and HasGeneratorsOfLeftOperatorRing],COM_FUN(33));
InstallMethod(Dimension,"for a free magma ring",[IsFreeMagmaRing],COM_FUN(34));
InstallMethod(GeneratorsOfLeftModule,"for a free magma ring",[IsFreeMagmaRing],COM_FUN(35));
InstallMethod(Centre,"for a group ring",[IsGroupRing],COM_FUN(36));
InstallMethod(\in,"for ring element, and magma ring",IsElmsColls,[IsElementOfMagmaRingModuloRelations,IsMagmaRingModuloRelations],COM_FUN(37));
InstallMethod(IsAssociative,"for a free magma ring",[IsFreeMagmaRing],COM_FUN(38));
InstallMethod(IsCommutative,"for a free magma ring",[IsFreeMagmaRing],COM_FUN(39));
InstallMethod(IsWholeFamily,"for a free magma ring",[IsFreeMagmaRing],COM_FUN(40));
InstallMethod(GeneratorsOfRing,"for a free magma ring",[IsFreeMagmaRing],COM_FUN(41));
InstallMethod(GeneratorsOfRingWithOne,"for a free magma ring-with-one",[IsFreeMagmaRingWithOne],COM_FUN(42));
DeclareRepresentation("IsEmbeddingRingMagmaRing",IsSPGeneralMapping and IsMapping and IsInjective and RespectsAddition and RespectsZero and RespectsMultiplication and RespectsOne and IsAttributeStoringRep,[]);
InstallMethod(Embedding,"for ring and magma ring",IsRingCollsMagmaRingColls,[IsRing,IsFreeMagmaRing],COM_FUN(43));
InstallMethod(ImagesElm,"for embedding of ring into magma ring, and ring element",FamSourceEqFamElm,[IsEmbeddingRingMagmaRing,IsRingElement],COM_FUN(44));
InstallMethod(ImagesRepresentative,"for embedding of ring into magma ring, and ring element",FamSourceEqFamElm,[IsEmbeddingRingMagmaRing,IsRingElement],COM_FUN(45));
InstallMethod(PreImagesElm,"for embedding of ring into magma ring, and free magma ring element",FamRangeEqFamElm,[IsEmbeddingRingMagmaRing,IsElementOfFreeMagmaRing],COM_FUN(46));
InstallMethod(PreImagesRepresentative,"for embedding of ring into magma ring, and free magma ring element",FamRangeEqFamElm,[IsEmbeddingRingMagmaRing,IsElementOfFreeMagmaRing],COM_FUN(47));
DeclareRepresentation("IsEmbeddingMagmaMagmaRing",IsSPGeneralMapping and IsMapping and IsInjective and RespectsMultiplication and IsAttributeStoringRep,[]);
InstallMethod(Embedding,"for magma and magma ring",IsMagmaCollsMagmaRingColls,[IsMagma,IsFreeMagmaRing],COM_FUN(48));
InstallMethod(ImagesElm,"for embedding of magma into magma ring, and mult. element",FamSourceEqFamElm,[IsEmbeddingMagmaMagmaRing,IsMultiplicativeElement],COM_FUN(49));
InstallMethod(ImagesRepresentative,"for embedding of magma into magma ring, and mult. element",FamSourceEqFamElm,[IsEmbeddingMagmaMagmaRing,IsMultiplicativeElement],COM_FUN(50));
InstallMethod(PreImagesElm,"for embedding of magma into magma ring, and free magma ring element",FamRangeEqFamElm,[IsEmbeddingMagmaMagmaRing,IsElementOfFreeMagmaRing],COM_FUN(51));
InstallMethod(PreImagesRepresentative,"for embedding of magma into magma ring, and free magma ring element",FamRangeEqFamElm,[IsEmbeddingMagmaMagmaRing,IsElementOfFreeMagmaRing],COM_FUN(52));
InstallMethod(ExtRepOfObj,"for magma ring element",[IsElementOfMagmaRingModuloRelations],COM_FUN(53));
InstallMethod(ObjByExtRep,"for magma ring elements family, and list",[IsElementOfMagmaRingModuloRelationsFamily,IsList],COM_FUN(54));
InstallHandlingByNiceBasis("IsSpaceOfElementsOfMagmaRing",rec(detect:=COM_FUN(55),NiceFreeLeftModuleInfo:=COM_FUN(56),NiceVector:=COM_FUN(57),UglyVector:=COM_FUN(58)));
InstallGlobalFunction(MagmaRingModuloSpanOfZero,COM_FUN(59));
InstallMethod(NormalizedElementOfMagmaRingModuloRelations,"for family of magma rings modulo the span of ``zero'', and list",[IsElementOfMagmaRingModuloSpanOfZeroFamily,IsList],COM_FUN(60));
InstallMethod(IsFinite,"for a magma ring modulo the span of ``zero''",[IsMagmaRingModuloSpanOfZero],COM_FUN(61));
InstallMethod(IsFiniteDimensional,"for a magma ring modulo the span of ``zero''",[IsMagmaRingModuloSpanOfZero],COM_FUN(62));
InstallMethod(Dimension,"for a magma ring modulo the span of ``zero''",[IsMagmaRingModuloSpanOfZero],COM_FUN(63));
InstallMethod(GeneratorsOfLeftModule,"for a magma ring modulo the span of ``zero''",[IsMagmaRingModuloSpanOfZero],COM_FUN(64));
InstallMethod(IsGeneratorsOfMagmaWithInverses,"for a collection of free magma ring elements",[IsElementOfMagmaRingModuloRelationsCollection],COM_FUN(65));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/mgmring.gi"

#F  file="lib/algebra.gi" crc=119667426
RANK_FILTER_LIST  := [ 23085479, 30, 65709763, 33, 50997183, 26, 8126465, 2, 
  50997183, 26, 32769, 4, 64918210, 8, 50997183, 26, 8126465, 2, 50997183, 
  26, 32769, 4, 64918210, 8, 57526177, 36, 26231372, 36, 59785924, 34, 
  59785924, 34, 59785924, 34, 55981102, 36, 51419271, 39, 59785924, 34, 
  59785924, 34, 59785924, 34, 59785924, 34, 55224093, 37, 55224093, 37, 
  59785924, 34, 8126465, 2, 59785924, 34, 41951068, 17, 59785924, 34, 
  59785924, 34, 59785924, 34, 50997183, 26, 8126465, 2, 40033072, 46, 
  16776722, 23, 40033072, 46, 59785924, 34, 50997183, 26, 8126465, 2, 
  40033072, 46, 16776722, 23, 40033072, 46, 59785924, 34, 40033072, 46, 
  55224093, 37, 59785924, 34, 64918210, 8, 9454171, 35, 64918210, 8, 
  55224093, 37, 64918210, 8, 4892340, 38, 64918210, 8, 59772005, 36, 
  64918210, 8, 43009203, 29, 43009203, 29, 38447372, 32, 38447372, 32, 
  42995284, 31, 8126465, 2, 43009203, 29, 8126465, 2, 59785924, 34, 59785924, 
  34, 55224093, 37, 55224093, 37, 59785924, 34, 59838108, 35, 39862200, 35, 
  59785924, 34, 39862200, 35, 55224093, 37, 55276277, 38, 15377605, 38, 
  55224093, 37, 35300369, 38, 57526177, 36, 7244771, 37, 37602453, 37, 
  57526177, 36, 37602453, 37, 52964346, 39, 2682940, 40, 13117858, 40, 
  52964346, 39, 33040622, 40, 64079747, 42, 13798341, 43, 44156023, 43, 
  57526177, 36, 57526177, 36, 57526177, 36, 52964346, 39, 57526177, 36, 
  57526177, 36, 57526177, 36, 52964346, 39, 57526177, 36, 49726793, 26, 
  53721355, 38, 50770314, 37, 57526177, 36, 56482656, 25, 53721355, 38, 
  57526177, 36, 57526177, 36, 1, 0, 59785924, 34, 16776722, 23, 16776722, 23, 
  57526177, 36, 57526177, 36, 22581252, 43, 22581252, 43, 57526177, 36, 
  59785924, 34, 55224093, 37, 59785924, 34, 59785924, 34, 55981102, 36, 
  51419271, 39, 64079747, 42, 57526177, 36, 57526177, 36, 64918210, 8, 
  55224093, 37, 502734, 35, 63049782, 38, 57526177, 36, 57526177, 36, 16385, 
  3, 59785924, 34, 59785924, 34, 55981102, 36, 55981102, 36, 51419271, 39, 
  51419271, 39, 30444821, 36, 7665940, 19, 56957408, 39, 7665940, 19, 
  57526177, 36, 57526177, 36, 57526177, 36, 53721355, 38 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/algebra.gi", 119667426 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/algebra.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/algebra.gi");
elif COM_RESULT = 3  then
Revision.algebra_gi:="@(#)$Id: algebra.gi,v 4.80.2.1 2005/11/26 06:58:57 gap Exp $";
InstallMethod(Representative,"for left operator ring with known generators",[IsLeftOperatorRing and HasGeneratorsOfLeftOperatorRing],RepresentativeFromGenerators(GeneratorsOfLeftOperatorRing));
InstallMethod(Representative,"for left operator ring-with-one with known generators",[IsLeftOperatorRingWithOne and HasGeneratorsOfLeftOperatorRingWithOne],RepresentativeFromGenerators(GeneratorsOfLeftOperatorRingWithOne));
InstallMethod(FLMLORByGenerators,"for ring and collection",[IsRing,IsCollection],COM_FUN(1));
InstallOtherMethod(FLMLORByGenerators,"for ring, homogeneous list, and ring element",[IsRing,IsHomogeneousList,IsRingElement],COM_FUN(2));
InstallMethod(FLMLORWithOneByGenerators,"for ring and collection",[IsRing,IsCollection],COM_FUN(3));
InstallOtherMethod(FLMLORWithOneByGenerators,"for ring, homogeneous list, and ring element",[IsRing,IsHomogeneousList,IsRingElement],COM_FUN(4));
InstallGlobalFunction(FLMLOR,COM_FUN(5));
InstallGlobalFunction(SubFLMLOR,COM_FUN(6));
InstallGlobalFunction(SubFLMLORNC,COM_FUN(7));
InstallGlobalFunction(FLMLORWithOne,COM_FUN(8));
InstallGlobalFunction(SubFLMLORWithOne,COM_FUN(9));
InstallGlobalFunction(SubFLMLORWithOneNC,COM_FUN(10));
InstallMethod(LieAlgebraByDomain,"for an algebra",[IsAlgebra],COM_FUN(11));
InstallGlobalFunction(LieAlgebra,COM_FUN(12));
InstallGlobalFunction(EmptySCTable,COM_FUN(13));
InstallGlobalFunction(SetEntrySCTable,COM_FUN(14));
InstallGlobalFunction(ReducedSCTable,COM_FUN(15));
InstallGlobalFunction(GapInputSCTable,COM_FUN(16));
InstallGlobalFunction(IdentityFromSCTable,COM_FUN(17));
InstallGlobalFunction(QuotientFromSCTable,COM_FUN(18));
InstallGlobalFunction(TestJacobi,COM_FUN(19));
InstallMethod(MultiplicativeNeutralElement,[IsFLMLOR and IsFiniteDimensional],COM_FUN(20));
InstallMethod(IsAssociative,"generic method for a (finite dimensional) FLMLOR",[IsFLMLOR],COM_FUN(21));
InstallMethod(IsAnticommutative,"generic method for a (finite dimensional) FLMLOR",[IsFLMLOR],COM_FUN(22));
InstallMethod(IsCommutative,"generic method for a finite dimensional FLMLOR",[IsFLMLOR],IsCommutativeFromGenerators(GeneratorsOfVectorSpace));
InstallMethod(IsCommutative,"for an associative FLMLOR",[IsFLMLOR and IsAssociative],IsCommutativeFromGenerators(GeneratorsOfAlgebra));
InstallMethod(IsCommutative,"for an associative FLMLOR-with-one",[IsFLMLORWithOne and IsAssociative],IsCommutativeFromGenerators(GeneratorsOfAlgebraWithOne));
InstallMethod(IsZeroSquaredRing,"for a finite dimensional FLMLOR",[IsFLMLOR],COM_FUN(23));
InstallMethod(IsJacobianRing,"for a (finite dimensional) FLMLOR",[IsFLMLOR],COM_FUN(24));
InstallMethod(Intersection2,"generic method for two FLMLORs",IsIdenticalObj,[IsFLMLOR,IsFLMLOR],Intersection2Spaces(AsFLMLOR,SubFLMLORNC,FLMLOR));
InstallMethod(Intersection2,"generic method for two FLMLORs-with-one",IsIdenticalObj,[IsFLMLORWithOne,IsFLMLORWithOne],Intersection2Spaces(AsFLMLORWithOne,SubFLMLORWithOneNC,FLMLORWithOne));
InstallOtherMethod(\/,"for FLMLOR and collection",IsIdenticalObj,[IsFLMLOR,IsCollection],COM_FUN(25));
InstallOtherMethod(\/,"for FLMLOR and empty list",[IsFLMLOR,IsList and IsEmpty],COM_FUN(26));
InstallOtherMethod(\/,"generic method for two FLMLORs",IsIdenticalObj,[IsFLMLOR,IsFLMLOR],COM_FUN(27));
InstallMethod(TrivialSubadditiveMagmaWithZero,"for a FLMLOR",[IsFLMLOR],COM_FUN(28));
InstallMethod(AsFLMLOR,"for a ring and a collection",[IsRing,IsCollection],COM_FUN(29));
InstallMethod(AsFLMLOR,"for a division ring and a free left module",[IsDivisionRing,IsFreeLeftModule],COM_FUN(30));
InstallMethod(AsFLMLOR,"for a division ring and an algebra",[IsDivisionRing,IsFLMLOR],COM_FUN(31));
InstallMethod(AsFLMLORWithOne,"for a ring and a collection",[IsRing,IsCollection],COM_FUN(32));
InstallMethod(AsFLMLORWithOne,"for a division ring and a free left module",[IsDivisionRing,IsFreeLeftModule],COM_FUN(33));
InstallMethod(AsFLMLORWithOne,"for a division ring and an algebra",[IsDivisionRing,IsFLMLOR],COM_FUN(34));
InstallMethod(AsFLMLORWithOne,"for a division ring and a algebra-with-one",[IsDivisionRing,IsFLMLORWithOne],COM_FUN(35));
InstallMethod(ClosureLeftOperatorRing,"for a FLMLOR and a ring element",IsCollsElms,[IsFLMLOR,IsRingElement],COM_FUN(36));
InstallMethod(ClosureLeftOperatorRing,"for an FLMLOR with basis, and a ring element",IsCollsElms,[IsFLMLOR and HasBasis,IsRingElement],COM_FUN(37));
InstallMethod(ClosureLeftOperatorRing,"for a FLMLOR-with-one and a ring element",IsCollsElms,[IsFLMLORWithOne,IsRingElement],COM_FUN(38));
InstallMethod(ClosureLeftOperatorRing,"for a FLMLOR-with-one with basis, and a ring element",IsCollsElms,[IsFLMLORWithOne and HasBasis,IsRingElement],COM_FUN(39));
InstallMethod(ClosureLeftOperatorRing,"for a FLMLOR containing the whole family, and a ring element",IsCollsElms,[IsFLMLOR and IsWholeFamily,IsRingElement],SUM_FLAGS,COM_FUN(40));
InstallMethod(ClosureLeftOperatorRing,"for two left operator rings",IsIdenticalObj,[IsLeftOperatorRing,IsLeftOperatorRing],COM_FUN(41));
InstallMethod(ClosureLeftOperatorRing,"for two left operator rings-with-one",IsIdenticalObj,[IsLeftOperatorRingWithOne,IsLeftOperatorRingWithOne],COM_FUN(42));
InstallMethod(ClosureLeftOperatorRing,"for a left op. ring cont. the whole family, and a collection",IsIdenticalObj,[IsLeftOperatorRing and IsWholeFamily,IsCollection],SUM_FLAGS,COM_FUN(43));
InstallMethod(ClosureLeftOperatorRing,"for left operator ring and list of elements",IsIdenticalObj,[IsLeftOperatorRing,IsCollection],COM_FUN(44));
InstallGlobalFunction(MutableBasisOfClosureUnderAction,COM_FUN(45));
InstallGlobalFunction(MutableBasisOfNonassociativeAlgebra,COM_FUN(46));
InstallGlobalFunction(MutableBasisOfIdealInNonassociativeAlgebra,COM_FUN(47));
InstallMethod(IsSubset,"for two FLMLORs",IsIdenticalObj,[IsFLMLOR,IsFLMLOR],COM_FUN(48));
InstallMethod(IsSubset,"for two FLMLORs-with-one",IsIdenticalObj,[IsFLMLORWithOne,IsFLMLORWithOne],COM_FUN(49));
InstallMethod(ViewObj,"for a FLMLOR",[IsFLMLOR],COM_FUN(50));
InstallMethod(ViewObj,"for a FLMLOR with known dimension",[IsFLMLOR and HasDimension],1,COM_FUN(51));
InstallMethod(ViewObj,"for a FLMLOR with known generators",[IsFLMLOR and HasGeneratorsOfAlgebra],COM_FUN(52));
InstallMethod(PrintObj,"for a FLMLOR",[IsFLMLOR],COM_FUN(53));
InstallMethod(PrintObj,"for a FLMLOR with known generators",[IsFLMLOR and HasGeneratorsOfFLMLOR],COM_FUN(54));
InstallMethod(ViewObj,"for a FLMLOR-with-one",[IsFLMLORWithOne],COM_FUN(55));
InstallMethod(ViewObj,"for a FLMLOR-with-one with known dimension",[IsFLMLORWithOne and HasDimension],1,COM_FUN(56));
InstallMethod(ViewObj,"for a FLMLOR-with-one with known generators",[IsFLMLORWithOne and HasGeneratorsOfFLMLORWithOne],COM_FUN(57));
InstallMethod(PrintObj,"for a FLMLOR-with-one",[IsFLMLORWithOne],COM_FUN(58));
InstallMethod(PrintObj,"for a FLMLOR-with-one with known generators",[IsFLMLORWithOne and HasGeneratorsOfFLMLOR],COM_FUN(59));
InstallMethod(ViewObj,"for an algebra",[IsAlgebra],COM_FUN(60));
InstallMethod(ViewObj,"for an algebra with known dimension",[IsAlgebra and HasDimension],1,COM_FUN(61));
InstallMethod(ViewObj,"for an algebra with known generators",[IsAlgebra and HasGeneratorsOfAlgebra],COM_FUN(62));
InstallMethod(PrintObj,"for an algebra",[IsAlgebra],COM_FUN(63));
InstallMethod(PrintObj,"for an algebra with known generators",[IsAlgebra and HasGeneratorsOfAlgebra],COM_FUN(64));
InstallMethod(ViewObj,"for an algebra-with-one",[IsAlgebraWithOne],COM_FUN(65));
InstallMethod(ViewObj,"for an algebra-with-one with known dimension",[IsAlgebraWithOne and HasDimension],1,COM_FUN(66));
InstallMethod(ViewObj,"for an algebra-with-one with known generators",[IsAlgebraWithOne and HasGeneratorsOfAlgebraWithOne],COM_FUN(67));
InstallMethod(PrintObj,"for an algebra-with-one",[IsAlgebraWithOne],COM_FUN(68));
InstallMethod(PrintObj,"for an algebra-with-one with known generators",[IsAlgebraWithOne and HasGeneratorsOfAlgebra],COM_FUN(69));
InstallMethod(ViewObj,"for a Lie algebra",[IsLieAlgebra],COM_FUN(70));
InstallMethod(ViewObj,"for a Lie algebra with known dimension",[IsLieAlgebra and HasDimension],1,COM_FUN(71));
InstallMethod(ViewObj,"for a Lie algebra with known generators",[IsLieAlgebra and HasGeneratorsOfAlgebra],COM_FUN(72));
InstallMethod(AsSubalgebra,"for two algebras",IsIdenticalObj,[IsAlgebra,IsAlgebra],COM_FUN(73));
InstallMethod(AsSubalgebra,"for an algebra and an algebra-with-one",IsIdenticalObj,[IsAlgebra,IsAlgebraWithOne],COM_FUN(74));
InstallMethod(AsSubalgebraWithOne,"for two algebras",IsIdenticalObj,[IsAlgebra,IsAlgebra],COM_FUN(75));
InstallMethod(AsSubalgebraWithOne,"for an algebra and a algebra-with-one",IsIdenticalObj,[IsAlgebra,IsAlgebraWithOne],COM_FUN(76));
InstallGlobalFunction(CentralizerInFiniteDimensionalAlgebra,COM_FUN(77));
InstallMethod(CentralizerOp,"for a finite dimensional algebra and a vector space with parent",IsIdenticalObj,[IsAlgebra,IsVectorSpace and HasParent],COM_FUN(78));
InstallMethod(CentralizerOp,"for a fin. dim. assoc. algebra and an algebra with parent",IsIdenticalObj,[IsAlgebra and IsAssociative,IsAlgebra and HasParent],COM_FUN(79));
InstallMethod(CentralizerOp,"for a finite dimensional algebra and a vector space",IsIdenticalObj,[IsAlgebra,IsVectorSpace],COM_FUN(80));
InstallMethod(CentralizerOp,"for a fin. dim. assoc. algebra and an algebra",IsIdenticalObj,[IsAlgebra and IsAssociative,IsAlgebra],COM_FUN(81));
InstallMethod(CentralizerOp,"for an algebra and an element",IsCollsElms,[IsAlgebra,IsObject],COM_FUN(82));
BindGlobal("CentreFromSCTable",COM_FUN(83));
InstallMethod(Centre,"for a finite dimensional FLMLOR",[IsFLMLOR],COM_FUN(84));
BindGlobal("MutableBasisOfProductSpace",COM_FUN(85));
InstallMethod(ProductSpace,"for two free left modules",IsIdenticalObj,[IsFreeLeftModule,IsFreeLeftModule],COM_FUN(86));
InstallMethod(ProductSpace,"for two algebras",IsIdenticalObj,[IsAlgebra,IsAlgebra],COM_FUN(87));
InstallMethod(ProductSpace,"for two ideals with same parent",IsIdenticalObj,[IsAlgebra and HasParent and IsTwoSidedIdealInParent,IsAlgebra and HasParent and IsTwoSidedIdealInParent],COM_FUN(88));
InstallMethod(RadicalOfAlgebra,"for an associative algebra",[IsAlgebra],COM_FUN(89));
InstallMethod(IsTrivial,"for a FLMLOR",[IsFLMLOR],COM_FUN(90));
InstallMethod(IsTrivial,"for a FLMLOR-with-one",[IsFLMLORWithOne],COM_FUN(91));
InstallMethod(GeneratorsOfLeftModule,"for a FLMLOR",[IsFLMLOR],COM_FUN(92));
InstallMethod(Basis,"for a FLMLOR",[IsFLMLOR],COM_FUN(93));
InstallMethod(Basis,"for an associative FLMLOR",[IsFLMLOR and IsAssociative],COM_FUN(94));
InstallMethod(Basis,"for an associative FLMLOR-with-one",[IsFLMLORWithOne and IsAssociative],COM_FUN(95));
InstallMethod(Basis,"for a Lie algebra",[IsLieAlgebra],COM_FUN(96));
InstallOtherMethod(PowerSubalgebraSeries,"for an algebra",[IsAlgebra],COM_FUN(97));
InstallMethod(IsNilpotentElement,"for an algebra, and an element",IsCollsElms,[IsAlgebra,IsRingElement],COM_FUN(98));
InstallMethod(GeneratorsOfLeftOperatorRing,"for a FLMLOR-with-one",[IsFLMLORWithOne],COM_FUN(99));
InstallMethod(GeneratorsOfLeftOperatorRing,"for a FLMLOR with known left module generators",[IsFLMLOR and HasGeneratorsOfLeftModule],GeneratorsOfLeftModule);
InstallMethod(GeneratorsOfLeftOperatorRingWithOne,"for a FLMLOR-with-one with known left module generators",[IsFLMLORWithOne and HasGeneratorsOfLeftModule],GeneratorsOfLeftModule);
InstallOtherMethod(DirectSumOfAlgebras,"for two algebras",[IsAlgebra,IsAlgebra],COM_FUN(100));
InstallMethod(DirectSumOfAlgebras,"for list of algebras",[IsDenseList],COM_FUN(101));
InstallMethod(IsCentral,"for two FLMLORs",IsIdenticalObj,[IsFLMLOR,IsFLMLOR],IsCentralFromGenerators(GeneratorsOfLeftModule,GeneratorsOfLeftModule));
InstallMethod(IsCentral,"for two associative FLMLORs",IsIdenticalObj,[IsFLMLOR and IsAssociative,IsFLMLOR and IsAssociative],IsCentralFromGenerators(GeneratorsOfAlgebra,GeneratorsOfAlgebra));
InstallMethod(IsCentral,"for two associative FLMLORs-with-one",IsIdenticalObj,[IsFLMLORWithOne and IsAssociative,IsFLMLORWithOne and IsAssociative],IsCentralFromGenerators(GeneratorsOfAlgebraWithOne,GeneratorsOfAlgebraWithOne));
BindGlobal("FreeAlgebraConstructor",COM_FUN(102));
InstallGlobalFunction(FreeAlgebra,FreeAlgebraConstructor("FreeAlgebra",FreeMagma));
InstallGlobalFunction(FreeAlgebraWithOne,FreeAlgebraConstructor("FreeAlgebraWithOne",FreeMagmaWithOne));
InstallGlobalFunction(FreeAssociativeAlgebra,FreeAlgebraConstructor("FreeAssociativeAlgebra",FreeSemigroup));
InstallGlobalFunction(FreeAssociativeAlgebraWithOne,FreeAlgebraConstructor("FreeAssociativeAlgebraWithOne",FreeMonoid));
InstallAccessToGenerators(IsMagmaRingModuloRelations,"magma ring containing the whole family",GeneratorsOfAlgebra);
InstallAccessToGenerators(IsMagmaRingModuloRelations and IsRingWithOne,"magma ring-with-one containing the whole family",GeneratorsOfAlgebraWithOne);
InstallMethod(CentralIdempotentsOfAlgebra,"for an associative algebra",[IsAlgebra],COM_FUN(103));
InstallMethod(IsSimpleAlgebra,"for an associative algebra",[IsAlgebra],COM_FUN(104));
InstallMethod(LeviMalcevDecomposition,"for an associative or a Lie algebra",[IsAlgebra],COM_FUN(105));
InstallMethod(DirectSumDecomposition,"for semisimple associative algebras",[IsAlgebra and IsAssociative],COM_FUN(106));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/algebra.gi"

#F  file="lib/idealalg.gi" crc=-64690832
RANK_FILTER_LIST  := [ 59785924, 34, 16776722, 23, 55981102, 36, 16776722, 
  23, 51419271, 39, 16776722, 23, 55981102, 36, 59785924, 34, 59785924, 34, 
  16776722, 23, 55981102, 36, 16776722, 23, 51419271, 39, 16776722, 23, 
  55981102, 36, 59785924, 34, 44566636, 36, 16776722, 23, 34701810, 36, 
  16776722, 23, 59785924, 34, 16776722, 23, 59785924, 34, 8126465, 2, 
  59785924, 34, 8126465, 2, 59785924, 34, 8126465, 2, 59785924, 34, 41951068, 
  17, 59785924, 34, 41951068, 17, 59785924, 34, 41951068, 17, 62407499, 35, 
  2620616, 27, 65029074, 35, 2620616, 27, 3162385, 35, 62407499, 35, 2620616, 
  27, 65029074, 35, 2620616, 27, 3162385, 35, 59785924, 34, 59785924, 34, 
  50997183, 26, 50997183, 26, 50997183, 26, 50997183, 26, 13648685, 35, 
  34620325, 35 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/idealalg.gi", -64690832 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/idealalg.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/idealalg.gi");
elif COM_RESULT = 3  then
Revision.idealalg_gi:="@(#)$Id: idealalg.gi,v 4.7 2002/04/15 10:04:53 sal Exp $";
BindGlobal("IsLeftIdealFromGenerators",COM_FUN(1));
BindGlobal("IsRightIdealFromGenerators",COM_FUN(2));
InstallOtherMethod(IsLeftIdealOp,"for FLMLOR and free left module",IsIdenticalObj,[IsFLMLOR,IsFreeLeftModule],0,IsLeftIdealFromGenerators(AsFLMLOR,AsLeftModule,GeneratorsOfLeftModule,GeneratorsOfLeftModule));
InstallOtherMethod(IsLeftIdealOp,"for associative FLMLOR and free left module",IsIdenticalObj,[IsFLMLOR and IsAssociative,IsFreeLeftModule],0,IsLeftIdealFromGenerators(AsFLMLOR,AsLeftModule,GeneratorsOfLeftOperatorRing,GeneratorsOfLeftModule));
InstallOtherMethod(IsLeftIdealOp,"for associative FLMLOR-with-one and free left module",IsIdenticalObj,[IsFLMLORWithOne and IsAssociative,IsFreeLeftModule],0,IsLeftIdealFromGenerators(AsFLMLOR,AsLeftModule,GeneratorsOfLeftOperatorRingWithOne,GeneratorsOfLeftModule));
InstallMethod(IsLeftIdealOp,"for associative FLMLOR and FLMLOR",IsIdenticalObj,[IsFLMLOR and IsAssociative,IsFLMLOR],0,IsLeftIdealFromGenerators(AsFLMLOR,AsFLMLOR,GeneratorsOfLeftOperatorRing,GeneratorsOfLeftOperatorRing));
InstallOtherMethod(IsRightIdealOp,"for FLMLOR and free left module",IsIdenticalObj,[IsFLMLOR,IsFreeLeftModule],0,IsRightIdealFromGenerators(AsFLMLOR,AsLeftModule,GeneratorsOfLeftModule,GeneratorsOfLeftModule));
InstallOtherMethod(IsRightIdealOp,"for associative FLMLOR and free left module",IsIdenticalObj,[IsFLMLOR and IsAssociative,IsFreeLeftModule],0,IsRightIdealFromGenerators(AsFLMLOR,AsLeftModule,GeneratorsOfLeftOperatorRing,GeneratorsOfLeftModule));
InstallOtherMethod(IsRightIdealOp,"for associative FLMLOR-with-one and free left module",IsIdenticalObj,[IsFLMLORWithOne and IsAssociative,IsFreeLeftModule],0,IsRightIdealFromGenerators(AsFLMLOR,AsLeftModule,GeneratorsOfLeftOperatorRingWithOne,GeneratorsOfLeftModule));
InstallMethod(IsRightIdealOp,"for associative FLMLOR and FLMLOR",IsIdenticalObj,[IsFLMLOR and IsAssociative,IsFLMLOR],0,IsRightIdealFromGenerators(AsFLMLOR,AsFLMLOR,GeneratorsOfLeftOperatorRing,GeneratorsOfLeftOperatorRing));
InstallOtherMethod(IsTwoSidedIdealOp,"for commutative FLMLOR and free left module",IsIdenticalObj,[IsFLMLOR and IsCommutative,IsFreeLeftModule],0,IsLeftIdeal);
InstallOtherMethod(IsTwoSidedIdealOp,"for anti-commutative FLMLOR and free left module",IsIdenticalObj,[IsFLMLOR and IsAnticommutative,IsFreeLeftModule],0,IsLeftIdeal);
InstallOtherMethod(IsTwoSidedIdealOp,"for FLMLOR and free left module",IsIdenticalObj,[IsFLMLOR,IsFreeLeftModule],0,COM_FUN(3));
InstallMethod(TwoSidedIdealByGenerators,"for FLMLOR and collection",IsIdenticalObj,[IsFLMLOR,IsCollection],0,COM_FUN(4));
InstallMethod(LeftIdealByGenerators,"for FLMLOR and collection",IsIdenticalObj,[IsFLMLOR,IsCollection],0,COM_FUN(5));
InstallMethod(RightIdealByGenerators,"for FLMLOR and collection",IsIdenticalObj,[IsFLMLOR,IsCollection],0,COM_FUN(6));
InstallMethod(TwoSidedIdealByGenerators,"for FLMLOR and empty list",true,[IsFLMLOR,IsList and IsEmpty],0,COM_FUN(7));
InstallMethod(LeftIdealByGenerators,"for FLMLOR and empty list",true,[IsFLMLOR,IsList and IsEmpty],0,COM_FUN(8));
InstallMethod(RightIdealByGenerators,"for FLMLOR and empty list",true,[IsFLMLOR,IsList and IsEmpty],0,COM_FUN(9));
LeftModuleGeneratorsForIdealFromGenerators:=COM_FUN(10);
InstallMethod(GeneratorsOfLeftModule,"for FLMLOR with known ideal generators",true,[IsFLMLOR and HasGeneratorsOfTwoSidedIdeal],0,COM_FUN(11));
InstallMethod(GeneratorsOfLeftModule,"for FLMLOR with known left ideal generators",true,[IsFLMLOR and HasGeneratorsOfLeftIdeal],RankFilter(HasGeneratorsOfTwoSidedIdeal),COM_FUN(12));
InstallMethod(GeneratorsOfLeftModule,"for FLMLOR with known right ideal generators",true,[IsFLMLOR and HasGeneratorsOfRightIdeal],RankFilter(HasGeneratorsOfTwoSidedIdeal),COM_FUN(13));
InstallMethod(GeneratorsOfLeftOperatorRing,"for FLMLOR with known ideal generators",true,[IsFLMLOR and HasGeneratorsOfTwoSidedIdeal],0,COM_FUN(14));
InstallMethod(GeneratorsOfLeftOperatorRing,"for FLMLOR with known left ideal generators",true,[IsFLMLOR and HasGeneratorsOfLeftIdeal],RankFilter(HasGeneratorsOfTwoSidedIdeal),COM_FUN(15));
InstallMethod(GeneratorsOfLeftOperatorRing,"for FLMLOR with known right ideal generators",true,[IsFLMLOR and HasGeneratorsOfRightIdeal],RankFilter(HasGeneratorsOfTwoSidedIdeal),COM_FUN(16));
InstallMethod(AsLeftIdeal,"for two FLMLORs",IsIdenticalObj,[IsFLMLOR,IsFLMLOR],0,COM_FUN(17));
InstallMethod(AsRightIdeal,"for two FLMLORs",IsIdenticalObj,[IsRing,IsRing],0,COM_FUN(18));
InstallMethod(AsTwoSidedIdeal,"for two FLMLORs",IsIdenticalObj,[IsRing,IsRing],0,COM_FUN(19));
InstallMethod(IsFiniteDimensional,"for an ideal in an algebra",true,[IsFLMLOR and HasLeftActingRingOfIdeal],0,COM_FUN(20));
InstallMethod(IsFiniteDimensional,"for an ideal in an algebra",true,[IsFLMLOR and HasRightActingRingOfIdeal],0,COM_FUN(21));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/idealalg.gi"

#F  file="lib/alghom.gi" crc=-97290782
RANK_FILTER_LIST  := [ 59785924, 34, 59785924, 34, 32769, 4, 32769, 4, 
  59785924, 34, 59785924, 34, 32769, 4, 32769, 4, 59785924, 34, 59785924, 34, 
  32769, 4, 32769, 4, 59785924, 34, 59785924, 34, 32769, 4, 32769, 4, 
  56389653, 25, 54797134, 31, 47377943, 29, 63808844, 27, 56389653, 25, 
  17081515, 25, 8069805, 29, 56389653, 25, 56389653, 25, 56389653, 25, 
  56389653, 25, 56389653, 25, 56389653, 25, 56389653, 25, 1, 0, 56389653, 25, 
  1, 0, 32505602, 3, 56389653, 25, 56389653, 25, 30183226, 19, 17081515, 25, 
  15260804, 21, 17081515, 25, 56389653, 25, 63580652, 7, 63580652, 7, 
  56389653, 25, 52726882, 29, 52726882, 29, 52726882, 29, 52726882, 29, 
  64918210, 8, 52726882, 29, 58412696, 30, 38344884, 29, 38344884, 29, 
  38344884, 29, 38344884, 29, 64918210, 8, 38344884, 29, 58412696, 30, 
  59785924, 34, 62163887, 7, 5, 1, 59785924, 34, 8126465, 2, 59785924, 34, 
  58156738, 26, 5, 1, 52726882, 29, 40186944, 29, 59785924, 34, 63198130, 7, 
  63198130, 7, 5, 1, 59785924, 34, 32769, 4, 32769, 4, 5, 1, 59785924, 34, 
  26230787, 47, 59785924, 34, 59785924, 34, 59785924, 34, 55224093, 37, 
  18874339, 37, 59785924, 34, 62163887, 7, 23003529, 39 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/alghom.gi", -97290782 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/alghom.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/alghom.gi");
elif COM_RESULT = 3  then
Revision.alghom_gi:="@(#)$Id: alghom.gi,v 4.25 2002/04/15 10:04:24 sal Exp $";
DeclareRepresentation("IsAlgebraGeneralMappingByImagesDefaultRep",IsAlgebraGeneralMapping and IsAdditiveElementWithInverse and IsAttributeStoringRep,[]);
InstallMethod(AlgebraGeneralMappingByImages,"for two FLMLORs and two homogeneous lists",[IsFLMLOR,IsFLMLOR,IsHomogeneousList,IsHomogeneousList],COM_FUN(1));
InstallMethod(AlgebraHomomorphismByImagesNC,"for two FLMLORs and two homogeneous lists",[IsFLMLOR,IsFLMLOR,IsHomogeneousList,IsHomogeneousList],COM_FUN(2));
InstallMethod(AlgebraWithOneGeneralMappingByImages,"for two FLMLORs and two homogeneous lists",[IsFLMLOR,IsFLMLOR,IsHomogeneousList,IsHomogeneousList],COM_FUN(3));
InstallMethod(AlgebraWithOneHomomorphismByImagesNC,"for two FLMLORs and two homogeneous lists",true,[IsFLMLOR,IsFLMLOR,IsHomogeneousList,IsHomogeneousList],0,COM_FUN(4));
InstallGlobalFunction(AlgebraHomomorphismByImages,COM_FUN(5));
InstallGlobalFunction(AlgebraWithOneHomomorphismByImages,COM_FUN(6));
InstallMethod(ViewObj,"for an algebra g.m.b.i",true,[IsGeneralMapping and IsAlgebraGeneralMappingByImagesDefaultRep],0,COM_FUN(7));
InstallMethod(PrintObj,"for an algebra-with-one hom. b.i",true,[IsMapping and IsTotal and RespectsOne and IsAlgebraGeneralMappingByImagesDefaultRep],0,COM_FUN(8));
InstallMethod(PrintObj,"for an algebra hom. b.i.",true,[IsMapping and IsTotal and IsAlgebraGeneralMappingByImagesDefaultRep],0,COM_FUN(9));
InstallMethod(PrintObj,"for an algebra-with-one g.m.b.i",true,[IsGeneralMapping and RespectsOne and IsAlgebraGeneralMappingByImagesDefaultRep],0,COM_FUN(10));
InstallMethod(PrintObj,"for an algebra g.m.b.i",true,[IsGeneralMapping and IsAlgebraGeneralMappingByImagesDefaultRep],0,COM_FUN(11));
InstallMethod(AsLeftModuleGeneralMappingByImages,"for an algebra general mapping by images",[IsAlgebraGeneralMapping and IsAlgebraGeneralMappingByImagesDefaultRep],COM_FUN(12));
InstallMethod(AsLeftModuleGeneralMappingByImages,"for an algebra homomorphism by images",[IsAlgebraHomomorphism and IsAlgebraGeneralMappingByImagesDefaultRep],COM_FUN(13));
InstallMethod(ImagesSource,"for an algebra g.m.b.i.",[IsGeneralMapping and IsAlgebraGeneralMappingByImagesDefaultRep],COM_FUN(14));
InstallMethod(PreImagesRange,"for an algebra g.m.b.i.",[IsGeneralMapping and IsAlgebraGeneralMappingByImagesDefaultRep],COM_FUN(15));
InstallMethod(CoKernelOfAdditiveGeneralMapping,"for algebra g.m.b.i.",[IsGeneralMapping and IsAlgebraGeneralMappingByImagesDefaultRep],COM_FUN(16));
InstallMethod(IsSingleValued,"for algebra g.m.b.i.",[IsGeneralMapping and IsAlgebraGeneralMappingByImagesDefaultRep],COM_FUN(17));
InstallMethod(KernelOfAdditiveGeneralMapping,"for algebra g.m.b.i.",[IsGeneralMapping and IsAlgebraGeneralMappingByImagesDefaultRep],COM_FUN(18));
InstallMethod(IsInjective,"for algebra g.m.b.i.",[IsGeneralMapping and IsAlgebraGeneralMappingByImagesDefaultRep],COM_FUN(19));
InstallMethod(ImagesRepresentative,"for algebra g.m.b.i., and element",FamSourceEqFamElm,[IsGeneralMapping and IsAlgebraGeneralMappingByImagesDefaultRep,IsObject],COM_FUN(20));
InstallMethod(PreImagesRepresentative,"for algebra g.m.b.i., and element",FamRangeEqFamElm,[IsGeneralMapping and IsAlgebraGeneralMappingByImagesDefaultRep,IsObject],COM_FUN(21));
InstallMethod(\*,"for scalar and algebra g.m.b.i.",[IsMultiplicativeElement,IsGeneralMapping and IsAlgebraGeneralMappingByImagesDefaultRep],COM_FUN(22));
InstallMethod(AdditiveInverseOp,"for algebra g.m.b.i.",[IsGeneralMapping and IsAlgebraGeneralMappingByImagesDefaultRep],COM_FUN(23));
InstallMethod(CompositionMapping2,"for left module hom. and algebra g.m.b.i.",FamSource1EqFamRange2,[IsLeftModuleHomomorphism,IsAlgebraGeneralMapping and IsAlgebraGeneralMappingByImagesDefaultRep],COM_FUN(24));
InstallMethod(CompositionMapping2,"for left module hom. and algebra g.m.b.i.",FamSource1EqFamRange2,[IsAlgebraHomomorphism,IsAlgebraGeneralMapping and IsAlgebraGeneralMappingByImagesDefaultRep],COM_FUN(25));
InstallOtherMethod(\+,"for an algebra g.m.b.i. and general mapping",IsIdenticalObj,[IsGeneralMapping and IsAlgebraGeneralMappingByImagesDefaultRep,IsGeneralMapping],COM_FUN(26));
InstallOtherMethod(\+,"for general mapping and algebra g.m.b.i.",IsIdenticalObj,[IsGeneralMapping,IsGeneralMapping and IsAlgebraGeneralMappingByImagesDefaultRep],COM_FUN(27));
DeclareRepresentation("IsOperationAlgebraHomomorphismDefaultRep",IsAlgebraHomomorphism and IsAdditiveElementWithInverse and IsAttributeStoringRep,["basis","operation","basisImage","preimagesBasisImage"]);
InstallMethod(ViewObj,"for an operation algebra homomorphism",[IsOperationAlgebraHomomorphismDefaultRep],COM_FUN(28));
InstallMethod(PrintObj,"for an operation algebra homomorphism",[IsOperationAlgebraHomomorphismDefaultRep],COM_FUN(29));
InstallGlobalFunction(InducedLinearAction,COM_FUN(30));
InstallMethod(MakePreImagesInfoOperationAlgebraHomomorphism,"for an operation algebra homomorphism",[IsOperationAlgebraHomomorphismDefaultRep],COM_FUN(31));
InstallMethod(ImagesRepresentative,"for an operation algebra homomorphism, and an element",FamSourceEqFamElm,[IsOperationAlgebraHomomorphismDefaultRep,IsRingElement],COM_FUN(32));
PreImagesRepresentativeOperationAlgebraHomomorphism:=COM_FUN(33);
InstallMethod(PreImagesRepresentative,"for an operation algebra homomorphism, and an element",FamRangeEqFamElm,[IsOperationAlgebraHomomorphismDefaultRep,IsMatrix],PreImagesRepresentativeOperationAlgebraHomomorphism);
DeclareRepresentation("IsAlgebraHomomorphismFromFpRep",IsAlgebraHomomorphism and IsAdditiveElementWithInverse and IsAttributeStoringRep,["Agenerators","Agenimages","basisImage","preimagesBasisImage"]);
InstallMethod(ViewObj,"for an alg. hom. from f. p. algebra",[IsAlgebraHomomorphismFromFpRep],COM_FUN(34));
InstallMethod(PrintObj,"for an alg. hom. from f. p. algebra",[IsAlgebraHomomorphismFromFpRep],COM_FUN(35));
InstallMethod(MakePreImagesInfoOperationAlgebraHomomorphism,"for an alg. hom. from f. p. algebra",[IsAlgebraHomomorphismFromFpRep],COM_FUN(36));
InstallMethod(ImagesRepresentative,"for an alg. hom. from f. p. algebra, and an element",FamSourceEqFamElm,[IsAlgebraHomomorphismFromFpRep,IsRingElement],COM_FUN(37));
InstallMethod(PreImagesRepresentative,"for an alg. hom. from f. p. algebra, and an element",FamRangeEqFamElm,[IsAlgebraHomomorphismFromFpRep,IsMatrix],PreImagesRepresentativeOperationAlgebraHomomorphism);
InstallMethod(OperationAlgebraHomomorphism,"for a FLMLOR, a basis, and a function",[IsFLMLOR,IsBasis,IsFunction],COM_FUN(38));
InstallOtherMethod(OperationAlgebraHomomorphism,"for a FLMLOR and a collection (add `OnRight' argument)",[IsFLMLOR,IsCollection],COM_FUN(39));
InstallOtherMethod(OperationAlgebraHomomorphism,"for a FLMLOR, a free left module with known generators, and a function",[IsFLMLOR,IsFreeLeftModule and IsFiniteDimensional and HasGeneratorsOfLeftModule,IsFunction],COM_FUN(40));
InstallMethod(Range,"for operation algebra homomorphism (set full matrix FLMLOR)",[IsOperationAlgebraHomomorphismDefaultRep],COM_FUN(41));
InstallMethod(KernelOfAdditiveGeneralMapping,"for operation algebra hom. with fin. dim. source",[IsMapping and IsOperationAlgebraHomomorphismDefaultRep],COM_FUN(42));
InstallMethod(RepresentativeLinearOperation,"for a FLMLOR, two elements in it, and `OnRight'",IsCollsElmsElmsX,[IsFLMLOR,IsVector,IsVector,IsFunction],COM_FUN(43));
InstallOtherMethod(RepresentativeLinearOperation,"for a FLMLOR, two tuples of elements in it, and `OnTuples'",IsFamFamFamX,[IsFLMLOR,IsHomogeneousList,IsHomogeneousList,IsFunction],COM_FUN(44));
InstallMethod(NaturalHomomorphismByIdeal,"for FLMLOR and trivial FLMLOR",IsIdenticalObj,[IsFLMLOR,IsFLMLOR and IsTrivial],SUM_FLAGS,COM_FUN(45));
InstallMethod(NaturalHomomorphismByIdeal,"for two finite dimensional FLMLORs",IsIdenticalObj,[IsFLMLOR,IsFLMLOR],COM_FUN(46));
InstallMethod(IsomorphismMatrixFLMLOR,"for a finite dimensional associative FLMLOR with identity",[IsFLMLOR],COM_FUN(47));
InstallMethod(IsomorphismFpFLMLOR,"for a finite dimensional FLMLOR-with-one",[IsFLMLORWithOne],COM_FUN(48));
InstallMethod(IsomorphismFpFLMLOR,"for f.p. FLMLOR (return the identity mapping)",[IsSubalgebraFpAlgebra],SUM_FLAGS,IdentityMapping);
InstallMethod(IsomorphismSCFLMLOR,"for a finite dimensional FLMLOR (delegate to the method for a basis)",[IsFLMLOR],COM_FUN(49));
InstallMethod(IsomorphismSCFLMLOR,"for a basis (of a finite dimensional FLMLOR)",[IsBasis],COM_FUN(50));
InstallMethod(IsomorphismSCFLMLOR,"for s.c. FLMLOR (return the identity mapping)",[IsFLMLOR and IsSCAlgebraObjCollection],SUM_FLAGS,IdentityMapping);
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/alghom.gi"

#F  file="lib/algfp.gi" crc=58533464
RANK_FILTER_LIST  := [ 9437170, 4, 64918210, 8, 31185522, 5, 64918210, 8, 
  20152321, 11, 31185522, 5, 8193, 2, 19136513, 9, 32769, 4, 32769, 4, 
  35447537, 11, 35447537, 11, 19136513, 9, 19136513, 9, 35447537, 11, 
  35447537, 11, 19136513, 9, 19136513, 9, 65011488, 40, 65011488, 40, 
  65011488, 40, 9291636, 37, 50368545, 35, 59785924, 34, 20152321, 11, 
  20152321, 11, 20152321, 11, 20152321, 11, 20152321, 11, 20152321, 11, 
  20152321, 11, 20152321, 11, 20152321, 11, 20152321, 11, 64918210, 8, 
  20152321, 11, 20152321, 11, 64918210, 8, 11551383, 37, 49321879, 45, 
  49321879, 45, 8126465, 2, 5, 1, 49321879, 45, 18874339, 37, 33945332, 27, 
  33945332, 27, 1, 0, 33945332, 27, 1, 0 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/algfp.gi", 58533464 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/algfp.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/algfp.gi");
elif COM_RESULT = 3  then
Revision.algfp_gi:="@(#)$Id: algfp.gi,v 4.25.4.1 2005/10/28 11:07:02 gap Exp $";
InstallMethod(ElementOfFpAlgebra,"for family of fp. alg. elements and ring element",true,[IsElementOfFpAlgebraFamily,IsRingElement],0,COM_FUN(1));
InstallMethod(ElementOfFpAlgebra,"for fp. alg. elms. family with normal form, and ring element",true,[IsElementOfFpAlgebraFamily and HasNiceNormalFormByExtRepFunction,IsRingElement],0,COM_FUN(2));
InstallMethod(ExtRepOfObj,"for f.p. algebra element",true,[IsElementOfFpAlgebra and IsPackedElementDefaultRep],0,COM_FUN(3));
InstallMethod(ObjByExtRep,"for family of f.p. algebra elements with normal form",true,[IsElementOfFpAlgebraFamily and HasNiceNormalFormByExtRepFunction,IsList],0,COM_FUN(4));
BindGlobal("MappedExpressionForElementOfFreeAssociativeAlgebra",COM_FUN(5));
InstallMethod(MappedExpression,"for element of f.p. algebra, and two lists of generators",IsElmsCollsX,[IsElementOfFpAlgebra,IsHomogeneousList,IsHomogeneousList],0,MappedExpressionForElementOfFreeAssociativeAlgebra);
InstallMethod(\=,"for two normalized f.p. algebra elements",IsIdenticalObj,[IsElementOfFpAlgebra and IsNormalForm,IsElementOfFpAlgebra and IsNormalForm],0,COM_FUN(6));
InstallMethod(\=,"for two f.p. algebra elements (try nice monomorphism)",IsIdenticalObj,[IsElementOfFpAlgebra,IsElementOfFpAlgebra],0,COM_FUN(7));
InstallMethod(\<,"for two normalized f.p. algebra elements",IsIdenticalObj,[IsElementOfFpAlgebra and IsNormalForm,IsElementOfFpAlgebra and IsNormalForm],0,COM_FUN(8));
InstallMethod(\<,"for two f.p. algebra elements (try nice monomorphism)",IsIdenticalObj,[IsElementOfFpAlgebra,IsElementOfFpAlgebra],0,COM_FUN(9));
InstallGlobalFunction(FactorFreeAlgebraByRelators,COM_FUN(10));
InstallMethod(FreeGeneratorsOfFpAlgebra,"for a full f.p. algebra",true,[IsSubalgebraFpAlgebra and IsFullFpAlgebra],0,COM_FUN(11));
InstallMethod(RelatorsOfFpAlgebra,"for a full f.p. algebra",true,[IsSubalgebraFpAlgebra and IsFullFpAlgebra],0,COM_FUN(12));
InstallMethod(FreeAlgebraOfFpAlgebra,"for a full f.p. algebra",true,[IsSubalgebraFpAlgebra and IsFullFpAlgebra],0,COM_FUN(13));
InstallOtherMethod(IsFullFpAlgebra,"for f. p. algebra",true,[IsAlgebra and IsSubalgebraFpAlgebra],0,COM_FUN(14));
InstallMethod(NaturalHomomorphismByIdeal,"for free algebra and ideal",IsIdenticalObj,[IsMagmaRingModuloRelations,IsFLMLOR],COM_FUN(15));
InstallMethod(PrintObj,"fp algebra elements",true,[IsElementOfFpAlgebra and IsPackedElementDefaultRep],0,COM_FUN(16));
InstallMethod(\+,"fp algebra elements",IsIdenticalObj,[IsElementOfFpAlgebra and IsPackedElementDefaultRep,IsElementOfFpAlgebra and IsPackedElementDefaultRep],0,COM_FUN(17));
InstallMethod(\-,"fp algebra elements",IsIdenticalObj,[IsElementOfFpAlgebra and IsPackedElementDefaultRep,IsElementOfFpAlgebra and IsPackedElementDefaultRep],0,COM_FUN(18));
InstallMethod(AdditiveInverseOp,"fp algebra element",true,[IsElementOfFpAlgebra and IsPackedElementDefaultRep],0,COM_FUN(19));
InstallOtherMethod(OneOp,"for an f.p. algebra element",true,[IsElementOfFpAlgebra and IsPackedElementDefaultRep],0,COM_FUN(20));
InstallMethod(ZeroOp,"for an f.p. algebra element",true,[IsElementOfFpAlgebra and IsPackedElementDefaultRep],0,COM_FUN(21));
InstallMethod(\*,"fp algebra elements",IsIdenticalObj,[IsElementOfFpAlgebra and IsPackedElementDefaultRep,IsElementOfFpAlgebra and IsPackedElementDefaultRep],0,COM_FUN(22));
InstallMethod(\*,"ring el *fp algebra el",IsRingsMagmaRings,[IsRingElement,IsElementOfFpAlgebra and IsPackedElementDefaultRep],0,COM_FUN(23));
InstallMethod(\*,"fp algebra el*ring el",IsMagmaRingsRings,[IsElementOfFpAlgebra and IsPackedElementDefaultRep,IsRingElement],0,COM_FUN(24));
InstallMethod(IsomorphismMatrixFLMLOR,"for a f.p. FLMLOR",true,[IsFLMLOR and IsSubalgebraFpAlgebra],0,COM_FUN(25));
InstallMethod(IsomorphismMatrixFLMLOR,"for a full f.p. associative FLMLOR",true,[IsFLMLORWithOne and IsSubalgebraFpAlgebra and IsAssociative and IsFullFpAlgebra],0,COM_FUN(26));
InstallOtherMethod(OperationAlgebraHomomorphism,"for a full f.p. associative FLMLOR, a collection, and a function",true,[IsFLMLORWithOne and IsSubalgebraFpAlgebra and IsAssociative and IsFullFpAlgebra,IsCollection,IsFunction],0,COM_FUN(27));
InstallMethod(NiceAlgebraMonomorphism,"for a full f.p. associative FLMLOR (call `IsomorphismMatrixFLMLOR')",true,[IsFLMLORWithOne and IsSubalgebraFpAlgebra and IsAssociative and IsFullFpAlgebra],0,IsomorphismMatrixFLMLOR);
InstallMethod(IsFiniteDimensional,"for f.p. algebra",true,[IsSubalgebraFpAlgebra],0,COM_FUN(28));
InstallHandlingByNiceBasis("IsFpAlgebraElementsSpace",rec(detect:=COM_FUN(29),NiceFreeLeftModuleInfo:=ReturnTrue,NiceVector:=COM_FUN(30),UglyVector:=COM_FUN(31)));
InstallGlobalFunction(FpAlgebraByGeneralizedCartanMatrix,COM_FUN(32));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/algfp.gi"

#F  file="lib/alglie.gi" crc=-48994603
RANK_FILTER_LIST  := [ 64079747, 42, 64079747, 42, 64079747, 42, 64079747, 
  42, 64079747, 42, 64079747, 42, 13747994, 43, 64079747, 42, 64079747, 42, 
  60645806, 48, 56482656, 25, 64079747, 42, 56482656, 25, 64079747, 42, 
  56482656, 25, 64079747, 42, 56482656, 25, 62163887, 7, 64918210, 8, 
  62163887, 7, 62163887, 7, 62163887, 7, 62163887, 7, 64079747, 42, 64079747, 
  42, 62163887, 7, 64918210, 8, 62163887, 7, 64079747, 42, 64079747, 42, 
  64079747, 42, 64079747, 42, 64079747, 42, 64079747, 42, 64079747, 42, 
  64079747, 42, 64079747, 42, 67108340, 1, 67108340, 1, 1, 0, 64079747, 42, 
  67108760, 2, 64079747, 42, 64079747, 42, 62163887, 7, 64079747, 42, 
  26357609, 27, 26357609, 27, 1, 0, 26357609, 27, 1, 0, 21444477, 5, 8193, 2, 
  42889913, 22, 19136513, 9, 42889913, 22, 19136513, 9, 42889913, 22, 
  15163243, 11, 15845206, 43, 15845206, 43, 15845206, 43, 29419057, 21, 
  29419057, 21 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/alglie.gi", -48994603 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/alglie.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/alglie.gi");
elif COM_RESULT = 3  then
Revision.alglie_gi:="@(#)$Id: alglie.gi,v 4.84.2.2 2005/12/21 08:30:03 gap Exp $";
InstallMethod(LieUpperCentralSeries,"for a Lie algebra",true,[IsAlgebra and IsLieAlgebra],0,COM_FUN(1));
InstallMethod(LieLowerCentralSeries,"for a Lie algebra",true,[IsAlgebra and IsLieAlgebra],0,COM_FUN(2));
InstallMethod(LieDerivedSubalgebra,"for a Lie algebra",true,[IsAlgebra and IsLieAlgebra],0,COM_FUN(3));
InstallMethod(LieDerivedSeries,"for a Lie algebra",true,[IsAlgebra and IsLieAlgebra],0,COM_FUN(4));
InstallMethod(IsLieSolvable,"for a Lie algebra",true,[IsAlgebra and IsLieAlgebra],0,COM_FUN(5));
InstallTrueMethod(IsLieSolvable,IsLieNilpotent);
InstallMethod(IsLieNilpotent,"for a Lie algebra",true,[IsAlgebra and IsLieAlgebra],0,COM_FUN(6));
InstallTrueMethod(IsLieNilpotent,IsLieAbelian);
InstallMethod(IsLieAbelian,"for a Lie algebra with known basis",true,[IsAlgebra and IsLieAlgebra and HasBasis],0,COM_FUN(7));
InstallMethod(IsLieAbelian,"for a Lie algebra",true,[IsAlgebra and IsLieAlgebra],0,COM_FUN(8));
InstallTrueMethod(IsLieAbelian,IsAlgebra and IsZeroMultiplicationRing);
InstallMethod(LieCentre,"for a Lie algebra",true,[IsAlgebra and IsLieAlgebra],0,COM_FUN(9));
InstallMethod(LieCentralizer,"for an abelian Lie algebra and a vector space",IsIdenticalObj,[IsAlgebra and IsLieAlgebra and IsLieAbelian,IsVectorSpace],0,COM_FUN(10));
InstallMethod(LieCentralizer,"for a Lie algebra and a vector space",IsIdenticalObj,[IsAlgebra and IsLieAlgebra,IsVectorSpace],0,COM_FUN(11));
InstallMethod(LieNormalizer,"for a Lie algebra and a vector space",IsIdenticalObj,[IsAlgebra and IsLieAlgebra,IsVectorSpace],0,COM_FUN(12));
InstallMethod(KappaPerp,"for a Lie algebra and a vector space",IsIdenticalObj,[IsAlgebra and IsLieAlgebra,IsVectorSpace],0,COM_FUN(13));
InstallMethod(AdjointMatrix,"for a basis of a Lie algebra, and an element",IsCollsElms,[IsBasis,IsRingElement],0,COM_FUN(14));
InstallMethod(RightDerivations,"method for a basis of an algebra",true,[IsBasis],0,COM_FUN(15));
InstallMethod(LeftDerivations,"method for a basis of an algebra",true,[IsBasis],0,COM_FUN(16));
InstallMethod(KillingMatrix,"for a basis of a Lie algebra",true,[IsBasis],0,COM_FUN(17));
InstallMethod(AdjointBasis,"for a basis of a Lie algebra",true,[IsBasis],0,COM_FUN(18));
InstallMethod(IsRestrictedLieAlgebra,"for a Lie algebra",true,[IsAlgebra and IsLieAlgebra],0,COM_FUN(19));
InstallGlobalFunction(PowerSi,COM_FUN(20));
InstallMethod(PowerS,"for a Lie algebra",true,[IsLieAlgebra],0,COM_FUN(21));
InstallMethod(PthPowerImage,"for a basis of an algebra, and a ring element",IsCollsElms,[IsBasis,IsRingElement],0,COM_FUN(22));
InstallMethod(PthPowerImages,"for a basis of a Lie algebra",true,[IsBasis],0,COM_FUN(23));
InstallMethod(CartanSubalgebra,"for a Lie algebra",true,[IsLieAlgebra],0,COM_FUN(24));
InstallMethod(AdjointAssociativeAlgebra,"for a Lie algebra and a subalgebra",true,[IsAlgebra and IsLieAlgebra,IsAlgebra and IsLieAlgebra],0,COM_FUN(25));
InstallMethod(LieNilRadical,"for a Lie algebra",true,[IsAlgebra and IsLieAlgebra],0,COM_FUN(26));
InstallMethod(LieSolvableRadical,"for a Lie algebra",true,[IsLieAlgebra],0,COM_FUN(27));
InstallMethod(DirectSumDecomposition,"for a Lie algebra",true,[IsAlgebra and IsLieAlgebra],0,COM_FUN(28));
InstallMethod(IsSimpleAlgebra,"for a Lie algebra in characteristic zero",true,[IsAlgebra and IsLieAlgebra],0,COM_FUN(29));
InstallGlobalFunction(FindSl2,COM_FUN(30));
InstallMethod(SemiSimpleType,"for a Lie algebra",true,[IsAlgebra and IsLieAlgebra],0,COM_FUN(31));
InstallMethod(NonNilpotentElement,"for a Lie algebra",true,[IsAlgebra and IsLieAlgebra],0,COM_FUN(32));
InstallMethod(PrintObj,"for a root system",true,[IsRootSystem],0,COM_FUN(33));
InstallMethod(\.,"for a root system and a record component",true,[IsRootSystem,IsObject],0,COM_FUN(34));
InstallMethod(RootSystem,"for a (semisimple) Lie algebra",true,[IsAlgebra and IsLieAlgebra],0,COM_FUN(35));
InstallMethod(CanonicalGenerators,"for a root system from a (semisimple) Lie algebra",true,[IsRootSystemFromLieAlgebra],0,COM_FUN(36));
InstallMethod(ChevalleyBasis,"for a semisimple Lie algebra with a split Cartan subalgebra",true,[IsLieAlgebra],0,COM_FUN(37));
InstallGlobalFunction(DescriptionOfNormalizedUEAElement,COM_FUN(38));
InstallOtherMethod(UniversalEnvelopingAlgebra,"for a finite dimensional Lie algebra and a basis of it",true,[IsLieAlgebra,IsBasis],0,COM_FUN(39));
InstallMethod(UniversalEnvelopingAlgebra,"for a finite dimensional Lie algebra",true,[IsLieAlgebra],0,COM_FUN(40));
DeclareHandlingByNiceBasis("IsSpaceOfUEAElements","for free left modules of elements of a universal enveloping algebra");
InstallHandlingByNiceBasis("IsSpaceOfUEAElements",rec(detect:=COM_FUN(41),NiceFreeLeftModuleInfo:=COM_FUN(42),NiceVector:=COM_FUN(43),UglyVector:=COM_FUN(44)));
InstallGlobalFunction(FreeLieAlgebra,COM_FUN(45));
InstallMethod(NormalizedElementOfMagmaRingModuloRelations,"for family of free Lie algebra elements, and list",true,[IsFamilyElementOfFreeLieAlgebra,IsList],0,COM_FUN(46));
BindGlobal("FptoSCAMorphismImageElm",COM_FUN(47));
InstallMethod(ImageElm,"for Fp to SCA mapping, and element",FamSourceEqFamElm,[IsFptoSCAMorphism,IsElementOfFpAlgebra],0,FptoSCAMorphismImageElm);
InstallMethod(ImagesRepresentative,"for Fp to SCA mapping, and element",FamSourceEqFamElm,[IsFptoSCAMorphism,IsElementOfFpAlgebra],0,FptoSCAMorphismImageElm);
InstallMethod(PreImagesRepresentative,"for Fp to SCA mapping, and element",FamRangeEqFamElm,[IsFptoSCAMorphism,IsSCAlgebraObj],0,COM_FUN(48));
InstallMethod(Dimension,"for a f.p. Lie algebra",true,[IsLieAlgebra and IsSubalgebraFpAlgebra],0,COM_FUN(49));
InstallMethod(IsFiniteDimensional,"for a f.p. Lie algebra",true,[IsLieAlgebra and IsSubalgebraFpAlgebra],0,COM_FUN(50));
InstallGlobalFunction(FpLieAlgebraEnumeration,COM_FUN(51));
InstallMethod(NiceAlgebraMonomorphism,"for a f.p. Lie algebra",true,[IsLieAlgebra and IsSubalgebraFpAlgebra],0,COM_FUN(52));
InstallGlobalFunction(NilpotentQuotientOfFpLieAlgebra,COM_FUN(53));
InstallGlobalFunction(FpLieAlgebraByCartanMatrix,COM_FUN(54));
InstallMethod(JenningsLieAlgebra,"for a p-group",true,[IsGroup],0,COM_FUN(55));
InstallMethod(PCentralLieAlgebra,"for a p-group",true,[IsGroup],0,COM_FUN(56));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/alglie.gi"

#F  file="lib/algliess.gi" crc=-128304571
RANK_FILTER_LIST  := [  ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/algliess.gi", -128304571 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/algliess.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/algliess.gi");
elif COM_RESULT = 3  then
Revision.algliess_gi:="@(#)$Id: algliess.gi,v 4.24 2003/10/19 09:54:44 gap Exp $";
AddendumSCTable:=COM_FUN(1);
SimpleLieAlgebraTypeA_G:=COM_FUN(2);
SimpleLieAlgebraTypeW:=COM_FUN(3);
SimpleLieAlgebraTypeS:=COM_FUN(4);
SimpleLieAlgebraTypeH:=COM_FUN(5);
SimpleLieAlgebraTypeK:=COM_FUN(6);
InstallGlobalFunction(SimpleLieAlgebra,COM_FUN(7));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/algliess.gi"

#F  file="lib/algsc.gi" crc=20862888
RANK_FILTER_LIST  := [ 28089094, 33, 20743782, 41, 41287156, 4, 32769, 4, 
  48868777, 5, 32769, 4, 34325017, 13, 15163243, 11, 41287156, 4, 15163243, 
  11, 15163243, 11, 34325017, 13, 34325017, 13, 15163243, 11, 15163243, 11, 
  34325017, 13, 34325017, 13, 15163243, 11, 15163243, 11, 34325017, 13, 
  34325017, 13, 15163243, 11, 15163243, 11, 34325017, 13, 34325017, 13, 
  15163243, 11, 15163243, 11, 34325017, 13, 34325017, 13, 64918210, 8, 
  15163243, 11, 64918210, 8, 34325017, 13, 15163243, 11, 64918210, 8, 
  34325017, 13, 64918210, 8, 17, 18, 15163243, 11, 17, 18, 34325017, 13, 
  15163243, 11, 17, 18, 34325017, 13, 17, 18, 15163243, 11, 30625149, 10, 
  34325017, 13, 30625149, 10, 15163243, 11, 15163243, 11, 15163243, 11, 
  15163243, 11, 15163243, 11, 46399174, 41, 56801934, 42, 7665940, 19, 
  37073015, 23, 37073015, 23, 37073015, 23, 62913301, 27, 62913301, 27, 1, 0, 
  62913301, 27, 1, 0, 50997183, 26, 30326485, 16, 50997183, 26, 8193, 2, 
  15163243, 11, 46434902, 11, 15163243, 11, 46434902, 11, 65077940, 12, 
  46434902, 11, 26393500, 41, 26393500, 41, 62163887, 7 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/algsc.gi", 20862888 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/algsc.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/algsc.gi");
elif COM_RESULT = 3  then
Revision.algsc_gi:="@(#)$Id: algsc.gi,v 4.29.2.4 2007/08/29 15:35:22 gap Exp $";
InstallMethod(IsWholeFamily,"for s. c. algebra elements collection",[IsSCAlgebraObjCollection and IsLeftModule and IsFreeLeftModule],COM_FUN(1));
InstallMethod(IsFullSCAlgebra,"for s. c. algebra elements collection",[IsSCAlgebraObjCollection and IsAlgebra],COM_FUN(2));
DeclareRepresentation("IsDenseCoeffVectorRep",IsPositionalObjectRep,[1]);
InstallMethod(ObjByExtRep,"for s. c. algebra elements family",[IsSCAlgebraObjFamily,IsHomogeneousList],COM_FUN(3));
InstallMethod(ObjByExtRep,"for s. c. alg. elms. family with coefficients family",[IsSCAlgebraObjFamily and IsFamilyOverFullCoefficientsFamily,IsHomogeneousList],COM_FUN(4));
InstallMethod(ExtRepOfObj,"for s. c. algebra element in dense coeff. vector rep.",[IsSCAlgebraObj and IsDenseCoeffVectorRep],COM_FUN(5));
InstallMethod(PrintObj,"for s. c. algebra element",[IsSCAlgebraObj],COM_FUN(6));
InstallMethod(One,"for family of s. c. algebra elements",[IsSCAlgebraObjFamily],COM_FUN(7));
InstallMethod(\=,"for s. c. algebra elements",IsIdenticalObj,[IsSCAlgebraObj,IsSCAlgebraObj],COM_FUN(8));
InstallMethod(\=,"for s. c. algebra elements in dense vector rep.",IsIdenticalObj,[IsSCAlgebraObj and IsDenseCoeffVectorRep,IsSCAlgebraObj and IsDenseCoeffVectorRep],COM_FUN(9));
InstallMethod(\<,"for s. c. algebra elements",IsIdenticalObj,[IsSCAlgebraObj,IsSCAlgebraObj],COM_FUN(10));
InstallMethod(\<,"for s. c. algebra elements in dense vector rep.",IsIdenticalObj,[IsSCAlgebraObj and IsDenseCoeffVectorRep,IsSCAlgebraObj and IsDenseCoeffVectorRep],0,COM_FUN(11));
InstallMethod(\+,"for s. c. algebra elements",IsIdenticalObj,[IsSCAlgebraObj,IsSCAlgebraObj],COM_FUN(12));
InstallMethod(\+,"for s. c. algebra elements in dense vector rep.",IsIdenticalObj,[IsSCAlgebraObj and IsDenseCoeffVectorRep,IsSCAlgebraObj and IsDenseCoeffVectorRep],COM_FUN(13));
InstallMethod(\-,"for s. c. algebra elements",IsIdenticalObj,[IsSCAlgebraObj,IsSCAlgebraObj],COM_FUN(14));
InstallMethod(\-,"for s. c. algebra elements in dense vector rep.",IsIdenticalObj,[IsSCAlgebraObj and IsDenseCoeffVectorRep,IsSCAlgebraObj and IsDenseCoeffVectorRep],COM_FUN(15));
InstallMethod(\*,"for s. c. algebra elements",IsIdenticalObj,[IsSCAlgebraObj,IsSCAlgebraObj],COM_FUN(16));
InstallMethod(\*,"for s. c. algebra elements in dense vector rep.",IsIdenticalObj,[IsSCAlgebraObj and IsDenseCoeffVectorRep,IsSCAlgebraObj and IsDenseCoeffVectorRep],COM_FUN(17));
InstallMethod(\*,"for ring element and s. c. algebra element",IsCoeffsElms,[IsRingElement,IsSCAlgebraObj],COM_FUN(18));
InstallMethod(\*,"for ring element and s. c. algebra element in dense vector rep.",IsCoeffsElms,[IsRingElement,IsSCAlgebraObj and IsDenseCoeffVectorRep],COM_FUN(19));
InstallMethod(\*,"for s. c. algebra element and ring element",IsElmsCoeffs,[IsSCAlgebraObj,IsRingElement],COM_FUN(20));
InstallMethod(\*,"for s. c. algebra element in dense vector rep. and ring element",IsElmsCoeffs,[IsSCAlgebraObj and IsDenseCoeffVectorRep,IsRingElement],COM_FUN(21));
InstallMethod(\*,"for integer and s. c. algebra element",[IsInt,IsSCAlgebraObj],COM_FUN(22));
InstallMethod(\*,"for integer and s. c. algebra element in dense vector rep.",[IsInt,IsSCAlgebraObj and IsDenseCoeffVectorRep],COM_FUN(23));
InstallMethod(\*,"for s. c. algebra element and integer",[IsSCAlgebraObj,IsInt],COM_FUN(24));
InstallMethod(\*,"for s. c. algebra element in dense vector rep. and integer",[IsSCAlgebraObj and IsDenseCoeffVectorRep,IsInt],COM_FUN(25));
InstallMethod(\/,"for s. c. algebra element and scalar",IsElmsCoeffs,[IsSCAlgebraObj,IsScalar],COM_FUN(26));
InstallMethod(\/,"for s. c. algebra element in dense vector rep. and scalar",IsElmsCoeffs,[IsSCAlgebraObj and IsDenseCoeffVectorRep,IsScalar],COM_FUN(27));
InstallMethod(ZeroOp,"for s. c. algebra element",[IsSCAlgebraObj],COM_FUN(28));
InstallMethod(AdditiveInverseOp,"for s. c. algebra element",[IsSCAlgebraObj],COM_FUN(29));
InstallOtherMethod(OneOp,"for s. c. algebra element",[IsSCAlgebraObj],COM_FUN(30));
InstallOtherMethod(InverseOp,"for s. c. algebra element",[IsSCAlgebraObj],COM_FUN(31));
InstallMethod(\in,"for s. c. algebra element, and full s. c. algebra",IsElmsColls,[IsSCAlgebraObj,IsFullSCAlgebra],COM_FUN(32));
BindGlobal("AlgebraByStructureConstantsArg",COM_FUN(33));
InstallGlobalFunction(AlgebraByStructureConstants,COM_FUN(34));
InstallGlobalFunction(LieAlgebraByStructureConstants,COM_FUN(35));
InstallAccessToGenerators(IsSCAlgebraObjCollection and IsFullSCAlgebra,"s.c. algebra containing the whole family",GeneratorsOfAlgebra);
InstallFlushableValue(QuaternionAlgebraData,[]);
InstallGlobalFunction(QuaternionAlgebra,COM_FUN(36));
InstallMethod(OneOp,"for a quaternion",[IsQuaternion and IsSCAlgebraObj],COM_FUN(37));
InstallMethod(InverseOp,"for a quaternion",[IsQuaternion and IsSCAlgebraObj],COM_FUN(38));
InstallMethod(ComplexConjugate,"for a quaternion",[IsQuaternion and IsSCAlgebraObj],COM_FUN(39));
InstallGlobalFunction(ComplexificationQuat,COM_FUN(40));
InstallGlobalFunction(OctaveAlgebra,COM_FUN(41));
InstallHandlingByNiceBasis("IsSCAlgebraObjSpace",rec(detect:=COM_FUN(42),NiceFreeLeftModuleInfo:=ReturnTrue,NiceVector:=COM_FUN(43),UglyVector:=COM_FUN(44)));
InstallMethod(MutableBasis,"for ring and collection of s. c. algebra elements",[IsRing,IsSCAlgebraObjCollection],MutableBasisViaNiceMutableBasisMethod2);
InstallOtherMethod(MutableBasis,"for ring, (possibly empty) list, and zero element",[IsRing,IsList,IsSCAlgebraObj],MutableBasisViaNiceMutableBasisMethod3);
InstallMethod(Coefficients,"for canonical basis of full s. c. algebra",IsCollsElms,[IsBasis and IsCanonicalBasisFullSCAlgebra,IsSCAlgebraObj],COM_FUN(45));
InstallMethod(LinearCombination,"for canonical basis of full s. c. algebra",[IsBasis and IsCanonicalBasisFullSCAlgebra,IsRowVector],COM_FUN(46));
InstallMethod(BasisVectors,"for canonical basis of full s. c. algebra",[IsBasis and IsCanonicalBasisFullSCAlgebra],COM_FUN(47));
InstallMethod(Basis,"for full s. c. algebra (delegate to `CanonicalBasis')",[IsFreeLeftModule and IsSCAlgebraObjCollection and IsFullSCAlgebra],CANONICAL_BASIS_FLAGS,CanonicalBasis);
InstallMethod(CanonicalBasis,"for full s. c. algebras",[IsFreeLeftModule and IsSCAlgebraObjCollection and IsFullSCAlgebra],COM_FUN(48));
InstallMethod(IsCanonicalBasisFullSCAlgebra,"for a basis",[IsBasis],COM_FUN(49));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/algsc.gi"

#F  file="lib/algmat.gi" crc=-112661752
RANK_FILTER_LIST  := [ 53865321, 19, 37386922, 19, 53865321, 19, 37386922, 
  19, 12321587, 29, 12321587, 29, 53865321, 19, 37386922, 19, 40033072, 46, 
  8134657, 5, 40033072, 46, 41951068, 17, 24644793, 32, 40033072, 46, 
  8134657, 5, 24644793, 32, 40033072, 46, 7383, 23, 40033072, 46, 41951068, 
  17, 31472285, 34, 40033072, 46, 7383, 23, 31472285, 34, 40033072, 46, 
  8134657, 5, 40033072, 46, 41951068, 17, 24644793, 32, 40033072, 46, 
  8134657, 5, 24644793, 32, 45189821, 49, 8134657, 5, 31489246, 48, 8134657, 
  5, 42262484, 44, 41951068, 17, 45189821, 49, 8134657, 5, 31489246, 48, 
  8134657, 5, 42262484, 44, 41951068, 17, 45189821, 49, 8134657, 5, 31489246, 
  48, 8134657, 5, 42262484, 44, 41951068, 17, 42262484, 44, 58412696, 30, 
  45189821, 49, 53888227, 49, 24644793, 32, 53888227, 49, 42262484, 44, 
  49326396, 52, 24644793, 32, 49326396, 52, 42262484, 44, 49345845, 75, 
  42262484, 44, 49345845, 75, 48094768, 22, 49345845, 75, 8134657, 5, 
  42281933, 67, 41951068, 17, 38457662, 46, 38457662, 46, 63333028, 52, 
  63333028, 52, 61077356, 73, 33246692, 42, 33246692, 42, 33246692, 42, 
  33246692, 42, 33246692, 42, 41951068, 17, 41951068, 17, 33246692, 42, 
  33246692, 42, 64918210, 8, 64918210, 8, 33246692, 42, 33246692, 42, 17, 18, 
  50997183, 26, 42262484, 44, 65077940, 12, 65077940, 12, 5, 1, 59785924, 34, 
  58412696, 30, 58412696, 30, 5, 1, 42262484, 44 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/algmat.gi", -112661752 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/algmat.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/algmat.gi");
elif COM_RESULT = 3  then
Revision.algmat_gi:="@(#)$Id: algmat.gi,v 4.32.4.1 2005/12/21 08:30:03 gap Exp $";
InstallOtherMethod(RingByGenerators,"for a list of matrices over a finite field",true,[IsFFECollCollColl],0,COM_FUN(1));
InstallOtherMethod(RingByGenerators,"for a list of matrices over the Cyclotomics",true,[IsCyclotomicCollCollColl],0,COM_FUN(2));
InstallOtherMethod(DefaultRingByGenerators,"for a list of matrices over a finite field",true,[IsFFECollCollColl],0,COM_FUN(3));
InstallOtherMethod(DefaultRingByGenerators,"for a list of matrices over the Cyclotomics",true,[IsCyclotomicCollCollColl],0,COM_FUN(4));
InstallOtherMethod(RingByGenerators,"for a list of Lie matrices over a finite field",true,[IsLieObjectCollection and IsMatrixCollection],0,COM_FUN(5));
InstallOtherMethod(DefaultRingByGenerators,"for a list of Lie matrices",true,[IsLieObjectCollection and IsMatrixCollection],0,COM_FUN(6));
InstallOtherMethod(RingWithOneByGenerators,"for a list of matrices over a finite field",true,[IsFFECollCollColl],0,COM_FUN(7));
InstallOtherMethod(RingWithOneByGenerators,"for a list of matrices over the Cyclotomics",true,[IsCyclotomicCollCollColl],0,COM_FUN(8));
InstallMethod(FLMLORByGenerators,"for division ring and list of ordinary matrices over it",IsElmsCollColls,[IsDivisionRing,IsCollection and IsList],0,COM_FUN(9));
InstallOtherMethod(FLMLORByGenerators,"for division ring, empty list, and square ordinary matrix",COM_FUN(10),[IsDivisionRing,IsList and IsEmpty,IsOrdinaryMatrix],0,COM_FUN(11));
InstallOtherMethod(FLMLORByGenerators,"for division ring, list of matrices over it, and ordinary matrix",COM_FUN(12),[IsDivisionRing,IsCollection and IsList,IsOrdinaryMatrix],0,COM_FUN(13));
InstallMethod(FLMLORByGenerators,"for division ring and list of Lie matrices over it",IsElmsCollLieColls,[IsDivisionRing,IsLieObjectCollection and IsList],0,COM_FUN(14));
InstallOtherMethod(FLMLORByGenerators,"for division ring, empty list, and Lie matrix",COM_FUN(15),[IsDivisionRing,IsList and IsEmpty,IsLieMatrix and IsLieObject],0,COM_FUN(16));
InstallOtherMethod(FLMLORByGenerators,"for division ring, list of Lie matrices over it, and Lie matrix",COM_FUN(17),[IsDivisionRing,IsLieObjectCollection and IsList,IsLieObject and IsLieMatrix],0,COM_FUN(18));
InstallMethod(FLMLORWithOneByGenerators,"for division ring and list of ordinary matrices over it",IsElmsCollColls,[IsDivisionRing,IsCollection and IsList],0,COM_FUN(19));
InstallOtherMethod(FLMLORWithOneByGenerators,"for division ring, empty list, and square ordinary matrix",COM_FUN(20),[IsDivisionRing,IsList and IsEmpty,IsOrdinaryMatrix],0,COM_FUN(21));
InstallOtherMethod(FLMLORWithOneByGenerators,"for division ring, list of matrices over it, and ordinary matrix",COM_FUN(22),[IsDivisionRing,IsCollection and IsList,IsOrdinaryMatrix],0,COM_FUN(23));
InstallMethod(TwoSidedIdealByGenerators,"for Gaussian matrix algebra and list of matrices",IsIdenticalObj,[IsMatrixFLMLOR and IsGaussianMatrixSpace,IsCollection and IsList],0,COM_FUN(24));
InstallMethod(TwoSidedIdealByGenerators,"for non-Gaussian matrix algebra and list of matrices",IsIdenticalObj,[IsMatrixFLMLOR and IsNonGaussianMatrixSpace,IsCollection and IsList],0,COM_FUN(25));
InstallMethod(TwoSidedIdealByGenerators,"for matrix algebra and empty list",true,[IsMatrixFLMLOR,IsList and IsEmpty],0,COM_FUN(26));
InstallMethod(LeftIdealByGenerators,"for Gaussian matrix algebra and list of matrices",IsIdenticalObj,[IsMatrixFLMLOR and IsGaussianMatrixSpace,IsCollection and IsList],0,COM_FUN(27));
InstallMethod(LeftIdealByGenerators,"for non-Gaussian matrix algebra and list of matrices",IsIdenticalObj,[IsMatrixFLMLOR and IsNonGaussianMatrixSpace,IsCollection and IsList],0,COM_FUN(28));
InstallMethod(LeftIdealByGenerators,"for matrix algebra and empty list",true,[IsMatrixFLMLOR,IsList and IsEmpty],0,COM_FUN(29));
InstallMethod(RightIdealByGenerators,"for Gaussian matrix algebra and list of matrices",IsIdenticalObj,[IsMatrixFLMLOR and IsGaussianMatrixSpace,IsCollection and IsList],0,COM_FUN(30));
InstallMethod(RightIdealByGenerators,"for non-Gaussian matrix algebra and list of matrices",IsIdenticalObj,[IsMatrixFLMLOR and IsNonGaussianMatrixSpace,IsCollection and IsList],0,COM_FUN(31));
InstallMethod(RightIdealByGenerators,"for matrix algebra and empty list",true,[IsMatrixFLMLOR,IsList and IsEmpty],0,COM_FUN(32));
InstallMethod(IsUnit,"for matrix FLMLOR and matrix",IsCollsElms,[IsMatrixFLMLOR,IsMatrix],0,COM_FUN(33));
InstallMethod(RadicalOfAlgebra,"for associative Gaussian matrix algebra",true,[IsAlgebra and IsGaussianMatrixSpace and IsMatrixFLMLOR],0,COM_FUN(34));
CentralizerInAssociativeGaussianMatrixAlgebra:=COM_FUN(35);
InstallMethod(CentralizerOp,"for associative Gaussian matrix FLMLOR, and ordinary matrix",IsCollsElms,[IsMatrixFLMLOR and IsAssociative and IsGaussianSpace,IsOrdinaryMatrix],0,COM_FUN(36));
InstallMethod(CentralizerOp,"for associative Gaussian matrix FLMLOR, and FLMLOR",IsIdenticalObj,[IsMatrixFLMLOR and IsAssociative and IsGaussianSpace,IsMatrixFLMLOR],0,COM_FUN(37));
InstallMethod(CentralizerOp,"for associative Gaussian matrix FLMLOR-with-one, and ordinary matrix",IsCollsElms,[IsMatrixFLMLOR and IsFLMLORWithOne and IsAssociative and IsGaussianSpace,IsOrdinaryMatrix],0,COM_FUN(38));
InstallMethod(CentralizerOp,"for associative Gaussian matrix FLMLOR-with-one, and FLMLOR",IsIdenticalObj,[IsMatrixFLMLOR and IsFLMLORWithOne and IsAssociative and IsGaussianSpace,IsMatrixFLMLOR],0,COM_FUN(39));
InstallGlobalFunction(FullMatrixAlgebraCentralizer,COM_FUN(40));
InstallMethod(CentralizerOp,"for full (associative) matrix FLMLOR, and FLMLOR",IsIdenticalObj,[IsMatrixFLMLOR and IsFLMLORWithOne and IsAssociative and IsGaussianSpace and IsFullMatrixModule,IsMatrixFLMLOR],0,COM_FUN(41));
InstallMethod(CentralizerOp,"for full (associative) matrix FLMLOR, and left module",IsIdenticalObj,[IsMatrixFLMLOR and IsFLMLORWithOne and IsAssociative and IsGaussianSpace and IsFullMatrixModule,IsLeftModule],0,COM_FUN(42));
InstallMethod(CentralizerOp,"for full (associative) matrix FLMLOR, and list of matrices",IsIdenticalObj,[IsMatrixFLMLOR and IsFLMLORWithOne and IsAssociative and IsGaussianSpace and IsFullMatrixModule,IsCollection and IsList],0,COM_FUN(43));
InstallMethod(CentralizerOp,"for full (associative) matrix FLMLOR, and empty list",true,[IsMatrixFLMLOR and IsFullMatrixModule,IsList and IsEmpty],0,COM_FUN(44));
InstallGlobalFunction(FullMatrixFLMLOR,COM_FUN(45));
InstallGlobalFunction(FullMatrixLieFLMLOR,COM_FUN(46));
InstallOtherMethod(DirectSumOfAlgebras,"for two associative matrix FLMLORs",IsIdenticalObj,[IsMatrixFLMLOR and IsAssociative,IsMatrixFLMLOR and IsAssociative],0,COM_FUN(47));
InstallOtherMethod(DirectSumOfAlgebras,"for two matrix Lie FLMLORs",IsIdenticalObj,[IsMatrixFLMLOR and IsLieAlgebra,IsMatrixFLMLOR and IsLieAlgebra],0,COM_FUN(48));
InstallMethod(Units,"for a full matrix algebra (over a finite field)",[IsAlgebra and IsFullMatrixModule and IsFFECollCollColl],COM_FUN(49));
InstallGlobalFunction(EmptyMatrix,COM_FUN(50));
InstallMethod(\+,"for two empty matrices",IsIdenticalObj,[IsMatrix and IsEmpty,IsMatrix and IsEmpty],0,COM_FUN(51));
InstallOtherMethod(\*,"for two empty matrices",IsIdenticalObj,[IsMatrix and IsEmpty,IsMatrix and IsEmpty],0,COM_FUN(52));
InstallOtherMethod(\*,"for empty matrix, and empty list",true,[IsMatrix and IsEmpty,IsList and IsEmpty],0,COM_FUN(53));
InstallOtherMethod(\*,"for empty list, and empty matrix",true,[IsList and IsEmpty,IsMatrix and IsEmpty],0,COM_FUN(54));
InstallOtherMethod(\*,"for empty matrix, and ring element",true,[IsMatrix and IsEmpty,IsRingElement],0,COM_FUN(55));
InstallOtherMethod(\*,"for ring element, and empty matrix",true,[IsRingElement,IsMatrix and IsEmpty],0,COM_FUN(56));
InstallMethod(\^,"for empty matrix, and integer",true,[IsMatrix and IsEmpty,IsInt],0,COM_FUN(57));
InstallMethod(NullAlgebra,"for a ring",true,[IsRing],0,COM_FUN(58));
InstallMethod(RepresentativeLinearOperation,"for a matrix FLMLOR, two row vectors, and `OnRight'",IsCollCollsElmsElmsX,[IsMatrixFLMLOR,IsRowVector,IsRowVector,IsFunction],0,COM_FUN(59));
InstallMethod(RepresentativeLinearOperation,"for a matrix FLMLOR, two lists of row vectors, and `OnTuples'",IsCollsElmsElmsX,[IsFLMLOR,IsMatrix,IsMatrix,IsFunction],0,COM_FUN(60));
InstallMethod(IsomorphismMatrixFLMLOR,"for a matrix FLMLOR",true,[IsMatrixFLMLOR],0,IdentityMapping);
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/algmat.gi"

#F  file="lib/liefam.gi" crc=14813825
RANK_FILTER_LIST  := [ 51101810, 3, 32505857, 2, 64918210, 8, 1014924, 13, 
  32488978, 33, 1014924, 13, 1014924, 13, 1014924, 13, 1014924, 13, 1014924, 
  13, 1014924, 13, 1014924, 13, 64918210, 8, 64918210, 8, 1014924, 13, 
  1014924, 13, 1014924, 13, 1014924, 13, 64918210, 8, 64918210, 8, 1014924, 
  13, 1014924, 13, 1014924, 13, 1014924, 13, 64918210, 8, 64918210, 8, 
  1014924, 13, 1014924, 13, 7665940, 19, 1014924, 13, 67107995, 11, 67107995, 
  11, 1014924, 13, 32488978, 33, 7665940, 19, 32488978, 33, 32488978, 33, 
  7665940, 19, 32488978, 33, 65077940, 12, 17, 18, 62499877, 2, 1985, 1, 
  34795321, 10, 1, 0, 34795321, 10, 1014924, 13, 67107995, 11, 50997183, 26, 
  67108070, 16, 50997183, 26, 8193, 2, 67107995, 11, 14731176, 27, 14731176, 
  27, 1, 0, 14731176, 27, 1, 0, 64079747, 42, 7383, 23, 64079747, 42, 7383, 
  23, 64079747, 42, 7383, 23, 64079747, 42, 41951068, 17, 64079747, 42, 
  41951068, 17, 64079747, 42, 41951068, 17 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/liefam.gi", 14813825 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/liefam.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/liefam.gi");
elif COM_RESULT = 3  then
Revision.liefam_gi:="@(#)$Id: liefam.gi,v 4.28 2002/04/15 10:04:54 sal Exp $";
InstallMethod(LieFamily,"for family of ring elements",true,[IsRingElementFamily],0,COM_FUN(1));
InstallMethod(LieFamily,"for a collections family (special case of Lie matrices)",true,[IsCollectionFamily],0,COM_FUN(2));
InstallMethod(LieObject,"for a ring element",true,[IsRingElement],0,COM_FUN(3));
InstallMethod(PrintObj,"for a Lie object in default representation",true,[IsLieObject and IsPackedElementDefaultRep],SUM_FLAGS,COM_FUN(4));
InstallMethod(ViewObj,"for a Lie matrix in default representation",true,[IsLieMatrix and IsPackedElementDefaultRep],SUM_FLAGS,COM_FUN(5));
InstallMethod(\=,"for two Lie objects in default representation",IsIdenticalObj,[IsLieObject and IsPackedElementDefaultRep,IsLieObject and IsPackedElementDefaultRep],0,COM_FUN(6));
InstallMethod(\<,"for two Lie objects in default representation",IsIdenticalObj,[IsLieObject and IsPackedElementDefaultRep,IsLieObject and IsPackedElementDefaultRep],0,COM_FUN(7));
InstallMethod(\+,"for two Lie objects in default representation",IsIdenticalObj,[IsLieObject and IsPackedElementDefaultRep,IsLieObject and IsPackedElementDefaultRep],0,COM_FUN(8));
InstallMethod(\+,"for Lie object in default representation, and ring element",true,[IsLieObject and IsPackedElementDefaultRep,IsRingElement],0,COM_FUN(9));
InstallMethod(\+,"for ring element, and Lie object in default representation",true,[IsRingElement,IsLieObject and IsPackedElementDefaultRep],0,COM_FUN(10));
InstallMethod(\-,"for two Lie objects in default representation",IsIdenticalObj,[IsLieObject and IsPackedElementDefaultRep,IsLieObject and IsPackedElementDefaultRep],0,COM_FUN(11));
InstallMethod(\-,"for Lie object in default representation, and ring element",true,[IsLieObject and IsPackedElementDefaultRep,IsRingElement],0,COM_FUN(12));
InstallMethod(\-,"for ring element, and Lie object in default representation",true,[IsRingElement,IsLieObject and IsPackedElementDefaultRep],0,COM_FUN(13));
InstallMethod(\*,"for two Lie objects in default representation",IsIdenticalObj,[IsLieObject and IsPackedElementDefaultRep,IsLieObject and IsPackedElementDefaultRep],0,COM_FUN(14));
InstallMethod(\*,"for Lie object in default representation, and ring element",true,[IsLieObject and IsPackedElementDefaultRep,IsRingElement],0,COM_FUN(15));
InstallMethod(\*,"for ring element, and Lie object in default representation",true,[IsRingElement,IsLieObject and IsPackedElementDefaultRep],0,COM_FUN(16));
InstallMethod(\^,"for Lie object in default representation, and positive integer",true,[IsLieObject and IsPackedElementDefaultRep,IsPosInt],0,COM_FUN(17));
InstallMethod(ZeroOp,"for Lie object in default representation",true,[IsLieObject and IsPackedElementDefaultRep],SUM_FLAGS,COM_FUN(18));
InstallOtherMethod(OneOp,"for Lie object",true,[IsLieObject],0,ReturnFail);
InstallOtherMethod(InverseOp,"for Lie object",true,[IsLieObject],0,ReturnFail);
InstallMethod(AdditiveInverseOp,"for Lie object in default representation",true,[IsLieObject and IsPackedElementDefaultRep],0,COM_FUN(19));
InstallMethod(\[\],"for Lie matrix in default representation, and positive integer",true,[IsLieMatrix and IsPackedElementDefaultRep,IsPosInt],0,COM_FUN(20));
InstallMethod(Length,"for Lie matrix in default representation",true,[IsLieMatrix and IsPackedElementDefaultRep],0,COM_FUN(21));
InstallMethod(IsBound\[\],"for Lie matrix in default representation, and integer",true,[IsLieMatrix and IsPackedElementDefaultRep,IsPosInt],0,COM_FUN(22));
InstallMethod(Position,"for Lie matrix in default representation, row vector, and integer",true,[IsLieMatrix and IsPackedElementDefaultRep,IsRowVector,IsInt],0,COM_FUN(23));
DeclareRepresentation("IsLieEmbeddingRep",IsAttributeStoringRep,["packedType"]);
InstallOtherMethod(Embedding,"for two families, the first with known Lie family",true,[IsFamily and HasLieFamily,IsFamily],0,COM_FUN(24));
InstallMethod(ImagesElm,"for Lie embedding and object",FamSourceEqFamElm,[IsGeneralMapping and IsLieEmbeddingRep,IsObject],0,COM_FUN(25));
InstallMethod(PreImagesElm,"for Lie embedding and Lie object in default representation",FamRangeEqFamElm,[IsGeneralMapping and IsLieEmbeddingRep,IsLieObject and IsPackedElementDefaultRep],0,COM_FUN(26));
InstallOtherMethod(IsUnit,"for a Lie object (return `false')",true,[IsLieObject],0,ReturnFalse);
InstallMethod(MutableBasis,"for ring and collection of Lie elements",COM_FUN(27),[IsRing,IsLieObjectCollection],0,MutableBasisViaNiceMutableBasisMethod2);
InstallOtherMethod(MutableBasis,"for ring, (possibly empty) list, and Lie zero",COM_FUN(28),[IsRing,IsList,IsLieObject],0,MutableBasisViaNiceMutableBasisMethod3);
InstallHandlingByNiceBasis("IsLieObjectsModule",rec(detect:=COM_FUN(29),NiceFreeLeftModuleInfo:=ReturnFalse,NiceVector:=COM_FUN(30),UglyVector:=COM_FUN(31)));
IdealByGeneratorsForLieAlgebra:=COM_FUN(32);
InstallMethod(TwoSidedIdealByGenerators,"for Lie algebra and collection of Lie objects",IsIdenticalObj,[IsLieAlgebra,IsLieObjectCollection and IsList],0,IdealByGeneratorsForLieAlgebra);
InstallMethod(LeftIdealByGenerators,"for Lie algebra and collection of Lie objects",IsIdenticalObj,[IsLieAlgebra,IsLieObjectCollection and IsList],0,IdealByGeneratorsForLieAlgebra);
InstallMethod(RightIdealByGenerators,"for Lie algebra and collection of Lie objects",IsIdenticalObj,[IsLieAlgebra,IsLieObjectCollection and IsList],0,IdealByGeneratorsForLieAlgebra);
InstallMethod(TwoSidedIdealByGenerators,"for Lie algebra and empty list",true,[IsLieAlgebra,IsList and IsEmpty],0,IdealByGeneratorsForLieAlgebra);
InstallMethod(LeftIdealByGenerators,"for Lie algebra and empty list",true,[IsLieAlgebra,IsList and IsEmpty],0,IdealByGeneratorsForLieAlgebra);
InstallMethod(RightIdealByGenerators,"for Lie algebra and empty list",true,[IsLieAlgebra,IsList and IsEmpty],0,IdealByGeneratorsForLieAlgebra);
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/liefam.gi"

#F  file="lib/algrep.gi" crc=125335276
RANK_FILTER_LIST  := [ 47018565, 27, 47018565, 27, 59423269, 10, 14581474, 2, 
  1, 0, 57526177, 36, 5, 1, 32769, 4, 57526177, 36, 5, 1, 32769, 4, 67108760, 
  5, 57526177, 36, 5, 1, 32769, 4, 57526177, 36, 5, 1, 32769, 4, 67108760, 5, 
  57526177, 36, 57526177, 36, 5, 1, 5, 1, 32769, 4, 57526177, 36, 57526177, 
  36, 5, 1, 5, 1, 32769, 4, 67108760, 5, 57526177, 36, 5, 1, 56482656, 25, 
  57526177, 36, 5, 1, 56482656, 25, 57526177, 36, 57526177, 36, 5, 1, 5, 1, 
  56482656, 25, 50997183, 26, 40845177, 13, 50997183, 26, 8193, 2, 58407461, 
  8, 50807940, 3, 50807940, 3, 50807941, 5, 63198130, 7, 50807941, 5, 
  63198130, 7, 57644789, 24, 59423269, 10, 59423269, 10, 59423269, 10, 
  59423269, 10, 59423269, 10, 59423269, 10, 59423269, 10, 59423269, 10, 
  63198130, 7, 63198130, 7, 59423269, 10, 59423269, 10, 59423269, 10, 
  30625149, 10, 30625149, 10, 59423269, 10, 59423269, 10, 1014924, 13, 
  65077940, 12, 65077940, 12, 1014924, 13, 64918210, 8, 30178755, 11, 
  50558714, 11, 64918210, 8, 7312631, 25, 57621898, 28, 62651832, 8, 
  59423269, 10, 57621898, 28, 40853369, 20, 57621898, 28, 40853369, 20, 
  57621898, 28, 57621898, 28, 7312631, 25, 40853369, 20, 7312631, 25, 
  40853369, 20, 67108760, 5, 57526177, 36, 15260804, 21, 57526177, 36, 
  15260804, 21, 57526177, 36, 57526177, 36, 57644789, 24, 57526177, 36, 
  57644789, 24, 57526177, 36, 57526177, 36, 57644789, 24, 57644789, 24, 
  47018565, 27, 8126465, 2, 47018565, 27, 57644789, 24, 62651832, 8, 1, 0, 
  62651832, 8, 1, 0, 1, 0, 58719342, 2, 8193, 2, 50533730, 10, 50533730, 10, 
  50533730, 10, 50533730, 10, 50533730, 10, 50533730, 10, 64918210, 8, 
  64918210, 8, 50533730, 10, 50533730, 10, 50533730, 10, 50533730, 10, 
  50533730, 10, 12581473, 28, 62921823, 20, 12581473, 28, 62921823, 20, 
  12581473, 28, 33210756, 9, 50533730, 10, 2299279, 11, 50330764, 9, 16385, 
  3, 56482656, 25, 56482656, 25, 16385, 3, 57644789, 24, 57644789, 24, 
  19076690, 11, 67108175, 9, 48094768, 22, 17, 18, 57644789, 24, 17, 18, 
  19076495, 11, 67107980, 9, 48094768, 22, 17, 18, 57644789, 24, 17, 18, 
  58240635, 2, 8193, 2, 4764872, 10, 3749064, 8, 4764872, 10, 4764872, 10, 
  4764872, 10, 4764872, 10, 4764872, 10, 64918210, 8, 64918210, 8, 4764872, 
  10, 4764872, 10, 4764872, 10, 4764872, 10, 4764872, 10, 15577959, 28, 
  32769, 4, 15577959, 28, 32769, 4, 15577959, 28, 4258585, 9, 3749064, 8, 
  50997183, 26, 17, 18, 59426119, 10, 6222977, 2, 8193, 2, 59426119, 10, 
  59426119, 10, 59426119, 10, 59426119, 10, 59426119, 10, 59426119, 10, 
  64918210, 8, 64918210, 8, 59426119, 10, 59426119, 10, 59426119, 10, 
  59426119, 10, 59426119, 10, 66149111, 27, 66149111, 27, 1, 0, 66149111, 27, 
  1, 0, 16385, 3, 57644789, 24, 57644789, 24, 57644789, 24, 16776722, 23, 
  16776722, 23 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/algrep.gi", 125335276 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/algrep.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/algrep.gi");
elif COM_RESULT = 3  then
Revision.algrep_gi:="@(#)$Id: algrep.gi,v 4.31.2.2 2005/08/24 14:15:12 sal Exp $";
InstallMethod(PrintObj,"for algebra module",true,[IsVectorSpace and IsAlgebraModule],0,COM_FUN(1));
InstallMethod(ViewObj,"for algebra module",true,[IsVectorSpace and IsAlgebraModule],0,COM_FUN(2));
InstallMethod(ExtRepOfObj,"for algebra module element in packed element rep",true,[IsAlgebraModuleElement and IsPackedElementDefaultRep],0,COM_FUN(3));
InstallMethod(ObjByExtRep,"for algebra module elements family, object",true,[IsAlgebraModuleElementFamily,IsObject],0,COM_FUN(4));
BindGlobal("BasisOfAlgebraModule",COM_FUN(5));
InstallMethod(LeftAlgebraModuleByGenerators,"for algebra, function of 2 args, module generators",true,[IsAlgebra,IS_FUNCTION,IsHomogeneousList],0,COM_FUN(6));
InstallOtherMethod(LeftAlgebraModuleByGenerators,"for algebra, function of 2 args, generators, string",true,[IsAlgebra,IS_FUNCTION,IsHomogeneousList,IsString],0,COM_FUN(7));
InstallMethod(RightAlgebraModuleByGenerators,"for algebra, function of 2 args, module generators",true,[IsAlgebra,IS_FUNCTION,IsHomogeneousList],0,COM_FUN(8));
InstallOtherMethod(RightAlgebraModuleByGenerators,"for algebra, function of 2 args, generators, string",true,[IsAlgebra,IS_FUNCTION,IsHomogeneousList,IsString],0,COM_FUN(9));
InstallMethod(BiAlgebraModuleByGenerators,"for 2 algebras, function of 2 args, function of 2 args, module generators",true,[IsAlgebra,IsAlgebra,IS_FUNCTION,IS_FUNCTION,IsHomogeneousList],0,COM_FUN(10));
InstallOtherMethod(BiAlgebraModuleByGenerators,"for 2 algebras, function of 2 args, function of 2 args, generators, string",true,[IsAlgebra,IsAlgebra,IS_FUNCTION,IS_FUNCTION,IsHomogeneousList,IsString],0,COM_FUN(11));
InstallMethod(LeftAlgebraModule,"for algebra, function of 2 args, underlying space",true,[IsAlgebra,IS_FUNCTION,IsVectorSpace],0,COM_FUN(12));
InstallMethod(RightAlgebraModule,"for algebra, function of 2 args, underlying space",true,[IsAlgebra,IS_FUNCTION,IsVectorSpace],0,COM_FUN(13));
InstallMethod(BiAlgebraModule,"for 2 algebras, function of 2 args, function of 2 args, module generators",true,[IsAlgebra,IsAlgebra,IS_FUNCTION,IS_FUNCTION,IsVectorSpace],0,COM_FUN(14));
DeclareRepresentation("IsMutableBasisViaUnderlyingMutableBasisRep",IsComponentObjectRep,["moduleElementsFam","underlyingMutableBasis"]);
InstallMethod(MutableBasis,"for ring and vectors",true,[IsRing,IsAlgebraModuleElementCollection],0,COM_FUN(15));
InstallOtherMethod(MutableBasis,"for ring, list and zero",true,[IsRing,IsList,IsAlgebraModuleElement],0,COM_FUN(16));
InstallMethod(PrintObj,"for mutable basis with underlying mutable basis",true,[IsMutableBasis and IsMutableBasisViaUnderlyingMutableBasisRep],0,COM_FUN(17));
InstallOtherMethod(BasisVectors,"for mutable basis with underlying mutable basis",true,[IsMutableBasis and IsMutableBasisViaUnderlyingMutableBasisRep],0,COM_FUN(18));
InstallMethod(CloseMutableBasis,"for mutable basis with underlying mutable basis, and vector",IsCollsElms,[IsMutableBasis and IsMutable and IsMutableBasisViaUnderlyingMutableBasisRep,IsVector],0,COM_FUN(19));
InstallMethod(IsContainedInSpan,"for mutable basis with underlying mutable basis, and vector",IsCollsElms,[IsMutableBasis and IsMutable and IsMutableBasisViaUnderlyingMutableBasisRep,IsVector],0,COM_FUN(20));
InstallMethod(ActingAlgebra,"for an algebra module",true,[IsAlgebraModule],0,COM_FUN(21));
InstallMethod(PrintObj,"for algebra module element in packed representation",true,[IsAlgebraModuleElement and IsPackedElementDefaultRep],0,COM_FUN(22));
InstallMethod(\=,"for two algebra module elements in packed representation",IsIdenticalObj,[IsAlgebraModuleElement and IsPackedElementDefaultRep,IsAlgebraModuleElement and IsPackedElementDefaultRep],0,COM_FUN(23));
InstallMethod(\<,"for two algebra module elements in packed representation",IsIdenticalObj,[IsAlgebraModuleElement and IsPackedElementDefaultRep,IsAlgebraModuleElement and IsPackedElementDefaultRep],0,COM_FUN(24));
InstallMethod(\+,"for two algebra module elements in packed representation",IsIdenticalObj,[IsAlgebraModuleElement and IsPackedElementDefaultRep,IsAlgebraModuleElement and IsPackedElementDefaultRep],0,COM_FUN(25));
InstallMethod(\+,"for an algebra module element in packed representation and a vector",true,[IsAlgebraModuleElement and IsPackedElementDefaultRep,IsVector],0,COM_FUN(26));
InstallMethod(\+,"for a vector and an algebra module element in packed representation",true,[IsVector,IsAlgebraModuleElement and IsPackedElementDefaultRep],0,COM_FUN(27));
InstallMethod(AdditiveInverseOp,"for an algebra module element in packed representation",true,[IsAlgebraModuleElement and IsPackedElementDefaultRep],0,COM_FUN(28));
InstallMethod(\*,"for an algebra module element in packed representation and a scalar",true,[IsAlgebraModuleElement and IsPackedElementDefaultRep,IsScalar],0,COM_FUN(29));
InstallMethod(\*,"for a scalar and an algebra module element in packed representation",true,[IsScalar,IsAlgebraModuleElement and IsPackedElementDefaultRep],0,COM_FUN(30));
InstallMethod(ZeroOp,"for an algebra module element in packed representation",true,[IsAlgebraModuleElement and IsPackedElementDefaultRep],0,COM_FUN(31));
InstallMethod(\*,"for Lie object and row vector",true,[IsLieObject and IsPackedElementDefaultRep,IsRowVector],0,COM_FUN(32));
InstallMethod(\*,"for row vector and Lie object",true,[IsRowVector,IsLieObject and IsPackedElementDefaultRep],0,COM_FUN(33));
InstallOtherMethod(\^,"for an algebra element and an element of an algebra module",COM_FUN(34),[IsRingElement,IsLeftAlgebraModuleElement and IsPackedElementDefaultRep],0,COM_FUN(35));
InstallOtherMethod(\^,"for an algebra element and an element of an algebra module",COM_FUN(36),[IsRightAlgebraModuleElement and IsPackedElementDefaultRep,IsRingElement],0,COM_FUN(37));
InstallMethod(Basis,"for an algebra module",true,[IsFreeLeftModule and IsAlgebraModule],0,COM_FUN(38));
InstallMethod(Basis,"for a space of algebra module elements",true,[IsFreeLeftModule and IsAlgebraModuleElementCollection],0,COM_FUN(39));
InstallMethod(Coefficients,"for basis of a space of algebra module elements, and algebra module element",true,[IsBasisOfAlgebraModuleElementSpace,IsAlgebraModuleElement and IsPackedElementDefaultRep],0,COM_FUN(40));
InstallMethod(Basis,"for a space of algebra module elements and a collection of algebra module el\
ements",IsIdenticalObj,[IsFreeLeftModule and IsAlgebraModuleElementCollection,IsAlgebraModuleElementCollection and IsList],0,COM_FUN(41));
InstallMethod(BasisNC,"for a space of algebra module elements and a collection of algebra module el\
ements",IsIdenticalObj,[IsFreeLeftModule and IsAlgebraModuleElementCollection,IsAlgebraModuleElementCollection and IsList],0,COM_FUN(42));
InstallMethod(IsFiniteDimensional,"for a space of algebra module elements",true,[IsFreeLeftModule and IsAlgebraModuleElementCollection],0,COM_FUN(43));
InstallMethod(GeneratorsOfLeftModule,"for a space of algebra module elements",true,[IsFreeLeftModule and IsAlgebraModuleElementCollection],0,COM_FUN(44));
InstallMethod(SubAlgebraModule,"for algebra module, and a list of submodule generators",IsIdenticalObj,[IsFreeLeftModule and IsAlgebraModule,IsAlgebraModuleElementCollection and IsList],0,COM_FUN(45));
InstallOtherMethod(SubAlgebraModule,"for algebra module, and a list of submodule generators, and string",COM_FUN(46),[IsFreeLeftModule and IsAlgebraModule,IsAlgebraModuleElementCollection and IsList,IsString],0,COM_FUN(47));
InstallMethod(LeftModuleByHomomorphismToMatAlg,"for an algebra and a homomorphism to a matrix algebra",true,[IsAlgebra,IsAlgebraHomomorphism],0,COM_FUN(48));
InstallMethod(RightModuleByHomomorphismToMatAlg,"for an algebra and a homomorphism to a matrix algebra",true,[IsAlgebra,IsAlgebraHomomorphism],0,COM_FUN(49));
InstallMethod(AdjointModule,"for an algebra",true,[IsAlgebra],0,COM_FUN(50));
InstallMethod(FaithfulModule,"for an algebra",true,[IsAlgebra],0,COM_FUN(51));
InstallMethod(ModuleByRestriction,"for an algebra module and a subalgebra",true,[IsAlgebraModule,IsAlgebra],0,COM_FUN(52));
InstallOtherMethod(ModuleByRestriction,"for a bi-algebra module and a subalgebra and a subalgebra",true,[IsAlgebraModule,IsAlgebra,IsAlgebra],0,COM_FUN(53));
InstallMethod(NaturalHomomorphismBySubAlgebraModule,"for algebra module and a submodule",IsIdenticalObj,[IsAlgebraModule,IsAlgebraModule],0,COM_FUN(54));
InstallOtherMethod(\/,"for an algebra module and collection",IsIdenticalObj,[IsVectorSpace and IsAlgebraModule,IsCollection],0,COM_FUN(55));
InstallOtherMethod(\/,"for two algebra modules",IsIdenticalObj,[IsVectorSpace and IsAlgebraModule,IsAlgebraModule],0,COM_FUN(56));
InstallMethod(MatrixOfAction,"for a basis of an algebra module and an algebra element",true,[IsBasisOfAlgebraModuleElementSpace,IsObject],0,COM_FUN(57));
InstallOtherMethod(MatrixOfAction,"for a basis of an algebra module, an algebra element and a side",true,[IsBasisOfAlgebraModuleElementSpace,IsObject,IsObject],0,COM_FUN(58));
DeclareRepresentation("IsMonomialElementRep",IsPositionalObjectRep,[1,2]);
InstallMethod(ObjByExtRep,"for a family of monomial elements and a list",true,[IsMonomialElementFamily,IsList],0,COM_FUN(59));
InstallMethod(ExtRepOfObj,"for a monomial element",true,[IsMonomialElement and IsMonomialElementRep],0,COM_FUN(60));
InstallMethod(ZeroOp,"for monomial elements",true,[IsMonomialElement and IsMonomialElementRep],0,COM_FUN(61));
InstallMethod(\+,"for monomial elements",IsIdenticalObj,[IsMonomialElement and IsMonomialElementRep,IsMonomialElement and IsMonomialElementRep],0,COM_FUN(62));
InstallMethod(AdditiveInverseOp,"for a monomial element",true,[IsMonomialElement and IsMonomialElementRep],0,COM_FUN(63));
InstallMethod(\*,"for a monomial element and a scalar",true,[IsMonomialElement and IsMonomialElementRep,IsRingElement],0,COM_FUN(64));
InstallMethod(\*,"for a scalar and a monomial element",true,[IsRingElement,IsMonomialElement and IsMonomialElementRep],0,COM_FUN(65));
InstallMethod(\<,"for monomial elements",IsIdenticalObj,[IsMonomialElement and IsMonomialElementRep,IsMonomialElement and IsMonomialElementRep],0,COM_FUN(66));
InstallMethod(\=,"for monomial elements",IsIdenticalObj,[IsMonomialElement and IsMonomialElementRep,IsMonomialElement and IsMonomialElementRep],0,COM_FUN(67));
TriangulizeMonomialElementList:=COM_FUN(68);
DeclareRepresentation("IsBasisOfMonomialSpaceRep",IsComponentObjectRep,["echelonBasis","heads","baseChange","zeroCoefficient"]);
BindGlobal("BasisOfMonomialSpace",COM_FUN(69));
InstallMethod(Basis,"for a space of monomial elements and a list of tensor elements",IsIdenticalObj,[IsFreeLeftModule and IsMonomialElementCollection,IsMonomialElementCollection and IsList],SUM_FLAGS,COM_FUN(70));
InstallMethod(BasisNC,"for a space of monomial elements and a list of monomial elements",IsIdenticalObj,[IsFreeLeftModule and IsMonomialElementCollection,IsMonomialElementCollection and IsList],SUM_FLAGS,COM_FUN(71));
InstallMethod(Basis,"for a space of monomial elements",true,[IsFreeLeftModule and IsMonomialElementCollection],SUM_FLAGS,COM_FUN(72));
InstallMethod(Coefficients,"for basis of a monomial space, and a vector",IsCollsElms,[IsBasis and IsBasisOfMonomialSpaceRep,IsMonomialElement and IsMonomialElementRep],SUM_FLAGS,COM_FUN(73));
InstallMethod(PrintObj,"for tensor elements",true,[IsTensorElement and IsMonomialElementRep],0,COM_FUN(74));
InstallMethod(ConvertToNormalFormMonomialElement,"for a tensor element",true,[IsTensorElement],0,COM_FUN(75));
InstallMethod(TensorProduct,"for a list of finite dimensional vector spaces",true,[IsDenseList],0,COM_FUN(76));
InstallOtherMethod(TensorProduct,"for two vector spaces",true,[IsVectorSpace,IsVectorSpace],0,COM_FUN(77));
InstallMethod(TensorProductOfAlgebraModules,"for a list of algebra modules",true,[IsDenseList],0,COM_FUN(78));
InstallOtherMethod(TensorProductOfAlgebraModules,"for two algebra modules",true,[IsAlgebraModule,IsAlgebraModule],0,COM_FUN(79));
InstallMethod(PrintObj,"for wedge elements",true,[IsWedgeElement and IsMonomialElementRep],0,COM_FUN(80));
InstallMethod(ConvertToNormalFormMonomialElement,"for a wedge element",true,[IsWedgeElement],0,COM_FUN(81));
InstallMethod(ExteriorPower,"for a vector space and an integer",true,[IsLeftModule,IsInt],0,COM_FUN(82));
InstallMethod(ExteriorPowerOfAlgebraModule,"for an algebra module and an integer",true,[IsAlgebraModule,IsInt],0,COM_FUN(83));
InstallMethod(PrintObj,"for symmetric elements",true,[IsSymmetricPowerElement and IsMonomialElementRep],0,COM_FUN(84));
InstallMethod(ConvertToNormalFormMonomialElement,"for a symmetric element",true,[IsSymmetricPowerElement],0,COM_FUN(85));
InstallMethod(SymmetricPower,"for an algebra module and an integer",true,[IsLeftModule,IsInt],0,COM_FUN(86));
InstallMethod(SymmetricPowerOfAlgebraModule,"for an algebra module and an integer",true,[IsAlgebraModule,IsInt],0,COM_FUN(87));
InstallMethod(ObjByExtRep,"for a sparse rowspace element family and a list",true,[IsSparseRowSpaceElementFamily,IsList],0,COM_FUN(88));
InstallMethod(ExtRepOfObj,"for a sparse rowspace element",true,[IsSparseRowSpaceElement and IsPackedElementDefaultRep],0,COM_FUN(89));
InstallMethod(PrintObj,"for a sparse rowspace element",true,[IsSparseRowSpaceElement],0,COM_FUN(90));
InstallMethod(ZeroOp,"for sparse rowspace elements",true,[IsSparseRowSpaceElement and IsPackedElementDefaultRep],0,COM_FUN(91));
InstallMethod(\+,"for sparse rowspace elements",IsIdenticalObj,[IsSparseRowSpaceElement and IsPackedElementDefaultRep,IsSparseRowSpaceElement and IsPackedElementDefaultRep],0,COM_FUN(92));
InstallMethod(AdditiveInverseOp,"for a sparse rowspace element",true,[IsSparseRowSpaceElement and IsPackedElementDefaultRep],0,COM_FUN(93));
InstallMethod(\*,"for a sparse rowspace element and a scalar",true,[IsSparseRowSpaceElement and IsPackedElementDefaultRep,IsRingElement],0,COM_FUN(94));
InstallMethod(\*,"for a scalar and a sparse rowspace element",true,[IsRingElement,IsSparseRowSpaceElement and IsPackedElementDefaultRep],0,COM_FUN(95));
InstallMethod(\<,"for sparse rowspace elements",IsIdenticalObj,[IsSparseRowSpaceElement and IsPackedElementDefaultRep,IsSparseRowSpaceElement and IsPackedElementDefaultRep],0,COM_FUN(96));
InstallMethod(\=,"for sparse rowspace elements",IsIdenticalObj,[IsSparseRowSpaceElement and IsPackedElementDefaultRep,IsSparseRowSpaceElement and IsPackedElementDefaultRep],0,COM_FUN(97));
DeclareRepresentation("IsBasisOfSparseRowSpaceRep",IsComponentObjectRep,["echelonBasis","heads","baseChange","zeroCoefficient"]);
BindGlobal("BasisOfSparseRowSpace",COM_FUN(98));
InstallMethod(Basis,"for a free module of sparse row space elements, and list",true,[IsFreeLeftModule and IsSparseRowSpaceElementCollection,IsHomogeneousList],SUM_FLAGS,COM_FUN(99));
InstallMethod(BasisNC,"for a free module of sparse row space elements, and list",true,[IsFreeLeftModule and IsSparseRowSpaceElementCollection,IsHomogeneousList],SUM_FLAGS,COM_FUN(100));
InstallMethod(Basis,"for a free module of sparse row space elements",true,[IsFreeLeftModule and IsSparseRowSpaceElementCollection],SUM_FLAGS,COM_FUN(101));
InstallMethod(Coefficients,"for basis of a sparse rowspace, and a vector",IsCollsElms,[IsBasis and IsBasisOfSparseRowSpaceRep,IsSparseRowSpaceElement],SUM_FLAGS,COM_FUN(102));
InstallMethod(FullSparseRowSpace,"for a ring and an integer",true,[IsRing,IsInt],0,COM_FUN(103));
InstallMethod(PrintObj,"for direct sum elements",true,[IsDirectSumElement and IsPackedElementDefaultRep],0,COM_FUN(104));
InstallMethod(ObjByExtRep,"for a family of direct sum elements and a list",true,[IsDirectSumElementFamily,IsList],0,COM_FUN(105));
InstallMethod(ExtRepOfObj,"for a direct sum element",true,[IsDirectSumElement and IsPackedElementDefaultRep],0,COM_FUN(106));
InstallMethod(ZeroOp,"for direct sum elements",true,[IsDirectSumElement and IsPackedElementDefaultRep],0,COM_FUN(107));
InstallMethod(\+,"for direct sum elements",IsIdenticalObj,[IsDirectSumElement and IsPackedElementDefaultRep,IsDirectSumElement and IsPackedElementDefaultRep],0,COM_FUN(108));
InstallMethod(AdditiveInverseOp,"for a direct sum element",true,[IsDirectSumElement and IsPackedElementDefaultRep],0,COM_FUN(109));
InstallMethod(\*,"for a direct sum element and a scalar",true,[IsDirectSumElement and IsPackedElementDefaultRep,IsRingElement],0,COM_FUN(110));
InstallMethod(\*,"for a direct sum element and a scalar",true,[IsRingElement,IsDirectSumElement and IsPackedElementDefaultRep],0,COM_FUN(111));
InstallMethod(\<,"for direct sum elements",IsIdenticalObj,[IsDirectSumElement and IsPackedElementDefaultRep,IsDirectSumElement and IsPackedElementDefaultRep],0,COM_FUN(112));
InstallMethod(\=,"for direct sum elements",IsIdenticalObj,[IsDirectSumElement and IsPackedElementDefaultRep,IsDirectSumElement and IsPackedElementDefaultRep],0,COM_FUN(113));
InstallHandlingByNiceBasis("IsDirectSumElementsSpace",rec(detect:=COM_FUN(114),NiceFreeLeftModuleInfo:=ReturnFalse,NiceVector:=COM_FUN(115),UglyVector:=COM_FUN(116)));
InstallMethod(DirectSumOfAlgebraModules,"for a list of algebra modules",true,[IsDenseList],0,COM_FUN(117));
InstallOtherMethod(DirectSumOfAlgebraModules,"for two algebra modules",true,[IsAlgebraModule,IsAlgebraModule],0,COM_FUN(118));
InstallMethod(TranslatorSubalgebra,"for an algebra, an algebra module and two subspaces",true,[IsAlgebraModule,IsFreeLeftModule,IsFreeLeftModule],0,COM_FUN(119));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/algrep.gi"

#F  file="lib/lierep.gi" crc=-88873740
RANK_FILTER_LIST  := [ 57644789, 24, 17, 18, 1, 0, 32651708, 10, 31635900, 8, 
  57644789, 24, 17, 18, 32651708, 10, 32651708, 10, 50043054, 11, 50043054, 
  11, 32651708, 10, 50043054, 11, 30625149, 10, 32651708, 10, 38630566, 12, 
  32651708, 10, 30625149, 10, 50043054, 11, 32651708, 10, 30625149, 10, 
  32651708, 10, 38630566, 12, 50043054, 11, 30625149, 10, 32651708, 10, 
  32651708, 10, 32651708, 10, 32651708, 10, 32651708, 10, 50043054, 11, 
  48757600, 27, 48757600, 27, 1, 0, 48757600, 27, 1, 0, 57644789, 24, 17, 18, 
  57644789, 24, 17, 18, 67108340, 1, 8193, 2, 17, 18, 8193, 2, 44086394, 23, 
  44086394, 23, 8193, 2, 44086394, 23, 8193, 2, 44086394, 23, 8193, 2, 
  67108340, 1, 67108340, 1, 8193, 2, 67108760, 2, 67108340, 1, 8193, 2, 
  64079747, 42, 8193, 2, 64079747, 42, 8193, 2, 8193, 2, 64079747, 42, 8193, 
  2, 48733699, 4, 8193, 2, 45737145, 10, 46752953, 12, 46752953, 12, 
  46752953, 12, 46752953, 12, 46752953, 12, 46752953, 12, 46752953, 12, 
  46752953, 12, 46752953, 12, 46752953, 12, 30625149, 10, 46752953, 12, 
  46752953, 12, 30625149, 10, 46752953, 12, 46752953, 12, 36814309, 5, 32769, 
  4, 1, 0, 36814309, 5, 32769, 4, 60816554, 2, 36814309, 5, 64079747, 42, 17, 
  18, 45737145, 10, 41549180, 2, 8193, 2, 61734763, 10, 61734763, 10, 
  61734763, 10, 61734763, 10, 61734763, 10, 61734763, 10, 64918210, 8, 
  64918210, 8, 61734763, 10, 61734763, 10, 61734763, 10, 61734763, 10, 
  61734763, 10, 61734763, 10, 64918210, 8, 61734763, 10, 3996872, 28, 
  54337222, 20, 3996872, 28, 54337222, 20, 3996872, 28, 15990440, 8, 
  61734763, 10, 64079747, 42, 8193, 2, 64079747, 42 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/lierep.gi", -88873740 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/lierep.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/lierep.gi");
elif COM_RESULT = 3  then
Revision.lierep_gi:="@(#)$Id: lierep.gi,v 4.35 2003/09/30 13:25:41 gap Exp $";
DeclareRepresentation("IsZeroCochainRep",IsPackedElementDefaultRep,[1]);
InstallMethod(Cochain,"for a module over a Lie algebra, an integer and an object",true,[IsAlgebraModule,IsInt,IsObject],0,COM_FUN(1));
InstallMethod(ExtRepOfObj,"for a cochain",true,[IsCochain and IsPackedElementDefaultRep],0,COM_FUN(2));
InstallMethod(PrintObj,"for a cochain",true,[IsCochain],0,COM_FUN(3));
InstallMethod(CochainSpace,"for a module over a Lie algebra and an integer",true,[IsAlgebraModule,IS_INT],0,COM_FUN(4));
InstallMethod(\+,"for two cochains",IsIdenticalObj,[IsCochain and IsPackedElementDefaultRep,IsCochain and IsPackedElementDefaultRep],0,COM_FUN(5));
InstallMethod(\+,"for two 0-cochains",IsIdenticalObj,[IsCochain and IsZeroCochainRep,IsCochain and IsZeroCochainRep],0,COM_FUN(6));
InstallMethod(AdditiveInverseOp,"for a cochain",true,[IsCochain and IsPackedElementDefaultRep],0,COM_FUN(7));
InstallMethod(AdditiveInverseOp,"for a 0-cochain",true,[IsCochain and IsZeroCochainRep],0,COM_FUN(8));
InstallMethod(\*,"for scalar and cochain",true,[IsScalar,IsCochain and IsPackedElementDefaultRep],0,COM_FUN(9));
InstallMethod(\*,"for scalar and cochain",true,[IsScalar and IsZero,IsCochain and IsPackedElementDefaultRep],0,COM_FUN(10));
InstallMethod(\*,"for scalar and 0-cochain",true,[IsScalar,IsCochain and IsZeroCochainRep],0,COM_FUN(11));
InstallMethod(\*,"for cochain and scalar",true,[IsCochain and IsPackedElementDefaultRep,IsScalar],0,COM_FUN(12));
InstallMethod(\*,"for cochain and scalar",true,[IsCochain and IsPackedElementDefaultRep,IsScalar and IsZero],0,COM_FUN(13));
InstallMethod(\*,"for 0-cochain and scalar",true,[IsCochain and IsZeroCochainRep,IsScalar],0,COM_FUN(14));
InstallMethod(\<,"for two cochains",true,[IsCochain and IsPackedElementDefaultRep,IsCochain and IsPackedElementDefaultRep],0,COM_FUN(15));
InstallMethod(\=,"for two cochains",true,[IsCochain and IsPackedElementDefaultRep,IsCochain and IsPackedElementDefaultRep],0,COM_FUN(16));
InstallMethod(ZeroOp,"for a cochain",true,[IsCochain and IsPackedElementDefaultRep],0,COM_FUN(17));
InstallMethod(ZeroOp,"for a 0-cochain",true,[IsCochain and IsZeroCochainRep],0,COM_FUN(18));
InstallHandlingByNiceBasis("IsCochainsSpace",rec(detect:=COM_FUN(19),NiceFreeLeftModuleInfo:=COM_FUN(20),NiceVector:=COM_FUN(21),UglyVector:=COM_FUN(22)));
InstallGlobalFunction(ValueCochain,COM_FUN(23));
InstallGlobalFunction(LieCoboundaryOperator,COM_FUN(24));
InstallMethod(Coboundaries,"for module over a Lie algebra and an integer",true,[IsAlgebraModule,IS_INT],0,COM_FUN(25));
InstallMethod(Cocycles,"for module over a Lie algebra and an integer",true,[IsAlgebraModule,IS_INT],0,COM_FUN(26));
InstallMethod(WeylGroup,"for a root system",true,[IsRootSystem],0,COM_FUN(27));
InstallMethod(ApplySimpleReflection,"for a sparse Cartan matrix, index and weight",true,[IsList,IS_INT,IsList],0,COM_FUN(28));
InstallMethod(LongestWeylWordPerm,"for Weyl group",true,[IsWeylGroup],0,COM_FUN(29));
InstallMethod(ConjugateDominantWeight,"for Weyl group and weight",true,[IsWeylGroup,IsList],0,COM_FUN(30));
InstallMethod(ConjugateDominantWeightWithWord,"for Weyl group and weight",true,[IsWeylGroup,IsList],0,COM_FUN(31));
BindGlobal("IsDoneIterator_WeylOrbit",COM_FUN(32));
BindGlobal("NextIterator_WeylOrbit",COM_FUN(33));
InstallMethod(WeylOrbitIterator,"for weights of a W-orbit",[IsWeylGroup,IsList],COM_FUN(34));
InstallMethod(PositiveRootsAsWeights,"for a root system",true,[IsRootSystem],0,COM_FUN(35));
InstallMethod(DominantWeights,"for a root system and a dominant weight",true,[IsRootSystem,IsList],0,COM_FUN(36));
InstallMethod(BilinearFormMat,"for a root system from a Lie algebra",true,[IsRootSystemFromLieAlgebra],0,COM_FUN(37));
InstallMethod(DominantCharacter,"for a root system and a highest weight",true,[IsRootSystem,IsList],0,COM_FUN(38));
InstallOtherMethod(DominantCharacter,"for a semisimple Lie algebra and a highest weight",true,[IsLieAlgebra,IsList],0,COM_FUN(39));
InstallMethod(DecomposeTensorProduct,"for a semisimple Lie algebra and two dominant weights",true,[IsLieAlgebra,IsList,IsList],0,COM_FUN(40));
InstallMethod(DimensionOfHighestWeightModule,"for a semisimple Lie algebra",true,[IsLieAlgebra,IsList],0,COM_FUN(41));
InstallMethod(ObjByExtRep,"for family of UEALattice elements, and list",true,[IsUEALatticeElementFamily,IsList],0,COM_FUN(42));
InstallMethod(ExtRepOfObj,"for an UEALattice element",true,[IsUEALatticeElement],0,COM_FUN(43));
InstallMethod(PrintObj,"for UEALattice element",true,[IsUEALatticeElement and IsPackedElementDefaultRep],0,COM_FUN(44));
InstallMethod(OneOp,"for UEALattice element",true,[IsUEALatticeElement and IsPackedElementDefaultRep],0,COM_FUN(45));
InstallMethod(ZeroOp,"for UEALattice element",true,[IsUEALatticeElement and IsPackedElementDefaultRep],0,COM_FUN(46));
InstallMethod(\<,"for two UEALattice elements",IsIdenticalObj,[IsUEALatticeElement and IsPackedElementDefaultRep,IsUEALatticeElement and IsPackedElementDefaultRep],0,COM_FUN(47));
InstallMethod(\=,"for two UEALattice elements",IsIdenticalObj,[IsUEALatticeElement and IsPackedElementDefaultRep,IsUEALatticeElement and IsPackedElementDefaultRep],0,COM_FUN(48));
InstallMethod(\+,"for two UEALattice elements",true,[IsUEALatticeElement and IsPackedElementDefaultRep,IsUEALatticeElement and IsPackedElementDefaultRep],0,COM_FUN(49));
InstallMethod(AdditiveInverseOp,"for UEALattice element",true,[IsUEALatticeElement and IsPackedElementDefaultRep],0,COM_FUN(50));
InstallMethod(\*,"for scalar and UEALattice element",true,[IsScalar,IsUEALatticeElement and IsPackedElementDefaultRep],0,COM_FUN(51));
InstallMethod(\*,"for UEALattice element and scalar",true,[IsUEALatticeElement and IsPackedElementDefaultRep,IsScalar],0,COM_FUN(52));
InstallGlobalFunction(CollectUEALatticeElement,COM_FUN(53));
InstallMethod(\*,"for two UEALattice elements",IsIdenticalObj,[IsUEALatticeElement and IsPackedElementDefaultRep,IsUEALatticeElement and IsPackedElementDefaultRep],0,COM_FUN(54));
DeclareRepresentation("IsVectorSearchTableDefaultRep",IsVectorSearchTable and IsComponentObjectRep and IsAttributeStoringRep,["top"]);
VSTNode:=COM_FUN(55);
VSTInsertToLeft:=COM_FUN(56);
InstallMethod(Insert,"for a vector search table in default representation",[IsVectorSearchTableDefaultRep,IsHomogeneousList,IsObject],COM_FUN(57));
InstallMethod(Search,"for vector search tables in default representation",[IsVectorSearchTableDefaultRep,IsHomogeneousList],COM_FUN(58));
InstallGlobalFunction(VectorSearchTable,COM_FUN(59));
InstallMethod(ViewObj,"for vector search tables",[IsVectorSearchTable],COM_FUN(60));
InstallMethod(Display,"for vector search tables in default representation",[IsVectorSearchTableDefaultRep],COM_FUN(61));
InstallMethod(LatticeGeneratorsInUEA,"for semsimple Lie algebra",true,[IsLieAlgebra],0,COM_FUN(62));
InstallMethod(LeadingUEALatticeMonomial,"for an integer and a UEALattice element",true,[IsInt,IsUEALatticeElement],0,COM_FUN(63));
InstallGlobalFunction(LeftReduceUEALatticeElement,COM_FUN(64));
InstallMethod(ObjByExtRep,"for a family of weight rep elements and a list",true,[IsWeightRepElementFamily,IsList],0,COM_FUN(65));
InstallMethod(ExtRepOfObj,"for weight rep element",true,[IsWeightRepElement and IsPackedElementDefaultRep],0,COM_FUN(66));
InstallMethod(PrintObj,"for weight rep element",true,[IsWeightRepElement and IsPackedElementDefaultRep],0,COM_FUN(67));
InstallMethod(\+,"for weight rep elements",IsIdenticalObj,[IsWeightRepElement and IsPackedElementDefaultRep,IsWeightRepElement and IsPackedElementDefaultRep],0,COM_FUN(68));
InstallMethod(AdditiveInverseOp,"for a weight rep element",true,[IsWeightRepElement and IsPackedElementDefaultRep],0,COM_FUN(69));
InstallMethod(\*,"for weight rep element and a scalar",true,[IsWeightRepElement and IsPackedElementDefaultRep,IsRingElement],0,COM_FUN(70));
InstallMethod(\*,"for weight rep element and a scalar",true,[IsRingElement,IsWeightRepElement and IsPackedElementDefaultRep],0,COM_FUN(71));
InstallMethod(ZeroOp,"for weight rep element",true,[IsWeightRepElement and IsPackedElementDefaultRep],0,COM_FUN(72));
InstallMethod(\=,"for two weight rep elements",IsIdenticalObj,[IsWeightRepElement and IsPackedElementDefaultRep,IsWeightRepElement and IsPackedElementDefaultRep],0,COM_FUN(73));
InstallMethod(\<,"for two weight rep elements",IsIdenticalObj,[IsWeightRepElement and IsPackedElementDefaultRep,IsWeightRepElement and IsPackedElementDefaultRep],0,COM_FUN(74));
InstallOtherMethod(\^,"for a Lie algebra element and a weight rep element",true,[IsRingElement,IsWeightRepElement and IsPackedElementDefaultRep],0,COM_FUN(75));
BindGlobal("BasisOfWeightRepSpace",COM_FUN(76));
TriangulizeWeightRepElementList:=COM_FUN(77);
InstallMethod(Basis,"for a space of weight rep elements and a list of weight rep elements",IsIdenticalObj,[IsFreeLeftModule and IsWeightRepElementCollection,IsWeightRepElementCollection and IsList],0,COM_FUN(78));
InstallMethod(BasisNC,"for a space of weight rep elements and a list of weight rep elements",IsIdenticalObj,[IsFreeLeftModule and IsWeightRepElementCollection,IsWeightRepElementCollection and IsList],0,COM_FUN(79));
InstallMethod(Basis,"for a space of weight rep elements",true,[IsFreeLeftModule and IsWeightRepElementCollection],0,COM_FUN(80));
InstallMethod(Coefficients,"for basis of weight rep elements, and algebra module element",true,[IsBasisOfWeightRepElementSpace,IsWeightRepElement and IsPackedElementDefaultRep],0,COM_FUN(81));
InstallMethod(HighestWeightModule,"for a Lie algebra and a list of non-negative integers",true,[IsLieAlgebra,IsList],0,COM_FUN(82));
InstallGlobalFunction(ExtendRepresentation,COM_FUN(83));
InstallMethod(FaithfulModule,"for a Lie algebra",true,[IsLieAlgebra],0,COM_FUN(84));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/lierep.gi"

#F  file="lib/numtheor.gi" crc=-54296347
RANK_FILTER_LIST  := [ 17, 18, 17, 18, 17, 18, 17, 18 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/numtheor.gi", -54296347 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/numtheor.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/numtheor.gi");
elif COM_RESULT = 3  then
Revision.numtheor_gi:="@(#)$Id: numtheor.gi,v 4.19.2.2 2005/07/22 11:26:27 stefan Exp $";
BindGlobal("PrimeResiduesCache",List([[],[0],[1],[1,2],[1,3],[1,2,3,4],[1,5],[1,2,3,4,5,6]],Immutable));
InstallGlobalFunction(PrimeResidues,COM_FUN(1));
InstallMethod(Phi,"value of Eulers totient function of an integer",true,[IsInt],0,COM_FUN(2));
InstallMethod(Lambda,"exponent of the group of prime residues modulo an integer",true,[IsInt],0,COM_FUN(3));
InstallGlobalFunction(OrderMod,COM_FUN(4));
InstallGlobalFunction(IsPrimitiveRootMod,COM_FUN(5));
InstallGlobalFunction(PrimitiveRootMod,COM_FUN(6));
InstallGlobalFunction(GeneratorsPrimeResidues,COM_FUN(7));
InstallGlobalFunction(Jacobi,COM_FUN(8));
InstallGlobalFunction(Legendre,COM_FUN(9));
BindGlobal("RootModPrime",COM_FUN(10));
RootModPrimePower:=COM_FUN(11);
MakeReadOnlyGlobal("RootModPrimePower");
InstallGlobalFunction(RootMod,COM_FUN(12));
BindGlobal("RootsModPrime",COM_FUN(13));
RootsModPrimePower:=COM_FUN(14);
MakeReadOnlyGlobal("RootsModPrimePower");
InstallGlobalFunction(RootsMod,COM_FUN(15));
BindGlobal("RootsUnityModPrime",COM_FUN(16));
RootsUnityModPrimePower:=COM_FUN(17);
MakeReadOnlyGlobal("RootsUnityModPrimePower");
InstallGlobalFunction(RootsUnityMod,COM_FUN(18));
InstallGlobalFunction(LogModShanks,COM_FUN(19));
BindGlobal("LogModRhoIterate",COM_FUN(20));
InstallGlobalFunction(DoLogModRho,COM_FUN(21));
InstallGlobalFunction(LogMod,COM_FUN(22));
InstallMethod(Sigma,"sum of divisors of an integer",true,[IsInt],0,COM_FUN(23));
InstallMethod(Tau,"number of divisors of an integer",true,[IsInt],0,COM_FUN(24));
InstallGlobalFunction(MoebiusMu,COM_FUN(25));
InstallGlobalFunction(TwoSquares,COM_FUN(26));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/numtheor.gi"

#F  file="lib/contfrac.gi" crc=-116226566
RANK_FILTER_LIST  := [  ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/contfrac.gi", -116226566 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/contfrac.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/contfrac.gi");
elif COM_RESULT = 3  then
Revision.contfrac_gi:="@(#)$Id: contfrac.gi,v 4.5.2.1 2005/05/03 13:44:09 stefan Exp $";
InstallGlobalFunction(ContinuedFractionExpansionOfRoot,COM_FUN(1));
InstallGlobalFunction(ContinuedFractionApproximationOfRoot,COM_FUN(2));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/contfrac.gi"

#F  file="lib/string.gi" crc=51631039
RANK_FILTER_LIST  := [ 67108760, 5, 67108760, 5, 53597154, 1, 67097600, 8, 
  41942756, 18, 67108760, 5, 67108760, 5, 67108760, 5, 67108760, 5, 53597154, 
  1, 53597154, 1, 67108760, 5, 67108760, 5, 53597154, 1, 67108760, 5, 
  53597154, 1, 67108760, 5, 67108760, 5, 67108760, 5, 67108760, 5, 53597154, 
  1, 67108640, 2, 67108640, 2, 67108640, 2, 67108640, 2, 17, 18 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/string.gi", 51631039 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/string.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/string.gi");
elif COM_RESULT = 3  then
Revision.string_gi:="@(#)$Id: string.gi,v 4.30 2003/08/07 13:39:42 sal Exp $";
BIND_GLOBAL("CHARS_DIGITS",Immutable(SSortedList("0123456789")));
InstallGlobalFunction(IsDigitChar,COM_FUN(1));
BIND_GLOBAL("CHARS_UALPHA",Immutable(SSortedList("ABCDEFGHIJKLMNOPQRSTUVWXYZ")));
InstallGlobalFunction(IsUpperAlphaChar,COM_FUN(2));
BIND_GLOBAL("CHARS_LALPHA",Immutable(SSortedList("abcdefghijklmnopqrstuvwxyz")));
InstallGlobalFunction(IsLowerAlphaChar,COM_FUN(3));
InstallGlobalFunction(IsAlphaChar,COM_FUN(4));
InstallGlobalFunction(DaysInYear,COM_FUN(5));
InstallGlobalFunction(DaysInMonth,COM_FUN(6));
InstallGlobalFunction(DMYDay,COM_FUN(7));
InstallGlobalFunction(DayDMY,COM_FUN(8));
InstallGlobalFunction(WeekDay,COM_FUN(9));
InstallGlobalFunction(SecondsDMYhms,COM_FUN(10));
InstallGlobalFunction(DMYhmsSeconds,COM_FUN(11));
InstallGlobalFunction(StringDate,COM_FUN(12));
InstallGlobalFunction(HMSMSec,COM_FUN(13));
InstallGlobalFunction(SecHMSM,COM_FUN(14));
InstallGlobalFunction(StringTime,COM_FUN(15));
InstallGlobalFunction(StringPP,COM_FUN(16));
InstallGlobalFunction(WordAlp,COM_FUN(17));
LOWERCASETRANSTABLE:=0;
InstallGlobalFunction(LowercaseString,COM_FUN(18));
InstallOtherMethod(Int,"for strings",true,[IsString],0,COM_FUN(19));
InstallOtherMethod(Rat,"for strings",true,[IsString],0,COM_FUN(20));
InstallMethod(ViewObj,"IsChar",true,[IsChar],0,COM_FUN(21));
InstallMethod(ViewObj,"IsString",true,[IsString and IsFinite],0,COM_FUN(22));
InstallMethod(ViewObj,"empty strings",true,[IsString and IsEmpty],0,COM_FUN(23));
InstallMethod(SplitString,"for three strings",true,[IsString,IsString,IsString],0,SplitStringInternal);
InstallMethod(SplitString,"for a string and two characters",true,[IsString,IsChar,IsChar],0,COM_FUN(24));
InstallMethod(SplitString,"for two strings and a character",true,[IsString,IsString,IsChar],0,COM_FUN(25));
InstallMethod(SplitString,"for a string, a character and a string",true,[IsString,IsChar,IsString],0,COM_FUN(26));
InstallOtherMethod(SplitString,"for two strings",true,[IsString,IsString],0,COM_FUN(27));
InstallOtherMethod(SplitString,"for a string and a character",true,[IsString,IsChar],0,COM_FUN(28));
InstallOtherMethod(PositionSublist,"for two args in IsStringRep",true,[IS_STRING_REP,IS_STRING_REP],0,COM_FUN(29));
InstallOtherMethod(PositionSublist,"for two args in IsStringRep and offset",true,[IS_STRING_REP,IS_STRING_REP,IsInt],0,COM_FUN(30));
InstallGlobalFunction("NormalizedWhitespace",COM_FUN(31));
InstallGlobalFunction("RemoveCharacters",REMOVE_CHARACTERS);
_EVALSTRINGTMP:=0;
InstallGlobalFunction("EvalString",COM_FUN(32));
Unbind(_EVALSTRINGTMP);
InstallGlobalFunction("JoinStringsWithSeparator",COM_FUN(33));
InstallGlobalFunction(Chomp,COM_FUN(34));
InstallGlobalFunction(StringFile,COM_FUN(35));
InstallGlobalFunction(FileString,COM_FUN(36));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/string.gi"

#F  file="lib/ratfun.gi" crc=-110667794
RANK_FILTER_LIST  := [ 30085677, 2, 7665940, 19, 30085677, 2, 7665940, 19, 
  30085677, 2, 7665940, 19, 67108760, 5, 49151311, 17, 67108760, 5, 45841788, 
  15, 30894539, 14, 67107965, 12, 60816884, 16, 1, 0, 1, 0, 5729390, 22, 
  24604418, 18, 54525848, 17, 67108010, 13, 67108010, 13, 67108010, 13, 
  45841788, 15, 49150441, 17, 45840918, 15, 67108010, 13, 67108010, 13, 
  30894584, 15, 67108010, 13, 30895454, 14, 67108010, 13, 30895454, 14, 
  30895454, 14, 67107965, 12, 67107965, 12, 8193, 2, 8193, 2, 1, 0, 8193, 2, 
  8193, 2, 8193, 2, 1, 0, 8193, 2, 1985, 1, 1, 0, 67108010, 13, 30895454, 14, 
  49193885, 15, 30895454, 14, 30895454, 14, 30895454, 14, 30895454, 14, 
  67108010, 13, 67108010, 13, 30895454, 14, 30895454, 14, 67107965, 12, 
  67107965, 12, 64918210, 8, 67107965, 12, 67107965, 12, 64918210, 8, 
  30895454, 14, 64918210, 8, 64918210, 8, 30895454, 14, 60628801, 5, 8193, 2, 
  8193, 2, 67108010, 13, 67108010, 13, 6553496, 27, 30895454, 14, 30895454, 
  14, 30895454, 14, 30895454, 14, 67108010, 13, 67108010, 13, 67107965, 12, 
  64918210, 8, 64918210, 8, 67107965, 12, 33, 17, 67107965, 12, 33, 17, 33, 
  17, 33, 17, 67107965, 12, 30895454, 14, 7665940, 19, 30895454, 14, 
  49151311, 17, 40557768, 31, 67108010, 13, 67108010, 13, 67107965, 12, 8193, 
  2, 8193, 2, 64918210, 8, 67107965, 12, 8193, 2, 8193, 2, 30895454, 14, 
  18312422, 17, 30895454, 14, 7665940, 19, 30894539, 14, 7665940, 19, 
  30894539, 14, 30894539, 14, 67107965, 12, 30894539, 14, 7665940, 19, 
  30894539, 14, 30894539, 14, 67107965, 12, 7665940, 19, 30894539, 14, 
  30894539, 14, 67107965, 12, 30894539, 14, 30894539, 14, 30894539, 14, 
  7665940, 19, 30894539, 14, 30894539, 14, 30894539, 14 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/ratfun.gi", -110667794 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/ratfun.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/ratfun.gi");
elif COM_RESULT = 3  then
Revision.ratfun_gi:="@(#)$Id: ratfun.gi,v 4.108.2.6 2006/06/07 19:42:42 gap Exp $";
InstallMethod(IndeterminateName,"for rational function families",true,[IsPolynomialFunctionsFamily,IsPosInt],0,COM_FUN(1));
InstallMethod(HasIndeterminateName,"for rational function families",true,[IsPolynomialFunctionsFamily,IsPosInt],0,COM_FUN(2));
InstallMethod(SetIndeterminateName,"for rational function families",true,[IsPolynomialFunctionsFamily,IsPosInt,IsString],0,COM_FUN(3));
InstallMethod(SetName,"set name of indeterminate",true,[IsLaurentPolynomial,IsString],0,COM_FUN(4));
InstallGlobalFunction(LaurentPolynomialByExtRepNC,LAUR_POL_BY_EXTREP);
InstallGlobalFunction(UnivariateRationalFunctionByExtRepNC,UNIV_FUNC_BY_EXTREP\
);
BindGlobal("SortedPolExtrepRatfun",COM_FUN(5));
InstallGlobalFunction(PolynomialByExtRepNC,COM_FUN(6));
InstallGlobalFunction(PolynomialByExtRep,COM_FUN(7));
InstallGlobalFunction(RationalFunctionByExtRepNC,COM_FUN(8));
InstallGlobalFunction(RationalFunctionByExtRep,COM_FUN(9));
InstallMethod(IsLaurentPolynomial,true,[IsUnivariateRationalFunction],0,COM_FUN(10));
InstallMethod(IsConstantRationalFunction,"polynomial",true,[IsPolynomialFunction and IsPolynomial],0,COM_FUN(11));
InstallMethod(IsConstantRationalFunction,"rational function",true,[IsPolynomialFunction],0,COM_FUN(12));
InstallMethod(IsPolynomial,"rational function rep.",true,[IsRationalFunctionDefaultRep],0,COM_FUN(13));
InstallOtherMethod(IsPolynomial,"fallback for non-ratfun",true,[IsObject],0,COM_FUN(14));
InstallOtherMethod(IsLaurentPolynomial,"fallback for non-ratfun",true,[IsObject],0,COM_FUN(15));
InstallMethod(ExtRepPolynomialRatFun,"laurent polynomial rep.",true,[IsLaurentPolynomialDefaultRep and IsPolynomial],0,EXTREP_POLYNOMIAL_LAURENT);
InstallMethod(ExtRepPolynomialRatFun,"rational function rep.",true,[IsRationalFunctionDefaultRep and IsPolynomial],0,COM_FUN(16));
InstallMethod(ExtRepNumeratorRatFun,"polynomial rep -> ExtRepPolynomialRatFun",true,[IsPolynomialDefaultRep],0,ExtRepPolynomialRatFun);
InstallMethod(ExtRepDenominatorRatFun,"polynomial, return constant",true,[IsRationalFunction],0,COM_FUN(17));
InstallGlobalFunction(UnivariatenessTestRationalFunction,UNIVARTEST_RATFUN);
BindGlobal("DoUnivTestRatfun",COM_FUN(18));
InstallMethod(IsUnivariateRationalFunction,"ratfun",true,[IsRationalFunction],0,COM_FUN(19));
InstallMethod(IsLaurentPolynomial,"ratfun",true,[IsRationalFunction],0,COM_FUN(20));
InstallMethod(IndeterminateNumberOfUnivariateRationalFunction,"ratfun",true,[IsUnivariateRationalFunction],0,COM_FUN(21));
InstallMethod(CoefficientsOfLaurentPolynomial,"ratfun",true,[IsRationalFunction and IsLaurentPolynomial],0,COM_FUN(22));
InstallMethod(CoefficientsOfUnivariateRationalFunction,"ratfun",true,[IsRationalFunction and IsUnivariateRationalFunction],0,COM_FUN(23));
InstallMethod(NumeratorOfRationalFunction,"call ExtRepNumerator",true,[IsRationalFunction],0,COM_FUN(24));
InstallMethod(DenominatorOfRationalFunction,"call ExtRepDenominator",true,[IsRationalFunction],0,COM_FUN(25));
InstallMethod(AsPolynomial,"call ExtRepPolynomial",true,[IsRationalFunction and IsPolynomial],0,COM_FUN(26));
BindGlobal("ExtRepOfPolynomial_String",COM_FUN(27));
InstallMethod(String,"rational function",[IsRationalFunction],COM_FUN(28));
InstallMethod(String,"polynomial",[IsPolynomial],COM_FUN(29));
InstallMethod(PrintObj,"rational function",[IsRationalFunction],COM_FUN(30));
InstallMethod(PrintObj,"polynomial",[IsPolynomial],COM_FUN(31));
InstallMethod(LaTeXObj,"polynomial",true,[IsPolynomial],0,COM_FUN(32));
InstallMethod(OneOp,"defer to family",true,[IsPolynomialFunction],0,COM_FUN(33));
InstallMethod(ZeroOp,"defer to family",true,[IsPolynomialFunction],0,COM_FUN(34));
InstallGlobalFunction(MonomialExtGrlexLess,MONOM_GRLEX);
InstallMethod(ZippedSum,true,[IsList,IsList,IsObject,IsList],0,ZIPPED_SUM_LISTS);
InstallMethod(ZippedProduct,true,[IsList,IsList,IsObject,IsList],0,ZIPPED_PRODUCT_LISTS);
InstallMethod(RationalFunctionsFamily,true,[IsFamily],1,COM_FUN(35));
InstallOtherMethod(RationalFunctionsFamily,"not UFD ring",true,[IsObject],0,COM_FUN(36));
InstallMethod(AdditiveInverseOp,"rational function",true,[IsRationalFunction],0,ADDITIVE_INV_RATFUN);
InstallMethod(AdditiveInverseOp,"polynomial",true,[IsPolynomial],0,ADDITIVE_INV_POLYNOMIAL);
InstallMethod(InverseOp,"rational function",true,[IsRationalFunctionsFamilyElement],0,COM_FUN(37));
InstallMethod(\+,"polynomial + polynomial",IsIdenticalObj,[IsPolynomial,IsPolynomial],0,COM_FUN(38));
InstallMethod(\*,"polynomial * polynomial",IsIdenticalObj,[IsPolynomial,IsPolynomial],0,COM_FUN(39));
InstallMethod(\=,"rational functions",IsIdenticalObj,[IsRationalFunction,IsRationalFunction],0,COM_FUN(40));
InstallMethod(\=,"polynomial",IsIdenticalObj,[IsPolynomial,IsPolynomial],0,COM_FUN(41));
InstallMethod(\<,"rational functions",IsIdenticalObj,[IsPolynomialFunction,IsPolynomialFunction],0,SMALLER_RATFUN);
InstallGlobalFunction(ProdCoefRatfun,COM_FUN(42));
InstallMethod(\*,"coeff * rat-fun",IsCoeffsElms,[IsRingElement,IsPolynomialFunction],3,COM_FUN(43));
InstallMethod(\*,"rat-fun * coeff",IsElmsCoeffs,[IsPolynomialFunction,IsRingElement],3,COM_FUN(44));
InstallGlobalFunction(SumCoefPolynomial,SUM_COEF_POLYNOMIAL);
InstallMethod(\+,"polynomial + coeff",IsElmsCoeffs,[IsPolynomial,IsRingElement],0,COM_FUN(45));
InstallMethod(\+,"coeff + polynomial ",IsCoeffsElms,[IsRingElement,IsPolynomial],0,COM_FUN(46));
InstallGlobalFunction(QuotientPolynomialsExtRep,QUOTIENT_POLYNOMIALS_EXT);
InstallGlobalFunction(SpecializedExtRepPol,SPECIALIZED_EXTREP_POL);
InstallMethod(HeuristicCancelPolynomialsExtRep,"ignore",true,[IsRationalFunctionsFamily,IsList,IsList],-1,COM_FUN(47));
InstallGlobalFunction(TryGcdCancelExtRepPolynomials,TRY_GCD_CANCEL_EXTREP_POL);
InstallGlobalFunction(RationalFunctionByExtRepWithCancellation,COM_FUN(48));
InstallMethod(\*,"rat-fun * rat-fun",IsIdenticalObj,[IsRationalFunction,IsRationalFunction],0,COM_FUN(49));
InstallMethod(Quotient,"multivar with ring",IsCollsElmsElms,[IsPolynomialRing,IsPolynomial,IsPolynomial],0,COM_FUN(50));
InstallOtherMethod(Quotient,"multivar",IsIdenticalObj,[IsPolynomial,IsPolynomial],0,COM_FUN(51));
InstallMethod(\+,"rat-fun + rat-fun",IsIdenticalObj,[IsRationalFunction,IsRationalFunction],0,COM_FUN(52));
InstallGlobalFunction(SumCoefRatfun,COM_FUN(53));
InstallMethod(\+,"ratfun + coeff",IsElmsCoeffs,[IsPolynomialFunction,IsRingElement],0,COM_FUN(54));
InstallMethod(\+,"coeff + ratfun ",IsCoeffsElms,[IsRingElement,IsPolynomialFunction],0,COM_FUN(55));
InstallMethod(\+,"ratfun + rat",true,[IsPolynomialFunction,IsRat],-RankFilter(IsRat),COM_FUN(56));
InstallMethod(\+,"rat + ratfun ",true,[IsRat,IsPolynomialFunction],-RankFilter(IsRat),COM_FUN(57));
InstallMethod(DegreeIndeterminate,"pol,indetnr",true,[IsPolynomial,IsPosInt],0,COM_FUN(58));
InstallOtherMethod(DegreeIndeterminate,"pol,indet",IsIdenticalObj,[IsPolynomial,IsLaurentPolynomial],0,COM_FUN(59));
InstallMethod(GcdOp,"Gcd(Polyring, Pol,Pol)",IsCollsElmsElms,[IsEuclideanRing,IsRationalFunction,IsRationalFunction],0,COM_FUN(60));
InstallOtherMethod(Value,"rat.fun., with one",true,[IsPolynomialFunction,IsList,IsList,IsRingElement],0,COM_FUN(61));
InstallMethod(Value,"rational function: supply `one'",true,[IsPolynomialFunction,IsList,IsList],0,COM_FUN(62));
InstallMethod(LeadingMonomial,"multivariate polynomials wrt total degree",true,[IsPolynomial],0,COM_FUN(63));
InstallMethod(LeadingCoefficient,"multivariate polynomials wrt total degree",true,[IsPolynomial and IsPolynomialDefaultRep],0,COM_FUN(64));
InstallOtherMethod(LeadingCoefficient,"multivariate",true,[IsPolynomial,IsPosInt],0,COM_FUN(65));
InstallMethod(PolynomialCoefficientsOfPolynomial,"polynomial,integer",true,[IsPolynomialFunction and IsPolynomial,IsPosInt],0,COM_FUN(66));
InstallOtherMethod(PolynomialCoefficientsOfPolynomial,"polynomial,indet",IsIdenticalObj,[IsPolynomialFunction and IsPolynomial,IsPolynomialFunction and IsPolynomial]\
,0,COM_FUN(67));
InstallMethod(ZeroCoefficientRatFun,"via family",[IsPolynomialFunction],0,COM_FUN(68));
BindGlobal("ConstantInBaseRingPol",COM_FUN(69));
InstallOtherMethod(Discriminant,"poly,inum",true,[IsPolynomialFunction and IsPolynomial,IsPosInt],0,COM_FUN(70));
InstallOtherMethod(Discriminant,"poly,ind",true,[IsPolynomialFunction and IsPolynomial,IsPolynomialFunction and IsPolynomial]\
,0,COM_FUN(71));
InstallOtherMethod(Derivative,"ratfun,inum",true,[IsPolynomialFunction,IsPosInt],0,COM_FUN(72));
InstallOtherMethod(Derivative,"poly,ind",true,[IsPolynomialFunction and IsPolynomial,IsPolynomialFunction and IsPolynomial]\
,0,COM_FUN(73));
InstallOtherMethod(Derivative,"ratfun,ind",true,[IsPolynomialFunction,IsPolynomialFunction and IsPolynomial],0,COM_FUN(74));
InstallGlobalFunction(OnIndeterminates,COM_FUN(75));
InstallMethod(Resultant,"pol,pol,inum",IsFamFamX,[IsPolynomialFunction and IsPolynomial,IsPolynomialFunction and IsPolynomial,IsPosInt],0,COM_FUN(76));
InstallOtherMethod(Resultant,"pol,pol,indet",IsFamFamFam,[IsPolynomialFunction and IsPolynomial,IsPolynomialFunction and IsPolynomial,IsPolynomialFunction and IsPolynomial],0,COM_FUN(77));
InstallGlobalFunction(LeadingMonomialPosExtRep,COM_FUN(78));
InstallGlobalFunction(ConstituentsPolynomial,COM_FUN(79));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/ratfun.gi"

#F  file="lib/ratfunul.gi" crc=-4733929
RANK_FILTER_LIST  := [ 1985, 1, 8193, 2, 17, 18, 17, 18, 15270232, 2, 8193, 
  2, 17, 18, 17, 18, 1985, 1, 8193, 2, 17, 18, 1985, 1, 8193, 2, 7665940, 19, 
  1985, 1, 8193, 2, 50997183, 26, 62727540, 13, 7665940, 19, 50997183, 26, 
  62727540, 13, 50997183, 26, 41942876, 3, 50997183, 26, 41942876, 3, 1, 0, 
  50997183, 26, 62727540, 13, 45841788, 15, 9629322, 19, 67107965, 12, 
  49150396, 17, 49151311, 17, 7665940, 19, 41942816, 20, 41942816, 20, 
  41941946, 20, 45840873, 15, 45840873, 15, 45840873, 15, 45840873, 15, 
  45840873, 15, 49150396, 17, 49150396, 17, 49150396, 17, 49150396, 17, 
  49150396, 17, 49150396, 17, 49150396, 17, 49150396, 17, 64918210, 8, 
  27885179, 17, 27885179, 17, 64918210, 8, 64918210, 8, 27885179, 17, 
  27885179, 17, 64918210, 8, 12938845, 19, 12938845, 19, 6553496, 27, 
  49151311, 17, 49151311, 17, 6553496, 27, 67108010, 13, 67108010, 13, 
  49151311, 17, 49151311, 17, 67108010, 13, 67108010, 13, 6553496, 27, 
  49151311, 17, 49151311, 17, 49151311, 17, 49151311, 17, 50997183, 26, 
  49151311, 17, 49151311, 17, 49151311, 17, 49151311, 17, 49151311, 17, 
  49151311, 17, 6553496, 27, 49151311, 17, 17, 18, 49151311, 17, 49151311, 
  17, 17, 18, 49151311, 17, 49151311, 17, 49151311, 17, 49151311, 17, 
  49151311, 17, 49151311, 17, 49151311, 17, 6553496, 27, 49151311, 17, 
  49151311, 17, 6553496, 27, 49151311, 17, 49151311, 17, 49151311, 17, 
  49151311, 17, 49151311, 17, 49151311, 17, 40557768, 31, 30895454, 14, 
  30895454, 14, 30894584, 15, 30894584, 15, 40557768, 31, 67108010, 13, 
  67108010, 13, 67108010, 13, 67108010, 13, 6553496, 27, 49151311, 17, 
  49151311, 17, 30895454, 14, 45841788, 15, 30895454, 14, 49151311, 17, 
  30895454, 14, 49151311, 17, 64918210, 8, 64918210, 8, 45841788, 15, 
  64918210, 8, 64918210, 8, 45841788, 15, 64918210, 8, 67107965, 12, 
  64918210, 8, 49151311, 17, 1985, 1, 8193, 2, 8193, 2, 17, 18, 17, 18, 1985, 
  1, 8193, 2, 8193, 2, 17, 18, 45841788, 15, 49151311, 17, 45841788, 15, 
  45841788, 15, 45841788, 15, 45841788, 15, 45841788, 15, 45841788, 15, 
  45840873, 15, 45840873, 15, 45840873, 15, 45840873, 15, 45840873, 15, 
  45840918, 15, 45840873, 15, 45840873, 15, 45840873, 15, 45840873, 15, 
  45840873, 15, 45840873, 15, 64918210, 8, 45840873, 15, 45840873, 15, 
  64918210, 8, 64918210, 8, 45840873, 15, 45840873, 15, 64918210, 8, 33, 17, 
  33, 17, 45840873, 15, 33, 17, 45840873, 15, 33, 17 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/ratfunul.gi", -4733929 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/ratfunul.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/ratfunul.gi");
elif COM_RESULT = 3  then
Revision.ratfunul_gi:="@(#)$Id: ratfunul.gi,v 4.81.2.8 2006/09/13 08:48:37 sal Exp $";
InstallMethod(LaurentPolynomialByCoefficients,"with indeterminate",true,[IsFamily,IsList,IsInt,IsInt],0,COM_FUN(1));
ITER_POLY_WARN:=true;
InstallMethod(LaurentPolynomialByCoefficients,"warn about iterated polynomials",true,[IsFamily and HasCoefficientsFamily,IsList,IsInt,IsInt],0,COM_FUN(2));
InstallOtherMethod(LaurentPolynomialByCoefficients,"fam, cof,val",true,[IsFamily,IsList,IsInt],0,COM_FUN(3));
InstallMethod(UnivariatePolynomialByCoefficients,"fam, cof,ind",true,[IsFamily,IsList,IsPosInt],0,COM_FUN(4));
InstallOtherMethod(UnivariatePolynomialByCoefficients,"fam,cof",true,[IsFamily,IsList],0,COM_FUN(5));
InstallMethod(UnivariatePolynomial,"ring,cof,indn",true,[IsRing,IsRingElementCollection,IsPosInt],0,COM_FUN(6));
InstallOtherMethod(UnivariatePolynomial,"ring,cof",true,[IsRing,IsRingElementCollection],0,COM_FUN(7));
InstallOtherMethod(UnivariatePolynomial,"ring,empty cof",true,[IsRing,IsEmpty],0,COM_FUN(8));
InstallOtherMethod(UnivariatePolynomial,"ring,empty cof, indnr",true,[IsRing,IsEmpty,IsObject],0,COM_FUN(9));
InstallOtherMethod(UnivariatePolynomial,"ring,cof,indpol",true,[IsRing,IsRingElementCollection,IsUnivariateRationalFunction],0,COM_FUN(10));
InstallMethod(CoefficientsOfUnivariatePolynomial,"use laurent coeffs",true,[IsUnivariatePolynomial],0,COM_FUN(11));
RedispatchOnCondition(CoefficientsOfUnivariatePolynomial,true,[IsPolynomialFunction],[IsUnivariatePolynomial],0);
InstallMethod(DegreeOfLaurentPolynomial,true,[IsPolynomialFunction and IsLaurentPolynomial],0,COM_FUN(12));
InstallOtherMethod(DegreeIndeterminate,"laurent,indetnr",true,[IsLaurentPolynomial,IsPosInt],0,COM_FUN(13));
InstallMethod(IsPolynomial,"laurent rep.",true,[IsLaurentPolynomialDefaultRep],0,COM_FUN(14));
InstallGlobalFunction(CIUnivPols,COM_FUN(15));
InstallMethod(ExtRepNumeratorRatFun,"laurent polynomial rep.",true,[IsLaurentPolynomialDefaultRep],0,COM_FUN(16));
InstallMethod(ExtRepDenominatorRatFun,"laurent polynomial rep.",true,[IsLaurentPolynomialDefaultRep and IsRationalFunction],0,COM_FUN(17));
InstallMethod(OneOp,"univariate",true,[IsPolynomialFunction and IsUnivariateRationalFunction],0,COM_FUN(18));
InstallMethod(One,"univariate",true,[IsPolynomialFunction and IsUnivariateRationalFunction],0,OneOp);
InstallMethod(ZeroOp,"univariate",true,[IsPolynomialFunction and IsUnivariateRationalFunction],0,COM_FUN(19));
InstallMethod(Zero,"univariate",true,[IsPolynomialFunction and IsUnivariateRationalFunction],0,ZeroOp);
InstallMethod(IndeterminateOfUnivariateRationalFunction,"use `IndeterminateNumber'",true,[IsPolynomialFunction and IsUnivariateRationalFunction],0,COM_FUN(20));
InstallMethod(AdditiveInverseOp,"laurent polynomial",true,[IsPolynomialFunction and IsLaurentPolynomial],0,COM_FUN(21));
InstallMethod(InverseOp,"try to express as laurent polynomial",true,[IsPolynomialFunction and IsLaurentPolynomial],0,COM_FUN(22));
InstallMethod(\*,"laurent * laurent",IsIdenticalObj,[IsPolynomialFunction and IsLaurentPolynomial,IsPolynomialFunction and IsLaurentPolynomial],0,PRODUCT_LAURPOLS);
InstallMethod(\+,"laurent + laurent",IsIdenticalObj,[IsPolynomialFunction and IsLaurentPolynomial,IsPolynomialFunction and IsLaurentPolynomial],0,SUM_LAURPOLS);
InstallMethod(\-,"laurent - laurent",IsIdenticalObj,[IsPolynomialFunction and IsLaurentPolynomial,IsPolynomialFunction and IsLaurentPolynomial],0,DIFF_LAURPOLS);
BindGlobal("ProdCoeffLaurpol",COM_FUN(23));
InstallMethod(\*,"coeff * laurent",IsCoeffsElms,[IsRingElement,IsUnivariateRationalFunction and IsLaurentPolynomial],0,ProdCoeffLaurpol);
InstallMethod(\*,"laurent * coeff",IsElmsCoeffs,[IsUnivariateRationalFunction and IsLaurentPolynomial,IsRingElement],0,COM_FUN(24));
BindGlobal("SumCoeffLaurpol",COM_FUN(25));
InstallMethod(\+,"coeff + laurent",IsCoeffsElms,[IsRingElement,IsUnivariateRationalFunction and IsLaurentPolynomial],0,SumCoeffLaurpol);
InstallMethod(\+,"laurent + coeff",IsElmsCoeffs,[IsUnivariateRationalFunction and IsLaurentPolynomial,IsRingElement],0,COM_FUN(26));
InstallGlobalFunction(QuotRemLaurpols,COM_FUN(27));
InstallMethod(\/,"upol/upol",true,[IsLaurentPolynomial and IsPolynomial,IsLaurentPolynomial and IsPolynomial],2,COM_FUN(28));
InstallMethod(QuotientRemainder,"laurent, ring",IsCollsElmsElms,[IsPolynomialRing,IsLaurentPolynomial,IsLaurentPolynomial],0,COM_FUN(29));
RedispatchOnCondition(QuotientRemainder,IsCollsElmsElms,[IsPolynomialRing,IsRationalFunction,IsRationalFunction],[,IsLaurentPolynomial,IsLaurentPolynomial],0);
InstallOtherMethod(QuotientRemainder,"laurent",IsIdenticalObj,[IsLaurentPolynomial,IsLaurentPolynomial],0,COM_FUN(30));
RedispatchOnCondition(QuotientRemainder,IsIdenticalObj,[IsRationalFunction,IsRationalFunction],[IsLaurentPolynomial,IsLaurentPolynomial],0);
InstallMethod(Quotient,"laurent, ring",IsCollsElmsElms,[IsPolynomialRing,IsLaurentPolynomial,IsLaurentPolynomial],0,COM_FUN(31));
InstallOtherMethod(Quotient,"laurent",IsIdenticalObj,[IsLaurentPolynomial,IsLaurentPolynomial],0,COM_FUN(32));
BIND_GLOBAL("QUOMOD_UPOLY",COM_FUN(33));
InstallMethod(QuotientMod,"laurent,ring",IsCollsElmsElmsElms,[IsRing,IsLaurentPolynomial,IsLaurentPolynomial,IsLaurentPolynomial],0,COM_FUN(34));
InstallOtherMethod(QuotientMod,"laurent",IsFamFamFam,[IsLaurentPolynomial,IsLaurentPolynomial,IsLaurentPolynomial],0,QUOMOD_UPOLY);
BindGlobal("POWMOD_UPOLY",COM_FUN(35));
InstallMethod(PowerMod,"laurent,ring ",IsCollsElmsXElms,[IsPolynomialRing,IsLaurentPolynomial,IsInt,IsLaurentPolynomial],0,COM_FUN(36));
InstallOtherMethod(PowerMod,"laurent",IsFamXFam,[IsLaurentPolynomial,IsInt,IsLaurentPolynomial],0,POWMOD_UPOLY);
InstallMethod(\=,"laurent",IsIdenticalObj,[IsLaurentPolynomial,IsLaurentPolynomial],0,COM_FUN(37));
InstallMethod(\<,"Univariate Polynomials",IsIdenticalObj,[IsLaurentPolynomial,IsLaurentPolynomial],0,COM_FUN(38));
InstallGlobalFunction(RandomPol,COM_FUN(39));
InstallMethod(LeadingCoefficient,"laurent",true,[IsLaurentPolynomial],0,COM_FUN(40));
InstallMethod(LeadingMonomial,"for a univariate laurent polynomial",true,[IsLaurentPolynomial],0,COM_FUN(41));
InstallOtherMethod(EuclideanDegree,"laurent,ring",IsCollsElms,[IsPolynomialRing,IsLaurentPolynomial],0,COM_FUN(42));
InstallOtherMethod(EuclideanDegree,"laurent",true,[IsLaurentPolynomial],0,DegreeOfLaurentPolynomial);
BindGlobal("MOD_UPOLY",COM_FUN(43));
InstallOtherMethod(EuclideanRemainder,"laurent,ring",IsCollsElmsElms,[IsPolynomialRing,IsLaurentPolynomial,IsLaurentPolynomial],0,COM_FUN(44));
InstallOtherMethod(EuclideanRemainder,"laurent",IsIdenticalObj,[IsLaurentPolynomial,IsLaurentPolynomial],0,MOD_UPOLY);
InstallMethod(\mod,"laurent",IsIdenticalObj,[IsLaurentPolynomial,IsLaurentPolynomial],0,MOD_UPOLY);
InstallGlobalFunction(GcdCoeffs,GCD_COEFFS);
BindGlobal("GCD_UPOLY",COM_FUN(45));
InstallMethod(GcdOp,"univariate polynomials, ring",IsCollsElmsElms,[IsEuclideanRing,IsPolynomial,IsPolynomial],0,COM_FUN(46));
InstallOtherMethod(GcdOp,"univariate polynomials",IsIdenticalObj,[IsPolynomial and IsRationalFunction,IsPolynomial and IsRationalFunction],0,GCD_UPOLY);
RedispatchOnCondition(GcdOp,IsCollsElmsElms,[IsEuclideanRing,IsRationalFunction,IsRationalFunction],[,IsUnivariatePolynomial,IsUnivariatePolynomial],0);
RedispatchOnCondition(GcdOp,IsIdenticalObj,[IsRationalFunction,IsRationalFunction],[IsUnivariatePolynomial,IsUnivariatePolynomial],0);
InstallMethod(StandardAssociate,"laurent",IsCollsElms,[IsPolynomialRing,IsLaurentPolynomial],0,COM_FUN(47));
InstallOtherMethod(Derivative,"Laurent Polynomials",true,[IsLaurentPolynomial],0,COM_FUN(48));
RedispatchOnCondition(Derivative,true,[IsPolynomial],[IsLaurentPolynomial],0);
InstallOtherMethod(Derivative,"uratfun,ind",true,[IsUnivariateRationalFunction],0,COM_FUN(49));
RedispatchOnCondition(Derivative,true,[IsPolynomial],[IsUnivariateRationalFunction],0);
InstallOtherMethod(Discriminant,"laurent",true,[IsLaurentPolynomial],0,COM_FUN(50));
RedispatchOnCondition(Discriminant,true,[IsPolynomial],[IsLaurentPolynomial],0);
InstallOtherMethod(Value,"Laurent, ring element, and mult. neutral element",true,[IsLaurentPolynomial,IsRingElement,IsRingElement],0,COM_FUN(51));
InstallOtherMethod(Value,"univariate rational function",true,[IsUnivariateRationalFunction,IsRingElement,IsRingElement],0,COM_FUN(52));
InstallOtherMethod(Value,"supply `one'",true,[IsUnivariateRationalFunction,IsRingElement],0,COM_FUN(53));
RedispatchOnCondition(Value,true,[IsPolynomialFunction,IsRingElement],[IsUnivariateRationalFunction,IsRingElement],0);
BindGlobal("StringUnivariateLaurent",COM_FUN(54));
BindGlobal("DoPrintUnivariateLaurent",COM_FUN(55));
InstallMethod(PrintObj,"laurent polynomial",true,[IsLaurentPolynomial],0,COM_FUN(56));
InstallMethod(UnivariateRationalFunctionByCoefficients,"with indeterminate",true,[IsFamily,IsList,IsList,IsInt,IsInt],0,COM_FUN(57));
InstallOtherMethod(UnivariateRationalFunctionByCoefficients,"fam, ncof,dcof,val",true,[IsFamily,IsList,IsList,IsInt],0,COM_FUN(58));
InstallMethod(PrintObj,"univar",true,[IsUnivariateRationalFunction],0,COM_FUN(59));
InstallMethod(CoefficientsOfUnivariateRationalFunction,"laurent polynomial",true,[IsLaurentPolynomial],0,COM_FUN(60));
InstallMethod(IsLaurentPolynomial,"univariate",true,[IsUnivariateRationalFunction],0,COM_FUN(61));
InstallMethod(IsPolynomial,"univariate",true,[IsUnivariateRationalFunction],0,COM_FUN(62));
InstallOtherMethod(ExtRepPolynomialRatFun,"univariate",true,[IsUnivariateRationalFunction],0,COM_FUN(63));
RedispatchOnCondition(CoefficientsOfLaurentPolynomial,true,[IsUnivariateRationalFunction],[IsLaurentPolynomial],0);
InstallMethod(ExtRepNumeratorRatFun,"univariate",true,[IsUnivariateRationalFunction],0,COM_FUN(64));
InstallMethod(ExtRepDenominatorRatFun,"univariate",true,[IsUnivariateRationalFunction],0,COM_FUN(65));
InstallMethod(AdditiveInverseOp,"univariate",true,[IsPolynomialFunction and IsUnivariateRationalFunction],0,COM_FUN(66));
InstallMethod(InverseOp,"univariate",true,[IsPolynomialFunction and IsUnivariateRationalFunction],0,COM_FUN(67));
InstallMethod(\*,"univariate * univariate",IsIdenticalObj,[IsPolynomialFunction and IsUnivariateRationalFunction,IsPolynomialFunction and IsUnivariateRationalFunction],0,PRODUCT_UNIVFUNCS);
InstallMethod(\/,"univariate / univariate",IsIdenticalObj,[IsPolynomialFunction and IsUnivariateRationalFunction,IsRationalFunction and IsUnivariateRationalFunction],0,QUOT_UNIVFUNCS);
InstallMethod(\+,"univariate + univariate",IsIdenticalObj,[IsPolynomialFunction and IsUnivariateRationalFunction,IsPolynomialFunction and IsUnivariateRationalFunction],0,SUM_UNIVFUNCS);
InstallMethod(\-,"univariate - univariate",IsIdenticalObj,[IsPolynomialFunction and IsUnivariateRationalFunction,IsPolynomialFunction and IsUnivariateRationalFunction],0,DIFF_UNIVFUNCS);
InstallMethod(\=,"univariate = univariate",IsIdenticalObj,[IsPolynomialFunction and IsUnivariateRationalFunction,IsPolynomialFunction and IsUnivariateRationalFunction],0,COM_FUN(68));
BindGlobal("ProdCoeffUnivfunc",COM_FUN(69));
InstallMethod(\*,"coeff * univariate",IsCoeffsElms,[IsRingElement,IsPolynomialFunction and IsUnivariateRationalFunction],3,ProdCoeffUnivfunc);
InstallMethod(\*,"univariate * coeff",IsElmsCoeffs,[IsPolynomialFunction and IsUnivariateRationalFunction,IsRingElement],3,COM_FUN(70));
BindGlobal("SumCoeffUnivfunc",COM_FUN(71));
InstallMethod(\+,"coeff + univariate",IsCoeffsElms,[IsRingElement,IsPolynomialFunction and IsUnivariateRationalFunction],0,SumCoeffUnivfunc);
InstallMethod(\+,"univariate + coeff",IsElmsCoeffs,[IsPolynomialFunction and IsUnivariateRationalFunction,IsRingElement],0,COM_FUN(72));
InstallMethod(\+,"rat + univariate",true,[IsRat,IsPolynomialFunction and IsUnivariateRationalFunction],-RankFilter(IsRat),COM_FUN(73));
InstallMethod(\+,"univariate + rat",true,[IsPolynomialFunction and IsUnivariateRationalFunction,IsRat],-RankFilter(IsRat),COM_FUN(74));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/ratfunul.gi"

#F  file="lib/ringpoly.gi" crc=-65511649
RANK_FILTER_LIST  := [ 50997183, 26, 8193, 2, 50997183, 26, 8193, 2, 
  50997183, 26, 7665940, 19, 50997183, 26, 7665940, 19, 8193, 2, 50997183, 
  26, 8193, 2, 8193, 2, 50997183, 26, 50997183, 26, 50997183, 26, 7665940, 
  19, 50997183, 26, 67108760, 5, 50997183, 26, 8193, 2, 50997183, 26, 
  67108760, 5, 8193, 2, 59785924, 34, 6553496, 27, 59785924, 34, 6553496, 27, 
  50997183, 26, 7665940, 19, 1985, 1, 7665940, 19, 50997183, 26, 50997183, 
  26, 8193, 2, 50997183, 26, 67108760, 5, 50997183, 26, 67108760, 5, 8193, 2, 
  6553496, 27, 7665940, 19, 67107965, 12, 6553496, 27, 63525761, 18, 
  50997183, 26, 63011586, 6, 6553496, 27, 30895454, 14 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/ringpoly.gi", -65511649 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/ringpoly.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/ringpoly.gi");
elif COM_RESULT = 3  then
Revision.ringpoly_gi:="@(#)$Id: ringpoly.gi,v 4.41.2.3 2007/02/16 15:51:19 gap Exp $";
BindGlobal("GiveNumbersNIndeterminates",COM_FUN(1));
InstallMethod(PolynomialRing,"indetlist",true,[IsRing,IsList],1,COM_FUN(2));
InstallMethod(PolynomialRing,"names",true,[IsRing,IsList],0,COM_FUN(3));
InstallMethod(PolynomialRing,"rank",true,[IsRing,IsPosInt],0,COM_FUN(4));
InstallOtherMethod(PolynomialRing,"rank,avoid",true,[IsRing,IsPosInt,IsList],0,COM_FUN(5));
InstallOtherMethod(PolynomialRing,"names,avoid",true,[IsRing,IsList,IsList],0,COM_FUN(6));
InstallOtherMethod(PolynomialRing,true,[IsRing],0,COM_FUN(7));
InstallMethod(UnivariatePolynomialRing,"indet 1",true,[IsRing],0,COM_FUN(8));
InstallOtherMethod(UnivariatePolynomialRing,"indet number",true,[IsRing,IsPosInt],0,COM_FUN(9));
InstallOtherMethod(UnivariatePolynomialRing,"name",true,[IsRing,IsString],0,COM_FUN(10));
InstallOtherMethod(UnivariatePolynomialRing,"avoid",true,[IsRing,IsList],0,COM_FUN(11));
InstallOtherMethod(UnivariatePolynomialRing,"name,avoid",true,[IsRing,IsString,IsList],0,COM_FUN(12));
InstallMethod(ViewObj,"for a polynomial ring",true,[IsPolynomialRing],RankFilter(IsFLMLOR),COM_FUN(13));
InstallMethod(PrintObj,"for a polynomial ring",true,[IsPolynomialRing],RankFilter(IsFLMLOR),COM_FUN(14));
InstallMethod(Indeterminate,"number",true,[IsRing,IsPosInt],0,COM_FUN(15));
InstallOtherMethod(Indeterminate,"fam,number",true,[IsFamily,IsPosInt],0,COM_FUN(16));
InstallOtherMethod(Indeterminate,"number 1",true,[IsRing],0,COM_FUN(17));
InstallOtherMethod(Indeterminate,"number, avoid",true,[IsRing,IsList],0,COM_FUN(18));
InstallOtherMethod(Indeterminate,"number, name",true,[IsRing,IsString],0,COM_FUN(19));
InstallOtherMethod(Indeterminate,"number, name, avoid",true,[IsRing,IsString,IsList],0,COM_FUN(20));
InstallMethod(\.,"pring indeterminates",true,[IsPolynomialRing,IsPosInt],COM_FUN(21));
InstallMethod(\in,"polynomial in polynomial ring",IsElmsColls,[IsPolynomialFunction,IsPolynomialRing],0,COM_FUN(22));
InstallMethod(DefaultRingByGenerators,true,[IsRationalFunctionCollection],0,COM_FUN(23));
InstallOtherMethod(MinimalPolynomial,"supply indeterminate 1",[IsRing,IsMultiplicativeElement and IsAdditiveElement],COM_FUN(24));
InstallMethod(StandardAssociate,"normalize leading coefficient",IsCollsElms,[IsPolynomialRing,IsPolynomial],0,COM_FUN(25));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/ringpoly.gi"

#F  file="lib/upoly.gi" crc=-61206995
RANK_FILTER_LIST  := [ 30895454, 14, 6553496, 27, 30895454, 14, 30895454, 14, 
  50997183, 26, 30895454, 14, 50997183, 26, 30895454, 14, 24813784, 48, 
  67108010, 13 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/upoly.gi", -61206995 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/upoly.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/upoly.gi");
elif COM_RESULT = 3  then
Revision.upoly_gi:="@(#)$Id: upoly.gi,v 4.48.2.2 2005/04/13 11:45:39 gap Exp $";
InstallMethod(IrrFacsPol,true,[IsPolynomial],0,COM_FUN(1));
InstallGlobalFunction(StoreFactorsPol,COM_FUN(2));
InstallMethod(IsIrreducibleRingElement,"polynomial",IsCollsElms,[IsPolynomialRing,IsPolynomial],0,COM_FUN(3));
InstallGlobalFunction(RootsOfUPol,COM_FUN(4));
RedispatchOnCondition(Factors,true,[IsPolynomial],[IsUnivariatePolynomial],0);
RedispatchOnCondition(Factors,true,[IsRing,IsPolynomial],[,IsUnivariatePolynomial],0);
RedispatchOnCondition(IsIrreducibleRingElement,true,[IsRing,IsPolynomial],[,IsUnivariatePolynomial],0);
InstallGlobalFunction(CyclotomicPol,COM_FUN(5));
InstallGlobalFunction(CyclotomicPolynomial,COM_FUN(6));
InstallMethod(IsPrimitivePolynomial,"for a (finite) field, and a polynomial",COM_FUN(7),[IsField,IsRationalFunction],0,COM_FUN(8));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/upoly.gi"

#F  file="lib/upolyirr.gi" crc=-77259681
RANK_FILTER_LIST  := [  ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/upolyirr.gi", -77259681 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/upolyirr.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/upolyirr.gi");
elif COM_RESULT = 3  then
Revision.upolyirr_gi:="@(#)$Id: upolyirr.gi,v 4.7 2002/04/15 10:05:26 sal Exp $";
AllMonicPolynomialCoeffsOfDegree:=COM_FUN(1);
IRR_POLS_OVER_GF_CACHE:=[];
AllIrreducibleMonicPolynomialCoeffsOfDegree:=COM_FUN(2);
InstallGlobalFunction(CompanionMat,COM_FUN(3));
InstallGlobalFunction(AllIrreducibleMonicPolynomials,COM_FUN(4));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/upolyirr.gi"

#F  file="lib/polyfinf.gi" crc=-103220236
RANK_FILTER_LIST  := [ 26213981, 28, 9629322, 19, 4097, 1, 26213981, 28, 
  9629322, 19, 9629322, 19, 67108010, 13, 9629322, 19 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/polyfinf.gi", -103220236 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/polyfinf.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/polyfinf.gi");
elif COM_RESULT = 3  then
Revision.polyfinf_gi:="@(#)$Id: polyfinf.gi,v 4.35.2.1 2004/01/25 02:09:37 gap Exp $";
InstallGlobalFunction(FactorsCommonDegreePol,COM_FUN(1));
InstallMethod(FactorsSquarefree,"univariate polynomial over finite field",true,[IsFiniteFieldPolynomialRing,IsUnivariatePolynomial,IsRecord],0,COM_FUN(2));
InstallGlobalFunction(RootsRepresentativeFFPol,COM_FUN(3));
InstallMethod(Factors,"polynomial over a finite field",IsCollsElms,[IsFiniteFieldPolynomialRing,IsUnivariatePolynomial],0,COM_FUN(4));
BindGlobal("ProductPP",COM_FUN(5));
BindGlobal("LcmPP",COM_FUN(6));
BindGlobal("FFPPowerModCheck",COM_FUN(7));
InstallGlobalFunction(OrderKnownDividendList,COM_FUN(8));
InstallGlobalFunction(FFPOrderKnownDividend,COM_FUN(9));
BindGlobal("FFPUpperBoundOrder",COM_FUN(10));
InstallOtherMethod(ProjectiveOrder,"divide and conquer for univariate polynomials",true,[IsUnivariatePolynomial],0,COM_FUN(11));
RedispatchOnCondition(ProjectiveOrder,true,[IsRationalFunction],[IsUnivariatePolynomial],0);
InstallMethod(SplittingField,"finite field polynomials",true,[IsUnivariatePolynomial],0,COM_FUN(12));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/polyfinf.gi"

#F  file="lib/polyrat.gi" crc=5469470
RANK_FILTER_LIST  := [ 12980459, 17, 9629322, 19, 30895454, 14, 48945851, 34, 
  9629322, 19, 9629322, 19, 9629322, 19, 17, 18, 30895454, 14, 17, 18, 
  8388084, 29, 9629322, 19, 4097, 1, 8388084, 29, 9629322, 19, 60628801, 5, 
  8193, 2, 8193, 2 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/polyrat.gi", 5469470 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/polyrat.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/polyrat.gi");
elif COM_RESULT = 3  then
Revision.polyrat_gi:="@(#)$Id: polyrat.gi,v 4.40.2.1 2004/01/25 02:09:37 gap Exp $";
InstallGlobalFunction(APolyProd,COM_FUN(1));
InstallGlobalFunction(BPolyProd,COM_FUN(2));
BindGlobal("ApproxRational",COM_FUN(3));
APPROXROOTS:=[];
BindGlobal("ApproximateRoot",COM_FUN(4));
BindGlobal("ApproxRootBound",COM_FUN(5));
InstallGlobalFunction(RootBound,COM_FUN(6));
InstallGlobalFunction(BombieriNorm,COM_FUN(7));
InstallMethod(MinimizedBombieriNorm,true,[IsPolynomial and IsRationalFunctionsFamilyElement],0,COM_FUN(8));
BindGlobal("BeauzamyBound",COM_FUN(9));
InstallGlobalFunction(OneFactorBound,COM_FUN(10));
InstallMethod(PrimitivePolynomial,"univariate polynomial",true,[IsUnivariatePolynomial],0,COM_FUN(11));
BindGlobal("PrimitiveFacExtRepRatPol",COM_FUN(12));
InstallMethod(PrimitivePolynomial,"rational polynomial",true,[IsPolynomial],0,COM_FUN(13));
BindGlobal("BeauzamyBoundGcd",COM_FUN(14));
BindGlobal("RPGcdModPrime",COM_FUN(15));
BindGlobal("RPGcdCRT",COM_FUN(16));
BindGlobal("RPGcd1",COM_FUN(17));
BindGlobal("RPIGcd",COM_FUN(18));
InstallMethod(GcdOp,"rational univariate polynomials",IsCollsElmsElms,[IsRationalsPolynomialRing and IsEuclideanRing,IsUnivariatePolynomial,IsUnivariatePolynomial],0,COM_FUN(19));
InstallMethod(\mod,"reduction of univariate rational polynomial at a prime",true,[IsUnivariatePolynomial,IsInt],0,COM_FUN(20));
InstallMethod(\mod,"reduction of general rational polynomial at a prime",true,[IsPolynomial,IsInt],0,COM_FUN(21));
BindGlobal("RPQuotientModPrime",COM_FUN(22));
BindGlobal("RPGcdRepresentationModPrime",COM_FUN(23));
InstallGlobalFunction(HenselBound,COM_FUN(24));
InstallGlobalFunction(TrialQuotientRPF,COM_FUN(25));
InstallGlobalFunction(TryCombinations,COM_FUN(26));
BindGlobal("RPSquareHensel",COM_FUN(27));
BindGlobal("RPFactorsModPrime",COM_FUN(28));
InstallMethod(FactorsSquarefree,"univariate rational poly",true,[IsRationalsPolynomialRing,IsUnivariatePolynomial,IsRecord],0,COM_FUN(29));
BindGlobal("RPIFactors",COM_FUN(30));
InstallMethod(Factors,"univariate rational polynomial",IsCollsElms,[IsRationalsPolynomialRing,IsUnivariatePolynomial],0,COM_FUN(31));
SymAdic:=COM_FUN(32);
MAXTRYGCDHEU:=6;
InstallGlobalFunction(HeuGcdIntPolsExtRep,COM_FUN(33));
InstallGlobalFunction(HeuGcdIntPolsCoeffs,COM_FUN(34));
InstallMethod(HeuristicCancelPolynomialsExtRep,"rationals",true,[IsRationalFunctionsFamily,IsList,IsList],0,COM_FUN(35));
InstallGlobalFunction(PolynomialModP,COM_FUN(36));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/polyrat.gi"

#F  file="lib/polyconw.gi" crc=-103456530
RANK_FILTER_LIST  := [  ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/polyconw.gi", -103456530 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/polyconw.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/polyconw.gi");
elif COM_RESULT = 3  then
Revision.polyconw_gi:="@(#)$Id: polyconw.gi,v 4.19.4.5 2005/12/28 16:55:37 gap Exp $";
InstallGlobalFunction(PowerModEvalPol,COM_FUN(1));
BindGlobal("CONWAYPOLYNOMIALSINFO",rec(RP:="original list by Richard Parker (from 1980's)\n",GAP:="computed with the GAP function by Thomas Breuer, just checks\nconditions st\
arting from 'smallest' polynomial\n",FL:="computed by a parallelized program by Frank Luebeck, computes\nminimal poly\
nomial of all compatible elements (~2001)\n",KM:="computed by Kate Minola, a parallelized program for p=2, considering\nminim\
al polynomials of all compatible elements (~2004-2005)\n",RPn:="computed by Richard Parker (2004)\n",3\,21:="for p=3, n=21 there appeared a polynomial in some lists/systems\nwhich was \
not the Conway polynomial; the current one in GAP is correct\n",JB:="computed by John Bray using minimal polynomials of consistent elements, res\
pectively a similar algorithm as in GAP (~2005)\n",conwdat1:=false,conwdat2:=false,conwdat3:=false,cache:=rec()));
BindGlobal("CONWAYPOLDATA",[]);
BindGlobal("IsConsistentPolynomial",COM_FUN(2));
BindGlobal("NrCompatiblePolynomials",COM_FUN(3));
ConwayCandidates:=COM_FUN(4);
InstallGlobalFunction(ConwayPol,COM_FUN(5));
InstallGlobalFunction(ConwayPolynomial,COM_FUN(6));
InstallGlobalFunction(IsCheapConwayPolynomial,COM_FUN(7));
InstallGlobalFunction(RandomPrimitivePolynomial,COM_FUN(8));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/polyconw.gi"

#F  file="lib/listcoef.gi" crc=-24701455
RANK_FILTER_LIST  := [ 18144854, 39, 42917551, 37, 13061976, 15, 7665940, 19, 
  7665940, 19, 42352567, 11, 16385, 3, 32505602, 3, 7665940, 19, 7665940, 19, 
  16386, 5, 16385, 3, 32505602, 3, 7665940, 19, 7665940, 19, 8193, 2, 1, 0, 
  1, 0, 7665940, 19, 7665940, 19, 18144854, 39, 42917551, 37, 13061976, 15, 
  42352567, 11, 16385, 3, 32505602, 3, 15204279, 4, 15204278, 2, 257, 15, 
  7665940, 19, 7665940, 19, 15204279, 4, 15204278, 2, 319, 17, 14745813, 41, 
  14745812, 39, 319, 17, 7665940, 19, 7665940, 19, 14745813, 41, 14745812, 
  39, 319, 17, 16386, 5, 16385, 3, 32505602, 3, 8193, 2, 1, 0, 1, 0, 8193, 2, 
  1, 0, 8005418, 6, 18144854, 39, 42917551, 37, 13173339, 22, 13173338, 20, 
  14745813, 41, 14745812, 39, 16386, 5, 16385, 3, 42352567, 11, 16385, 3, 
  15204279, 4, 15204278, 2, 8193, 2, 1, 0, 16386, 5, 7665940, 19, 8193, 2, 1, 
  0, 16385, 3, 30666589, 21, 16386, 5, 16385, 3, 16385, 3, 16385, 3, 
  32505602, 3, 8193, 2, 1, 0, 1, 0, 1, 0, 1, 0, 16386, 5, 32505602, 3, 8193, 
  2, 1, 0, 42352567, 11, 32505602, 3, 18144854, 39, 13061976, 15, 14745813, 
  41, 257, 15, 8194, 4, 7665940, 19, 1, 0, 8193, 2, 1, 0, 8193, 2, 1, 0, 1, 
  0, 8193, 2, 30666589, 21, 1, 0, 8194, 4, 8193, 2, 8194, 4, 7665940, 19, 1, 
  0, 61258490, 15, 7665940, 19, 16386, 5, 16385, 3, 16385, 3, 16385, 3, 
  32505602, 3, 8193, 2, 1, 0, 1, 0, 1, 0, 1, 0, 16386, 5, 16385, 3, 32505602, 
  3, 8193, 2, 1, 0, 1, 0, 16386, 5, 16385, 3, 16386, 5, 41951068, 17, 8193, 
  2, 1, 0, 8194, 4, 16385, 3, 17, 18, 16385, 3, 17, 18, 8193, 2, 1, 0, 17, 
  18, 1, 0, 17, 18, 16386, 5, 17, 18, 16385, 3, 17, 18, 8193, 2, 17, 18, 1, 
  0, 17, 18, 16386, 5, 16385, 3, 8193, 2, 1, 0, 16386, 5, 17, 18, 16385, 3, 
  17, 18, 17, 18, 8193, 2, 17, 18, 1, 0, 17, 18, 17, 18, 16386, 5, 16385, 3, 
  17, 18, 8193, 2, 1, 0, 17, 18, 16386, 5, 17, 18, 17, 18, 8193, 2, 17, 18, 
  17, 18, 16386, 5, 17, 18, 8193, 2, 17, 18, 8193, 2, 17, 18, 8193, 2, 17, 
  18, 16385, 3, 16385, 3, 16386, 5, 1, 0, 8193, 2, 1, 0, 8194, 4, 8193, 2, 
  16385, 3, 17, 18, 17, 18, 16385, 3, 17, 18, 16385, 3, 17, 18, 17, 18, 
  16385, 3, 17, 18, 16385, 3, 17, 18, 16385, 3, 16385, 3, 17, 18, 16385, 3, 
  17, 18, 16385, 3, 16385, 3, 16385, 3, 17, 18, 41951068, 17, 17, 18, 8193, 
  2, 64918210, 8, 8193, 2, 33, 17, 8193, 2, 15212470, 12, 8193, 2, 8193, 2, 
  15212470, 12, 15212470, 12, 8193, 2, 8193, 2, 58412696, 30, 24813319, 65, 
  8193, 2, 58412696, 30, 24813319, 65, 8193, 2, 17, 18, 17, 18, 58412696, 30, 
  24813319, 65, 8193, 2, 17, 18, 17, 18, 58412696, 30, 24813319, 65, 
  42909360, 39, 67108790, 38, 17, 18 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/listcoef.gi", -24701455 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/listcoef.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/listcoef.gi");
elif COM_RESULT = 3  then
Revision.listcoef_gi:="@(#)$Id: listcoef.gi,v 4.54.2.3 2006/02/22 12:26:40 sal Exp $";
InstallMethod(AddRowVector,"kernel method for plain lists of cyclotomics",IsCollsCollsElmsXX,[IsSmallList and IsDenseList and IsMutable and IsCyclotomicCollection and IsPlistRep,IsDenseList and IsCyclotomicCollection and IsPlistRep,IsCyclotomic,IsPosInt,IsPosInt],0,ADD_ROW_VECTOR_5_FAST);
InstallMethod(AddRowVector,"kernel method for small lists",IsCollsCollsElmsXX,[IsSmallList and IsDenseList and IsMutable,IsDenseList,IsMultiplicativeElement,IsPosInt,IsPosInt],0,ADD_ROW_VECTOR_5);
InstallMethod(AddRowVector,"generic method",IsCollsCollsElmsXX,[IsDenseList and IsMutable,IsDenseList,IsMultiplicativeElement,IsPosInt,IsPosInt],0,COM_FUN(1));
L1_IMMUTABLE_ERROR:=COM_FUN(2);
InstallOtherMethod(AddRowVector,"error if immutable",true,[IsList,IsObject,IsObject,IsPosInt,IsPosInt],0,L1_IMMUTABLE_ERROR);
InstallOtherMethod(AddRowVector,"kernel method for plain lists of cyclotomics(3 args)",IsCollsCollsElms,[IsSmallList and IsDenseList and IsMutable and IsCyclotomicCollection and IsPlistRep,IsDenseList and IsPlistRep and IsCyclotomicCollection,IsCyclotomic],0,ADD_ROW_VECTOR_3_FAST);
InstallOtherMethod(AddRowVector,"kernel method for small lists (3 args)",IsCollsCollsElms,[IsSmallList and IsDenseList and IsMutable,IsDenseList,IsMultiplicativeElement],0,ADD_ROW_VECTOR_3);
InstallOtherMethod(AddRowVector,"kernel method for GF2 (5 args, last 2 ignored)",IsCollsCollsElmsXX,[IsGF2VectorRep and IsMutable,IsGF2VectorRep,IS_FFE,IsPosInt,IsPosInt],0,COM_FUN(3));
InstallOtherMethod(AddRowVector,"kernel method for GF2 (3 args)",IsCollsCollsElms,[IsGF2VectorRep and IsMutable,IsGF2VectorRep,IS_FFE and IsInternalRep],0,ADDCOEFFS_GF2VEC_GF2VEC_MULT);
InstallOtherMethod(AddRowVector,"kernel method for vecffe (5 args -- ignores last 2)",IsCollsCollsElmsXX,[IsRowVector and IsMutable and IsPlistRep and IsFFECollection,IsRowVector and IsPlistRep and IsFFECollection,IS_FFE and IsInternalRep,IsPosInt,IsPosInt],0,COM_FUN(4));
InstallOtherMethod(AddRowVector,"kernel method for vecffe (3 args)",IsCollsCollsElms,[IsRowVector and IsMutable and IsPlistRep and IsFFECollection,IsRowVector and IsPlistRep and IsFFECollection,IS_FFE and IsInternalRep],0,ADD_ROWVECTOR_VECFFES_3);
InstallOtherMethod(AddRowVector,"generic method 3 args",IsCollsCollsElms,[IsDenseList and IsMutable,IsDenseList,IsMultiplicativeElement],0,COM_FUN(5));
InstallOtherMethod(AddRowVector,"error if immutable",true,[IsList,IsObject,IsObject],0,L1_IMMUTABLE_ERROR);
InstallOtherMethod(AddRowVector,"do nothing if mult is zero",IsCollsCollsElms,[IsList,IsObject,IsObject and IsZero],SUM_FLAGS,ReturnTrue);
InstallOtherMethod(AddRowVector,"kernel method for plain lists of cyclotomics (2 args)",IsIdenticalObj,[IsSmallList and IsDenseList and IsMutable and IsCyclotomicCollection and IsPlistRep,IsDenseList and IsCyclotomicCollection and IsPlistRep],0,ADD_ROW_VECTOR_2_FAST);
InstallOtherMethod(AddRowVector,"kernel method for GF2 (2 args)",IsIdenticalObj,[IsGF2VectorRep and IsMutable and IsRowVector,IsGF2VectorRep and IsRowVector],0,ADDCOEFFS_GF2VEC_GF2VEC);
InstallOtherMethod(AddRowVector,"kernel method for vecffe (2 args)",IsIdenticalObj,[IsRowVector and IsMutable and IsPlistRep and IsFFECollection,IsRowVector and IsPlistRep and IsFFECollection],0,ADD_ROWVECTOR_VECFFES_2);
InstallOtherMethod(AddRowVector,"generic method (2 args)",IsIdenticalObj,[IsDenseList and IsMutable,IsDenseList],0,COM_FUN(6));
InstallOtherMethod(AddRowVector,"kernel method for small lists (2 args)",IsIdenticalObj,[IsSmallList and IsDenseList and IsMutable,IsDenseList],0,ADD_ROW_VECTOR_2);
InstallOtherMethod(AddRowVector,"kernel method for GF2 (2 args)",IsIdenticalObj,[IsGF2VectorRep and IsMutable,IsGF2VectorRep],0,ADDCOEFFS_GF2VEC_GF2VEC);
InstallOtherMethod(AddRowVector,"error if immutable",true,[IsList,IsObject],0,L1_IMMUTABLE_ERROR);
InstallMethod(LeftShiftRowVector,"generic method",true,[IsDenseList and IsMutable,IsPosInt],0,COM_FUN(7));
InstallOtherMethod(LeftShiftRowVector,"error if immutable",true,[IsList,IsObject],0,L1_IMMUTABLE_ERROR);
InstallOtherMethod(LeftShiftRowVector,true,[IsDenseList,IsInt and IsZeroCyc],SUM_FLAGS,COM_FUN(8));
InstallMethod(MultRowVector,"generic method",true,[IsDenseList and IsMutable,IsDenseList,IsDenseList,IsDenseList,IsMultiplicativeElement],0,COM_FUN(9));
InstallOtherMethod(MultRowVector,"error if immutable",true,[IsList,IsObject,IsObject,IsObject,IsObject],0,L1_IMMUTABLE_ERROR);
InstallOtherMethod(MultRowVector,"two argument generic method",true,[IsDenseList and IsMutable,IsMultiplicativeElement],0,COM_FUN(10));
InstallOtherMethod(MultRowVector,"error if immutable",true,[IsList,IsObject],0,L1_IMMUTABLE_ERROR);
InstallOtherMethod(MultRowVector,"Two argument kernel method for small list",IsCollsElms,[IsSmallList and IsDenseList and IsMutable,IsMultiplicativeElement],0,MULT_ROW_VECTOR_2);
InstallOtherMethod(MultRowVector,"Two argument kernel method for plain list of cyclotomics and an integer",IsCollsElms,[IsSmallList and IsDenseList and IsMutable and IsPlistRep and IsCyclotomicCollection,IsCyclotomic],0,MULT_ROW_VECTOR_2_FAST);
InstallOtherMethod(MultRowVector,"kernel method for vecffe (2 args)",IsCollsElms,[IsRowVector and IsMutable and IsPlistRep and IsFFECollection,IsFFE],0,MULT_ROWVECTOR_VECFFES);
InstallMethod(RightShiftRowVector,"generic method",true,[IsList and IsMutable,IsPosInt,IsObject],0,COM_FUN(11));
InstallOtherMethod(RightShiftRowVector,"error if immutable",true,[IsList,IsObject],0,L1_IMMUTABLE_ERROR);
InstallOtherMethod(RightShiftRowVector,"error if immutable",true,[IsList,IsObject,IsObject],0,L1_IMMUTABLE_ERROR);
InstallOtherMethod(RightShiftRowVector,true,[IsList,IsInt and IsZeroCyc,IsObject],SUM_FLAGS,COM_FUN(12));
InstallMethod(ShrinkRowVector,"generic method",true,[IsList and IsMutable],0,COM_FUN(13));
InstallOtherMethod(ShrinkRowVector,"error if immutable",true,[IsList],0,L1_IMMUTABLE_ERROR);
InstallMethod(PadCoeffs,"pad with supplied value",IsCollsXElms,[IsList and IsMutable,IsPosInt,IsObject],COM_FUN(14));
InstallMethod(PadCoeffs,"pad with zero",[IsList and IsMutable and IsAdditiveElementWithZeroCollection,IsPosInt],COM_FUN(15));
InstallMethod(AddCoeffs,"generic method (5 args)",true,[IsDenseList and IsMutable,IsDenseList,IsDenseList,IsDenseList,IsMultiplicativeElement],0,COM_FUN(16));
InstallOtherMethod(AddCoeffs,"error if immutable",true,[IsList,IsObject,IsObject,IsObject,IsObject],0,L1_IMMUTABLE_ERROR);
InstallOtherMethod(AddCoeffs,"generic method 3args",true,[IsDenseList and IsMutable,IsDenseList,IsMultiplicativeElement],0,ADDCOEFFS_GENERIC_3);
InstallOtherMethod(AddCoeffs,"error if immutable",true,[IsList,IsObject,IsObject],0,L1_IMMUTABLE_ERROR);
InstallOtherMethod(AddCoeffs,"generic method (2 args)",true,[IsDenseList and IsMutable,IsDenseList],0,COM_FUN(17));
InstallOtherMethod(AddCoeffs,"generic method (2nd arg empty)",true,[IsDenseList and IsMutable,IsList and IsEmpty],0,COM_FUN(18));
InstallOtherMethod(AddCoeffs,"error if immutable",true,[IsList,IsObject],0,L1_IMMUTABLE_ERROR);
InstallMethod(MultCoeffs,"generic method",true,[IsList and IsMutable,IsDenseList,IsInt,IsDenseList,IsInt],0,COM_FUN(19));
InstallOtherMethod(MultCoeffs,"error if immutable",true,[IsList,IsObject,IsInt,IsObject,IsInt],0,L1_IMMUTABLE_ERROR);
InstallMethod(ReduceCoeffs,"generic method",true,[IsDenseList and IsMutable,IsInt,IsDenseList,IsInt],0,COM_FUN(20));
InstallOtherMethod(ReduceCoeffs,"error if immutable",true,[IsList,IsInt,IsObject,IsInt],0,L1_IMMUTABLE_ERROR);
InstallOtherMethod(ReduceCoeffs,true,[IsDenseList and IsMutable,IsDenseList],0,COM_FUN(21));
InstallOtherMethod(ReduceCoeffs,"error if immutable",true,[IsList,IsObject],0,L1_IMMUTABLE_ERROR);
InstallMethod(ReduceCoeffsMod,"generic method (5 args)",true,[IsDenseList and IsMutable,IsInt,IsDenseList,IsInt,IsInt],0,COM_FUN(22));
InstallOtherMethod(ReduceCoeffsMod,"error if immutable",true,[IsList,IsInt,IsObject,IsInt,IsInt],0,L1_IMMUTABLE_ERROR);
InstallOtherMethod(ReduceCoeffsMod,"generic: list,list,int",true,[IsDenseList and IsMutable,IsDenseList,IsInt],0,COM_FUN(23));
InstallOtherMethod(ReduceCoeffsMod,"error if immutable",true,[IsList,IsObject,IsInt],0,L1_IMMUTABLE_ERROR);
InstallOtherMethod(ReduceCoeffsMod,"generic: list, int,int",true,[IsDenseList and IsMutable,IsInt,IsInt],0,COM_FUN(24));
InstallOtherMethod(ReduceCoeffsMod,"error if immutable",true,[IsList,IsInt,IsInt],0,L1_IMMUTABLE_ERROR);
InstallOtherMethod(ReduceCoeffsMod,true,[IsDenseList and IsMutable,IsInt],0,COM_FUN(25));
InstallOtherMethod(ReduceCoeffsMod,"error if immutable",true,[IsList,IsInt],0,L1_IMMUTABLE_ERROR);
InstallMethod(QuotRemCoeffs,"generic",[IsList,IsInt,IsList,IsInt],COM_FUN(26));
InstallOtherMethod(QuotRemCoeffs,"generic, use list lengths",true,[IsDenseList,IsDenseList],0,COM_FUN(27));
InstallMethod(RemoveOuterCoeffs,"generic method",true,[IsDenseList and IsMutable,IsObject],0,REMOVE_OUTER_COEFFS_GENERIC);
InstallOtherMethod(RemoveOuterCoeffs,"error if immutable",true,[IsList,IsObject],0,L1_IMMUTABLE_ERROR);
InstallMethod(ShrinkCoeffs,"call `ShrinkRowVector'",true,[IsList and IsMutable],0,COM_FUN(28));
InstallOtherMethod(ShrinkCoeffs,"error if immutable",true,[IsList],0,L1_IMMUTABLE_ERROR);
InstallMethod(CoeffsMod,"call `ReduceCoeffsMod'",true,[IsDenseList,IsInt,IsInt],0,COM_FUN(29));
InstallOtherMethod(CoeffsMod,true,[IsDenseList,IsInt],0,COM_FUN(30));
InstallMethod(PowerModCoeffs,"default five argt method",true,[IsDenseList,IsInt,IsInt,IsDenseList,IsInt],0,COM_FUN(31));
InstallOtherMethod(PowerModCoeffs,"default, 3 argt",true,[IsDenseList,IsInt,IsDenseList],0,COM_FUN(32));
InstallMethod(ProductCoeffs,"call PRODUCT_COEFFS_GENERIC_LISTS",true,[IsDenseList,IsInt,IsDenseList,IsInt],0,PRODUCT_COEFFS_GENERIC_LISTS);
InstallOtherMethod(ProductCoeffs,"call PRODUCT_COEFFS_GENERIC_LISTS with lengths",true,[IsDenseList,IsDenseList],0,COM_FUN(33));
InstallMethod(ShiftedCoeffs,"call ShiftRowVektor",true,[IsDenseList,IsInt],0,COM_FUN(34));
InstallMethod(ShiftedCoeffs,"empty list",true,[IsList and IsEmpty,IsInt],0,COM_FUN(35));
InstallGlobalFunction(ProductPol,COM_FUN(36));
InstallMethod(ValuePol,"generic",true,[IsList,IsRingElement],0,COM_FUN(37));
InstallMethod(ValuePol,"special code for rational values",true,[IsList,IsRat],0,COM_FUN(38));
QuotRemPolList:=COM_FUN(39);
InstallMethod(WeightVecFFE,"generic",true,[IsList],0,COM_FUN(40));
InstallMethod(WeightVecFFE,"gf2 vectors",true,[IsGF2VectorRep and IsList],0,COM_FUN(41));
InstallMethod(DistanceVecFFE,"generic",IsIdenticalObj,[IsList,IsList],0,COM_FUN(42));
InstallMethod(DistanceVecFFE,"gf2 vectors",IsIdenticalObj,[IsGF2VectorRep and IsList,IsGF2VectorRep and IsList],0,DIST_GF2VEC_GF2VEC);
InstallMethod(DistancesDistributionVecFFEsVecFFE,"generic",IsCollsElms,[IsList,IsList],0,COM_FUN(43));
DistVecClosVecLib:=COM_FUN(44);
InstallMethod(DistancesDistributionMatFFEVecFFE,"generic",IsCollsElmsElms,[IsMatrix,IsFFECollection and IsField,IsList],0,COM_FUN(45));
AClosVecLib:=COM_FUN(46);
AClosestVectorDriver:=COM_FUN(47);
InstallMethod(AClosestVectorCombinationsMatFFEVecFFE,"generic",COM_FUN(48),[IsMatrix,IsFFECollection and IsField,IsList,IsInt,IsInt],0,COM_FUN(49));
InstallMethod(AClosestVectorCombinationsMatFFEVecFFECoords,"generic",COM_FUN(50),[IsMatrix,IsFFECollection and IsField,IsList,IsInt,IsInt],0,COM_FUN(51));
CosetLeadersInner:=COM_FUN(52);
MakeReadOnlyGlobal("CosetLeadersInner");
InstallMethod(CosetLeadersMatFFE,"generic",IsCollsElms,[IsMatrix,IsFFECollection and IsField],0,COM_FUN(53));
InstallMethod(AddToListEntries,"fast kernel method",true,[IsList and IsPlistRep and IsMutable and IsCyclotomicCollection,IsRange and IsRangeRep,IsInt],0,ADD_TO_LIST_ENTRIES_PLIST_RANGE);
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/listcoef.gi"

#F  file="lib/algfld.gi" crc=130817318
RANK_FILTER_LIST  := [ 9629322, 19, 24813784, 48, 9629322, 19, 24813784, 48, 
  9629322, 19, 24813784, 48, 9629322, 19, 67108760, 5, 24813784, 48, 9629322, 
  19, 32760020, 51, 32760020, 51, 7820072, 13, 20861466, 13, 39480865, 4, 
  64918210, 8, 39480865, 4, 8193, 2, 13041395, 13, 26082789, 13, 13041395, 
  13, 26082789, 13, 26082789, 13, 26082789, 13, 26082789, 13, 13041395, 13, 
  13041395, 13, 26082789, 13, 13041395, 13, 13041395, 13, 26082789, 13, 
  64918210, 8, 64918210, 8, 26082789, 13, 13041395, 13, 64918210, 8, 
  64918210, 8, 13041395, 13, 26082789, 13, 13041395, 13, 26082789, 13, 
  26082789, 13, 26082789, 13, 13041395, 13, 13041395, 13, 26082789, 13, 
  13041395, 13, 13041395, 13, 61887557, 11, 64918210, 8, 64918210, 8, 
  61887557, 11, 61887557, 11, 63198130, 7, 63198130, 7, 61887557, 11, 
  26082789, 13, 13041395, 13, 26082789, 13, 26082789, 13, 26082789, 13, 
  13041395, 13, 13041395, 13, 26082789, 13, 13041395, 13, 13041395, 13, 
  26082789, 13, 64918210, 8, 64918210, 8, 26082789, 13, 13041395, 13, 
  64918210, 8, 64918210, 8, 13041395, 13, 26082789, 13, 26082789, 13, 
  26082789, 13, 13041395, 13, 13041395, 13, 26082789, 13, 13041395, 13, 
  13041395, 13, 26082789, 13, 64918210, 8, 64918210, 8, 26082789, 13, 
  13041395, 13, 64918210, 8, 64918210, 8, 13041395, 13, 61887557, 11, 
  7665940, 19, 61887557, 11, 24211395, 49, 64918210, 8, 24211395, 49, 
  24813784, 48, 61887557, 11, 7665940, 19, 24211395, 49, 33, 17, 7820072, 13, 
  20861466, 13, 24211395, 49, 24211395, 49, 52166537, 12, 52166537, 12, 
  61887557, 11, 52166537, 12, 30625149, 10, 61887557, 11, 51454183, 23, 
  9746774, 35, 24211395, 49, 37748002, 28, 9629322, 19, 4097, 1, 37748002, 
  28, 9629322, 19, 37748002, 28, 9629322, 19 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/algfld.gi", 130817318 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/algfld.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/algfld.gi");
elif COM_RESULT = 3  then
Revision.algfld_gi:="@(#)$Id: algfld.gi,v 4.51.2.3 2007/08/22 11:45:09 gap Exp $";
DeclareRepresentation("IsAlgebraicExtensionDefaultRep",IsAlgebraicExtension and IsComponentObjectRep and IsAttributeStoringRep,["extFam"]);
DeclareRepresentation("IsAlgBFRep",IsPositionalObjectRep and IsAlgebraicElement,[]);
DeclareRepresentation("IsAlgExtRep",IsPositionalObjectRep and IsAlgebraicElement,[]);
InstallMethod(AlgebraicElementsFamilies,true,[IsUnivariatePolynomial],0,COM_FUN(1));
StoreAlgExtFam:=COM_FUN(2);
InstallMethod(AlgebraicElementsFamily,"generic",true,[IsField,IsUnivariatePolynomial],0,COM_FUN(3));
DoAlgebraicExt:=COM_FUN(4);
InstallMethod(AlgebraicExtension,"generic",true,[IsField,IsUnivariatePolynomial],0,DoAlgebraicExt);
InstallOtherMethod(AlgebraicExtension,"with name",true,[IsField,IsUnivariatePolynomial,IsString],0,DoAlgebraicExt);
InstallMethod(FieldExtension,"generic",true,[IsField,IsUnivariatePolynomial],0,AlgebraicExtension);
InstallMethod(PrintObj,"for algebraic extension",true,[IsNumberField and IsAlgebraicExtension],0,COM_FUN(5));
InstallMethod(ViewObj,"for algebraic extension",true,[IsNumberField and IsAlgebraicExtension],0,COM_FUN(6));
InstallMethod(ExtRepOfObj,"baseFieldElm",true,[IsAlgebraicElement and IsAlgBFRep],0,COM_FUN(7));
InstallMethod(ExtRepOfObj,"ExtElm",true,[IsAlgebraicElement and IsAlgExtRep],0,COM_FUN(8));
InstallMethod(ObjByExtRep,"baseFieldElm",true,[IsAlgebraicElementFamily,IsRingElement],0,COM_FUN(9));
InstallMethod(ObjByExtRep,"ExtElm",true,[IsAlgebraicElementFamily,IsList],0,COM_FUN(10));
BindGlobal("AlgExtElm",COM_FUN(11));
InstallMethod(PrintObj,"BFElm",true,[IsAlgBFRep],0,COM_FUN(12));
InstallMethod(PrintObj,"AlgElm",true,[IsAlgExtRep],0,COM_FUN(13));
InstallMethod(String,"BFElm",true,[IsAlgBFRep],0,COM_FUN(14));
InstallMethod(String,"AlgElm",true,[IsAlgExtRep],0,COM_FUN(15));
InstallMethod(\+,"AlgElm+AlgElm",IsIdenticalObj,[IsAlgExtRep,IsAlgExtRep],0,COM_FUN(16));
InstallMethod(\+,"AlgElm+BFElm",IsIdenticalObj,[IsAlgExtRep,IsAlgBFRep],0,COM_FUN(17));
InstallMethod(\+,"BFElm+AlgElm",IsIdenticalObj,[IsAlgBFRep,IsAlgExtRep],0,COM_FUN(18));
InstallMethod(\+,"BFElm+BFElm",IsIdenticalObj,[IsAlgBFRep,IsAlgBFRep],0,COM_FUN(19));
InstallMethod(\+,"AlgElm+FElm",IsElmsCoeffs,[IsAlgExtRep,IsRingElement],0,COM_FUN(20));
InstallMethod(\+,"FElm+AlgElm",IsCoeffsElms,[IsRingElement,IsAlgExtRep],0,COM_FUN(21));
InstallMethod(\+,"BFElm+FElm",IsElmsCoeffs,[IsAlgBFRep,IsRingElement],0,COM_FUN(22));
InstallMethod(\+,"FElm+BFElm",IsCoeffsElms,[IsRingElement,IsAlgBFRep],0,COM_FUN(23));
InstallMethod(AdditiveInverseOp,"AlgElm",true,[IsAlgExtRep],0,COM_FUN(24));
InstallMethod(AdditiveInverseOp,"BFElm",true,[IsAlgBFRep],0,COM_FUN(25));
InstallMethod(\*,"AlgElm*AlgElm",IsIdenticalObj,[IsAlgExtRep,IsAlgExtRep],0,COM_FUN(26));
InstallMethod(\*,"AlgElm*BFElm",IsIdenticalObj,[IsAlgExtRep,IsAlgBFRep],0,COM_FUN(27));
InstallMethod(\*,"BFElm*AlgElm",IsIdenticalObj,[IsAlgBFRep,IsAlgExtRep],0,COM_FUN(28));
InstallMethod(\*,"BFElm*BFElm",IsIdenticalObj,[IsAlgBFRep,IsAlgBFRep],0,COM_FUN(29));
InstallMethod(\*,"Alg*FElm",IsElmsCoeffs,[IsAlgebraicElement,IsRingElement],0,COM_FUN(30));
InstallMethod(\*,"FElm*Alg",IsCoeffsElms,[IsRingElement,IsAlgebraicElement],0,COM_FUN(31));
InstallMethod(\*,"Alg*List",true,[IsAlgebraicElement,IsVector],0,COM_FUN(32));
InstallMethod(\*,"List*Alg",true,[IsVector,IsAlgebraicElement],0,COM_FUN(33));
InstallMethod(InverseOp,"AlgElm",true,[IsAlgExtRep],0,COM_FUN(34));
InstallMethod(InverseOp,"BFElm",true,[IsAlgBFRep],0,COM_FUN(35));
InstallMethod(\<,"AlgElm<AlgElm",IsIdenticalObj,[IsAlgExtRep,IsAlgExtRep],0,COM_FUN(36));
InstallMethod(\<,"AlgElm<BFElm",IsIdenticalObj,[IsAlgExtRep,IsAlgBFRep],0,COM_FUN(37));
InstallMethod(\<,"BFElm<AlgElm",IsIdenticalObj,[IsAlgBFRep,IsAlgExtRep],0,COM_FUN(38));
InstallMethod(\<,"BFElm<BFElm",IsIdenticalObj,[IsAlgBFRep,IsAlgBFRep],0,COM_FUN(39));
InstallMethod(\<,"AlgElm<FElm",true,[IsAlgExtRep,IsRingElement],0,COM_FUN(40));
InstallMethod(\<,"FElm<AlgElm",true,[IsRingElement,IsAlgExtRep],0,COM_FUN(41));
InstallMethod(\<,"BFElm<FElm",true,[IsAlgBFRep,IsRingElement],0,COM_FUN(42));
InstallMethod(\<,"FElm<BFElm",true,[IsRingElement,IsAlgBFRep],0,COM_FUN(43));
InstallMethod(\=,"AlgElm=AlgElm",IsIdenticalObj,[IsAlgExtRep,IsAlgExtRep],0,COM_FUN(44));
InstallMethod(\=,"AlgElm=BFElm",IsIdenticalObj,[IsAlgExtRep,IsAlgBFRep],0,COM_FUN(45));
InstallMethod(\=,"BFElm<AlgElm",IsIdenticalObj,[IsAlgBFRep,IsAlgExtRep],0,COM_FUN(46));
InstallMethod(\=,"BFElm=BFElm",IsIdenticalObj,[IsAlgBFRep,IsAlgBFRep],0,COM_FUN(47));
InstallMethod(\=,"AlgElm=FElm",true,[IsAlgExtRep,IsRingElement],0,COM_FUN(48));
InstallMethod(\=,"FElm=AlgElm",true,[IsRingElement,IsAlgExtRep],0,COM_FUN(49));
InstallMethod(\=,"BFElm=FElm",true,[IsAlgBFRep,IsRingElement],0,COM_FUN(50));
InstallMethod(\=,"FElm=BFElm",true,[IsRingElement,IsAlgBFRep],0,COM_FUN(51));
InstallMethod(\mod,"AlgElm",IsElmsCoeffs,[IsAlgebraicElement,IsPosInt],0,COM_FUN(52));
InstallMethod(\in,"Alg in Ext",true,[IsAlgebraicElement,IsAlgebraicExtension],0,COM_FUN(53));
InstallMethod(\in,"FElm in Ext",true,[IsRingElement,IsAlgebraicExtension],0,COM_FUN(54));
InstallMethod(MinimalPolynomial,"AlgElm",true,[IsField,IsAlgebraicElement,IsPosInt],0,COM_FUN(55));
InstallMethod(Random,"Alg",true,[IsAlgebraicExtension],0,COM_FUN(56));
InstallMethod(MaxNumeratorCoeffAlgElm,"rational",true,[IsRat],0,COM_FUN(57));
InstallMethod(MaxNumeratorCoeffAlgElm,"algebraic element",true,[IsAlgebraicElement and IsAlgBFRep],0,COM_FUN(58));
InstallMethod(MaxNumeratorCoeffAlgElm,"algebraic element",true,[IsAlgebraicElement and IsAlgExtRep],0,COM_FUN(59));
InstallMethod(Basis,"for an algebraic extension (delegate to `CanonicalBasis')",[IsAlgebraicExtension],CANONICAL_BASIS_FLAGS,CanonicalBasis);
DeclareRepresentation("IsCanonicalBasisAlgebraicExtension",IsBasis and IsCanonicalBasis and IsAttributeStoringRep,[]);
InstallMethod(CanonicalBasis,"for an algebraic extension",true,[IsAlgebraicExtension],0,COM_FUN(60));
InstallMethod(BasisVectors,"for canon. basis of an algebraic extension",[IsCanonicalBasisAlgebraicExtension],COM_FUN(61));
InstallMethod(Coefficients,"for canon. basis of an algebraic extension, and alg. element",IsCollsElms,[IsCanonicalBasisAlgebraicExtension,IsAlgebraicElement],0,COM_FUN(62));
InstallMethod(Coefficients,"for canon. basis of an algebraic extension, and scalar",true,[IsCanonicalBasisAlgebraicExtension,IsScalar],0,COM_FUN(63));
InstallMethod(Characteristic,"alg elm",true,[IsAlgebraicElement],0,COM_FUN(64));
InstallMethod(DefaultFieldByGenerators,"alg elms",[IsList and IsAlgebraicElementCollection],0,COM_FUN(65));
InstallMethod(DefaultFieldOfMatrixGroup,"alg elms",[IsGroup and IsAlgebraicElementCollCollColl and HasGeneratorsOfGroup],0,COM_FUN(66));
InstallGlobalFunction(AlgExtEmbeddedPol,COM_FUN(67));
BindGlobal("AlgExtFactSQFree",COM_FUN(68));
InstallMethod(DefectApproximation,"Algebraic Extension",true,[IsAlgebraicExtension],0,COM_FUN(69));
BindGlobal("ChaNuPol",COM_FUN(70));
BindGlobal("AlgebraicPolynomialModP",COM_FUN(71));
BindGlobal("AlgFacUPrep",COM_FUN(72));
BindGlobal("TransferedExtensionPol",COM_FUN(73));
BindGlobal("OrthogonalityDefectEuclideanLattice",COM_FUN(74));
InstallGlobalFunction(AlgExtSquareHensel,COM_FUN(75));
InstallMethod(FactorsSquarefree,"polynomial/alg. ext.",IsCollsElmsX,[IsAlgebraicExtensionPolynomialRing,IsUnivariatePolynomial,IsRecord],COM_FUN(76));
InstallMethod(Factors,"alg ext polynomial",IsCollsElms,[IsAlgebraicExtensionPolynomialRing,IsUnivariatePolynomial],0,COM_FUN(77));
InstallMethod(IsIrreducibleRingElement,"AlgPol",true,[IsAlgebraicExtensionPolynomialRing,IsUnivariatePolynomial],0,COM_FUN(78));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/algfld.gi"

#F  file="lib/groebner.gi" crc=51612764
RANK_FILTER_LIST  := [ 12517272, 5, 5, 1, 30895454, 14, 67107965, 12, 
  39812596, 1, 67107965, 12, 39812596, 1, 67107965, 12, 39812596, 1, 
  63558529, 25, 39812596, 1, 43219145, 33, 43219145, 33, 39812596, 1, 
  42169804, 34, 39812596, 1, 63558529, 25, 39812596, 1, 43219145, 33, 
  39812596, 1, 30895454, 14, 43219145, 33 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/groebner.gi", 51612764 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/groebner.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/groebner.gi");
elif COM_RESULT = 3  then
Revision.groebner_gi:="@(#)$Id: groebner.gi,v 4.1.2.6 2006/03/02 18:00:12 gap Exp $";
BindGlobal("MakeMonomialOrdering",COM_FUN(1));
BindGlobal("InstallMonomialOrdering",COM_FUN(2));
InstallMethod(MonomialComparisonFunction,"default: use extrep",true,[IsMonomialOrderingDefaultRep],0,COM_FUN(3));
InstallMonomialOrdering(MonomialLexOrdering,COM_FUN(4),COM_FUN(5),"lp");
InstallMonomialOrdering(MonomialGrlexOrdering,COM_FUN(6),COM_FUN(7),"Dp");
InstallMonomialOrdering(MonomialGrevlexOrdering,COM_FUN(8),COM_FUN(9),"dp");
InstallGlobalFunction(EliminationOrdering,COM_FUN(10));
InstallMethod(MonomialExtrepComparisonFun,"functions are themselves -- for compatibility",true,[IsFunction],0,COM_FUN(1\
1));
InstallOtherMethod(OccuringVariableIndices,"polynomial",true,[IsPolynomial],0,COM_FUN(12));
InstallMethod(LeadingTermOfPolynomial,"with ordering",true,[IsPolynomialFunction,IsMonomialOrdering],0,COM_FUN(13));
InstallOtherMethod(LeadingMonomialOfPolynomial,"with ordering",true,[IsPolynomialFunction,IsMonomialOrdering],0,COM_FUN(14));
InstallOtherMethod(LeadingCoefficientOfPolynomial,"with ordering",true,[IsPolynomialFunction,IsMonomialOrdering],0,COM_FUN(15));
BindGlobal("SPolynomial",COM_FUN(16));
InstallGlobalFunction(PolynomialReduction,COM_FUN(17));
InstallGlobalFunction(PolynomialReducedRemainder,COM_FUN(18));
InstallGlobalFunction(PolynomialDivisionAlgorithm,COM_FUN(19));
BindGlobal("SyzygyCriterion",COM_FUN(20));
BindGlobal("GAPGBASIS",rec(name:="naive GAP version of Buchberger's algorithm",GroebnerBasis:=COM_FUN(21)));
GBASIS:=GAPGBASIS;
InstallGlobalFunction(GroebnerBasisNC,COM_FUN(22));
InstallMethod(GroebnerBasis,"polynomials",true,[IsHomogeneousList and IsRationalFunctionCollection,IsMonomialOrdering],0,COM_FUN(23));
InstallMethod(StoredGroebnerBasis,"ideal",true,[IsPolynomialRingIdeal],0,COM_FUN(24));
InstallMethod(GroebnerBasis,"ideal",true,[IsPolynomialRingIdeal,IsMonomialOrdering],0,COM_FUN(25));
InstallMethod(GroebnerBasis,"ideal with stored GB",true,[IsPolynomialRingIdeal and HasStoredGroebnerBasis,IsMonomialOrdering],0,COM_FUN(26));
InstallMethod(ReducedGroebnerBasis,"polynomials",true,[IsHomogeneousList and IsRationalFunctionCollection,IsMonomialOrdering],0,COM_FUN(27));
InstallMethod(ReducedGroebnerBasis,"ideal",true,[IsPolynomialRingIdeal,IsMonomialOrdering],0,COM_FUN(28));
InstallMethod(\in,"polynomial ideal",true,[IsPolynomial,IsPolynomialRingIdeal],0,COM_FUN(29));
BindGlobal("Naive",COM_FUN(30));
BindGlobal("CANGB",COM_FUN(31));
DoTest:=COM_FUN(32);
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/groebner.gi"

#F  file="lib/unknown.gi" crc=-2995805
RANK_FILTER_LIST  := [ 7665940, 19, 29588709, 18, 59473395, 16, 65, 16, 65, 
  16, 59473395, 16, 29588709, 18, 29588709, 18, 59473395, 16, 65, 16, 65, 16, 
  59473395, 16, 29588709, 18, 29588709, 18, 59473395, 16, 65, 16, 65, 16, 
  59473395, 16, 59473395, 16, 59473395, 16, 59473395, 16, 65, 16, 65, 16, 
  59473395, 16, 29588709, 18, 29588709, 18, 59473395, 16, 65, 16, 65, 16, 
  59473395, 16, 59473395, 16, 59473395, 16, 59473395, 16, 65, 16, 59473395, 
  16, 7665940, 19, 29588709, 18 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/unknown.gi", -2995805 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/unknown.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/unknown.gi");
elif COM_RESULT = 3  then
Revision.unknown_gi:="@(#)$Id: unknown.gi,v 4.9 2002/04/15 10:05:25 sal Exp $";
DeclareRepresentation("IsUnknownDefaultRep",IsPositionalObjectRep,[1]);
BindGlobal("UnknownsType",NewType(CyclotomicsFamily,IsUnknown and IsUnknownDefaultRep));
InstallMethod(Unknown,"for positive integer",true,[IsPosInt],0,COM_FUN(1));
InstallMethod(Unknown,"for empty argument",true,[],0,COM_FUN(2));
InstallMethod(PrintObj,"for unknown in default representation",true,[IsUnknown and IsUnknownDefaultRep],0,COM_FUN(3));
InstallMethod(\=,"for unknown and cyclotomic",true,[IsUnknown,IsCyc],0,ReturnFalse);
InstallMethod(\=,"for cyclotomic and unknown",true,[IsCyc,IsUnknown],0,ReturnFalse);
InstallMethod(\=,"for two unknowns in default representation",true,[IsUnknown and IsUnknownDefaultRep,IsUnknown and IsUnknownDefaultRep],0,COM_FUN(4));
InstallMethod(\<,"for unknown and cyclotomic",true,[IsUnknown,IsCyc],0,ReturnFalse);
InstallMethod(\<,"for cyclotomic and unknown",true,[IsCyc,IsUnknown],0,ReturnTrue);
InstallMethod(\<,"for two unknowns in default representation",true,[IsUnknown and IsUnknownDefaultRep,IsUnknown and IsUnknownDefaultRep],0,COM_FUN(5));
InstallMethod(\+,"for unknown and cyclotomic",true,[IsUnknown,IsCyc],0,COM_FUN(6));
InstallMethod(\+,"for cyclotomic and unknown",true,[IsCyc,IsUnknown],0,COM_FUN(7));
InstallMethod(\+,"for two unknowns",true,[IsUnknown,IsUnknown],0,COM_FUN(8));
InstallMethod(\-,"for unknown and cyclotomic",true,[IsUnknown,IsCyc],0,COM_FUN(9));
InstallMethod(\-,"for cyclotomic and unknown",true,[IsCyc,IsUnknown],0,COM_FUN(10));
InstallMethod(\-,"for two unknowns in default representation",true,[IsUnknown and IsUnknownDefaultRep,IsUnknown and IsUnknownDefaultRep],0,COM_FUN(11));
InstallMethod(\*,"for unknown and cyclotomic",true,[IsUnknown,IsCyc],0,COM_FUN(12));
InstallMethod(\*,"for cyclotomic and unknown",true,[IsCyc,IsUnknown],0,COM_FUN(13));
InstallMethod(\*,"for two unknowns",true,[IsUnknown,IsUnknown],0,COM_FUN(14));
InstallMethod(\/,"for unknown and cyclotomic",true,[IsUnknown,IsCyc],0,COM_FUN(15));
InstallMethod(\^,"for unknown and positive integer",true,[IsUnknown,IsPosInt],0,COM_FUN(16));
InstallMethod(String,"for an unknown in default representation",true,[IsUnknown and IsUnknownDefaultRep],0,COM_FUN(17));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/unknown.gi"

#F  file="lib/field.gi" crc=45013254
RANK_FILTER_LIST  := [ 8126465, 2, 40033072, 46, 8126465, 2, 8126465, 2, 
  8126465, 2, 40033072, 46, 30625149, 10, 40019153, 48, 30625149, 10, 
  40033072, 46, 8126465, 2, 40033072, 46, 41951068, 17, 24813784, 48, 
  53241816, 49, 24813784, 48, 40033072, 46, 40033072, 46, 30144040, 50, 
  40033072, 46, 24813784, 48, 24813784, 48, 24813784, 48, 62163887, 7, 
  30144040, 50, 5330257, 48, 24813784, 48, 24813784, 48, 30625149, 10, 
  40033072, 46, 1352225, 47, 30144040, 50, 30144040, 50, 30144040, 50, 
  40033072, 46, 40033072, 46, 40033072, 46, 40033072, 46, 8126465, 2, 
  40033072, 46, 8126465, 2, 40033072, 46, 40033072, 46, 40033072, 46, 
  40033072, 46, 30625149, 10, 24813784, 48, 30625149, 10, 24813784, 48, 
  24813784, 48, 30625149, 10, 7454316, 49, 24813784, 48, 30625149, 10, 
  30625149, 10, 24813784, 48, 30625149, 10, 7454316, 49, 24813784, 48, 
  30625149, 10, 24813784, 48, 24813784, 48, 30625149, 10, 30625149, 10, 
  24813784, 48, 30625149, 10, 7454316, 49, 24813784, 48, 30625149, 10, 
  24813784, 48, 24813784, 48, 30625149, 10, 24813784, 48, 30625149, 10, 
  7665940, 19, 24813784, 48, 24813784, 48, 30625149, 10, 7665940, 19, 
  24813784, 48, 24813784, 48, 30625149, 10, 24813784, 48, 24813784, 48, 
  30625149, 10, 24813784, 48, 24813784, 48, 30625149, 10, 7665940, 19, 
  31456576, 27, 31456576, 27, 1, 0, 31456576, 27, 1, 0, 24813784, 48, 
  64918210, 8, 64918210, 8, 24813784, 48, 64918210, 8, 40033072, 46, 
  24802624, 53, 24813784, 48, 64918210, 8, 64918210, 8, 24813784, 48, 
  30625149, 10, 24813784, 48, 30625149, 10, 63580652, 7, 27262782, 23, 
  27262782, 23, 27262782, 23, 27262782, 23, 27262782, 23, 27262782, 23, 
  24813784, 48, 27262782, 23, 1, 0, 27262782, 23, 24813784, 48 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/field.gi", 45013254 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/field.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/field.gi");
elif COM_RESULT = 3  then
Revision.field_gi:="@(#)$Id: field.gi,v 4.65.2.1 2007/07/02 13:00:30 stefan Exp $";
InstallOtherMethod(DivisionRingByGenerators,"for a collection",[IsCollection],COM_FUN(1));
InstallMethod(DivisionRingByGenerators,"for a division ring, and a collection",IsIdenticalObj,[IsDivisionRing,IsCollection],COM_FUN(2));
InstallMethod(FieldOverItselfByGenerators,"for a collection",[IsCollection],COM_FUN(3));
InstallMethod(DefaultFieldByGenerators,"for a collection",[IsCollection],DivisionRingByGenerators);
InstallGlobalFunction(Field,COM_FUN(4));
InstallGlobalFunction(DefaultField,COM_FUN(5));
InstallGlobalFunction(Subfield,COM_FUN(6));
InstallGlobalFunction(SubfieldNC,COM_FUN(7));
InstallMethod(ClosureDivisionRing,"for a division ring and a scalar",IsCollsElms,[IsDivisionRing,IsScalar],COM_FUN(8));
InstallMethod(ClosureDivisionRing,"for a division ring containing the whole family, and a scalar",IsCollsElms,[IsDivisionRing and IsWholeFamily,IsScalar],SUM_FLAGS,COM_FUN(9));
InstallMethod(ClosureDivisionRing,"for division ring and collection of elements",IsIdenticalObj,[IsDivisionRing,IsCollection],COM_FUN(10));
InstallMethod(ClosureDivisionRing,"for division ring and empty list",[IsDivisionRing,IsList and IsEmpty],COM_FUN(11));
InstallMethod(ViewObj,"for a field",[IsField],COM_FUN(12));
InstallMethod(PrintObj,"for a field with known generators",[IsField and HasGeneratorsOfField],COM_FUN(13));
InstallMethod(PrintObj,"for a field",[IsField],COM_FUN(14));
InstallMethod(IsTrivial,"for a division ring",[IsDivisionRing],ReturnFalse);
InstallMethod(PrimeField,"for a division ring",[IsDivisionRing],COM_FUN(15));
InstallMethod(PrimeField,"for a prime field",[IsField and IsPrimeField],IdFunc);
InstallMethod(IsPrimeField,"for a division ring",[IsDivisionRing],COM_FUN(16));
InstallMethod(IsNumberField,"for a field",[IsField],COM_FUN(17));
InstallMethod(IsAbelianNumberField,"for a field",[IsField],COM_FUN(18));
InstallMethod(IsCyclotomicField,"for a field",[IsField],COM_FUN(19));
InstallMethod(IsNormalBasis,"for a basis of a field",[IsBasis],COM_FUN(20));
InstallMethod(GeneratorsOfDivisionRing,"for a prime field",[IsField and IsPrimeField],COM_FUN(21));
InstallImmediateMethod(DegreeOverPrimeField,IsPrimeField,20,COM_FUN(22));
InstallMethod(NormalBase,"for a field (in characteristic zero)",[IsField],COM_FUN(23));
InstallMethod(NormalBase,"for a field (in characteristic zero), and a scalar",[IsField,IsScalar],COM_FUN(24));
InstallMethod(PrimitiveElement,"for a division ring",[IsDivisionRing],COM_FUN(25));
InstallMethod(Representative,"for a division ring with known generators",[IsDivisionRing and HasGeneratorsOfDivisionRing],RepresentativeFromGenerators(GeneratorsOfDivisionRing));
EnumeratorOfPrimeField:=COM_FUN(26);
InstallMethod(Enumerator,"for a prime field",[IsField and IsPrimeField],EnumeratorOfPrimeField);
InstallMethod(EnumeratorSorted,"for a prime field",[IsField and IsPrimeField],EnumeratorOfPrimeField);
InstallMethod(AsList,"for a prime field",[IsField and IsPrimeField],COM_FUN(27));
BindGlobal("DivisionRing_IsSubset",COM_FUN(28));
InstallMethod(IsSubset,"for two division rings",IsIdenticalObj,[IsDivisionRing,IsDivisionRing],DivisionRing_IsSubset);
InstallMethod(\=,"for two division rings",IsIdenticalObj,[IsDivisionRing,IsDivisionRing],COM_FUN(29));
InstallMethod(AsDivisionRing,"for a collection",[IsCollection],COM_FUN(30));
InstallMethod(AsDivisionRing,"for a division ring, and a collection",IsIdenticalObj,[IsDivisionRing,IsCollection],COM_FUN(31));
InstallMethod(AsDivisionRing,"for two division rings",IsIdenticalObj,[IsDivisionRing,IsDivisionRing],COM_FUN(32));
InstallMethod(AsLeftModule,"for two division rings",IsIdenticalObj,[IsDivisionRing,IsDivisionRing],AsDivisionRing);
InstallMethod(Conjugates,"for a scalar (delegate to version with default field)",[IsScalar],COM_FUN(33));
InstallMethod(Conjugates,"for a field and a scalar (delegate to version with two fields)",IsCollsElms,[IsField,IsScalar],COM_FUN(34));
InstallMethod(Conjugates,"for two fields and a scalar (call `TracePolynomial')",IsCollsXElms,[IsField,IsField,IsScalar],COM_FUN(35));
InstallMethod(Conjugates,"for two fields and a scalar (call `GaloisGroup')",IsCollsXElms,[IsFieldControlledByGaloisGroup,IsField,IsScalar],COM_FUN(36));
InstallMethod(Norm,"for a scalar (delegate to version with default field)",[IsScalar],COM_FUN(37));
InstallMethod(Norm,"for a field and a scalar (delegate to version with two fields)",IsCollsElms,[IsField,IsScalar],COM_FUN(38));
InstallMethod(Norm,"for two fields and a scalar (use `Conjugates')",IsCollsXElms,[IsFieldControlledByGaloisGroup,IsField,IsScalar],COM_FUN(39));
InstallMethod(Norm,"for two fields and a scalar (use the trace pol.)",IsCollsXElms,[IsField,IsField,IsScalar],COM_FUN(40));
InstallMethod(Trace,"for a scalar (delegate to version with default field)",[IsScalar],COM_FUN(41));
InstallMethod(Trace,"for a field and a scalar (delegate to version with two fields)",IsCollsElms,[IsField,IsScalar],COM_FUN(42));
InstallMethod(Trace,"for two fields and a scalar (use `Conjugates')",IsCollsXElms,[IsFieldControlledByGaloisGroup,IsField,IsScalar],COM_FUN(43));
InstallMethod(Trace,"for two fields and a scalar (use the trace pol.)",IsCollsXElms,[IsField,IsField,IsScalar],COM_FUN(44));
InstallMethod(MinimalPolynomial,"for field, scalar, and indet. number",IsCollsElmsX,[IsField,IsScalar,IsPosInt],COM_FUN(45));
InstallMethod(TracePolynomial,"using minimal polynomial",IsCollsXElmsX,[IsField,IsField,IsScalar,IsPosInt],COM_FUN(46));
InstallMethod(TracePolynomial,"add default indet. 1",IsCollsXElms,[IsField,IsField,IsScalar],COM_FUN(47));
InstallOtherMethod(CharacteristicPolynomial,"call `TracePolynomial'",IsCollsXElms,[IsField,IsField,IsScalar],COM_FUN(48));
InstallOtherMethod(CharacteristicPolynomial,"call `TracePolynomial'",IsCollsXElmsX,[IsField,IsField,IsScalar,IsPosInt],TracePolynomial);
InstallHandlingByNiceBasis("IsFieldElementsSpace",rec(detect:=COM_FUN(49),NiceFreeLeftModuleInfo:=COM_FUN(50),NiceVector:=COM_FUN(51),UglyVector:=COM_FUN(52)));
InstallMethod(Quotient,"for field, and two ring elements",IsCollsElmsElms,[IsField,IsRingElement,IsRingElement],COM_FUN(53));
InstallMethod(IsUnit,"for field, and ring element",IsCollsElms,[IsField,IsRingElement],COM_FUN(54));
InstallMethod(Units,"for a division ring",[IsDivisionRing],COM_FUN(55));
InstallMethod(PrimitiveRoot,"for a finite prime field",[IsField and IsFinite],COM_FUN(56));
InstallMethod(IsAssociated,"for field, and two ring elements",IsCollsElmsElms,[IsField,IsRingElement,IsRingElement],COM_FUN(57));
InstallMethod(StandardAssociate,"for field and ring element",IsCollsElms,[IsField,IsScalar],COM_FUN(58));
InstallMethod(IsIrreducibleRingElement,"for field and ring element",IsCollsElms,[IsField,IsScalar],0,COM_FUN(59));
InstallMethod(IsFieldHomomorphism,[IsGeneralMapping],COM_FUN(60));
InstallMethod(KernelOfAdditiveGeneralMapping,"for a field homomorphism",[IsFieldHomomorphism],COM_FUN(61));
InstallMethod(IsInjective,"for a field homomorphism",[IsFieldHomomorphism],COM_FUN(62));
InstallMethod(IsSurjective,"for a field homomorphism",[IsFieldHomomorphism],COM_FUN(63));
InstallMethod(\=,"for two field homomorphisms",IsIdenticalObj,[IsFieldHomomorphism,IsFieldHomomorphism],COM_FUN(64));
InstallMethod(ImagesSet,"for field homomorphism and field",CollFamSourceEqFamElms,[IsFieldHomomorphism,IsField],COM_FUN(65));
InstallMethod(PreImagesElm,"for field homomorphism and element",FamRangeEqFamElm,[IsFieldHomomorphism,IsObject],COM_FUN(66));
InstallMethod(PreImagesSet,"for field homomorphism and field",CollFamRangeEqFamElms,[IsFieldHomomorphism,IsField],COM_FUN(67));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/field.gi"

#F  file="lib/fieldfin.gi" crc=-41123006
RANK_FILTER_LIST  := [ 24802624, 53, 30132880, 55, 50900243, 54, 24802624, 
  53, 24802624, 53, 24802624, 53, 24802624, 53, 24802624, 53, 24813319, 65, 
  24813319, 65, 24802624, 53, 30625149, 10, 7665940, 19, 257, 15, 29418592, 
  248, 29418592, 248, 24802624, 53, 24802624, 53, 7728, 27, 24802624, 53, 
  32769, 4, 2394515, 13, 30625149, 10, 2394515, 13, 32769, 4, 24802624, 53, 
  24802624, 53, 30625149, 10, 24813784, 48, 14679975, 26, 14679975, 26, 
  19481731, 17, 14679975, 26, 14679975, 26, 19481731, 17, 14679975, 26, 1, 0, 
  14679975, 26, 1, 0, 14679975, 26, 24813784, 48, 14679975, 26, 1, 0, 
  14679975, 26, 14679975, 26, 14679975, 26, 14679975, 26, 17, 18, 19481731, 
  17, 14679975, 26, 14679975, 26, 19481731, 17, 14679975, 26, 14679975, 26, 
  14679975, 26, 24802624, 53 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/fieldfin.gi", -41123006 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/fieldfin.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/fieldfin.gi");
elif COM_RESULT = 3  then
Revision.fieldfin_gi:="@(#)$Id: fieldfin.gi,v 4.41.4.5 2005/11/30 02:51:40 gap Exp $";
InstallMethod(GeneratorsOfLeftModule,"for a finite field (return the vectors of the canonical basis)",[IsField and IsFinite],COM_FUN(1));
InstallMethod(Random,"for a finite prime field",[IsField and IsPrimeField and IsFinite],COM_FUN(2));
InstallMethod(Random,"for a finite field with known primitive root",[IsField and IsFinite and HasPrimitiveRoot],COM_FUN(3));
InstallMethod(Units,"for a finite field",[IsField and IsFinite],COM_FUN(4));
InstallMethod(\=,"for two finite fields in the same family",IsIdenticalObj,[IsField and IsFinite,IsField and IsFinite],COM_FUN(5));
InstallMethod(IsSubset,"for two finite fields in the same family",IsIdenticalObj,[IsField and IsFinite,IsField and IsFinite],COM_FUN(6));
InstallMethod(Subfields,"for finite field of FFEs",[IsField and IsFFECollection],COM_FUN(7));
InstallMethod(PrimeField,"for finite field of FFEs",[IsField and IsFFECollection],COM_FUN(8));
InstallMethod(MinimalPolynomial,"finite field, finite field element, and indet. number",IsCollsElmsX,[IsField and IsFinite,IsScalar,IsPosInt],COM_FUN(9));
InstallTrueMethod(IsHandledByNiceMonomorphism,IsGroup and IsFFECollection);
InstallTrueMethod(IsCyclic,IsGroup and IsFFECollection);
InstallMethod(\in,"for groups of FFE",IsElmsColls,[IsFFE,IsGroup and IsFFECollection],COM_FUN(10));
InstallMethod(Pcgs,"for groups of FFE",[IsGroup and IsFFECollection],COM_FUN(11));
DeclareRepresentation("IsBasisFiniteFieldRep",IsAttributeStoringRep,["inverseBase","d","q"]);
InstallTrueMethod(IsFinite,IsBasis and IsBasisFiniteFieldRep);
InstallMethod(Basis,"for a finite field (delegate to `CanonicalBasis')",[IsField and IsFinite],CANONICAL_BASIS_FLAGS,CanonicalBasis);
InstallMethod(Basis,"for a finite field, and a hom. list",IsIdenticalObj,[IsField and IsFinite,IsFFECollection and IsList],COM_FUN(12));
InstallMethod(BasisNC,"for a finite field, and a hom. list",IsIdenticalObj,[IsField and IsFinite,IsHomogeneousList],10,COM_FUN(13));
InstallMethod(Coefficients,"for a basis of a finite field, and a scalar",IsCollsElms,[IsBasis and IsBasisFiniteFieldRep,IsScalar],COM_FUN(14));
InstallMethod(LinearCombination,"for a basis of a finite field, and a hom. list",IsIdenticalObj,[IsBasis and IsBasisFiniteFieldRep,IsHomogeneousList],COM_FUN(15));
InstallMethod(CanonicalBasis,"for a finite field",[IsField and IsFinite],COM_FUN(16));
InstallMethod(NormalBase,"for a finite field and scalar",[IsField and IsFinite,IsScalar],COM_FUN(17));
DeclareRepresentation("IsFrobeniusAutomorphism",IsFieldHomomorphism and IsMapping and IsAttributeStoringRep,["power"]);
BindGlobal("FrobeniusAutomorphismI",COM_FUN(18));
InstallMethod(FrobeniusAutomorphism,"for a field",[IsField],COM_FUN(19));
InstallMethod(\=,"for two Frobenius automorphisms",IsIdenticalObj,[IsFrobeniusAutomorphism,IsFrobeniusAutomorphism],COM_FUN(20));
InstallMethod(\=,"for identity mapping and Frobenius automorphism",IsIdenticalObj,[IsMapping and IsOne,IsFrobeniusAutomorphism],COM_FUN(21));
InstallMethod(\=,"for Frobenius automorphism and identity mapping",IsIdenticalObj,[IsFrobeniusAutomorphism,IsMapping and IsOne],COM_FUN(22));
InstallMethod(ImageElm,"for Frobenius automorphism and source element",FamSourceEqFamElm,[IsFrobeniusAutomorphism,IsObject],COM_FUN(23));
InstallMethod(ImagesElm,"for Frobenius automorphism and source element",FamSourceEqFamElm,[IsFrobeniusAutomorphism,IsObject],COM_FUN(24));
InstallMethod(ImagesSet,"for Frobenius automorphism and field contained in the source",CollFamSourceEqFamElms,[IsFrobeniusAutomorphism,IsField],COM_FUN(25));
InstallMethod(ImagesRepresentative,"for Frobenius automorphism and source element",FamSourceEqFamElm,[IsFrobeniusAutomorphism,IsObject],COM_FUN(26));
InstallMethod(CompositionMapping2,"for two Frobenius automorphisms",IsIdenticalObj,[IsFrobeniusAutomorphism,IsFrobeniusAutomorphism],COM_FUN(27));
InstallMethod(InverseGeneralMapping,"for a Frobenius automorphism",[IsFrobeniusAutomorphism],COM_FUN(28));
InstallMethod(\^,"for a Frobenius automorphism, and an integer",[IsFrobeniusAutomorphism,IsInt],COM_FUN(29));
InstallMethod(\<,"for an identity mapping, and a Frobenius automorphism",IsIdenticalObj,[IsMapping and IsOne,IsFrobeniusAutomorphism],COM_FUN(30));
InstallMethod(\<,"for a Frobenius automorphism, and an identity mapping",IsIdenticalObj,[IsFrobeniusAutomorphism,IsMapping and IsOne],COM_FUN(31));
InstallMethod(\<,"for two Frobenius automorphisms",IsIdenticalObj,[IsFrobeniusAutomorphism,IsFrobeniusAutomorphism],COM_FUN(32));
InstallMethod(PrintObj,"for a Frobenius automorphism",[IsFrobeniusAutomorphism],COM_FUN(33));
InstallMethod(GaloisGroup,"for a finite field",[IsField and IsFinite],COM_FUN(34));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/fieldfin.gi"

#F  file="lib/zmodnz.gi" crc=24297098
RANK_FILTER_LIST  := [ 67108775, 4, 17, 18, 42108362, 5, 17, 18, 17, 18, 
  7665940, 19, 67108775, 4, 17, 18, 20970486, 14, 58719657, 13, 58719913, 18, 
  58719657, 13, 58719913, 18, 58719657, 13, 58719657, 13, 58719913, 18, 319, 
  17, 319, 17, 58719913, 18, 20970486, 14, 20970486, 14, 62913856, 19, 
  62913856, 19, 12581983, 19, 12581983, 19, 12581983, 19, 319, 17, 319, 17, 
  12581983, 19, 58719657, 13, 58719657, 13, 58719657, 13, 17, 18, 17, 18, 
  58719657, 13, 58719657, 13, 33, 17, 33, 17, 58719657, 13, 12581983, 19, 
  319, 17, 319, 17, 12581983, 19, 58719657, 13, 58719657, 13, 58719657, 13, 
  17, 18, 17, 18, 58719657, 13, 58719657, 13, 33, 17, 33, 17, 58719657, 13, 
  12581983, 19, 319, 17, 319, 17, 12581983, 19, 58719657, 13, 58719657, 13, 
  58719657, 13, 17, 18, 17, 18, 58719657, 13, 58719657, 13, 33, 17, 33, 17, 
  58719657, 13, 12581983, 19, 319, 17, 319, 17, 12581983, 19, 58719657, 13, 
  58719657, 13, 58719657, 13, 17, 18, 17, 18, 58719657, 13, 58719657, 13, 33, 
  17, 33, 17, 58719657, 13, 12581983, 19, 319, 17, 319, 17, 12581983, 19, 
  58719657, 13, 17, 18, 29359709, 11, 58719657, 13, 29359709, 11, 58719657, 
  13, 58719913, 18, 58719913, 18, 58719913, 18, 58719657, 13, 58719913, 18, 
  58719657, 13, 7665940, 19, 15948189, 37, 15948189, 37, 15948190, 39, 
  67094751, 18, 67094751, 18, 67094751, 18, 67094751, 18, 67094751, 18, 
  67094751, 18, 50983054, 33, 58719417, 12, 29418847, 33, 67094751, 18, 
  30144040, 50, 58719913, 18, 54525188, 40, 7665940, 19, 58719417, 12, 
  29359965, 16, 257, 15, 67108670, 16, 5232377, 34 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/zmodnz.gi", 24297098 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/zmodnz.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/zmodnz.gi");
elif COM_RESULT = 3  then
Revision.zmodnz_gi:="@(#)$Id: zmodnz.gi,v 4.53.2.1 2006/02/22 13:52:08 sal Exp $";
DeclareSynonym("ZNZ_PURE_TYPE",POS_FIRST_FREE_TYPE);
DeclareRepresentation("IsModulusRep",IsPositionalObjectRep,[1]);
InstallMethod(ZmodnZObj,"for family of elements in Z/nZ (nonprime), and integer",[IsZmodnZObjNonprimeFamily,IsInt],COM_FUN(1));
InstallOtherMethod(ZmodnZObj,"for family of FFE elements, and integer",[IsFFEFamily,IsInt],COM_FUN(2));
InstallMethod(ZmodnZObj,"for a positive integer, and an integer",[IsInt,IsPosInt],COM_FUN(3));
InstallMethod(ObjByExtRep,"for family of elements in Z/nZ (nonprime), and integer",[IsZmodnZObjNonprimeFamily,IsInt],COM_FUN(4));
InstallMethod(ExtRepOfObj,"for element in Z/nZ (ModulusRep, nonprime)",[IsZmodnZObjNonprime and IsModulusRep],COM_FUN(5));
InstallMethod(PrintObj,"for element in Z/nZ (ModulusRep)",IsZmodnZObjNonprimeFamily,[IsZmodnZObj and IsModulusRep],COM_FUN(6));
InstallMethod(PrintObj,"for element in Z/pZ (ModulusRep)",[IsZmodpZObj and IsModulusRep],COM_FUN(7));
InstallMethod(String,"for element in Z/nZ (ModulusRep)",IsZmodnZObjNonprimeFamily,[IsZmodnZObj and IsModulusRep],COM_FUN(8));
InstallMethod(String,"for element in Z/pZ (ModulusRep)",[IsZmodpZObj and IsModulusRep],COM_FUN(9));
InstallMethod(\=,"for two elements in Z/nZ (ModulusRep)",IsIdenticalObj,[IsZmodnZObj and IsModulusRep,IsZmodnZObj and IsModulusRep],COM_FUN(10));
InstallMethod(\=,"for element in Z/pZ (ModulusRep) and internal FFE",IsIdenticalObj,[IsZmodpZObj and IsModulusRep,IsFFE and IsInternalRep],COM_FUN(11));
InstallMethod(\=,"for internal FFE and element in Z/pZ (ModulusRep)",IsIdenticalObj,[IsFFE and IsInternalRep,IsZmodpZObj and IsModulusRep],COM_FUN(12));
InstallMethod(\<,"for two elements in Z/nZ (ModulusRep, nonprime)",IsIdenticalObj,[IsZmodnZObjNonprime and IsModulusRep,IsZmodnZObjNonprime and IsModulusRep],COM_FUN(13));
InstallMethod(\<,"for two elements in Z/pZ (ModulusRep, large)",IsIdenticalObj,[IsZmodpZObjLarge and IsModulusRep,IsZmodpZObjLarge and IsModulusRep],COM_FUN(14));
InstallMethod(\<,"for two elements in Z/pZ (ModulusRep, small)",IsIdenticalObj,[IsZmodpZObjSmall and IsModulusRep,IsZmodpZObjSmall and IsModulusRep],COM_FUN(15));
InstallMethod(\<,"for element in Z/pZ (ModulusRep) and internal FFE",IsIdenticalObj,[IsZmodpZObjSmall and IsModulusRep,IsFFE and IsInternalRep],COM_FUN(16));
InstallMethod(\<,"for internal FFE and element in Z/pZ (ModulusRep)",IsIdenticalObj,[IsFFE and IsInternalRep,IsZmodpZObjSmall and IsModulusRep],COM_FUN(17));
InstallMethod(\+,"for two elements in Z/nZ (ModulusRep)",IsIdenticalObj,[IsZmodnZObj and IsModulusRep,IsZmodnZObj and IsModulusRep],COM_FUN(18));
InstallMethod(\+,"for element in Z/nZ (ModulusRep) and integer",[IsZmodnZObj and IsModulusRep,IsInt],COM_FUN(19));
InstallMethod(\+,"for integer and element in Z/nZ (ModulusRep)",[IsInt,IsZmodnZObj and IsModulusRep],COM_FUN(20));
InstallMethod(\+,"for element in Z/nZ (ModulusRep) and rational",[IsZmodnZObj and IsModulusRep,IsRat],COM_FUN(21));
InstallMethod(\+,"for rational and element in Z/nZ (ModulusRep)",[IsRat,IsZmodnZObj and IsModulusRep],COM_FUN(22));
InstallMethod(\+,"for element in Z/pZ (ModulusRep) and internal FFE",IsIdenticalObj,[IsZmodpZObjSmall and IsModulusRep,IsFFE and IsInternalRep],COM_FUN(23));
InstallMethod(\+,"for internal FFE and element in Z/pZ (ModulusRep)",IsIdenticalObj,[IsFFE and IsInternalRep,IsZmodpZObjSmall and IsModulusRep],COM_FUN(24));
InstallMethod(\-,"for two elements in Z/nZ (ModulusRep)",IsIdenticalObj,[IsZmodnZObj and IsModulusRep,IsZmodnZObj and IsModulusRep],COM_FUN(25));
InstallMethod(\-,"for element in Z/nZ (ModulusRep) and integer",[IsZmodnZObj and IsModulusRep,IsInt],COM_FUN(26));
InstallMethod(\-,"for integer and element in Z/nZ (ModulusRep)",[IsInt,IsZmodnZObj and IsModulusRep],COM_FUN(27));
InstallMethod(\-,"for element in Z/nZ (ModulusRep) and rational",[IsZmodnZObj and IsModulusRep,IsRat],COM_FUN(28));
InstallMethod(\-,"for rational and element in Z/nZ (ModulusRep)",[IsRat,IsZmodnZObj and IsModulusRep],COM_FUN(29));
InstallMethod(\-,"for element in Z/pZ (ModulusRep) and internal FFE",IsIdenticalObj,[IsZmodpZObjSmall and IsModulusRep,IsFFE and IsInternalRep],COM_FUN(30));
InstallMethod(\-,"for internal FFE and element in Z/pZ (ModulusRep)",IsIdenticalObj,[IsFFE and IsInternalRep,IsZmodpZObjSmall and IsModulusRep],COM_FUN(31));
InstallMethod(\*,"for two elements in Z/nZ (ModulusRep)",IsIdenticalObj,[IsZmodnZObj and IsModulusRep,IsZmodnZObj and IsModulusRep],COM_FUN(32));
InstallMethod(\*,"for element in Z/nZ (ModulusRep) and integer",[IsZmodnZObj and IsModulusRep,IsInt],COM_FUN(33));
InstallMethod(\*,"for integer and element in Z/nZ (ModulusRep)",[IsInt,IsZmodnZObj and IsModulusRep],COM_FUN(34));
InstallMethod(\*,"for element in Z/nZ (ModulusRep) and rational",[IsZmodnZObj and IsModulusRep,IsRat],COM_FUN(35));
InstallMethod(\*,"for rational and element in Z/nZ (ModulusRep)",[IsRat,IsZmodnZObj and IsModulusRep],COM_FUN(36));
InstallMethod(\*,"for element in Z/pZ (ModulusRep) and internal FFE",IsIdenticalObj,[IsZmodpZObjSmall and IsModulusRep,IsFFE and IsInternalRep],COM_FUN(37));
InstallMethod(\*,"for internal FFE and element in Z/pZ (ModulusRep)",IsIdenticalObj,[IsFFE and IsInternalRep,IsZmodpZObjSmall and IsModulusRep],COM_FUN(38));
InstallMethod(\/,"for two elements in Z/nZ (ModulusRep)",IsIdenticalObj,[IsZmodnZObj and IsModulusRep,IsZmodnZObj and IsModulusRep],COM_FUN(39));
InstallMethod(\/,"for element in Z/nZ (ModulusRep) and integer",[IsZmodnZObj and IsModulusRep,IsInt],COM_FUN(40));
InstallMethod(\/,"for integer and element in Z/nZ (ModulusRep)",[IsInt,IsZmodnZObj and IsModulusRep],COM_FUN(41));
InstallMethod(\/,"for element in Z/nZ (ModulusRep) and rational",[IsZmodnZObj and IsModulusRep,IsRat],COM_FUN(42));
InstallMethod(\/,"for rational and element in Z/nZ (ModulusRep)",[IsRat,IsZmodnZObj and IsModulusRep],COM_FUN(43));
InstallMethod(\/,"for element in Z/pZ (ModulusRep) and internal FFE",IsIdenticalObj,[IsZmodpZObjSmall and IsModulusRep,IsFFE and IsInternalRep],COM_FUN(44));
InstallMethod(\/,"for internal FFE and element in Z/pZ (ModulusRep)",IsIdenticalObj,[IsFFE and IsInternalRep,IsZmodpZObjSmall and IsModulusRep],COM_FUN(45));
InstallMethod(\^,"for element in Z/nZ (ModulusRep), and integer",[IsZmodnZObj and IsModulusRep,IsInt],COM_FUN(46));
InstallMethod(ZeroOp,"for element in Z/nZ (ModulusRep)",[IsZmodnZObj],COM_FUN(47));
InstallMethod(AdditiveInverseOp,"for element in Z/nZ (ModulusRep)",[IsZmodnZObj and IsModulusRep],COM_FUN(48));
InstallMethod(OneOp,"for element in Z/nZ (ModulusRep)",[IsZmodnZObj],COM_FUN(49));
InstallMethod(InverseOp,"for element in Z/nZ (ModulusRep)",[IsZmodnZObj and IsModulusRep],COM_FUN(50));
InstallMethod(DegreeFFE,"for element in Z/pZ (ModulusRep)",[IsZmodpZObj and IsModulusRep],COM_FUN(51));
InstallMethod(LogFFE,"for two elements in Z/pZ (ModulusRep)",IsIdenticalObj,[IsZmodpZObj and IsModulusRep,IsZmodpZObj and IsModulusRep],COM_FUN(52));
InstallMethod(Int,"for element in Z/nZ (ModulusRep)",[IsZmodnZObj and IsModulusRep],COM_FUN(53));
InstallMethod(IntFFE,[IsZmodpZObj and IsModulusRep],COM_FUN(54));
InstallOtherMethod(IntFFESymm,"Z/nZ (ModulusRep)",[IsZmodnZObj and IsModulusRep],COM_FUN(55));
InstallMethod(ZOp,[IsPosInt],COM_FUN(56));
InstallMethod(InverseOp,"for an ordinary matrix over a ring Z/nZ",[IsMatrix and IsOrdinaryMatrix and IsZmodnZObjNonprimeCollColl],COM_FUN(57));
InstallMethod(InverseSM,"for an ordinary matrix over a ring Z/nZ",[IsMatrix and IsOrdinaryMatrix and IsZmodnZObjNonprimeCollColl],COM_FUN(58));
InstallMethod(TriangulizeMat,"for a mutable ordinary matrix over a ring Z/nZ",[IsMatrix and IsMutable and IsOrdinaryMatrix and IsZmodnZObjNonprimeCollColl],COM_FUN(59));
InstallMethod(ViewObj,"for full ring Z/nZ",[IsZmodnZObjNonprimeCollection and IsWholeFamily],SUM_FLAGS,COM_FUN(60));
InstallMethod(PrintObj,"for full ring Z/nZ",[IsZmodnZObjNonprimeCollection and IsWholeFamily],SUM_FLAGS,COM_FUN(61));
InstallMethod(AsList,"for full ring Z/nZ",[IsZmodnZObjNonprimeCollection and IsWholeFamily],COM_FUN(62));
InstallMethod(AsSSortedList,"for full ring Z/nZ",[IsZmodnZObjNonprimeCollection and IsWholeFamily],COM_FUN(63));
InstallMethod(Random,"for full ring Z/nZ",[IsZmodnZObjNonprimeCollection and IsWholeFamily],COM_FUN(64));
InstallMethod(Size,"for full ring Z/nZ",[IsZmodnZObjNonprimeCollection and IsWholeFamily],COM_FUN(65));
InstallMethod(Units,"for full ring Z/nZ",[IsZmodnZObjNonprimeCollection and IsWholeFamily and IsRing],COM_FUN(66));
InstallMethod(\in,"for subgroups of Z/p^aZ, p<>2",IsElmsColls,[IsZmodnZObjNonprime,IsGroup and IsZmodnZObjNonprimeCollection],COM_FUN(67));
BindGlobal("ElementNumber_ZmodnZ",COM_FUN(68));
BindGlobal("NumberElement_ZmodnZ",COM_FUN(69));
InstallGlobalFunction(EnumeratorOfZmodnZ,COM_FUN(70));
InstallMethod(Enumerator,"for full ring Z/nZ",[IsZmodnZObjNonprimeCollection and IsWholeFamily],SUM_FLAGS,EnumeratorOfZmodnZ);
InstallMethod(SquareRoots,"for prime field and object in Z/pZ",IsCollsElms,[IsField and IsPrimeField,IsZmodpZObj and IsModulusRep],COM_FUN(71));
InstallGlobalFunction(ZmodpZ,COM_FUN(72));
InstallGlobalFunction(ZmodpZNC,COM_FUN(73));
InstallGlobalFunction(ZmodnZ,COM_FUN(74));
InstallMethod(\mod,"for `Integers', and positive integers",[IsIntegers,IsPosInt],COM_FUN(75));
InstallMethod(ModulusOfZmodnZObj,"for element in Z/nZ (nonprime)",[IsZmodnZObjNonprime],COM_FUN(76));
InstallMethod(ModulusOfZmodnZObj,"for element in Z/pZ (prime)",[IsZmodpZObj],Characteristic);
InstallOtherMethod(ModulusOfZmodnZObj,"for FFE",[IsFFE],COM_FUN(77));
InstallMethod(DefaultRingByGenerators,"for a collection over a ring Z/nZ",[IsZmodnZObjNonprimeCollection],COM_FUN(78));
InstallMethod(DefaultFieldOfMatrixGroup,"for a matrix group over a ring Z/nZ",[IsMatrixGroup and IsZmodnZObjNonprimeCollCollColl],COM_FUN(79));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/zmodnz.gi"

#F  file="lib/ffe.gi" crc=-123461150
RANK_FILTER_LIST  := [ 257, 15, 33, 17, 33, 17, 257, 15, 257, 15, 33, 17, 33, 
  17, 257, 15, 65077475, 29, 31628240, 40, 257, 15, 257, 15, 65077475, 29, 
  42108362, 5, 42108362, 5, 7665940, 19, 7665940, 19, 7665940, 19, 24813319, 
  268, 49151311, 17, 24813319, 268, 24813319, 268, 24813319, 268, 24813319, 
  268, 257, 15, 24813319, 268, 24813319, 268, 24813319, 268, 24802159, 278, 
  24802159, 278, 257, 15, 24802159, 278, 24802159, 278, 257, 15, 24802159, 
  278, 24802159, 278, 257, 15, 319, 17, 257, 15, 24813784, 48, 257, 15, 
  24813784, 48, 257, 15, 7665940, 19, 257, 15, 257, 15, 65077475, 29, 319, 
  17, 319, 17, 67108415, 20, 24813319, 268, 67108415, 20, 7728, 27, 24802624, 
  53, 7728, 27, 67108415, 20, 67108415, 20, 7728, 27, 24813319, 268, 
  67108415, 20, 24813319, 268, 67108415, 20, 67108415, 20 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/ffe.gi", -123461150 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/ffe.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/ffe.gi");
elif COM_RESULT = 3  then
Revision.ffe_gi:="@(#)$Id: ffe.gi,v 4.67.2.4 2007/03/19 10:33:22 sal Exp $";
InstallFlushableValue(GALOIS_FIELDS,[]);
InstallMethod(\+,"for a FFE and a rational",[IsFFE,IsRat],COM_FUN(1));
InstallMethod(\+,"for a rational and a FFE",[IsRat,IsFFE],COM_FUN(2));
InstallMethod(\*,"for a FFE and a rational",[IsFFE,IsRat],COM_FUN(3));
InstallMethod(\*,"for a rational and a FFE",[IsRat,IsFFE],COM_FUN(4));
InstallOtherMethod(DegreeFFE,"for a row vector of FFEs",true,[IsRowVector and IsFFECollection],0,COM_FUN(5));
InstallOtherMethod(DegreeFFE,"for a matrix of FFEs",true,[IsMatrix and IsFFECollColl],0,COM_FUN(6));
InstallMethod(LogFFE,"for two FFEs (in a prime field)",IsIdenticalObj,[IsFFE,IsFFE],COM_FUN(7));
InstallMethod(IntVecFFE,"for a row vector of FFEs",true,[IsRowVector and IsFFECollection],0,COM_FUN(8));
InstallGlobalFunction(FFEFamily,COM_FUN(9));
InstallOtherMethod(Zero,"for a family of FFEs",true,[IsFFEFamily],0,COM_FUN(10));
InstallOtherMethod(One,"for a family of FFEs",true,[IsFFEFamily],0,COM_FUN(11));
InstallMethod(LargeGaloisField,[IsPosInt],COM_FUN(12));
InstallMethod(LargeGaloisField,[IsPosInt,IsPosInt],COM_FUN(13));
GFCACHE:=[0,0];
InstallGlobalFunction(GaloisField,COM_FUN(14));
InstallOtherMethod(FieldExtension,"for a field of FFEs, and a univ. Laurent polynomial",true,[IsField and IsFFECollection,IsLaurentPolynomial],0,COM_FUN(15));
InstallMethod(DefiningPolynomial,"for a field of FFEs (return the Conway polynomial)",true,[IsField and IsFFECollection],0,COM_FUN(16));
InstallMethod(RootOfDefiningPolynomial,"for a small field of FFEs",true,[IsField and IsFFECollection],0,COM_FUN(17));
InstallMethod(ViewObj,"for a field of FFEs",true,[IsField and IsFFECollection],10,COM_FUN(18));
InstallMethod(PrintObj,"for a field of FFEs",true,[IsField and IsFFECollection],10,COM_FUN(19));
InstallMethod(\in,"for a FFE, and a field of FFEs",IsElmsColls,[IsFFE,IsField and IsFFECollection],0,COM_FUN(20));
InstallMethod(Intersection2,"for two fields of FFEs",IsIdenticalObj,[IsField and IsFFECollection,IsField and IsFFECollection],0,COM_FUN(21));
InstallMethod(Conjugates,"for two fields of FFEs, and a FFE",IsCollsXElms,[IsField and IsFinite and IsFFECollection,IsField and IsFinite and IsFFECollection,IsFFE],0,COM_FUN(22));
InstallMethod(Norm,"for two fields of FFEs, and a FFE",IsCollsXElms,[IsField and IsFinite and IsFFECollection,IsField and IsFinite and IsFFECollection,IsFFE],0,COM_FUN(23));
InstallMethod(Trace,"for two fields of FFEs, and a FFE",IsCollsXElms,[IsField and IsFinite and IsFFECollection,IsField and IsFinite and IsFFECollection,IsFFE],0,COM_FUN(24));
InstallMethod(Order,"for an internal FFE",true,[IsFFE and IsInternalRep],0,COM_FUN(25));
InstallMethod(Order,"for a general FFE",[IsFFE],COM_FUN(26));
InstallMethod(SquareRoots,"for a field of FFEs, and a FFE",IsCollsElms,[IsField,IsFFE],0,COM_FUN(27));
InstallMethod(NthRoot,"for a field of FFEs, and a FFE",IsCollsElmsX,[IsField,IsFFE,IsPosInt],0,COM_FUN(28));
InstallMethod(Int,"for an FFE",true,[IsFFE],0,IntFFE);
InstallMethod(IntFFESymm,"FFE",true,[IsFFE],0,COM_FUN(29));
InstallOtherMethod(IntFFESymm,"vector",true,[IsRowVector and IsFFECollection],0,COM_FUN(30));
InstallMethod(String,"for an internal FFE",true,[IsFFE and IsInternalRep],0,COM_FUN(31));
InstallMethod(LaTeXObj,"for an internal FFE",true,[IsFFE and IsInternalRep],0,COM_FUN(32));
InstallMethod(FieldOverItselfByGenerators,"for a collection of FFEs",true,[IsFFECollection],0,COM_FUN(33));
InstallMethod(FieldByGenerators,"for two coll. of FFEs, the first a field",IsIdenticalObj,[IsFFECollection and IsField,IsFFECollection],0,COM_FUN(34));
InstallMethod(DefaultFieldByGenerators,"for a collection of FFEs that is a list",true,[IsFFECollection and IsList],0,COM_FUN(35));
InstallOtherMethod(DefaultFieldByGenerators,"for a finite field, and a collection of FFEs that is a list",IsIdenticalObj,[IsField and IsFinite,IsFFECollection and IsList],0,COM_FUN(36));
RingFromFFE:=COM_FUN(37);
InstallMethod(RingByGenerators,"for a collection of FFE",true,[IsFFECollection],0,RingFromFFE);
InstallMethod(RingWithOneByGenerators,"for a collection of FFE",true,[IsFFECollection],0,RingFromFFE);
InstallMethod(DefaultRingByGenerators,"for a collection of FFE",true,[IsFFECollection and IsList],0,RingFromFFE);
FLMLORFromFFE:=COM_FUN(38);
InstallMethod(FLMLORByGenerators,"for a field, and a collection of FFE",IsIdenticalObj,[IsField and IsFFECollection,IsFFECollection],0,FLMLORFromFFE);
InstallMethod(FLMLORWithOneByGenerators,"for a field, and a collection of FFE",IsIdenticalObj,[IsField and IsFFECollection,IsFFECollection],0,FLMLORFromFFE);
InstallMethod(IsGeneratorsOfMagmaWithInverses,"for a collection of FFEs",true,[IsFFECollection],0,COM_FUN(39));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/ffe.gi"

#F  file="lib/ffeconway.gi" crc=-5631027
RANK_FILTER_LIST  := [ 7665940, 19, 7665940, 19, 7665940, 19, 58720153, 17, 
  58720153, 17, 58720153, 17, 58720153, 17, 58720153, 17, 58720153, 17, 
  58720153, 17, 58720153, 17, 58720153, 17, 58720153, 17, 257, 15, 257, 15, 
  58720153, 17, 58720153, 17, 58720153, 17, 58720153, 17, 257, 15, 257, 15, 
  58720153, 17, 319, 17, 319, 17, 257, 15, 257, 15, 58720153, 17, 58720153, 
  17, 58720153, 17, 257, 15, 257, 15, 58720153, 17, 319, 17, 319, 17, 257, 
  15, 257, 15, 58720153, 17, 58720153, 17, 257, 15, 58720153, 17, 58720153, 
  17, 257, 15, 319, 17, 319, 17, 257, 15, 257, 15, 257, 15, 257, 15, 
  58720153, 17, 58720153, 17, 319, 17, 319, 17, 58720153, 17, 58720153, 17, 
  58720153, 17, 58720153, 17, 58720153, 17, 58720153, 17, 5448293, 18, 
  5448293, 18, 58719897, 2, 319, 17, 319, 17, 58719897, 2, 58719897, 2, 
  29360205, 17, 29360205, 17, 58719897, 2, 58720153, 17, 58720153, 17, 
  58720153, 17, 319, 17, 58720153, 17, 257, 15, 7665940, 19, 7665940, 19, 
  24802159, 278, 44779389, 15, 58720153, 17, 24802159, 278, 24802159, 278, 
  24802159, 278, 24802159, 278, 5330257, 48, 58720153, 17, 7665940, 19, 
  31628240, 40 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/ffeconway.gi", -5631027 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/ffeconway.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/ffeconway.gi");
elif COM_RESULT = 3  then
Revision.ffeconway_gi:="@(#)$Id: ffeconway.gi,v 4.10.2.6 2007/03/20 15:06:06 sal Exp $";
BindGlobal("IsCoeffsModConwayPolRep",NewRepresentation("IsCoeffsModConwayPolRep",IsPositionalObjectRep,3));
BindGlobal("FFECONWAY",rec());
FFECONWAY.SetUpConwayStuff:=COM_FUN(1);
FFECONWAY.ZNC:=COM_FUN(2);
InstallOtherMethod(ZOp,[IsPosInt,IsPosInt],COM_FUN(3));
InstallMethod(ZOp,[IsPosInt],COM_FUN(4));
InstallMethod(String,"For large finite field elements",[IsFFE and IsCoeffsModConwayPolRep],COM_FUN(5));
InstallMethod(PrintObj,"for large finite field elements (use String)",[IsFFE and IsCoeffsModConwayPolRep],COM_FUN(6));
InstallMethod(DisplayString,"For large finite field elements",[IsFFE and IsCoeffsModConwayPolRep],COM_FUN(7));
InstallMethod(Display,"For large finite field elements",[IsFFE and IsCoeffsModConwayPolRep],COM_FUN(8));
InstallMethod(ViewString,"For large finite field elements",[IsFFE and IsCoeffsModConwayPolRep],COM_FUN(9));
InstallMethod(ViewObj,"For large finite field elements",[IsFFE and IsCoeffsModConwayPolRep],COM_FUN(10));
FFECONWAY.GetConwayPolCoeffs:=COM_FUN(11);
FFECONWAY.FiniteFieldEmbeddingRecord:=COM_FUN(12);
FFECONWAY.WriteOverLargerField:=COM_FUN(13);
FFECONWAY.TryToWriteInSmallerField:=COM_FUN(14);
FFECONWAY.WriteOverSmallestField:=COM_FUN(15);
InstallMethod(DegreeFFE,[IsCoeffsModConwayPolRep and IsFFE],COM_FUN(16));
InstallMethod(\=,IsIdenticalObj,[IsCoeffsModConwayPolRep and IsFFE,IsCoeffsModConwayPolRep and IsFFE],COM_FUN(17));
InstallMethod(\=,IsIdenticalObj,[IsCoeffsModConwayPolRep and IsFFE,IsFFE],COM_FUN(18));
InstallMethod(\=,IsIdenticalObj,[IsFFE,IsCoeffsModConwayPolRep and IsFFE],COM_FUN(19));
FFECONWAY.CoeffsOverCommonField:=COM_FUN(20);
FFECONWAY.SumConwayOtherFFEs:=COM_FUN(21);
InstallMethod(\+,IsIdenticalObj,[IsCoeffsModConwayPolRep and IsFFE,IsCoeffsModConwayPolRep and IsFFE],COM_FUN(22));
InstallMethod(\+,IsIdenticalObj,[IsCoeffsModConwayPolRep and IsFFE,IsFFE],FFECONWAY.SumConwayOtherFFEs);
InstallMethod(\+,IsIdenticalObj,[IsFFE,IsCoeffsModConwayPolRep and IsFFE],FFECONWAY.SumConwayOtherFFEs);
InstallMethod(SUM_FFE_LARGE,IsIdenticalObj,[IsFFE and IsInternalRep,IsFFE and IsInternalRep],FFECONWAY.SumConwayOtherFFEs);
FFECONWAY.CATCH_UNEQUAL_CHARACTERISTIC:=COM_FUN(23);
InstallMethod(\+,[IsFFE,IsFFE],FFECONWAY.CATCH_UNEQUAL_CHARACTERISTIC);
FFECONWAY.DiffConwayOtherFFEs:=COM_FUN(24);
InstallMethod(\-,IsIdenticalObj,[IsCoeffsModConwayPolRep and IsFFE,IsCoeffsModConwayPolRep and IsFFE],COM_FUN(25));
InstallMethod(\-,IsIdenticalObj,[IsCoeffsModConwayPolRep and IsFFE,IsFFE],FFECONWAY.DiffConwayOtherFFEs);
InstallMethod(\-,IsIdenticalObj,[IsFFE,IsCoeffsModConwayPolRep and IsFFE],FFECONWAY.DiffConwayOtherFFEs);
InstallMethod(DIFF_FFE_LARGE,IsIdenticalObj,[IsFFE and IsInternalRep,IsFFE and IsInternalRep],FFECONWAY.DiffConwayOtherFFEs);
InstallMethod(\-,[IsFFE,IsFFE],FFECONWAY.CATCH_UNEQUAL_CHARACTERISTIC);
FFECONWAY.ProdConwayOtherFFEs:=COM_FUN(26);
InstallMethod(\*,IsIdenticalObj,[IsCoeffsModConwayPolRep and IsFFE,IsCoeffsModConwayPolRep and IsFFE],COM_FUN(27));
InstallMethod(\*,IsIdenticalObj,[IsFFE,IsCoeffsModConwayPolRep and IsFFE],FFECONWAY.ProdConwayOtherFFEs);
InstallMethod(\*,IsIdenticalObj,[IsCoeffsModConwayPolRep and IsFFE,IsFFE],FFECONWAY.ProdConwayOtherFFEs);
InstallMethod(PROD_FFE_LARGE,IsIdenticalObj,[IsFFE and IsInternalRep,IsFFE and IsInternalRep],FFECONWAY.ProdConwayOtherFFEs);
InstallMethod(\*,[IsFFE,IsFFE],FFECONWAY.CATCH_UNEQUAL_CHARACTERISTIC);
InstallMethod(QUO,[IsFFE,IsFFE],FFECONWAY.CATCH_UNEQUAL_CHARACTERISTIC);
InstallMethod(AdditiveInverseOp,[IsCoeffsModConwayPolRep and IsFFE],COM_FUN(28));
InstallMethod(InverseOp,[IsCoeffsModConwayPolRep and IsFFE],COM_FUN(29));
InstallMethod(QUO_FFE_LARGE,IsIdenticalObj,[IsFFE and IsInternalRep,IsFFE and IsInternalRep],COM_FUN(30));
InstallMethod(IsZero,[IsCoeffsModConwayPolRep and IsFFE],COM_FUN(31));
InstallMethod(IsOne,[IsCoeffsModConwayPolRep and IsFFE],COM_FUN(32));
FFECONWAY.Zero:=COM_FUN(33);
InstallMethod(ZeroOp,[IsCoeffsModConwayPolRep and IsFFE],FFECONWAY.Zero);
InstallMethod(ZeroAttr,[IsCoeffsModConwayPolRep and IsFFE],FFECONWAY.Zero);
FFECONWAY.One:=COM_FUN(34);
InstallMethod(OneOp,[IsCoeffsModConwayPolRep and IsFFE],FFECONWAY.One);
InstallMethod(OneAttr,[IsCoeffsModConwayPolRep and IsFFE],FFECONWAY.One);
InstallMethod(\<,IsIdenticalObj,[IsCoeffsModConwayPolRep and IsLexOrderedFFE,IsCoeffsModConwayPolRep and IsLexOrderedFFE],COM_FUN(35));
InstallMethod(\<,IsIdenticalObj,[IsCoeffsModConwayPolRep,IsFFE and IsInternalRep],COM_FUN(36));
InstallMethod(\<,IsIdenticalObj,[IsFFE and IsInternalRep,IsCoeffsModConwayPolRep],COM_FUN(37));
InstallMethod(\<,IsIdenticalObj,[IsCoeffsModConwayPolRep,IsFFE and IsModulusRep],COM_FUN(38));
InstallMethod(\<,IsIdenticalObj,[IsFFE and IsModulusRep,IsCoeffsModConwayPolRep],COM_FUN(39));
InstallMethod(IntFFE,[IsFFE and IsCoeffsModConwayPolRep],COM_FUN(40));
FFECONWAY.LogFFERhoIterate:=COM_FUN(41);
FFECONWAY.DoLogFFERho:=COM_FUN(42);
InstallMethod(LogFFE,IsIdenticalObj,[IsFFE and IsCoeffsModConwayPolRep,IsFFE and IsCoeffsModConwayPolRep],COM_FUN(43));
InstallMethod(LogFFE,IsIdenticalObj,[IsFFE and IsInternalRep,IsFFE and IsCoeffsModConwayPolRep],COM_FUN(44));
InstallMethod(Order,[IsFFE],COM_FUN(45));
InstallMethod(LargeGaloisField,[IsPosInt,IsPosInt],COM_FUN(46));
InstallMethod(PrimitiveRoot,[IsField and IsFFECollection and IsFinite],COM_FUN(47));
InstallMethod(Coefficients,"For a FFE in Conway polynomial represntation wrt the canonical basis of its \
natural field",IsCollsElms,[IsCanonicalBasis and IsBasisFiniteFieldRep,IsFFE and IsCoeffsModConwayPolRep\
],COM_FUN(48));
InstallMethod(Enumerator,[IsField and IsFinite and IsFFECollection],COM_FUN(49));
InstallMethod(AsList,[IsField and IsFinite and IsFFECollection],COM_FUN(50));
InstallMethod(Iterator,[IsField and IsFinite and IsFFECollection],COM_FUN(51));
InstallMethod(Random,[IsField and IsFFECollection and IsFinite],COM_FUN(52));
InstallMethod(MinimalPolynomial,IsCollsElmsX,[IsPrimeField,IsCoeffsModConwayPolRep and IsFFE,IsPosInt],COM_FUN(53));
InstallMethod(Display,"for matrix of FFEs (for larger fields)",[IsFFECollColl and IsMatrix],10,COM_FUN(54));
FFECONWAY.WriteOverSmallestCommonField:=COM_FUN(55);
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/ffeconway.gi"

#F  file="lib/rational.gi" crc=-120776568
RANK_FILTER_LIST  := [ 13061976, 15, 56267990, 63, 56267990, 63, 56267990, 
  63, 56267990, 63, 33, 17, 56267990, 63, 15716923, 12, 63198130, 7, 
  56267990, 63, 56267990, 63, 33, 17, 33, 17, 33, 17, 7665940, 19, 33, 17 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/rational.gi", -120776568 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/rational.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/rational.gi");
elif COM_RESULT = 3  then
Revision.rational_gi:="@(#)$Id: rational.gi,v 4.36.2.3 2006/01/25 10:13:51 gap Exp $";
InstallValue(Rationals,Objectify(NewType(CollectionsFamily(CyclotomicsFamily),IsRationals and IsAttributeStoringRep),rec()));
SetName(Rationals,"Rationals");
SetLeftActingDomain(Rationals,Rationals);
SetSize(Rationals,infinity);
SetConductor(Rationals,1);
SetDimension(Rationals,1);
SetGaloisStabilizer(Rationals,[1]);
SetGeneratorsOfLeftModule(Rationals,[1]);
SetIsWholeFamily(Rationals,false);
InstallValue(GaussianRationals,Objectify(NewType(CollectionsFamily(CyclotomicsFamily),IsGaussianRationals and IsAttributeStoringRep),rec()));
SetName(GaussianRationals,"GaussianRationals");
SetLeftActingDomain(GaussianRationals,Rationals);
SetIsPrimeField(GaussianRationals,false);
SetIsCyclotomicField(GaussianRationals,true);
SetSize(GaussianRationals,infinity);
SetConductor(GaussianRationals,4);
SetDimension(GaussianRationals,2);
SetDegreeOverPrimeField(GaussianRationals,2);
SetGaloisStabilizer(GaussianRationals,[1]);
SetGeneratorsOfLeftModule(GaussianRationals,[1,E(4)]);
SetIsWholeFamily(GaussianRationals,false);
InstallMethod(\in,"for cyclotomic and Rationals",[IsCyclotomic,IsRationals],COM_FUN(1));
InstallMethod(Random,"for Rationals",[IsRationals],COM_FUN(2));
InstallMethod(Conjugates,"for Rationals, Rationals, and a rational",IsCollsXElms,[IsRationals,IsRationals,IsRat],COM_FUN(3));
DeclareRepresentation("IsCanonicalBasisRationals",IsAttributeStoringRep,[]);
InstallMethod(CanonicalBasis,"for Rationals",[IsRationals],COM_FUN(4));
InstallMethod(Coefficients,"method for canonical basis of Rationals",IsCollsElms,[IsBasis and IsCanonicalBasis and IsCanonicalBasisRationals,IsVector],COM_FUN(5));
BindGlobal("NextIterator_Rationals",COM_FUN(6));
BindGlobal("ShallowCopy_Rationals",COM_FUN(7));
InstallMethod(Iterator,"for `Rationals'",[IsRationals],COM_FUN(8));
BindGlobal("NumberElement_Rationals",COM_FUN(9));
BindGlobal("ElementNumber_Rationals",COM_FUN(10));
InstallMethod(Enumerator,"for `Rationals'",[IsRationals],COM_FUN(11));
BindGlobal("EvalF",COM_FUN(12));
InstallMethod(RoundCyc,"Rational",[IsRat],COM_FUN(13));
InstallMethod(RoundCycDown,"Rational",[IsRat],COM_FUN(14));
InstallMethod(PadicValuation,"for rationals",ReturnTrue,[IsRat,IsPosInt],0,COM_FUN(15));
InstallMethod(LaTeXObj,"rational",[IsRat],COM_FUN(16));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/rational.gi"

#F  file="lib/gaussian.gi" crc=-31646309
RANK_FILTER_LIST  := [ 65, 16, 33553983, 42, 33553983, 42, 33553983, 42, 
  66048796, 12, 65, 16, 33553983, 42, 65, 16, 65, 16, 33553983, 42, 65, 16, 
  33553983, 42, 65, 16, 33553983, 42, 65, 16, 65, 16, 33553983, 42, 65, 16, 
  65, 16, 33553983, 42, 65, 16, 65, 16, 33553983, 42, 17, 18, 33553983, 42, 
  65, 16, 33553983, 42, 65, 16 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/gaussian.gi", -31646309 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/gaussian.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/gaussian.gi");
elif COM_RESULT = 3  then
Revision.gaussian_gi:="@(#)$Id: gaussian.gi,v 4.13 2002/04/15 10:04:40 sal Exp $";
InstallMethod(\in,"for Gaussian integers",IsElmsColls,[IsCyc,IsGaussianIntegers],COM_FUN(1));
InstallMethod(Basis,"for Gaussian integers (delegate to `CanonicalBasis')",[IsGaussianIntegers],CANONICAL_BASIS_FLAGS,CanonicalBasis);
DeclareRepresentation("IsCanonicalBasisGaussianIntegersRep",IsAttributeStoringRep,["conductor","zumbroichbase"]);
InstallMethod(CanonicalBasis,"for Gaussian integers",[IsGaussianIntegers],COM_FUN(2));
InstallMethod(Coefficients,"for canon. basis of Gaussian integers, and cyclotomic",IsCollsElms,[IsBasis and IsCanonicalBasis and IsCanonicalBasisGaussianIntegersRep,IsCyc],COM_FUN(3));
InstallMethod(Quotient,"for Gaussian integers",IsCollsElmsElms,[IsGaussianIntegers,IsCyc,IsCyc],COM_FUN(4));
InstallMethod(StandardAssociate,"for Gaussian integers",IsCollsElms,[IsGaussianIntegers,IsCyc],COM_FUN(5));
InstallMethod(EuclideanDegree,"for Gaussian integers",IsCollsElms,[IsGaussianIntegers,IsCyc],COM_FUN(6));
InstallMethod(EuclideanRemainder,"for Gaussian integers",IsCollsElmsElms,[IsGaussianIntegers,IsCyc,IsCyc],COM_FUN(7));
InstallMethod(EuclideanQuotient,"for Gaussian integers",IsCollsElmsElms,[IsGaussianIntegers,IsCyc,IsCyc],COM_FUN(8));
InstallMethod(QuotientRemainder,"for Gaussian integers",IsCollsElmsElms,[IsGaussianIntegers,IsCyc,IsCyc],COM_FUN(9));
InstallMethod(IsPrime,"for Gaussian integers and integer",IsCollsElms,[IsGaussianIntegers,IsInt],COM_FUN(10));
InstallMethod(IsPrime,"for Gaussian integers and cyclotomic",IsCollsElms,[IsGaussianIntegers,IsCyc],COM_FUN(11));
InstallMethod(Factors,"for Gaussian integers",IsCollsElms,[IsGaussianIntegers,IsCyc],COM_FUN(12));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/gaussian.gi"

#F  file="lib/cyclotom.gi" crc=108651071
RANK_FILTER_LIST  := [ 8193, 2, 13061976, 15, 13061976, 15, 65, 16, 127, 17, 
  33, 17, 43551717, 40, 58412696, 30, 41951068, 17, 26123951, 20, 52427961, 
  28, 9629322, 19, 4097, 1, 52427961, 28, 9629322, 19 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/cyclotom.gi", 108651071 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/cyclotom.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/cyclotom.gi");
elif COM_RESULT = 3  then
Revision.cyclotom_gi:="@(#)$Id: cyclotom.gi,v 4.50.2.1 2005/11/29 16:46:52 gap Exp $";
InstallOtherMethod(Conductor,"for a list",[IsList],COM_FUN(1));
InstallMethod(RoundCyc,"general cyclotomic",[IsCyclotomic],COM_FUN(2));
InstallMethod(RoundCycDown,"general cyclotomic",[IsCyclotomic],COM_FUN(3));
InstallMethod(ComplexConjugate,"for a cyclotomic",[IsCyc],COM_FUN(4));
InstallMethod(ExtRepOfObj,"for an internal cyclotomic",[IsCyc and IsInternalRep],COEFFS_CYC);
InstallGlobalFunction(CoeffsCyc,COM_FUN(5));
BindGlobal("CycList",COM_FUN(6));
InstallGlobalFunction(IsGaussInt,COM_FUN(7));
InstallGlobalFunction(IsGaussRat,COM_FUN(8));
InstallGlobalFunction(DescriptionOfRootOfUnity,COM_FUN(9));
BindGlobal("Atlas1",COM_FUN(10));
InstallGlobalFunction(EB,COM_FUN(11));
InstallGlobalFunction(EC,COM_FUN(12));
InstallGlobalFunction(ED,COM_FUN(13));
InstallGlobalFunction(EE,COM_FUN(14));
InstallGlobalFunction(EF,COM_FUN(15));
InstallGlobalFunction(EG,COM_FUN(16));
InstallGlobalFunction(EH,COM_FUN(17));
InstallGlobalFunction(NK,COM_FUN(18));
BindGlobal("Atlas2",COM_FUN(19));
InstallGlobalFunction(EY,COM_FUN(20));
InstallGlobalFunction(EX,COM_FUN(21));
InstallGlobalFunction(EW,COM_FUN(22));
InstallGlobalFunction(EV,COM_FUN(23));
InstallGlobalFunction(EU,COM_FUN(24));
InstallGlobalFunction(ET,COM_FUN(25));
InstallGlobalFunction(ES,COM_FUN(26));
InstallGlobalFunction(EM,COM_FUN(27));
InstallGlobalFunction(EL,COM_FUN(28));
InstallGlobalFunction(EK,COM_FUN(29));
InstallGlobalFunction(EJ,COM_FUN(30));
InstallGlobalFunction(ER,COM_FUN(31));
InstallGlobalFunction(EI,COM_FUN(32));
InstallMethod(Sqrt,"for a rational",[IsRat],ER);
InstallGlobalFunction(StarCyc,COM_FUN(33));
InstallGlobalFunction(AtlasIrrationality,COM_FUN(34));
InstallGlobalFunction(Quadratic,COM_FUN(35));
InstallMethod(GaloisMat,"for a matrix of cyclotomics",[IsMatrix and IsCyclotomicCollColl],COM_FUN(36));
InstallMethod(RationalizedMat,"for a matrix",[IsMatrix],COM_FUN(37));
InstallOtherMethod(RationalizedMat,"for an empty list",[IsList and IsEmpty],COM_FUN(38));
InstallMethod(IsGeneratorsOfMagmaWithInverses,"for a collection of cyclotomics (return false)",[IsCyclotomicCollection],SUM_FLAGS,COM_FUN(39));
InstallMethod(FactorsSquarefree,"for a polynomial over a field of cyclotomics",IsCollsElmsX,[IsAbelianNumberFieldPolynomialRing,IsUnivariatePolynomial,IsRecord],COM_FUN(40));
InstallMethod(Factors,"for a polynomial over a field of cyclotomics",IsCollsElms,[IsAbelianNumberFieldPolynomialRing,IsUnivariatePolynomial],COM_FUN(41));
InstallGlobalFunction(DenominatorCyc,COM_FUN(42));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/cyclotom.gi"

#F  file="lib/fldabnum.gi" crc=-103551766
RANK_FILTER_LIST  := [ 41634040, 59, 21055428, 61, 41634040, 59, 21055428, 
  61, 41634040, 59, 21055428, 61, 15510090, 53, 15510090, 53, 15510090, 53, 
  15510090, 53, 65, 16, 41634040, 59, 65, 16, 21055428, 61, 21055428, 61, 
  21055428, 61, 21055428, 61, 41634040, 59, 41634040, 59, 21055428, 61, 
  41634040, 59, 41634040, 59, 41634040, 59, 41634040, 59, 41634040, 59, 
  41634040, 59, 41634040, 59, 49151311, 17, 41634040, 59, 41634040, 59, 65, 
  16, 21055428, 61, 41634040, 59, 65, 16, 41634040, 59, 41634040, 59, 65, 16, 
  21055428, 61, 41634040, 59, 65, 16, 41634040, 59, 41634040, 59, 65, 16, 
  21055428, 61, 41634040, 59, 65, 16, 41634040, 59, 41634040, 59, 32494784, 
  12, 65, 16, 26123951, 20, 50937734, 54, 26123951, 20, 26123951, 20, 
  21055428, 61, 32494679, 13, 32494679, 13, 65, 16, 54568522, 14, 19481731, 
  17, 54568942, 11, 27262362, 26, 27262362, 26, 19481731, 17, 27262362, 26, 
  27262362, 26, 19481731, 17, 27262362, 26, 27262362, 26, 19481731, 17, 
  27262362, 26, 27262362, 26, 19481731, 17, 27262362, 26, 65, 16, 27262362, 
  26, 30625149, 10, 27262362, 26, 24813784, 48, 27262362, 26, 30625149, 10, 
  8288730, 30, 30625149, 10, 27262362, 26, 30625149, 10, 27262362, 26, 
  24813784, 48, 27262362, 26, 30625149, 10, 27262362, 26, 27262362, 26, 
  27262362, 26, 27262362, 26, 17, 18, 27262362, 26, 15510090, 53 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/fldabnum.gi", -103551766 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/fldabnum.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/fldabnum.gi");
elif COM_RESULT = 3  then
Revision.fldabnum_gi:="@(#)$Id: fldabnum.gi,v 4.48 2002/04/15 10:04:40 sal Exp $";
BindGlobal("AbelianNumberFieldByReducedGaloisStabilizerInfo",COM_FUN(1));
InstallGlobalFunction(CyclotomicField,COM_FUN(2));
BindGlobal("ReducedGaloisStabilizerInfo",COM_FUN(3));
InstallGlobalFunction(AbelianNumberField,COM_FUN(4));
InstallMethod(ViewObj,"for abelian number field of cyclotomics",[IsAbelianNumberField and IsCyclotomicCollection],COM_FUN(5));
InstallMethod(ViewObj,"for cyclotomic field of cyclotomics",[IsCyclotomicField and IsCyclotomicCollection],COM_FUN(6));
InstallMethod(PrintObj,"for abelian number field of cyclotomics",[IsAbelianNumberField and IsCyclotomicCollection],COM_FUN(7));
InstallMethod(PrintObj,"for cyclotomic field of cyclotomics",[IsCyclotomicField and IsCyclotomicCollection],COM_FUN(8));
InstallMethod(String,"for abelian number field of cyclotomics",[IsAbelianNumberField and IsCyclotomicCollection],COM_FUN(9));
InstallMethod(String,"for cyclotomic field of cyclotomics",[IsCyclotomicField and IsCyclotomicCollection],COM_FUN(10));
InstallMethod(\=,"for two abelian number fields",IsIdenticalObj,[IsAbelianNumberField,IsAbelianNumberField],COM_FUN(11));
InstallMethod(\<,"for two abelian number fields",IsIdenticalObj,[IsAbelianNumberField,IsAbelianNumberField],COM_FUN(12));
InstallMethod(\in,"for cyclotomic and abelian number field",IsElmsColls,[IsCyc,IsAbelianNumberField and IsCyclotomicCollection],COM_FUN(13));
InstallMethod(\in,"for cyclotomic and cyclotomic field",IsElmsColls,[IsCyc,IsCyclotomicField and IsCyclotomicCollection],COM_FUN(14));
InstallMethod(Intersection2,"for two cyclotomic fields of cyclotomics",IsIdenticalObj,[IsCyclotomicField and IsCyclotomicCollection,IsCyclotomicField and IsCyclotomicCollection],COM_FUN(15));
InstallMethod(Intersection2,"for cyclotomic field and abelian number field",IsIdenticalObj,[IsCyclotomicField and IsCyclotomicCollection,IsAbelianNumberField and IsCyclotomicCollection],COM_FUN(16));
InstallMethod(Intersection2,"for abelian number field and cyclotomic field",IsIdenticalObj,[IsAbelianNumberField and IsCyclotomicCollection,IsCyclotomicField and IsCyclotomicCollection],COM_FUN(17));
InstallMethod(Intersection2,"for two abelian number fields",IsIdenticalObj,[IsAbelianNumberField and IsCyclotomicCollection,IsAbelianNumberField and IsCyclotomicCollection],COM_FUN(18));
InstallMethod(GeneratorsOfDivisionRing,"for abelian number field of cyclotomics",[IsAbelianNumberField and IsCyclotomicCollection],COM_FUN(19));
InstallOtherMethod(Conductor,"for abelian number field of cyclotomics",[IsAbelianNumberField and IsCyclotomicCollection],COM_FUN(20));
InstallMethod(Subfields,"for abelian number field of cyclotomics",[IsAbelianNumberField and IsCyclotomicCollection],COM_FUN(21));
InstallMethod(PrimeField,"for abelian number field of cyclotomics",[IsAbelianNumberField and IsCyclotomicCollection],COM_FUN(22));
InstallOtherMethod(FieldExtension,"for field of cyclotomics, and univ. polynomial (degree <= 2)",[IsAbelianNumberField and IsCyclotomicCollection,IsLaurentPolynomial],COM_FUN(23));
InstallMethod(Conjugates,"for two abelian number fields of cyclotomics, and cyclotomic",IsCollsXElms,[IsAbelianNumberField and IsCyclotomicCollection,IsAbelianNumberField and IsCyclotomicCollection,IsCyc],COM_FUN(24));
InstallMethod(Conjugates,"for cycl. field of cyclotomics, ab. number field, and cyclotomic",IsCollsXElms,[IsCyclotomicField and IsCyclotomicCollection,IsAbelianNumberField and IsCyclotomicCollection,IsCyc],COM_FUN(25));
InstallMethod(Norm,"for two abelian number fields of cyclotomics, and cyclotomic",IsCollsXElms,[IsAbelianNumberField and IsCyclotomicCollection,IsAbelianNumberField and IsCyclotomicCollection,IsCyc],COM_FUN(26));
InstallMethod(Norm,"for cycl. field of cyclotomics, ab. number field, and cyclotomic",IsCollsXElms,[IsCyclotomicField and IsCyclotomicCollection,IsAbelianNumberField and IsCyclotomicCollection,IsCyc],COM_FUN(27));
InstallMethod(Trace,"for two abelian number fields of cyclotomics, and cyclotomic",IsCollsXElms,[IsAbelianNumberField and IsCyclotomicCollection,IsAbelianNumberField and IsCyclotomicCollection,IsCyc],COM_FUN(28));
InstallMethod(Trace,"for cycl. field of cyclotomics, ab. number field, and cyclotomic",IsCollsXElms,[IsCyclotomicField and IsCyclotomicCollection,IsAbelianNumberField and IsCyclotomicCollection,IsCyc],COM_FUN(29));
InstallGlobalFunction(ZumbroichBase,COM_FUN(30));
InstallGlobalFunction(LenstraBase,COM_FUN(31));
DeclareRepresentation("IsCanonicalBasisAbelianNumberFieldRep",IsAttributeStoringRep,["coeffslist","coeffsmat","lenstrabase","conductor"]);
DeclareRepresentation("IsCanonicalBasisCyclotomicFieldRep",IsCanonicalBasisAbelianNumberFieldRep,["zumbroichbase"]);
InstallMethod(CanonicalBasis,"for abelian number field of cyclotomics",[IsAbelianNumberField and IsCyclotomicCollection],COM_FUN(32));
InstallMethod(Basis,"for abelian number field of cyclotomics (delegate to `CanonicalBasis')",[IsAbelianNumberField and IsCyclotomicCollection],CANONICAL_BASIS_FLAGS,CanonicalBasis);
InstallMethod(Coefficients,"for canonical basis of abelian number field, and cyclotomic",IsCollsElms,[IsBasis and IsCanonicalBasis and IsCanonicalBasisAbelianNumberFieldRep,IsCyc],COM_FUN(33));
InstallOtherMethod(FieldByGenerators,"for collection of cyclotomics",[IsCyclotomicCollection],COM_FUN(34));
InstallMethod(FieldByGenerators,"for field and collection, both collections of cyclotomics",IsIdenticalObj,[IsField and IsCyclotomicCollection,IsCyclotomicCollection],COM_FUN(35));
InstallMethod(DefaultFieldByGenerators,"for collection of cyclotomics",[IsCyclotomicCollection],COM_FUN(36));
InstallMethod(CanonicalBasis,"for cyclotomic field of cyclotomics",[IsCyclotomicField and IsCyclotomicCollection],COM_FUN(37));
InstallMethod(BasisVectors,"for canon. basis of cyclotomic field of cyclotomics",[IsBasis and IsCanonicalBasis and IsCanonicalBasisCyclotomicFieldRep],COM_FUN(38));
InstallMethod(Coefficients,"for canonical basis of cyclotomic field, and cyclotomic",IsCollsElms,[IsBasis and IsCanonicalBasis and IsCanonicalBasisCyclotomicFieldRep,IsCyc],COM_FUN(39));
InstallValue(Cyclotomics,Objectify(NewType(CollectionsFamily(CyclotomicsFamily),IsField and IsAttributeStoringRep),rec()));
SetName(Cyclotomics,"Cyclotomics");
SetLeftActingDomain(Cyclotomics,Rationals);
SetIsFiniteDimensional(Cyclotomics,false);
SetIsFinite(Cyclotomics,false);
SetIsWholeFamily(Cyclotomics,true);
SetDegreeOverPrimeField(Cyclotomics,infinity);
SetDimension(Cyclotomics,infinity);
DeclareRepresentation("IsANFAutomorphismRep",IsAttributeStoringRep,["galois"]);
DeclareSynonym("IsANFAutomorphism",IsANFAutomorphismRep and IsFieldHomomorphism and IsMapping and IsBijective);
InstallMethod(ExponentOfPowering,"for an ANFAutomorphism",[IsMapping and IsANFAutomorphismRep],COM_FUN(40));
InstallMethod(ExponentOfPowering,"for an identity mapping",[IsMapping and IsOne],COM_FUN(41));
InstallMethod(ExponentOfPowering,"for a mapping (check whether it is the identity mapping)",[IsMapping],COM_FUN(42));
InstallGlobalFunction(ANFAutomorphism,COM_FUN(43));
InstallMethod(\=,"for two ANF automorphisms",IsIdenticalObj,[IsFieldHomomorphism and IsANFAutomorphismRep,IsFieldHomomorphism and IsANFAutomorphismRep],COM_FUN(44));
InstallMethod(\=,"for identity mapping and ANF automorphism",IsIdenticalObj,[IsMapping and IsOne,IsFieldHomomorphism and IsANFAutomorphismRep],COM_FUN(45));
InstallMethod(\=,"for ANF automorphism and identity mapping",IsIdenticalObj,[IsFieldHomomorphism and IsANFAutomorphismRep,IsMapping and IsOne],COM_FUN(46));
InstallMethod(\<,"for two ANF automorphisms",IsIdenticalObj,[IsFieldHomomorphism and IsANFAutomorphismRep,IsFieldHomomorphism and IsANFAutomorphismRep],COM_FUN(47));
InstallMethod(\<,"for identity mapping and ANF automorphism",IsIdenticalObj,[IsMapping and IsOne,IsFieldHomomorphism and IsANFAutomorphismRep],COM_FUN(48));
InstallMethod(\<,"for ANF automorphism and identity mapping",IsIdenticalObj,[IsFieldHomomorphism and IsANFAutomorphismRep,IsMapping and IsOne],COM_FUN(49));
InstallMethod(ImageElm,"for ANF automorphism and scalar",FamSourceEqFamElm,[IsFieldHomomorphism and IsANFAutomorphismRep,IsCyc],COM_FUN(50));
InstallMethod(ImagesElm,"for ANF automorphism and scalar",FamSourceEqFamElm,[IsFieldHomomorphism and IsANFAutomorphismRep,IsScalar],COM_FUN(51));
InstallMethod(ImagesSet,"for ANF automorphism and field",CollFamSourceEqFamElms,[IsFieldHomomorphism and IsANFAutomorphismRep,IsField],COM_FUN(52));
InstallMethod(ImagesRepresentative,"for ANF automorphism and scalar",FamSourceEqFamElm,[IsFieldHomomorphism and IsANFAutomorphismRep,IsScalar],COM_FUN(53));
InstallMethod(PreImageElm,"for ANF automorphism and scalar",FamRangeEqFamElm,[IsFieldHomomorphism and IsBijective and IsANFAutomorphismRep,IsScalar],COM_FUN(54));
InstallMethod(PreImagesElm,"for ANF automorphism and scalar",FamRangeEqFamElm,[IsFieldHomomorphism and IsANFAutomorphismRep,IsScalar],COM_FUN(55));
InstallMethod(PreImagesSet,"for ANF automorphism and scalar",CollFamRangeEqFamElms,[IsFieldHomomorphism and IsANFAutomorphismRep,IsField],COM_FUN(56));
InstallMethod(PreImagesRepresentative,"for ANF automorphism and scalar",FamRangeEqFamElm,[IsFieldHomomorphism and IsANFAutomorphismRep,IsScalar],COM_FUN(57));
InstallMethod(CompositionMapping2,"for two ANF automorphisms",FamSource1EqFamRange2,[IsFieldHomomorphism and IsANFAutomorphismRep,IsFieldHomomorphism and IsANFAutomorphismRep],COM_FUN(58));
InstallOtherMethod(InverseGeneralMapping,"for ANF automorphism",[IsFieldHomomorphism and IsANFAutomorphismRep],COM_FUN(59));
InstallMethod(\^,"for ANF automorphism and integer",[IsFieldHomomorphism and IsANFAutomorphismRep,IsInt],COM_FUN(60));
InstallMethod(PrintObj,"for ANF automorphism",[IsFieldHomomorphism and IsANFAutomorphismRep],COM_FUN(61));
InstallMethod(GaloisGroup,"for abelian number field ",[IsAbelianNumberField],COM_FUN(62));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/fldabnum.gi"

#F  file="lib/padics.gi" crc=-42719481
RANK_FILTER_LIST  := [ 35414261, 13, 17, 18, 35414261, 13, 33, 17, 33, 17, 
  35414261, 13, 3728794, 25, 33, 17, 33, 17, 3728794, 25, 35414261, 13, 
  35414261, 13, 59539217, 5, 26123951, 20, 59539217, 5, 33, 17, 29769609, 14, 
  59539217, 5, 59539217, 5, 29769609, 14, 59539217, 5, 29769609, 14, 
  29769609, 14, 29769609, 14, 29769609, 14, 29769609, 14, 29769609, 14, 
  29769609, 14, 29769609, 14, 29769609, 14, 29769609, 14, 29769609, 14, 
  29769609, 14, 29769609, 14, 36831188, 5, 8193, 2, 36831188, 5, 33, 17, 
  51969554, 14, 36831188, 5, 36831188, 5, 51969554, 14, 36831188, 5, 
  51969554, 14, 51969554, 14, 51969554, 14, 51969554, 14, 51969554, 14, 
  51969554, 14, 51969554, 14, 29769609, 14, 51969554, 14, 51969554, 14, 
  29769609, 14, 51969554, 14, 51969554, 14, 51969554, 14, 51969554, 14, 
  51969554, 14, 51969554, 14 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/padics.gi", -42719481 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/padics.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/padics.gi");
elif COM_RESULT = 3  then
Revision.padics_gi:="@(#)$Id: padics.gi,v 4.18 2002/04/15 10:05:11 sal Exp $";
PrintPadicExpansion:=COM_FUN(1);
PadicExpansionByRat:=COM_FUN(2);
MultMatrixPadicNumbersByCoefficientsList:=COM_FUN(3);
StructureConstantsPadicNumbers:=COM_FUN(4);
InstallMethod(ShiftedPadicNumber,true,[IsPadicNumber,IsInt],0,COM_FUN(5));
InstallMethod(\*,true,[IsPadicNumber,IsRat],0,COM_FUN(6));
InstallMethod(\*,true,[IsRat,IsPadicNumber],0,COM_FUN(7));
InstallMethod(\*,true,[IsPadicNumberList,IsRat],0,COM_FUN(8));
InstallMethod(\*,true,[IsRat,IsPadicNumberList],0,COM_FUN(9));
InstallMethod(ZeroOp,"for a p-adic number",true,[IsPadicNumber],0,COM_FUN(10));
InstallMethod(OneOp,"for a p-adic number",true,[IsPadicNumber],0,COM_FUN(11));
InstallGlobalFunction(PurePadicNumberFamily,COM_FUN(12));
InstallMethod(PadicNumber,true,[IsPurePadicNumberFamily,IsCyclotomicCollection],0,COM_FUN(13));
InstallMethod(PadicNumber,true,[IsPurePadicNumberFamily,IsRat],0,COM_FUN(14));
InstallMethod(PrintObj,true,[IsPurePadicNumber],0,COM_FUN(15));
InstallOtherMethod(Random,true,[IsPurePadicNumberFamily],0,COM_FUN(16));
InstallOtherMethod(Zero,true,[IsPurePadicNumberFamily],0,COM_FUN(17));
InstallMethod(IsZero,true,[IsPurePadicNumber],0,COM_FUN(18));
InstallOtherMethod(One,true,[IsPurePadicNumberFamily],0,COM_FUN(19));
InstallMethod(Valuation,true,[IsPurePadicNumber],0,COM_FUN(20));
InstallMethod(AdditiveInverseOp,true,[IsPurePadicNumber],0,COM_FUN(21));
InstallMethod(InverseOp,true,[IsPurePadicNumber],0,COM_FUN(22));
InstallMethod(\+,IsIdenticalObj,[IsPurePadicNumber,IsPurePadicNumber],0,COM_FUN(23));
InstallMethod(\*,IsIdenticalObj,[IsPurePadicNumber,IsPurePadicNumber],0,COM_FUN(24));
InstallMethod(\/,IsIdenticalObj,[IsPurePadicNumber,IsPurePadicNumber],0,COM_FUN(25));
InstallMethod(\=,IsIdenticalObj,[IsPurePadicNumber,IsPurePadicNumber],0,COM_FUN(26));
InstallMethod(\<,IsIdenticalObj,[IsPurePadicNumber,IsPurePadicNumber],0,COM_FUN(27));
InstallGlobalFunction(PadicExtensionNumberFamily,COM_FUN(28));
InstallMethod(PadicNumber,true,[IsPadicExtensionNumberFamily,IsList],0,COM_FUN(29));
InstallMethod(PadicNumber,true,[IsPadicExtensionNumberFamily,IsRat],0,COM_FUN(30));
InstallMethod(PrintObj,true,[IsPadicExtensionNumber],0,COM_FUN(31));
InstallOtherMethod(Random,true,[IsPadicExtensionNumberFamily],0,COM_FUN(32));
InstallOtherMethod(Zero,true,[IsPadicExtensionNumberFamily],0,COM_FUN(33));
InstallMethod(IsZero,true,[IsPadicExtensionNumber],0,COM_FUN(34));
InstallOtherMethod(One,true,[IsPadicExtensionNumberFamily],0,COM_FUN(35));
InstallMethod(Valuation,true,[IsPadicExtensionNumber],0,COM_FUN(36));
InstallMethod(AdditiveInverseOp,true,[IsPadicExtensionNumber],0,COM_FUN(37));
InstallMethod(InverseOp,true,[IsPadicExtensionNumber],0,COM_FUN(38));
InstallMethod(\+,IsIdenticalObj,[IsPadicExtensionNumber,IsPadicExtensionNumber],0,COM_FUN(39));
InstallMethod(\-,IsIdenticalObj,[IsPadicExtensionNumber,IsPadicExtensionNumber],0,COM_FUN(40));
InstallMethod(\*,true,[IsPurePadicNumber,IsPadicExtensionNumber],0,COM_FUN(41));
InstallMethod(\*,true,[IsPadicExtensionNumber,IsPurePadicNumber],0,COM_FUN(42));
InstallMethod(\*,IsIdenticalObj,[IsPadicExtensionNumber,IsPadicExtensionNumber],0,COM_FUN(43));
InstallMethod(\=,IsIdenticalObj,[IsPadicExtensionNumber,IsPadicExtensionNumber],0,COM_FUN(44));
InstallMethod(\<,IsIdenticalObj,[IsPadicExtensionNumber,IsPadicExtensionNumber],0,COM_FUN(45));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/padics.gi"

#F  file="lib/vecmat.gi" crc=122235577
RANK_FILTER_LIST  := [ 15212470, 12, 15212470, 12, 7665940, 19, 15212470, 12, 
  7665940, 19, 15212470, 12, 24639, 14, 15212470, 12, 7665940, 19, 1, 0, 
  15212470, 12, 7665940, 19, 15204278, 2, 13162178, 20, 8978734, 23, 8978735, 
  25, 8978734, 23, 8978734, 23, 8978734, 23, 8978735, 25, 8978734, 23, 
  13173338, 20, 13173338, 20, 13173338, 20, 13173338, 20, 8978734, 23, 
  8978734, 23, 8978734, 23, 8978734, 23, 4605586, 31, 4605586, 31, 257, 15, 
  8800190, 28, 8800190, 28, 257, 15, 13173339, 22, 13173338, 20, 257, 15, 
  13173339, 22, 13173338, 20, 41951069, 19, 13173338, 20, 257, 15, 41951069, 
  19, 13173338, 20, 13173339, 22, 7314756, 26, 7665940, 19, 13173338, 20, 17, 
  18, 13173338, 20, 17, 18, 7314755, 30, 21712371, 39, 21712371, 39, 7665940, 
  19, 30416748, 14, 7665940, 19, 1, 0, 30416747, 12, 7665940, 19, 1, 0, 
  30416748, 14, 7665940, 19, 30416747, 12, 7665940, 19, 30408555, 2, 
  21701211, 39, 21712371, 39, 21712371, 39, 21712371, 39, 17517767, 40, 
  17517767, 40, 17517767, 40, 2155133, 50, 2155133, 50, 48405456, 51, 
  48405456, 51, 38275771, 40, 38275771, 40, 38275771, 40, 17517767, 40, 
  17517767, 40, 17517767, 40, 17517767, 40, 17517767, 40, 17517767, 40, 
  17517767, 40, 17517767, 40, 17517767, 40, 17517767, 40, 17517767, 40, 
  4605586, 31, 17517767, 40, 51136371, 28, 8081033, 40, 17517767, 40, 
  8978734, 23, 17517767, 40, 17517767, 40, 257, 15, 17517767, 40, 17517767, 
  40, 257, 15, 1, 0, 58412696, 30, 1, 0, 58412696, 30, 1025, 1, 24813784, 48, 
  54525338, 2, 24813784, 48, 30408555, 2, 7665940, 19, 54525338, 2, 7665940, 
  19, 30408555, 2, 1, 0, 41942876, 3, 1, 0, 8193, 2, 57540459, 12, 5635857, 
  12, 13173339, 22, 257, 15, 13173338, 20, 8005674, 17, 13173338, 20, 
  8005674, 17, 8005434, 20, 15212471, 14, 15212470, 12, 30416747, 12, 1, 0, 
  13181530, 20, 13173338, 20, 65077940, 12, 13172873, 36, 7665940, 19, 
  65077475, 29, 7665940, 19, 24802159, 278, 13172873, 36, 62036794, 50, 
  13172873, 36, 13173339, 22, 7665940, 19, 13173339, 22, 7665940, 19, 
  8005674, 17, 13173339, 22, 13173339, 22, 8005674, 17, 13173338, 20, 17, 18, 
  13173338, 20, 17, 18, 13173338, 20, 13173338, 20, 13173339, 22, 17, 18, 
  13173338, 20, 17, 18, 13173339, 22, 13173338, 20, 13173338, 20, 17, 18, 
  7665940, 19, 13173338, 20, 17, 18, 63197665, 24, 8193, 2, 5, 1, 62036794, 
  50, 62036794, 50, 48405457, 53, 48405457, 53, 48405457, 53, 62036795, 52, 
  48405457, 53, 48405457, 53, 30408555, 2, 30408555, 2, 15204278, 2, 
  15204278, 2, 30408555, 2, 17, 18, 15204278, 2 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/vecmat.gi", 122235577 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/vecmat.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/vecmat.gi");
elif COM_RESULT = 3  then
Revision.vecmat_gi:="@(#)$Id: vecmat.gi,v 4.93.2.4 2006/08/22 10:35:54 gap Exp $";
DeclareFilter("IsLockedRepresentationVector");
InstallValue(TYPE_LIST_GF2VEC,NewType(CollectionsFamily(FFEFamily(2)),IsHomogeneousList and IsListDefault and IsNoImmediateMethodsObject and IsMutable and IsCopyable and IsGF2VectorRep));
InstallValue(TYPE_LIST_GF2VEC_IMM,NewType(CollectionsFamily(FFEFamily(2)),IsHomogeneousList and IsListDefault and IsNoImmediateMethodsObject and IsCopyable and IsGF2VectorRep));
InstallValue(TYPE_LIST_GF2VEC_IMM_LOCKED,NewType(CollectionsFamily(FFEFamily(2)),IsHomogeneousList and IsListDefault and IsNoImmediateMethodsObject and IsCopyable and IsGF2VectorRep and IsLockedRepre\
sentationVector));
InstallValue(TYPE_LIST_GF2VEC_LOCKED,NewType(CollectionsFamily(FFEFamily(2)),IsHomogeneousList and IsListDefault and IsNoImmediateMethodsObject and IsCopyable and IsGF2VectorRep and IsLockedRepresentationVector and IsMutable));
InstallValue(TYPE_LIST_GF2MAT,NewType(CollectionsFamily(CollectionsFamily(FFEFamily(2))),IsMatrix and IsListDefault and IsSmallList and IsFFECollColl and IsNoImmediateMethodsObject and IsMutable and IsCopyable and IsGF2MatrixRep and HasIsRectangularTable and IsRectangularTable));
InstallValue(TYPE_LIST_GF2MAT_IMM,NewType(CollectionsFamily(CollectionsFamily(FFEFamily(2))),IsMatrix and IsListDefault and IsCopyable and IsGF2MatrixRep and IsNoImmediateMethodsObject and IsSmallList and IsFFECollColl and HasIsRectangularTable and IsRectangularTable));
InstallMethod(Length,"for GF2 vector",true,[IsList and IsGF2VectorRep],0,LEN_GF2VEC);
InstallMethod(ELM0_LIST,"for GF2 vector",true,[IsList and IsGF2VectorRep,IsPosInt],0,ELM0_GF2VEC);
InstallMethod(ELM_LIST,"for GF2 vector",true,[IsList and IsGF2VectorRep,IsPosInt],0,ELM_GF2VEC);
InstallMethod(ELMS_LIST,"for GF2 vector",true,[IsList and IsGF2VectorRep,IsList and IsDenseList and IsInternalRep],0,ELMS_GF2VEC);
InstallOtherMethod(ASS_LIST,"for GF2 vector",true,[IsList and IsGF2VectorRep,IsPosInt,IsObject],0,ASS_GF2VEC);
InstallOtherMethod(UNB_LIST,"for GF2 vector",true,[IsList and IsGF2VectorRep,IsPosInt],0,UNB_GF2VEC);
InstallMethod(PrintObj,"for GF2 vector",true,[IsGF2VectorRep],0,COM_FUN(1));
InstallMethod(ViewObj,"for GF2 vector",true,[IsRowVector and IsFinite and IsGF2VectorRep],0,COM_FUN(2));
InstallMethod(AdditiveInverseMutable,"for GF2 vector",true,[IsRowVector and IsListDefault and IsGF2VectorRep],0,ShallowCopy);
InstallMethod(AdditiveInverseSameMutability,"for GF2 vector, mutable",true,[IsRowVector and IsListDefault and IsGF2VectorRep and IsMutable],0,ShallowCopy);
InstallMethod(AdditiveInverseSameMutability,"for GF2 vector, immutable",true,[IsRowVector and IsListDefault and IsGF2VectorRep],0,COM_FUN(3));
InstallMethod(AdditiveInverse,"for GF2 vector",true,[IsRowVector and IsListDefault and IsGF2VectorRep],0,Immutable);
InstallMethod(ZeroOp,"for GF2 vector",true,[IsRowVector and IsListDefault and IsGF2VectorRep],0,ZERO_GF2VEC);
InstallMethod(ZeroSameMutability,"for GF2 vector, mutable",true,[IsRowVector and IsListDefault and IsGF2VectorRep and IsMutable],0,ZERO_GF2VEC);
InstallMethod(ZeroSameMutability,"for GF2 vector, immutable",true,[IsRowVector and IsListDefault and IsGF2VectorRep],0,COM_FUN(4));
InstallMethod(\=,"for GF2 vectors",IsIdenticalObj,[IsRowVector and IsGF2VectorRep,IsRowVector and IsGF2VectorRep],0,EQ_GF2VEC_GF2VEC);
InstallMethod(\<,"for GF2 vectors",IsIdenticalObj,[IsRowVector and IsGF2VectorRep,IsRowVector and IsGF2VectorRep],0,LT_GF2VEC_GF2VEC);
InstallMethod(\+,"for GF2 vectors",IsIdenticalObj,[IsRowVector and IsListDefault and IsGF2VectorRep,IsRowVector and IsListDefault and IsGF2VectorRep],0,SUM_GF2VEC_GF2VEC);
InstallMethod(\-,"for GF2 vectors",IsIdenticalObj,[IsRowVector and IsListDefault and IsGF2VectorRep,IsRowVector and IsListDefault and IsGF2VectorRep],0,SUM_GF2VEC_GF2VEC);
InstallMethod(\*,"for GF2 vectors",IsIdenticalObj,[IsRingElementList and IsListDefault and IsRowVector and IsGF2VectorRep,IsRingElementList and IsListDefault and IsRowVector and IsGF2VectorRep],0,PROD_GF2VEC_GF2VEC);
InstallMethod(\*,"for FFE and GF2 vector",IsElmsColls,[IsFFE,IsRingElementList and IsRowVector and IsGF2VectorRep],10,COM_FUN(5));
InstallMethod(\*,"for GF2 vector and FFE",IsCollsElms,[IsRingElementList and IsRowVector and IsGF2VectorRep,IsFFE],10,COM_FUN(6));
InstallOtherMethod(AddCoeffs,"for GF2 vectors and FFE",COM_FUN(7),[IsRowVector and IsGF2VectorRep and IsMutable,IsRowVector and IsGF2VectorRep,IsFFE],0,ADDCOEFFS_GF2VEC_GF2VEC_MULT);
InstallOtherMethod(AddCoeffs,"for GF2 vectors",IsIdenticalObj,[IsRowVector and IsGF2VectorRep and IsMutable,IsRowVector and IsGF2VectorRep],0,ADDCOEFFS_GF2VEC_GF2VEC);
InstallOtherMethod(AddCoeffs,"for empty list, GF2 vector and FFE",true,[IsList and IsEmpty and IsMutable,IsRowVector and IsGF2VectorRep,IsFFE],0,COM_FUN(8));
InstallOtherMethod(AddCoeffs,"for empty list, GF2 vector",true,[IsList and IsEmpty and IsMutable,IsRowVector and IsGF2VectorRep],0,COM_FUN(9));
InstallMethod(ShrinkCoeffs,"for GF2 vector",true,[IsMutable and IsRowVector and IsGF2VectorRep],0,SHRINKCOEFFS_GF2VEC);
InstallMethod(PadCoeffs,"for GF2 vector",true,[IsMutable and IsRowVector and IsAdditiveElementWithZeroCollection and IsGF2V\
ectorRep,IsPosInt],0,COM_FUN(10));
InstallMethod(QuotRemCoeffs,"GF2 vectors",[IsRowVector and IsGF2VectorRep,IsInt,IsRowVector and IsGF2VectorRep,IsInt],QUOTREM_COEFFS_GF2VEC);
InstallMethod(NormedRowVector,"for GF(2) vector",true,[IsRowVector and IsGF2VectorRep and IsScalarCollection],0,COM_FUN(11));
InstallMethod(Length,"for GF2 matrix",true,[IsMatrix and IsGF2MatrixRep],0,COM_FUN(12));
InstallMethod(ELM_LIST,"for GF2 matrix",true,[IsMatrix and IsGF2MatrixRep,IsPosInt],0,COM_FUN(13));
InstallMethod(ASS_LIST,"for GF2 matrix",true,[IsList and IsGF2MatrixRep and IsMutable,IsPosInt,IsObject],0,ASS_GF2MAT);
InstallOtherMethod(ASS_LIST,"for GF2 matrix",true,[IsList and IsGF2MatrixRep,IsPosInt,IsObject],0,ASS_GF2MAT);
InstallMethod(UNB_LIST,"for GF2 matrix",true,[IsList and IsGF2MatrixRep and IsMutable,IsPosInt],0,UNB_GF2MAT);
InstallOtherMethod(UNB_LIST,"for GF2 matrix",true,[IsList and IsGF2MatrixRep,IsPosInt],0,COM_FUN(14));
InstallMethod(PrintObj,"for GF2 matrix",true,[IsGF2MatrixRep],0,COM_FUN(15));
InstallMethod(ViewObj,"for GF2 matrix",true,[IsMatrix and IsFinite and IsGF2MatrixRep],0,COM_FUN(16));
BindGlobal("SHALLOWCOPY_GF2MAT",COM_FUN(17));
InstallMethod(ShallowCopy,"for GF2 matrix",true,[IsMatrix and IsGF2MatrixRep],0,SHALLOWCOPY_GF2MAT);
InstallMethod(TransposedMat,"GF2 matrix",true,[IsMatrix and IsGF2MatrixRep],0,TRANSPOSED_GF2MAT);
InstallMethod(MutableTransposedMat,"GF2 matrix",true,[IsMatrix and IsGF2Matrix\
Rep],0,TRANSPOSED_GF2MAT);
InstallMethod(AdditiveInverseOp,"for GF2 matrix",true,[IsMatrix and IsListDefault and IsGF2MatrixRep],0,COM_FUN(18));
InstallMethod(AdditiveInverseSameMutability,"for GF2 matrix",true,[IsMatrix and IsListDefault and IsGF2MatrixRep],0,COM_FUN(19));
InstallMethod(AdditiveInverse,"for GF2 matrix",true,[IsMatrix and IsListDefault and IsGF2MatrixRep],0,Immutable);
InstallMethod(InverseOp,"for GF2 matrix",true,[IsMultiplicativeElementWithInverse and IsOrdinaryMatrix and IsSmallList and IsFFECollColl and IsGF2MatrixRep],0,INV_GF2MAT_MUTABLE);
InstallMethod(InverseSameMutability,"for GF2 matrix",true,[IsMultiplicativeElementWithInverse and IsOrdinaryMatrix and IsSmallList and IsFFECollColl and IsGF2MatrixRep],0,INV_GF2MAT_SAME_MUTABILITY);
InstallMethod(InverseOp,"for plain list of GF2 vectors",true,[IsPlistRep and IsFFECollColl and IsMatrix],0,COM_FUN(20));
InstallMethod(InverseSameMutability,"for plain list of GF2 vectors",true,[IsPlistRep and IsFFECollColl and IsMatrix],0,COM_FUN(21));
BindGlobal("GF2IdentityMatrix",COM_FUN(22));
InstallMethod(OneOp,"for GF2 Matrix",true,[IsOrdinaryMatrix and IsGF2MatrixRep and IsMultiplicativeElementWithOne],0,COM_FUN(23));
InstallMethod(One,"for GF2 Matrix",true,[IsOrdinaryMatrix and IsGF2MatrixRep and IsMultiplicativeElementWithOne],0,COM_FUN(24));
InstallMethod(OneSameMutability,"for GF2 Matrix",true,[IsOrdinaryMatrix and IsGF2MatrixRep and IsMultiplicativeElementWithOne],0,COM_FUN(25));
InstallMethod(ZeroOp,"for GF2 Matrix",true,[IsMatrix and IsListDefault and IsGF2MatrixRep],0,COM_FUN(26));
InstallMethod(ZeroSameMutability,"for GF2 Matrix",true,[IsMatrix and IsListDefault and IsGF2MatrixRep],0,COM_FUN(27));
InstallMethod(Zero,"for GF2 Matrix",true,[IsMatrix and IsListDefault and IsGF2MatrixRep],0,COM_FUN(28));
InstallMethod(\+,"for GF2 matrix and GF2 matrix",IsIdenticalObj,[IsMatrix and IsListDefault and IsGF2MatrixRep,IsMatrix and IsListDefault and IsGF2MatrixRep],0,SUM_GF2MAT_GF2MAT);
InstallMethod(\<,"for GF2 matrix and GF2 matrix",IsIdenticalObj,[IsMatrix and IsListDefault and IsGF2MatrixRep,IsMatrix and IsListDefault and IsGF2MatrixRep],0,LT_GF2MAT_GF2MAT);
InstallMethod(\=,"for GF2 matrix and GF2 matrix",IsIdenticalObj,[IsMatrix and IsListDefault and IsGF2MatrixRep,IsMatrix and IsListDefault and IsGF2MatrixRep],0,EQ_GF2MAT_GF2MAT);
InstallMethod(\-,"for GF2 matrix and GF2 matrix",IsIdenticalObj,[IsMatrix and IsListDefault and IsGF2MatrixRep,IsMatrix and IsListDefault and IsGF2MatrixRep],0,SUM_GF2MAT_GF2MAT);
InstallMethod(\*,"for GF2 vector and GF2 matrix",true,[IsRingElementList and IsRowVector and IsListDefault and IsGF2VectorRep,IsMatrix and IsListDefault and IsGF2MatrixRep],0,PROD_GF2VEC_GF2MAT);
InstallMethod(\*,"For a GF2 vector and a compatible matrix",IsElmsColls,[IsRowVector and IsGF2VectorRep and IsSmallList and IsRingElementList,IsRingElementTable and IsPlistRep],0,PROD_GF2VEC_ANYMAT);
InstallMethod(\*,"for GF2 matrix and GF2 vector",true,[IsMatrix and IsListDefault and IsGF2MatrixRep,IsRowVector and IsListDefault and IsGF2VectorRep],0,PROD_GF2MAT_GF2VEC);
InstallMethod(\*,"for GF2 matrix and GF2 matrix",IsIdenticalObj,[IsMatrix and IsListDefault and IsGF2MatrixRep,IsMatrix and IsListDefault and IsGF2MatrixRep],0,PROD_GF2MAT_GF2MAT);
InstallMethod(\*,"for GF2 element and GF2 matrix",IsElmsCollColls,[IsFFE,IsMatrix and IsListDefault and IsGF2MatrixRep],0,COM_FUN(29));
InstallMethod(\*,"for GF2 matrix and GF2 element",IsCollCollsElms,[IsMatrix and IsListDefault and IsGF2MatrixRep,IsFFE],0,COM_FUN(30));
LOCAL_COPY_GF2:=GF(2);
InstallGlobalFunction(ConvertToVectorRepNC,COM_FUN(31));
DoImmutableMatrix:=COM_FUN(32);
InstallMethod(ImmutableMatrix,"general,2",[IsObject,IsMatrix],0,COM_FUN(33));
InstallOtherMethod(ImmutableMatrix,"general,3",[IsObject,IsMatrix,IsBool],0,DoImmutableMatrix);
InstallOtherMethod(ImmutableMatrix,"field,8bit",[IsField,Is8BitMatrixRep],0,COM_FUN(34));
InstallOtherMethod(ImmutableMatrix,"field,gf2",[IsField,IsGF2MatrixRep],0,COM_FUN(35));
InstallOtherMethod(ImmutableMatrix,"fieldsize,8bit",[IsPosInt,Is8BitMatrixRep]\
,0,COM_FUN(36));
InstallOtherMethod(ImmutableMatrix,"fieldsize,gf2",[IsPosInt,IsGF2MatrixRep],0,COM_FUN(37));
InstallOtherMethod(ImmutableMatrix,"empty",[IsObject,IsEmpty],0,COM_FUN(38));
InstallOtherMethod(ImmutableMatrix,"transposed empty",[IsObject,IsList],0,COM_FUN(39));
InstallMethod(PlainListCopyOp,"for a GF2 vector",true,[IsGF2VectorRep and IsSmallList],0,COM_FUN(40));
InstallMethod(PlainListCopyOp,"for a GF2 matrix",true,[IsSmallList and IsGF2MatrixRep],0,COM_FUN(41));
InstallOtherMethod(MultRowVector,"for GF(2) vector and char 2 scalar",IsCollsElms,[IsGF2VectorRep and IsRowVector and IsMutable,IsFFE],0,MULT_ROW_VECTOR_GF2VECS_2);
InstallOtherMethod(PositionNot,"for GF(2) vector and 0*Z(2)",IsCollsElms,[IsGF2VectorRep and IsRowVector,IsFFE and IsZero],0,POSITION_NONZERO_GF2VEC);
InstallMethod(PositionNot,"for GF(2) vector and 0*Z(2) and 0",IsCollsElmsX,[IsGF2VectorRep and IsRowVector,IsFFE and IsZero,IsZero and IsInt],0,COM_FUN(42));
InstallMethod(Append,"for GF2 vectors",true,[IsGF2VectorRep and IsMutable and IsList,IsGF2VectorRep and IsList],0,APPEND_GF2VEC);
InstallMethod(PositionCanonical,"for internally represented lists, fall back on `Position'",true,[IsList and IsGF2MatrixRep,IsObject],0,COM_FUN(43));
InstallMethod(ShallowCopy,"for GF2 vectors",true,[IsGF2VectorRep and IsList and IsRowVector],0,SHALLOWCOPY_GF2VEC);
InstallMethod(PositionNonZero,"for GF(2) vector",true,[IsGF2VectorRep and IsRowVector],0,COM_FUN(44));
InstallMethod(PositionNonZero,"General method for a row vector",true,[IsRowVector],0,COM_FUN(45));
InstallMethod(NumberFFVector,"GF2-Vector",true,[IsGF2VectorRep and IsRowVector and IsFFECollection,IsPosInt],0,COM_FUN(46));
InstallMethod(NumberFFVector,"uncompressed vecffe",[IsRowVector and IsFFECollection,IsPosInt],COM_FUN(47));
InstallMethod(IsSubset,"field, 8bit-vector",IsIdenticalObj,[IsField and IsFinite and IsFFECollection,IsGF2VectorRep and IsRowVector and IsFFECollection],0,COM_FUN(48));
InstallMethod(DefaultFieldOfMatrix,"method for a matrix over GF(2)",true,[IsMatrix and IsFFECollColl and IsGF2MatrixRep],0,COM_FUN(49));
InstallOtherMethod(DegreeFFE,"for GF(2) vectors",true,[IsRowVector and IsFFECollection and IsGF2VectorRep],0,COM_FUN(50));
InstallMethod(LeftShiftRowVector,"gf2 vector",true,[IsMutable and IsRowVector and IsGF2VectorRep,IsPosInt],0,SHIFT_LEFT_GF2VEC);
InstallMethod(RightShiftRowVector,"gf2 vector, fill with zeros",IsCollsXElms,[IsMutable and IsRowVector and IsGF2VectorRep,IsPosInt,IsFFE and IsZero],0,SHIFT_RIGHT_GF2VEC);
InstallMethod(ShrinkRowVector,"GF2 vector",true,[IsMutable and IsRowVector and IsGF2VectorRep],0,COM_FUN(51));
InstallMethod(RemoveOuterCoeffs,"gf2vec and zero",IsCollsElms,[IsMutable and IsGF2VectorRep and IsRowVector,IsFFE and IsZero],0,COM_FUN(52));
InstallMethod(ProductCoeffs,"GF2 vectors, kernel method",IsFamXFamY,[IsGF2VectorRep and IsRowVector,IsInt,IsGF2VectorRep and IsRowVector,IsInt],0,PROD_COEFFS_GF2VEC);
InstallOtherMethod(ProductCoeffs,"Gf2 vectors, kernel method (2 arg)",IsIdenticalObj,[IsGF2VectorRep and IsRowVector,IsGF2VectorRep and IsRowVector],0,COM_FUN(53));
InstallMethod(ReduceCoeffs,"GF2 vectors, kernel method",IsFamXFamY,[IsGF2VectorRep and IsRowVector and IsMutable,IsInt,IsGF2VectorRep and IsRowVector,IsInt],0,REDUCE_COEFFS_GF2VEC);
InstallOtherMethod(ReduceCoeffs,"Gf2 vectors, kernel method (2 arg)",IsIdenticalObj,[IsGF2VectorRep and IsRowVector and IsMutable,IsGF2VectorRep and IsRowVector],0,COM_FUN(54));
InstallMethod(PowerModCoeffs,"for gf2vectors",IsFamXYFamZ,[IsGF2VectorRep and IsRowVector,IsInt,IsPosInt,IsGF2VectorRep and IsRowVector,IsInt],0,COM_FUN(55));
InstallMethod(DomainForAction,"FFE vector/matrix",IsElmsCollCollsX,[IsVector and IsFFECollection,IsList,IsFunction],0,COM_FUN(56));
BindGlobal("GF2_AHEAD_OF_8BIT_RANK",10);
InstallMethod(SemiEchelonMat,"shortcut method for GF2 matrices",true,[IsMatrix and IsGF2MatrixRep and IsFFECollColl],0,COM_FUN(57));
InstallMethod(SemiEchelonMatTransformation,"kernel method for plain lists of GF2 vectors",true,[IsMatrix and IsFFECollColl and IsGF2MatrixRep],0,COM_FUN(58));
InstallMethod(SemiEchelonMatDestructive,"kernel method for plain lists of GF2 vectors",true,[IsPlistRep and IsMatrix and IsMutable and IsFFECollColl],GF2_AHEAD_OF_8BIT_RANK,SEMIECHELON_LIST_GF2VECS);
InstallMethod(SemiEchelonMatTransformationDestructive,"kernel method for plain lists of GF2 vectors",true,[IsMatrix and IsPlistRep and IsFFECollColl and IsMutable],GF2_AHEAD_OF_8BIT_RANK,SEMIECHELON_LIST_GF2VECS_TRANSFORMATIONS);
InstallMethod(TriangulizeMat,"kernel method for plain list of GF2 vectors",true,[IsMatrix and IsPlistRep and IsFFECollColl and IsMutable],GF2_AHEAD_OF_8BIT_RANK,TRIANGULIZE_LIST_GF2VECS);
InstallMethod(TriangulizeMat,"for GF2 matrices",true,[IsMatrix and IsMutable and IsFFECollColl and IsGF2MatrixRep],0,COM_FUN(59));
InstallMethod(DeterminantMatDestructive,"kernel method for plain list of GF2 vectors",true,[IsMatrix and IsPlistRep and IsFFECollColl and IsMutable],GF2_AHEAD_OF_8BIT_RANK,DETERMINANT_LIST_GF2VECS);
InstallMethod(RankMatDestructive,"kernel method for plain list of GF2 vectors",true,[IsMatrix and IsPlistRep and IsFFECollColl and IsMutable],GF2_AHEAD_OF_8BIT_RANK,RANK_LIST_GF2VECS);
InstallMethod(NestingDepthM,[IsGF2MatrixRep],COM_FUN(60));
InstallMethod(NestingDepthA,[IsGF2MatrixRep],COM_FUN(61));
InstallMethod(NestingDepthM,[IsGF2VectorRep],COM_FUN(62));
InstallMethod(NestingDepthA,[IsGF2VectorRep],COM_FUN(63));
InstallMethod(PostMakeImmutable,[IsGF2MatrixRep],COM_FUN(64));
InstallMethod(ZeroVector,"for an int and a gf2 vector",[IsInt,IsGF2VectorRep],COM_FUN(65));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/vecmat.gi"

#F  file="lib/vec8bit.gi" crc=15822938
RANK_FILTER_LIST  := [ 60825301, 15, 60825301, 15, 7665940, 19, 60825302, 17, 
  7665940, 19, 1, 0, 60825302, 17, 7665940, 19, 36044411, 15, 36044411, 15, 
  36044411, 15, 58786169, 23, 58786169, 23, 13173338, 20, 58786169, 23, 
  58786169, 23, 13173338, 20, 36044411, 15, 60825301, 15, 7665940, 19, 
  58785704, 39, 60825301, 15, 16793601, 15, 60825301, 15, 33, 37, 58786169, 
  23, 319, 17, 29640323, 31, 8081033, 40, 257, 15, 8800190, 28, 319, 17, 
  58786169, 23, 257, 15, 8800190, 28, 58786169, 23, 58786169, 23, 13173338, 
  20, 58786169, 23, 58786169, 23, 13173338, 20, 58786169, 23, 58786169, 23, 
  58786169, 23, 58786169, 23, 58786169, 23, 58786169, 23, 58786169, 23, 
  58786169, 23, 58786169, 23, 56443961, 30, 56443961, 30, 13173338, 20, 
  58786169, 23, 58786169, 23, 13173338, 20, 58786169, 23, 58786169, 23, 319, 
  17, 7665940, 19, 7665940, 19, 58786169, 23, 58786169, 23, 319, 17, 
  58786169, 23, 58786169, 23, 58786169, 23, 319, 17, 58786169, 23, 8005674, 
  17, 58786169, 23, 8005674, 17, 8005434, 20, 58786169, 23, 60825302, 17, 
  60825301, 15, 58785704, 39, 7665940, 19, 24802159, 278, 58785704, 39, 
  58786169, 23, 58786169, 23, 58786169, 23, 58786169, 23, 257, 15, 58786169, 
  23, 13173338, 20, 257, 15, 13173338, 20, 58786169, 23, 257, 15, 58786169, 
  23, 58786169, 23, 58786169, 23, 13173338, 20, 13173338, 20, 58786169, 23, 
  58786170, 25, 7665940, 19, 58786170, 25, 7665940, 19, 8005674, 17, 
  58786170, 25, 52927587, 29, 7665940, 19, 58786170, 25, 58786170, 25, 
  8005674, 17, 58786169, 23, 17, 18, 58786169, 23, 17, 18, 58786169, 23, 
  58786169, 23, 58786170, 25, 17, 18, 58786169, 23, 17, 18, 58786170, 25, 
  58786169, 23, 58786170, 25, 17, 18, 58786169, 23, 17, 18, 58786170, 25, 
  58786169, 23, 58786169, 23, 17, 18, 7665940, 19, 58786169, 23, 17, 18, 17, 
  18, 60817109, 2 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/vec8bit.gi", 15822938 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/vec8bit.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/vec8bit.gi");
elif COM_RESULT = 3  then
Revision.vec8bit_gi:="@(#)$Id: vec8bit.gi,v 4.46.2.3 2006/08/22 10:35:54 gap Exp $";
InstallValue(TYPES_VEC8BIT,[[],[],[],[]]);
TYPES_VEC8BIT[1][257]:=1;
TYPES_VEC8BIT[2][257]:=1;
TYPES_VEC8BIT[3][257]:=1;
TYPES_VEC8BIT[4][257]:=1;
InstallGlobalFunction(TYPE_VEC8BIT,COM_FUN(1));
InstallGlobalFunction(TYPE_VEC8BIT_LOCKED,COM_FUN(2));
InstallValue(TYPE_FIELDINFO_8BIT,NewType(NewFamily("FieldInfo8BitFamily",IsObject),IsObject and IsDataObjectRep));
InstallMethod(Length,"For a compressed VecFFE",true,[IsList and Is8BitVectorRep],0,LEN_VEC8BIT);
InstallMethod(\[\],"For a compressed VecFFE",true,[IsList and Is8BitVectorRep,IsPosInt],0,ELM_VEC8BIT);
InstallMethod(\[\]\:\=,"For a compressed VecFFE",true,[IsMutable and IsList and Is8BitVectorRep,IsPosInt,IsObject],0,ASS_VEC8BIT);
InstallMethod(Unbind\[\],"For a compressed VecFFE",true,[IsMutable and IsList and Is8BitVectorRep,IsPosInt],0,UNB_VEC8BIT);
InstallMethod(ViewObj,"For a compressed VecFFE",true,[Is8BitVectorRep and IsSmallList],0,COM_FUN(3));
InstallMethod(PrintObj,"For a compressed VecFFE",true,[Is8BitVectorRep and IsSmallList],0,COM_FUN(4));
InstallMethod(ShallowCopy,"For a compressed VecFFE",true,[Is8BitVectorRep and IsSmallList],0,SHALLOWCOPY_VEC8BIT);
InstallMethod(\+,"For two 8 bit vectors in same characteristic",IsIdenticalObj,[IsRowVector and Is8BitVectorRep,IsRowVector and Is8BitVectorRep],0,SUM_VEC8BIT_VEC8BIT);
InstallMethod(\+,"For a GF2 vector and an 8 bit vector of char 2",IsIdenticalObj,[IsRowVector and IsGF2VectorRep,IsRowVector and Is8BitVectorRep],0,COM_FUN(5));
InstallMethod(\+,"For an 8 bit vector of char 2 and a GF2 vector",IsIdenticalObj,[IsRowVector and Is8BitVectorRep,IsRowVector and IsGF2VectorRep],0,COM_FUN(6));
InstallMethod(PlainListCopyOp,"For an 8 bit vector",true,[IsSmallList and Is8BitVectorRep],0,COM_FUN(7));
InstallMethod(ELM0_LIST,"For an 8 bit vector",true,[IsList and Is8BitVectorRep,IsPosInt],0,ELM0_VEC8BIT);
BindGlobal("Q_TO_DEGREE",[0,1,1,2,1,0,1,3,2,0,1,0,1,0,0,4,1,0,1,0,0,0,1,0,2,0,3,0,1,0,1,5,0,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,2,0,0,0,1,0,0,0,0,0,1,0,1,0,0,6,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,0,4,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,2,0,0,0,3,0,1,7,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,2,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,5,0,0,0,0,0,0,0,1,0,0,0,0,8]);
InstallOtherMethod(DegreeFFE,"for 8 bit vectors",true,[IsRowVector and IsFFECollection and Is8BitVectorRep],0,COM_FUN(8));
InstallMethod(ELMS_LIST,"For an 8 bit vector and a plain list",true,[IsList and Is8BitVectorRep,IsPlistRep and IsDenseList],0,ELMS_VEC8BIT);
InstallMethod(ELMS_LIST,"For an 8 bit vector and a range",true,[IsList and Is8BitVectorRep,IsRange and IsInternalRep],0,ELMS_VEC8BIT_RANGE);
InstallMethod(\*,"For an 8 bit vector and an FFE",IsCollsElms,[IsRowVector and Is8BitVectorRep,IsFFE and IsInternalRep],0,PROD_VEC8BIT_FFE);
InstallMethod(\*,"For an 8 bit vector and a compatible matrix",IsElmsColls,[IsRowVector and Is8BitVectorRep and IsSmallList and IsRingElementList,IsRingElementTable and IsPlistRep],0,PROD_VEC8BIT_MATRIX);
InstallMethod(\*,"for FFE and GF2 vector",IsElmsColls,[IsFFE,IsRingElementList and IsRowVector and IsGF2VectorRep],0,COM_FUN(9));
InstallMethod(\*,"For an FFE and an 8 bit vector ",IsElmsColls,[IsFFE and IsInternalRep,IsRowVector and Is8BitVectorRep],0,PROD_FFE_VEC8BIT);
InstallMethod(\*,"for FFE and GF2 vector",IsElmsColls,[IsFFE,IsRingElementList and IsRowVector and IsGF2VectorRep],0,COM_FUN(10));
InstallMethod(\-,"For two 8bit vectors",IsIdenticalObj,[IsRowVector and Is8BitVectorRep,IsRowVector and Is8BitVectorRep],0,DIFF_VEC8BIT_VEC8BIT);
InstallMethod(\-,"For a GF2 vector and an 8 bit vector of char 2",IsIdenticalObj,[IsRowVector and IsGF2VectorRep,IsRowVector and Is8BitVectorRep],0,COM_FUN(11));
InstallMethod(\-,"For an 8 bit vector of char 2 and a GF2 vector",IsIdenticalObj,[IsRowVector and Is8BitVectorRep,IsRowVector and IsGF2VectorRep],0,COM_FUN(12));
InstallMethod(AdditiveInverseOp,"For an 8 bit vector",true,[IsRowVector and Is8BitVectorRep],0,AINV_VEC8BIT_MUTABLE);
InstallMethod(AdditiveInverseSameMutability,"For an 8 bit vector",true,[IsRowVector and Is8BitVectorRep],0,AINV_VEC8BIT_SAME_MUTABILITY);
InstallMethod(AdditiveInverseImmutable,"For an 8 bit vector",true,[IsRowVector and Is8BitVectorRep],0,AINV_VEC8BIT_IMMUTABLE);
InstallMethod(ZeroOp,"For an 8 bit vector",true,[IsRowVector and Is8BitVectorRep],0,ZERO_VEC8BIT);
InstallMethod(ZeroSameMutability,"For an 8 bit vector",true,[IsRowVector and Is8BitVectorRep],0,COM_FUN(13));
InstallMethod(\=,"For 2 8 bit vectors",IsIdenticalObj,[IsRowVector and Is8BitVectorRep,IsRowVector and Is8BitVectorRep],0,EQ_VEC8BIT_VEC8BIT);
InstallMethod(\<,"For 2 8 bit vectors",IsIdenticalObj,[IsRowVector and Is8BitVectorRep,IsRowVector and Is8BitVectorRep],0,LT_VEC8BIT_VEC8BIT);
InstallMethod(\*,"For 2 8 bit vectors",IsIdenticalObj,[IsRingElementList and Is8BitVectorRep,IsRingElementList and Is8BitVectorRep],0,PROD_VEC8BIT_VEC8BIT);
InstallMethod(\*,"For a GF2 vector and an 8 bit vector of char 2",IsIdenticalObj,[IsRowVector and IsGF2VectorRep,IsRowVector and Is8BitVectorRep],0,COM_FUN(14));
InstallMethod(\*,"For an 8 bit vector of char 2 and a GF2 vector",IsIdenticalObj,[IsRowVector and Is8BitVectorRep,IsRowVector and IsGF2VectorRep],0,COM_FUN(15));
InstallOtherMethod(AddRowVector,"For 2 8 bit vectors and a field element and f\
rom and to",IsCollsCollsElmsXX,[IsRowVector and Is8BitVectorRep,IsRowVector and Is8BitVectorRep,IsFFE and IsInternalRep,IsPosInt,IsPosInt],0,ADD_ROWVECTOR_VEC8BITS_5);
InstallOtherMethod(AddRowVector,"For 2 8 bit vectors and a field element",IsCollsCollsElms,[IsRowVector and Is8BitVectorRep,IsRowVector and Is8BitVectorRep,IsFFE and IsInternalRep],0,ADD_ROWVECTOR_VEC8BITS_3);
InstallOtherMethod(AddRowVector,"For 2 8 bit vectors",IsIdenticalObj,[IsRowVector and Is8BitVectorRep,IsRowVector and Is8BitVectorRep],0,ADD_ROWVECTOR_VEC8BITS_2);
InstallOtherMethod(MultRowVector,"For an 8 bit vector and an ffe",IsCollsElms,[IsRowVector and Is8BitVectorRep,IsFFE and IsInternalRep],0,MULT_ROWVECTOR_VEC8BITS);
InstallOtherMethod(PositionNot,"for 8-bit vector and 0*Z(p)",IsCollsElms,[Is8BitVectorRep and IsRowVector,IsFFE and IsZero],0,POSITION_NONZERO_VEC8BIT);
InstallMethod(PositionNot,"for 8-bit vector and 0*Z(p) and 0",IsCollsElmsX,[Is8BitVectorRep and IsRowVector,IsFFE and IsZero,IsZero and IsInt],0,COM_FUN(16));
InstallMethod(PositionNonZero,"for 8-bit vector",true,[Is8BitVectorRep and IsRowVector],0,COM_FUN(17));
InstallMethod(Append,"for 8bitm vectors",IsIdenticalObj,[Is8BitVectorRep and IsMutable and IsList,Is8BitVectorRep and IsList],0,APPEND_VEC8BIT);
InstallMethod(NumberFFVector,"8bit-vector",true,[Is8BitVectorRep and IsRowVector and IsFFECollection,IsPosInt],0,COM_FUN(18));
InstallMethod(IsSubset,"field, 8bit-vector",IsIdenticalObj,[IsField and IsFinite and IsFFECollection,Is8BitVectorRep and IsRowVector and IsFFECollection],0,COM_FUN(19));
InstallMethod(DistanceVecFFE,"8bit-vector",true,[Is8BitVectorRep and IsRowVector,Is8BitVectorRep and IsRowVector],0,DISTANCE_VEC8BIT_VEC8BIT);
InstallOtherMethod(AddCoeffs,"two 8 bit vectors",IsCollsCollsElms,[Is8BitVectorRep and IsRowVector,Is8BitVectorRep and IsRowVector,IsFFE],0,ADD_COEFFS_VEC8BIT_3);
InstallOtherMethod(AddCoeffs,"8 bit vector and GF2 vector",IsCollsCollsElms,[Is8BitVectorRep and IsRowVector,IsGF2VectorRep and IsRowVector,IsFFE],0,COM_FUN(20));
InstallOtherMethod(AddCoeffs,"GF2 vector and 8 bit vector",IsCollsCollsElms,[IsGF2VectorRep and IsRowVector,Is8BitVectorRep and IsRowVector,IsFFE],0,COM_FUN(21));
InstallOtherMethod(AddCoeffs,"two 8 bit vectors",IsIdenticalObj,[Is8BitVectorRep and IsRowVector,Is8BitVectorRep and IsRowVector],0,ADD_COEFFS_VEC8BIT_2);
InstallOtherMethod(AddCoeffs,"8 bit vector and GF2 vector",IsIdenticalObj,[Is8BitVectorRep and IsRowVector,IsGF2VectorRep and IsRowVector],0,COM_FUN(22));
InstallOtherMethod(AddCoeffs,"GF2 vector and 8 bit vector",IsIdenticalObj,[IsGF2VectorRep and IsRowVector,Is8BitVectorRep and IsRowVector],0,COM_FUN(23));
InstallMethod(LeftShiftRowVector,"8bit vector",true,[IsMutable and IsRowVector and Is8BitVectorRep,IsPosInt],0,SHIFT_VEC8BIT_LEFT);
InstallMethod(RightShiftRowVector,"8bit vector, fill with zeros",IsCollsXElms,[IsMutable and IsRowVector and Is8BitVectorRep,IsPosInt,IsFFE and IsZero],0,SHIFT_VEC8BIT_RIGHT);
InstallMethod(ShrinkCoeffs,"8 bit vector",true,[IsMutable and IsRowVector and Is8BitVectorRep],0,COM_FUN(24));
InstallMethod(PadCoeffs,"8 bit vector",true,[IsMutable and IsRowVector and Is8BitVectorRep and IsAdditiveElementWithZeroC\
ollection,IsPosInt],0,COM_FUN(25));
InstallMethod(ShrinkRowVector,"8 bit vector",true,[IsMutable and IsRowVector and Is8BitVectorRep],0,COM_FUN(26));
InstallMethod(RemoveOuterCoeffs,"vec8bit and zero",IsCollsElms,[IsMutable and Is8BitVectorRep and IsRowVector,IsFFE and IsZero],0,COM_FUN(27));
InstallMethod(ProductCoeffs,"8 bit vectors, kernel method",IsFamXFamY,[Is8BitVectorRep and IsRowVector,IsInt,Is8BitVectorRep and IsRowVector,IsInt],0,PROD_COEFFS_VEC8BIT);
InstallOtherMethod(ProductCoeffs,"8 bit vectors, kernel method (2 arg)",IsIdenticalObj,[Is8BitVectorRep and IsRowVector,Is8BitVectorRep and IsRowVector],0,COM_FUN(28));
BindGlobal("ADJUST_FIELDS_VEC8BIT",COM_FUN(29));
InstallMethod(ReduceCoeffs,"8 bit vectors, kernel method",IsFamXFamY,[Is8BitVectorRep and IsRowVector and IsMutable,IsInt,Is8BitVectorRep and IsRowVector,IsInt],0,COM_FUN(30));
InstallOtherMethod(ReduceCoeffs,"8 bit vectors, kernel method (2 arg)",IsIdenticalObj,[Is8BitVectorRep and IsRowVector and IsMutable,Is8BitVectorRep and IsRowVector],0,COM_FUN(31));
InstallMethod(QuotRemCoeffs,"8 bit vectors, kernel method",IsFamXFamY,[Is8BitVectorRep and IsRowVector and IsMutable,IsInt,Is8BitVectorRep and IsRowVector,IsInt],0,COM_FUN(32));
InstallOtherMethod(QuotRemCoeffs,"8 bit vectors, kernel method (2 arg)",IsIdenticalObj,[Is8BitVectorRep and IsRowVector and IsMutable,Is8BitVectorRep and IsRowVector],0,COM_FUN(33));
IsFamXYFamZ:=COM_FUN(34);
InstallMethod(PowerModCoeffs,"for 8 bit vectors",IsFamXYFamZ,[Is8BitVectorRep and IsRowVector,IsInt,IsPosInt,Is8BitVectorRep and IsRowVector,IsInt],0,COM_FUN(35));
InstallMethod(ZeroVector,"for an int and an 8bit vector",[IsInt,Is8BitVectorRep],COM_FUN(36));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/vec8bit.gi"

#F  file="lib/mat8bit.gi" crc=5646043
RANK_FILTER_LIST  := [ 54533530, 15, 54533530, 15, 7665940, 19, 54533531, 17, 
  7665940, 19, 1, 0, 54533531, 17, 7665940, 19, 29752640, 15, 29752640, 15, 
  29752640, 15, 54533530, 15, 1, 0, 45829154, 39, 45829154, 39, 45829154, 39, 
  45829154, 39, 29752640, 15, 54533530, 15, 7665940, 19, 54413021, 31, 
  45829154, 39, 45829154, 39, 54413021, 31, 45829154, 39, 45829154, 39, 257, 
  15, 45829154, 39, 45829154, 39, 257, 15, 51681604, 39, 51681604, 39, 
  51681604, 39, 51681604, 39, 51681604, 39, 51681604, 39, 33907028, 51, 
  33907028, 51, 33907028, 51, 33907028, 51, 33907028, 51, 19044698, 49, 
  19044698, 49, 19044698, 49, 19044698, 49, 19044698, 49, 19044698, 49, 
  19044698, 49, 19044698, 49, 19044698, 49, 48405457, 53, 48405457, 53, 
  48405457, 53, 19044699, 51, 48405457, 53, 48405457, 53, 54525338, 2, 
  54525338, 2, 60817109, 2, 60817109, 2, 54525338, 2 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/mat8bit.gi", 5646043 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/mat8bit.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/mat8bit.gi");
elif COM_RESULT = 3  then
Revision.mat8bit_gi:="@(#)$Id: mat8bit.gi,v 4.33 2002/07/02 09:52:23 sal Exp $";
InstallValue(TYPES_MAT8BIT,[[],[]]);
TYPES_MAT8BIT[1][257]:=1;
TYPES_MAT8BIT[2][257]:=1;
InstallGlobalFunction(TYPE_MAT8BIT,COM_FUN(1));
InstallMethod(Length,"For a compressed MatFFE",true,[IsList and Is8BitMatrixRep],0,COM_FUN(2));
InstallMethod(\[\],"For a compressed MatFFE",true,[IsList and Is8BitMatrixRep,IsPosInt],0,COM_FUN(3));
InstallMethod(\[\]\:\=,"For a compressed MatFE",true,[IsMutable and IsList and Is8BitMatrixRep,IsPosInt,IsObject],0,ASS_MAT8BIT);
InstallMethod(Unbind\[\],"For a compressed MatFFE",true,[IsMutable and IsList and Is8BitMatrixRep,IsPosInt],0,COM_FUN(4));
InstallMethod(ViewObj,"For a compressed MatFFE",true,[Is8BitMatrixRep and IsSmallList],0,COM_FUN(5));
InstallMethod(PrintObj,"For a compressed MatFFE",true,[Is8BitMatrixRep and IsSmallList],0,COM_FUN(6));
InstallMethod(ShallowCopy,"For a compressed MatFFE",true,[Is8BitMatrixRep and IsSmallList],0,COM_FUN(7));
InstallMethod(PositionCanonical,"for 8bit matrices lists, fall back on `Position'",true,[IsList and Is8BitMatrixRep,IsObject],0,COM_FUN(8));
InstallMethod(\+,"For two 8 bit matrices in same characteristic",IsIdenticalObj,[IsMatrix and Is8BitMatrixRep,IsMatrix and Is8BitMatrixRep],0,SUM_MAT8BIT_MAT8BIT);
InstallMethod(\-,"For two 8 bit matrices in same characteristic",IsIdenticalObj,[IsMatrix and Is8BitMatrixRep,IsMatrix and Is8BitMatrixRep],0,DIFF_MAT8BIT_MAT8BIT);
InstallMethod(PlainListCopyOp,"For an 8 bit vector",true,[IsSmallList and Is8BitMatrixRep],0,COM_FUN(9));
InstallMethod(ELM0_LIST,"For an 8 bit matrix",true,[IsList and Is8BitMatrixRep,IsPosInt],0,COM_FUN(10));
InstallGlobalFunction(ConvertToMatrixRepNC,COM_FUN(11));
InstallMethod(\*,"8 bit vector * 8 bit matrix",IsElmsColls,[Is8BitVectorRep and IsRowVector and IsRingElementList,Is8BitMatrixRep and IsMatrix],0,PROD_VEC8BIT_MAT8BIT);
InstallMethod(\*,"8 bit matrix * 8 bit vector",IsCollsElms,[Is8BitMatrixRep and IsMatrix,Is8BitVectorRep and IsRowVector and IsRingElementList],0,PROD_MAT8BIT_VEC8BIT);
InstallMethod(\*,"8 bit matrix * 8 bit matrix",IsIdenticalObj,[Is8BitMatrixRep and IsMatrix,Is8BitMatrixRep and IsMatrix],0,PROD_MAT8BIT_MAT8BIT);
InstallMethod(\*,"scalar * 8 bit matrix",IsElmsCollColls,[IsFFE,Is8BitMatrixRep and IsMatrix],0,COM_FUN(12));
InstallMethod(\*,"scalar * 8 bit matrix",IsCollCollsElms,[Is8BitMatrixRep and IsMatrix,IsFFE],0,COM_FUN(13));
InstallMethod(AdditiveInverseMutable,"8 bit matrix",true,[Is8BitMatrixRep and IsMatrix and IsAdditiveElementWithZero and IsSmallList],0,COM_FUN(14));
InstallMethod(AdditiveInverseImmutable,"8 bit matrix",true,[Is8BitMatrixRep and IsMatrix and IsAdditiveElementWithZero and IsSmallList],0,COM_FUN(15));
InstallMethod(AdditiveInverseSameMutability,"8 bit matrix",true,[Is8BitMatrixRep and IsMatrix and IsAdditiveElementWithZero and IsSmallList],0,COM_FUN(16));
InstallMethod(ZeroMutable,"8 bit matrix",true,[Is8BitMatrixRep and IsMatrix and IsAdditiveElementWithZero and IsSmallList],0,COM_FUN(17));
InstallMethod(ZeroImmutable,"8 bit matrix",true,[Is8BitMatrixRep and IsMatrix and IsAdditiveElementWithZero and IsSmallList],0,COM_FUN(18));
InstallMethod(ZeroSameMutability,"8 bit matrix",true,[Is8BitMatrixRep and IsMatrix and IsAdditiveElementWithZero and IsSmallList],0,COM_FUN(19));
InstallMethod(InverseOp,"8 bit matrix",true,[Is8BitMatrixRep and IsMatrix and IsMultiplicativeElementWithInverse and IsOrdinaryMatrix and IsSmallList and IsCommutativeElementCollColl and IsRingElementTable and IsFFECollColl],0,INV_MAT8BIT_MUTABLE);
InstallMethod(InverseSameMutability,"8 bit matrix",true,[Is8BitMatrixRep and IsMatrix and IsMultiplicativeElementWithInverse and IsOrdinaryMatrix and IsSmallList and IsCommutativeElementCollColl and IsRingElementTable and IsFFECollColl],0,INV_MAT8BIT_SAME_MUTABILITY);
InstallMethod(OneSameMutability,"8 bit matrix",true,[Is8BitMatrixRep and IsMatrix and IsMultiplicativeElementWithInverse and IsOrdinaryMatrix and IsSmallList and IsCommutativeElementCollColl and IsRingElementTable and IsFFECollColl],0,COM_FUN(20));
InstallMethod(OneMutable,"8 bit matrix",true,[Is8BitMatrixRep and IsMatrix and IsMultiplicativeElementWithInverse and IsOrdinaryMatrix and IsSmallList and IsCommutativeElementCollColl and IsRingElementTable and IsFFECollColl],0,COM_FUN(21));
InstallMethod(One,"8 bit matrix",true,[Is8BitMatrixRep and IsMatrix and IsMultiplicativeElementWithInverse and IsOrdinaryMatrix and IsSmallList and IsCommutativeElementCollColl and IsRingElementTable and IsFFECollColl],0,COM_FUN(22));
InstallGlobalFunction(RepresentationsOfMatrix,COM_FUN(23));
InstallMethod(DefaultFieldOfMatrix,"method for a compressed matrix over GF(q)",true,[IsMatrix and IsFFECollColl and Is8BitMatrixRep],0,COM_FUN(24));
InstallMethod(\<,"for two compressed 8 bit matrices",IsIdenticalObj,[IsMatrix and IsFFECollColl and Is8BitMatrixRep,IsMatrix and IsFFECollColl an\
d Is8BitMatrixRep],0,LT_MAT8BIT_MAT8BIT);
InstallMethod(\=,"for two compressed 8 bit matrices",IsIdenticalObj,[IsMatrix and IsFFECollColl and Is8BitMatrixRep,IsMatrix and IsFFECollColl an\
d Is8BitMatrixRep],0,EQ_MAT8BIT_MAT8BIT);
InstallMethod(TransposedMat,"for a compressed 8 bit matrix",true,[IsMatrix and IsFFECollColl and Is8BitMatrixRep],0,TRANSPOSED_MAT8BIT);
InstallMethod(MutableTransposedMat,"for a compressed 8 bit matrix",true,[IsMatrix and IsFFECollColl and Is8BitMatrixRep],0,TRANSPOSED_MAT8BIT);
InstallMethod(SemiEchelonMat,"shortcut method for 8bit matrices",true,[IsMatrix and Is8BitMatrixRep and IsFFECollColl],0,COM_FUN(25));
InstallMethod(SemiEchelonMatTransformation,"shortcut method for 8bit matrices",true,[IsMatrix and Is8BitMatrixRep and IsFFECollColl],0,COM_FUN(26));
InstallMethod(SemiEchelonMatDestructive,"kernel method for plain lists of 8bit\
 vectors",true,[IsPlistRep and IsMatrix and IsMutable and IsFFECollColl],0,SEMIECHELON_LIST_VEC8BITS);
InstallMethod(SemiEchelonMatTransformationDestructive," kernel method for plain lists of 8 bit vectors",true,[IsMatrix and IsFFECollColl and IsPlistRep and IsMutable],0,SEMIECHELON_LIST_VEC8BITS_TRANSFORMATIONS);
InstallMethod(TriangulizeMat,"kernel method for plain list of GF2 vectors",true,[IsMatrix and IsPlistRep and IsFFECollColl and IsMutable],0,TRIANGULIZE_LIST_VEC8BITS);
InstallMethod(TriangulizeMat,"method for compressed matrices",true,[IsMutable and IsMatrix and Is8BitMatrixRep and IsFFECollColl],0,COM_FUN(27));
InstallMethod(DeterminantMatDestructive,"kernel method for plain list of GF2 vectors",true,[IsMatrix and IsPlistRep and IsFFECollColl and IsMutable],0,DETERMINANT_LIST_VEC8BITS);
InstallMethod(RankMatDestructive,"kernel method for plain list of GF2 vectors",true,[IsMatrix and IsPlistRep and IsFFECollColl and IsMutable],0,RANK_LIST_VEC8BITS);
InstallMethod(NestingDepthM,[Is8BitMatrixRep],COM_FUN(28));
InstallMethod(NestingDepthA,[Is8BitMatrixRep],COM_FUN(29));
InstallMethod(NestingDepthM,[Is8BitVectorRep],COM_FUN(30));
InstallMethod(NestingDepthA,[Is8BitVectorRep],COM_FUN(31));
InstallMethod(PostMakeImmutable,[Is8BitMatrixRep],COM_FUN(32));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/mat8bit.gi"

#F  file="lib/meataxe.gi" crc=77948462
RANK_FILTER_LIST  := [  ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/meataxe.gi", 77948462 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/meataxe.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/meataxe.gi");
elif COM_RESULT = 3  then
Revision.meataxe_gi:="@(#)$Id: meataxe.gi,v 4.64.2.9 2006/11/14 16:25:02 gap Exp $";
InstallGlobalFunction(GModuleByMats,COM_FUN(1));
InstallGlobalFunction(TrivialGModule,COM_FUN(2));
InstallGlobalFunction(InducedGModule,COM_FUN(3));
InstallGlobalFunction(PermutationGModule,COM_FUN(4));
InstallGlobalFunction(TensorProductGModule,COM_FUN(5));
InstallGlobalFunction(WedgeGModule,COM_FUN(6));
SMTX.Setter:=COM_FUN(7);
SMTX.IsMTXModule:=COM_FUN(8);
SMTX.IsZeroGens:=COM_FUN(9);
SMTX.Dimension:=COM_FUN(10);
SMTX.Field:=COM_FUN(11);
SMTX.Generators:=COM_FUN(12);
SMTX.SetIsIrreducible:=COM_FUN(13);
SMTX.HasIsIrreducible:=COM_FUN(14);
SMTX.IsAbsolutelyIrreducible:=COM_FUN(15);
SMTX.SetIsAbsolutelyIrreducible:=COM_FUN(16);
SMTX.HasIsAbsolutelyIrreducible:=COM_FUN(17);
SMTX.SetSmashRecord:=SMTX.Setter("dummy");
SMTX.Subbasis:=SMTX.Getter("subbasis");
SMTX.SetSubbasis:=SMTX.Setter("subbasis");
SMTX.AlgEl:=SMTX.Getter("algebraElement");
SMTX.SetAlgEl:=SMTX.Setter("algebraElement");
SMTX.AlgElMat:=SMTX.Getter("algebraElementMatrix");
SMTX.SetAlgElMat:=SMTX.Setter("algebraElementMatrix");
SMTX.AlgElCharPol:=SMTX.Getter("characteristicPolynomial");
SMTX.SetAlgElCharPol:=SMTX.Setter("characteristicPolynomial");
SMTX.AlgElCharPolFac:=SMTX.Getter("charpolFactors");
SMTX.SetAlgElCharPolFac:=SMTX.Setter("charpolFactors");
SMTX.AlgElNullspaceVec:=SMTX.Getter("nullspaceVector");
SMTX.SetAlgElNullspaceVec:=SMTX.Setter("nullspaceVector");
SMTX.AlgElNullspaceDimension:=SMTX.Getter("ndimFlag");
SMTX.SetAlgElNullspaceDimension:=SMTX.Setter("ndimFlag");
SMTX.CentMat:=SMTX.Getter("centMat");
SMTX.SetCentMat:=SMTX.Setter("centMat");
SMTX.CentMatMinPoly:=SMTX.Getter("centMatMinPoly");
SMTX.SetCentMatMinPoly:=SMTX.Setter("centMatMinPoly");
SMTX.FGCentMat:=SMTX.Getter("fieldGenCentMat");
SMTX.SetFGCentMat:=SMTX.Setter("fieldGenCentMat");
SMTX.FGCentMatMinPoly:=SMTX.Getter("fieldGenCentMatMinPoly");
SMTX.SetFGCentMatMinPoly:=SMTX.Setter("fieldGenCentMatMinPoly");
SMTX.SetDegreeFieldExt:=SMTX.Setter("degreeFieldExt");
LinearCombinationVecs:=COM_FUN(18);
SMTX_OrthogonalVector:=COM_FUN(19);
SMTX.OrthogonalVector:=SMTX_OrthogonalVector;
SubGModLeadPos:=COM_FUN(20);
SMTX_SpinnedBasis:=COM_FUN(21);
SMTX.SpinnedBasis:=SMTX_SpinnedBasis;
SMTX_SubGModule:=COM_FUN(22);
SMTX.SubGModule:=SMTX_SubGModule;
SMTX.SubmoduleGModule:=SMTX_SubGModule;
SMTX_SubQuotActions:=COM_FUN(23);
SMTX.SubQuotActions:=SMTX_SubQuotActions;
SMTX.NormedBasisAndBaseChange:=COM_FUN(24);
SMTX.InducedActionSubmoduleNB:=COM_FUN(25);
SMTX.InducedActionSubmodule:=COM_FUN(26);
SMTX.ProperSubmoduleBasis:=COM_FUN(27);
SMTX.InducedActionFactorModule:=COM_FUN(28);
SMTX.InducedActionFactorModuleWithBasis:=COM_FUN(29);
SMTX.InducedAction:=COM_FUN(30);
SMTX.InducedActionSubMatrixNB:=COM_FUN(31);
SMTX.InducedActionSubMatrix:=COM_FUN(32);
SMTX.InducedActionFactorMatrix:=COM_FUN(33);
SMTX_SMCoRaEl:=COM_FUN(34);
SMTX.SMCoRaEl:=SMTX_SMCoRaEl;
SMTX.RAND_ELM_LIMIT:=500;
SMTX_IrreducibilityTest:=COM_FUN(35);
SMTX.IrreducibilityTest:=SMTX_IrreducibilityTest;
SMTX.IsIrreducible:=COM_FUN(36);
SMTX_RandomIrreducibleSubGModule:=COM_FUN(37);
SMTX.RandomIrreducibleSubGModule:=SMTX_RandomIrreducibleSubGModule;
SMTX_GoodElementGModule:=COM_FUN(38);
SMTX.GoodElementGModule:=SMTX_GoodElementGModule;
SMTX_FrobeniusAction:=COM_FUN(39);
SMTX.FrobeniusAction:=SMTX_FrobeniusAction;
SMTX_CompleteBasis:=COM_FUN(40);
SMTX.CompleteBasis:=SMTX_CompleteBasis;
SMTX_AbsoluteIrreducibilityTest:=COM_FUN(41);
SMTX.AbsoluteIrreducibilityTest:=SMTX_AbsoluteIrreducibilityTest;
SMTX.DegreeFieldExt:=COM_FUN(42);
SMTX.DegreeSplittingField:=COM_FUN(43);
SMTX.FieldGenCentMat:=COM_FUN(44);
SMTX_CollectedFactors:=COM_FUN(45);
SMTX.CollectedFactors:=SMTX_CollectedFactors;
SMTX.CompositionFactors:=COM_FUN(46);
SMTX_Distinguish:=COM_FUN(47);
SMTX.Distinguish:=SMTX_Distinguish;
SMTX_MinimalSubGModule:=COM_FUN(48);
SMTX.MinimalSubGModule:=SMTX_MinimalSubGModule;
SMTX_IsomorphismComp:=COM_FUN(49);
SMTX.IsomorphismComp:=SMTX_IsomorphismComp;
SMTX.Isomorphism:=COM_FUN(50);
SMTX.IsEquivalent:=COM_FUN(51);
SMTX_MatrixSum:=COM_FUN(52);
SMTX.MatrixSum:=SMTX_MatrixSum;
SMTX_Homomorphisms:=COM_FUN(53);
SMTX.Homomorphisms:=SMTX_Homomorphisms;
SMTX_SortHomGModule:=COM_FUN(54);
SMTX.SortHomGModule:=SMTX_SortHomGModule;
SMTX_Homomorphism:=COM_FUN(55);
SMTX.Homomorphism:=SMTX_Homomorphism;
SMTX_MinimalSubGModules:=COM_FUN(56);
SMTX.MinimalSubGModules:=SMTX_MinimalSubGModules;
SMTX_BasesCompositionSeries:=COM_FUN(57);
SMTX.BasesCompositionSeries:=SMTX_BasesCompositionSeries;
SMTX_BasesSubmodules:=COM_FUN(58);
SMTX.BasesSubmodules:=SMTX_BasesSubmodules;
SMTX_BasesMinimalSubmodules:=COM_FUN(59);
SMTX.BasesMinimalSubmodules:=SMTX_BasesMinimalSubmodules;
SMTX.DualModule:=COM_FUN(60);
InstallGlobalFunction(DualGModule,COM_FUN(61));
SMTX.DualizedBasis:=COM_FUN(62);
SMTX_BasesMaximalSubmodules:=COM_FUN(63);
SMTX.BasesMaximalSubmodules:=SMTX_BasesMaximalSubmodules;
SMTX_BasesMinimalSupermodules:=COM_FUN(64);
SMTX.BasesMinimalSupermodules:=SMTX_BasesMinimalSupermodules;
SMTX_BasisRadical:=COM_FUN(65);
SMTX.BasisRadical:=SMTX_BasisRadical;
SMTX_SpanOfMinimalSubGModules:=COM_FUN(66);
SMTX.SpanOfMinimalSubGModules:=SMTX_SpanOfMinimalSubGModules;
SMTX_BasisSocle:=COM_FUN(67);
SMTX.BasisSocle:=SMTX_BasisSocle;
SMTX_BasisRadical:=COM_FUN(68);
SMTX.BasisRadical:=SMTX_BasisRadical;
SMTX.funcs:=[SMTX_OrthogonalVector,SMTX_SpinnedBasis,SMTX_SubQuotActions,SMTX_SMCoRaEl,SMTX_IrreducibilityTest,SMTX_RandomIrreducibleSubGModule,SMTX_GoodElementGModule,SMTX_FrobeniusAction,SMTX_CompleteBasis,SMTX_AbsoluteIrreducibilityTest,SMTX_CollectedFactors,SMTX_Distinguish,SMTX_MinimalSubGModule,SMTX_IsomorphismComp,SMTX_MatrixSum,SMTX_Homomorphisms,SMTX_SortHomGModule,SMTX_MinimalSubGModules,SMTX_BasesCompositionSeries,SMTX_BasesSubmodules,SMTX_BasesMinimalSubmodules,SMTX_BasesMaximalSubmodules,SMTX_BasesMinimalSupermodules,SMTX_BasisSocle,SMTX_BasisRadical];
SMTX.SetBasisInOrbit:=COM_FUN(69);
SMTX_BasisInOrbit:=COM_FUN(70);
SMTX.BasisInOrbit:=SMTX_BasisInOrbit;
SMTX.SetInvariantBilinearForm:=COM_FUN(71);
SMTX_InvariantBilinearForm:=COM_FUN(72);
SMTX.InvariantBilinearForm:=SMTX_InvariantBilinearForm;
SMTX.MatrixUnderFieldAuto:=COM_FUN(73);
SMTX.TwistedDualModule:=COM_FUN(74);
SMTX.SetInvariantSesquilinearForm:=COM_FUN(75);
SMTX_InvariantSesquilinearForm:=COM_FUN(76);
SMTX.InvariantSesquilinearForm:=SMTX_InvariantSesquilinearForm;
SMTX.SetInvariantQuadraticForm:=COM_FUN(77);
SMTX_InvariantQuadraticForm:=COM_FUN(78);
SMTX.InvariantQuadraticForm:=SMTX_InvariantQuadraticForm;
SMTX.SetOrthogonalSign:=COM_FUN(79);
SMTX_OrthogonalSign:=COM_FUN(80);
SMTX.OrthogonalSign:=SMTX_OrthogonalSign;
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/meataxe.gi"

#F  file="lib/word.gi" crc=53813355
RANK_FILTER_LIST  := [ 51837910, 4, 51837910, 4, 51837910, 4, 51837910, 4, 
  6025000, 5, 6025000, 5, 6025000, 5, 6025000, 5, 12049999, 9, 8193, 2, 1, 0, 
  41942876, 3, 8193, 2, 6025000, 5, 6025000, 5, 48201913, 2, 17, 18, 
  48201913, 2, 8193, 2, 46780266, 7, 41085333, 6 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/word.gi", 53813355 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/word.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/word.gi");
elif COM_RESULT = 3  then
Revision.word_gi:="@(#)$Id: word.gi,v 4.30.4.1 2006/07/27 20:32:27 gap Exp $";
InstallMethod(\=,"for two words",IsIdenticalObj,[IsWord,IsWord],0,COM_FUN(1));
InstallMethod(\<,"nonassoc words",IsIdenticalObj,[IsWord,IsWord],0,COM_FUN(2));
InstallMethod(\*,"for two nonassoc. words",IsIdenticalObj,[IsNonassocWord,IsNonassocWord],0,COM_FUN(3));
InstallOtherMethod(Length,"for a nonassoc. word",true,[IsNonassocWord],0,COM_FUN(4));
InstallMethod(MappedWord,"for a nonassoc. word, a homogeneous list, and a list",IsElmsCollsX,[IsNonassocWord,IsNonassocWordCollection,IsList],0,COM_FUN(5));
InstallOtherMethod(MappedWord,"empty generators list",true,[IsObject,IsEmpty,IsList],0,COM_FUN(6));
DeclareRepresentation("IsBracketRep",IsPositionalObjectRep,[]);
InstallMethod(PrintObj,"for a nonassociative word",true,[IsNonassocWord],0,COM_FUN(7));
InstallMethod(String,"for a nonassociative word",true,[IsNonassocWord],0,COM_FUN(8));
InstallMethod(ObjByExtRep,"for a family of nonassociative words, and an integer",true,[IsNonassocWordFamily,IsInt],0,COM_FUN(9));
InstallMethod(ObjByExtRep,"for a family of nonassociative words, and a list",true,[IsNonassocWordFamily,IsList],0,COM_FUN(10));
InstallMethod(ExtRepOfObj,"for a nonassoc. word",true,[IsNonassocWord and IsBracketRep],0,COM_FUN(11));
InstallMethod(OneOp,"for a nonassoc. word-with-one",true,[IsNonassocWordWithOne],0,COM_FUN(12));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/word.gi"

#F  file="lib/wordass.gi" crc=264270
RANK_FILTER_LIST  := [ 47676329, 5, 47676329, 5, 56064997, 6, 56064997, 6, 
  47676329, 5, 47676329, 5, 56064997, 6, 7665940, 19, 54723937, 8, 17, 18, 
  54723937, 8, 56064997, 6, 56064997, 6, 7665940, 19, 17, 18, 47676329, 5, 
  7665940, 19, 17, 18, 47676329, 5, 47676329, 5, 56064997, 6, 47676329, 5, 
  7665940, 19, 47676329, 5, 7665940, 19, 7665940, 19, 47676329, 5, 47676329, 
  5, 47676329, 5, 7665940, 19, 47676329, 5, 47676329, 5, 47676329, 5, 
  47676329, 5, 56064997, 6, 8193, 2, 56064997, 6, 58592771, 10, 8193, 2 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/wordass.gi", 264270 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/wordass.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/wordass.gi");
elif COM_RESULT = 3  then
Revision.wordass_gi:="@(#)$Id: wordass.gi,v 4.31 2002/04/15 10:05:30 sal Exp $";
InstallGlobalFunction("AssignGeneratorVariables",COM_FUN(1));
InstallGlobalFunction(ERepAssWorProd,COM_FUN(2));
InstallGlobalFunction(ERepAssWorInv,COM_FUN(3));
InstallMethod(\<,"assoc words",IsIdenticalObj,[IsAssocWord,IsAssocWord],0,COM_FUN(4));
BindGlobal("AssocWord_Product",COM_FUN(5));
InstallMethod(\*,"for two assoc. words in syllable rep",IsIdenticalObj,[IsAssocWord and IsSyllableAssocWordRep,IsAssocWord and IsSyllableAssocWordRep],0,AssocWord_Product);
InstallMethod(\*,"for two assoc. words: force syllable rep",IsIdenticalObj,[IsAssocWord,IsAssocWord],0,COM_FUN(6));
InstallMethod(\^,"for an assoc. word in syllable rep, and a positive integer",true,[IsAssocWord and IsSyllableAssocWordRep,IsPosInt],0,COM_FUN(7));
BindGlobal("AssocWordWithInverse_Power",COM_FUN(8));
InstallMethod(\^,"for an assoc. word with inverse in syllable rep, and an integer",true,[IsAssocWordWithInverse and IsSyllableAssocWordRep,IsInt],0,AssocWordWithInverse_Power);
BindGlobal("AssocWordWithInverse_Inverse",COM_FUN(9));
InstallMethod(InverseOp,"for an assoc. word with inverse in syllable rep",true,[IsAssocWordWithInverse and IsSyllableAssocWordRep],0,AssocWordWithInverse_Inverse);
InstallOtherMethod(ReversedOp,"for an assoc. word in syllable rep",true,[IsAssocWord and IsSyllableAssocWordRep],0,COM_FUN(10));
InstallOtherMethod(Subword,"for syllable associative word and two positions",true,[IsAssocWord and IsSyllableAssocWordRep,IsPosInt,IsInt],0,COM_FUN(11));
InstallMethod(SubSyllables,"for associative word and two positions, using ext rep.",true,[IsAssocWord,IsPosInt,IsInt],0,COM_FUN(12));
InstallOtherMethod(PositionWord,"for two associative words,start at 1",IsIdenticalObj,[IsAssocWord,IsAssocWord],0,COM_FUN(13));
InstallMethod(PositionWord,"for two associative words and a positive integer, using syllables",IsFamFamX,[IsAssocWord and IsSyllableAssocWordRep,IsAssocWord,IsPosInt],0,COM_FUN(14));
InstallMethod(SubstitutedWord,"for assoc. word, two positive integers, and assoc. word",true,[IsAssocWord,IsPosInt,IsPosInt,IsAssocWord],0,COM_FUN(15));
InstallOtherMethod(SubstitutedWord,"for three associate words",true,[IsAssocWord,IsAssocWord,IsPosInt,IsAssocWord],0,COM_FUN(16));
InstallMethod(EliminatedWord,"for three associative words, using the external rep.",IsFamFamFam,[IsAssocWord,IsAssocWord,IsAssocWord],0,COM_FUN(17));
InstallMethod(RenumberedWord,"associative words in syllable rep",true,[IsAssocWord and IsSyllableAssocWordRep,IsList],0,COM_FUN(18));
BindGlobal("MappedWordSyllableAssocWord",COM_FUN(19));
InstallMethod(MappedWord,"for a syllable assoc. word, a homogeneous list, and a list",IsElmsCollsX,[IsAssocWord and IsSyllableAssocWordRep,IsAssocWordCollection,IsList],MappedWordSyllableAssocWord);
BindGlobal("LengthOfLongestCommonPrefixOfTwoAssocWords",COM_FUN(20));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/wordass.gi"

#F  file="lib/wordrep.gi" crc=-80941172
RANK_FILTER_LIST  := [ 47676329, 5, 47676329, 5, 57966383, 3, 32769, 4, 
  47676329, 5, 56064997, 6, 49840039, 4, 32769, 4, 33586391, 4, 32769, 4, 
  1081015, 4, 32769, 4, 3178182, 4, 32769, 4, 57966383, 3, 13061976, 15, 17, 
  18, 32769, 4, 55158600, 8, 55158600, 8, 55158600, 8, 55158600, 8, 55158600, 
  8, 55158600, 8, 55158600, 8, 18948473, 9, 38381024, 9, 24890838, 23, 
  53817540, 10, 9557088, 21, 55158600, 8, 1891165, 21, 55158600, 8, 7665940, 
  19, 55158600, 8, 17, 18, 55158600, 8, 55158600, 8, 55158600, 8, 17, 18, 17, 
  18, 55158600, 8, 16855427, 8, 16855427, 8, 16855427, 8, 16855427, 8, 
  16855427, 8, 16855427, 8, 16855427, 8, 47754179, 9, 77851, 9, 24890838, 23, 
  15514367, 10, 9557088, 21, 16855427, 8, 1891165, 21, 16855427, 8, 7665940, 
  19, 16855427, 8, 17, 18, 16855427, 8, 16855427, 8, 16855427, 8, 17, 18, 17, 
  18, 16855427, 8, 7357960, 8, 7357960, 8, 7357960, 8, 7357960, 8, 7357960, 
  8, 7357960, 8, 7357960, 8, 38256712, 9, 57689263, 9, 24890838, 23, 6016900, 
  10, 9557088, 21, 7357960, 8, 1891165, 21, 7357960, 8, 7665940, 19, 7357960, 
  8, 7665940, 19, 7357960, 8, 7357960, 8, 7357960, 8, 17, 18, 17, 18, 
  7357960, 8, 55472865, 8, 55472865, 8, 55472865, 8, 55472865, 8, 55472865, 
  8, 19262738, 9, 55472865, 8, 7665940, 19, 55472865, 8, 17, 18, 55472865, 8, 
  55472865, 8, 55472865, 8, 17, 18, 17, 18, 49840039, 4, 17, 18, 17, 18, 
  32769, 4, 33586391, 4, 17, 18, 17, 18, 32769, 4, 1081015, 4, 17, 18, 17, 
  18, 32769, 4, 3178182, 4, 13061976, 15, 17, 18, 32769, 4, 45522740, 4, 
  45522740, 4, 45522740, 4, 7665940, 19, 45522740, 4, 45522740, 4, 1, 0, 
  30666573, 21, 23928408, 4, 23928408, 4, 23928408, 4, 23928408, 4, 7665940, 
  19, 23928408, 4, 1, 0, 30666573, 21, 23928408, 4, 8387709, 6, 8193, 2, 
  8387709, 6, 58981576, 3, 32769, 4, 58981576, 3, 32769, 4, 32769, 4, 
  56064997, 6, 56064997, 6, 7665940, 19, 56064997, 6, 7665940, 19, 56064997, 
  6, 56064997, 6, 47676329, 5, 29419057, 21, 47676329, 5 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/wordrep.gi", -80941172 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/wordrep.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/wordrep.gi");
elif COM_RESULT = 3  then
Revision.wordrep_gi:="@(#)$Id: wordrep.gi,v 4.49 2002/04/15 10:05:30 sal Exp $";
DeclareRepresentation("Is8BitsAssocWord",IsSyllableAssocWordRep and IsDataObjectRep,[]);
DeclareRepresentation("Is16BitsAssocWord",IsSyllableAssocWordRep and IsDataObjectRep,[]);
DeclareRepresentation("Is32BitsAssocWord",IsSyllableAssocWordRep and IsDataObjectRep,[]);
DeclareRepresentation("IsInfBitsAssocWord",IsSyllableAssocWordRep and IsPositionalObjectRep,[]);
BindGlobal("InfBits_AssocWord",COM_FUN(1));
InstallMethod(PrintObj,"for an associative word",true,[IsAssocWord],0,COM_FUN(2));
InstallMethod(String,"for an associative word",true,[IsAssocWord],0,COM_FUN(3));
InstallGlobalFunction(AssocWord,COM_FUN(4));
BindGlobal("SyllableWordObjByExtRep",COM_FUN(5));
InstallMethod(ObjByExtRep,"for a family of associative words, and a homogeneous list",true,[IsAssocWordFamily and IsSyllableWordsFamily,IsHomogeneousList],0,SyllableWordObjByExtRep);
InstallMethod(SyllableRepAssocWord,"assoc word: via extrep",true,[IsAssocWord],0,COM_FUN(6));
InstallMethod(SyllableRepAssocWord,"assoc word in syllable rep",true,[IsAssocWord and IsSyllableAssocWordRep],0,COM_FUN(7));
InstallOtherMethod(ObjByExtRep,"for a 8Bits-family of associative words, and a homogeneous list",true,[IsAssocWordFamily and Is8BitsFamily,IsHomogeneousList],0,COM_FUN(8));
InstallOtherMethod(ObjByExtRep,"for a 16Bits-family of associative words, and a homogeneous list",true,[IsAssocWordFamily and Is16BitsFamily,IsHomogeneousList],0,COM_FUN(9));
InstallOtherMethod(ObjByExtRep,"for a 32Bits-family of associative words, and a homogeneous list",true,[IsAssocWordFamily and Is32BitsFamily,IsHomogeneousList],0,COM_FUN(10));
InstallOtherMethod(ObjByExtRep,"for a InfBits-family of associative words, and a homogeneous list",true,[IsAssocWordFamily and IsInfBitsFamily,IsHomogeneousList],0,COM_FUN(11));
InstallOtherMethod(ObjByExtRep,"for a fam. of assoc. words, a cyclotomic, an int., and a homog. list",true,[IsAssocWordFamily and IsSyllableWordsFamily,IsCyclotomic,IsInt,IsHomogeneousList],0,COM_FUN(12));
InstallMethod(ExtRepOfObj,"for an 8 bits assoc. word",true,[Is8BitsAssocWord],0,8Bits_ExtRepOfObj);
InstallMethod(\=,"for two 8 bits assoc. words",IsIdenticalObj,[Is8BitsAssocWord,Is8BitsAssocWord],0,8Bits_Equal);
InstallMethod(\<,"for two 8 bits assoc. words",IsIdenticalObj,[Is8BitsAssocWord,Is8BitsAssocWord],0,8Bits_Less);
InstallMethod(\*,"for two 8 bits assoc. words",IsIdenticalObj,[Is8BitsAssocWord,Is8BitsAssocWord],0,8Bits_Product);
InstallMethod(OneOp,"for an 8 bits assoc. word-with-one",true,[Is8BitsAssocWord and IsAssocWordWithOne],0,COM_FUN(13));
InstallMethod(\^,"for an 8 bits assoc. word, and zero (in small integer rep)",true,[Is8BitsAssocWord and IsMultiplicativeElementWithOne,IsZeroCyc and IsSmallIntRep],0,8Bits_Power);
InstallMethod(\^,"for an 8 bits assoc. word, and a small negative integer",true,[Is8BitsAssocWord and IsMultiplicativeElementWithInverse,IsInt and IsNegRat and IsSmallIntRep],0,8Bits_Power);
InstallMethod(\^,"for an 8 bits assoc. word, and a small positive integer",true,[Is8BitsAssocWord,IsPosInt and IsSmallIntRep],0,8Bits_Power);
InstallMethod(ExponentSyllable,"for an 8 bits assoc. word, and a pos. integer",true,[Is8BitsAssocWord,IsPosInt],0,8Bits_ExponentSyllable);
InstallMethod(GeneratorSyllable,"for an 8 bits assoc. word, and an integer",true,[Is8BitsAssocWord,IsInt],0,8Bits_GeneratorSyllable);
InstallMethod(NumberSyllables,"for an 8 bits assoc. word",true,[Is8BitsAssocWord],0,8Bits_NumberSyllables);
InstallMethod(ExponentSums,"for an 8 bits assoc. word",true,[Is8BitsAssocWord],0,8Bits_ExponentSums1);
InstallOtherMethod(ExponentSums,"for an 8 bits assoc. word, and two integers",true,[Is8BitsAssocWord,IsInt,IsInt],0,8Bits_ExponentSums3);
InstallOtherMethod(Length,"for an 8 bits assoc. word",true,[Is8BitsAssocWord],0,8Bits_LengthWord);
InstallMethod(ExtRepOfObj,"for a 16 bits assoc. word",true,[Is16BitsAssocWord],0,16Bits_ExtRepOfObj);
InstallMethod(\=,"for two 16 bits assoc. words",IsIdenticalObj,[Is16BitsAssocWord,Is16BitsAssocWord],0,16Bits_Equal);
InstallMethod(\<,"for two 16 bits assoc. words",IsIdenticalObj,[Is16BitsAssocWord,Is16BitsAssocWord],0,16Bits_Less);
InstallMethod(\*,"for two 16 bits assoc. words",IsIdenticalObj,[Is16BitsAssocWord,Is16BitsAssocWord],0,16Bits_Product);
InstallMethod(OneOp,"for a 16 bits assoc. word-with-one",true,[Is16BitsAssocWord and IsAssocWordWithOne],0,COM_FUN(14));
InstallMethod(\^,"for a 16 bits assoc. word, and zero (in small integer rep)",true,[Is16BitsAssocWord and IsMultiplicativeElementWithOne,IsZeroCyc and IsSmallIntRep],0,16Bits_Power);
InstallMethod(\^,"for a 16 bits assoc. word, and a small negative integer",true,[Is16BitsAssocWord and IsMultiplicativeElementWithInverse,IsInt and IsNegRat and IsSmallIntRep],0,16Bits_Power);
InstallMethod(\^,"for a 16 bits assoc. word, and a small positive integer",true,[Is16BitsAssocWord,IsPosInt and IsSmallIntRep],0,16Bits_Power);
InstallMethod(ExponentSyllable,"for a 16 bits assoc. word, and pos. integer",true,[Is16BitsAssocWord,IsPosInt],0,16Bits_ExponentSyllable);
InstallMethod(GeneratorSyllable,"for a 16 bits assoc. word, and integer",true,[Is16BitsAssocWord,IsInt],0,16Bits_GeneratorSyllable);
InstallMethod(NumberSyllables,"for a 16 bits assoc. word",true,[Is16BitsAssocWord],0,16Bits_NumberSyllables);
InstallMethod(ExponentSums,"for a 16 bits assoc. word",true,[Is16BitsAssocWord],0,16Bits_ExponentSums1);
InstallOtherMethod(ExponentSums,"for a 16 bits assoc. word, and two integers",true,[Is16BitsAssocWord,IsInt,IsInt],0,16Bits_ExponentSums3);
InstallOtherMethod(Length,"for a 16 bits assoc. word",true,[Is16BitsAssocWord],0,16Bits_LengthWord);
InstallMethod(ExtRepOfObj,"for a 32 bits assoc. word",true,[Is32BitsAssocWord],0,32Bits_ExtRepOfObj);
InstallMethod(\=,"for two 32 bits assoc. words",IsIdenticalObj,[Is32BitsAssocWord,Is32BitsAssocWord],0,32Bits_Equal);
InstallMethod(\<,"for two 32 bits assoc. words",IsIdenticalObj,[Is32BitsAssocWord,Is32BitsAssocWord],0,32Bits_Less);
InstallMethod(\*,"for two 32 bits assoc. words",IsIdenticalObj,[Is32BitsAssocWord,Is32BitsAssocWord],0,32Bits_Product);
InstallMethod(OneOp,"for a 32 bits assoc. word-with-one",true,[Is32BitsAssocWord and IsAssocWordWithOne],0,COM_FUN(15));
InstallMethod(\^,"for a 32 bits assoc. word, and zero (in small integer rep)",true,[Is32BitsAssocWord and IsMultiplicativeElementWithOne,IsZeroCyc and IsSmallIntRep],0,32Bits_Power);
InstallMethod(\^,"for a 32 bits assoc. word, and a small negative integer",true,[Is32BitsAssocWord and IsMultiplicativeElementWithInverse,IsInt and IsNegRat and IsSmallIntRep],0,32Bits_Power);
InstallMethod(\^,"for a 32 bits assoc. word, and a small positive integer",true,[Is32BitsAssocWord,IsPosInt and IsSmallIntRep],0,32Bits_Power);
InstallMethod(ExponentSyllable,"for a 32 bits assoc. word, and pos. integer",true,[Is32BitsAssocWord,IsPosInt],0,32Bits_ExponentSyllable);
InstallMethod(GeneratorSyllable,"for a 32 bits assoc. word, and pos. integer",true,[Is32BitsAssocWord,IsPosInt],0,32Bits_GeneratorSyllable);
InstallMethod(NumberSyllables,"for a 32 bits assoc. word",true,[Is32BitsAssocWord],0,32Bits_NumberSyllables);
InstallMethod(ExponentSums,"for a 32 bits assoc. word",true,[Is32BitsAssocWord],0,32Bits_ExponentSums1);
InstallOtherMethod(ExponentSums,"for a 32 bits assoc. word",true,[Is32BitsAssocWord,IsInt,IsInt],0,32Bits_ExponentSums3);
InstallOtherMethod(Length,"for a 32 bits assoc. word",true,[Is32BitsAssocWord],0,32Bits_LengthWord);
InfBits_ExtRepOfObj:=COM_FUN(16);
InstallMethod(ExtRepOfObj,"for a inf. bits assoc. word",true,[IsInfBitsAssocWord],0,InfBits_ExtRepOfObj);
InfBits_Equal:=COM_FUN(17);
InstallMethod(\=,"for two inf. bits assoc. words",IsIdenticalObj,[IsInfBitsAssocWord,IsInfBitsAssocWord],0,InfBits_Equal);
InfBits_Less:=COM_FUN(18);
InstallMethod(\<,"for two inf. bits assoc. words",IsIdenticalObj,[IsInfBitsAssocWord,IsInfBitsAssocWord],100,InfBits_Less);
InfBits_One:=COM_FUN(19);
InstallMethod(OneOp,"for an inf. bits assoc. word-with-one",true,[IsInfBitsAssocWord and IsAssocWordWithOne],0,InfBits_One);
InfBits_ExponentSyllable:=COM_FUN(20);
InstallMethod(ExponentSyllable,"for an inf. bits assoc. word, and a pos. integer",true,[IsInfBitsAssocWord,IsPosInt],0,InfBits_ExponentSyllable);
InfBits_GeneratorSyllable:=COM_FUN(21);
InstallMethod(GeneratorSyllable,"for an inf. bits assoc. word, and an integer",true,[IsInfBitsAssocWord,IsInt],0,InfBits_GeneratorSyllable);
InfBits_NumberSyllables:=COM_FUN(22);
InstallMethod(NumberSyllables,"for an inf. bits assoc. word",true,[IsInfBitsAssocWord],0,InfBits_NumberSyllables);
InfBits_ExponentSums1:=COM_FUN(23);
InstallMethod(ExponentSums,"for an inf. bits assoc. word",true,[IsInfBitsAssocWord],0,InfBits_ExponentSums1);
InfBits_ExponentSums3:=COM_FUN(24);
InstallOtherMethod(ExponentSums,"for an inf. bits assoc. word, and two integers",true,[IsInfBitsAssocWord,IsInt,IsInt],1,InfBits_ExponentSums3);
InstallGlobalFunction(ObjByVector,COM_FUN(25));
BindGlobal("InfBits_ObjByVector",COM_FUN(26));
InstallOtherMethod(ObjByExtRep,"for an 8 bits assoc. words family, two integers, and a list",true,[IsAssocWordFamily and Is8BitsFamily,IsInt,IsInt,IsHomogeneousList],0,COM_FUN(27));
InstallOtherMethod(ObjByExtRep,"for a 16 bits assoc. words family, two integers, and a list",true,[IsAssocWordFamily and Is16BitsFamily,IsInt,IsInt,IsHomogeneousList],0,COM_FUN(28));
InstallOtherMethod(ObjByExtRep,"for a 32 bits assoc. words family, two integers, and a list",true,[IsAssocWordFamily and Is32BitsFamily,IsInt,IsInt,IsHomogeneousList],0,COM_FUN(29));
InstallOtherMethod(ObjByExtRep,"for an inf. bits assoc. words family, two integers, and a list",true,[IsAssocWordFamily and IsInfBitsFamily,IsCyclotomic,IsInt,IsHomogeneousList],0,COM_FUN(30));
InstallGlobalFunction(StoreInfoFreeMagma,COM_FUN(31));
DeclareRepresentation("IsInfiniteListOfNamesRep",IsPositionalObjectRep,[1,2]);
InstallMethod(PrintObj,"for an infinite list of names",true,[IsList and IsInfiniteListOfNamesRep],0,COM_FUN(32));
InstallMethod(ViewObj,"for an infinite list of names",true,[IsList and IsInfiniteListOfNamesRep],0,COM_FUN(33));
InstallMethod(\[\],"for an infinite list of names",true,[IsList and IsInfiniteListOfNamesRep,IsPosInt],0,COM_FUN(34));
InstallMethod(Length,"for an infinite list of names",true,[IsList and IsInfiniteListOfNamesRep],0,COM_FUN(35));
InstallMethod(Position,"for an infinite list of names, an object, and zero",true,[IsList and IsInfiniteListOfNamesRep,IsObject,IsZeroCyc],0,COM_FUN(36));
InstallGlobalFunction(InfiniteListOfNames,COM_FUN(37));
DeclareRepresentation("IsInfiniteListOfGeneratorsRep",IsPositionalObjectRep,[1,2]);
InstallMethod(ViewObj,"for an infinite list of generators",true,[IsList and IsInfiniteListOfGeneratorsRep],0,COM_FUN(38));
InstallMethod(PrintObj,"for an infinite list of generators",true,[IsList and IsInfiniteListOfGeneratorsRep],0,COM_FUN(39));
InstallMethod(Length,"for an infinite list of generators",true,[IsList and IsInfiniteListOfGeneratorsRep],0,COM_FUN(40));
InstallMethod(\[\],"for an infinite list of generators",true,[IsList and IsInfiniteListOfGeneratorsRep,IsPosInt],0,COM_FUN(41));
InstallMethod(Position,"for an infinite list of generators, an object, and zero",true,[IsList and IsInfiniteListOfGeneratorsRep,IsObject,IsZeroCyc],0,COM_FUN(42));
InstallMethod(Random,"for an infinite list of generators",true,[IsList and IsInfiniteListOfGeneratorsRep],0,COM_FUN(43));
InstallGlobalFunction(InfiniteListOfGenerators,COM_FUN(44));
InstallOtherMethod(LetterRepAssocWord,"syllable rep, generators",true,[IsSyllableAssocWordRep,IsList],0,COM_FUN(45));
InstallMethod(LetterRepAssocWord,"syllable rep",true,[IsSyllableAssocWordRep],0,COM_FUN(46));
InstallMethod(AssocWordByLetterRep,"family, list: syllables",true,[IsSyllableWordsFamily,IsHomogeneousList],0,COM_FUN(47));
InstallOtherMethod(AssocWordByLetterRep,"family, list, gens: syllables",true,[IsSyllableWordsFamily,IsHomogeneousList,IsHomogeneousList],0,COM_FUN(48));
InstallOtherMethod(Length,"for an assoc. word in syllable rep",true,[IsAssocWord and IsSyllableAssocWordRep],0,COM_FUN(49));
InstallMethod(ExponentSyllable,"for an assoc. word in syllable rep, and a positive integer",true,[IsAssocWord and IsSyllableAssocWordRep,IsPosInt],0,COM_FUN(50));
InstallMethod(GeneratorSyllable,"for an assoc. word in syllable rep, and a positive integer",true,[IsAssocWord and IsSyllableAssocWordRep,IsPosInt],0,COM_FUN(51));
InstallMethod(NumberSyllables,"for an assoc. word in syllable rep",true,[IsAssocWord and IsSyllableAssocWordRep],0,COM_FUN(52));
InstallMethod(ExponentSumWord,"syllable rep as.word, gen",IsIdenticalObj,[IsAssocWord and IsSyllableAssocWordRep,IsAssocWord],0,COM_FUN(53));
InstallOtherMethod(ExponentSums,"for a group and an assoc. word in syllable rep",true,[IsGroup,IsAssocWord],0,COM_FUN(54));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/wordrep.gi"

#F  file="lib/wordlett.gi" crc=10344165
RANK_FILTER_LIST  := [ 51337224, 4, 32769, 4, 39481375, 4, 32769, 4, 
  67108850, 3, 32769, 4, 32769, 4, 67108385, 7, 33553713, 7, 16776377, 6, 
  32769, 4, 38466212, 3, 32769, 4, 38466212, 3, 17, 18, 17, 18, 32769, 4, 
  64452705, 6, 64452705, 6, 47675834, 7, 7665940, 19, 14121162, 7, 7665940, 
  19, 64452705, 6, 7665940, 19, 64452705, 6, 47676329, 5, 64452705, 6, 
  64452705, 6, 17, 18, 17, 18, 64452705, 6, 30898258, 8, 64452465, 8, 
  46334774, 9, 12780102, 9, 64452705, 6, 64452705, 6, 64452705, 6, 64452705, 
  6, 64452705, 6, 64452705, 6, 47675834, 7, 47675834, 7, 14121162, 7, 
  14121162, 7, 47675834, 7, 7665940, 19, 47675834, 7, 15332823, 19, 14121162, 
  7, 7665940, 19, 14121162, 7, 15332823, 19, 64452705, 6, 64452705, 6, 
  7665940, 19, 17, 18, 64452705, 6, 47676329, 5, 7665940, 19, 64452705, 6, 
  8193, 2, 64452705, 6, 58592771, 10, 8193, 2 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/wordlett.gi", 10344165 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/wordlett.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/wordlett.gi");
elif COM_RESULT = 3  then
Revision.wordlett_gi:="@(#)$Id: wordlett.gi,v 4.16 2002/12/18 13:54:24 gap Exp $";
LIB_CHAR_SINT:=COM_FUN(1);
LIB_SINT_CHAR:=COM_FUN(2);
LIB_SINTLIST_STRING:=COM_FUN(3);
LIB_STRING_SINTLIST:=COM_FUN(4);
SINTLIST_STRING:=COM_FUN(5);
InstallMethod(AssocWordByLetterRep,"W letter words family",true,[IsWLetterWordsFamily,IsHomogeneousList],0,COM_FUN(6));
InstallMethod(AssocWordByLetterRep,"B letter words family",true,[IsBLetterWordsFamily,IsHomogeneousList],0,COM_FUN(7));
InstallOtherMethod(AssocWordByLetterRep,"letter words family",true,[IsLetterWordsFamily,IsHomogeneousList,IsHomogeneousList],0,COM_FUN(8));
InstallMethod(LetterRepAssocWord,"W letter rep",true,[IsWLetterAssocWordRep],0,COM_FUN(9));
InstallMethod(LetterRepAssocWord,"B letter rep",true,[IsBLetterAssocWordRep],0,COM_FUN(10));
InstallOtherMethod(LetterRepAssocWord,"letter rep,gens",true,[IsLetterAssocWordRep,IsHomogeneousList],0,COM_FUN(11));
InstallMethod(ObjByExtRep,"letter rep family",true,[IsAssocWordFamily and IsLetterWordsFamily,IsHomogeneousList],0,COM_FUN(12));
InstallOtherMethod(ObjByExtRep,"letter rep family,integers (ignored)",true,[IsAssocWordFamily and IsLetterWordsFamily,IsInt,IsInt,IsHomogeneousList],0,COM_FUN(13));
LETTER_WORD_EREP_CACHE:=[1,1,1];
LETTER_WORD_EREP_CACHEVAL:=[1,1,1];
LETTER_WORD_EREP_CACHEPOS:=1;
BindGlobal("ERepLettWord",COM_FUN(14));
InstallMethod(ExtRepOfObj,"assoc word in letter rep",true,[IsAssocWord and IsLetterAssocWordRep],0,ERepLettWord);
InstallMethod(NumberSyllables,"assoc word in letter rep",true,[IsAssocWord and IsLetterAssocWordRep],0,COM_FUN(15));
InstallMethod(GeneratorSyllable,"assoc word in W letter rep",true,[IsAssocWord and IsWLetterAssocWordRep,IsPosInt],0,COM_FUN(16));
InstallMethod(GeneratorSyllable,"assoc word in B letter rep",true,[IsAssocWord and IsBLetterAssocWordRep,IsPosInt],0,COM_FUN(17));
InstallMethod(ExponentSyllable,"assoc word in letter rep",true,[IsAssocWord and IsLetterAssocWordRep,IsPosInt],0,COM_FUN(18));
InstallMethod(ExponentSumWord,"letter rep as.word, gen",IsIdenticalObj,[IsAssocWord and IsLetterAssocWordRep,IsAssocWord],0,COM_FUN(19));
InstallMethod(ExponentSums,"assoc word in letter rep",true,[IsAssocWord and IsLetterAssocWordRep],0,COM_FUN(20));
InstallOtherMethod(ExponentSums,"assoc word in letter rep,ints",true,[IsAssocWord and IsLetterAssocWordRep,IsInt,IsInt],0,COM_FUN(21));
InstallMethod(Length,"assoc word in letter rep",true,[IsAssocWord and IsLetterAssocWordRep],0,COM_FUN(22));
InstallMethod(OneOp,"assoc word in W letter rep",true,[IsAssocWord and IsWLetterAssocWordRep and IsMultiplicativeElementWithOne],0,COM_FUN(23));
InstallMethod(OneOp,"assoc word in B letter rep",true,[IsAssocWord and IsBLetterAssocWordRep and IsMultiplicativeElementWithOne],0,COM_FUN(24));
InstallMethod(InverseOp,"assoc word in W letter rep",true,[IsAssocWord and IsWLetterAssocWordRep and IsMultiplicativeElementWithInverse],0,COM_FUN(25));
InstallMethod(InverseOp,"assoc word in B letter rep",true,[IsAssocWord and IsBLetterAssocWordRep and IsMultiplicativeElementWithInverse],0,COM_FUN(26));
InstallMethod(PrintObj,"assoc word in letter rep",true,[IsAssocWord and IsLetterAssocWordRep],0,COM_FUN(27));
InstallMethod(LaTeXObj,"assoc word in letter rep",true,[IsAssocWord and IsLetterAssocWordRep],0,COM_FUN(28));
InstallMethod(\=,"assoc words in letter rep",IsIdenticalObj,[IsAssocWord and IsLetterAssocWordRep,IsAssocWord and IsLetterAssocWordRep],0,COM_FUN(29));
InstallMethod(\<,"assoc words in letter rep",IsIdenticalObj,[IsAssocWord and IsLetterAssocWordRep,IsAssocWord and IsLetterAssocWordRep],0,COM_FUN(30));
InstallMethod(\*,"assoc words in W letter rep",IsIdenticalObj,[IsAssocWord and IsWLetterAssocWordRep,IsAssocWord and IsWLetterAssocWordRep],0,COM_FUN(31));
MUL_BYT_LETTREP:=COM_FUN(32);
InstallMethod(\*,"assoc words in B letter rep",IsIdenticalObj,[IsAssocWord and IsBLetterAssocWordRep,IsAssocWord and IsBLetterAssocWordRep],0,COM_FUN(33));
AssocWWorLetRepPow:=COM_FUN(34);
InstallMethod(\^,"assoc word in W letter rep and positive integer",true,[IsAssocWord and IsWLetterAssocWordRep,IsPosInt],0,AssocWWorLetRepPow);
InstallMethod(\^,"assoc word in W letter rep and negative integer",true,[IsAssocWord and IsWLetterAssocWordRep,IsNegRat and IsInt],0,AssocWWorLetRepPow);
AssocBWorLetRepPow:=COM_FUN(35);
InstallMethod(\^,"assoc word in B letter rep and positive integer",true,[IsAssocWord and IsBLetterAssocWordRep,IsPosInt],0,AssocBWorLetRepPow);
InstallMethod(\^,"assoc word in B letter rep and negative integer",true,[IsAssocWord and IsBLetterAssocWordRep,IsNegRat and IsInt],0,AssocBWorLetRepPow);
InstallOtherMethod(ReversedOp,"for an assoc. word in letter rep",true,[IsAssocWord and IsLetterAssocWordRep],0,COM_FUN(36));
InstallOtherMethod(Subword,"for letter associative word and two positions",true,[IsAssocWord and IsLetterAssocWordRep,IsPosInt,IsInt],0,COM_FUN(37));
InstallMethod(PositionWord,"for two associative words and a positive integer, using letters",IsFamFamX,[IsAssocWord and IsLetterAssocWordRep,IsAssocWord,IsPosInt],0,COM_FUN(38));
InstallMethod(RenumberedWord,"associative words in letter rep",true,[IsAssocWord and IsLetterAssocWordRep,IsList],0,COM_FUN(39));
InstallMethod(MappedWord,"for a letter assoc. word, a homogeneous list, and a list",IsElmsCollsX,[IsAssocWord and IsLetterAssocWordRep,IsAssocWordCollection,IsList],COM_FUN(40));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/wordlett.gi"

#F  file="lib/mgmfree.gi" crc=-15721771
RANK_FILTER_LIST  := [ 27685846, 13, 27685846, 13, 27685846, 13, 27685846, 
  13, 27685846, 13, 48201913, 2, 52188868, 14, 16353513, 17, 33294669, 15, 
  7665940, 19, 45673994, 18, 7665940, 19 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/mgmfree.gi", -15721771 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/mgmfree.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/mgmfree.gi");
elif COM_RESULT = 3  then
Revision.mgmfree_gi:="@(#)$Id: mgmfree.gi,v 4.13 2003/03/10 08:47:31 gap Exp $";
InstallMethod(IsWholeFamily,"for a free magma",[IsMagma and IsNonassocWordCollection],COM_FUN(1));
InstallMethod(IsFinite,"for a magma of nonassoc. words",[IsMagma and IsNonassocWordCollection],IsTrivial);
InstallMethod(IsAssociative,"for a magma of nonassoc. words",[IsMagma and IsNonassocWordCollection],IsTrivial);
InstallMethod(Size,"for a free magma",[IsMagma and IsNonassocWordCollection],COM_FUN(2));
InstallMethod(Random,"for a free magma",[IsMagma and IsNonassocWordCollection],COM_FUN(3));
InstallMethod(MagmaGeneratorsOfFamily,"for a family of free magma elements",[IsNonassocWordFamily],COM_FUN(4));
InstallGlobalFunction(FreeMagma,COM_FUN(5));
InstallGlobalFunction(FreeMagmaWithOne,COM_FUN(6));
InstallMethod(ViewObj,"for a free magma containing the whole family",[IsMagma and IsWordCollection and IsWholeFamily],COM_FUN(7));
InstallMethod(ViewObj,"for a free magma-with-one containing the whole family",[IsMagmaWithOne and IsWordCollection and IsWholeFamily],COM_FUN(8));
InstallAccessToGenerators(IsMagma and IsWordCollection and IsWholeFamily,"free magma containing the whole family",GeneratorsOfMagma);
InstallAccessToGenerators(IsMagmaWithOne and IsWordCollection and IsWholeFamily,"free magma-with-one containing the whole family",GeneratorsOfMagmaWithOne);
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/mgmfree.gi"

#F  file="lib/smgrpfre.gi" crc=80804827
RANK_FILTER_LIST  := [ 3314917, 16, 58578852, 12, 3300998, 18, 3314917, 16, 
  61908647, 18, 3314917, 16, 66092727, 2, 3300998, 18 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/smgrpfre.gi", 80804827 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/smgrpfre.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/smgrpfre.gi");
elif COM_RESULT = 3  then
Revision.smgrpfre_gi:="@(#)$Id: smgrpfre.gi,v 4.42 2003/04/16 07:47:56 gap Exp $";
InstallMethod(IsWholeFamily,"for a free semigroup",[IsSemigroup and IsAssocWordCollection],COM_FUN(1));
BindGlobal("FreeSemigroup_NextWordExp",COM_FUN(2));
BindGlobal("NextIterator_FreeSemigroup",COM_FUN(3));
BindGlobal("ShallowCopy_FreeSemigroup",COM_FUN(4));
InstallMethod(Iterator,"for a free semigroup",[IsAssocWordCollection and IsWholeFamily],COM_FUN(5));
BindGlobal("ElementNumber_FreeMonoid",COM_FUN(6));
BindGlobal("ElementNumber_FreeSemigroup",COM_FUN(7));
BindGlobal("NumberElement_FreeMonoid",COM_FUN(8));
BindGlobal("NumberElement_FreeSemigroup",COM_FUN(9));
InstallMethod(Enumerator,"for a free semigroup",[IsAssocWordCollection and IsWholeFamily and IsSemigroup],COM_FUN(10));
InstallMethod(IsFinite,"for a semigroup of assoc. words",[IsSemigroup and IsAssocWordCollection],IsTrivial);
InstallMethod(Size,"for a free semigroup",[IsSemigroup and IsAssocWordWithOneCollection],COM_FUN(11));
InstallMethod(Random,"for a free semigroup",[IsSemigroup and IsAssocWordCollection],COM_FUN(12));
InstallMethod(MagmaGeneratorsOfFamily,"for a family of free semigroup elements",[IsAssocWordFamily],COM_FUN(13));
InstallGlobalFunction(FreeSemigroup,COM_FUN(14));
InstallMethod(ViewObj,"for a free semigroup containing the whole family",[IsSemigroup and IsAssocWordCollection and IsWholeFamily],COM_FUN(15));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/smgrpfre.gi"

#F  file="lib/monofree.gi" crc=-14527031
RANK_FILTER_LIST  := [ 26073292, 20, 50063703, 14, 26059373, 22, 26073292, 
  20, 26073292, 20, 65076574, 3, 65076574, 3, 34574522, 21 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/monofree.gi", -14527031 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/monofree.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/monofree.gi");
elif COM_RESULT = 3  then
Revision.monofree_gi:="@(#)$Id: monofree.gi,v 4.36 2003/04/16 07:47:56 gap Exp $";
InstallMethod(IsWholeFamily,"for a free monoid",[IsAssocWordWithOneCollection and IsMonoid],COM_FUN(1));
InstallMethod(Iterator,"for a free monoid",[IsAssocWordWithOneCollection and IsWholeFamily],COM_FUN(2));
InstallMethod(Enumerator,"for a free monoid",[IsAssocWordWithOneCollection and IsWholeFamily and IsMonoid],COM_FUN(3));
InstallMethod(Random,"for a free monoid",[IsMonoid and IsAssocWordWithOneCollection],COM_FUN(4));
InstallMethod(Size,"for a free monoid",[IsMonoid and IsAssocWordWithOneCollection],COM_FUN(5));
InstallOtherMethod(One,"for a family of free monoid elements",[IsAssocWordWithOneFamily],COM_FUN(6));
InstallMethod(MagmaGeneratorsOfFamily,"for a family of free monoid elements",[IsAssocWordWithOneFamily],COM_FUN(7));
InstallGlobalFunction(FreeMonoid,COM_FUN(8));
InstallMethod(ViewObj,"for a free monoid containing the whole family",[IsMonoid and IsAssocWordCollection and IsWholeFamily],COM_FUN(9));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/monofree.gi"

#F  file="lib/grpfree.gi" crc=-45769649
RANK_FILTER_LIST  := [ 33032445, 18, 62451501, 33, 62465420, 30, 62465420, 
  30, 62465420, 30, 63045228, 4, 32776187, 31, 32776187, 31, 32776187, 31, 
  46335269, 7, 63045228, 4, 46335269, 7, 62465420, 30, 24308270, 32, 7665940, 
  19 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grpfree.gi", -45769649 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grpfree.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grpfree.gi");
elif COM_RESULT = 3  then
Revision.grpfree_gi:="@(#)$Id: grpfree.gi,v 4.51 2003/04/16 07:47:56 gap Exp $";
BindGlobal("NextIterator_FreeGroup",COM_FUN(1));
BindGlobal("ShallowCopy_FreeGroup",COM_FUN(2));
InstallMethod(Iterator,"for a free group",[IsAssocWordWithInverseCollection and IsWholeFamily],COM_FUN(3));
BindGlobal("ElementNumber_FreeGroup",COM_FUN(4));
BindGlobal("NumberElement_FreeGroup",COM_FUN(5));
InstallMethod(Enumerator,"for enumerator of a free group",[IsAssocWordWithInverseCollection and IsWholeFamily and IsGroup],COM_FUN(6));
InstallMethod(IsWholeFamily,"for a free group",[IsAssocWordWithInverseCollection and IsGroup],COM_FUN(7));
InstallMethod(Random,"for a free group",[IsAssocWordWithInverseCollection and IsGroup],COM_FUN(8));
InstallMethod(Size,"for a free group",[IsAssocWordWithInverseCollection and IsGroup],COM_FUN(9));
InstallMethod(MagmaGeneratorsOfFamily,"for a family of assoc. words",[IsAssocWordWithInverseFamily],COM_FUN(10));
InstallGlobalFunction(FreeGroup,COM_FUN(11));
InstallMethod(FreeGeneratorsOfFpGroup,"for a free group",[IsSubgroupFpGroup and IsGroupOfFamily and IsFreeGroup],GeneratorsOfGroup);
InstallMethod(RelatorsOfFpGroup,"for a free group",[IsSubgroupFpGroup and IsGroupOfFamily and IsFreeGroup],COM_FUN(12));
InstallMethod(FreeGroupOfFpGroup,"for a free group",[IsSubgroupFpGroup and IsGroupOfFamily and IsFreeGroup],IdFunc);
InstallMethod(UnderlyingElement,"for an element of a free group",[IsElementOfFreeGroup],IdFunc);
InstallOtherMethod(ElementOfFpGroup,"for a family of free group elements, and an assoc. word",[IsElementOfFreeGroupFamily and IsAssocWordWithInverseFamily,IsAssocWordWithInverse],COM_FUN(13));
InstallMethod(ViewObj,"subgroup of free group",[IsFreeGroup],COM_FUN(14));
InstallAccessToGenerators(IsSubgroupFpGroup and IsGroupOfFamily and IsFreeGroup,"free group containing the whole family",GeneratorsOfMagmaWithInverses);
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grpfree.gi"

#F  file="lib/rws.gi" crc=-111236058
RANK_FILTER_LIST  := [ 49422182, 3, 32769, 4, 49422181, 2, 49422181, 2, 
  49422181, 2, 6999564, 10, 49422181, 2, 6999564, 10, 49422182, 3, 38508430, 
  4, 32412609, 5, 6999564, 10, 65767820, 5, 65767820, 5, 6999564, 10, 
  65767820, 5, 65767820, 5, 38508430, 4, 32412609, 5, 32412609, 5, 22038587, 
  8, 65767820, 5, 22038587, 8, 65767820, 5, 65767820, 5, 9021843, 6, 6999564, 
  10, 32505602, 3, 17, 18, 5767177, 4, 32505602, 3, 32505602, 3, 22038587, 8, 
  65767820, 5, 65767820, 5, 38508430, 4, 30505985, 3, 30505985, 3, 38508430, 
  4, 49422181, 2, 1, 0 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/rws.gi", -111236058 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/rws.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/rws.gi");
elif COM_RESULT = 3  then
Revision.rws_gi:="@(#)$Id: rws.gi,v 4.29 2002/04/15 10:05:15 sal Exp $";
InstallMethod(AddGenerators,true,[IsRewritingSystem and IsMutable,IsHomogeneousList],0,COM_FUN(1));
InstallMethod(NumberGeneratorsOfRws,true,[IsRewritingSystem],0,COM_FUN(2));
InstallMethod(UnderlyingFamily,true,[IsRewritingSystem],0,COM_FUN(3));
InstallMethod(ViewObj,true,[IsRewritingSystem],0,COM_FUN(4));
InstallMethod(ViewObj,true,[IsRewritingSystem and IsBuiltFromGroup],0,COM_FUN(5));
InstallMethod(PrintObj,true,[IsRewritingSystem],0,COM_FUN(6));
InstallMethod(PrintObj,true,[IsRewritingSystem and IsBuiltFromGroup],0,COM_FUN(7));
InstallMethod(ReduceRules,true,[IsRewritingSystem and IsMutable],0,COM_FUN(8));
IsIdenticalObjFamiliesRwsObj:=COM_FUN(9);
IsIdenticalObjFamiliesRwsObjObj:=COM_FUN(10);
IsIdenticalObjFamiliesRwsObjXXX:=COM_FUN(11);
InstallMethod(ReducedAdditiveInverse,"ReducedForm",IsIdenticalObjFamiliesRwsObj,[IsRewritingSystem and IsBuiltFromAdditiveMagmaWithInverses,IsAdditiveElementWithInverse],0,COM_FUN(12));
InstallMethod(ReducedComm,"ReducedLeftQuotient/ReducedProduct",IsIdenticalObjFamiliesRwsObjObj,[IsRewritingSystem and IsBuiltFromGroup,IsMultiplicativeElementWithInverse,IsMultiplicativeElementWithInverse],0,COM_FUN(13));
InstallMethod(ReducedConjugate,"ReducedLeftQuotient/ReducedProduct",IsIdenticalObjFamiliesRwsObjObj,[IsRewritingSystem and IsBuiltFromGroup,IsMultiplicativeElementWithInverse,IsMultiplicativeElementWithInverse],0,COM_FUN(14));
InstallMethod(ReducedDifference,"ReducedSum/ReducedAdditiveInverse",IsIdenticalObjFamiliesRwsObjObj,[IsRewritingSystem and IsBuiltFromAdditiveMagmaWithInverses,IsAdditiveElementWithInverse,IsAdditiveElementWithInverse],0,COM_FUN(15));
InstallMethod(ReducedInverse,"ReducedForm",IsIdenticalObjFamiliesRwsObj,[IsRewritingSystem and IsBuiltFromMagmaWithInverses,IsMultiplicativeElementWithInverse],0,COM_FUN(16));
InstallMethod(ReducedLeftQuotient,"ReducedProduct/ReducedInverse",IsIdenticalObjFamiliesRwsObjObj,[IsRewritingSystem and IsBuiltFromMagmaWithInverses,IsMultiplicativeElementWithInverse,IsMultiplicativeElementWithInverse],0,COM_FUN(17));
InstallMethod(ReducedOne,"ReducedForm",true,[IsRewritingSystem and IsBuiltFromMagmaWithOne],0,COM_FUN(18));
InstallMethod(ReducedPower,"ReducedProduct/ReducedInverse",IsIdenticalObjFamiliesRwsObjXXX,[IsRewritingSystem and IsBuiltFromGroup,IsMultiplicativeElement,IsInt],0,COM_FUN(19));
InstallMethod(ReducedProduct,"ReducedForm",IsIdenticalObjFamiliesRwsObjObj,[IsRewritingSystem and IsBuiltFromMagma,IsMultiplicativeElement,IsMultiplicativeElement],0,COM_FUN(20));
InstallMethod(ReducedQuotient,"ReducedProduct/ReducedInverse",IsIdenticalObjFamiliesRwsObjObj,[IsRewritingSystem and IsBuiltFromMagmaWithInverses,IsMultiplicativeElementWithInverse,IsMultiplicativeElementWithInverse],0,COM_FUN(21));
InstallMethod(ReducedSum,"ReducedForm",IsIdenticalObjFamiliesRwsObjObj,[IsRewritingSystem and IsBuiltFromAdditiveMagmaWithInverses,IsAdditiveElement,IsAdditiveElement],0,COM_FUN(22));
InstallMethod(ReducedOne,"ReducedForm",true,[IsRewritingSystem and IsBuiltFromAdditiveMagmaWithInverses],0,COM_FUN(23));
InstallMethod(IsReducedForm,"for a rewriting system and an object",true,[IsRewritingSystem,IsObject],COM_FUN(24));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/rws.gi"

#F  file="lib/rwspcclt.gi" crc=93081492
RANK_FILTER_LIST  := [ 44833821, 15, 44844981, 11, 44833821, 15, 8193, 2, 
  44844982, 12, 44844981, 11, 38573959, 12, 26033835, 12, 44844981, 11, 
  38573959, 12, 26033835, 12, 44844981, 11, 8193, 2, 65767820, 5, 44844981, 
  11, 8193, 2, 65767820, 5, 5582223, 12, 8193, 2, 65767820, 5, 44844981, 11, 
  65767820, 5, 44844981, 11, 65767820, 5, 17, 18, 44844982, 12, 65767820, 5, 
  65767820, 5, 65767820, 5, 38573960, 13, 65767820, 5, 65767820, 5, 65767820, 
  5, 38573960, 13, 17, 18, 17, 18, 65767820, 5, 38573960, 13, 17, 18, 17, 18, 
  1, 0, 44844982, 12, 65767820, 5, 65767820, 5, 65767820, 5, 44844982, 12, 
  65767820, 5, 65767820, 5, 65767820, 5, 26033836, 13, 17, 18, 17, 18, 
  65767820, 5, 26033836, 13, 17, 18, 17, 18, 65767820, 5, 44844982, 12, 
  65767820, 5, 65767820, 5, 44844982, 12, 65767820, 5, 65767820, 5, 44844982, 
  12, 65767820, 5, 17, 18, 44844982, 12, 65767820, 5, 17, 18, 44844981, 11, 
  32769, 4, 32769, 4, 7665940, 19, 7665940, 19, 7665940, 19, 44844981, 11, 
  32769, 4, 32769, 4, 7665940, 19, 7665940, 19, 7665940, 19, 44844981, 11, 
  32769, 4, 32769, 4, 7665940, 19, 7665940, 19, 7665940, 19, 44844981, 11, 
  32769, 4, 32769, 4, 7665940, 19, 7665940, 19 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/rwspcclt.gi", 93081492 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/rwspcclt.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/rwspcclt.gi");
elif COM_RESULT = 3  then
Revision.rwspcclt_gi:="@(#)$Id: rwspcclt.gi,v 4.32 2002/04/15 10:05:15 sal Exp $";
IsIdenticalObjFamiliesColObjObj:=COM_FUN(1);
IsIdenticalObjFamiliesColObjObjObj:=COM_FUN(2);
IsIdenticalObjFamiliesColXXXObj:=COM_FUN(3);
IsIdenticalObjFamiliesColXXXXXXObj:=COM_FUN(4);
FinitePolycyclicCollector_IsConfluent:=COM_FUN(5);
InstallMethod(IsConfluent,"method for finite polycylic rewriting systems",true,[IsPolycyclicCollector and IsFinite],0,COM_FUN(6));
InstallMethod(IsConfluent,"generic method for polycyclic rewriting systems",true,[IsPolycyclicCollector],0,COM_FUN(7));
InstallOtherMethod(IsConfluent,true,[IsPolycyclicCollector and IsFinite,IsList],0,FinitePolycyclicCollector_IsConfluent);
InstallMethod(OutdatePolycyclicCollector,true,[IsPolycyclicCollector and IsMutable],0,COM_FUN(8));
InstallMethod(ViewObj,true,[IsPolycyclicCollector],0,COM_FUN(9));
InstallMethod(ViewObj,true,[IsPowerConjugateCollector],0,COM_FUN(10));
InstallMethod(ViewObj,true,[IsPowerCommutatorCollector],0,COM_FUN(11));
InstallMethod(PrintObj,true,[IsPolycyclicCollector],0,COM_FUN(12));
InstallMethod(PrintObj,true,[IsPowerConjugateCollector],0,COM_FUN(13));
InstallMethod(PrintObj,true,[IsPowerCommutatorCollector],0,COM_FUN(14));
InstallMethod(CollectWord,IsIdenticalObjFamiliesColXXXObj,[IsPolycyclicCollector,IsList,IsMultiplicativeElementWithInverse],0,COM_FUN(15));
InstallMethod(CollectWordOrFail,IsIdenticalObjFamiliesColXXXObj,[IsPolycyclicCollector,IsList,IsMultiplicativeElementWithInverse],0,COM_FUN(16));
InstallMethod(CollectWordOrFail,IsIdenticalObjFamiliesColXXXObj,[IsPolycyclicCollector and IsUpToDatePolycyclicCollector,IsList,IsMultiplicativeElementWithInverse],0,COM_FUN(17));
InstallMethod(ReducedForm,"CollectWordOrFail",IsIdenticalObjFamiliesRwsObj,[IsPolycyclicCollector,IsMultiplicativeElementWithInverse],0,COM_FUN(18));
InstallMethod(ReducedPower,"ReducedInverse/CollectWordOrFail",IsIdenticalObjFamiliesRwsObjXXX,[IsPolycyclicCollector,IsMultiplicativeElementWithInverse,IsInt],0,COM_FUN(19));
InstallMethod(SetCommutator,"elements",IsIdenticalObjFamiliesColObjObjObj,[IsPolycyclicCollector and IsMutable,IsMultiplicativeElementWithInverse,IsMultiplicativeElementWithInverse,IsMultiplicativeElementWithInverse],0,COM_FUN(20));
InstallMethod(SetCommutatorNC,"elements",IsIdenticalObjFamiliesColObjObjObj,[IsPowerConjugateCollector and IsMutable,IsMultiplicativeElementWithInverse,IsMultiplicativeElementWithInverse,IsMultiplicativeElementWithInverse],0,COM_FUN(21));
InstallMethod(SetCommutatorNC,"integers",IsIdenticalObjFamiliesColXXXXXXObj,[IsPowerConjugateCollector and IsMutable,IsInt,IsInt,IsMultiplicativeElementWithInverse],0,COM_FUN(22));
InstallMethod(SetCommutator,"integers",IsIdenticalObjFamiliesColXXXXXXObj,[IsPowerConjugateCollector and IsMutable,IsInt,IsInt,IsObject],0,COM_FUN(23));
InstallMethod(SetConjugate,IsIdenticalObjFamiliesColObjObjObj,[IsPolycyclicCollector and IsMutable,IsMultiplicativeElementWithInverse,IsMultiplicativeElementWithInverse,IsMultiplicativeElementWithInverse],0,COM_FUN(24));
InstallMethod(SetConjugateNC,IsIdenticalObjFamiliesColObjObjObj,[IsPolycyclicCollector and IsMutable,IsMultiplicativeElementWithInverse,IsMultiplicativeElementWithInverse,IsMultiplicativeElementWithInverse],0,COM_FUN(25));
InstallMethod(SetConjugate,IsIdenticalObjFamiliesColXXXXXXObj,[IsPowerCommutatorCollector and IsMutable,IsInt,IsInt,IsMultiplicativeElementWithInverse],0,COM_FUN(26));
InstallMethod(SetConjugateNC,IsIdenticalObjFamiliesColXXXXXXObj,[IsPowerCommutatorCollector and IsMutable,IsInt,IsInt,IsMultiplicativeElementWithInverse],0,COM_FUN(27));
InstallMethod(SetPower,IsIdenticalObjFamiliesColObjObj,[IsPolycyclicCollector and IsMutable,IsMultiplicativeElementWithInverse,IsMultiplicativeElementWithInverse],0,COM_FUN(28));
InstallMethod(SetPowerNC,IsIdenticalObjFamiliesColObjObj,[IsPolycyclicCollector and IsMutable,IsMultiplicativeElementWithInverse,IsMultiplicativeElementWithInverse],0,COM_FUN(29));
InstallMethod(SetRelativeOrder,IsIdenticalObjFamiliesColObjObj,[IsPolycyclicCollector and IsMutable,IsMultiplicativeElementWithInverse,IsInt],0,COM_FUN(30));
InstallMethod(SetRelativeOrderNC,IsIdenticalObjFamiliesColObjObj,[IsPolycyclicCollector and IsMutable,IsMultiplicativeElementWithInverse,IsInt],0,COM_FUN(31));
InstallMethod(EvaluateOverlapCBA,"polyc. collector, 2 hom. lists, 3 pos. integers",true,[IsPolycyclicCollector,IsHomogeneousList,IsHomogeneousList,IsPosInt,IsPosInt,IsPosInt],0,COM_FUN(32));
InstallMethod(EvaluateOverlapBNA,"polyc. collector, 2 hom. lists, 3 pos. integers",true,[IsPolycyclicCollector,IsHomogeneousList,IsHomogeneousList,IsPosInt,IsPosInt,IsPosInt],0,COM_FUN(33));
InstallMethod(EvaluateOverlapBAN,"polyc. collector, 2 hom. lists, 3 pos. integers",true,[IsPolycyclicCollector,IsHomogeneousList,IsHomogeneousList,IsPosInt,IsPosInt,IsPosInt],0,COM_FUN(34));
InstallMethod(EvaluateOverlapANA,"polyc. collector, 2 hom. lists, 3 pos. integers",true,[IsPolycyclicCollector,IsHomogeneousList,IsHomogeneousList,IsPosInt,IsPosInt],0,COM_FUN(35));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/rwspcclt.gi"

#F  file="lib/rwspcsng.gi" crc=-123092339
RANK_FILTER_LIST  := [ 19294350, 18, 19294351, 19, 19294351, 19, 17, 18, 17, 
  18, 65767820, 5, 19294351, 19, 17, 18, 17, 18, 65767820, 5, 19294351, 19, 
  17, 18, 17, 18, 65767820, 5, 19294351, 19, 17, 18, 65767820, 5, 19294351, 
  19, 17, 18, 65767820, 5, 19294351, 19, 17, 18, 65767820, 5, 19294350, 18, 
  17, 18, 17, 18, 19294350, 18, 17, 18, 19294351, 19, 17, 18, 17, 18, 
  19294351, 19, 17, 18, 17, 18, 19294350, 18, 43885109, 31, 8193, 2, 
  43885109, 31, 17, 18, 8193, 2, 8193, 2, 8193, 2, 17, 18, 1985, 1, 8193, 2, 
  8193, 2, 19294350, 18, 19294350, 18, 19294350, 18, 19294350, 18, 47140471, 
  19, 8193, 2, 65767820, 5, 55121233, 21, 8193, 2, 55158600, 8, 16584335, 21, 
  8193, 2, 16855427, 8, 6620378, 21, 8193, 2, 7357960, 8, 19294350, 18, 
  19294350, 18, 19294350, 18, 8193, 2, 19294350, 18, 47140471, 19, 25901, 19, 
  27872022, 20, 28597882, 19, 56444003, 20, 18632965, 19, 46479086, 20, 
  19294350, 18, 47140471, 19, 25901, 19, 27872022, 20, 28597882, 19, 
  56444003, 20, 18632965, 19, 46479086, 20, 55121233, 21, 55158600, 8, 
  55158600, 8, 16584335, 21, 16855427, 8, 16855427, 8, 6620378, 21, 7357960, 
  8, 7357960, 8, 19294350, 18, 47676329, 5, 55121233, 21, 55158600, 8, 
  16584335, 21, 16855427, 8, 6620378, 21, 7357960, 8, 55121233, 21, 55158600, 
  8, 55158600, 8, 16584335, 21, 16855427, 8, 16855427, 8, 6620378, 21, 
  7357960, 8, 7357960, 8, 19294350, 18, 55121233, 21, 55158600, 8, 55158600, 
  8, 16584335, 21, 16855427, 8, 16855427, 8, 6620378, 21, 7357960, 8, 
  7357960, 8, 55121233, 21, 55158600, 8, 61333161, 20, 16584335, 21, 
  16855427, 8, 61333161, 20, 6620378, 21, 7357960, 8, 61333161, 20, 55121233, 
  21, 55158600, 8, 55158600, 8, 16584335, 21, 16855427, 8, 16855427, 8, 
  6620378, 21, 7357960, 8, 7357960, 8 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/rwspcsng.gi", -123092339 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/rwspcsng.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/rwspcsng.gi");
elif COM_RESULT = 3  then
Revision.rwspcsng_gi:="@(#)$Id: rwspcsng.gi,v 4.50 2002/05/04 13:45:53 gap Exp $";
DeclareRepresentation("IsSingleCollectorRep",IsPositionalObjectRep,[1..SCP_AVECTOR],IsPowerConjugateCollector and IsFinite);
DeclareRepresentation("Is8BitsSingleCollectorRep",IsSingleCollectorRep,[],IsPowerConjugateCollector and IsFinite);
DeclareRepresentation("Is16BitsSingleCollectorRep",IsSingleCollectorRep,[],IsPowerConjugateCollector and IsFinite);
DeclareRepresentation("Is32BitsSingleCollectorRep",IsSingleCollectorRep,[],IsPowerConjugateCollector and IsFinite);
DeclareFilter("IsDefaultRhsTypeSingleCollector");
SingleCollector_CollectWordRunning:=false;
SingleCollector_CollectWord:=COM_FUN(1);
SingleCollector_Solution:=COM_FUN(2);
InstallMethod(Rules,true,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep],0,COM_FUN(3));
InstallMethod(ReduceRules,true,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep and IsMutable],0,COM_FUN(4));
InstallMethod(SetConjugateANC,"pow conj single collector",IsIdenticalObjFamiliesColXXXXXXObj,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep and IsMutable,IsInt,IsInt,IsMultiplicativeElementWithInverse],0,COM_FUN(5));
SingleCollector_SetConjugateNC:=COM_FUN(6);
InstallMethod(SetConjugateNC,IsIdenticalObjFamiliesColXXXXXXObj,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep and IsMutable,IsInt,IsInt,IsMultiplicativeElementWithInverse],0,SingleCollector_SetConjugateNC);
InstallMethod(SetConjugate,IsIdenticalObjFamiliesColXXXXXXObj,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep and IsMutable,IsInt,IsInt,IsMultiplicativeElementWithInverse],0,COM_FUN(7));
InstallMethod(SetPowerANC,"pow conj single collector",IsIdenticalObjFamiliesColXXXObj,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep and IsMutable,IsInt,IsMultiplicativeElementWithInverse],0,COM_FUN(8));
SingleCollector_SetPowerNC:=COM_FUN(9);
InstallMethod(SetPowerNC,IsIdenticalObjFamiliesColXXXObj,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep and IsMutable,IsInt,IsMultiplicativeElementWithInverse],0,SingleCollector_SetPowerNC);
InstallMethod(SetPower,IsIdenticalObjFamiliesColXXXObj,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep and IsMutable,IsInt,IsMultiplicativeElementWithInverse],0,COM_FUN(10));
InstallMethod(GetConjugateNC,"finite pow-conj single collector",true,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep,IsInt,IsInt],0,COM_FUN(11));
InstallMethod(GetPowerNC,true,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep,IsInt],0,COM_FUN(12));
SingleCollector_SetRelativeOrderNC:=COM_FUN(13);
InstallMethod(SetRelativeOrderNC,true,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep and IsMutable,IsInt,IsInt],0,SingleCollector_SetRelativeOrderNC);
InstallMethod(SetRelativeOrder,true,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep and IsMutable,IsInt,IsInt],0,COM_FUN(14));
SingleCollector_MakeAvector:=COM_FUN(15);
SingleCollector_MakeInverses:=COM_FUN(16);
InstallMethod(UpdatePolycyclicCollector,true,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep],0,COM_FUN(17));
InstallMethod(SingleCollector,true,[IsFreeGroup and IsGroupOfFamily,IsList],0,COM_FUN(18));
InstallMethod(SingleCollector,true,[IsFreeGroup and IsGroupOfFamily,IsInt],0,COM_FUN(19));
InstallMethod(SingleCollector,true,[IsList,IsList],0,COM_FUN(20));
InstallMethod(SingleCollector,true,[IsList,IsInt],0,COM_FUN(21));
InstallMethod(SingleCollectorByGenerators,true,[IsFamily,IsList,IsList],0,COM_FUN(22));
InstallMethod(NumberGeneratorsOfRws,true,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep],0,COM_FUN(23));
InstallMethod(GeneratorsOfRws,true,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep],0,COM_FUN(24));
InstallMethod(UnderlyingFamily,true,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep],0,COM_FUN(25));
InstallMethod(RelativeOrders,true,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep],0,COM_FUN(26));
InstallMethod(CollectWordOrFail,IsIdenticalObjFamiliesColXXXObj,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep and IsUpToDatePolycyclicCollector,IsList,IsMultiplicativeElementWithInverse],0,SingleCollector_CollectWord);
InstallMethod(CollectWordOrFail,IsIdenticalObjFamiliesColXXXObj,[IsPowerConjugateCollector and IsFinite and Is8BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePo\
lycyclicCollector,IsList,Is8BitsAssocWord],0,FinPowConjCol_CollectWordOrFail);
InstallMethod(CollectWordOrFail,IsIdenticalObjFamiliesColXXXObj,[IsPowerConjugateCollector and IsFinite and Is16BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDateP\
olycyclicCollector,IsList,Is16BitsAssocWord],0,FinPowConjCol_CollectWordOrFail);
InstallMethod(CollectWordOrFail,IsIdenticalObjFamiliesColXXXObj,[IsPowerConjugateCollector and IsFinite and Is32BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePolycyclicCollector,IsList,Is32BitsAssocWord],0,FinPowConjCol_CollectWordOrFail);
ShallowCopy_SingleCollector:=COM_FUN(27);
InstallMethod(ShallowCopy,true,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep],0,ShallowCopy_SingleCollector);
InstallMethod(NonTrivialRightHandSides,true,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep],0,COM_FUN(28));
InstallMethod(ObjByExponents,true,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep,IsList],0,COM_FUN(29));
InstallMethod(ViewObj,true,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep],0,COM_FUN(30));
InstallMethod(ViewObj,true,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep and IsUpToDatePolycyclicCollector],0,COM_FUN(31));
InstallMethod(ViewObj,true,[IsPowerConjugateCollector and IsFinite and Is8BitsSingleCollectorRep],0,COM_FUN(32));
InstallMethod(ViewObj,true,[IsPowerConjugateCollector and IsFinite and Is8BitsSingleCollectorRep and IsUpToDatePolycyclicCollector],0,COM_FUN(33));
InstallMethod(ViewObj,true,[IsPowerConjugateCollector and IsFinite and Is16BitsSingleCollectorRep],0,COM_FUN(34));
InstallMethod(ViewObj,true,[IsPowerConjugateCollector and IsFinite and Is16BitsSingleCollectorRep and IsUpToDatePolycyclicCollector],0,COM_FUN(35));
InstallMethod(ViewObj,true,[IsPowerConjugateCollector and IsFinite and Is32BitsSingleCollectorRep],0,COM_FUN(36));
InstallMethod(ViewObj,true,[IsPowerConjugateCollector and IsFinite and Is32BitsSingleCollectorRep and IsUpToDatePolycyclicCollector],0,COM_FUN(37));
InstallMethod(PrintObj,true,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep],0,COM_FUN(38));
InstallMethod(PrintObj,true,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep and IsUpToDatePolycyclicCollector],0,COM_FUN(39));
InstallMethod(PrintObj,true,[IsPowerConjugateCollector and IsFinite and Is8BitsSingleCollectorRep],0,COM_FUN(40));
InstallMethod(PrintObj,true,[IsPowerConjugateCollector and IsFinite and Is8BitsSingleCollectorRep and IsUpToDatePolycyclicCollector],0,COM_FUN(41));
InstallMethod(PrintObj,true,[IsPowerConjugateCollector and IsFinite and Is16BitsSingleCollectorRep],0,COM_FUN(42));
InstallMethod(PrintObj,true,[IsPowerConjugateCollector and IsFinite and Is16BitsSingleCollectorRep and IsUpToDatePolycyclicCollector],0,COM_FUN(43));
InstallMethod(PrintObj,true,[IsPowerConjugateCollector and IsFinite and Is32BitsSingleCollectorRep],0,COM_FUN(44));
InstallMethod(PrintObj,true,[IsPowerConjugateCollector and IsFinite and Is32BitsSingleCollectorRep and IsUpToDatePolycyclicCollector],0,COM_FUN(45));
InstallMethod(ReducedComm,IsIdenticalObjFamiliesRwsObjObj,[IsPowerConjugateCollector and IsFinite and Is8BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePolycyclicCollector,Is8BitsAssocWord,Is8BitsAssocWord],0,FinPowConjCol_ReducedComm);
InstallMethod(ReducedComm,IsIdenticalObjFamiliesRwsObjObj,[IsPowerConjugateCollector and IsFinite and Is16BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePolycyclicCollector,Is16BitsAssocWord,Is16BitsAssocWord],0,FinPowConjCol_ReducedComm);
InstallMethod(ReducedComm,IsIdenticalObjFamiliesRwsObjObj,[IsPowerConjugateCollector and IsFinite and Is32BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePolycyclicCollector,Is32BitsAssocWord,Is32BitsAssocWord],0,FinPowConjCol_ReducedComm);
InstallMethod(ReducedInverse,IsIdenticalObjFamiliesRwsObj,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep,IsAssocWord],0,COM_FUN(46));
InstallMethod(ReducedForm,IsIdenticalObjFamiliesRwsObj,[IsPowerConjugateCollector and IsFinite and Is8BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePolycyclicCollector,Is8BitsAssocWord],0,FinPowConjCol_ReducedForm);
InstallMethod(ReducedForm,IsIdenticalObjFamiliesRwsObj,[IsPowerConjugateCollector and IsFinite and Is16BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePolycyclicCollector,Is16BitsAssocWord],0,FinPowConjCol_ReducedForm);
InstallMethod(ReducedForm,IsIdenticalObjFamiliesRwsObj,[IsPowerConjugateCollector and IsFinite and Is32BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePolycyclicCollector,Is32BitsAssocWord],0,FinPowConjCol_ReducedForm);
InstallMethod(ReducedLeftQuotient,IsIdenticalObjFamiliesRwsObjObj,[IsPowerConjugateCollector and IsFinite and Is8BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePolycyclicCollector,Is8BitsAssocWord,Is8BitsAssocWord],0,FinPowConjCol_ReducedLeftQuotient);
InstallMethod(ReducedLeftQuotient,IsIdenticalObjFamiliesRwsObjObj,[IsPowerConjugateCollector and IsFinite and Is16BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePolycyclicCollector,Is16BitsAssocWord,Is16BitsAssocWord],0,FinPowConjCol_ReducedLeftQuotient);
InstallMethod(ReducedLeftQuotient,IsIdenticalObjFamiliesRwsObjObj,[IsPowerConjugateCollector and IsFinite and Is32BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePolycyclicCollector,Is32BitsAssocWord,Is32BitsAssocWord],0,FinPowConjCol_ReducedLeftQuotient);
InstallMethod(ReducedOne,true,[IsPowerConjugateCollector and IsFinite and IsSingleCollectorRep],0,COM_FUN(47));
InstallMethod(ReducedProduct,IsIdenticalObjFamiliesRwsObjObj,[IsPowerConjugateCollector and IsFinite and Is8BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePolycyclicCollector,Is8BitsAssocWord,Is8BitsAssocWord],0,FinPowConjCol_ReducedProduct);
InstallMethod(ReducedProduct,IsIdenticalObjFamiliesRwsObjObj,[IsPowerConjugateCollector and IsFinite and Is16BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePolycyclicCollector,Is16BitsAssocWord,Is16BitsAssocWord],0,FinPowConjCol_ReducedProduct);
InstallMethod(ReducedProduct,IsIdenticalObjFamiliesRwsObjObj,[IsPowerConjugateCollector and IsFinite and Is32BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePolycyclicCollector,Is32BitsAssocWord,Is32BitsAssocWord],0,FinPowConjCol_ReducedProduct);
InstallMethod(ReducedPower,IsIdenticalObjFamiliesRwsObjXXX,[IsPowerConjugateCollector and IsFinite and Is8BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePolycyclicCollector,Is8BitsAssocWord,IsInt and IsSmallIntRep],0,FinPowConjCol_ReducedPowerSmallInt);
InstallMethod(ReducedPower,IsIdenticalObjFamiliesRwsObjXXX,[IsPowerConjugateCollector and IsFinite and Is16BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePolycyclicCollector,Is16BitsAssocWord,IsInt and IsSmallIntRep],0,FinPowConjCol_ReducedPowerSmallInt);
InstallMethod(ReducedPower,IsIdenticalObjFamiliesRwsObjXXX,[IsPowerConjugateCollector and IsFinite and Is32BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePolycyclicCollector,Is32BitsAssocWord,IsInt and IsSmallIntRep],0,FinPowConjCol_ReducedPowerSmallInt);
InstallMethod(ReducedQuotient,IsIdenticalObjFamiliesRwsObjObj,[IsPowerConjugateCollector and IsFinite and Is8BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePolycyclicCollector,Is8BitsAssocWord,Is8BitsAssocWord],0,FinPowConjCol_ReducedQuotient);
InstallMethod(ReducedQuotient,IsIdenticalObjFamiliesRwsObjObj,[IsPowerConjugateCollector and IsFinite and Is16BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePolycyclicCollector,Is16BitsAssocWord,Is16BitsAssocWord],0,FinPowConjCol_ReducedQuotient);
InstallMethod(ReducedQuotient,IsIdenticalObjFamiliesRwsObjObj,[IsPowerConjugateCollector and IsFinite and Is32BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePolycyclicCollector,Is32BitsAssocWord,Is32BitsAssocWord],0,FinPowConjCol_ReducedQuotient);
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/rwspcsng.gi"

#F  file="lib/rwspccoc.gi" crc=111810481
RANK_FILTER_LIST  := [ 25953303, 20, 17, 18, 17, 18, 65767820, 5, 25953303, 
  20, 17, 18, 65767820, 5, 25953302, 19, 43885109, 31, 8193, 2, 43885109, 31, 
  17, 18, 8193, 2, 8193, 2, 8193, 2, 17, 18, 1985, 1, 8193, 2, 8193, 2, 
  25953302, 19, 25953302, 19, 53799423, 20, 54525283, 20, 15262525, 21, 
  15988385, 20, 43834506, 21, 6023468, 20, 33869589, 21, 25953302, 19, 
  53799423, 20, 54525283, 20, 15262525, 21, 15988385, 20, 43834506, 21, 
  6023468, 20, 33869589, 21 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/rwspccoc.gi", 111810481 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/rwspccoc.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/rwspccoc.gi");
elif COM_RESULT = 3  then
Revision.rwspccoc_gi:="@(#)$Id: rwspccoc.gi,v 4.3.4.1 2005/12/03 16:28:29 gap Exp $";
DeclareRepresentation("IsCombinatorialCollectorRep",IsSingleCollectorRep,[1..SCP_CLASS],IsPowerConjugateCollector and IsFinite);
InstallMethod(SetConjugate,"combinatorial collector rep",IsIdenticalObjFamiliesColXXXXXXObj,[IsPowerConjugateCollector and IsFinite and IsCombinatorialCollectorRep and IsMutable,IsInt,IsInt,IsMultiplicativeElementWithInverse],0,COM_FUN(1));
InstallMethod(SetPower,"combinatorial collector rep",IsIdenticalObjFamiliesColXXXObj,[IsPowerConjugateCollector and IsFinite and IsCombinatorialCollectorRep and IsMutable,IsInt,IsMultiplicativeElementWithInverse],0,COM_FUN(2));
CombiCollector_MakeAvector2:=COM_FUN(3);
InstallMethod(UpdatePolycyclicCollector,"combinatorial collector rep",true,[IsPowerConjugateCollector and IsFinite and IsCombinatorialCollectorRep],0,COM_FUN(4));
InstallMethod(CombinatorialCollector,true,[IsFreeGroup and IsGroupOfFamily,IsList],0,COM_FUN(5));
InstallMethod(CombinatorialCollector,true,[IsFreeGroup and IsGroupOfFamily,IsInt],0,COM_FUN(6));
InstallMethod(CombinatorialCollector,true,[IsList,IsList],0,COM_FUN(7));
InstallMethod(CombinatorialCollector,true,[IsList,IsInt],0,COM_FUN(8));
InstallMethod(CombinatorialCollectorByGenerators,true,[IsFamily,IsList,IsList],0,COM_FUN(9));
InstallMethod(ShallowCopy,"combinatorial collector rep",true,[IsPowerConjugateCollector and IsFinite and IsCombinatorialCollectorRep],0,COM_FUN(10));
InstallMethod(ViewObj,"combinatorial collector rep",true,[IsPowerConjugateCollector and IsFinite and IsCombinatorialCollectorRep],0,COM_FUN(11));
InstallMethod(ViewObj,"combinatorial collector rep (up to date)",true,[IsPowerConjugateCollector and IsFinite and IsCombinatorialCollectorRep and IsUpToDatePolycyclicCollector],0,COM_FUN(12));
InstallMethod(ViewObj,"combinatorial collector rep (8 Bits)",true,[IsPowerConjugateCollector and IsFinite and Is8BitsSingleCollectorRep and IsCombinatorialCollectorRep],0,COM_FUN(13));
InstallMethod(ViewObj,"combinatorial collector rep (8 Bits, up to date)",true,[IsPowerConjugateCollector and IsFinite and Is8BitsSingleCollectorRep and IsCombinatorialCollectorRep and IsUpToDatePolycyclicCollector],0,COM_FUN(14));
InstallMethod(ViewObj,"combinatorial collector rep (16 Bits)",true,[IsPowerConjugateCollector and IsFinite and Is16BitsSingleCollectorRep and IsCombinatorialCollectorRep],0,COM_FUN(15));
InstallMethod(ViewObj,"combinatorial collector rep (16 Bits, up to date)",true,[IsPowerConjugateCollector and IsFinite and Is16BitsSingleCollectorRep and IsCombinatorialCollectorRep and IsUpToDatePolycyclicCollector],0,COM_FUN(16));
InstallMethod(ViewObj,"combinatorial collector rep (32 Bits)",true,[IsPowerConjugateCollector and IsFinite and Is32BitsSingleCollectorRep and IsCombinatorialCollectorRep],0,COM_FUN(17));
InstallMethod(ViewObj,"combinatorial collector rep (32 Bits, up to date)",true,[IsPowerConjugateCollector and IsFinite and Is32BitsSingleCollectorRep and IsCombinatorialCollectorRep and IsUpToDatePolycyclicCollector],0,COM_FUN(18));
InstallMethod(PrintObj,"combinatorial collector",true,[IsPowerConjugateCollector and IsFinite and IsCombinatorialCollectorRep],0,COM_FUN(19));
InstallMethod(PrintObj,"combinatorial collector (up to date)",true,[IsPowerConjugateCollector and IsFinite and IsCombinatorialCollectorRep and IsUpToDatePolycyclicCollector],0,COM_FUN(20));
InstallMethod(PrintObj,"combinatorial collector rep (8 Bits)",true,[IsPowerConjugateCollector and IsFinite and Is8BitsSingleCollectorRep and IsCombinatorialCollectorRep],0,COM_FUN(21));
InstallMethod(PrintObj,"combinatorial collector rep (8 Bits, up to date)",true,[IsPowerConjugateCollector and IsFinite and Is8BitsSingleCollectorRep and IsCombinatorialCollectorRep and IsUpToDatePolycyclicCollector],0,COM_FUN(22));
InstallMethod(PrintObj,"combinatorial collector rep (16 Bits)",true,[IsPowerConjugateCollector and IsFinite and Is16BitsSingleCollectorRep and IsCombinatorialCollectorRep],0,COM_FUN(23));
InstallMethod(PrintObj,"combinatorial collector rep (16 Bits, up to date)",true,[IsPowerConjugateCollector and IsFinite and Is16BitsSingleCollectorRep and IsCombinatorialCollectorRep and IsUpToDatePolycyclicCollector],0,COM_FUN(24));
InstallMethod(PrintObj,"combinatorial collector rep (32 Bits)",true,[IsPowerConjugateCollector and IsFinite and Is32BitsSingleCollectorRep and IsCombinatorialCollectorRep],0,COM_FUN(25));
InstallMethod(PrintObj,"combinatorial collector rep (32 Bits, up to date)",true,[IsPowerConjugateCollector and IsFinite and Is32BitsSingleCollectorRep and IsCombinatorialCollectorRep and IsUpToDatePolycyclicCollector],0,COM_FUN(26));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/rwspccoc.gi"

#F  file="lib/rwsgrp.gi" crc=17370671
RANK_FILTER_LIST  := [ 55692243, 2, 1, 0, 55692243, 2, 8193, 2, 45291414, 8, 
  45291414, 8, 44275606, 6, 44275606, 6, 44275606, 6, 44275606, 6, 44275606, 
  6, 44275606, 6, 44275606, 6, 44275606, 6, 44275606, 6, 44275606, 6, 
  44275606, 6, 44275606, 6, 44275606, 6, 44275606, 6, 17, 18, 44275606, 6, 
  44275606, 6, 44275606, 6, 44275606, 6, 6999564, 10, 6999564, 10, 6999564, 
  10 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/rwsgrp.gi", 17370671 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/rwsgrp.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/rwsgrp.gi");
elif COM_RESULT = 3  then
Revision.rwsgrp_gi:="@(#)$Id: rwsgrp.gi,v 4.30.4.1 2005/12/03 16:29:07 gap Exp $";
InstallMethod(ElementByRws,true,[IsElementsFamilyByRws,IsObject],0,COM_FUN(1));
InstallMethod(ElementByRws,true,[IsElementsFamilyByRws,IsList],0,COM_FUN(2));
InstallMethod(PrintObj,true,[IsMultiplicativeElementWithInverseByRws and IsPackedElementDefaultRep],0,COM_FUN(3));
InstallMethod(UnderlyingElement,true,[IsMultiplicativeElementWithInverseByRws and IsPackedElementDefaultRep],0,COM_FUN(4));
InstallMethod(ExtRepOfObj,true,[IsMultiplicativeElementWithInverseByRws],0,COM_FUN(5));
InstallMethod(Comm,"rws-element, rws-element",IsIdenticalObj,[IsMultiplicativeElementWithInverseByRws,IsMultiplicativeElementWithInverseByRws],0,COM_FUN(6));
InstallMethod(InverseOp,"rws-element",true,[IsMultiplicativeElementWithInverseByRws],0,COM_FUN(7));
InstallMethod(LeftQuotient,"rws-element, rws-element",IsIdenticalObj,[IsMultiplicativeElementWithInverseByRws,IsMultiplicativeElementWithInverseByRws],0,COM_FUN(8));
InstallMethod(OneOp,"rws-element",true,[IsMultiplicativeElementWithInverseByRws],0,COM_FUN(9));
InstallMethod(\/,"rws-element, rws-element",IsIdenticalObj,[IsMultiplicativeElementWithInverseByRws,IsMultiplicativeElementWithInverseByRws],0,COM_FUN(10));
InstallMethod(\*,"rws-element * rws-element",IsIdenticalObj,[IsMultiplicativeElementWithInverseByRws,IsMultiplicativeElementWithInverseByRws],0,COM_FUN(11));
InstallMethod(\^,"rws-element ^ rws-element",IsIdenticalObj,[IsMultiplicativeElementWithInverseByRws,IsMultiplicativeElementWithInverseByRws],0,COM_FUN(12));
InstallMethod(\^,"rws-element ^ int",IsIdenticalObj,[IsMultiplicativeElementWithInverseByRws,IsInt],0,COM_FUN(13));
InstallMethod(\=,IsIdenticalObj,[IsMultiplicativeElementWithInverseByRws,IsMultiplicativeElementWithInverseByRws],0,COM_FUN(14));
InstallMethod(\<,IsIdenticalObj,[IsMultiplicativeElementWithInverseByRws,IsMultiplicativeElementWithInverseByRws],0,COM_FUN(15));
InstallMethod(MultiplicativeElementsWithInversesFamilyByRws,true,[IsRewritingSystem and IsBuiltFromGroup],0,COM_FUN(16));
InstallMethod(GroupByRws,true,[IsRewritingSystem and IsBuiltFromGroup],0,COM_FUN(17));
InstallMethod(GroupByRwsNC,"rewriting system",true,[IsRewritingSystem and IsBuiltFromGroup],100,COM_FUN(18));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/rwsgrp.gi"

#F  file="lib/rwspcgrp.gi" crc=40946607
RANK_FILTER_LIST  := [ 66740907, 29, 44844981, 11, 60550331, 10, 60550331, 
  10, 60550331, 10, 60550331, 10, 60550331, 10, 60550331, 10, 60550331, 10, 
  60550331, 10, 60550331, 10, 60550331, 10, 60550331, 10, 60550331, 10, 
  60550331, 10, 60550331, 10, 61333161, 20, 61392255, 20, 30142165, 3, 
  55158600, 8, 16671852, 103, 16671852, 103, 30142165, 3, 8193, 2, 35332297, 
  111, 35332297, 111, 35332297, 111, 35332297, 111, 22855357, 20, 60284329, 
  3, 16855427, 8, 33343703, 103, 33343703, 103, 60284329, 3, 8193, 2, 
  52004148, 111, 52004148, 111, 52004148, 111, 52004148, 111, 12891400, 20, 
  53460738, 3, 7357960, 8, 66688365, 103, 66688365, 103, 53460738, 3, 8193, 
  2, 18239931, 111, 18239931, 111, 18239931, 111, 18239931, 111, 1985, 1, 
  8193, 2, 8193, 2, 1985, 1, 8193, 2, 8193, 2, 62465420, 30, 32769, 4, 
  62465420, 30, 32769, 4, 62465420, 30, 41951068, 17 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/rwspcgrp.gi", 40946607 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/rwspcgrp.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/rwspcgrp.gi");
elif COM_RESULT = 3  then
Revision.rwspcgrp_gi:="@(#)$Id: rwspcgrp.gi,v 4.46 2003/07/04 15:26:23 gap Exp $";
InstallOtherMethod(IsConfluent,"for pc group",true,[IsPcGroup],0,COM_FUN(1));
InstallMethod(MultiplicativeElementsWithInversesFamilyByRws,"generic method",true,[IsPolycyclicCollector],0,COM_FUN(2));
DeclareRepresentation("IsNBitsPcWordRep",IsDataObjectRep,[]);
InstallMethod(PrintObj,"pcword",true,[IsMultiplicativeElementWithInverseByPolycyclicCollector and IsNBitsPcWordRep],0,COM_FUN(3));
InstallMethod(String,"pcword",true,[IsMultiplicativeElementWithInverseByPolycyclicCollector and IsNBitsPcWordRep],\
0,COM_FUN(4));
InstallMethod(InverseOp,"generic method for n bits pc word rep",true,[IsMultiplicativeElementWithInverseByPolycyclicCollector and IsNBitsPcWordRep],0,COM_FUN(5));
InstallMethod(Comm,"generic method for n bits pc word rep",IsIdenticalObj,[IsMultiplicativeElementWithInverseByPolycyclicCollector and IsNBitsPcWordRep,IsMultiplicativeElementWithInverseByPolycyclicCollector and IsNBitsPcWordRep],0,NBitsPcWord_Comm);
InstallMethod(LeftQuotient,"generic method for n bits pc word rep",IsIdenticalObj,[IsMultiplicativeElementWithInverseByPolycyclicCollector and IsNBitsPcWordRep,IsMultiplicativeElementWithInverseByPolycyclicCollector and IsNBitsPcWordRep],0,NBitsPcWord_LeftQuotient);
InstallMethod(\/,"generic method for n bits pc word rep",IsIdenticalObj,[IsMultiplicativeElementWithInverseByPolycyclicCollector and IsNBitsPcWordRep,IsMultiplicativeElementWithInverseByPolycyclicCollector and IsNBitsPcWordRep],0,NBitsPcWord_Quotient);
InstallMethod(\*,"generic method for n bits pc word rep",IsIdenticalObj,[IsMultiplicativeElementWithInverseByPolycyclicCollector and IsNBitsPcWordRep,IsMultiplicativeElementWithInverseByPolycyclicCollector and IsNBitsPcWordRep],0,NBitsPcWord_Product);
InstallMethod(\^,"generic method for n bits pc word rep",IsIdenticalObj,[IsMultiplicativeElementWithInverseByPolycyclicCollector and IsNBitsPcWordRep,IsMultiplicativeElementWithInverseByPolycyclicCollector and IsNBitsPcWordRep],0,NBitsPcWord_Conjugate);
InstallMethod(\^,"generic method for n bits pc word rep and small int",true,[IsMultiplicativeElementWithInverseByPolycyclicCollector and IsNBitsPcWordRep,IsInt and IsSmallIntRep],0,NBitsPcWord_PowerSmallInt);
DeclareRepresentation("Is8BitsPcWordRep",IsNBitsPcWordRep and IsKernelPcWord,[]);
InstallMethod(MultiplicativeElementsWithInversesFamilyByRws,"8 bits family",true,[IsPolycyclicCollector and IsFinite and Is8BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePolycyclicCollector],0,COM_FUN(6));
InstallMethod(ElementByRws,"using 8Bits_AssocWord",true,[IsElementsFamilyBy8BitsSingleCollector,Is8BitsAssocWord],0,COM_FUN(7));
InstallMethod(UnderlyingElement,"using 8Bits_ExtRepOfObj",true,[Is8BitsPcWordRep],0,COM_FUN(8));
InstallMethod(ExtRepOfObj,"using 8Bits_ExtRepOfObj",true,[Is8BitsPcWordRep],0,8Bits_ExtRepOfObj);
InstallMethod(ObjByExtRep,"using 8Bits_AssocWord",true,[IsElementsFamilyBy8BitsSingleCollector,IsList],0,COM_FUN(9));
InstallMethod(\=,"for 8 bits pc word rep",IsIdenticalObj,[IsMultiplicativeElementWithInverseByPolycyclicCollector and Is8BitsPcWordRep,IsMultiplicativeElementWithInverseByPolycyclicCollector and Is8BitsPcWordRep],0,8Bits_Equal);
InstallMethod(\<,"method for 8 bits pc word rep",IsIdenticalObj,[IsMultiplicativeElementWithInverseByPolycyclicCollector and Is8BitsPcWordRep,IsMultiplicativeElementWithInverseByPolycyclicCollector and Is8BitsPcWordRep],0,8Bits_Less);
DeclareRepresentation("Is16BitsPcWordRep",IsNBitsPcWordRep and IsKernelPcWord,[]);
InstallMethod(MultiplicativeElementsWithInversesFamilyByRws,"16 bits family",true,[IsPolycyclicCollector and IsFinite and Is16BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePolycyclicCollector],0,COM_FUN(10));
InstallMethod(ElementByRws,"using 16Bits_AssocWord",true,[IsElementsFamilyBy16BitsSingleCollector,Is16BitsAssocWord],0,COM_FUN(11));
InstallMethod(UnderlyingElement,"using 16Bits_ExtRepOfObj",true,[Is16BitsPcWordRep],0,COM_FUN(12));
InstallMethod(ExtRepOfObj,"using 16Bits_ExtRepOfObj",true,[Is16BitsPcWordRep],0,16Bits_ExtRepOfObj);
InstallMethod(ObjByExtRep,"using 16Bits_AssocWord",true,[IsElementsFamilyBy16BitsSingleCollector,IsList],0,COM_FUN(13));
InstallMethod(\=,"for 16 bits pc word rep",IsIdenticalObj,[IsMultiplicativeElementWithInverseByPolycyclicCollector and Is16BitsPcWordRep,IsMultiplicativeElementWithInverseByPolycyclicCollector and Is16BitsPcWordRep],0,16Bits_Equal);
InstallMethod(\<,"for 16 bits pc word rep",IsIdenticalObj,[IsMultiplicativeElementWithInverseByPolycyclicCollector and Is16BitsPcWordRep,IsMultiplicativeElementWithInverseByPolycyclicCollector and Is16BitsPcWordRep],0,16Bits_Less);
DeclareRepresentation("Is32BitsPcWordRep",IsNBitsPcWordRep and IsKernelPcWord,[]);
InstallMethod(MultiplicativeElementsWithInversesFamilyByRws,"32 bits family",true,[IsPolycyclicCollector and IsFinite and Is32BitsSingleCollectorRep and IsDefaultRhsTypeSingleCollector and IsUpToDatePolycyclicCollector],0,COM_FUN(14));
InstallMethod(ElementByRws,"using 32Bits_AssocWord",true,[IsElementsFamilyBy32BitsSingleCollector,Is32BitsAssocWord],0,COM_FUN(15));
InstallMethod(UnderlyingElement,"using 16Bits_ExtRepOfObj",true,[Is32BitsPcWordRep],0,COM_FUN(16));
InstallMethod(ExtRepOfObj,"using 32Bits_ExtRepOfObj",true,[Is32BitsPcWordRep],0,32Bits_ExtRepOfObj);
InstallMethod(ObjByExtRep,"using 32Bits_AssocWord",true,[IsElementsFamilyBy32BitsSingleCollector,IsList],0,COM_FUN(17));
InstallMethod(\=,"for 32 bits pc word rep",IsIdenticalObj,[IsMultiplicativeElementWithInverseByPolycyclicCollector and Is32BitsPcWordRep,IsMultiplicativeElementWithInverseByPolycyclicCollector and Is32BitsPcWordRep],0,32Bits_Equal);
InstallMethod(\<,"for 32 bits pc word rep",IsIdenticalObj,[IsMultiplicativeElementWithInverseByPolycyclicCollector and Is32BitsPcWordRep,IsMultiplicativeElementWithInverseByPolycyclicCollector and Is32BitsPcWordRep],0,32Bits_Less);
SingleCollector_GroupRelators:=COM_FUN(18);
InstallGlobalFunction("SingleCollectorByRelators",COM_FUN(19));
InstallMethod(PolycyclicFactorGroupByRelatorsNC,"generic method for family, generators, relators",true,[IsFamily,IsList,IsList],0,COM_FUN(20));
InstallMethod(PolycyclicFactorGroupByRelators,"generic method for family, generators, relators",true,[IsFamily,IsList,IsList],0,COM_FUN(21));
InstallMethod(PolycyclicFactorGroup,"for free group, list using ' PolycyclicFactorGroupByRelators'",IsIdenticalObj,[IsFreeGroup,IsHomogeneousList],0,COM_FUN(22));
InstallMethod(PolycyclicFactorGroupNC,"for free group, list using ' PolycyclicFactorGroupByRelators'",IsIdenticalObj,[IsFreeGroup,IsHomogeneousList],0,COM_FUN(23));
InstallMethod(PolycyclicFactorGroup,"for free group, empty list using ' PolycyclicFactorGroupByRelators'",true,[IsFreeGroup,IsList and IsEmpty],0,COM_FUN(24));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/rwspcgrp.gi"

#F  file="lib/rwsdt.gi" crc=-114950986
RANK_FILTER_LIST  := [ 62451501, 33, 8193, 2, 62451501, 33, 17, 18, 1985, 1, 
  8193, 2, 8193, 2, 37733889, 14, 37733889, 14, 8193, 2, 37733890, 15, 17, 
  18, 1, 0, 37733889, 14, 37733889, 14, 17, 18, 37733889, 14, 37733889, 14, 
  8193, 2, 37733889, 14, 37733889, 14, 37733889, 14, 37733890, 15, 17, 18, 
  65767820, 5, 37733890, 15, 17, 18, 17, 18, 65767820, 5, 37733889, 14, 
  65580010, 15, 47676329, 5, 47676329, 5, 65580010, 15, 47676329, 5, 
  47676329, 5, 65580010, 15, 47676329, 5, 47676329, 5, 65580010, 15, 
  47676329, 5, 17, 18, 65580010, 15, 47676329, 5, 47676329, 5, 65580010, 15, 
  47676329, 5, 47676329, 5, 65580010, 15, 47676329, 5, 37733889, 14, 8193, 2, 
  65767820, 5, 37733889, 14, 8193, 2 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/rwsdt.gi", -114950986 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/rwsdt.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/rwsdt.gi");
elif COM_RESULT = 3  then
Revision.rwsdt_gi:="@(#)$Id: rwsdt.gi,v 4.12 2002/04/15 10:05:15 sal Exp $";
DeclareRepresentation("IsDeepThoughtCollectorRep",IsPositionalObjectRep,[1..PC_DEFAULT_TYPE],IsPowerConjugateCollector);
InstallMethod(DeepThoughtCollector,true,[IsFreeGroup and IsWholeFamily,IsList],0,COM_FUN(1));
InstallMethod(DeepThoughtCollector,true,[IsFreeGroup and IsWholeFamily,IsInt],0,COM_FUN(2));
InstallMethod(DeepThoughtCollectorByGenerators,true,[IsFamily,IsList,IsList],0,COM_FUN(3));
InstallMethod(Rules,"Deep Thought",true,[IsPowerConjugateCollector and IsDeepThoughtCollectorRep],0,COM_FUN(4));
InstallMethod(SetRelativeOrders,true,[IsDeepThoughtCollectorRep and IsPowerConjugateCollector,IsList],0,COM_FUN(5));
InstallMethod(SetRelativeOrder,true,[IsDeepThoughtCollectorRep and IsPowerConjugateCollector and IsMutable,IsInt,IsObject],0,COM_FUN(6));
InstallMethod(RelativeOrders,"Method for Deep Thought",true,[IsDeepThoughtCollectorRep and IsPowerConjugateCollector],0,COM_FUN(7));
InstallMethod(SetNumberGeneratorsOfRws,true,[IsDeepThoughtCollectorRep and IsPowerConjugateCollector,IsInt],0,COM_FUN(8));
InstallMethod(NumberGeneratorsOfRws,true,[IsDeepThoughtCollectorRep and IsPowerConjugateCollector],0,COM_FUN(9));
InstallMethod(SetGeneratorsOfRws,true,[IsDeepThoughtCollectorRep and IsPowerConjugateCollector,IsList],0,COM_FUN(10));
InstallMethod(GeneratorsOfRws,true,[IsDeepThoughtCollectorRep and IsPowerConjugateCollector],0,COM_FUN(11));
InstallMethod(ViewObj,true,[IsDeepThoughtCollectorRep and IsPowerConjugateCollector],0,COM_FUN(12));
InstallMethod(PrintObj,true,[IsDeepThoughtCollectorRep and IsPowerConjugateCollector],0,COM_FUN(13));
InstallMethod(SetPower,IsIdenticalObjFamiliesColXXXObj,[IsPowerConjugateCollector and IsDeepThoughtCollectorRep and IsMutable,IsInt,IsMultiplicativeElementWithInverse],0,COM_FUN(14));
DeepThoughtCollector_SetConjugateNC:=COM_FUN(15);
InstallMethod(SetConjugate,IsIdenticalObjFamiliesColXXXXXXObj,[IsPowerConjugateCollector and IsDeepThoughtCollectorRep and IsMutable,IsInt,IsInt,IsMultiplicativeElementWithInverse],0,COM_FUN(16));
InstallMethod(UpdatePolycyclicCollector,true,[IsPowerConjugateCollector and IsDeepThoughtCollectorRep],0,COM_FUN(17));
InstallMethod(ReducedProduct,"DeepThoughtReducedProduct",IsIdenticalObjFamiliesRwsObjObj,[IsPowerConjugateCollector and IsDeepThoughtCollectorRep and IsUpToDatePolycyclicCollector,IsAssocWord,IsAssocWord],0,COM_FUN(18));
InstallMethod(ReducedComm,"DeepThoughtReducedComm",IsIdenticalObjFamiliesRwsObjObj,[IsPowerConjugateCollector and IsDeepThoughtCollectorRep and IsUpToDatePolycyclicCollector,IsAssocWord,IsAssocWord],0,COM_FUN(19));
InstallMethod(ReducedLeftQuotient,"DeepThoughtReducedLeftQuotient",IsIdenticalObjFamiliesRwsObjObj,[IsPowerConjugateCollector and IsDeepThoughtCollectorRep and IsUpToDatePolycyclicCollector,IsAssocWord,IsAssocWord],0,COM_FUN(20));
InstallMethod(ReducedPower,"DeepThoughtReducedPower",IsIdenticalObjFamiliesRwsObjXXX,[IsPowerConjugateCollector and IsDeepThoughtCollectorRep and IsUpToDatePolycyclicCollector,IsAssocWord,IsInt],0,COM_FUN(21));
InstallMethod(ReducedQuotient,"DeepThoughtReducedQuotient",IsIdenticalObjFamiliesRwsObjObj,[IsPowerConjugateCollector and IsDeepThoughtCollectorRep and IsUpToDatePolycyclicCollector,IsAssocWord,IsAssocWord],0,COM_FUN(22));
InstallMethod(ReducedConjugate,"DeepThoughtReducedConjugate",IsIdenticalObjFamiliesRwsObjObj,[IsPowerConjugateCollector and IsDeepThoughtCollectorRep and IsUpToDatePolycyclicCollector,IsAssocWord,IsAssocWord],0,COM_FUN(23));
InstallMethod(ReducedInverse,"DeepThoughtReducedInverse",IsIdenticalObjFamiliesRwsObj,[IsPowerConjugateCollector and IsDeepThoughtCollectorRep and IsUpToDatePolycyclicCollector,IsAssocWord],0,COM_FUN(24));
InstallMethod(CollectWordOrFail,"DeepThought",IsIdenticalObjFamiliesColXXXObj,[IsPowerConjugateCollector and IsDeepThoughtCollectorRep,IsList,IsMultiplicativeElementWithInverse],0,COM_FUN(25));
InstallMethod(ObjByExponents,"DeepThought",true,[IsPowerConjugateCollector and IsDeepThoughtCollectorRep,IsList],0,COM_FUN(26));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/rwsdt.gi"

#F  file="lib/nilpquot.gi" crc=-72130247
RANK_FILTER_LIST  := [  ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/nilpquot.gi", -72130247 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/nilpquot.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/nilpquot.gi");
elif COM_RESULT = 3  then
Revision.nilpquot_gi:="$Id: nilpquot.gi,v 4.1 1999/09/13 16:51:06 werner Exp $";
LeftNormedComm:=COM_FUN(1);
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/nilpquot.gi"

#F  file="lib/pquot.gi" crc=-27536251
RANK_FILTER_LIST  := [ 1957334, 3, 7665940, 19, 1957334, 3, 7665940, 19, 1, 
  0, 1957334, 3, 7665940, 19, 1957334, 3, 1957334, 3, 1957334, 3, 47676329, 
  5, 1957334, 3, 63198130, 7, 1957334, 3, 1957334, 3, 1957334, 3, 1957334, 3, 
  1957334, 3, 1957334, 3, 29419057, 21, 7665940, 19, 7665940, 19, 67108760, 
  5, 1957334, 3, 1957334, 3, 7665940, 19, 1957334, 3, 1957334, 3, 1957334, 3, 
  55986039, 26, 7665940, 19, 55986039, 26, 7665940, 19, 7665940, 19, 
  55999958, 23, 7665940, 19, 55999958, 23, 7665940, 19, 7665940, 19, 1957334, 
  3, 1957334, 3, 1957334, 3, 55999958, 23, 1, 0, 55986039, 26, 1, 0, 1957334, 
  3, 7665940, 19 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/pquot.gi", -27536251 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/pquot.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/pquot.gi");
elif COM_RESULT = 3  then
Revision.pquot_gi:="$Id: pquot.gi,v 4.42.2.1 2005/10/17 00:13:11 gap Exp $";
CHECK:=false;
NumberOfCommutators:=COM_FUN(1);
PQStatistics:=rec(TailCountBNA:=0,TailCountBAN:=0,TailCountCBA:=0,ConsCountANA:=0,ConsCountBNA:=0,ConsCountBAN:=0,ConsCountCBA:=0);
IncreaseCounter:=COM_FUN(2);
PrintCounters:=COM_FUN(3);
ClearPQuotientStatistics:=COM_FUN(4);
TrailingEntriesLTM:=COM_FUN(5);
ReducedVectorLTM:=COM_FUN(6);
AddVectorLTM:=COM_FUN(7);
RowEchelonFormLTM:=COM_FUN(8);
LowerTriangularMatrix:=COM_FUN(9);
InstallGlobalFunction(QuotSysDefinitionByIndex,COM_FUN(10));
InstallGlobalFunction(QuotSysIndexByDefinition,COM_FUN(11));
InstallMethod(GetDefinitionNC,true,[IsPQuotientSystem,IsPosInt],0,COM_FUN(12));
InstallMethod(SetDefinitionNC,true,[IsPQuotientSystem,IsPosInt,IsObject],0,COM_FUN(13));
InstallMethod(ClearDefinitionNC,true,[IsPQuotientSystem,IsPosInt],0,COM_FUN(14));
NumberOfNewGenerators:=COM_FUN(15);
InitialiseCentralRelations:=COM_FUN(16);
ClearCentralRelations:=COM_FUN(17);
CentralRelations:=COM_FUN(18);
InstallMethod(IncorporateCentralRelations,"p-quotient system",true,[IsPQuotientSystem],0,COM_FUN(19));
UpdateWeightInfo:=COM_FUN(20);
InstallMethod(DefineNewGenerators,"p-quotient system",true,[IsPQuotientSystem],0,COM_FUN(21));
InstallMethod(SplitWordTail,"p-quotient system, word",true,[IsPQuotientSystem,IsAssocWord],0,COM_FUN(22));
InstallMethod(ExtRepByTailVector,"p-quotient system, vector",true,[IsPQuotientSystem,IsVector],0,COM_FUN(23));
InstallMethod(TailsInverses,"p-quotient system",true,[IsPQuotientSystem],0,COM_FUN(24));
InstallMethod(ComputeTails,"p-quotient system",true,[IsPQuotientSystem],0,COM_FUN(25));
InstallMethod(EvaluateConsistency,"p-quotient system",true,[IsPQuotientSystem],0,COM_FUN(26));
InstallMethod(RenumberHighestWeightGenerators,"p-quotient system",true,[IsPQuotientSystem],0,COM_FUN(27));
EvaluateRelation:=COM_FUN(28);
InstallMethod(EvaluateRelators,"p-quotient system",true,[IsPQuotientSystem],0,COM_FUN(29));
InstallMethod(LiftEpimorphism,"p-quotient system",true,[IsPQuotientSystem],0,COM_FUN(30));
InstallMethod(QuotientSystem,"pquotient",true,[IsGroup,IsPosInt,IsPosInt,IsString],0,COM_FUN(31));
InstallMethod(GeneratorNumberOfQuotient,"p-quotient system",true,[IsPQuotientSystem],0,COM_FUN(32));
InstallMethod(GeneratorsOfLayer,"p-quotient system",true,[IsPQuotientSystem,IsPosInt],0,COM_FUN(33));
InstallMethod(LengthOfDescendingSeries,"p-quotient system",true,[IsPQuotientSystem],0,COM_FUN(34));
InstallMethod(RanksOfDescendingSeries,"p-quotient system",true,[IsPQuotientSystem],0,COM_FUN(35));
InstallMethod(CheckConsistencyOfDefinitions,"p-quotient system",true,[IsPQuotientSystem],0,COM_FUN(36));
InstallGlobalFunction(AbelianPQuotient,COM_FUN(37));
InstallGlobalFunction(PQuotient,COM_FUN(38));
InstallMethod(EpimorphismPGroup,"for finitely presented groups",true,[IsSubgroupFpGroup and IsWholeFamily,IsPosInt],0,COM_FUN(39));
InstallMethod(EpimorphismPGroup,"for finitely presented groups, class bound",true,[IsSubgroupFpGroup and IsWholeFamily,IsPosInt,IsPosInt],0,COM_FUN(40));
InstallMethod(EpimorphismPGroup,"for subgroups of finitely presented groups",true,[IsSubgroupFpGroup,IsPosInt],0,COM_FUN(41));
InstallMethod(EpimorphismPGroup,"for subgroups of finitely presented groups, class bound",true,[IsSubgroupFpGroup,IsPosInt,IsPosInt],0,COM_FUN(42));
InstallMethod(GroupByQuotientSystem,"p-group from a p-quotient system",true,[IsPQuotientSystem],0,COM_FUN(43));
PCover:=COM_FUN(44);
PMultiplicator:=COM_FUN(45);
Nucleus:=COM_FUN(46);
AllowableSubgroup:=COM_FUN(47);
InstallMethod(ViewObj,"p-quotient system",true,[IsPQuotientSystem],0,COM_FUN(48));
InstallMethod(EpimorphismQuotientSystem,"for p-quotient systems",true,[IsPQuotientSystem],0,COM_FUN(49));
InstallGlobalFunction("EpimorphismNilpotentQuotient",COM_FUN(50));
InstallMethod(EpimorphismNilpotentQuotientOp,"subgroup fp group",true,[IsSubgroupFpGroup,IsObject],0,COM_FUN(51));
InstallMethod(EpimorphismNilpotentQuotientOp,"full fp group",true,[IsSubgroupFpGroup and IsWholeFamily,IsObject],0,COM_FUN(52));
InstallMethod(TraceDefinition,"p-quotient system",true,[IsPQuotientSystem,IsPosInt],0,COM_FUN(53));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/pquot.gi"

#F  file="lib/pcgs.gi" crc=77750006
RANK_FILTER_LIST  := [ 8956334, 30, 29419057, 21, 1025, 1, 58719912, 21, 
  7665940, 19, 25165000, 24, 25165000, 24, 25165000, 24, 1, 0, 17, 18, 
  25165000, 24, 25165000, 24, 25165000, 24, 7665940, 19, 58719912, 21, 16385, 
  3, 33553968, 3, 58719912, 21, 66740907, 29, 66740907, 29, 58719912, 21, 
  58719912, 21, 1, 0, 58719912, 21, 1, 0, 17, 18, 58719912, 21, 1, 0, 1, 0, 
  58719912, 21, 1, 0, 7665940, 19, 58719912, 21, 1, 0, 8193, 2, 62914396, 20, 
  7665940, 19, 7665940, 19, 62914396, 20, 7665940, 19, 62914396, 20, 7665940, 
  19, 7665940, 19, 58719912, 21, 1, 0, 17, 18, 58719912, 21, 58719912, 21, 1, 
  0, 58719912, 21, 41951068, 17, 8193, 2, 24093011, 29, 8193, 2, 65077475, 
  29, 58719912, 21, 41951068, 17, 41951068, 17, 58719912, 21, 8193, 2, 
  24093011, 29, 58719912, 21, 8193, 2, 65077475, 29, 62914396, 20, 24093011, 
  29, 65077475, 29, 62914396, 20, 24093011, 29, 24093011, 29, 49020554, 25, 
  1, 0, 1, 0, 49020554, 25, 1, 0, 58719912, 21, 1, 0, 58719912, 21, 65767820, 
  5, 7665940, 19, 48758945, 25, 8193, 2, 58721152, 23, 8193, 2, 58719912, 21, 
  1, 0, 1, 0, 58719912, 21, 41951068, 17, 49020554, 25, 8193, 2, 8193, 2, 1, 
  0, 49020554, 25, 8193, 2, 8193, 2, 49020554, 25, 8193, 2, 8193, 2, 
  49020554, 25, 8193, 2, 8193, 2, 49020554, 25, 8193, 2, 8193, 2, 1, 0, 
  58719912, 21, 58719912, 21, 58719912, 21, 58719912, 21, 8193, 2, 65436932, 
  5, 65436932, 5, 7665940, 19, 65436932, 5, 65767820, 5, 30666573, 21, 
  65436932, 5, 65767820, 5, 58719912, 21, 58719912, 21, 19425093, 22, 
  48659957, 28, 4385592, 23, 46725939, 22, 46725939, 22, 38943959, 22, 
  1069944, 28, 23905418, 23, 46725939, 22, 46725939, 22, 52343383, 22, 
  14469368, 28, 37304842, 23, 46725939, 22, 46725939, 22, 56004341, 22, 
  18130326, 28, 40965800, 23, 46725939, 22, 46725939, 22, 58719912, 21, 
  29419057, 21, 8193, 2 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/pcgs.gi", 77750006 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/pcgs.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/pcgs.gi");
elif COM_RESULT = 3  then
Revision.pcgs_gi:="@(#)$Id: pcgs.gi,v 4.103.2.1 2005/10/14 08:45:40 gap Exp $";
InstallGlobalFunction(PcgsByIndependentGeneratorsOfAbelianGroup,COM_FUN(1));
InstallMethod(Pcgs,"from independent generators of abelian group",true,[IsGroup and IsAbelian and HasIndependentGeneratorsOfAbelianGroup],0,COM_FUN(2));
InstallMethod(SetPcgs,true,[IsGroup,IsBool],0,COM_FUN(3));
InstallMethod(IsBound\[\],"pcgs",true,[IsPcgs,IsPosInt],0,COM_FUN(4));
InstallMethod(Length,"pcgs",true,[IsPcgs and IsPcgsDefaultRep],0,COM_FUN(5));
InstallMethod(AsList,"pcgs",true,[IsPcgs and IsPcgsDefaultRep],0,COM_FUN(6));
InstallMethod(Position,"pcgs, object, int",true,[IsPcgs and IsPcgsDefaultRep,IsObject,IsInt],0,COM_FUN(7));
InstallMethod(PrintObj,"pcgs",true,[IsPcgs and IsPcgsDefaultRep],0,COM_FUN(8));
InstallMethod(ViewObj,"pcgs",true,[IsPcgs and IsPcgsDefaultRep],0,COM_FUN(9));
InstallMethod(\[\],"pcgs, pos int",true,[IsPcgs and IsPcgsDefaultRep,IsPosInt],0,COM_FUN(10));
InstallMethod(ELMS_LIST,"pcgs, range",true,[IsPcgs,IsDenseList],0,COM_FUN(11));
InstallMethod(PcgsByPcSequenceCons,"generic constructor",true,[IsPcgsDefaultRep,IsObject,IsFamily,IsList,IsList],0,COM_FUN(12));
InstallMethod(IsPrimeOrdersPcgs,true,[IsPcgs],0,COM_FUN(13));
InstallMethod(RefinedPcGroup,"group with refined pcgs",true,[IsPcGroup],0,COM_FUN(14));
InstallMethod(IsomorphismRefinedPcGroup,"group with refined pcgs",true,[IsPcGroup],0,COM_FUN(15));
InstallTrueMethod(IsFiniteOrdersPcgs,IsPrimeOrdersPcgs);
InstallMethod(IsFiniteOrdersPcgs,true,[IsPcgs],0,COM_FUN(16));
InstallMethod(DepthOfPcElement,"generic methods, ExponentsOfPcElement",IsCollsElms,[IsPcgs,IsObject],0,COM_FUN(17));
InstallOtherMethod(DepthOfPcElement,"pcgs modulo pcgs, ignoring <min>",COM_FUN(18),[IsPcgs,IsObject,IsInt],0,COM_FUN(19));
InstallMethod(DifferenceOfPcElement,"generic methods, PcElementByExponents/ExponentsOfPcElement",IsCollsElmsElms,[IsPcgs,IsObject,IsObject],0,COM_FUN(20));
InstallMethod(ExponentOfPcElement,"generic method, ExponentsOfPcElement",COM_FUN(21),[IsPcgs,IsObject,IsPosInt],0,COM_FUN(22));
InstallOtherMethod(ExponentsOfPcElement,"with positions, falling back to ExponentsOfPcElement",COM_FUN(23),[IsPcgs,IsObject,IsList],0,COM_FUN(24));
InstallMethod(ExponentsOfConjugate,"generic: compute conjugate",true,[IsModuloPcgs,IsPosInt,IsPosInt],0,COM_FUN(25));
InstallMethod(ExponentsOfRelativePower,"generic: compute power",true,[IsModuloPcgs,IsPosInt],0,COM_FUN(26));
InstallMethod(ExponentsOfCommutator,"generic: compute commutator",true,[IsModuloPcgs,IsPosInt,IsPosInt],0,COM_FUN(27));
InstallMethod(HeadPcElementByNumber,"using 'ExponentsOfPcElement', 'PcElementByExponents'",true,[IsPcgs,IsObject,IsInt],0,COM_FUN(28));
InstallOtherMethod(ParentPcgs,true,[IsPcgs],0,IdFunc);
InstallMethod(LeadingExponentOfPcElement,"generic methods, ExponentsOfPcElement",IsCollsElms,[IsPcgs,IsObject],0,COM_FUN(29));
InstallGlobalFunction(PcElementByExponents,COM_FUN(30));
InstallMethod(PcElementByExponentsNC,"generic method for empty lists",true,[IsPcgs,IsList and IsEmpty],0,COM_FUN(31));
InstallGlobalFunction(PowerPcgsElement,COM_FUN(32));
InstallGlobalFunction(LeftQuotientPowerPcgsElement,COM_FUN(33));
InstallGlobalFunction(LinearCombinationPcgs,COM_FUN(34));
InstallOtherMethod(PcElementByExponentsNC,"generic method: call LinearCombinationPcgs",true,[IsList,IsRowVector and IsCyclotomicCollection],0,LinearCombinationPcgs);
InstallOtherMethod(PcElementByExponentsNC,"generic method",true,[IsList,IsRowVector and IsFFECollection],0,COM_FUN(35));
InstallOtherMethod(PcElementByExponentsNC,"generic method for empty lists",true,[IsPcgs,IsList and IsEmpty,IsList and IsEmpty],0,COM_FUN(36));
InstallOtherMethod(PcElementByExponentsNC,"multiply basis elements",IsFamFamX,[IsPcgs,IsList,IsRowVector and IsCyclotomicCollection],0,COM_FUN(37));
InstallOtherMethod(PcElementByExponentsNC,"multiply base elts., FFE",IsFamFamX,[IsPcgs,IsList,IsRowVector and IsFFECollection],0,COM_FUN(38));
InstallOtherMethod(PcElementByExponentsNC,"index: defer to basis",true,[IsModuloPcgs,IsRowVector and IsCyclotomicCollection,IsRowVector and IsFFECollection],0,COM_FUN(39));
InstallOtherMethod(PcElementByExponentsNC,"index: defer to basis,FFE",true,[IsModuloPcgs,IsRowVector and IsCyclotomicCollection,IsRowVector and IsCyclotomicCollection],0,COM_FUN(40));
InstallMethod(ReducedPcElement,"generic method",IsCollsElmsElms,[IsPcgs and IsPrimeOrdersPcgs,IsObject,IsObject],0,COM_FUN(41));
InstallMethod(RelativeOrderOfPcElement,"for IsPrimeOrdersPcgs using RelativeOrders",IsCollsElms,[IsPcgs and IsPrimeOrdersPcgs,IsObject],0,COM_FUN(42));
InstallMethod(RelativeOrderOfPcElement,"general method using RelativeOrders",IsCollsElms,[IsPcgs,IsObject],0,COM_FUN(43));
InstallMethod(CleanedTailPcElement,"generic: do nothing",IsCollsElmsX,[IsPcgs,IsMultiplicativeElementWithInverse,IsPosInt],0,COM_FUN(44));
SET_RELATIVE_ORDERS:=SETTER_FUNCTION("RelativeOrders",HasRelativeOrders);
InstallMethod(SetRelativeOrders,"setting orders for prime orders pcgs",true,[IsPcgs and IsComponentObjectRep and IsAttributeStoringRep and HasIsPrimeOrdersPcgs and HasIsFiniteOrdersPcgs,IsList],1,SET_RELATIVE_ORDERS);
InstallMethod(SetRelativeOrders,"setting orders and checking for prime orders",true,[IsPcgs and IsComponentObjectRep and IsAttributeStoringRep,IsList],0,COM_FUN(45));
InstallMethod(SumOfPcElement,"generic methods, PcElementByExponents+ExponentsOfPcElement",IsCollsElmsElms,[IsPcgs,IsObject,IsObject],0,COM_FUN(46));
InstallMethod(ExtendedPcgs,"pcgs, empty list",true,[IsPcgs,IsList and IsEmpty],0,COM_FUN(47));
InstallMethod(ExtendedIntersectionSumPcgs,"generic method for modulo pcgs",true,[IsPcgs and IsPrimeOrdersPcgs,IsList,IsList,IsObject],0,COM_FUN(48));
InstallMethod(IntersectionSumPcgs,"using 'ExtendedIntersectionSumPcgs'",COM_FUN(49),[IsPcgs and IsPrimeOrdersPcgs,IsList,IsList],0,COM_FUN(50));
InstallMethod(NormalIntersectionPcgs,"using 'ExtendedIntersectionSumPcgs'",COM_FUN(51),[IsPcgs and IsPrimeOrdersPcgs,IsList,IsList],0,COM_FUN(52));
InstallMethod(SumPcgs,"generic method",COM_FUN(53),[IsPcgs and IsPrimeOrdersPcgs,IsList,IsList],0,COM_FUN(54));
InstallMethod(SumFactorizationFunctionPcgs,"generic method",true,[IsPcgs and IsPrimeOrdersPcgs,IsList,IsList,IsObject],0,COM_FUN(55));
GROUP_BY_PCGS_FINITE_ORDERS:=COM_FUN(56);
InstallMethod(PcGroupWithPcgs,true,[IsPcgs],0,COM_FUN(57));
InstallMethod(GroupOfPcgs,true,[IsPcgs],0,COM_FUN(58));
DeclareRepresentation("IsEnumeratorByPcgsRep",IsAttributeStoringRep,["pcgs","sublist"]);
InstallMethod(EnumeratorByPcgs,"pcgs",true,[IsPcgs],0,COM_FUN(59));
InstallOtherMethod(EnumeratorByPcgs,"pcgs, sublist",true,[IsPcgs,IsList],0,COM_FUN(60));
InstallMethod(Length,"enum-by-pcgs",true,[IsList and IsEnumeratorByPcgsRep],0,COM_FUN(61));
InstallMethod(\[\],"enum-by-pcgs",true,[IsList and IsEnumeratorByPcgsRep,IsPosInt],0,COM_FUN(62));
InstallMethod(Position,"enum-by-pcgs",IsCollsElmsX,[IsList and IsEnumeratorByPcgsRep,IsMultiplicativeElementWithInverse,IsZeroCyc],0,COM_FUN(63));
InstallMethod(PositionCanonical,"enum-by-pcgs",IsCollsElms,[IsList and IsEnumeratorByPcgsRep,IsMultiplicativeElementWithInverse],0,COM_FUN(64));
InstallMethod(IndicesNormalSteps,"generic",true,[IsPcgs],0,COM_FUN(65));
InstallMethod(NormalSeriesByPcgs,"generic",true,[IsPcgs],0,COM_FUN(66));
InstallPcgsSeriesFromIndices:=COM_FUN(67);
InstallPcgsSeriesFromIndices(EANormalSeriesByPcgs,IndicesEANormalSteps);
InstallPcgsSeriesFromIndices(ChiefNormalSeriesByPcgs,IndicesChiefNormalSteps);
InstallPcgsSeriesFromIndices(CentralNormalSeriesByPcgs,IndicesCentralNormalSteps);
InstallPcgsSeriesFromIndices(PCentralNormalSeriesByPcgsPGroup,IndicesPCentralNormalStepsPGroup);
InstallMethod(IsPcgsElementaryAbelianSeries,"test if elm. abelian",true,[IsPcgs],0,COM_FUN(68));
InstallGlobalFunction(LiftedPcElement,COM_FUN(69));
InstallGlobalFunction(ProjectedPcElement,COM_FUN(70));
InstallGlobalFunction(ProjectedInducedPcgs,COM_FUN(71));
InstallGlobalFunction(LiftedInducedPcgs,COM_FUN(72));
BindGlobal("DoPcgsElementaryAbelianSeries",COM_FUN(73));
InstallMethod(PcgsElementaryAbelianSeries,"generic group",true,[IsGroup],0,DoPcgsElementaryAbelianSeries);
InstallOtherMethod(PcgsElementaryAbelianSeries,"group list",true,[IsList],0,DoPcgsElementaryAbelianSeries);
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/pcgs.gi"

#F  file="lib/pcgsind.gi" crc=54091002
RANK_FILTER_LIST  := [ 58719912, 21, 41951068, 17, 58719912, 21, 41951068, 
  17, 8193, 2, 58719912, 21, 8159233, 5, 58719912, 21, 8159233, 5, 8193, 2, 
  3718269, 30, 58719912, 21, 41951068, 17, 58719912, 21, 8159233, 5, 
  49020554, 25, 8193, 2, 8193, 2, 49020554, 25, 8126465, 2, 8126465, 2, 
  49020554, 25, 41951068, 17, 41951068, 17, 49020554, 25, 8126465, 2, 
  8126465, 2, 58719912, 21, 8193, 2, 8193, 2, 58719912, 21, 41951068, 17, 
  49020554, 25, 8126465, 2, 58719912, 21, 8126465, 2, 58719912, 21, 41951068, 
  17, 58719912, 21, 8126465, 2, 58719912, 21, 41951068, 17, 58719912, 21, 
  32769, 4, 7077589, 26, 16776947, 22, 19617587, 24, 58719912, 21, 8193, 2, 
  58719912, 21, 8193, 2, 1, 0, 58719912, 21, 41951068, 17, 49020554, 25, 
  32769, 4, 58719912, 21, 41951068, 17, 5, 1, 49020554, 25, 32769, 4, 5, 1, 
  58719912, 21, 41951068, 17, 1, 0, 49020554, 25, 32769, 4, 1, 0, 58719912, 
  21, 49020554, 25, 3341587, 28, 8193, 2, 49020554, 25, 3341587, 28, 8193, 2, 
  49020554, 25, 3341587, 28, 13417627, 26, 3718269, 30, 1, 0, 13417627, 26, 
  1, 0, 3718269, 30, 1, 0, 7665940, 19, 3718269, 30, 1, 0, 3718269, 30, 1, 0, 
  8193, 2, 3718269, 30, 1, 0, 42302874, 30, 1, 0, 42302874, 30, 1, 0, 8193, 
  2, 42302874, 30, 1, 0, 16776947, 22, 8193, 2 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/pcgsind.gi", 54091002 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/pcgsind.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/pcgsind.gi");
elif COM_RESULT = 3  then
Revision.pcgsind_gi:="@(#)$Id: pcgsind.gi,v 4.70 2002/04/15 10:05:12 sal Exp $";
DeclareRepresentation("IsInducedPcgsRep",IsPcgsDefaultRep,["depthsInParent","depthMapFromParent"]);
DeclareRepresentation("IsSubsetInducedPcgsRep",IsInducedPcgsRep,["parentZeroVector"]);
DeclareRepresentation("IsTailInducedPcgsRep",IsSubsetInducedPcgsRep,[]);
InstallMethod(InducedPcgsByPcSequenceNC,"pcgs, empty list",true,[IsPcgs,IsList and IsEmpty],0,COM_FUN(1));
InstallOtherMethod(InducedPcgsByPcSequenceNC,"pcgs, empty list,depths",true,[IsPcgs,IsList and IsEmpty,IsList],0,COM_FUN(2));
BindGlobal("DoInducedPcgsByPcSequenceNC",COM_FUN(3));
InstallMethod(InducedPcgsByPcSequenceNC,"pcgs, homogeneous list",IsIdenticalObj,[IsPcgs,IsCollection and IsHomogeneousList],0,DoInducedPcgsByPcSequenceNC);
InstallOtherMethod(InducedPcgsByPcSequenceNC,"pcgs, homogeneous list, depths",IsFamFamX,[IsPcgs,IsCollection and IsHomogeneousList,IsList],0,DoInducedPcgsByPcSequenceNC);
InstallMethod(LeadCoeffsIGS,"generic",true,[IsInducedPcgs and IsInducedPcgsRep and IsPrimeOrdersPcgs],0,COM_FUN(4));
InstallMethod(InducedPcgsByPcSequence,true,[IsPcgs,IsList and IsEmpty],0,COM_FUN(5));
InstallMethod(InducedPcgsByPcSequence,true,[IsPcgs,IsCollection and IsHomogeneousList],0,COM_FUN(6));
InstallMethod(InducedPcgsByPcSequenceAndGenerators,true,[IsPcgs and IsPrimeOrdersPcgs,IsList,IsList],0,COM_FUN(7));
InstallMethod(InducedPcgsByGeneratorsWithImages,true,[IsPcgs and IsPrimeOrdersPcgs,IsCollection,IsCollection],0,COM_FUN(8));
InstallOtherMethod(InducedPcgsByGeneratorsWithImages,true,[IsPcgs and IsPrimeOrdersPcgs,IsList and IsEmpty,IsList and IsEmpty],0,COM_FUN(9));
InstallMethod(CanonicalPcgsByGeneratorsWithImages,true,[IsPcgs and IsPrimeOrdersPcgs,IsCollection,IsCollection],0,COM_FUN(10));
InstallOtherMethod(CanonicalPcgsByGeneratorsWithImages,true,[IsPcgs,IsList,IsList],0,COM_FUN(11));
InstallOtherMethod(InducedPcgsByGeneratorsNC,"pcgs, empty list",true,[IsPcgs,IsList and IsEmpty],0,COM_FUN(12));
InstallMethod(InducedPcgsByGeneratorsNC,"prime order pcgs, collection",COM_FUN(13),[IsPcgs and IsPrimeOrdersPcgs,IsCollection],0,COM_FUN(14));
RedispatchOnCondition(InducedPcgsByGeneratorsNC,true,[IsPcgs,IsCollection],[IsPrimeOrdersPcgs],0);
InstallOtherMethod(InducedPcgsByGenerators,true,[IsPcgs,IsList and IsEmpty],0,COM_FUN(15));
InstallMethod(InducedPcgsByGenerators,"pcgs, collection",COM_FUN(16),[IsPcgs,IsCollection],0,COM_FUN(17));
InstallMethod(AsInducedPcgs,true,[IsPcgs,IsEmpty and IsList],0,COM_FUN(18));
InstallMethod(AsInducedPcgs,IsIdenticalObj,[IsPcgs,IsHomogeneousList],0,COM_FUN(19));
HOMOMORPHIC_IGS:=COM_FUN(20);
InstallGlobalFunction(NORMALIZE_IGS,COM_FUN(21));
InstallMethod(CanonicalPcgs,"induced prime orders pcgs",true,[IsInducedPcgs and IsPrimeOrdersPcgs],0,COM_FUN(22));
RedispatchOnCondition(CanonicalPcgs,true,[IsInducedPcgs],[IsPrimeOrdersPcgs],0);
InstallOtherMethod(CanonicalPcgs,"of an canonical pcgs",true,[IsCanonicalPcgs],SUM_FLAGS,COM_FUN(23));
InstallMethod(HomomorphicCanonicalPcgs,"pcgs, list",true,[IsPcgs,IsList],0,COM_FUN(24));
InstallOtherMethod(HomomorphicCanonicalPcgs,"pcgs, list, object",true,[IsPcgs,IsList,IsObject],0,COM_FUN(25));
InstallMethod(HomomorphicInducedPcgs,true,[IsPcgs,IsEmpty and IsList],0,COM_FUN(26));
InstallMethod(HomomorphicInducedPcgs,IsIdenticalObj,[IsPcgs and IsPrimeOrdersPcgs,IsHomogeneousList],0,COM_FUN(27));
InstallOtherMethod(HomomorphicInducedPcgs,true,[IsPcgs,IsEmpty and IsList,IsFunction],0,COM_FUN(28));
InstallOtherMethod(HomomorphicInducedPcgs,COM_FUN(29),[IsPcgs and IsPrimeOrdersPcgs,IsHomogeneousList,IsFunction],0,COM_FUN(30));
InstallOtherMethod(HomomorphicInducedPcgs,true,[IsPcgs,IsEmpty and IsList,IsObject],0,COM_FUN(31));
InstallOtherMethod(HomomorphicInducedPcgs,COM_FUN(32),[IsPcgs and IsPrimeOrdersPcgs,IsHomogeneousList,IsObject],0,COM_FUN(33));
InstallMethod(ElementaryAbelianSubseries,"generic method",true,[IsPcgs],0,COM_FUN(34));
InstallMethod(IntersectionSumPcgs,"prime orders pcgs, tail-pcgs, list",IsFamFamFam,[IsPcgs and IsPrimeOrdersPcgs,IsInducedPcgs and IsTailInducedPcgsRep,IsList],0,COM_FUN(35));
InstallMethod(NormalIntersectionPcgs,"prime orders pcgs, tail-pcgs, list",IsFamFamFam,[IsPcgs and IsPrimeOrdersPcgs,IsInducedPcgs and IsTailInducedPcgsRep,IsList],0,COM_FUN(36));
InstallMethod(NormalIntersectionPcgs,"prime orders pcgs, tail-pcgs, induced-pcgs",IsFamFamFam,[IsPcgs and IsPrimeOrdersPcgs,IsInducedPcgs and IsTailInducedPcgsRep,IsInducedPcgs and IsInducedPcgsRep],0,COM_FUN(37));
CANONICAL_PC_ELEMENT:=COM_FUN(38);
InstallMethod(CanonicalPcElement,"generic method",IsCollsElms,[IsInducedPcgs and IsInducedPcgsRep and IsPrimeOrdersPcgs,IsObject],0,CANONICAL_PC_ELEMENT);
InstallMethod(DepthOfPcElement,"induced pcgs",IsCollsElms,[IsInducedPcgs and IsInducedPcgsRep,IsObject],0,COM_FUN(39));
InstallMethod(ExponentOfPcElement,"induced pcgs",COM_FUN(40),[IsInducedPcgs and IsInducedPcgsRep and IsPrimeOrdersPcgs,IsObject,IsPosInt],0,COM_FUN(41));
InstallMethod(ExponentsOfPcElement,"induced pcgs",IsCollsElms,[IsInducedPcgs and IsInducedPcgsRep and IsPrimeOrdersPcgs,IsObject],0,COM_FUN(42));
InstallOtherMethod(ExponentsOfPcElement,"induced pcgs, subrange",IsCollsElmsX,[IsInducedPcgs and IsInducedPcgsRep and IsPrimeOrdersPcgs,IsObject,IsList],0,COM_FUN(43));
InstallMethod(SiftedPcElement,"for induced pcgs",IsCollsElms,[IsInducedPcgs and IsInducedPcgsRep and IsPrimeOrdersPcgs,IsObject],0,COM_FUN(44));
InstallMethod(ExponentsOfPcElement,"subset of induced pcgs",IsCollsElms,[IsPcgs and IsSubsetInducedPcgsRep and IsPrimeOrdersPcgs,IsObject],0,COM_FUN(45));
InstallOtherMethod(ExponentsOfPcElement,"subset of induced pcgs, subrange",IsCollsElmsX,[IsPcgs and IsSubsetInducedPcgsRep and IsPrimeOrdersPcgs,IsObject,IsList],0,COM_FUN(46));
InstallMethod(LeadingExponentOfPcElement,"subset induced pcgs",IsCollsElms,[IsPcgs and IsSubsetInducedPcgsRep and IsPrimeOrdersPcgs,IsObject],0,COM_FUN(47));
InstallMethod(ExtendedPcgs,"induced pcgs",IsIdenticalObj,[IsInducedPcgs,IsList],0,COM_FUN(48));
InstallGlobalFunction(CorrespondingGeneratorsByModuloPcgs,COM_FUN(49));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/pcgsind.gi"

#F  file="lib/pcgsmodu.gi" crc=-32146057
RANK_FILTER_LIST  := [ 62914396, 20, 7665940, 19, 62914396, 20, 62914396, 20, 
  1, 0, 17, 18, 62914396, 20, 62914396, 20, 7665940, 19, 58719912, 21, 8193, 
  2, 58719912, 21, 58719912, 21, 8193, 2, 16776947, 22, 58719912, 21, 
  16776947, 22, 58719912, 21, 58719912, 21, 16776947, 22, 16776947, 22, 
  62914396, 20, 62914396, 20, 58719912, 21, 58719912, 21, 62914396, 20, 1, 0, 
  17, 18, 62914396, 20, 1, 0, 7665940, 19, 62914396, 20, 1, 0, 8193, 2, 
  62914396, 20, 62914396, 20, 62914396, 20, 1, 0, 62914396, 20, 41951068, 17, 
  62914396, 20, 24093011, 29, 62914396, 20, 65077475, 29, 62914396, 20, 
  41951068, 17, 8193, 2, 62914396, 20, 8193, 2, 24093011, 29, 62914396, 20, 
  8193, 2, 65077475, 29, 62914396, 20, 1, 0, 1, 0, 62914396, 20, 53215038, 
  24, 53215038, 24, 1, 0, 36044636, 24, 1, 0, 36044636, 24, 1, 0, 36044636, 
  24, 1, 0, 8193, 2, 9174876, 25, 1, 0, 9174876, 25, 1, 0, 8193, 2, 9174876, 
  25, 1, 0, 7665940, 19, 62914396, 20, 65767820, 5, 65767820, 5, 62914396, 
  20, 62914396, 20, 49281993, 26, 49281993, 26, 58719912, 21, 58719912, 21, 
  29419057, 21, 29419057, 21, 34770305, 32, 24093011, 29, 34770305, 32, 
  24093011, 29, 24093011, 29, 34770305, 32, 65077475, 29, 34770305, 32, 
  24093011, 29, 65077475, 29, 34770305, 32, 65767820, 5, 65767820, 5, 
  49019909, 26, 1, 0, 8193, 2, 49019909, 26, 1, 0, 49019909, 26, 7665940, 19, 
  7665940, 19, 49019909, 26, 7665940, 19 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/pcgsmodu.gi", -32146057 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/pcgsmodu.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/pcgsmodu.gi");
elif COM_RESULT = 3  then
Revision.pcgsmodu_gi:="@(#)$Id: pcgsmodu.gi,v 4.47 2002/04/15 10:05:12 sal Exp $";
DeclareRepresentation("IsModuloPcgsRep",IsPcgsDefaultRep,["moduloDepths","moduloMap","numerator","denominator","depthMap"]);
DeclareRepresentation("IsModuloTailPcgsRep",IsModuloPcgsRep,["moduloDepths","moduloMap","numerator","denominator","depthMap"]);
DeclareRepresentation("IsSubsetInducedNumeratorModuloTailPcgsRep",IsModuloTailPcgsRep,["moduloDepths","moduloMap","numerator","denominator","depthMap","depthsInParent","numeratorParent","parentZeroVector"]);
DeclareRepresentation("IsModuloTailPcgsByListRep",IsModuloTailPcgsRep,["moduloDepths","moduloMap","numerator","denominator","depthMap","depthsInParent","numeratorParent","parentZeroVector"]);
DeclareRepresentation("IsNumeratorParentForExponentsRep",IsModuloPcgsRep,["moduloDepths","moduloMap","numerator","denominator","depthMap","depthsInParent","numeratorParent","parentZeroVector"]);
InstallMethod(IsBound\[\],true,[IsModuloPcgs,IsPosInt],0,COM_FUN(1));
InstallMethod(Length,"modulo pcgs",true,[IsModuloPcgs],0,COM_FUN(2));
InstallMethod(Position,"modulo pcgs",true,[IsModuloPcgs,IsObject,IsInt],0,COM_FUN(3));
InstallMethod(PrintObj,"modulo pcgs",true,[IsModuloPcgs],0,COM_FUN(4));
InstallMethod(\[\],"modulo pcgs",true,[IsModuloPcgs,IsPosInt],0,COM_FUN(5));
InstallGlobalFunction(ModuloTailPcgsByList,COM_FUN(6));
InstallMethod(ModuloPcgsByPcSequenceNC,"generic method for pcgs mod pcgs",true,[IsPcgs,IsList,IsPcgs],0,COM_FUN(7));
InstallMethod(ModuloPcgsByPcSequence,"generic method",true,[IsPcgs,IsList,IsInducedPcgs],0,COM_FUN(8));
InstallMethod(MOD,"parent pcgs mod induced pcgs",IsIdenticalObj,[IsPcgs,IsInducedPcgs],0,COM_FUN(9));
InstallMethod(MOD,"two parent pcgs",IsIdenticalObj,[IsPcgs,IsPcgs],0,COM_FUN(10));
InstallMethod(MOD,"two induced pcgs",IsIdenticalObj,[IsInducedPcgs,IsInducedPcgs],0,COM_FUN(11));
InstallMethod(MOD,"two modulo pcgs",IsIdenticalObj,[IsModuloPcgs,IsModuloPcgs],0,COM_FUN(12));
InstallMethod(MOD,"two induced pcgs",IsIdenticalObj,[IsPcgs,IsPcgs],0,COM_FUN(13));
InstallOtherMethod(DepthOfPcElement,"pcgs modulo pcgs, ignoring <min>",COM_FUN(14),[IsModuloPcgs,IsObject,IsInt],0,COM_FUN(15));
InstallOtherMethod(ExponentOfPcElement,"pcgs modulo pcgs, ExponentsOfPcElement",IsCollsElmsX,[IsModuloPcgs,IsObject,IsPosInt],0,COM_FUN(16));
InstallOtherMethod(ExponentsOfPcElement,"pcgs mod. pcgs,range, falling back to Exp.OfPcElement",IsCollsElmsX,[IsModuloPcgs,IsObject,IsList],0,COM_FUN(17));
InstallOtherMethod(IsFiniteOrdersPcgs,true,[IsModuloPcgs],0,COM_FUN(18));
InstallOtherMethod(IsPrimeOrdersPcgs,true,[IsModuloPcgs],0,COM_FUN(19));
InstallOtherMethod(LeadingExponentOfPcElement,"pcgs modulo pcgs, use ExponentsOfPcElement",IsCollsElms,[IsModuloPcgs,IsObject],0,COM_FUN(20));
InstallOtherMethod(PcElementByExponentsNC,"generic method for empty lists",true,[IsModuloPcgs,IsList and IsEmpty],0,COM_FUN(21));
InstallOtherMethod(PcElementByExponentsNC,"generic method: modulo",true,[IsModuloPcgs,IsRowVector and IsCyclotomicCollection],0,COM_FUN(22));
InstallOtherMethod(PcElementByExponentsNC,"generic method: modulo, FFE",true,[IsModuloPcgs,IsRowVector and IsFFECollection],0,COM_FUN(23));
InstallOtherMethod(PcElementByExponentsNC,"generic method for empty list as basis or basisindex, modulo",true,[IsModuloPcgs,IsList and IsEmpty,IsList],SUM_FLAGS,COM_FUN(24));
InstallOtherMethod(PcElementByExponentsNC,"generic method: modulo, basis",IsFamFamX,[IsModuloPcgs,IsList,IsRowVector and IsCyclotomicCollection],0,COM_FUN(25));
InstallOtherMethod(PcElementByExponentsNC,"generic method: modulo, basis, FFE",IsFamFamX,[IsModuloPcgs,IsList,IsRowVector and IsFFECollection],0,COM_FUN(26));
InstallOtherMethod(ReducedPcElement,"pcgs modulo pcgs",IsCollsElmsElms,[IsModuloPcgs,IsObject,IsObject],0,COM_FUN(27));
InstallOtherMethod(RelativeOrderOfPcElement,"pcgs modulo pcgs",IsCollsElms,[IsModuloPcgs and IsPrimeOrdersPcgs,IsObject],RankFilter(IsModuloPcgs)-RankFilter(IsModuloPcgs and IsPrimeOrdersPcgs),COM_FUN(28));
InstallOtherMethod(DepthOfPcElement,"pcgs modulo pcgs",IsCollsElms,[IsModuloPcgs and IsModuloPcgsRep,IsObject],0,COM_FUN(29));
InstallOtherMethod(ExponentsOfPcElement,"pcgs modulo pcgs",IsCollsElms,[IsModuloPcgs and IsModuloPcgsRep,IsObject],0,COM_FUN(30));
InstallOtherMethod(ExponentsOfPcElement,"pcgs modulo pcgs, subrange",IsCollsElmsX,[IsModuloPcgs and IsModuloPcgsRep,IsObject,IsList],0,COM_FUN(31));
InstallOtherMethod(ExponentsOfPcElement,"pcgs modulo tail-pcgs",IsCollsElms,[IsModuloPcgs and IsModuloTailPcgsRep,IsObject],0,COM_FUN(32));
InstallOtherMethod(ExponentsOfPcElement,"pcgs modulo tail-pcgs, subrange",IsCollsElmsX,[IsModuloPcgs and IsModuloTailPcgsRep,IsObject,IsList],0,COM_FUN(33));
InstallOtherMethod(ExponentOfPcElement,"pcgs modulo tail-pcgs, ExponentsOfPcElement",IsCollsElmsX,[IsModuloPcgs and IsModuloTailPcgsRep,IsObject,IsPosInt],0,COM_FUN(34));
InstallMethod(ExponentsConjugateLayer,"default: compute brute force",IsCollsElmsElms,[IsModuloPcgs,IsMultiplicativeElementWithInverse,IsMultiplicativeElementWithInverse],0,COM_FUN(35));
InstallMethod(PcGroupWithPcgs,"pcgs modulo pcgs",true,[IsModuloPcgs],0,COM_FUN(36));
InstallOtherMethod(GroupOfPcgs,true,[IsModuloPcgs],0,COM_FUN(37));
InstallMethod(NumeratorOfModuloPcgs,"modolo-tail-pcgs-by-list-rep",true,[IsModuloPcgs and IsModuloTailPcgsByListRep],0,COM_FUN(38));
InstallMethod(DenominatorOfModuloPcgs,"modolo-tail-pcgs-by-list-rep",true,[IsModuloPcgs and IsModuloTailPcgsByListRep],0,COM_FUN(39));
InstallMethod(NumeratorOfModuloPcgs,"for pcgs",true,[IsPcgs],0,COM_FUN(40));
InstallMethod(DenominatorOfModuloPcgs,"for pcgs",true,[IsPcgs],0,COM_FUN(41));
InstallMethod(ModuloPcgs,"for groups",IsIdenticalObj,[IsGroup,IsGroup],0,COM_FUN(42));
InstallMethod(PcElementByExponentsNC,"modulo subset induced wrt family pcgs",true,[IsModuloPcgs and IsSubsetInducedNumeratorModuloTailPcgsRep and IsPrimeOrdersPcgs and IsNumeratorParentPcgsFamilyPcgs,IsRowVector and IsCyclotomicCollection],0,COM_FUN(43));
InstallOtherMethod(PcElementByExponentsNC,"modulo subset induced wrt family pcgs,index",true,[IsModuloPcgs and IsSubsetInducedNumeratorModuloTailPcgsRep and IsPrimeOrdersPcgs and IsNumeratorParentPcgsFamilyPcgs,IsRowVector and IsCyclotomicCollection,IsRowVector and IsCyclotomicCollection],0,COM_FUN(44));
InstallMethod(PcElementByExponentsNC,"modulo subset induced wrt family pcgs, FFE",true,[IsModuloPcgs and IsSubsetInducedNumeratorModuloTailPcgsRep and IsPrimeOrdersPcgs and IsNumeratorParentPcgsFamilyPcgs,IsRowVector and IsFFECollection],0,COM_FUN(45));
InstallOtherMethod(PcElementByExponentsNC,"modulo subset induced wrt family pcgs, FFE, index",true,[IsModuloPcgs and IsSubsetInducedNumeratorModuloTailPcgsRep and IsPrimeOrdersPcgs and IsNumeratorParentPcgsFamilyPcgs,IsRowVector and IsCyclotomicCollection,IsRowVector and IsFFECollection],0,COM_FUN(46));
InstallMethod(ExponentsConjugateLayer,"subset induced modulo pcgs",IsCollsElmsElms,[IsModuloPcgs and IsSubsetInducedNumeratorModuloTailPcgsRep and IsPrimeOrdersPcgs and IsNumeratorParentPcgsFamilyPcgs,IsMultiplicativeElementWithInverse,IsMultiplicativeElementWithInverse],0,COM_FUN(47));
InstallOtherMethod(ExponentsOfPcElement,"subset induced pcgs modulo tail-pcgs, subrange",IsCollsElmsX,[IsModuloPcgs and IsModuloTailPcgsRep and IsNumeratorParentForExponentsRep,IsObject,IsList],0,COM_FUN(48));
InstallOtherMethod(ExponentsOfPcElement,"subset induced pcgs modulo tail-pcgs",IsCollsElms,[IsModuloPcgs and IsModuloTailPcgsRep and IsNumeratorParentForExponentsRep,IsObject],0,COM_FUN(49));
InstallOtherMethod(ExponentsOfConjugate,"subset induced pcgs modulo tail-pcgs",true,[IsModuloPcgs and IsModuloTailPcgsRep and IsNumeratorParentForExponentsRep,IsPosInt,IsPosInt],0,COM_FUN(50));
InstallOtherMethod(ExponentsOfRelativePower,"subset induced pcgs modulo tail-pcgs",true,[IsModuloPcgs and IsModuloTailPcgsRep and IsNumeratorParentForExponentsRep,IsPosInt],0,COM_FUN(51));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/pcgsmodu.gi"

#F  file="lib/pcgspcg.gi" crc=-8838266
RANK_FILTER_LIST  := [ 63227064, 3, 32769, 4, 55692243, 2, 32769, 4, 
  55692243, 2, 41951068, 17, 55692243, 2, 32769, 4, 55692243, 2, 41951068, 
  17, 9758592, 76, 65767820, 5, 9758592, 76, 44275606, 6, 9758592, 76, 
  44275606, 6, 9758592, 76, 44275606, 6, 9758592, 76, 24093011, 29, 9758592, 
  76, 65077475, 29, 9758592, 76, 24093011, 29, 24093011, 29, 9758592, 76, 
  24093011, 29, 65077475, 29, 60800603, 52, 24093011, 29, 60800603, 52, 
  24093011, 29, 24093011, 29, 60800603, 52, 65077475, 29, 60800603, 52, 
  24093011, 29, 65077475, 29, 3278544, 49, 65767820, 5, 65767820, 5, 
  21839316, 49, 60947457, 109, 9758592, 76, 60947457, 109, 9758592, 76, 
  60947457, 109, 7665940, 19, 9758592, 76, 16671852, 103, 9758592, 76, 
  16671852, 103, 8193, 2, 9758592, 76, 60947457, 109, 17, 18, 9758592, 76, 
  60947457, 109, 17, 18, 9758592, 76, 60947457, 109, 21839316, 49, 10510429, 
  109, 9758592, 76, 10510429, 109, 9758592, 76, 10510429, 109, 7665940, 19, 
  9758592, 76, 33343703, 103, 9758592, 76, 33343703, 103, 8193, 2, 9758592, 
  76, 10510429, 109, 17, 18, 9758592, 76, 10510429, 109, 17, 18, 9758592, 76, 
  10510429, 109, 21839316, 49, 43855091, 109, 9758592, 76, 43855091, 109, 
  9758592, 76, 43855091, 109, 7665940, 19, 9758592, 76, 66688365, 103, 
  9758592, 76, 66688365, 103, 8193, 2, 9758592, 76, 43855091, 109, 17, 18, 
  9758592, 76, 43855091, 109, 17, 18, 9758592, 76, 43855091, 109, 9758592, 
  76, 7665940, 19, 7665940, 19, 9758592, 76, 7665940, 19, 9758592, 76, 
  65767820, 5, 7665940, 19, 4193180, 25, 1, 0, 16776287, 26, 1, 0, 4193180, 
  25, 1, 0, 7665940, 19, 16776287, 26, 1, 0, 7665940, 19, 4193180, 25, 1, 0, 
  4193180, 25, 1, 0, 8193, 2, 16776287, 26, 1, 0, 16776287, 26, 1, 0, 8193, 
  2, 4193180, 25, 1, 0, 16776287, 26, 1, 0, 16776287, 26, 65767820, 5, 
  7665940, 19, 50331304, 4, 50331304, 4 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/pcgspcg.gi", -8838266 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/pcgspcg.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/pcgspcg.gi");
elif COM_RESULT = 3  then
Revision.pcgspcg_gi:="@(#)$Id: pcgspcg.gi,v 4.47 2002/04/15 10:05:12 sal Exp $";
DeclareRepresentation("IsUnsortedPcgsRep",IsPcgsDefaultRep,[]);
DeclareRepresentation("IsSortedPcgsRep",IsUnsortedPcgsRep,[]);
InstallMethod(PcgsByPcSequenceNC,"elements family by rws with defining pcgs",true,[IsElementsFamilyByRws and HasDefiningPcgs,IsHomogeneousList],0,COM_FUN(1));
InstallMethod(PcgsByPcSequenceNC,"elements family by rws",true,[IsElementsFamilyByRws,IsHomogeneousList],0,COM_FUN(2));
InstallMethod(PcgsByPcSequenceNC,"elements family by rws, empty sequence",true,[IsElementsFamilyByRws,IsList and IsEmpty],0,COM_FUN(3));
InstallMethod(PcgsByPcSequence,true,[IsElementsFamilyByRws,IsHomogeneousList],0,COM_FUN(4));
InstallMethod(PcgsByPcSequence,true,[IsElementsFamilyByRws,IsList and IsEmpty],0,COM_FUN(5));
InstallMethod(SiftedPcElement,"family pcgs",IsCollsElms,[IsPcgs and IsFamilyPcgs,IsMultiplicativeElementWithInverse],0,COM_FUN(6));
InstallMethod(DepthOfPcElement,"family pcgs",IsCollsElms,[IsPcgs and IsFamilyPcgs,IsMultiplicativeElementWithInverseByRws],0,COM_FUN(7));
InstallMethod(ExponentsOfPcElement,"family pcgs",IsCollsElms,[IsPcgs and IsFamilyPcgs,IsMultiplicativeElementWithInverseByRws],0,COM_FUN(8));
InstallMethod(LeadingExponentOfPcElement,"family pcgs",IsCollsElms,[IsPcgs and IsFamilyPcgs,IsMultiplicativeElementWithInverseByRws],0,COM_FUN(9));
InstallMethod(PcElementByExponentsNC,"family pcgs",true,[IsPcgs and IsFamilyPcgs,IsRowVector and IsCyclotomicCollection],0,COM_FUN(10));
InstallMethod(PcElementByExponentsNC,"family pcgs, FFE",true,[IsPcgs and IsFamilyPcgs,IsRowVector and IsFFECollection],0,COM_FUN(11));
InstallOtherMethod(PcElementByExponentsNC,"family pcgs, index",true,[IsPcgs and IsFamilyPcgs,IsRowVector and IsCyclotomicCollection,IsRowVector and IsCyclotomicCollection],0,COM_FUN(12));
InstallOtherMethod(PcElementByExponentsNC,"family pcgs, basisind, FFE",true,[IsPcgs and IsFamilyPcgs,IsRowVector and IsCyclotomicCollection,IsRowVector and IsFFECollection],0,COM_FUN(13));
InstallMethod(PcElementByExponentsNC,"subset induced wrt family pcgs",true,[IsPcgs and IsParentPcgsFamilyPcgs and IsSubsetInducedPcgsRep and IsPrimeOrdersPcgs,IsRowVector and IsCyclotomicColle\
ction],0,COM_FUN(14));
InstallOtherMethod(PcElementByExponentsNC,"subset induced wrt family pcgs, index",true,[IsPcgs and IsParentPcgsFamilyPcgs and IsSubsetInducedPcgsRep and IsPrimeOrdersPcgs,IsRowVector and IsCyclotomicColle\
ction,IsRowVector and IsCyclotomicCollection],0,COM_FUN(15));
InstallMethod(PcElementByExponentsNC,"subset induced wrt family pcgs, FFE",true,[IsPcgs and IsParentPcgsFamilyPcgs and IsSubsetInducedPcgsRep and IsPrimeOrdersPcgs,IsRowVector and IsFFECollection],0,COM_FUN(16));
InstallOtherMethod(PcElementByExponentsNC,"subset induced wrt family pcgs, FFE,index",true,[IsPcgs and IsParentPcgsFamilyPcgs and IsSubsetInducedPcgsRep and IsPrimeOrdersPcgs,IsRowVector and IsCyclotomicColle\
ction,IsRowVector and IsFFECollection],0,COM_FUN(17));
InstallGlobalFunction(DoExponentsConjLayerFampcgs,COM_FUN(18));
InstallMethod(ExponentsConjugateLayer,"subset induced pcgs",IsCollsElmsElms,[IsTailInducedPcgsRep and IsParentPcgsFamilyPcgs,IsMultiplicativeElementWithInverse,IsMultiplicativeElementWithInverse],0,COM_FUN(19));
InstallMethod(CanonicalPcElement,"tail induced pcgs, 8bits word",IsCollsElms,[IsInducedPcgs and IsTailInducedPcgsRep and IsParentPcgsFamilyPcgs,IsMultiplicativeElementWithInverseByRws and Is8BitsPcWordRep],0,COM_FUN(20));
InstallMethod(DepthOfPcElement,"family pcgs (8 bits)",IsCollsElms,[IsPcgs and IsFamilyPcgs,IsMultiplicativeElementWithInverseByRws and Is8BitsPcWordRep],0,8Bits_DepthOfPcElement);
InstallMethod(ExponentOfPcElement,"family pcgs (8bits)",IsCollsElmsX,[IsPcgs and IsFamilyPcgs,IsMultiplicativeElementWithInverseByRws and Is8BitsPcWordRep,IsPosInt],0,8Bits_ExponentOfPcElement);
InstallMethod(ExponentsOfPcElement,"family pcgs/8 bit",IsCollsElms,[IsPcgs and IsFamilyPcgs,Is8BitsPcWordRep],0,8Bits_ExponentsOfPcElement);
InstallOtherMethod(ExponentsOfPcElement,"family pcgs/8 bit",IsCollsElmsX,[IsPcgs and IsFamilyPcgs,Is8BitsPcWordRep,IsList],0,COM_FUN(21));
InstallMethod(HeadPcElementByNumber,"family pcgs (8bits)",IsCollsElmsX,[IsPcgs and IsFamilyPcgs,IsMultiplicativeElementWithInverseByRws and Is8BitsPcWordRep,IsInt],0,COM_FUN(22));
InstallMethod(CleanedTailPcElement,"family pcgs (8bits)",IsCollsElmsX,[IsPcgs and IsFamilyPcgs,IsMultiplicativeElementWithInverseByRws and Is8BitsPcWordRep,IsInt],0,COM_FUN(23));
InstallMethod(LeadingExponentOfPcElement,"family pcgs (8 bits)",IsCollsElms,[IsPcgs and IsFamilyPcgs,IsMultiplicativeElementWithInverseByRws and Is8BitsPcWordRep],0,8Bits_LeadingExponentOfPcElement);
InstallMethod(CanonicalPcElement,"tail induced pcgs, 16bits word",IsCollsElms,[IsInducedPcgs and IsTailInducedPcgsRep and IsParentPcgsFamilyPcgs,IsMultiplicativeElementWithInverseByRws and Is16BitsPcWordRep],0,COM_FUN(24));
InstallMethod(DepthOfPcElement,"family pcgs (16 bits)",IsCollsElms,[IsPcgs and IsFamilyPcgs,IsMultiplicativeElementWithInverseByRws and Is16BitsPcWordRep],0,16Bits_DepthOfPcElement);
InstallMethod(ExponentOfPcElement,"family pcgs (16bits)",IsCollsElmsX,[IsPcgs and IsFamilyPcgs,IsMultiplicativeElementWithInverseByRws and Is16BitsPcWordRep,IsPosInt],0,16Bits_ExponentOfPcElement);
InstallMethod(ExponentsOfPcElement,"family pcgs/16 bit",IsCollsElms,[IsPcgs and IsFamilyPcgs,Is16BitsPcWordRep],0,16Bits_ExponentsOfPcElement);
InstallOtherMethod(ExponentsOfPcElement,"family pcgs/16 bit",IsCollsElmsX,[IsPcgs and IsFamilyPcgs,Is16BitsPcWordRep,IsList],0,COM_FUN(25));
InstallMethod(HeadPcElementByNumber,"family pcgs (16bits)",IsCollsElmsX,[IsPcgs and IsFamilyPcgs,IsMultiplicativeElementWithInverseByRws and Is16BitsPcWordRep,IsInt],0,COM_FUN(26));
InstallMethod(CleanedTailPcElement,"family pcgs (16bits)",IsCollsElmsX,[IsPcgs and IsFamilyPcgs,IsMultiplicativeElementWithInverseByRws and Is16BitsPcWordRep,IsInt],0,COM_FUN(27));
InstallMethod(LeadingExponentOfPcElement,"family pcgs (16 bits)",IsCollsElms,[IsPcgs and IsFamilyPcgs,IsMultiplicativeElementWithInverseByRws and Is16BitsPcWordRep],0,16Bits_LeadingExponentOfPcElement);
InstallMethod(CanonicalPcElement,"tail induced pcgs, 32bits word",IsCollsElms,[IsInducedPcgs and IsTailInducedPcgsRep and IsParentPcgsFamilyPcgs,IsMultiplicativeElementWithInverseByRws and Is32BitsPcWordRep],0,COM_FUN(28));
InstallMethod(DepthOfPcElement,"family pcgs (32 bits)",IsCollsElms,[IsPcgs and IsFamilyPcgs,IsMultiplicativeElementWithInverseByRws and Is32BitsPcWordRep],0,32Bits_DepthOfPcElement);
InstallMethod(ExponentOfPcElement,"family pcgs (32bits)",IsCollsElmsX,[IsPcgs and IsFamilyPcgs,IsMultiplicativeElementWithInverseByRws and Is32BitsPcWordRep,IsPosInt],0,32Bits_ExponentOfPcElement);
InstallMethod(ExponentsOfPcElement,"family pcgs/32 bit",IsCollsElms,[IsPcgs and IsFamilyPcgs,Is32BitsPcWordRep],0,32Bits_ExponentsOfPcElement);
InstallOtherMethod(ExponentsOfPcElement,"family pcgs/32 bit",IsCollsElmsX,[IsPcgs and IsFamilyPcgs,Is32BitsPcWordRep,IsList],0,COM_FUN(29));
InstallMethod(HeadPcElementByNumber,"family pcgs (32bits)",IsCollsElmsX,[IsPcgs and IsFamilyPcgs,IsMultiplicativeElementWithInverseByRws and Is32BitsPcWordRep,IsInt],0,COM_FUN(30));
InstallMethod(CleanedTailPcElement,"family pcgs (32bits)",IsCollsElmsX,[IsPcgs and IsFamilyPcgs,IsMultiplicativeElementWithInverseByRws and Is32BitsPcWordRep,IsInt],0,COM_FUN(31));
InstallMethod(LeadingExponentOfPcElement,"family pcgs (32 bits)",IsCollsElms,[IsPcgs and IsFamilyPcgs,IsMultiplicativeElementWithInverseByRws and Is32BitsPcWordRep],0,32Bits_LeadingExponentOfPcElement);
InstallMethod(ExponentsOfConjugate,"family pcgs: look up",true,[IsPcgs and IsFamilyPcgs,IsPosInt,IsPosInt],0,COM_FUN(32));
InstallMethod(ExponentsOfRelativePower,"family pcgs: look up",true,[IsPcgs and IsFamilyPcgs,IsPosInt],0,COM_FUN(33));
InstallMethod(CleanedTailPcElement,"family pcgs",IsCollsElmsX,[IsPcgs and IsFamilyPcgs,IsMultiplicativeElementWithInverse,IsPosInt],0,COM_FUN(34));
InstallMethod(DepthOfPcElement,"unsorted pcgs",IsCollsElms,[IsPcgs and IsUnsortedPcgsRep,IsObject],0,COM_FUN(35));
InstallMethod(DepthOfPcElement,"sorted pcgs",IsCollsElms,[IsPcgs and IsSortedPcgsRep,IsObject],0,COM_FUN(36));
InstallMethod(ExponentOfPcElement,"unsorted pcgs",IsCollsElmsX,[IsPcgs and IsUnsortedPcgsRep,IsObject,IsPosInt],0,COM_FUN(37));
InstallMethod(ExponentOfPcElement,"sorted pcgs",IsCollsElmsX,[IsPcgs and IsSortedPcgsRep,IsObject,IsPosInt],0,COM_FUN(38));
InstallMethod(ExponentsOfPcElement,"unsorted pcgs",IsCollsElms,[IsPcgs and IsUnsortedPcgsRep,IsObject],0,COM_FUN(39));
InstallOtherMethod(ExponentsOfPcElement,"unsorted pcgs/range",IsCollsElmsX,[IsPcgs and IsUnsortedPcgsRep,IsObject,IsList],0,COM_FUN(40));
ExpPcElmSortedFun:=COM_FUN(41);
InstallMethod(ExponentsOfPcElement,"sorted pcgs",IsCollsElms,[IsPcgs and IsSortedPcgsRep,IsObject],0,COM_FUN(42));
InstallOtherMethod(ExponentsOfPcElement,"sorted pcgs/range",IsCollsElmsX,[IsPcgs and IsSortedPcgsRep,IsObject,IsList],0,ExpPcElmSortedFun);
InstallMethod(LeadingExponentOfPcElement,"unsorted pcgs",IsCollsElms,[IsPcgs and IsUnsortedPcgsRep,IsObject],0,COM_FUN(43));
InstallMethod(LeadingExponentOfPcElement,"sorted pcgs",IsCollsElms,[IsPcgs and IsSortedPcgsRep,IsObject],0,COM_FUN(44));
InstallMethod(CleanedTailPcElement,"sorted pcgs - defer to sorting pcgs",IsCollsElmsX,[IsPcgs and IsSortedPcgsRep,IsMultiplicativeElementWithInverse,IsPosInt],0,COM_FUN(45));
InstallMethod(Order,"method for a pc-element",HasDefiningPcgs,[IsMultiplicativeElementWithOne],3,COM_FUN(46));
InstallMethod(PrimePowerComponents,"method for a pc element",HasDefiningPcgs,[IsMultiplicativeElementWithOne],0,COM_FUN(47));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/pcgspcg.gi"

#F  file="lib/pcgscomp.gi" crc=-12410418
RANK_FILTER_LIST  := [ 1985, 1, 32769, 4, 1985, 1, 41951068, 17, 1985, 1, 
  32769, 4, 1985, 1, 41951068, 17, 29419057, 21, 58719912, 21, 1, 0, 
  58719912, 21, 58719912, 21 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/pcgscomp.gi", -12410418 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/pcgscomp.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/pcgscomp.gi");
elif COM_RESULT = 3  then
Revision.pcgscomp_gi:="@(#)$Id: pcgscomp.gi,v 4.27.4.1 2005/10/14 08:45:40 gap Exp $";
InstallMethod(PcgsByPcSequenceNC,"pc series",true,[IsFamily,IsHomogeneousList],0,COM_FUN(1));
InstallMethod(PcgsByPcSequenceNC,"pc series, empty sequence",true,[IsFamily,IsList and IsEmpty],0,COM_FUN(2));
InstallMethod(PcgsByPcSequence,true,[IsFamily,IsHomogeneousList],0,COM_FUN(3));
InstallMethod(PcgsByPcSequence,true,[IsFamily,IsList and IsEmpty],0,COM_FUN(4));
InstallMethod(Pcgs,"generic method using CompositionSeries",true,[IsGroup],0,COM_FUN(5));
InstallMethod(ExponentsOfPcElement,"pc series",IsCollsElms,[IsPcgs,IsObject],0,COM_FUN(6));
InstallMethod(RelativeOrders,"pc series",true,[IsPcgs],0,COM_FUN(7));
InstallMethod(PcSeries,"construct subgroups",true,[IsPcgs],0,COM_FUN(8));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/pcgscomp.gi"

#F  file="lib/pcgsperm.gi" crc=-47199965
RANK_FILTER_LIST  := [ 64830489, 29, 9311293, 30, 58470689, 26, 58470689, 26, 
  62973024, 30, 50331469, 31, 20845897, 27, 20845897, 27, 11146539, 29, 
  33562160, 33, 38516246, 32, 11146539, 29, 33562160, 33, 11146539, 29, 513, 
  8, 11146539, 29, 513, 8, 7665940, 19, 11146539, 29, 513, 8, 11146539, 29, 
  513, 8, 11146539, 29, 513, 8, 26132143, 27, 11146539, 29, 513, 8, 41951068, 
  17, 11146539, 29, 513, 8, 7665940, 19, 26801537, 31, 513, 8, 513, 8, 5, 1, 
  62973024, 30, 62973024, 30, 62973024, 30, 62973024, 30, 26790377, 37 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/pcgsperm.gi", -47199965 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/pcgsperm.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/pcgsperm.gi");
elif COM_RESULT = 3  then
Revision.pcgsperm_gi:="@(#)$Id: pcgsperm.gi,v 4.120.2.3 2005/12/05 20:42:46 gap Exp $";
DeclareRepresentation("IsMemberPcSeriesPermGroup",IsPermGroup,["noInSeries"]);
InstallGlobalFunction(AddNormalizingElementPcgs,COM_FUN(1));
InstallGlobalFunction(ExtendSeriesPermGroup,COM_FUN(2));
InstallGlobalFunction(TryPcgsPermGroup,COM_FUN(3));
InstallGlobalFunction(PcgsStabChainSeries,COM_FUN(4));
BindGlobal("NorSerPermPcgs",COM_FUN(5));
InstallMethod(EANormalSeriesByPcgs,"perm group rep",true,[IsPcgs and IsPcgsElementaryAbelianSeries and IsPcgsPermGroupRep],0,NorSerPermPcgs);
InstallOtherMethod(EANormalSeriesByPcgs,"perm group modulo rep",true,[IsModuloPcgsPermGroupRep and IsPcgsElementaryAbelianSeries],0,NorSerPermPcgs);
InstallGlobalFunction(PcgsMemberPcSeriesPermGroup,COM_FUN(6));
InstallGlobalFunction(ExponentsOfPcElementPermGroup,COM_FUN(7));
InstallGlobalFunction(PermpcgsPcGroupPcgs,COM_FUN(8));
InstallGlobalFunction(SolvableNormalClosurePermGroup,COM_FUN(9));
InstallOtherMethod(NumeratorOfModuloPcgs,true,[IsModuloPcgsPermGroupRep],0,COM_FUN(10));
InstallOtherMethod(DenominatorOfModuloPcgs,true,[IsModuloPcgsPermGroupRep],0,COM_FUN(11));
InstallMethod(Pcgs,"Sims's method",true,[IsPermGroup],100,COM_FUN(12));
InstallMethod(Pcgs,"tail of perm pcgs",true,[IsMemberPcSeriesPermGroup],100,PcgsMemberPcSeriesPermGroup);
InstallMethod(GroupOfPcgs,true,[IsPcgs and IsPcgsPermGroupRep],0,COM_FUN(13));
InstallMethod(PcSeries,true,[IsPcgs and IsPcgsPermGroupRep],0,COM_FUN(14));
InstallGlobalFunction(TailOfPcgsPermGroup,COM_FUN(15));
InstallMethod(InducedPcgsByPcSequenceNC,"tail of perm pcgs",true,[IsPcgsPermGroupRep and IsPrimeOrdersPcgs and IsPcgs,IsList and IsPermCollection],0,COM_FUN(16));
InstallMethod(InducedPcgsWrtHomePcgs,"tail of perm pcgs",true,[IsMemberPcSeriesPermGroup and HasHomePcgs],0,COM_FUN(17));
InstallMethod(ExtendedPcgs,"perm pcgs",true,[IsPcgs and IsPcgsPermGroupRep and IsPrimeOrdersPcgs,IsList and IsPermCollection],0,COM_FUN(18));
InstallMethod(DepthOfPcElement,"permpcgs",true,[IsPcgs and IsPcgsPermGroupRep and IsPrimeOrdersPcgs,IsPerm],0,COM_FUN(19));
InstallOtherMethod(DepthOfPcElement,"permpcgs,start",true,[IsPcgs and IsPcgsPermGroupRep and IsPrimeOrdersPcgs,IsPerm,IsPosInt],0,COM_FUN(20));
InstallMethod(LeadingExponentOfPcElement,true,[IsPcgs and IsPcgsPermGroupRep and IsPrimeOrdersPcgs,IsPerm],0,COM_FUN(21));
InstallMethod(ExponentsOfPcElement,"perm group",true,[IsPcgs and IsPcgsPermGroupRep and IsPrimeOrdersPcgs,IsPerm],0,COM_FUN(22));
InstallOtherMethod(ExponentsOfPcElement,"perm group with positions",true,[IsPcgs and IsPcgsPermGroupRep and IsPrimeOrdersPcgs,IsPerm,IsList and IsCyclotomicCollection],0,COM_FUN(23));
InstallOtherMethod(ExponentsOfPcElement,"perm group with 0 positions",true,[IsPcgs and IsPcgsPermGroupRep and IsPrimeOrdersPcgs,IsPerm,IsList and IsEmpty],0,COM_FUN(24));
InstallMethod(ExponentOfPcElement,true,[IsPcgs and IsPcgsPermGroupRep and IsPrimeOrdersPcgs,IsPerm,IsPosInt],0,COM_FUN(25));
InstallOtherMethod(RepresentativeActionOp,"cycle structure comparison for solvable perm groups",true,[IsPermGroup and CanEasilyComputePcgs,IsPerm,IsPerm,IsFunction],0,COM_FUN(26));
InstallMethod(IsomorphismPcGroup,true,[IsPermGroup],0,COM_FUN(27));
BindGlobal("EpiPcByModpcgs",COM_FUN(28));
InstallMethod(ModuloPcgs,"for permutation groups",IsIdenticalObj,[IsPermGroup,IsPermGroup],0,COM_FUN(29));
InstallMethod(PcgsElementaryAbelianSeries,"perm group",true,[IsPermGroup],0,COM_FUN(30));
InstallMethod(MaximalSubgroupClassReps,"solvable perm group",true,[IsPermGroup and CanEasilyComputePcgs and IsFinite],0,COM_FUN(31));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/pcgsperm.gi"

#F  file="lib/pcgsnice.gi" crc=-15412413
RANK_FILTER_LIST  := [ 29418502, 222, 58719357, 222, 65767820, 5, 58719357, 
  222, 65767820, 5, 7665940, 19, 58719357, 222, 65767820, 5, 58719357, 222, 
  65767820, 5, 58719357, 222, 65767820, 5, 26132143, 27, 58719357, 222, 
  65767820, 5, 41951068, 17, 58719357, 222, 65767820, 5, 7665940, 19 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/pcgsnice.gi", -15412413 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/pcgsnice.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/pcgsnice.gi");
elif COM_RESULT = 3  then
Revision.pcgsnice_gi:="@(#)$Id: pcgsnice.gi,v 4.9 2002/04/15 10:05:12 sal Exp $";
InstallMethod(Pcgs,"via niceomorphism",true,[IsGroup and IsHandledByNiceMonomorphism],0,COM_FUN(1));
AttributeMethodByNiceMonomorphismCollElm(DepthOfPcElement,[IsPcgs,IsMultiplicativeElementWithInverse]);
InstallOtherMethod(DepthOfPcElement,true,[IsPcgs and IsHandledByNiceMonomorphism,IsMultiplicativeElementWithInverse,IsPosInt],0,COM_FUN(2));
AttributeMethodByNiceMonomorphismCollElm(LeadingExponentOfPcElement,[IsPcgs,IsMultiplicativeElementWithInverse]);
AttributeMethodByNiceMonomorphismCollElm(ExponentsOfPcElement,[IsPcgs,IsMultiplicativeElementWithInverse]);
InstallOtherMethod(ExponentsOfPcElement,true,[IsPcgs and IsHandledByNiceMonomorphism,IsMultiplicativeElementWithInverse,IsList and IsCyclotomicCollection],0,COM_FUN(3));
InstallOtherMethod(ExponentsOfPcElement,"perm group with 0 positions",true,[IsPcgs and IsHandledByNiceMonomorphism,IsMultiplicativeElementWithInverse,IsList and IsEmpty],0,COM_FUN(4));
InstallMethod(ExponentOfPcElement,"via nicoemorphism",true,[IsPcgs and IsHandledByNiceMonomorphism,IsMultiplicativeElementWithInverse,IsPosInt],0,COM_FUN(5));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/pcgsnice.gi"

#F  file="lib/pcgsspec.gi" crc=92648693
RANK_FILTER_LIST  := [ 15282614, 25, 10223122, 25, 15282614, 25, 15282614, 
  25, 29419057, 21, 29419057, 21, 66740907, 29, 29419057, 21, 66740907, 29, 
  29419057, 21, 53525179, 22, 61083797, 22, 26214131, 23, 26214131, 23, 
  26214131, 23, 29419057, 21, 58364419, 47, 58364419, 47, 15282614, 25, 
  65116071, 22, 66740907, 29, 66740907, 29, 65116071, 22, 66740907, 29 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/pcgsspec.gi", 92648693 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/pcgsspec.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/pcgsspec.gi");
elif COM_RESULT = 3  then
Revision.pcgsspec_gi:="@(#)$Id: pcgsspec.gi,v 4.61.2.1 2005/10/14 08:45:40 gap Exp $";
PrimePowerPcSequence:=COM_FUN(1);
ModifyPcgs:=COM_FUN(2);
PcgsSystemWithWf:=COM_FUN(3);
PcgsSystemLGSeries:=COM_FUN(4);
LeastBadHallLayer:=COM_FUN(5);
PcgsSystemWithHallSystem:=COM_FUN(6);
LeastBadComplementLayer:=COM_FUN(7);
PcgsSystemWithComplementSystem:=COM_FUN(8);
InstallMethod(SpecialPcgs,"method for special pcgs",true,[IsSpecialPcgs],10,IdFunc);
InstallMethod(SpecialPcgs,"generic method for pcgs",true,[IsPcgs and IsFiniteOrdersPcgs and IsPrimeOrdersPcgs],0,COM_FUN(9));
InstallMethod(LGHeads,"for special pcgs",true,[IsSpecialPcgs],0,COM_FUN(10));
InstallMethod(LGTails,"for special pcgs",true,[IsSpecialPcgs],0,COM_FUN(11));
InstallOtherMethod(SpecialPcgs,"generic method for groups",true,[IsGroup],0,COM_FUN(12));
InstallOtherMethod(SpecialPcgs,"last resort method which tests solvability",true,[IsGroup],0,COM_FUN(13));
InstallMethod(IsomorphismSpecialPcGroup,"method for pc groups",true,[IsPcGroup],0,COM_FUN(14));
InstallMethod(IsomorphismSpecialPcGroup,"generic method for groups",true,[IsGroup],0,COM_FUN(15));
InstallOtherMethod(InducedPcgsWrtSpecialPcgs,"method for pc groups",true,[IsPcGroup],0,COM_FUN(16));
InstallOtherMethod(InducedPcgsWrtSpecialPcgs,"generic method for groups",true,[IsGroup],0,COM_FUN(17));
IndPcgsWrtSpecFromFamOrHome:=COM_FUN(18);
InstallOtherMethod(InducedPcgsWrtSpecialPcgs,"for groups that have already an induced pcgs wrt home pcgs",true,[IsGroup and HasInducedPcgsWrtHomePcgs],0,IndPcgsWrtSpecFromFamOrHome);
InstallOtherMethod(InducedPcgsWrtSpecialPcgs,"for groups that have already an induced pcgs wrt family pcgs",true,[IsGroup and HasInducedPcgsWrtFamilyPcgs],0,IndPcgsWrtSpecFromFamOrHome);
InstallMethod(LGWeights,"for induced wrt special",true,[IsInducedPcgsWrtSpecialPcgs],0,COM_FUN(19));
InstallMethod(LGLayers,"for induced wrt special",true,[IsInducedPcgsWrtSpecialPcgs],0,COM_FUN(20));
InstallMethod(LGFirst,"for induced wrt special",true,[IsInducedPcgsWrtSpecialPcgs],0,COM_FUN(21));
InstallMethod(LGLength,"for groups",true,[IsGroup],0,COM_FUN(22));
InstallMethod(PClassPGroup,"for groups with special pcgs",true,[IsPGroup and HasSpecialPcgs],1,COM_FUN(23));
InstallMethod(RankPGroup,"for groups with special pcgs",true,[IsPGroup and HasSpecialPcgs],1,COM_FUN(24));
SpecialPcgsSubgroup:=COM_FUN(25);
SpecialPcgsFactor:=COM_FUN(26);
InstallMethod(IndicesEANormalSteps,"special pcgs: LGFirst",true,[IsSpecialPcgs],0,LGFirst);
DoCentralSeriesPcgsIfNilpot:=COM_FUN(27);
InstallOtherMethod(PcgsCentralSeries,"if special pcgs is known",true,[HasSpecialPcgs],0,DoCentralSeriesPcgsIfNilpot);
InstallOtherMethod(PcgsCentralSeries,"for pc groups use SpecialPcgs",true,[IsPcGroup],0,DoCentralSeriesPcgsIfNilpot);
InstallOtherMethod(PcgsPCentralSeriesPGroup,"for pc groups use SpecialPcgs",true,[IsPcGroup],0,DoCentralSeriesPcgsIfNilpot);
PcgsElAbSerFromSpecPcgs:=COM_FUN(28);
InstallOtherMethod(PcgsElementaryAbelianSeries,"if special pcgs is known",true,[HasSpecialPcgs],0,PcgsElAbSerFromSpecPcgs);
InstallMethod(PcgsElementaryAbelianSeries,"for PCgroups via SpecialPcgs",true,[IsPcGroup],0,PcgsElAbSerFromSpecPcgs);
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/pcgsspec.gi"

#F  file="lib/grppc.gi" crc=93880368
RANK_FILTER_LIST  := [ 29418292, 22, 17603834, 22, 29418292, 22, 66726988, 
  31, 29419057, 21, 66740907, 29, 58719912, 21, 29419057, 21, 58719912, 21, 
  29419057, 21, 58719912, 21, 65817608, 22, 29419057, 21, 32046974, 22, 
  29418292, 22, 17603834, 22, 53525179, 22, 29404373, 24, 65817608, 22, 
  29419057, 21, 29419057, 21, 45448315, 13, 45448315, 13, 18660446, 8, 
  41951068, 17, 18660446, 8, 65767820, 5, 60355684, 23, 65767820, 5, 
  17353692, 23, 65767820, 5, 44762397, 23, 39343238, 23, 39343238, 23, 
  827188, 23, 827188, 23, 60355684, 23, 29419057, 21, 29419057, 21, 58719912, 
  21, 8193, 2, 58412696, 30, 5, 1, 5, 1, 29419057, 21, 58412696, 30, 5, 1, 5, 
  1, 29419057, 21, 8193, 2, 58412696, 30, 5, 1, 5, 1, 58719912, 21, 58412696, 
  30, 5, 1, 5, 1, 17603834, 22, 17603834, 22, 17603834, 22, 65767820, 5, 
  17603834, 22, 17603834, 22, 17603834, 22, 65767820, 5, 17603834, 22, 
  17603834, 22, 60356449, 22, 29419057, 21, 60356449, 22, 7665940, 19, 
  29419057, 21, 7665940, 19, 8193, 2, 58412696, 30, 5, 1, 29419057, 21, 
  58412696, 30, 5, 1, 58719912, 21, 58412696, 30, 5, 1, 29419057, 21, 8193, 
  2, 58412696, 30, 5, 1, 17603834, 22, 17603834, 22, 60345289, 27, 60345289, 
  27, 65767820, 5, 60345289, 27, 60345289, 27, 60345289, 27, 65767820, 5, 
  65767820, 5, 5, 1, 60356449, 22, 60356449, 22, 65767820, 5, 60356449, 22, 
  60356449, 22, 29419057, 21, 29419057, 21, 29419057, 21, 1, 0, 67105912, 7, 
  66740907, 29, 66740907, 29, 60345289, 27, 66740907, 29, 8193, 2, 66740907, 
  29, 66740907, 29, 66740907, 29, 66740907, 29, 66740907, 29, 5, 1, 29419057, 
  21, 60356449, 22, 64094577, 23, 62973024, 30, 64094577, 23, 64094577, 23, 
  66740907, 29, 11226115, 13, 45137161, 33 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grppc.gi", 93880368 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grppc.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grppc.gi");
elif COM_RESULT = 3  then
Revision.grppc_gi:="@(#)$Id: grppc.gi,v 4.143.2.4 2005/12/03 17:11:20 gap Exp $";
InstallMethod(CanonicalPcgsWrtFamilyPcgs,true,[IsGroup and HasFamilyPcgs],0,COM_FUN(1));
InstallMethod(CanonicalPcgsWrtHomePcgs,true,[IsGroup and HasHomePcgs],0,COM_FUN(2));
InstallMethod(InducedPcgsWrtFamilyPcgs,true,[IsGroup and HasFamilyPcgs],0,COM_FUN(3));
InstallMethod(InducedPcgsWrtFamilyPcgs,"whole family",true,[IsPcGroup and IsWholeFamily],0,FamilyPcgs);
InstallMethod(InducedPcgsWrtHomePcgs,"from generators",true,[IsGroup],0,COM_FUN(4));
InstallMethod(InducedPcgsWrtHomePcgs,"pc group: home=family",true,[IsPcGroup],0,InducedPcgsWrtFamilyPcgs);
InstallMethod(InducedPcgs,"cache pcgs",true,[IsPcgs,IsGroup],2,COM_FUN(5));
InstallMethod(InducedPcgsOp,"generic method",IsIdenticalObj,[IsPcgs,IsGroup],COM_FUN(6));
InstallMethod(InducedPcgsOp,"sift existing pcgs",IsIdenticalObj,[IsPcgs,IsGroup and HasPcgs],COM_FUN(7));
InstallMethod(ComputedInducedPcgses,"default method",[IsGroup],COM_FUN(8));
InstallGlobalFunction(SetInducedPcgs,COM_FUN(9));
InstallMethod(Pcgs,"fail if insolvable",true,[HasIsSolvableGroup],SUM_FLAGS,COM_FUN(10));
InstallMethod(Pcgs,"for a group with known family pcgs",true,[IsGroup and HasFamilyPcgs],0,InducedPcgsWrtFamilyPcgs);
InstallMethod(Pcgs,"for a group with known home pcgs",true,[IsGroup and HasHomePcgs],1,InducedPcgsWrtHomePcgs);
InstallMethod(Pcgs,"take induced pcgs",true,[IsGroup and HasInducedPcgsWrtHomePcgs],SUM_FLAGS,InducedPcgsWrtHomePcgs);
InstallMethod(Pcgs,"for a group containing the whole family and with known family pcgs",true,[IsGroup and HasFamilyPcgs and IsWholeFamily],0,FamilyPcgs);
InstallImmediateMethod(GeneralizedPcgs,IsGroup and HasPcgs,0,Pcgs);
InstallMethod(HomePcgs,true,[IsGroup],0,COM_FUN(11));
InstallMethod(PcgsChiefSeries,"compute chief series and pcgs",true,[IsGroup],0,COM_FUN(12));
InstallMethod(GroupWithGenerators,"method for pc elements collection",true,[IsCollection and IsMultiplicativeElementWithInverseByPolycyclicCollectorCollection],10,COM_FUN(13));
InstallOtherMethod(GroupWithGenerators,"method for pc collection and identity element",IsCollsElms,[IsCollection and IsMultiplicativeElementWithInverseByPolycyclicCollectorCollection,IsMultiplicativeElementWithInverseByPolycyclicCollector],0,COM_FUN(14));
InstallOtherMethod(GroupWithGenerators,"method for empty pc collection and identity element",true,[IsList and IsEmpty,IsMultiplicativeElementWithInverseByPolycyclicCollector],10,COM_FUN(15));
InstallMethod(\in,"for pc group",IsElmsColls,[IsMultiplicativeElementWithInverse,IsGroup and HasFamilyPcgs and CanEasilyComputePcgs],2,COM_FUN(16));
InstallMethod(\in,"for pcgs computable groups with home pcgs",IsElmsColls,[IsMultiplicativeElementWithInverse,IsGroup and HasInducedPcgsWrtHomePcgs and CanEasilyComputePcgs],1,COM_FUN(17));
InstallMethod(\in,"for pcgs computable groups with induced pcgs",IsElmsColls,[IsMultiplicativeElementWithInverse,IsGroup and HasComputedInducedPcgses and CanEasilyComputePcgs],0,COM_FUN(18));
InstallMethod(\=,"pcgs computable groups using home pcgs",IsIdenticalObj,[IsGroup and HasHomePcgs and HasCanonicalPcgsWrtHomePcgs,IsGroup and HasHomePcgs and HasCanonicalPcgsWrtHomePcgs],0,COM_FUN(19));
InstallMethod(\=,"pcgs computable groups using family pcgs",IsIdenticalObj,[IsGroup and HasFamilyPcgs and HasCanonicalPcgsWrtFamilyPcgs,IsGroup and HasFamilyPcgs and HasCanonicalPcgsWrtFamilyPcgs],0,COM_FUN(20));
InstallMethod(IsSubset,"pcgs computable groups",IsIdenticalObj,[IsGroup and HasFamilyPcgs and CanEasilyComputePcgs,IsGroup],0,COM_FUN(21));
InstallMethod(SubgroupByPcgs,"subgroup with pcgs",true,[IsGroup,IsPcgs],0,COM_FUN(22));
InstallGlobalFunction(VectorSpaceByPcgsOfElementaryAbelianGroup,COM_FUN(23));
InstallGlobalFunction(LinearActionLayer,COM_FUN(24));
InstallGlobalFunction(AffineActionLayer,COM_FUN(25));
InstallMethod(AffineAction,"generators",true,[IsList,IsMatrix,IsFunction,IsFunction],0,COM_FUN(26));
InstallOtherMethod(AffineAction,"group",true,[IsGroup,IsMatrix,IsFunction,IsFunction],0,COM_FUN(27));
InstallOtherMethod(AffineAction,"group2",true,[IsGroup,IsList,IsMatrix,IsFunction,IsFunction],0,COM_FUN(28));
InstallOtherMethod(AffineAction,"pcgs",true,[IsPcgs,IsMatrix,IsFunction,IsFunction],0,COM_FUN(29));
InstallMethod(ClosureGroup,"groups with home pcgs",IsIdenticalObj,[IsGroup and HasHomePcgs,IsGroup and HasHomePcgs],0,COM_FUN(30));
InstallMethod(ClosureGroup,"groups with home pcgs",IsCollsElms,[IsGroup and HasHomePcgs,IsMultiplicativeElementWithInverse],0,COM_FUN(31));
InstallMethod(CommutatorSubgroup,"groups with home pcgs",true,[IsGroup and HasHomePcgs,IsGroup and HasHomePcgs],0,COM_FUN(32));
InstallMethod(ConjugateGroup,"groups with home pcgs",IsCollsElms,[IsGroup and HasHomePcgs,IsMultiplicativeElementWithInverse],0,COM_FUN(33));
InstallMethod(ConjugateSubgroups,"groups with home pcgs",IsIdenticalObj,[IsGroup and HasHomePcgs,IsGroup and HasHomePcgs],0,COM_FUN(34));
InstallMethod(CoreOp,"pcgs computable groups",true,[IsGroup and CanEasilyComputePcgs,IsGroup],0,COM_FUN(35));
InstallMethod(EulerianFunction,"pcgs computable groups using special pcgs",true,[IsGroup and CanEasilyComputePcgs,IsPosInt],0,COM_FUN(36));
RedispatchOnCondition(EulerianFunction,true,[IsGroup,IsPosInt],[IsSolvableGroup,IsPosInt],1);
InstallMethod(LinearAction,true,[IsList,IsMatrix,IsFunction],0,COM_FUN(37));
InstallOtherMethod(LinearAction,true,[IsGroup,IsMatrix,IsFunction],0,COM_FUN(38));
InstallOtherMethod(LinearAction,true,[IsPcgs,IsMatrix,IsFunction],0,COM_FUN(39));
InstallOtherMethod(LinearAction,true,[IsGroup,IsList,IsMatrix,IsFunction],0,COM_FUN(40));
InstallMethod(NormalClosureOp,"groups with home pcgs",true,[IsGroup and HasHomePcgs,IsGroup and HasHomePcgs],0,COM_FUN(41));
InstallMethod(Random,"pcgs computable groups",true,[IsGroup and CanEasilyComputePcgs and IsFinite],0,COM_FUN(42));
BindGlobal("CentralizerSolvableGroup",COM_FUN(43));
InstallMethod(CentralizerOp,"pcgs computable group and element",IsCollsElms,[IsGroup and CanEasilyComputePcgs and IsFinite,IsMultiplicativeElementWithInverse],0,COM_FUN(44));
InstallMethod(CentralizerOp,"pcgs computable groups",IsIdenticalObj,[IsGroup and CanEasilyComputePcgs and IsFinite,IsGroup and CanEasilyComputePcgs and IsFinite],0,COM_FUN(45));
InstallOtherMethod(RepresentativeActionOp,"element conjugacy in pcgs computable groups",IsCollsElmsElmsX,[IsGroup and CanEasilyComputePcgs and IsFinite,IsMultiplicativeElementWithInverse,IsMultiplicativeElementWithInverse,IsFunction],0,COM_FUN(46));
InstallMethod(CentralizerModulo,"pcgs computable groups, for elm",IsCollsCollsElms,[IsGroup and CanEasilyComputePcgs,IsGroup and CanEasilyComputePcgs,IsMultiplicativeElementWithInverse],0,COM_FUN(47));
InstallMethod(CentralizerModulo,"group centralizer via generators",IsFamFamFam,[IsGroup and CanEasilyComputePcgs,IsGroup and CanEasilyComputePcgs,IsGroup],0,COM_FUN(48));
RedispatchOnCondition(CentralizerModulo,true,[IsGroup,IsGroup,IsObject],[IsGroup and IsSolvableGroup,IsGroup and IsSolvableGroup,IsObject],0);
InstallOtherMethod(ElementaryAbelianSeries,"list of pcgs computable groups",true,[IsList and IsFinite],1,COM_FUN(49));
InstallMethod(\<,"cgs comparison",IsIdenticalObj,[IsPcGroup,IsPcGroup],0,COM_FUN(50));
InstallGlobalFunction(GapInputPcGroup,COM_FUN(51));
InstallMethod(Enumerator,"finite pc computable groups",true,[IsGroup and CanEasilyComputePcgs and IsFinite],0,COM_FUN(52));
InstallMethod(KnowsHowToDecompose,"pc group and generators: always true",IsIdenticalObj,[IsPcGroup,IsList],0,ReturnTrue);
InstallGlobalFunction(CanonicalSubgroupRepresentativePcGroup,COM_FUN(53));
InstallMethod(ConjugacyClassSubgroups,IsIdenticalObj,[IsPcGroup,IsPcGroup],0,COM_FUN(54));
InstallOtherMethod(RepresentativeActionOp,"pc group on subgroups",true,[IsPcGroup,IsPcGroup,IsPcGroup,IsFunction],0,COM_FUN(55));
InstallMethod(ChiefSeriesUnderAction,"method for a pcgs computable group",IsIdenticalObj,[IsGroup,IsGroup and CanEasilyComputePcgs],0,COM_FUN(56));
InstallMethod(IsSimpleGroup,"for solvable groups",true,[IsSolvableGroup],Maximum(RankFilter(IsSolvableGroup),RankFilter(IsPermGroup)+1)-RankFilter(IsSolvableGroup),COM_FUN(57));
InstallMethod(ViewObj,"pc group",true,[IsPcGroup],0,COM_FUN(58));
InstallTrueMethod(CanEasilyComputePcgs,IsPcGroup);
InstallTrueMethod(CanEasilyComputePcgs,HasPcgs);
InstallTrueMethod(CanEasilyComputePcgs,IsGroup and HasFamilyPcgs);
InstallTrueMethod(CanEasilyTestMembership,CanEasilyComputePcgs);
InstallTrueMethod(CanComputeSize,CanEasilyComputePcgs);
InstallTrueMethod(CanComputeSizeAnySubgroup,CanEasilyComputePcgs);
InstallMethod(IsConjugatorIsomorphism,"for a pc group general mapping",true,[IsGroupGeneralMapping],1,COM_FUN(59));
InstallMethod(IndependentGeneratorsOfAbelianGroup,"Use Pcgs and NormalFormIntMat to find the independent generators",[IsGroup and CanEasilyComputePcgs and IsAbelian],0,COM_FUN(60));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grppc.gi"

#F  file="lib/grppcint.gi" crc=115538774
RANK_FILTER_LIST  := [ 17603834, 22, 17603834, 22, 17603834, 22, 17603834, 22 
 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grppcint.gi", 115538774 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grppcint.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grppcint.gi");
elif COM_RESULT = 3  then
Revision.grppcint_gi:="@(#)$Id: grppcint.gi,v 4.27.4.1 2005/04/12 19:07:15 gap Exp $";
GS_SIZE:=20;
GlasbyCover:=COM_FUN(1);
GlasbyShift:=COM_FUN(2);
GlasbyStabilizer:=COM_FUN(3);
AvoidedLayers:=COM_FUN(4);
GlasbyIntersection:=COM_FUN(5);
ZassenhausIntersection:=COM_FUN(6);
InstallMethod(Intersection2,"groups with pcgs",true,[IsGroup and HasHomePcgs,IsGroup and HasHomePcgs],0,COM_FUN(7));
InstallMethod(NormalIntersection,"method for two groups with home pcgs",IsIdenticalObj,[IsGroup and HasHomePcgs,IsGroup and HasHomePcgs],COM_FUN(8));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grppcint.gi"

#F  file="lib/grppcprp.gi" crc=122813800
RANK_FILTER_LIST  := [ 60356449, 25, 60356449, 25 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grppcprp.gi", 122813800 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grppcprp.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grppcprp.gi");
elif COM_RESULT = 3  then
Revision.grppcprp_gi:="@(#)$Id: grppcprp.gi,v 4.6 2002/04/15 10:04:52 sal Exp $";
InstallMethod(IsNilpotentGroup,"method for pc groups",true,[IsGroup and CanEasilyComputePcgs],0,COM_FUN(1));
InstallMethod(IsSupersolvableGroup,"method for pc groups",true,[IsGroup and CanEasilyComputePcgs],0,COM_FUN(2));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grppcprp.gi"

#F  file="lib/grppcatr.gi" crc=-94750068
RANK_FILTER_LIST  := [ 60345289, 30, 60345289, 30, 66740907, 33, 60345289, 
  30, 60345289, 30, 60345289, 30, 60345289, 30, 60345289, 30, 8193, 2, 
  29419057, 21, 8193, 2, 60345289, 30, 60356449, 25, 60356449, 25, 60345289, 
  30, 7665940, 19, 29419057, 21, 7665940, 19, 60345289, 30, 7665940, 19, 
  60345289, 30, 29407132, 31, 60345289, 30, 66729747, 44, 66729747, 44, 
  67108115, 26, 60345289, 30, 60345289, 30, 66729747, 44, 7665940, 19 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grppcatr.gi", -94750068 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grppcatr.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grppcatr.gi");
elif COM_RESULT = 3  then
Revision.grppcatr_gi:="@(#)$Id: grppcatr.gi,v 4.56.2.2 2005/12/15 21:20:59 gap Exp $";
InstallMethod(AsSSortedListNonstored,"pcgs computable groups",true,[IsGroup and CanEasilyComputePcgs and IsFinite],0,COM_FUN(1));
InstallMethod(AsSSortedList,"pcgs computable groups",true,[IsGroup and CanEasilyComputePcgs and IsFinite],0,AsSSortedListNonstored);
InstallMethod(AsList,"pc group",true,[IsPcGroup],0,AsSSortedListNonstored);
InstallMethod(CompositionSeries,"pcgs computable groups",true,[IsGroup and CanEasilyComputePcgs and IsFinite],0,COM_FUN(2));
InstallMethod(DerivedSubgroup,"pcgs computable groups",true,[IsGroup and CanEasilyComputePcgs and IsFinite],0,COM_FUN(3));
InstallMethod(ElementaryAbelianSeries,"pcgs computable groups using `PcgsElementaryAbelianSeries'",true,[IsGroup and CanEasilyComputePcgs and IsFinite],0,COM_FUN(4));
InstallMethod(FrattiniSubgroup,"pcgs computable groups using prefrattini and core",true,[IsGroup and CanEasilyComputePcgs and IsFinite],0,COM_FUN(5));
InstallMethod(HallSubgroupOp,"pcgs computable groups using special pcgs",true,[IsGroup and CanEasilyComputePcgs and IsFinite,IsList],0,COM_FUN(6));
RedispatchOnCondition(HallSubgroupOp,true,[IsGroup,IsList],[IsGroup and IsSolvableGroup and CanEasilyComputePcgs and IsFinite,IsList],0);
InstallMethod(PrefrattiniSubgroup,"pcgs computable groups using special pcgs",true,[IsGroup and CanEasilyComputePcgs and IsFinite],0,COM_FUN(7));
InstallMethod(IsFinite,"pcgs computable groups",true,[IsGroup and CanEasilyComputePcgs],0,COM_FUN(8));
InstallMethod(Size,"pcgs computable groups",true,[IsGroup and CanEasilyComputePcgs],0,COM_FUN(9));
InstallMethod(SylowComplementOp,"pcgs computable groups using special pcgs",true,[IsGroup and CanEasilyComputePcgs and IsFinite,IsPosInt],80,COM_FUN(10));
RedispatchOnCondition(SylowComplementOp,true,[IsGroup,IsPosInt],[IsGroup and IsSolvableGroup and CanEasilyComputePcgs and IsFinite,IsPosInt],0);
InstallMethod(SylowSubgroupOp,"pcgs computable groups using special pcgs",true,[IsGroup and CanEasilyComputePcgs and IsFinite,IsPosInt],100,COM_FUN(11));
MaximalSubgroupClassesRepsLayer:=COM_FUN(12);
InstallMethod(MaximalSubgroupClassReps,"pcgs computable groups using special pcgs",true,[IsGroup and CanEasilyComputePcgs and IsFinite],0,COM_FUN(13));
InstallMethod(MaximalSubgroups,"pcgs computable groups using special pcgs",true,[IsGroup and HasFamilyPcgs and IsFinite],0,COM_FUN(14));
InstallMethod(NormalMaximalSubgroups,"pcgs computable groups using special pcgs",true,[IsGroup and CanEasilyComputePcgs and IsFinite],0,COM_FUN(15));
ModifyMinGens:=COM_FUN(16);
MinimalGensLayer:=COM_FUN(17);
InstallMethod(MinimalGeneratingSet,"pcgs computable groups using special pcgs",true,[IsPcGroup and IsFinite],0,COM_FUN(18));
InstallMethod(SmallGeneratingSet,"using minimal generating set",true,[IsPcGroup and IsFinite],0,COM_FUN(19));
InstallMethod(GeneratorsSmallest,"group of pc words which is full family",true,[HasFamilyPcgs],0,COM_FUN(20));
NextStepCentralizer:=COM_FUN(21);
InstallGlobalFunction(GeneratorsCentrePGroup,COM_FUN(22));
InstallGlobalFunction(CentrePcGroup,COM_FUN(23));
InstallMethod(Centre,"pcgs computable groups using special pcgs",[IsGroup and CanEasilyComputePcgs and IsFinite],CentrePcGroup);
InstallMethod(OmegaSeries,"for p-groups",true,[IsGroup and CanEasilyComputePcgs and IsFinite],0,COM_FUN(24));
InstallMethod(PCentralSeriesOp,"method for pc groups and prime",true,[IsPcGroup and IsFinite,IsPosInt],0,COM_FUN(25));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grppcatr.gi"

#F  file="lib/grppcnrm.gi" crc=18488832
RANK_FILTER_LIST  := [ 17603834, 22, 17603834, 22, 17603834, 22, 17603834, 
  22, 17603834, 22 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grppcnrm.gi", 18488832 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grppcnrm.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grppcnrm.gi");
elif COM_RESULT = 3  then
Revision.grppcnrm_gi:="@(#)$Id: grppcnrm.gi,v 4.26.4.1 2005/06/30 17:39:24 gap Exp $";
PCGS_STABILIZER:=COM_FUN(1);
PCGS_STABILIZER_HOMOMORPHIC:=COM_FUN(2);
PCGS_NORMALIZER_OPB:=COM_FUN(3);
PCGS_NORMALIZER_OPC1:=COM_FUN(4);
PCGS_NORMALIZER_OPC2:=COM_FUN(5);
PCGS_NORMALIZER_OPD:=COM_FUN(6);
PCGS_NORMALIZER_OPE:=COM_FUN(7);
PCGS_NORMALIZER_DATAE:=COM_FUN(8);
PCGS_NORMALIZER:=COM_FUN(9);
PCGS_NORMALIZER_LINEAR:=COM_FUN(10);
PCGS_CONJUGATING_WORD_GS:=COM_FUN(11);
PCGS_NORMALIZER_GLASBY:=COM_FUN(12);
PCGS_NORMALIZER_COBOUNDS:=COM_FUN(13);
PcGroup_NormalizerWrtHomePcgs:=COM_FUN(14);
InstallMethod(NormalizerInHomePcgs,"for group with home pcgs",true,[IsGroup and HasHomePcgs],0,COM_FUN(15));
InstallMethod(NormalizerOp,"for groups with home pcgs",IsIdenticalObj,[IsGroup and HasHomePcgs,IsGroup and HasHomePcgs],1,COM_FUN(16));
InstallMethod(NormalizerOp,"slightly better orbit algorithm for pc groups",IsIdenticalObj,[IsGroup and HasHomePcgs,IsGroup and HasHomePcgs],0,COM_FUN(17));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grppcnrm.gi"

#F  file="lib/grptbl.gi" crc=33241429
RANK_FILTER_LIST  := [ 33554058, 7, 33554058, 7, 33554058, 7, 33554058, 7, 
  33554058, 7, 33554058, 7, 33554058, 7, 33554058, 7, 8126465, 2, 33554058, 
  7, 32769, 4, 15635848, 11 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grptbl.gi", 33241429 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grptbl.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grptbl.gi");
elif COM_RESULT = 3  then
Revision.grptbl_gi:="@(#)$Id: grptbl.gi,v 4.22.4.2 2006/03/07 15:33:53 sal Exp $";
DeclareRepresentation("IsMagmaByMultiplicationTableObj",IsPositionalObjectRep and IsMultiplicativeElementWithInverse,[1]);
InstallMethod(PrintObj,"for element of magma by mult. table",[IsMagmaByMultiplicationTableObj],COM_FUN(1));
InstallMethod(\=,"for two elements of magma by mult. table",IsIdenticalObj,[IsMagmaByMultiplicationTableObj,IsMagmaByMultiplicationTableObj],COM_FUN(2));
InstallMethod(\<,"for two elements of magma by mult. table",IsIdenticalObj,[IsMagmaByMultiplicationTableObj,IsMagmaByMultiplicationTableObj],COM_FUN(3));
InstallMethod(\*,"for two elements of magma by mult. table",IsIdenticalObj,[IsMagmaByMultiplicationTableObj,IsMagmaByMultiplicationTableObj],COM_FUN(4));
InstallMethod(OneOp,"for an element in a magma by mult. table",[IsMagmaByMultiplicationTableObj],COM_FUN(5));
InstallMethod(IsGeneratorsOfMagmaWithInverses,"for a collection of magma by mult table elements",[IsCollection],COM_FUN(6));
InstallMethod(InverseOp,"for an element in a magma by mult. table",[IsMagmaByMultiplicationTableObj],COM_FUN(7));
InstallGlobalFunction(MagmaElement,COM_FUN(8));
InstallGlobalFunction(MagmaByMultiplicationTableCreator,COM_FUN(9));
InstallGlobalFunction(MagmaByMultiplicationTable,COM_FUN(10));
InstallGlobalFunction(MagmaWithOneByMultiplicationTable,COM_FUN(11));
InstallGlobalFunction(MagmaWithInversesByMultiplicationTable,COM_FUN(12));
InstallGlobalFunction(SemigroupByMultiplicationTable,COM_FUN(13));
InstallGlobalFunction(MonoidByMultiplicationTable,COM_FUN(14));
InstallGlobalFunction(GroupByMultiplicationTable,COM_FUN(15));
InstallMethod(MultiplicationTable,"for a list of elements",[IsHomogeneousList],COM_FUN(16));
InstallMethod(MultiplicationTable,"for a magma",[IsMagma],COM_FUN(17));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grptbl.gi"

#F  file="lib/ghom.gi" crc=-95603517
RANK_FILTER_LIST  := [ 2214405, 17, 29419057, 21, 11226115, 13, 11226115, 13, 
  2214405, 17, 11226115, 13, 54066721, 19, 63580652, 7, 18021921, 18, 
  65767820, 5, 9010481, 17, 65767820, 5, 18021921, 18, 4980722, 14, 18021921, 
  18, 4980722, 14, 18021921, 18, 4980722, 14, 18021921, 18, 4980722, 14, 
  18021921, 18, 4980722, 14, 18021921, 18, 4980722, 14, 18021921, 18, 
  4980722, 14, 18021921, 18, 4980722, 14, 29419057, 21, 29419057, 21, 8193, 
  2, 8193, 2, 29419057, 21, 29419057, 21, 8193, 2, 8193, 2, 2214405, 17, 
  63580652, 7, 2214405, 17, 11226115, 13, 4505241, 17, 11227107, 15, 
  11226115, 13, 6719645, 21, 2214405, 17, 2214405, 17, 6719645, 21, 2214405, 
  17, 2214405, 17, 2214405, 17, 2214405, 17, 4505241, 17, 11226115, 13, 
  52640488, 25, 4505241, 17, 4505241, 17, 4505241, 17, 4505241, 17, 65767820, 
  5, 4505241, 17, 65767820, 5, 4505241, 17, 4505241, 17, 4505241, 17, 
  59074182, 21, 29419057, 21, 65767820, 5, 29419057, 21, 65767820, 5, 
  29419057, 21, 65767820, 5, 59768653, 23, 59768653, 23, 59768653, 23, 
  25763196, 25, 37747972, 27, 59768653, 23, 59768653, 23, 25763196, 25, 
  25763196, 25, 37747972, 27, 37747972, 27, 59768653, 23, 65767820, 5, 
  59768653, 23, 29419057, 21, 59768653, 23, 65767820, 5, 59768653, 23, 
  29419057, 21, 59768653, 23, 59768653, 23, 59768653, 23, 37747972, 27, 
  11226115, 13, 11226115, 13, 29419057, 21, 62972799, 49, 29407897, 26, 
  29407897, 26, 29419057, 21 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/ghom.gi", -95603517 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/ghom.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/ghom.gi");
elif COM_RESULT = 3  then
Revision.ghom_gi:="@(#)$Id: ghom.gi,v 4.108.2.1 2006/07/25 19:23:20 gap Exp $";
InstallGlobalFunction(GroupHomomorphismByImages,COM_FUN(1));
InstallMethod(RestrictedMapping,"create new GHBI",CollFamSourceEqFamElms,[IsGroupHomomorphism,IsGroup],0,COM_FUN(2));
InstallMethod(\=,"compare source generator images",IsIdenticalObj,[IsGroupGeneralMapping,IsGroupGeneralMapping],0,COM_FUN(3));
InstallMethod(CompositionMapping2,"for gp. hom. and gp. gen. mapp., using `MappingGeneratorsImages'",FamSource1EqFamRange2,[IsGroupHomomorphism,IsGroupGeneralMapping],0,COM_FUN(4));
InstallOtherMethod(SetInverseGeneralMapping,"transfer the AsGHBI",true,[IsGroupGeneralMappingByAsGroupGeneralMappingByImages and HasAsGroupGeneralMappingByImages,IsGeneralMapping],0,COM_FUN(5));
InstallMethod(ImagesRepresentative,"for `ByAsGroupGeneralMapping' hom",FamSourceEqFamElm,[IsGroupGeneralMappingByAsGroupGeneralMappingByImages,IsMultiplicativeElementWithInverse],0,COM_FUN(6));
InstallMethod(PreImagesRepresentative,"for PBG-Hom",FamRangeEqFamElm,[IsPreimagesByAsGroupGeneralMappingByImages,IsMultiplicativeElementWithInverse],0,COM_FUN(7));
InstallAttributeMethodByGroupGeneralMappingByImages(CoKernelOfMultiplicativeGe\
neralMapping,IsGroup);
InstallAttributeMethodByGroupGeneralMappingByImages(KernelOfMultiplicativeGene\
ralMapping,IsGroup);
InstallAttributeMethodByGroupGeneralMappingByImages(PreImagesRange,IsGroup);
InstallAttributeMethodByGroupGeneralMappingByImages(ImagesSource,IsGroup);
InstallAttributeMethodByGroupGeneralMappingByImages(IsSingleValued,IsBool);
InstallAttributeMethodByGroupGeneralMappingByImages(IsInjective,IsBool);
InstallAttributeMethodByGroupGeneralMappingByImages(IsTotal,IsBool);
InstallAttributeMethodByGroupGeneralMappingByImages(IsSurjective,IsBool);
InstallMethod(GroupGeneralMappingByImages,"for group, group, list, list",true,[IsGroup,IsGroup,IsList,IsList],0,COM_FUN(8));
InstallMethod(GroupHomomorphismByImagesNC,"for group, group, list, list",true,[IsGroup,IsGroup,IsList,IsList],0,COM_FUN(9));
InstallMethod(MappingGeneratorsImages,"for a group homomorphism",true,[IsGroupHomomorphism],0,COM_FUN(10));
RedispatchOnCondition(MappingGeneratorsImages,true,[IsGeneralMapping],[IsGroupHomomorphism],0);
InstallMethod(AsGroupGeneralMappingByImages,"for a group homomorphism",true,[IsGroupHomomorphism],0,COM_FUN(11));
InstallMethod(AsGroupGeneralMappingByImages,"for group general mapping",true,[IsGroupGeneralMapping],0,COM_FUN(12));
InstallMethod(AsGroupGeneralMappingByImages,"for GHBI",true,[IsGroupGeneralMappingByImages],SUM_FLAGS,IdFunc);
InstallMethod(SetAsGroupGeneralMappingByImages,"assign MappingOfWhichItIsAsGGMBI",true,[IsGroupGeneralMapping and IsAttributeStoringRep,IsGroupGeneralMapping],0,COM_FUN(13));
InstallMethod(\=,"homomorphism by images with homomorphism: compare generator images",IsIdenticalObj,[IsGroupHomomorphism and IsGroupGeneralMappingByImages,IsGroupHomomorphism],1,COM_FUN(14));
InstallMethod(\=,"homomorphism with general mapping: test b=a",IsIdenticalObj,[IsGroupHomomorphism,IsGroupHomomorphism and IsGroupGeneralMappingByImages],0,COM_FUN(15));
InstallMethod(ImagesSmallestGenerators,"group homomorphisms",true,[IsGroupHomomorphism],0,COM_FUN(16));
InstallMethod(\<,"group homomorphisms: Images of smallest generators",IsIdenticalObj,[IsGroupHomomorphism,IsGroupHomomorphism],0,COM_FUN(17));
InstallMethod(ImagesSource,"for GHBI",true,[IsGroupHomomorphism],0,COM_FUN(18));
InstallMethod(PreImagesRange,"for GHBI",true,[IsGroupGeneralMappingByImages],0,COM_FUN(19));
InstallMethod(InverseGeneralMapping,"via generators/images",true,[IsGroupGeneralMapping],0,COM_FUN(20));
InstallMethod(InverseGeneralMapping,"for bijective GHBI",true,[IsGroupGeneralMappingByImages and IsBijective],0,COM_FUN(21));
InstallGlobalFunction(MakeMapping,COM_FUN(22));
InstallMethod(CoKernelOfMultiplicativeGeneralMapping,"for GHBI",true,[IsGroupGeneralMappingByImages],0,COM_FUN(23));
InstallMethod(KernelOfMultiplicativeGeneralMapping,"for GHBI",true,[IsGroupGeneralMappingByImages],0,COM_FUN(24));
InstallMethod(IsInjective,"for GHBI",true,[IsGroupGeneralMappingByImages],0,COM_FUN(25));
InstallGlobalFunction(ImagesRepresentativeGMBIByElementsList,COM_FUN(26));
InstallMethod(ImagesRepresentative,"parallel enumeration of source and range",FamSourceEqFamElm,[IsGroupGeneralMappingByImages,IsMultiplicativeElementWithInverse],0,ImagesRepresentativeGMBIByElementsList);
InstallMethod(PreImagesRepresentative,"for GHBI and mult.-elm.-with-inverse",FamRangeEqFamElm,[IsGroupGeneralMappingByImages,IsMultiplicativeElementWithInverse],0,COM_FUN(27));
InstallMethod(ViewObj,"for GHBI",true,[IsGroupGeneralMappingByImages],0,COM_FUN(28));
InstallMethod(String,"for GHBI",true,[IsGroupGeneralMappingByImages],0,COM_FUN(29));
InstallMethod(PrintObj,"for group general mapping b.i.",true,[IsGroupGeneralMappingByImages],0,COM_FUN(30));
InstallMethod(PrintObj,"for GHBI",true,[IsGroupGeneralMappingByImages and IsMapping],0,COM_FUN(31));
InstallMethod(ConjugatorIsomorphism,"for group and mult.-elm.-with-inverse",IsCollsElms,[IsGroup,IsMultiplicativeElementWithInverse],0,COM_FUN(32));
InstallMethod(ConjugatorAutomorphismNC,"group and mult.-elm.-with-inverse",IsCollsElms,[IsGroup,IsMultiplicativeElementWithInverse],0,COM_FUN(33));
InstallGlobalFunction(ConjugatorAutomorphism,COM_FUN(34));
InstallMethod(InnerAutomorphismNC,"for group and mult.-elm.-with-inverse",IsCollsElms,[IsGroup,IsMultiplicativeElementWithInverse],0,COM_FUN(35));
InstallGlobalFunction(InnerAutomorphism,COM_FUN(36));
InstallMethod(MappingGeneratorsImages,"for conjugator isomorphism",true,[IsConjugatorIsomorphism],0,COM_FUN(37));
InstallMethod(AsGroupGeneralMappingByImages,"for conjugator isomorphism",true,[IsConjugatorIsomorphism],0,COM_FUN(38));
InstallMethod(InverseGeneralMapping,"for conjugator isomorphism",true,[IsConjugatorIsomorphism],0,COM_FUN(39));
InstallMethod(InverseGeneralMapping,"for conjugator automorphism",true,[IsConjugatorAutomorphism],0,COM_FUN(40));
InstallMethod(InverseGeneralMapping,"for inner automorphism",true,[IsInnerAutomorphism],0,COM_FUN(41));
InstallMethod(CompositionMapping2,"for two conjugator isomorphisms",true,[IsConjugatorIsomorphism,IsConjugatorIsomorphism],0,COM_FUN(42));
InstallMethod(CompositionMapping2,"for two conjugator automorphisms",true,[IsConjugatorAutomorphism,IsConjugatorAutomorphism],0,COM_FUN(43));
InstallMethod(CompositionMapping2,"for two inner automorphisms",IsIdenticalObj,[IsInnerAutomorphism,IsInnerAutomorphism],0,COM_FUN(44));
InstallMethod(ImagesRepresentative,"for conjugator isomorphism",FamSourceEqFamElm,[IsConjugatorIsomorphism,IsMultiplicativeElementWithInverse],0,COM_FUN(45));
InstallMethod(ImagesSet,"for conjugator isomorphism, and group",CollFamSourceEqFamElms,[IsConjugatorIsomorphism,IsGroup],0,COM_FUN(46));
InstallMethod(PreImagesRepresentative,"for conjugator isomorphism",FamRangeEqFamElm,[IsConjugatorIsomorphism,IsMultiplicativeElementWithInverse],0,COM_FUN(47));
InstallMethod(PreImagesSet,"for conjugator isomorphism, and group",CollFamRangeEqFamElms,[IsConjugatorIsomorphism,IsGroup],0,COM_FUN(48));
InstallMethod(ViewObj,"for conjugator isomorphism",true,[IsConjugatorIsomorphism],0,COM_FUN(49));
InstallMethod(String,"for conjugator isomorphism",true,[IsConjugatorIsomorphism],0,COM_FUN(50));
InstallMethod(PrintObj,"for conjugator isomorphism",true,[IsConjugatorIsomorphism],0,COM_FUN(51));
InstallMethod(PrintObj,"for inner automorphism",true,[IsInnerAutomorphism],0,COM_FUN(52));
InstallMethod(IsConjugatorIsomorphism,"for a group general mapping",true,[IsGroupGeneralMapping],0,COM_FUN(53));
InstallMethod(IsInnerAutomorphism,"for a group general mapping",true,[IsGroupGeneralMapping],0,COM_FUN(54));
InstallGlobalFunction(NaturalHomomorphismByNormalSubgroup,COM_FUN(55));
InstallMethod(NaturalHomomorphismByNormalSubgroupOp,"for group, and trivial group (delegate to `IdentityMapping')",IsIdenticalObj,[IsGroup,IsGroup and IsTrivial],SUM_FLAGS,COM_FUN(56));
InstallMethod(IsomorphismPermGroup,"right regular operation",true,[IsGroup and IsFinite],0,COM_FUN(57));
InstallMethod(IsomorphismPcGroup,"via permutation representation",true,[IsGroup and IsFinite],0,COM_FUN(58));
InstallGlobalFunction(GroupHomomorphismByFunction,COM_FUN(59));
InstallMethod(RegularActionHomomorphism,"generic",true,[IsGroup],0,COM_FUN(60));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/ghom.gi"

#F  file="lib/ghompcgs.gi" crc=17779163
RANK_FILTER_LIST  := [ 2214405, 17, 54568372, 22, 13903997, 28, 13903997, 28, 
  65305200, 20, 65767820, 5, 67108310, 18, 67108310, 18, 23864959, 24, 
  54568762, 23, 54568762, 23, 54568582, 22, 65767820, 5, 66740907, 33, 
  66740907, 33, 36404717, 23, 36404717, 23, 29566052, 25, 65767820, 5, 
  29566052, 25, 65767820, 5, 54568762, 23, 54568762, 23, 54568762, 23, 
  29419057, 21, 58719912, 21, 66740907, 33 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/ghompcgs.gi", 17779163 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/ghompcgs.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/ghompcgs.gi");
elif COM_RESULT = 3  then
Revision.ghompcgs_gi:="@(#)$Id: ghompcgs.gi,v 4.54.4.1 2006/05/11 19:18:48 gap Exp $";
BindGlobal("PcgsHomSoImPow",COM_FUN(1));
InstallMethod(CompositionMapping2,"method for hom2 from pc group",FamSource1EqFamRange2,[IsGroupHomomorphism,IsGroupGeneralMappingByPcgs and IsMapping and IsTotal],0,COM_FUN(2));
InstallMethod(CompositionMapping2,"method for two pc group automorphisms",IsIdenticalObj,[IsPcGroupHomomorphismByImages and IsToPcGroupHomomorphismByImages and IsTotal and IsInjective and IsSurjective,IsPcGroupHomomorphismByImages and IsToPcGroupHomomorphismByImages and IsTotal and IsInjective and IsSurjective],0,COM_FUN(3));
InstallMethod(ImagesRepresentative,"for total GGMBPCGS, and mult.-elm.-with-inverse",FamSourceEqFamElm,[IsGroupGeneralMappingByPcgs and IsTotal,IsMultiplicativeElementWithInverse],100,COM_FUN(4));
InstallMethod(IsSingleValued,"for GMBPCGS: test relations",true,[IsGroupGeneralMappingByPcgs],0,COM_FUN(5));
InstallMethod(CoKernelOfMultiplicativeGeneralMapping,"for GMBPCGS: evaluate relations",true,[IsGroupGeneralMappingByPcgs],0,COM_FUN(6));
InversePcgs:=COM_FUN(7);
InstallMethod(KernelOfMultiplicativeGeneralMapping,"method for homs from pc group into pc group or perm group",true,[IsPcGroupHomomorphismByImages and IsToPcGroupHomomorphismByImages],0,COM_FUN(8));
InstallMethod(KernelOfMultiplicativeGeneralMapping,"method for homs from pc group",true,[IsPcGroupHomomorphismByImages],0,COM_FUN(9));
InstallMethod(IsInjective,"method for homs from pc group",true,[IsPcGroupHomomorphismByImages],0,COM_FUN(10));
InstallMethod(PreImagesRepresentative,"method for pcgs hom",FamRangeEqFamElm,[IsToPcGroupHomomorphismByImages,IsMultiplicativeElementWithInverse],0,COM_FUN(11));
InstallMethod(NaturalHomomorphismByNormalSubgroupOp,IsIdenticalObj,[IsPcGroup,IsPcGroup],0,COM_FUN(12));
InstallMethod(ViewObj,"for nat. hom. of pc group",true,[IsNaturalHomomorphismPcGroupRep],0,COM_FUN(13));
InstallMethod(PrintObj,"for nat. hom. of pc group",true,[IsNaturalHomomorphismPcGroupRep],0,COM_FUN(14));
InstallMethod(ImagesRepresentative,FamSourceEqFamElm,[IsPcgsToPcgsHomomorphism,IsMultiplicativeElementWithInverse],0,COM_FUN(15));
InstallMethod(PreImagesRepresentative,FamRangeEqFamElm,[IsPcgsToPcgsHomomorphism,IsMultiplicativeElementWithInverse],0,COM_FUN(16));
InstallMethod(\=,"pc group homomorphisms",IsIdenticalObj,[IsPcGroupHomomorphismByImages,IsPcGroupHomomorphismByImages],1,COM_FUN(17));
InstallMethod(PrintObj,"method for a PcGroupHomomorphisms",true,[IsPcGroupHomomorphismByImages],0,COM_FUN(18));
InstallMethod(NaturalIsomorphismByPcgs,"for group and pcgs",IsIdenticalObj,[IsGroup,IsPcgs],0,COM_FUN(19));
InstallMethod(IsomorphismPcGroup,true,[IsPcGroup],0,IdentityMapping);
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/ghompcgs.gi"

#F  file="lib/gprd.gi" crc=-126917924
RANK_FILTER_LIST  := [ 8193, 2, 29419057, 21, 8588461, 15, 15818713, 22, 
  15818713, 22, 7665940, 19, 15818713, 22, 7665940, 19, 15818713, 22, 
  15818713, 22, 15818713, 22, 15818713, 22, 15818713, 22, 46756884, 30, 
  66740907, 33, 59958721, 32, 15818713, 22, 66740907, 33, 59958721, 32, 
  15818713, 22, 66740907, 33, 59958721, 32, 15818713, 22, 66740907, 33, 
  59958721, 32, 15818713, 22, 66740907, 33, 59958721, 32, 15818713, 22, 
  58719147, 25, 8588461, 15, 58719147, 25, 8588461, 15, 29419057, 21, 
  29419057, 21, 2214405, 17, 2214405, 17, 38622845, 22, 7665940, 19, 
  38622845, 22, 29419057, 21, 29419057, 21, 29419057, 21, 29419057, 21, 
  60052424, 8, 39069693, 7, 39069693, 7, 39069693, 7, 39069693, 7, 39069693, 
  7, 39069693, 7, 39069693, 7, 39069693, 7, 39069693, 7, 50216985, 26, 
  7665940, 19, 50216985, 26, 50203066, 28, 39069693, 7, 29419057, 21, 1, 0, 
  29419057, 21, 2214405, 17, 29419057, 21, 17123190, 22, 7665940, 19, 
  17123190, 22, 29419057, 21, 2214405, 17, 22930668, 51, 17123190, 22, 
  7665940, 19, 8193, 2, 29419057, 21, 48953903, 22, 7665940, 19 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/gprd.gi", -126917924 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/gprd.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/gprd.gi");
elif COM_RESULT = 3  then
Revision.gprd_gi:="@(#)$Id: gprd.gi,v 4.46.2.6 2007/01/17 16:45:21 gap Exp $";
InstallGlobalFunction(DirectProduct,COM_FUN(1));
InstallMethod(DirectProductOp,"for a list (of groups), and a group",true,[IsList,IsGroup],0,COM_FUN(2));
InstallMethod(\in,"generic direct product",IsElmsColls,[IsTuple,IsGroup and HasDirectProductInfo],0,COM_FUN(3));
InstallMethod(Embedding,"group direct product and integer",true,[IsGroup and HasDirectProductInfo,IsPosInt],0,COM_FUN(4));
InstallMethod(Projection,"group direct product and integer",true,[IsGroup and HasDirectProductInfo,IsPosInt],0,COM_FUN(5));
InstallMethod(Size,"group direct product",true,[IsGroup and HasDirectProductInfo],0,COM_FUN(6));
InstallMethod(IsSolvableGroup,"for direct products",true,[IsGroup and HasDirectProductInfo],0,COM_FUN(7));
InstallMethod(IsNilpotentGroup,"for direct products",true,[IsGroup and HasDirectProductInfo],0,COM_FUN(8));
InstallMethod(IsAbelian,"for direct products",true,[IsGroup and HasDirectProductInfo],0,COM_FUN(9));
InstallMethod(IsPGroup,"for direct products",true,[IsGroup and HasDirectProductInfo],0,COM_FUN(10));
InstallMethod(PrimePGroup,"for direct products",true,[IsPGroup and HasDirectProductInfo],0,COM_FUN(11));
DeclareRepresentation("IsPcgsDirectProductRep",IsPcgsDefaultRep,["pcgs","len"]\
);
InstallGlobalFunction(PcgsDirectProduct,COM_FUN(12));
InstallMethod(Pcgs,"for direct products",true,[IsGroup and HasDirectProductInfo],Maximum(RankFilter(IsPcGroup),RankFilter(IsPermGroup and IsSolvableGroup)),COM_FUN(13));
InstallMethod(PcgsElementaryAbelianSeries,"for direct products",true,[IsGroup and HasDirectProductInfo],Maximum(RankFilter(IsPcGroup),RankFilter(IsPermGroup and IsSolvableGroup)),COM_FUN(14));
InstallMethod(PcgsCentralSeries,"for direct products",true,[IsGroup and HasDirectProductInfo],Maximum(RankFilter(IsPcGroup),RankFilter(IsPermGroup and IsSolvableGroup)),COM_FUN(15));
InstallMethod(PcgsChiefSeries,"for direct products",true,[IsGroup and HasDirectProductInfo],Maximum(RankFilter(IsPcGroup),RankFilter(IsPermGroup and IsSolvableGroup)),COM_FUN(16));
InstallMethod(PcgsPCentralSeriesPGroup,"for direct products",true,[IsGroup and HasDirectProductInfo],Maximum(RankFilter(IsPcGroup),RankFilter(IsPermGroup and IsSolvableGroup)),COM_FUN(17));
InstallMethod(ExponentsOfPcElement,"for pcgs of direct product",IsCollsElms,[IsPcgs and IsPcgsDirectProductRep,IsTuple],0,COM_FUN(18));
InstallMethod(DepthOfPcElement,"for pcgs of direct product",IsCollsElms,[IsPcgs and IsPcgsDirectProductRep,IsTuple],0,COM_FUN(19));
InstallGlobalFunction(SubdirectProduct,COM_FUN(20));
InstallMethod(SubdirectProductOp,"groups",true,[IsGroup,IsGroup,IsGroupHomomorphism,IsGroupHomomorphism],0,COM_FUN(21));
InstallMethod(Projection,"pc subdirect product",true,[IsGroup and HasSubdirectProductInfo,IsPosInt],0,COM_FUN(22));
InstallMethod(Size,"subdirect product",true,[IsGroup and HasSubdirectProductInfo],0,COM_FUN(23));
InstallGlobalFunction(InnerSubdirectProducts2,COM_FUN(24));
InstallGlobalFunction(InnerSubdirectProducts,COM_FUN(25));
InstallGlobalFunction(SubdirectProducts,COM_FUN(26));
InstallOtherMethod(WreathProduct,"generic groups",true,[IsGroup,IsGroup],0,COM_FUN(27));
InstallOtherMethod(WreathProduct,"generic groups with permhom",true,[IsGroup,IsGroup,IsSPGeneralMapping],0,COM_FUN(28));
InstallMethod(PrintObj,"wreath elements",true,[IsWreathProductElement],0,COM_FUN(29));
InstallMethod(OneOp,"wreath elements",true,[IsWreathProductElement],0,COM_FUN(30));
InstallMethod(InverseOp,"wreath elements",true,[IsWreathProductElement],0,COM_FUN(31));
InstallMethod(\*,"wreath elements",IsIdenticalObj,[IsWreathProductElement,IsWreathProductElement],0,COM_FUN(32));
InstallMethod(\=,"wreath elements",IsIdenticalObj,[IsWreathProductElement,IsWreathProductElement],0,COM_FUN(33));
InstallMethod(\<,"wreath elements",IsIdenticalObj,[IsWreathProductElement,IsWreathProductElement],0,COM_FUN(34));
InstallMethod(Embedding,"generic wreath product",true,[IsGroup and HasWreathProductInfo and IsWreathProductElementCollection,IsPosInt],0,COM_FUN(35));
InstallOtherMethod(Projection,"generic wreath product",true,[IsGroup and HasWreathProductInfo and IsWreathProductElementCollection],0,COM_FUN(36));
InstallMethod(\in,"generic wreath product",IsCollsElms,[IsGroup and HasWreathProductInfo and IsWreathProductElementCollection and IsWholeFamily,IsWreathProductElement],0,COM_FUN(37));
InstallOtherMethod(SemidirectProduct,"automorphisms group with group",true,[IsGroup,IsObject],0,COM_FUN(38));
InstallMethod(SemidirectProduct,"different representations",true,[IsGroup,IsGroupHomomorphism,IsGroup],0,COM_FUN(39));
InstallMethod(Embedding,"of semidirect product and integer",true,[IsGroup and HasSemidirectProductInfo,IsPosInt],0,COM_FUN(40));
InstallOtherMethod(Projection,"of semidirect product",true,[IsGroup and HasSemidirectProductInfo],0,COM_FUN(41));
InstallOtherMethod(SemidirectProduct,"group with vector space: affine",true,[IsGroup,IsGroupHomomorphism,IsFullRowModule and IsVectorSpace],0,COM_FUN(42));
InstallMethod(Embedding,"vectorspace semidirect products",true,[IsGroup and HasSemidirectProductInfo,IsPosInt],0,COM_FUN(43));
InstallGlobalFunction(FreeProduct,COM_FUN(44));
InstallMethod(FreeProductOp,"for a list (of groups), and a group",true,[IsList,IsGroup],0,COM_FUN(45));
InstallMethod(Embedding,"free products",true,[IsGroup and HasFreeProductInfo,IsPosInt],0,COM_FUN(46));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/gprd.gi"

#F  file="lib/ghomperm.gi" crc=34950227
RANK_FILTER_LIST  := [ 44122021, 18, 44122021, 18, 44122021, 18, 44122021, 
  18, 65767820, 5, 2214405, 17, 46336425, 22, 21135162, 18, 65767820, 5, 
  65257182, 19, 65257182, 19, 65257182, 19, 54843165, 23, 65767820, 5, 
  54843165, 23, 57371522, 31, 61714518, 25, 42841080, 23, 54843165, 23, 513, 
  8, 54843165, 23, 62973024, 30, 54843165, 23, 64130082, 23, 64130082, 23, 
  65767820, 5, 64130082, 23, 62973024, 30, 15894641, 25, 64130082, 23, 
  64130082, 23, 65767820, 5, 64130082, 23, 62973024, 30, 64130082, 23, 
  66344486, 23, 35768567, 22, 62973024, 30, 11226115, 13 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/ghomperm.gi", 34950227 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/ghomperm.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/ghomperm.gi");
elif COM_RESULT = 3  then
Revision.ghomperm_gi:="@(#)$Id: ghomperm.gi,v 4.94.2.5 2006/11/15 17:20:09 gap Exp $";
InstallGlobalFunction(AddGeneratorsGenimagesExtendSchreierTree,COM_FUN(1));
InstallGlobalFunction(ImageSiftedBaseImage,COM_FUN(2));
BindGlobal("IsDoneIterator_CoKernelGens",COM_FUN(3));
BindGlobal("NextIterator_CoKernelGens",COM_FUN(4));
BindGlobal("ShallowCopy_CoKernelGens",COM_FUN(5));
InstallGlobalFunction(CoKernelGensIterator,COM_FUN(6));
InstallGlobalFunction(CoKernelGensPermHom,COM_FUN(7));
InstallGlobalFunction(RelatorsPermGroupHom,COM_FUN(8));
DoShortwordBasepoint:=COM_FUN(9);
InstallOtherMethod(StabChainMutable,"perm mapping by images",true,[IsPermGroupGeneralMappingByImages],0,COM_FUN(10));
InstallMethod(CoKernelOfMultiplicativeGeneralMapping,true,[IsPermGroupGeneralMappingByImages],0,COM_FUN(11));
InstallMethod(IsSingleValued,true,[IsPermGroupGeneralMappingByImages],0,COM_FUN(12));
InstallMethod(ImagesRepresentative,"perm group hom",FamSourceEqFamElm,[IsPermGroupGeneralMappingByImages,IsMultiplicativeElementWithInverse],COM_FUN(13));
InstallMethod(CompositionMapping2,"group hom. with perm group hom.",FamSource1EqFamRange2,[IsGroupHomomorphism,IsPermGroupGeneralMappingByImages and IsGroupHomomorphism],0,COM_FUN(14));
InstallMethod(PreImagesRepresentative,FamRangeEqFamElm,[IsToPermGroupGeneralMappingByImages,IsMultiplicativeElementWithInverse],0,COM_FUN(15));
InstallGlobalFunction(StabChainPermGroupToPermGroupGeneralMappingByImages,COM_FUN(16));
InstallGlobalFunction(MakeStabChainLong,COM_FUN(17));
InstallMethod(StabChainMutable,"perm to perm mapping by images",true,[IsPermGroupGeneralMappingByImages and IsToPermGroupGeneralMappingByImages],0,StabChainPermGroupToPermGroupGeneralMappingByImages);
InstallMethod(KernelOfMultiplicativeGeneralMapping,true,[IsPermGroupGeneralMappingByImages and IsToPermGroupGeneralMappingByImages],0,COM_FUN(18));
InstallMethod(CoKernelOfMultiplicativeGeneralMapping,true,[IsPermGroupGeneralMappingByImages and IsToPermGroupGeneralMappingByImages],0,COM_FUN(19));
InstallMethod(ImagesRepresentative,"Constituent homomorphism",FamSourceEqFamElm,[IsConstituentHomomorphism,IsMultiplicativeElementWithInverse],0,COM_FUN(20));
InstallMethod(ImagesSet,"constituent homomorphism",CollFamSourceEqFamElms,[IsConstituentHomomorphism,IsPermGroup and HasStabChainMutable],0,COM_FUN(21));
RanImgSrcSurjTraho:=COM_FUN(22);
InstallMethod(Range,"surjective constituent homomorphism",true,[IsConstituentHomomorphism and IsActionHomomorphism and IsSurjective],0,RanImgSrcSurjTraho);
InstallMethod(ImagesSource,"constituent homomorphism",true,[IsConstituentHomomorphism and IsActionHomomorphism],0,RanImgSrcSurjTraho);
InstallMethod(PreImagesRepresentative,"constituent homomorphism",FamRangeEqFamElm,[IsConstituentHomomorphism,IsPerm],0,COM_FUN(23));
InstallMethod(PreImagesSet,"constituent homomorphism",CollFamRangeEqFamElms,[IsConstituentHomomorphism,IsPermGroup],0,COM_FUN(24));
InstallMethod(KernelOfMultiplicativeGeneralMapping,"for constituent homomorphism",true,[IsConstituentHomomorphism],0,COM_FUN(25));
InstallMethod(StabChainMutable,"for blocks homomorphism",true,[IsBlocksHomomorphism],0,COM_FUN(26));
InstallMethod(ImagesRepresentative,"blocks homomorphism",FamSourceEqFamElm,[IsBlocksHomomorphism,IsMultiplicativeElementWithInverse],0,COM_FUN(27));
InstallGlobalFunction(ImageKernelBlocksHomomorphism,COM_FUN(28));
InstallMethod(ImagesSet,"for blocks homomorphism and perm. group",CollFamSourceEqFamElms,[IsBlocksHomomorphism,IsPermGroup],0,COM_FUN(29));
RanImgSrcSurjBloho:=COM_FUN(30);
InstallMethod(Range,"surjective blocks homomorphism",true,[IsBlocksHomomorphism and IsSurjective],0,RanImgSrcSurjBloho);
InstallMethod(ImagesSource,"blocks homomorphism",true,[IsBlocksHomomorphism],0,RanImgSrcSurjBloho);
InstallMethod(PreImagesRepresentative,"blocks homomorphism",FamRangeEqFamElm,[IsBlocksHomomorphism,IsMultiplicativeElementWithInverse],0,COM_FUN(31));
InstallMethod(PreImagesSet,CollFamRangeEqFamElms,[IsBlocksHomomorphism,IsPermGroup],0,COM_FUN(32));
InstallGlobalFunction(PreImageSetStabBlocksHomomorphism,COM_FUN(33));
InstallMethod(KernelOfMultiplicativeGeneralMapping,"blocks homomorphism",true,[IsBlocksHomomorphism],0,COM_FUN(34));
DeclareRepresentation("IsBlocksOfActionHomomorphism",IsActionHomomorphismByBase,[]);
InstallMethod(CompositionMapping2,"for action homomorphism with blocks homomorphism",FamSource1EqFamRange2,[IsGroupHomomorphism and IsBlocksHomomorphism,IsGroupHomomorphism and IsActionHomomorphism],0,COM_FUN(35));
InstallMethod(IsomorphismPermGroup,"perm groups",true,[IsPermGroup],0,IdentityMapping);
InstallOtherMethod(IsConjugatorIsomorphism,"perm group homomorphism",true,[IsGroupGeneralMapping],1,COM_FUN(36));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/ghomperm.gi"

#F  file="lib/grpperm.gi" crc=-74264559
RANK_FILTER_LIST  := [ 62973024, 33, 62973024, 33, 47753736, 42, 33553968, 
  33, 41951068, 17, 33553968, 33, 41951068, 17, 33553968, 33, 41951068, 17, 
  513, 8, 33553968, 33, 41951068, 17, 62973024, 33, 62973024, 33, 62973024, 
  33, 62973024, 33, 62973024, 33, 62973024, 33, 62973024, 33, 62973024, 33, 
  513, 8, 54505107, 34, 62973024, 33, 33562160, 36, 4097, 1, 62973024, 33, 
  41951068, 17, 62973024, 33, 513, 8, 62973024, 33, 33562160, 36, 62973024, 
  33, 513, 8, 4097, 1, 62973024, 33, 62973024, 33, 4097, 1, 62973024, 33, 
  41951068, 17, 4097, 1, 62973024, 33, 62973024, 33, 62973024, 33, 513, 8, 
  62973024, 33, 62973024, 33, 62973024, 33, 62973024, 33, 62973024, 33, 
  62973024, 33, 62973024, 33, 62973024, 33, 62973024, 33, 26790377, 40, 
  62961864, 39, 62961864, 39, 62973024, 33, 7665940, 19, 62973024, 33, 
  7665940, 19, 62973024, 33, 62973024, 33, 62973024, 33, 7665940, 19, 
  7665940, 19, 32228062, 10, 7665940, 19, 32228062, 10, 513, 8, 62973024, 33, 
  62973024, 33, 62973024, 33, 62973024, 33, 62973024, 33, 62973024, 33, 
  62973024, 33, 62973024, 33, 8193, 2, 54505107, 34, 62973024, 33, 62973024, 
  33, 62973024, 33, 62973024, 33, 62973024, 33 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grpperm.gi", -74264559 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grpperm.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grpperm.gi");
elif COM_RESULT = 3  then
Revision.grpperm_gi:="@(#)$Id: grpperm.gi,v 4.155.2.6 2007/03/27 03:36:31 gap Exp $";
InstallTrueMethod(CanEasilyTestMembership,IsPermGroup);
InstallTrueMethod(CanEasilyComputePcgs,IsPermGroup and IsSolvableGroup);
InstallTrueMethod(CanComputeSizeAnySubgroup,IsPermGroup);
InstallMethod(AsSubgroup,"perm groups",IsIdenticalObj,[IsPermGroup,IsPermGroup],0,COM_FUN(1));
InstallGlobalFunction(IndependentGeneratorsAbelianPPermGroup,COM_FUN(2));
InstallMethod(IndependentGeneratorsOfAbelianGroup,"for perm group",[IsPermGroup and IsAbelian],COM_FUN(3));
InstallGlobalFunction(OrbitPerms,COM_FUN(4));
InstallGlobalFunction(OrbitsPerms,COM_FUN(5));
SmallestMovedPointPerms:=COM_FUN(6);
InstallMethod(SmallestMovedPoint,"for a collection of permutations",true,[IsPermCollection],0,SmallestMovedPointPerms);
InstallMethod(SmallestMovedPoint,"for an empty list",true,[IsList and IsEmpty],0,SmallestMovedPointPerms);
LargestMovedPointPerms:=COM_FUN(7);
InstallMethod(LargestMovedPoint,"for a collection of permutations",true,[IsPermCollection],0,LargestMovedPointPerms);
InstallMethod(LargestMovedPoint,"for an empty list",true,[IsList and IsEmpty],0,LargestMovedPointPerms);
InstallGlobalFunction(MovedPointsPerms,COM_FUN(8));
InstallMethod(MovedPoints,"for a collection of permutations",true,[IsPermCollection],0,MovedPointsPerms);
InstallMethod(MovedPoints,"for an empty list",true,[IsList and IsEmpty],0,MovedPointsPerms);
InstallMethod(MovedPoints,"for a permutation",true,[IsPerm],0,COM_FUN(9));
NrMovedPointsPerms:=COM_FUN(10);
InstallMethod(NrMovedPoints,"for a collection of permutations",true,[IsPermCollection],0,NrMovedPointsPerms);
InstallMethod(NrMovedPoints,"for an empty list",true,[IsList and IsEmpty],0,NrMovedPointsPerms);
InstallMethod(LargestMovedPoint,"for a permutation group",true,[IsPermGroup],0,COM_FUN(11));
InstallMethod(SmallestMovedPoint,"for a permutation group",true,[IsPermGroup],0,COM_FUN(12));
InstallMethod(MovedPoints,"for a permutation group",true,[IsPermGroup],0,COM_FUN(13));
InstallMethod(NrMovedPoints,"for a permutation group",true,[IsPermGroup],0,COM_FUN(14));
InstallMethod(BaseOfGroup,"for a permutation group",true,[IsPermGroup],0,COM_FUN(15));
InstallMethod(Size,"for a permutation group",true,[IsPermGroup],0,COM_FUN(16));
BindGlobal("ElementNumber_PermGroup",COM_FUN(17));
BindGlobal("NumberElement_PermGroup",COM_FUN(18));
InstallMethod(Enumerator,"for a permutation group",[IsPermGroup],COM_FUN(19));
InstallMethod(Random,"for a permutation group",[IsPermGroup],10,COM_FUN(20));
InstallMethod(\in,"for a permutation, and a permutation group",true,[IsPerm,IsPermGroup and HasGeneratorsOfGroup],0,COM_FUN(21));
BindGlobal("DoClosurePrmGp",COM_FUN(22));
BindGlobal("PG_EMPTY_OPT",rec());
InstallOtherMethod(ClosureGroup,"permgroup, elements, options",true,[IsPermGroup,IsList and IsPermCollection,IsRecord],0,DoClosurePrmGp);
InstallOtherMethod(ClosureGroup,"empty list",true,[IsPermGroup,IsList and IsEmpty],0,COM_FUN(23));
InstallMethod(ClosureGroup,"permgroup, element",true,[IsPermGroup,IsPerm],0,COM_FUN(24));
InstallMethod(ClosureGroup,"permgroup, elements",true,[IsPermGroup,IsList and IsPermCollection],0,COM_FUN(25));
InstallOtherMethod(ClosureGroup,"permgroup, element, options",true,[IsPermGroup,IsPerm,IsRecord],0,COM_FUN(26));
InstallOtherMethod(ClosureGroup,"permgroup, permgroup, options",true,[IsPermGroup,IsPermGroup,IsRecord],0,COM_FUN(27));
InstallOtherMethod(ClosureGroup,"empty list and options",true,[IsPermGroup,IsList and IsEmpty,IsRecord],0,COM_FUN(28));
BindGlobal("DoNormalClosurePermGroup",COM_FUN(29));
InstallMethod(NormalClosureOp,"subgroup of perm group",IsIdenticalObj,[IsPermGroup,IsPermGroup],0,COM_FUN(30));
InstallMethod(ConjugateGroup,"<P>, <g>",true,[IsPermGroup,IsPerm],0,COM_FUN(31));
InstallMethod(CommutatorSubgroup,"permgroups",IsIdenticalObj,[IsPermGroup,IsPermGroup],0,COM_FUN(32));
InstallMethod(DerivedSubgroup,"permgrps",true,[IsPermGroup],0,COM_FUN(33));
InstallMethod(IsSimpleGroup,"for permgrp",true,[IsPermGroup],0,COM_FUN(34));
InstallMethod(IsSolvableGroup,"for permgrp",true,[IsPermGroup],0,COM_FUN(35));
InstallMethod(IsNilpotentGroup,"for permgrp",true,[IsPermGroup],0,COM_FUN(36));
InstallOtherMethod(PcgsCentralSeries,"for permgrp",true,[IsPermGroup],0,COM_FUN(37));
InstallOtherMethod(PcgsPCentralSeriesPGroup,"for permgrp",true,[IsPermGroup],0,COM_FUN(38));
InstallMethod(LowerCentralSeriesOfGroup,"for permgrp",true,[IsPermGroup],0,COM_FUN(39));
InstallOtherMethod(ElementaryAbelianSeries,"perm group",true,[IsPermGroup and IsFinite],RankFilter(IsPermGroup and CanEasilyComputePcgs and IsFinite)-RankFilter(IsPermGroup and IsFinite),COM_FUN(40));
InstallMethod(PCentralSeriesOp,"for permgrp",true,[IsPermGroup,IsPosInt],0,COM_FUN(41));
InstallMethod(SylowSubgroupOp,"permutation groups",true,[IsPermGroup,IsPosInt],0,COM_FUN(42));
InstallGlobalFunction(SylowSubgroupPermGroup,COM_FUN(43));
InstallMethod(Socle,"for permgrp",true,[IsPermGroup],0,COM_FUN(44));
InstallMethod(FrattiniSubgroup,"for permgrp",true,[IsPermGroup],0,COM_FUN(45));
InstallMethod(OmegaOp,"in abelian perm groups",true,[IsPermGroup,IsPosInt,IsPosInt],0,COM_FUN(46));
InstallGlobalFunction(MinimizeExplicitTransversal,COM_FUN(47));
BindGlobal("RightTransversalPermGroupConstructor",COM_FUN(48));
DeclareRepresentation("IsRightTransversalPermGroupRep",IsRightTransversalRep,["stabChainGroup","stabChainSubgroup"]);
InstallMethod(\[\],"for right transversal of perm. group, and pos. integer",true,[IsList and IsRightTransversalPermGroupRep,IsPosInt],0,COM_FUN(49));
InstallMethod(PositionCanonical,"for right transversal of perm. group, and permutation",IsCollsElms,[IsList and IsRightTransversalPermGroupRep,IsPerm],0,COM_FUN(50));
InstallMethod(RightTransversalOp,"for two perm. groups",IsIdenticalObj,[IsPermGroup,IsPermGroup],0,COM_FUN(51));
MAX_SIZE_TRANSVERSAL:=100000;
InstallGlobalFunction(AddCosetInfoStabChain,COM_FUN(52));
InstallGlobalFunction(NumberCoset,COM_FUN(53));
InstallGlobalFunction(CosetNumber,COM_FUN(54));
InstallGlobalFunction(ApproximateSuborbitsStabilizerPermGroup,COM_FUN(55));
InstallMethod(AllBlocks,"generic",[IsPermGroup],COM_FUN(56));
InstallGlobalFunction(SignPermGroup,COM_FUN(57));
CreateAllCycleStructures:=COM_FUN(58);
InstallGlobalFunction(CycleStructuresGroup,COM_FUN(59));
InstallMethod(SmallGeneratingSet,"random and generators subset, randsims",true,[IsPermGroup],0,COM_FUN(60));
InstallMethod(MinimalGeneratingSet,"solvable perm group via pc",true,[IsPermGroup],0,COM_FUN(61));
DeclareGlobalFunction("GeneratorsSmallestStab");
InstallGlobalFunction(GeneratorsSmallestStab,COM_FUN(62));
InstallMethod(GeneratorsSmallest,"perm group via minimal stab chain",[IsPermGroup],COM_FUN(63));
InstallMethod(LargestElementGroup,"perm group via minimal stab chain",[IsPermGroup],COM_FUN(64));
InstallMethod(KnowsHowToDecompose,"perm group and generators: always true",IsIdenticalObj,[IsPermGroup,IsList],ReturnTrue);
InstallMethod(ViewObj,"for a permutation group",true,[IsPermGroup and HasGeneratorsOfGroup],0,COM_FUN(65));
InstallMethod(AsList,"permgp: AsSSortedList",true,[IsPermGroup],0,AsSSortedList);
InstallMethod(AsSSortedList,"via stabchain",true,[IsPermGroup],0,COM_FUN(66));
InstallMethod(AsSSortedListNonstored,"via stabchain",true,[IsPermGroup],0,COM_FUN(67));
InstallMethod(ONanScottType,"primitive permgroups",true,[IsPermGroup],0,COM_FUN(68));
InstallMethod(SocleTypePrimitiveGroup,"primitive permgroups",true,[IsPermGroup],0,COM_FUN(69));
BindGlobal("STGSelFunc",COM_FUN(70));
InstallGlobalFunction(DiagonalSocleAction,COM_FUN(71));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grpperm.gi"

#F  file="lib/gpprmsya.gi" crc=-75014547
RANK_FILTER_LIST  := [ 513, 8, 59702088, 37, 59702088, 37, 65767820, 5, 
  59702088, 37, 1, 0, 1, 0, 5, 1, 59702088, 37, 7665940, 19, 59702088, 37, 
  59702088, 37, 59702088, 37, 67108760, 5, 62974946, 34, 62973024, 33, 
  62974946, 34, 62973024, 33, 513, 8, 15721567, 37, 15721567, 37, 62973024, 
  33, 15721567, 37, 15721567, 37, 65767820, 5, 15721567, 37, 7665940, 19, 5, 
  1, 15721567, 37, 513, 8, 15721567, 37, 62973024, 33, 59702088, 37, 
  62973024, 33, 65767820, 5, 15721567, 37, 1, 0, 1, 0, 5, 1, 15721567, 37, 
  7665940, 19, 15721567, 37, 15721567, 37, 15721567, 37, 67108760, 5, 
  15721567, 37, 59702088, 37, 15721567, 37, 59702088, 37, 62973024, 33, 
  15721567, 37, 62973024, 33, 15721567, 37, 4097, 1, 62973024, 33 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/gpprmsya.gi", -75014547 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/gpprmsya.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/gpprmsya.gi");
elif COM_RESULT = 3  then
Revision.gpprmsya_gi:="@(#)$Id: gpprmsya.gi,v 4.38.2.12 2006/07/26 21:12:50 gap Exp $";
if not IsBound(TRANSDEGREES) then
TRANSDEGREES:=0;
fi;
InstallMethod(\in,"alternating",true,[IsPerm,IsNaturalAlternatingGroup],0,COM_FUN(1));
InstallMethod(Random,"alternating group: floyd's algorithm",true,[IsNaturalAlternatingGroup],10,COM_FUN(2));
InstallOtherMethod(RepresentativeActionOp,"natural alternating group",true,[IsNaturalAlternatingGroup,IsObject,IsObject,IsFunction],2*RankFilter(IsMultiplicativeElementWithInverse),COM_FUN(3));
InstallMethod(SylowSubgroupOp,"alternating",true,[IsNaturalAlternatingGroup,IsPosInt],0,COM_FUN(4));
InstallMethod(ConjugacyClasses,"alternating",true,[IsNaturalAlternatingGroup],0,COM_FUN(5));
InstallMethod(IsomorphismFpGroup,"alternating group",true,[IsNaturalAlternatingGroup],10,COM_FUN(6));
InstallOtherMethod(IsomorphismFpGroup,"alternating group,name",true,[IsNaturalAlternatingGroup,IsString],10,COM_FUN(7));
PermNatAnTestDetect:=COM_FUN(8);
BindGlobal("DoSnAnGiantTest",COM_FUN(9));
BindGlobal("PermgpContainsAn",COM_FUN(10));
InstallMethod(IsNaturalAlternatingGroup,"knows size",true,[IsPermGroup and HasSize],0,COM_FUN(11));
InstallMethod(IsNaturalAlternatingGroup,"comprehensive",true,[IsPermGroup],0,COM_FUN(12));
InstallMethod(IsNaturalSymmetricGroup,"knows size",true,[IsPermGroup and HasSize],0,COM_FUN(13));
InstallMethod(IsNaturalSymmetricGroup,"comprehensive",true,[IsPermGroup],0,COM_FUN(14));
InstallMethod(\in,"perm in natsymmetric group",true,[IsPerm,IsNaturalSymmetricGroup],0,COM_FUN(15));
InstallMethod(IsSubset,"permgrp of natsymmetric group",true,[IsNaturalSymmetricGroup,IsPermGroup],SUM_FLAGS,COM_FUN(16));
InstallMethod(Size,true,[IsNaturalSymmetricGroup],0,COM_FUN(17));
InstallMethod(Random,"symmetric group: floyd's algorithm",true,[IsNaturalSymmetricGroup],10,COM_FUN(18));
InstallOtherMethod(StabilizerOp,"symmetric group",true,[IsNaturalSymmetricGroup,IsPosInt,IsFunction],RankFilter(IsMultiplicativeElementWithInverse),COM_FUN(19));
InstallMethod(CentralizerOp,"element in natural symmetric group",IsCollsElms,[IsNaturalSymmetricGroup,IsPerm],0,COM_FUN(20));
BindGlobal("OneNormalizerfixedBlockSystem",COM_FUN(21));
BindGlobal("NormalizerParentSA",COM_FUN(22));
BindGlobal("DoNormalizerSA",COM_FUN(23));
InstallMethod(NormalizerOp,"subgp of natural symmetric group",IsIdenticalObj,[IsNaturalSymmetricGroup,IsPermGroup],0,DoNormalizerSA);
InstallMethod(NormalizerOp,"subgp of natural alternating group",IsIdenticalObj,[IsNaturalAlternatingGroup,IsPermGroup],0,DoNormalizerSA);
BindGlobal("SubgpConjSymmgp",COM_FUN(24));
InstallOtherMethod(RepresentativeActionOp,"for natural symmetric group",true,[IsNaturalSymmetricGroup,IsObject,IsObject,IsFunction],2*RankFilter(IsMultiplicativeElementWithInverse),COM_FUN(25));
InstallMethod(SylowSubgroupOp,"symmetric",true,[IsNaturalSymmetricGroup,IsPosInt],0,COM_FUN(26));
InstallMethod(ConjugacyClasses,"symmetric",true,[IsNaturalSymmetricGroup],0,COM_FUN(27));
InstallMethod(IsomorphismFpGroup,"symmetric group",true,[IsNaturalSymmetricGroup],0,COM_FUN(28));
InstallOtherMethod(IsomorphismFpGroup,"symmetric group,name",true,[IsNaturalSymmetricGroup,IsString],0,COM_FUN(29));
InstallMethod(ViewObj,"for natural symmetric group",true,[IsNaturalSymmetricGroup],0,COM_FUN(30));
InstallMethod(ViewObj,"for natural alternating group",true,[IsNaturalAlternatingGroup],0,COM_FUN(31));
InstallMethod(PrintObj,"for natural symmetric group",true,[IsNaturalSymmetricGroup],0,COM_FUN(32));
InstallMethod(PrintObj,"for natural alternating group",true,[IsNaturalAlternatingGroup],0,COM_FUN(33));
InstallMethod(SymmetricParentGroup,"symm(moved pts)",true,[IsPermGroup],0,COM_FUN(34));
InstallMethod(SymmetricParentGroup,"natural symmetric group",true,[IsNaturalSymmetricGroup],0,IdFunc);
InstallMethod(OrbitStabilizingParentGroup,"direct product of S_n's",true,[IsPermGroup],0,COM_FUN(35));
InstallOtherMethod(StabChainOp,"symmetric group",true,[IsNaturalSymmetricGroup,IsRecord],0,COM_FUN(36));
InstallMethod(AlternatingSubgroup,"for perm groups",true,[IsPermGroup],0,COM_FUN(37));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/gpprmsya.gi"

#F  file="lib/gprdperm.gi" crc=18271093
RANK_FILTER_LIST  := [ 7248, 17, 62973024, 33, 49372680, 34, 49372680, 34, 
  7665940, 19, 52810129, 23, 52810129, 23, 65767820, 5, 52810129, 23, 
  65767820, 5, 52810129, 23, 52810129, 23, 52810129, 23, 49372680, 34, 
  7665940, 19, 3328997, 23, 3328997, 23, 65767820, 5, 3328997, 23, 65767820, 
  5, 3328997, 23, 3328997, 23, 3328997, 23, 62973024, 33, 62973024, 33, 
  2214405, 17, 2214405, 17, 5067933, 34, 7665940, 19, 6657993, 23, 6657993, 
  23, 65767820, 5, 6657993, 23, 65767820, 5, 6657993, 23, 6657993, 23, 
  6657993, 23, 62973024, 33, 62973024, 33, 62973024, 33, 62973024, 33, 
  60052424, 8, 5631568, 34, 7665940, 19, 26882728, 23, 42135845, 24, 
  65767820, 5, 42135845, 24, 65767820, 5, 26882728, 23, 26882728, 23, 
  5631568, 34, 62973024, 33, 2214405, 17, 62973024, 33, 50677157, 34, 
  7665940, 19, 50677157, 34 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/gprdperm.gi", 18271093 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/gprdperm.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/gprdperm.gi");
elif COM_RESULT = 3  then
Revision.gprdperm_gi:="@(#)$Id: gprdperm.gi,v 4.37.2.3 2005/12/03 04:08:11 gap Exp $";
InstallMethod(DirectProductOp,"for a list of permutation groups, and a permutation group",IsCollsElms,[IsList and IsPermCollColl,IsPermGroup],0,COM_FUN(1));
InstallMethod(Size,"for a permutation group that knows to be a direct product",true,[IsPermGroup and HasDirectProductInfo],0,COM_FUN(2));
DeclareRepresentation("IsEmbeddingDirectProductPermGroup",IsAttributeStoringRep and IsGroupHomomorphism and IsInjective and IsSPGeneralMapping,["component"]);
DeclareRepresentation("IsEmbeddingWreathProductPermGroup",IsAttributeStoringRep and IsGroupHomomorphism and IsInjective and IsSPGeneralMapping,["component"]);
DeclareRepresentation("IsEmbeddingImprimitiveWreathProductPermGroup",IsEmbeddingWreathProductPermGroup,["component"]);
DeclareRepresentation("IsEmbeddingProductActionWreathProductPermGroup",IsEmbeddingWreathProductPermGroup and IsGroupGeneralMappingByAsGroupGeneralMap\
pingByImages,["component"]);
InstallMethod(Embedding,"perm direct product",true,[IsPermGroup and HasDirectProductInfo,IsPosInt],0,COM_FUN(3));
InstallMethod(Source,"perm direct product embedding",true,[IsEmbeddingDirectProductPermGroup],0,COM_FUN(4));
InstallMethod(ImagesRepresentative,"perm direct product embedding",FamSourceEqFamElm,[IsEmbeddingDirectProductPermGroup,IsMultiplicativeElementWithInverse],0,COM_FUN(5));
InstallMethod(PreImagesRepresentative,"perm direct product embedding",FamRangeEqFamElm,[IsEmbeddingDirectProductPermGroup,IsMultiplicativeElementWithInverse],COM_FUN(6));
InstallMethod(ImagesSource,"perm direct product embedding",true,[IsEmbeddingDirectProductPermGroup],0,COM_FUN(7));
InstallMethod(ViewObj,"for embedding into direct product",true,[IsEmbeddingDirectProductPermGroup],0,COM_FUN(8));
InstallMethod(PrintObj,"for embedding into direct product",true,[IsEmbeddingDirectProductPermGroup],0,COM_FUN(9));
DeclareRepresentation("IsProjectionDirectProductPermGroup",IsAttributeStoringRep and IsGroupHomomorphism and IsSurjective and IsSPGeneralMapping,["component"]);
InstallMethod(Projection,"perm direct product",true,[IsPermGroup and HasDirectProductInfo,IsPosInt],0,COM_FUN(10));
InstallMethod(Range,"perm direct product projection",true,[IsProjectionDirectProductPermGroup],0,COM_FUN(11));
InstallMethod(ImagesRepresentative,"perm direct product projection",FamSourceEqFamElm,[IsProjectionDirectProductPermGroup,IsMultiplicativeElementWithInverse],0,COM_FUN(12));
InstallMethod(PreImagesRepresentative,"perm direct product projection",FamRangeEqFamElm,[IsProjectionDirectProductPermGroup,IsMultiplicativeElementWithInverse],0,COM_FUN(13));
InstallMethod(KernelOfMultiplicativeGeneralMapping,"perm direct product projection",true,[IsProjectionDirectProductPermGroup],0,COM_FUN(14));
InstallMethod(ViewObj,"for projection from a direct product",true,[IsProjectionDirectProductPermGroup],0,COM_FUN(15));
InstallMethod(PrintObj,"for projection from a direct product",true,[IsProjectionDirectProductPermGroup],0,COM_FUN(16));
InstallGlobalFunction(SubdirectDiagonalPerms,COM_FUN(17));
InstallMethod(SubdirectProductOp,"permgroup",true,[IsPermGroup,IsPermGroup,IsGroupHomomorphism,IsGroupHomomorphism],0,COM_FUN(18));
DeclareRepresentation("IsProjectionSubdirectProductPermGroup",IsAttributeStoringRep and IsGroupHomomorphism and IsSurjective and IsSPGeneralMapping,["component"]);
InstallMethod(Projection,"perm subdirect product",true,[IsPermGroup and HasSubdirectProductInfo,IsPosInt],0,COM_FUN(19));
InstallMethod(Range,"perm subdirect product projection",true,[IsProjectionSubdirectProductPermGroup],0,COM_FUN(20));
InstallMethod(ImagesRepresentative,"perm subdirect product projection",FamSourceEqFamElm,[IsProjectionSubdirectProductPermGroup,IsMultiplicativeElementWithInverse],0,COM_FUN(21));
InstallMethod(PreImagesRepresentative,"perm subdirect product projection",FamRangeEqFamElm,[IsProjectionSubdirectProductPermGroup,IsMultiplicativeElementWithInverse],0,COM_FUN(22));
InstallMethod(KernelOfMultiplicativeGeneralMapping,"perm subdirect product projection",true,[IsProjectionSubdirectProductPermGroup],0,COM_FUN(23));
InstallMethod(ViewObj,"for projection from subdirect product",true,[IsProjectionSubdirectProductPermGroup],0,COM_FUN(24));
InstallMethod(PrintObj,"for projection from subdirect product",true,[IsProjectionSubdirectProductPermGroup],0,COM_FUN(25));
InstallGlobalFunction(WreathProductImprimitiveAction,COM_FUN(26));
InstallMethod(WreathProduct,"permgroups: imprimitive",true,[IsPermGroup,IsPermGroup],0,WreathProductImprimitiveAction);
InstallOtherMethod(WreathProduct,"permgroups and action",true,[IsPermGroup,IsPermGroup,IsSPGeneralMapping],0,WreathProductImprimitiveAction);
InstallMethod(Embedding,"perm wreath product",true,[IsPermGroup and HasWreathProductInfo,IsPosInt],0,COM_FUN(27));
InstallMethod(Source,"perm wreath product embedding",true,[IsEmbeddingWreathProductPermGroup],0,COM_FUN(28));
InstallMethod(ImagesRepresentative,"imprim perm wreath product embedding",FamSourceEqFamElm,[IsEmbeddingImprimitiveWreathProductPermGroup,IsMultiplicativeElementWithInverse],0,COM_FUN(29));
InstallMethod(PreImagesRepresentative,"imprim perm wreath product embedding",FamRangeEqFamElm,[IsEmbeddingImprimitiveWreathProductPermGroup,IsMultiplicativeElementWithInverse],0,COM_FUN(30));
InstallMethod(ViewObj,"for embedding into wreath product",true,[IsEmbeddingWreathProductPermGroup],0,COM_FUN(31));
InstallMethod(PrintObj,"for embedding into wreath product",true,[IsEmbeddingWreathProductPermGroup],0,COM_FUN(32));
InstallOtherMethod(Projection,"perm wreath product",true,[IsPermGroup and HasWreathProductInfo],0,COM_FUN(33));
InstallGlobalFunction(WreathProductProductAction,COM_FUN(34));
InstallMethod(SemidirectProduct,"generic method for permutation groups",true,[IsPermGroup,IsGroupHomomorphism,IsPermGroup],0,COM_FUN(35));
InstallMethod(Embedding,"generic method for perm semidirect products",true,[IsPermGroup and HasSemidirectProductInfo,IsPosInt],0,COM_FUN(36));
InstallOtherMethod(Projection,"generic method for perm semidirect products",true,[IsPermGroup and HasSemidirectProductInfo],0,COM_FUN(37));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/gprdperm.gi"

#F  file="lib/gprdpc.gi" crc=-99879880
RANK_FILTER_LIST  := [ 8193, 2, 66740907, 33, 53140563, 34, 7665940, 19, 
  53140563, 34, 7665940, 19, 30937393, 25, 2214405, 17, 30937393, 25, 
  66740907, 33, 4097, 1, 66740907, 33, 2214405, 17, 54445040, 34, 7665940, 
  19, 54445040, 34, 66740907, 33, 66740907, 33, 2214405, 17, 2214405, 17 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/gprdpc.gi", -99879880 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/gprdpc.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/gprdpc.gi");
elif COM_RESULT = 3  then
Revision.gprdpc_gi:="@(#)$Id: gprdpc.gi,v 4.24.4.2 2004/03/04 22:25:02 gap Exp $";
InstallMethod(DirectProductOp,"for a list (of pc groups), and a pc group",true,[IsList,IsPcGroup],0,COM_FUN(1));
InstallMethod(Embedding,"of pc group and integer",true,[IsPcGroup and HasDirectProductInfo,IsPosInt],0,COM_FUN(2));
InstallMethod(Projection,"of pc group and integer",true,[IsPcGroup and HasDirectProductInfo,IsPosInt],0,COM_FUN(3));
InstallMethod(SemidirectProduct,"generic method for pc groups",true,[CanEasilyComputePcgs,IsGroupHomomorphism,CanEasilyComputePcgs],0,COM_FUN(4));
InstallOtherMethod(SemidirectProduct,"generic method for pc groups",true,[IsPcGroup,IsRecord],0,COM_FUN(5));
InstallOtherMethod(SemidirectProduct,"generic method for pc groups",true,[IsPcGroup,IsGroupHomomorphism],0,COM_FUN(6));
InstallMethod(Embedding,"of semidirect pc group and integer",true,[IsPcGroup and HasSemidirectProductInfo,IsPosInt],0,COM_FUN(7));
InstallOtherMethod(Projection,"of semidirect pc group",true,[IsPcGroup and HasSemidirectProductInfo],0,COM_FUN(8));
InstallGlobalFunction(SubdirProdPcGroups,COM_FUN(9));
InstallMethod(SubdirectProductOp,"pcgroup",true,[IsPcGroup,IsPcGroup,IsGroupHomomorphism,IsGroupHomomorphism],0,COM_FUN(10));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/gprdpc.gi"

#F  file="lib/oprt.gi" crc=5669872
RANK_FILTER_LIST  := [ 29419057, 21, 4063233, 1, 8193, 2, 8193, 2, 5, 1, 
  55180923, 6, 29419057, 21, 55180923, 6, 20971131, 9, 55180923, 6, 55180923, 
  6, 55180923, 6, 29419057, 21, 8193, 2, 8193, 2, 8193, 2, 8193, 2, 5, 1, 
  29419057, 21, 55180923, 6, 8193, 2, 8193, 2, 8193, 2, 5, 1, 29419057, 21, 
  8193, 2, 8193, 2, 8193, 2, 5, 1, 43252966, 9, 43252966, 9, 60030527, 10, 
  19398012, 10, 19398012, 10, 29419057, 21, 4063233, 1, 1, 0, 8193, 2, 8193, 
  2, 5, 1, 29419057, 21, 55180923, 6, 1, 0, 8193, 2, 8193, 2, 5, 1, 29419057, 
  21, 1, 0, 8193, 2, 8193, 2, 5, 1, 19398012, 10, 19398012, 10, 19398012, 10, 
  19398012, 10, 19398012, 10, 19398012, 10, 19398012, 10, 19398012, 10, 
  19399934, 12, 19399934, 12, 7847704, 11, 7847704, 11, 1, 0, 19399934, 12, 
  1, 0, 19398012, 10, 1, 0, 55184767, 7, 1, 0, 19428764, 11, 1, 0, 19644028, 
  11, 1, 0, 20382076, 11, 1, 0, 7847704, 11, 55180923, 6, 55180923, 6, 
  33554163, 22, 33554163, 22, 33554163, 22, 33554163, 22, 52427601, 24, 
  33554163, 22, 29419057, 21, 29419057, 21, 4063233, 1, 1, 0, 8193, 2, 8193, 
  2, 5, 1, 29419057, 21, 1, 0, 8193, 2, 8193, 2, 5, 1, 29419057, 21, 4063233, 
  1, 1, 0, 8193, 2, 8193, 2, 5, 1, 29419057, 21, 1, 0, 8193, 2, 8193, 2, 5, 
  1, 29419057, 21, 4063233, 1, 1, 0, 8193, 2, 8193, 2, 5, 1, 29419057, 21, 1, 
  0, 8193, 2, 8193, 2, 5, 1, 17941365, 29, 1, 0, 1, 0, 8193, 2, 8193, 2, 
  4097, 1, 29419057, 21, 1, 0, 1, 0, 8193, 2, 8193, 2, 4097, 1, 29419057, 21, 
  16784689, 3, 8193, 2, 8193, 2, 5, 1, 29419057, 21, 4063233, 1, 8193, 2, 
  8193, 2, 5, 1, 29419057, 21, 41951068, 17, 8193, 2, 8193, 2, 5, 1, 
  29419057, 21, 29419057, 21, 4063233, 1, 8193, 2, 8193, 2, 5, 1, 29419057, 
  21, 41951068, 17, 8193, 2, 8193, 2, 5, 1, 29419057, 21, 29419057, 21, 8193, 
  2, 8193, 2, 8193, 2, 8193, 2, 5, 1, 29419057, 21, 8193, 2, 8193, 2, 8193, 
  2, 5, 1, 29419057, 21, 8193, 2, 8193, 2, 8193, 2, 5, 1, 29419057, 21, 
  4063233, 1, 8193, 2, 8193, 2, 5, 1, 29419057, 21, 55180923, 6, 8193, 2, 
  8193, 2, 5, 1, 29419057, 21, 4063233, 1, 8193, 2, 8193, 2, 5, 1, 29419057, 
  21, 55180923, 6, 8193, 2, 8193, 2, 5, 1, 1, 0, 8193, 2, 5, 1, 1, 0, 8193, 
  2, 1, 0, 5, 1, 1, 0, 8193, 2, 1, 0, 5, 1, 1, 0, 1, 0, 5, 1, 1, 0, 8193, 2, 
  5, 1, 29419057, 21, 8193, 2, 8193, 2, 8193, 2, 5, 1, 29419057, 21, 8193, 2, 
  8193, 2, 8193, 2, 8193, 2, 5, 1, 29419057, 21, 41951068, 17, 8193, 2, 8193, 
  2, 8193, 2, 5, 1, 29419057, 21, 8193, 2, 8193, 2, 8193, 2, 5, 1, 29419057, 
  21, 8193, 2, 8193, 2, 8193, 2, 8193, 2, 5, 1, 29419057, 21, 4063233, 1, 1, 
  0, 8193, 2, 8193, 2, 5, 1, 29419057, 21, 1, 0, 8193, 2, 8193, 2, 5, 1, 
  29419057, 21, 4063233, 1, 8193, 2, 8193, 2, 5, 1, 29419057, 21, 4063233, 1, 
  8193, 2, 8193, 2, 5, 1, 1, 0, 8193, 2, 1, 0, 5, 1, 1, 0, 1, 0, 5, 1, 1, 0, 
  8193, 2, 5, 1, 65767820, 5, 4063233, 1, 5, 1, 29407897, 26, 4063233, 1, 5, 
  1, 29419057, 21, 4063233, 1, 8193, 2, 8193, 2, 5, 1, 29419057, 21, 4063233, 
  1, 8193, 2, 8193, 2, 5, 1, 29419057, 21, 41951068, 17, 8193, 2, 8193, 2, 5, 
  1, 29419057, 21, 4063233, 1, 8193, 2, 8193, 2, 5, 1, 29419057, 21, 1025, 1, 
  29419057, 21, 4063233, 1, 8193, 2, 8193, 2, 5, 1, 29419057, 21, 4063233, 1, 
  8193, 2, 8193, 2, 5, 1, 29419057, 21, 41951068, 17, 8193, 2, 8193, 2, 5, 1, 
  29419057, 21, 8193, 2, 8193, 2, 41951068, 17, 5, 1, 29419057, 21, 4063233, 
  1, 8193, 2, 8193, 2, 5, 1, 29419057, 21, 8193, 2, 1, 0, 1, 0, 5, 1, 
  29419057, 21, 1, 0, 1, 0, 5, 1, 29419057, 21, 4063233, 1, 1, 0, 8193, 2, 
  8193, 2, 5, 1, 29419057, 21, 1, 0, 8193, 2, 8193, 2, 5, 1, 29419057, 21, 
  4063233, 1, 8193, 2, 8193, 2, 5, 1, 29419057, 21, 26132143, 27, 8193, 2, 
  8193, 2, 5, 1, 29419057, 21, 41951068, 17, 8193, 2, 8193, 2, 5, 1, 
  55180923, 6, 43630615, 7, 55180923, 6, 55180923, 6, 33554163, 22, 65767820, 
  5, 51576083, 23, 65767820, 5, 51576083, 23, 33554163, 22, 29397815, 24, 
  65767820, 5, 16645267, 23, 21551523, 23, 65767820, 5, 58359323, 23, 513, 8, 
  58359323, 23, 1, 0, 4063233, 1, 5, 1, 29419057, 21, 29419057, 21, 29419057, 
  21, 58359323, 23 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/oprt.gi", 5669872 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/oprt.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/oprt.gi");
elif COM_RESULT = 3  then
Revision.oprt_gi:="@(#)$Id: oprt.gi,v 4.179.2.7 2007/04/24 15:32:17 gap Exp $";
InstallMethod(ExternalSet,"G, D, gens, acts, act",true,OrbitsishReq,0,COM_FUN(1));
InstallGlobalFunction(ExternalSetByFilterConstructor,COM_FUN(2));
InstallGlobalFunction(ExternalSetByTypeConstructor,COM_FUN(3));
InstallMethod(RestrictedExternalSet,"restrict the acting domain",true,[IsExternalSet,IsGroup],0,COM_FUN(4));
InstallMethod(Enumerator,"external set -> HomeEnumerator",true,[IsExternalSet],0,HomeEnumerator);
InstallMethod(FunctionAction,"ExternalSetByActorsRep",true,[IsExternalSetByActorsRep],0,COM_FUN(5));
InstallMethod(PrintObj,"External Set",true,[IsExternalSet],0,COM_FUN(6));
InstallMethod(ViewObj,"External Set",true,[IsExternalSet],0,COM_FUN(7));
InstallMethod(Representative,"External Set",true,[IsExternalSet],0,COM_FUN(8));
InstallMethod(ExternalSubsetOp,"G, D, start, gens, acts, act",true,[IsGroup,IsList,IsList,IsList,IsList,IsFunction],0,COM_FUN(9));
InstallOtherMethod(ExternalSubsetOp,"G, xset, start, gens, acts, act",true,[IsGroup,IsExternalSet,IsList,IsList,IsList,IsFunction],0,COM_FUN(10));
InstallOtherMethod(ExternalSubsetOp,"G, start, gens, acts, act",true,[IsGroup,IsList,IsList,IsList,IsFunction],0,COM_FUN(11));
InstallMethod(ViewObj,"for external subset",true,[IsExternalSubset],0,COM_FUN(12));
InstallMethod(PrintObj,"for external subset",true,[IsExternalSubset],0,COM_FUN(13));
InstallMethod(Enumerator,"for external subset with home enumerator",[IsExternalSubset and HasHomeEnumerator],COM_FUN(14));
InstallMethod(Enumerator,"for external orbit: compute orbit",true,[IsExternalOrbit],0,COM_FUN(15));
InstallMethod(Random,"for external orbit: via acting domain",true,[IsExternalOrbit],0,COM_FUN(16));
InstallMethod(ExternalOrbitOp,"G, D, pnt, gens, acts, act",true,OrbitishReq,0,COM_FUN(17));
InstallOtherMethod(ExternalOrbitOp,"G, xset, pnt, gens, acts, act",true,[IsGroup,IsExternalSet,IsObject,IsList,IsList,IsFunction],0,COM_FUN(18));
InstallOtherMethod(ExternalOrbitOp,"G, pnt, gens, acts, act",true,[IsGroup,IsObject,IsList,IsList,IsFunction],0,COM_FUN(19));
InstallMethod(ViewObj,"for external orbit",true,[IsExternalOrbit],0,COM_FUN(20));
InstallMethod(PrintObj,"for external orbit",true,[IsExternalOrbit],0,COM_FUN(21));
InstallMethod(AsList,"external orbit",true,[IsExternalOrbit],0,COM_FUN(22));
InstallMethod(AsSSortedList,"external orbit",true,[IsExternalOrbit],0,COM_FUN(23));
InstallMethod(\=,"xorbs",IsIdenticalObj,[IsExternalOrbit,IsExternalOrbit],0,COM_FUN(24));
InstallMethod(\<,"xorbs, via AsSSortedList",IsIdenticalObj,[IsExternalOrbit,IsExternalOrbit],0,COM_FUN(25));
InstallMethod(\=,"xorbs which know their size",IsIdenticalObj,[IsExternalOrbit and HasSize,IsExternalOrbit and HasSize],0,COM_FUN(26));
InstallMethod(\=,"xorbs with canonicalRepresentativeDeterminator",IsIdenticalObj,[IsExternalOrbit and HasCanonicalRepresentativeDeterminatorOfExternalSet,IsExternalOrbit and HasCanonicalRepresentativeDeterminatorOfExternalSet],0,COM_FUN(27));
InstallMethod(\in,"very small xorbs: test in AsList",IsElmsColls,[IsObject,IsExternalOrbit and HasSize],0,COM_FUN(28));
InstallMethod(\in,"xorb: RepresentativeAction",IsElmsColls,[IsObject,IsExternalOrbit],0,COM_FUN(29));
InstallMethod(\in,"xset: Test representative equal",IsElmsColls,[IsObject,IsExternalSet and HasRepresentative],10,COM_FUN(30));
InstallMethod(\in,"xorb: HasEnumerator",IsElmsColls,[IsObject,IsExternalOrbit and HasEnumerator],0,COM_FUN(31));
InstallMethod(\in,"xorb HasAsList",IsElmsColls,[IsObject,IsExternalOrbit and HasAsList],1,COM_FUN(32));
InstallMethod(\in,"xorb HasAsSSortedList",IsElmsColls,[IsObject,IsExternalOrbit and HasAsSSortedList],2,COM_FUN(33));
InstallMethod(\in,"by CanonicalRepresentativeDeterminator",IsElmsColls,[IsObject,IsExternalOrbit and HasCanonicalRepresentativeDeterminatorOfExternalSet],1,COM_FUN(34));
InstallGlobalFunction(ActionHomomorphism,COM_FUN(35));
InstallGlobalFunction(ActionHomomorphismConstructor,COM_FUN(36));
InstallMethod(ActionHomomorphismAttr,"call OpHomConstructor",true,[IsExternalSet],0,COM_FUN(37));
InstallMethod(SurjectiveActionHomomorphismAttr,"call Ac.Hom.Constructor",true,[IsExternalSet],0,COM_FUN(38));
VPActionHom:=COM_FUN(39);
InstallMethod(ViewObj,"for action homomorphism",true,[IsActionHomomorphism],0,VPActionHom);
InstallMethod(PrintObj,"for action homomorphism",true,[IsActionHomomorphism],0,VPActionHom);
InstallMethod(Source,"action homomorphism",true,[IsActionHomomorphism],0,COM_FUN(40));
InstallMethod(Range,"ophom: S(domain)",true,[IsActionHomomorphism],0,COM_FUN(41));
InstallMethod(Range,"surjective action homomorphism",[IsActionHomomorphism and IsSurjective],COM_FUN(42));
InstallMethod(RestrictedMapping,"action homomorphism",CollFamSourceEqFamElms,[IsActionHomomorphism,IsGroup],0,COM_FUN(43));
InstallGlobalFunction(Action,COM_FUN(44));
InstallMethod(OrbitOp,"G, D, pnt, [ 1gen ], [ 1act ], act",true,OrbitishReq,20,COM_FUN(45));
InstallOtherMethod(OrbitOp,"G, pnt, [ 1gen ], [ 1act ], act",true,[IsGroup,IsObject,IsList,IsList,IsFunction],20,COM_FUN(46));
InstallMethod(OrbitOp,"with domain",true,OrbitishReq,0,COM_FUN(47));
InstallOtherMethod(OrbitOp,"standard orbit algorithm:list",true,[IsGroup,IsObject,IsList,IsList,IsFunction],0,COM_FUN(48));
InstallGlobalFunction(OrbitByPosOp,COM_FUN(49));
InstallMethod(OrbitStabilizerOp,"`OrbitStabilizerAlgorithm' with domain",true,OrbitishReq,0,COM_FUN(50));
InstallOtherMethod(OrbitStabilizerOp,"`OrbitStabilizerAlgorithm' without domain",true,[IsGroup,IsObject,IsList,IsList,IsFunction],0,COM_FUN(51));
InstallMethod(OrbitStabilizerAlgorithm,"use stabilizer size",true,[IsGroup and IsFinite and CanComputeSizeAnySubgroup,IsObject,IsObject,IsList,IsList,IsRecord],0,COM_FUN(52));
InstallMethod(OrbitStabilizerAlgorithm,"collect stabilizer generators",true,[IsGroup,IsObject,IsObject,IsList,IsList,IsRecord],0,COM_FUN(53));
BindGlobal("OrbitsByPosOp",COM_FUN(54));
InstallMethod(OrbitsDomain,"for quick position domains",true,[IsGroup,IsList and IsQuickPositionList,IsList,IsList,IsFunction],0,OrbitsByPosOp);
InstallMethod(OrbitsDomain,"for arbitrary domains",true,OrbitsishReq,0,COM_FUN(55));
InstallMethod(OrbitsDomain,"empty domain",true,[IsGroup,IsList and IsEmpty,IsList,IsList,IsFunction],0,COM_FUN(56));
InstallOtherMethod(OrbitsDomain,"group without domain",true,[IsGroup],0,COM_FUN(57));
InstallMethod(Orbits,"for arbitrary domains",true,OrbitsishReq,0,COM_FUN(58));
InstallMethod(OrbitsDomain,"empty domain",true,[IsGroup,IsList and IsEmpty,IsList,IsList,IsFunction],0,COM_FUN(59));
InstallOtherMethod(Orbits,"group without domain",true,[IsGroup],0,COM_FUN(60));
InstallMethod(SparseActionHomomorphismOp,"domain given",true,[IsGroup,IsList,IsList,IsList,IsList,IsFunction],0,COM_FUN(61));
InstallGlobalFunction(DoSparseActionHomomorphism,COM_FUN(62));
InstallOtherMethod(SparseActionHomomorphismOp,"no domain given",true,[IsGroup,IsList,IsList,IsList,IsFunction],0,COM_FUN(63));
InstallOtherMethod(SortedSparseActionHomomorphismOp,"no domain given",true,[IsGroup,IsList,IsList,IsList,IsFunction],0,COM_FUN(64));
InstallMethod(ExternalOrbits,"G, D, gens, acts, act",true,OrbitsishReq,0,COM_FUN(65));
InstallOtherMethod(ExternalOrbits,"G, xset, gens, acts, act",true,[IsGroup,IsExternalSet,IsList,IsList,IsFunction],0,COM_FUN(66));
BindGlobal("ExtOrbStabDom",COM_FUN(67));
InstallMethod(ExternalOrbitsStabilizers,"arbitrary domain",true,OrbitsishReq,0,COM_FUN(68));
InstallOtherMethod(ExternalOrbitsStabilizers,"external set",true,[IsGroup,IsExternalSet,IsList,IsList,IsFunction],0,COM_FUN(69));
InstallGlobalFunction(Permutation,COM_FUN(70));
InstallMethod(PermutationOp,"object on list",true,[IsObject,IsList,IsFunction],0,COM_FUN(71));
InstallGlobalFunction(PermutationCycle,COM_FUN(72));
InstallMethod(PermutationCycleOp,"of object in list",true,[IsObject,IsList,IsObject,IsFunction],0,COM_FUN(73));
InstallGlobalFunction(Cycle,COM_FUN(74));
InstallMethod(CycleOp,"of object in list",true,[IsObject,IsList,IsObject,IsFunction],0,COM_FUN(75));
CycleByPosOp:=COM_FUN(76);
InstallOtherMethod(CycleOp,true,[IsObject,IsObject,IsFunction],0,COM_FUN(77));
InstallGlobalFunction(Cycles,COM_FUN(78));
InstallMethod(CyclesOp,true,[IsObject,IsList,IsFunction],1,COM_FUN(79));
InstallOtherMethod(BlocksOp,"G, D, gens, acts, act",true,[IsGroup,IsList,IsList,IsList,IsFunction],0,COM_FUN(80));
InstallMethod(BlocksOp,"G, D, seed, gens, acts, act",true,[IsGroup,IsList,IsList,IsList,IsList,IsFunction],0,COM_FUN(81));
InstallMethod(BlocksOp,"G, [  ], seed, gens, acts, act",true,[IsGroup,IsList and IsEmpty,IsList,IsList,IsList,IsFunction],20,COM_FUN(82));
InstallOtherMethod(MaximalBlocksOp,"G, D, gens, acts, act",true,[IsGroup,IsList,IsList,IsList,IsFunction],0,COM_FUN(83));
InstallMethod(MaximalBlocksOp,"G, D, seed, gens, acts, act",true,[IsGroup,IsList,IsList,IsList,IsList,IsFunction],0,COM_FUN(84));
InstallMethod(OrbitLengthOp,"compute orbit",true,OrbitishReq,0,COM_FUN(85));
InstallOtherMethod(OrbitLengthOp,"compute orbit",true,[IsGroup,IsObject,IsList,IsList,IsFunction],0,COM_FUN(86));
InstallMethod(OrbitLengths,"compute orbits",true,OrbitsishReq,0,COM_FUN(87));
InstallMethod(OrbitLengthsDomain,"compute orbits",true,OrbitsishReq,0,COM_FUN(88));
InstallGlobalFunction(CycleLength,COM_FUN(89));
InstallMethod(CycleLengthOp,true,[IsObject,IsList,IsObject,IsFunction],0,COM_FUN(90));
InstallOtherMethod(CycleLengthOp,true,[IsObject,IsObject,IsFunction],0,COM_FUN(91));
InstallGlobalFunction(CycleLengths,COM_FUN(92));
InstallMethod(CycleLengthsOp,true,[IsObject,IsList,IsFunction],0,COM_FUN(93));
InstallGlobalFunction(CycleIndex,COM_FUN(94));
InstallOtherMethod(CycleIndexOp,"element",true,[IsMultiplicativeElementWithInverse,IsListOrCollection,IsFunction],0,COM_FUN(95));
InstallMethod(CycleIndexOp,"finite group",true,[IsGroup and IsFinite,IsListOrCollection,IsFunction],0,COM_FUN(96));
InstallMethod(IsTransitive,"compare with orbit of element",true,OrbitsishReq,0,COM_FUN(97));
InstallMethod(Transitivity,"of the image of an ophom",true,OrbitsishReq,0,COM_FUN(98));
InstallMethod(Transitivity,"G, [  ], gens, perms, act",true,[IsGroup,IsList and IsEmpty,IsList,IsList,IsFunction],20,COM_FUN(99));
InstallMethod(IsPrimitive,"transitive and no blocks",true,OrbitsishReq,0,COM_FUN(100));
InstallOtherMethod(SetEarns,"never set fail",true,[IsGroup,IsBool],0,COM_FUN(101));
InstallMethod(IsPrimitiveAffine,"primitive and earns",true,OrbitsishReq,0,COM_FUN(102));
InstallMethod(IsSemiRegular,"via ophom",true,OrbitsishReq,0,COM_FUN(103));
InstallMethod(IsSemiRegular,"G, [  ], gens, perms, act",true,[IsGroup,IsList and IsEmpty,IsList,IsList,IsFunction],20,COM_FUN(104));
InstallMethod(IsSemiRegular,"G, D, gens, [  ], act",true,[IsGroup,IsList,IsList,IsList and IsEmpty,IsFunction],20,COM_FUN(105));
InstallMethod(IsRegular,"transitive and semiregular",true,OrbitsishReq,0,COM_FUN(106));
InstallGlobalFunction(RepresentativeAction,COM_FUN(107));
InstallMethod(RepresentativeActionOp,"ignore domain",true,[IsGroup,IsList,IsObject,IsObject,IsFunction],0,COM_FUN(108));
InstallOtherMethod(RepresentativeActionOp,"orbit algorithm: trace transversal",true,[IsGroup,IsObject,IsObject,IsFunction],0,COM_FUN(109));
InstallGlobalFunction(Stabilizer,COM_FUN(110));
InstallMethod(StabilizerOp,"`OrbitStabilizerAlgorithm' with domain",true,OrbitishReq,0,COM_FUN(111));
InstallOtherMethod(StabilizerOp,"`OrbitStabilizerAlgorithm' without domain",true,[IsGroup,IsObject,IsList,IsList,IsFunction],0,COM_FUN(112));
InstallMethod(RankAction,"via ophom",true,OrbitsishReq,0,COM_FUN(113));
InstallMethod(RankAction,"G, ints, gens, perms, act",true,[IsGroup,IsList and IsCyclotomicCollection,IsList,IsList,IsFunction],0,COM_FUN(114));
InstallMethod(RankAction,"G, [  ], gens, perms, act",true,[IsGroup,IsList and IsEmpty,IsList,IsList,IsFunction],20,COM_FUN(115));
InstallMethod(CanonicalRepresentativeOfExternalSet,"smallest element",true,[IsExternalSet],0,COM_FUN(116));
InstallMethod(CanonicalRepresentativeOfExternalSet,"by CanonicalRepresentativeDeterminator",true,[IsExternalSet and HasCanonicalRepresentativeDeterminatorOfExternalSet],0,COM_FUN(117));
InstallMethod(ActorOfExternalSet,true,[IsExternalSet],0,COM_FUN(118));
InstallMethod(StabilizerOfExternalSet,"stabilizer of the represenattive",true,[IsExternalSet],0,COM_FUN(119));
InstallGlobalFunction(ImageElmActionHomomorphism,COM_FUN(120));
InstallMethod(ImagesRepresentative,"for action hom",FamSourceEqFamElm,[IsActionHomomorphism,IsMultiplicativeElementWithInverse],0,ImageElmActionHomomorphism);
InstallMethod(ImagesRepresentative,"for action hom that is `ByAsGroup'",FamSourceEqFamElm,[IsGroupGeneralMappingByAsGroupGeneralMappingByImages and IsActionHomomorphism,\
IsMultiplicativeElementWithInverse],0,COM_FUN(121));
InstallMethod(MappingGeneratorsImages,"for action hom that is `ByAsGroup'",true,[IsGroupGeneralMappingByAsGroupGeneralMappingByImages and IsActionHomomorphism],0,COM_FUN(122));
InstallMethod(KernelOfMultiplicativeGeneralMapping,"for action homomorphism",true,[IsActionHomomorphism],0,COM_FUN(123));
InstallMethod(ImagesRepresentative,"using `RepresentativeAction'",FamSourceEqFamElm,[IsActionHomomorphismByBase and HasImagesSource,IsMultiplicativeElementWithInverse],0,COM_FUN(124));
InstallMethod(ImagesSource,"actionHomomorphismByBase",true,[IsActionHomomorphismByBase],0,COM_FUN(125));
InstallMethod(ImagesRepresentative,"restricted perm",FamSourceEqFamElm,[IsActionHomomorphismSubset,IsMultiplicativeElementWithInverse],0,COM_FUN(126));
InstallMethod(PreImagesRepresentative,"IsLinearActionHomomorphism",FamRangeEqFamElm,[IsLinearActionHomomorphism,IsPerm],0,COM_FUN(127));
InstallMethod(LinearActionBasis,"find basis in domain",true,[IsLinearActionHomomorphism],0,COM_FUN(128));
InstallMethod(DomainForAction,"default: fail",true,[IsObject,IsListOrCollection,IsFunction],0,COM_FUN(129));
InstallMethod(AbelianSubfactorAction,"generic:use modulo pcgs",true,[IsGroup,IsGroup,IsGroup],0,COM_FUN(130));
InstallMethod(IsInjective,"for a linear action homomorphism",[IsLinearActionHomomorphism],COM_FUN(131));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/oprt.gi"

#F  file="lib/oprtperm.gi" crc=55251805
RANK_FILTER_LIST  := [ 62973024, 33, 17, 18, 8193, 2, 8193, 2, 5, 1, 
  62973024, 33, 17, 18, 8193, 2, 8193, 2, 5, 1, 29419057, 21, 26132143, 27, 
  8193, 2, 33562160, 36, 5, 1, 29419057, 21, 26132143, 27, 8193, 2, 33562160, 
  36, 5, 1, 513, 8, 17, 18, 5, 1, 575, 9, 17, 18, 513, 8, 17, 18, 5, 1, 575, 
  9, 17, 18, 29419057, 21, 26132143, 27, 41951068, 17, 8193, 2, 33562160, 36, 
  5, 1, 29419057, 21, 26132143, 27, 26132143, 27, 8193, 2, 33562160, 36, 5, 
  1, 29419057, 21, 26132143, 27, 8193, 2, 33562160, 36, 5, 1, 29419057, 21, 
  26132143, 27, 41942876, 3, 8193, 2, 33562160, 36, 5, 1, 29419057, 21, 8193, 
  2, 8193, 2, 8193, 2, 5, 1, 62973024, 33, 8193, 2, 8193, 2, 8193, 2, 5, 1, 
  62973024, 33, 26132143, 27, 8193, 2, 8193, 2, 5, 1, 29419057, 21, 26132143, 
  27, 8193, 2, 33562160, 36, 5, 1, 62973024, 33, 62974946, 34, 65767820, 5, 
  62973024, 33, 1, 0, 1, 0, 5, 1, 65767820, 5, 64094577, 23, 62973024, 33, 1, 
  0, 8193, 2, 8193, 2, 5, 1 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/oprtperm.gi", 55251805 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/oprtperm.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/oprtperm.gi");
elif COM_RESULT = 3  then
Revision.oprtperm_gi:="@(#)$Id: oprtperm.gi,v 4.73.2.3 2006/08/16 21:34:30 gap Exp $";
InstallOtherMethod(OrbitOp,"G, int, gens, perms, act = `OnPoints'",true,[IsPermGroup,IsInt,IsList,IsList,IsFunction],0,COM_FUN(1));
InstallOtherMethod(OrbitStabilizerOp,"permgroup",true,[IsPermGroup,IsInt,IsList,IsList,IsFunction],0,COM_FUN(2));
ORBS_PERMGP_PTS:=COM_FUN(3);
InstallMethod(Orbits,"permgroup on points",true,[IsGroup,IsList and IsCyclotomicCollection,IsList,IsList and IsPermCollection,IsFunction],0,ORBS_PERMGP_PTS);
InstallMethod(OrbitsDomain,"permgroup on points",true,[IsGroup,IsList and IsCyclotomicCollection,IsList,IsList and IsPermCollection,IsFunction],0,ORBS_PERMGP_PTS);
InstallOtherMethod(CycleOp,"perm, int, act",true,[IsPerm,IsInt,IsFunction],0,COM_FUN(4));
InstallOtherMethod(CycleOp,"perm, int",true,[IsPerm and IsInternalRep,IsInt],0,COM_FUN(5));
InstallOtherMethod(CycleLengthOp,"perm, int, act",true,[IsPerm,IsInt,IsFunction],0,COM_FUN(6));
InstallOtherMethod(CycleLengthOp,"perm, int",true,[IsPerm and IsInternalRep,IsInt],0,CycleLengthPermInt);
InstallMethod(BlocksOp,"permgroup on integers",[IsGroup,IsList and IsCyclotomicCollection,IsList and IsEmpty,IsList,IsList and IsPermCollection,IsFunction],COM_FUN(7));
InstallMethod(BlocksOp,"integers, with seed",true,[IsGroup,IsList and IsCyclotomicCollection,IsList and IsCyclotomicCollection,IsList,IsList and IsPermCollection,IsFunction],0,COM_FUN(8));
InstallOtherMethod(RepresentativesMinimalBlocksOp,"permgrp on points",true,[IsGroup,IsList and IsCyclotomicCollection,IsList,IsList and IsPermCollection,IsFunction],0,COM_FUN(9));
InstallOtherMethod(RepresentativesMinimalBlocksOp,"G, domain, noseed, gens, perms, act",true,[IsGroup,IsList and IsCyclotomicCollection,IsEmpty,IsList,IsList and IsPermCollection,IsFunction],0,COM_FUN(10));
InstallOtherMethod(RepresentativesMinimalBlocksOp,"general case: translate",true,[IsGroup,IsList,IsList,IsList,IsFunction],-1,COM_FUN(11));
InstallMethod(Earns,"G, ints, gens, perms, act",true,[IsPermGroup,IsList,IsList,IsList,IsFunction],0,COM_FUN(12));
InstallMethod(Transitivity,"permgroup on numbers",true,[IsPermGroup,IsList and IsCyclotomicCollection,IsList,IsList,IsFunction],0,COM_FUN(13));
InstallMethod(IsSemiRegular,"permgroup on numbers",true,[IsGroup,IsList and IsCyclotomicCollection,IsList,IsList and IsPermCollection,IsFunction],0,COM_FUN(14));
InstallOtherMethod(IsRegular,"permgroup",true,[IsPermGroup],0,COM_FUN(15));
InstallOtherMethod(IsRegular,"permgroup with known size",true,[IsPermGroup and HasSize],0,COM_FUN(16));
InstallTrueMethod(IsSemiRegular,IsPermGroup and IsRegular);
InstallTrueMethod(IsTransitive,IsPermGroup and IsRegular);
InstallTrueMethod(IsRegular,IsPermGroup and IsSemiRegular and IsTransitive);
InstallOtherMethod(RepresentativeActionOp,"permgrp",true,[IsPermGroup,IsObject,IsObject,IsFunction],2*RankFilter(IsMultiplicativeElementWithInverse),COM_FUN(17));
InstallOtherMethod(StabilizerOp,"permutation group",true,[IsPermGroup,IsObject,IsList,IsList,IsFunction],RankFilter(IsMultiplicativeElementWithInverse)+RankFilter(IsSolvableGroup),COM_FUN(18));
InstallGlobalFunction(StabilizerOfBlockNC,COM_FUN(19));
InstallGlobalFunction(OnSetsSets,COM_FUN(20));
InstallGlobalFunction(OnSetsDisjointSets,COM_FUN(21));
InstallGlobalFunction(OnSetsTuples,COM_FUN(22));
InstallGlobalFunction(OnTuplesSets,COM_FUN(23));
InstallGlobalFunction(OnTuplesTuples,COM_FUN(24));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/oprtperm.gi"

#F  file="lib/oprtpcgs.gi" crc=-104585623
RANK_FILTER_LIST  := [ 29419057, 21, 8193, 2, 1, 0, 57409522, 23, 8193, 2, 5, 
  1, 29419057, 21, 1, 0, 57409522, 23, 8193, 2, 5, 1, 29419057, 21, 1, 0, 1, 
  0, 58719912, 21, 8193, 2, 4097, 1, 58195954, 11, 58195954, 11, 58195954, 
  11, 58195954, 11, 29419057, 21, 8193, 2, 1, 0, 57409522, 23, 8193, 2, 5, 1, 
  29419057, 21, 1, 0, 57409522, 23, 8193, 2, 5, 1, 29419057, 21, 8193, 2, 1, 
  0, 1, 0, 57409522, 23, 8193, 2, 5, 1, 29419057, 21, 8193, 2, 1, 0, 
  57409522, 23, 8193, 2, 5, 1, 29419057, 21, 1, 0, 57409522, 23, 8193, 2, 5, 
  1, 60356449, 25, 1, 0, 8193, 2, 8193, 2, 5, 1, 60356449, 25, 4063233, 1, 1, 
  0, 8193, 2, 8193, 2, 5, 1, 60356449, 25, 1, 0, 57409522, 23, 8193, 2, 5, 1, 
  60356449, 25, 1, 0, 1, 0, 57409522, 23, 8193, 2, 5, 1 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/oprtpcgs.gi", -104585623 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/oprtpcgs.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/oprtpcgs.gi");
elif COM_RESULT = 3  then
Revision.oprtpcgs_gi:="@(#)$Id: oprtpcgs.gi,v 4.47 2002/04/15 10:05:06 sal Exp $";
InstallGlobalFunction(Pcs_OrbitStabilizer,COM_FUN(1));
InstallGlobalFunction(Pcgs_OrbitStabilizer,COM_FUN(2));
InstallGlobalFunction(StabilizerPcgs,COM_FUN(3));
BindGlobal("Pcgs_MutableOrbitStabilizerOp",COM_FUN(4));
InstallMethod(OrbitStabilizerOp,"G, D, pnt, pcgs, acts, act",true,[IsGroup,IsList,IsObject,IsPrimeOrdersPcgs,IsList,IsFunction],0,COM_FUN(5));
InstallOtherMethod(OrbitStabilizerOp,"G, pnt, pcgs, acts, act",true,[IsGroup,IsObject,IsPrimeOrdersPcgs,IsList,IsFunction],0,COM_FUN(6));
InstallMethod(OrbitStabilizerAlgorithm,"for pcgs",true,[IsGroup,IsObject,IsObject,IsPcgs,IsList,IsRecord],0,COM_FUN(7));
InstallGlobalFunction(SetCanonicalRepresentativeOfExternalOrbitByPcgs,COM_FUN(8));
InstallMethod(Enumerator,"<xorb by pcgs>",true,[IsExternalOrbit and IsExternalSetByPcgs],0,COM_FUN(9));
InstallMethod(CanonicalRepresentativeOfExternalSet,"via `ActorOfExternalSet'",true,[IsExternalOrbit and IsExternalSetByPcgs],0,COM_FUN(10));
InstallMethod(ActorOfExternalSet,true,[IsExternalOrbit and IsExternalSetByPcgs],0,COM_FUN(11));
InstallMethod(StabilizerOfExternalSet,true,[IsExternalOrbit and IsExternalSetByPcgs],0,COM_FUN(12));
BindGlobal("DoPcgsOrbitOp",COM_FUN(13));
InstallMethod(OrbitOp,"via prime order pcgs, with domain",true,[IsGroup,IsList,IsObject,IsPrimeOrdersPcgs,IsList,IsFunction],0,DoPcgsOrbitOp);
InstallOtherMethod(OrbitOp,"action via prime order pcgs",true,[IsGroup,IsObject,IsPrimeOrdersPcgs,IsList,IsFunction],0,COM_FUN(14));
InstallOtherMethod(RepresentativeActionOp,true,[IsGroup,IsList,IsObject,IsObject,IsPrimeOrdersPcgs,IsList,IsFunction],0,COM_FUN(15));
InstallMethod(StabilizerOp,"G, D, pnt, pcgs, acts, act, calling `Pcgs_MutableOrbitStabilizerOp'",true,[IsGroup,IsList,IsObject,IsPrimeOrdersPcgs,IsList,IsFunction],0,COM_FUN(16));
InstallOtherMethod(StabilizerOp,"G, pnt, pcgs, acts, act, calling `Pcgs_MutableOrbitStabilizerOp'",true,[IsGroup,IsObject,IsPrimeOrdersPcgs,IsList,IsFunction],0,COM_FUN(17));
InstallOtherMethod(StabilizerOp,"G (solv.), pnt, gens, gens, act",true,[IsGroup and CanEasilyComputePcgs,IsObject,IsList,IsList,IsFunction],0,COM_FUN(18));
InstallMethod(StabilizerOp,"G (solv.), D,pnt, gens, gens, act",true,[IsGroup and CanEasilyComputePcgs,IsListOrCollection,IsObject,IsList,IsList,IsFunction],0,COM_FUN(19));
InstallOtherMethod(StabilizerOp,"G (solv.), pnt, gens, gens, act",true,[IsGroup and CanEasilyComputePcgs,IsObject,IsPrimeOrdersPcgs,IsList,IsFunction],0,COM_FUN(20));
InstallOtherMethod(StabilizerOp,"G (solv.), D,pnt, gens, gens, act",true,[IsGroup and CanEasilyComputePcgs,IsObject,IsObject,IsPrimeOrdersPcgs,IsList,IsFunction],0,COM_FUN(21));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/oprtpcgs.gi"

#F  file="lib/partitio.gi" crc=-32415795
RANK_FILTER_LIST  := [  ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/partitio.gi", -32415795 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/partitio.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/partitio.gi");
elif COM_RESULT = 3  then
Revision.partitio_gi:="@(#)$Id: partitio.gi,v 4.19 2003/06/03 21:07:16 gap Exp $";
InstallGlobalFunction(Partition,COM_FUN(1));
InstallGlobalFunction(IsPartition,COM_FUN(2));
InstallGlobalFunction(NumberCells,COM_FUN(3));
InstallGlobalFunction(Cell,COM_FUN(4));
InstallGlobalFunction(Cells,COM_FUN(5));
InstallGlobalFunction(CellNoPoint,COM_FUN(6));
InstallGlobalFunction(CellNoPoints,COM_FUN(7));
InstallGlobalFunction(PointInCellNo,COM_FUN(8));
InstallGlobalFunction(Fixcells,COM_FUN(9));
BindGlobal("SplitCellTestfun1",COM_FUN(10));
BindGlobal("SplitCellTestfun2",COM_FUN(11));
InstallGlobalFunction(SplitCell,COM_FUN(12));
InstallGlobalFunction(IsolatePoint,COM_FUN(13));
InstallGlobalFunction(UndoRefinement,COM_FUN(14));
InstallGlobalFunction(FixpointCellNo,COM_FUN(15));
InstallGlobalFunction(FixcellPoint,COM_FUN(16));
InstallGlobalFunction(FixcellsCell,COM_FUN(17));
InstallGlobalFunction(TrivialPartition,COM_FUN(18));
InstallGlobalFunction(OrbitsPartition,COM_FUN(19));
InstallGlobalFunction(SmallestPrimeDivisor,COM_FUN(20));
InstallGlobalFunction(CollectedPartition,COM_FUN(21));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/partitio.gi"

#F  file="lib/stbc.gi" crc=4716383
RANK_FILTER_LIST  := [ 1, 0, 29419057, 21, 62973024, 33, 26132143, 27, 
  62973024, 33, 41951068, 17, 29417887, 62, 4097, 1, 62973024, 33, 4097, 1, 
  62973024, 33, 4097, 1, 26132143, 27, 8193, 2, 4097, 1, 29419057, 21, 513, 
  8, 62973024, 33, 4097, 1 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/stbc.gi", 4716383 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/stbc.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/stbc.gi");
elif COM_RESULT = 3  then
Revision.stbc_gi:="@(#)$Id: stbc.gi,v 4.72.2.4 2005/09/08 02:10:22 gap Exp $";
InstallGlobalFunction(StabChain,COM_FUN(1));
InstallMethod(StabChainImmutable,"use StabChainMutable",true,[IsObject],0,StabChainMutable);
InstallMethod(StabChainMutable,"call StabChainOp",true,[IsGroup],0,COM_FUN(2));
InstallOtherMethod(StabChainOp,"with base",true,[IsPermGroup,IsList and IsCyclotomicCollection],0,COM_FUN(3));
InstallOtherMethod(StabChainOp,"empty base",true,[IsPermGroup,IsList and IsEmpty],0,COM_FUN(4));
InstallMethod(StabChainOp,"trivial group",[IsPermGroup and IsTrivial,IsRecord],COM_FUN(5));
InstallMethod(StabChainOp,"group and option",[IsPermGroup,IsRecord],COM_FUN(6));
InstallGlobalFunction(CopyStabChain,COM_FUN(7));
InstallMethod(StabChainOptions,true,[IsPermGroup],0,COM_FUN(8));
InstallValue(DefaultStabChainOptions,rec(reduced:=true,random:=1000,tryPcgs:=true));
InstallGlobalFunction(CopyOptionsDefaults,COM_FUN(9));
InstallGlobalFunction(StabChainBaseStrongGenerators,COM_FUN(10));
InstallGlobalFunction(GroupStabChain,COM_FUN(11));
InstallGlobalFunction(DepthSchreierTrees,COM_FUN(12));
InstallGlobalFunction(AddGeneratorsExtendSchreierTree,COM_FUN(13));
InstallGlobalFunction(ChooseNextBasePoint,COM_FUN(14));
InstallGlobalFunction(StabChainStrong,COM_FUN(15));
InstallGlobalFunction(StabChainForcePoint,COM_FUN(16));
InstallGlobalFunction(StabChainSwap,COM_FUN(17));
InstallGlobalFunction(InsertElmList,COM_FUN(18));
InstallGlobalFunction(RemoveElmList,COM_FUN(19));
InstallGlobalFunction(LabsLims,COM_FUN(20));
InstallGlobalFunction(ConjugateStabChain,COM_FUN(21));
InstallGlobalFunction(ChangeStabChain,COM_FUN(22));
InstallGlobalFunction(ExtendStabChain,COM_FUN(23));
InstallGlobalFunction(ReduceStabChain,COM_FUN(24));
InstallGlobalFunction(EmptyStabChain,COM_FUN(25));
InstallGlobalFunction(InitializeSchreierTree,COM_FUN(26));
InstallGlobalFunction(InsertTrivialStabilizer,COM_FUN(27));
InstallGlobalFunction(RemoveStabChain,COM_FUN(28));
InstallGlobalFunction(BasePoint,COM_FUN(29));
InstallGlobalFunction(IsInBasicOrbit,COM_FUN(30));
InstallGlobalFunction(IsFixedStabilizer,COM_FUN(31));
InstallGlobalFunction(InverseRepresentative,COM_FUN(32));
InstallGlobalFunction(QuickInverseRepresentative,COM_FUN(33));
InstallGlobalFunction(InverseRepresentativeWord,COM_FUN(34));
InstallGlobalFunction(SiftedPermutation,COM_FUN(35));
InstallGlobalFunction(MinimalElementCosetStabChain,COM_FUN(36));
InstallMethod(MembershipTestKnownBase,"stabchain, base, word",true,[IsRecord,IsList and IsCyclotomicCollection,IsList],0,COM_FUN(37));
InstallOtherMethod(MembershipTestKnownBase,true,[IsRecord,IsGroup,IsPerm],0,COM_FUN(38));
InstallGlobalFunction(BaseStabChain,COM_FUN(39));
InstallGlobalFunction(SizeStabChain,COM_FUN(40));
InstallGlobalFunction(StrongGeneratorsStabChain,COM_FUN(41));
InstallGlobalFunction(IndicesStabChain,COM_FUN(42));
InstallGlobalFunction(ListStabChain,COM_FUN(43));
InstallGlobalFunction(OrbitStabChain,COM_FUN(44));
InstallMethod(MinimalStabChain,"Perm",true,[IsPermGroup],0,COM_FUN(45));
InstallGlobalFunction(SCMinSmaGens,COM_FUN(46));
InstallGlobalFunction(LargestElementStabChain,COM_FUN(47));
InstallGlobalFunction(ElementsStabChain,COM_FUN(48));
InstallMethod(ViewObj,"stabilizer chain records",true,[IsRecord],0,COM_FUN(49));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/stbc.gi"

#F  file="lib/stbcbckt.gi" crc=-83598900
RANK_FILTER_LIST  := [ 513, 8, 13315985, 9, 17, 18, 13315985, 9, 1, 0, 
  13315985, 9, 13315985, 9, 1, 0, 26631969, 9, 26631969, 9, 62973024, 33, 
  62973024, 33, 62973024, 33, 62973024, 33, 62973024, 33, 62973024, 33, 513, 
  8, 62973024, 33, 62973024, 33, 62973024, 33, 513, 8, 62973024, 33, 
  62973024, 33, 62973024, 33, 62973024, 33 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/stbcbckt.gi", -83598900 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/stbcbckt.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/stbcbckt.gi");
elif COM_RESULT = 3  then
Revision.stbcbckt_gi:="@(#)$Id: stbcbckt.gi,v 4.83.2.4 2006/02/20 15:54:06 gap Exp $";
if not IsBound(LARGE_TASK) then
LARGE_TASK:=false;
fi;
DeclareRepresentation("IsSlicedPerm",IsPerm,["length","word","lftObj","opr"]);
InstallGlobalFunction(AsPerm,COM_FUN(1));
InstallMethod(\^,"sliced perm",true,[IsPerm,IsSlicedPerm],0,COM_FUN(2));
InstallMethod(\^,"sliced perm",true,[IsInt,IsSlicedPerm],0,COM_FUN(3));
InstallOtherMethod(\/,"sliced perm",true,[IsObject,IsSlicedPerm],0,COM_FUN(4));
InstallMethod(PrintObj,"sliced perm",true,[IsSlicedPerm],0,COM_FUN(5));
DeclareRepresentation("IsSlicedPermInv",IsPerm,["length","word","lftObj","opr"]);
InstallOtherMethod(\^,"sliced perm",true,[IsObject,IsSlicedPermInv],0,COM_FUN(6));
InstallMethod(PrintObj,"sliced perm",true,[IsSlicedPermInv],0,COM_FUN(7));
InstallGlobalFunction(PreImageWord,COM_FUN(8));
InstallGlobalFunction(ExtendedT,COM_FUN(9));
InstallGlobalFunction(MeetPartitionStrat,COM_FUN(10));
InstallGlobalFunction(StratMeetPartition,COM_FUN(11));
InstallGlobalFunction(SuboLiBli,COM_FUN(12));
InstallGlobalFunction(SuboSiBli,COM_FUN(13));
InstallGlobalFunction(SuboTruePos,COM_FUN(14));
InstallGlobalFunction(SuboUniteBlist,COM_FUN(15));
InstallGlobalFunction(ConcatSubos,COM_FUN(16));
InstallGlobalFunction(Suborbits,COM_FUN(17));
InstallGlobalFunction(OrbitalPartition,COM_FUN(18));
InstallGlobalFunction(EmptyRBase,COM_FUN(19));
InstallGlobalFunction(IsTrivialRBase,COM_FUN(20));
InstallGlobalFunction(AddRefinement,COM_FUN(21));
InstallGlobalFunction(ProcessFixpoint,COM_FUN(22));
InstallGlobalFunction(RegisterRBasePoint,COM_FUN(23));
InstallGlobalFunction(NextRBasePoint,COM_FUN(24));
InstallGlobalFunction(RRefine,COM_FUN(25));
InstallGlobalFunction(PBIsMinimal,COM_FUN(26));
InstallGlobalFunction(SubtractBlistOrbitStabChain,COM_FUN(27));
InstallGlobalFunction(PartitionBacktrack,COM_FUN(28));
InstallValue(Refinements,rec());
InstallGlobalFunction(Refinements_ProcessFixpoint,COM_FUN(29));
Refinements.ProcessFixpoint:=Refinements_ProcessFixpoint;
InstallGlobalFunction(Refinements_Intersection,COM_FUN(30));
Refinements.Intersection:=Refinements_Intersection;
InstallGlobalFunction(Refinements_Centralizer,COM_FUN(31));
Refinements.Centralizer:=Refinements_Centralizer;
InstallGlobalFunction(Refinements__MakeBlox,COM_FUN(32));
Refinements._MakeBlox:=Refinements__MakeBlox;
InstallGlobalFunction(Refinements_SplitOffBlock,COM_FUN(33));
Refinements.SplitOffBlock:=Refinements_SplitOffBlock;
InstallGlobalFunction(Refinements__RegularOrbit1,COM_FUN(34));
Refinements._RegularOrbit1:=Refinements__RegularOrbit1;
InstallGlobalFunction(Refinements_RegularOrbit2,COM_FUN(35));
Refinements.RegularOrbit2:=Refinements_RegularOrbit2;
InstallGlobalFunction(Refinements_RegularOrbit3,COM_FUN(36));
Refinements.RegularOrbit3:=Refinements_RegularOrbit3;
InstallGlobalFunction(Refinements_Suborbits0,COM_FUN(37));
Refinements.Suborbits0:=Refinements_Suborbits0;
InstallGlobalFunction(Refinements_Suborbits1,COM_FUN(38));
Refinements.Suborbits1:=Refinements_Suborbits1;
InstallGlobalFunction(Refinements_Suborbits2,COM_FUN(39));
Refinements.Suborbits2:=Refinements_Suborbits2;
InstallGlobalFunction(Refinements_Suborbits3,COM_FUN(40));
Refinements.Suborbits3:=Refinements_Suborbits3;
InstallGlobalFunction(Refinements_TwoClosure,COM_FUN(41));
Refinements.TwoClosure:=Refinements_TwoClosure;
InstallGlobalFunction(NextLevelRegularGroups,COM_FUN(42));
InstallGlobalFunction(RBaseGroupsBloxPermGroup,COM_FUN(43));
InstallGlobalFunction(RepOpSetsPermGroup,COM_FUN(44));
InstallGlobalFunction(RepOpElmTuplesPermGroup,COM_FUN(45));
InstallGlobalFunction(IsomorphismPermGroups,COM_FUN(46));
InstallGlobalFunction(AutomorphismGroupPermGroup,COM_FUN(47));
InstallMethod(NormalizerOp,"perm group",IsIdenticalObj,[IsPermGroup,IsPermGroup],0,AutomorphismGroupPermGroup);
InstallOtherMethod(Normalizer,"perm group",true,[IsPermGroup,IsPermGroup,IsPermGroup],0,AutomorphismGroupPermGroup);
InstallGlobalFunction(ElementProperty,COM_FUN(48));
InstallGlobalFunction(SubgroupProperty,COM_FUN(49));
InstallGlobalFunction(PartitionStabilizerPermGroup,COM_FUN(50));
InstallMethod(CentralizerOp,"perm group,elm",IsCollsElms,[IsPermGroup,IsPerm],0,COM_FUN(51));
InstallMethod(CentralizerOp,"perm group, perm group",IsIdenticalObj,[IsPermGroup,IsPermGroup],0,COM_FUN(52));
InstallOtherMethod(Centralizer,"with given subgroup",true,[IsPermGroup,IsPerm,IsPermGroup],0,COM_FUN(53));
InstallMethod(Intersection2,"perm groups",IsIdenticalObj,[IsPermGroup,IsPermGroup],0,COM_FUN(54));
TwoClosurePermGroup:=COM_FUN(55);
InstallMethod(TwoClosure,"permutation group",true,[IsPermGroup],0,TwoClosurePermGroup);
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/stbcbckt.gi"

#F  file="lib/stbcrand.gi" crc=94610783
RANK_FILTER_LIST  := [  ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/stbcrand.gi", 94610783 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/stbcrand.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/stbcrand.gi");
elif COM_RESULT = 3  then
Revision.stbcrand_gi:="@(#)$Id: stbcrand.gi,v 4.28.2.5 2005/12/03 04:08:11 gap Exp $";
InstallGlobalFunction(StabChainRandomPermGroup,COM_FUN(1));
InstallGlobalFunction(SCRMakeStabStrong,COM_FUN(2));
InstallGlobalFunction(SCRStrongGenTest,COM_FUN(3));
InstallGlobalFunction(SCRSift,COM_FUN(4));
InstallGlobalFunction(SCRStrongGenTest2,COM_FUN(5));
InstallGlobalFunction(SCRNotice,COM_FUN(6));
InstallGlobalFunction(SCRExtend,COM_FUN(7));
InstallGlobalFunction(SCRSchTree,COM_FUN(8));
InstallGlobalFunction(SCRRandomPerm,COM_FUN(9));
InstallGlobalFunction(SCRRandomString,COM_FUN(10));
InstallGlobalFunction(SCRRandomSubproduct,COM_FUN(11));
InstallGlobalFunction(SCRExtendRecord,COM_FUN(12));
InstallGlobalFunction(SCRRestoredRecord,COM_FUN(13));
InstallGlobalFunction(VerifyStabilizer,COM_FUN(14));
InstallGlobalFunction(VerifySGS,COM_FUN(15));
InstallGlobalFunction(ExtensionOnBlocks,COM_FUN(16));
InstallGlobalFunction(ClosureRandomPermGroup,COM_FUN(17));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/stbcrand.gi"

#F  file="lib/clas.gi" crc=-76356875
RANK_FILTER_LIST  := [ 44158107, 11, 44158107, 11, 44158107, 11, 44158107, 
  11, 29419057, 21, 1, 0, 29419057, 21, 1, 0, 29419057, 21, 21208294, 12, 
  21208294, 12, 21208294, 12, 21208294, 12, 21208294, 12, 21208294, 12, 
  21208294, 12, 29419057, 21, 29419057, 21, 29419057, 21, 29419057, 21, 1, 0, 
  17727174, 11, 17727174, 11, 1, 0, 17727174, 11, 21208294, 12, 17727174, 11, 
  17727174, 11, 17727174, 11, 17727174, 11, 17727174, 11, 17727174, 11, 
  29419057, 21, 30937393, 25 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/clas.gi", -76356875 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/clas.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/clas.gi");
elif COM_RESULT = 3  then
Revision.clas_gi:="@(#)$Id: clas.gi,v 4.71 2003/05/19 16:02:37 gap Exp $";
BindGlobal("ElementNumber_ExternalOrbitByStabilizer",COM_FUN(1));
BindGlobal("NumberElement_ExternalOrbitByStabilizer",COM_FUN(2));
InstallMethod(Enumerator,"xorb by stabilizer",[IsExternalOrbitByStabilizerRep],COM_FUN(3));
InstallMethod(AsList,"xorb by stabilizer",[IsExternalOrbitByStabilizerRep],COM_FUN(4));
InstallMethod(IsFinite,"method for an ext. orbit by stabilizer",[IsExternalOrbitByStabilizerRep],COM_FUN(5));
InstallMethod(Size,"method for an ext. orbit by stabilizer",[IsExternalOrbitByStabilizerRep],COM_FUN(6));
InstallMethod(ConjugacyClass,"class of element",IsCollsElms,[IsGroup,IsObject],COM_FUN(7));
InstallOtherMethod(ConjugacyClass,"class of element and centralizer",IsCollsElmsColls,[IsGroup,IsObject,IsGroup],COM_FUN(8));
InstallMethod(HomeEnumerator,[IsConjugacyClassGroupRep],COM_FUN(9));
InstallMethod(PrintObj,[IsConjugacyClassGroupRep],COM_FUN(10));
InstallMethod(ViewObj,[IsConjugacyClassGroupRep],COM_FUN(11));
InstallMethod(Size,"for a conjugacy class",[IsConjugacyClassGroupRep],COM_FUN(12));
InstallMethod(IsFinite,"for a conjugacy class",[IsConjugacyClassGroupRep],COM_FUN(13));
InstallOtherMethod(Centralizer,[IsConjugacyClassGroupRep],StabilizerOfExternalSet);
InstallMethod(StabilizerOfExternalSet,[IsConjugacyClassGroupRep],10,COM_FUN(14));
InstallGlobalFunction(ConjugacyClassesTry,COM_FUN(15));
InstallGlobalFunction(ConjugacyClassesByRandomSearch,COM_FUN(16));
InstallGlobalFunction(ConjugacyClassesByOrbits,COM_FUN(17));
InstallMethod(ConjugacyClasses,"test options",[IsGroup],GETTER_FLAGS-1,COM_FUN(18));
DEFAULT_CLASS_ORBIT_LIMIT:=500;
InstallGlobalFunction(ConjugacyClassesForSmallGroup,COM_FUN(19));
InstallMethod(ConjugacyClasses,"for groups: try random search",[IsGroup],COM_FUN(20));
InstallMethod(ConjugacyClasses,"try solvable method",[IsGroup],COM_FUN(21));
InstallMethod(RationalClass,IsCollsElms,[IsGroup,IsObject],COM_FUN(22));
InstallMethod(\=,IsIdenticalObj,[IsRationalClassGroupRep,IsRationalClassGroupRep],COM_FUN(23));
InstallMethod(\in,IsElmsColls,[IsObject,IsRationalClassGroupRep],COM_FUN(24));
InstallMethod(HomeEnumerator,[IsConjugacyClassGroupRep],COM_FUN(25));
InstallMethod(PrintObj,[IsRationalClassGroupRep],COM_FUN(26));
InstallMethod(Size,"method for a rational class",[IsRationalClassGroupRep],COM_FUN(27));
InstallGlobalFunction(DecomposedRationalClass,COM_FUN(28));
BindGlobal("ElementNumber_RationalClassGroup",COM_FUN(29));
BindGlobal("NumberElement_RationalClassGroup",COM_FUN(30));
InstallMethod(Enumerator,[IsRationalClassGroupRep],COM_FUN(31));
InstallOtherMethod(CentralizerOp,[IsRationalClassGroupRep],StabilizerOfExternalSet);
InstallMethod(AsList,[IsRationalClassGroupRep],COM_FUN(32));
InstallOtherMethod(GaloisGroup,[IsRationalClassGroupRep],COM_FUN(33));
InstallGlobalFunction(GroupByPrimeResidues,COM_FUN(34));
InstallMethod(RationalClasses,"trial",[IsGroup],COM_FUN(35));
InstallGlobalFunction(RationalClassesTry,COM_FUN(36));
InstallMethod(RationalClasses,"solvable",[CanEasilyComputePcgs],20,COM_FUN(37));
InstallGlobalFunction(RationalClassesInEANS,COM_FUN(38));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/clas.gi"

#F  file="lib/claspcgs.gi" crc=74640452
RANK_FILTER_LIST  := [ 21208294, 12 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/claspcgs.gi", 74640452 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/claspcgs.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/claspcgs.gi");
elif COM_RESULT = 3  then
Revision.claspcgs_gi:="@(#)$Id: claspcgs.gi,v 4.70.2.1 2005/08/24 14:16:10 sal Exp $";
InstallGlobalFunction(SubspaceVectorSpaceGroup,COM_FUN(1));
InstallGlobalFunction(KernelHcommaC,COM_FUN(2));
InstallGlobalFunction(CentralStepClEANS,COM_FUN(3));
InstallGlobalFunction(CorrectConjugacyClass,COM_FUN(4));
InstallGlobalFunction(GeneralStepClEANS,COM_FUN(5));
InstallGlobalFunction(ClassesSolvableGroup,COM_FUN(6));
InstallGlobalFunction(CentralizerSizeLimitConsiderFunction,COM_FUN(7));
InstallMethod(ActorOfExternalSet,true,[IsConjugacyClassGroupRep],0,COM_FUN(8));
InstallGlobalFunction(RationalClassesSolvableGroup,COM_FUN(9));
InstallGlobalFunction(OrderModK,COM_FUN(10));
BindGlobal("OldSubspaceVectorSpaceGroup",COM_FUN(11));
BindGlobal("OldKernelHcommaC",COM_FUN(12));
InstallGlobalFunction(CentralStepConjugatingElement,COM_FUN(13));
InstallGlobalFunction(CentralStepRatClPGroup,COM_FUN(14));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/claspcgs.gi"

#F  file="lib/clasperm.gi" crc=27070
RANK_FILTER_LIST  := [ 42417547, 13, 42417547, 13, 42417547, 13, 513, 8, 
  42417547, 13, 35454347, 12, 17727174, 11, 35454347, 12, 35454347, 12, 513, 
  8, 35454347, 12, 62973024, 33, 49491928, 34 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/clasperm.gi", 27070 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/clasperm.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/clasperm.gi");
elif COM_RESULT = 3  then
Revision.clasperm_gi:="@(#)$Id: clasperm.gi,v 4.36 2003/05/23 16:17:59 gap Exp $";
BindGlobal("NumberElement_ConjugacyClassPermGroup",COM_FUN(1));
InstallMethod(Enumerator,[IsConjugacyClassPermGroupRep],COM_FUN(2));
InstallMethod(\=,"classes for perm group",IsIdenticalObj,[IsConjugacyClassPermGroupRep,IsConjugacyClassPermGroupRep],COM_FUN(3));
InstallMethod(\in,"perm class rep",IsElmsColls,[IsPerm,IsConjugacyClassPermGroupRep],COM_FUN(4));
BindGlobal("NumberElement_RationalClassPermGroup",COM_FUN(5));
InstallMethod(Enumerator,[IsRationalClassPermGroupRep],COM_FUN(6));
InstallOtherMethod(CentralizerOp,[IsRationalClassGroupRep],StabilizerOfExternalSet);
InstallMethod(\=,IsIdenticalObj,[IsRationalClassPermGroupRep,IsRationalClassPermGroupRep],COM_FUN(7));
InstallMethod(\in,true,[IsPerm,IsRationalClassPermGroupRep],0,COM_FUN(8));
InstallGlobalFunction(CompleteGaloisGroupPElement,COM_FUN(9));
InstallGlobalFunction(RatClasPElmArrangeClasses,COM_FUN(10));
InstallGlobalFunction(SortRationalClasses,COM_FUN(11));
InstallGlobalFunction(FusionRationalClassesPSubgroup,COM_FUN(12));
InstallGlobalFunction(RationalClassesPElements,COM_FUN(13));
InstallGlobalFunction(RationalClassesPermGroup,COM_FUN(14));
InstallMethod(RationalClasses,"perm group",[IsPermGroup],COM_FUN(15));
InstallMethod(ConjugacyClasses,"perm group",[IsPermGroup and HasRationalClasses],COM_FUN(16));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/clasperm.gi"

#F  file="lib/clashom.gi" crc=25678771
RANK_FILTER_LIST  := [ 62973024, 33 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/clashom.gi", 25678771 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/clashom.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/clashom.gi");
elif COM_RESULT = 3  then
Revision.clashom_gi:="@(#)$Id: clashom.gi,v 4.51.2.3 2006/01/10 23:16:13 gap Exp $";
BindGlobal("GeneralStepClEANSNonsolv",COM_FUN(1));
BindGlobal("CentralStelClEANSNonsolv",COM_FUN(2));
AutomorphismRepresentingGroup:=COM_FUN(3);
BindGlobal("ClassRepsPermutedTuples",COM_FUN(4));
InstallGlobalFunction(ConjugacyClassesSubwreath,COM_FUN(5));
InstallGlobalFunction(ConjugacyClassesFittingFreeGroup,COM_FUN(6));
InstallGlobalFunction(ConjugacyClassesViaRadical,COM_FUN(7));
InstallMethod(ConjugacyClasses,"perm group",true,[IsPermGroup],0,COM_FUN(8));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/clashom.gi"

#F  file="lib/csetgrp.gi" crc=-87192773
RANK_FILTER_LIST  := [ 54525458, 11, 29419057, 21, 29419057, 21, 29419057, 
  21, 29419057, 21, 1, 0, 29419057, 21, 29419057, 21, 1, 0, 29419057, 21, 
  7665940, 19, 7601547, 8, 7601547, 8, 7601547, 8, 7601547, 8, 7601547, 8, 
  7601547, 8, 65767820, 5, 7601547, 8, 7601547, 8, 7601547, 8, 7601547, 8, 
  29419057, 21, 1, 0, 29420979, 23, 1, 0, 54525458, 11, 54525458, 11, 
  54525458, 11, 54525458, 11, 54525458, 11, 54525458, 11, 54525458, 11, 
  65767820, 5, 29419057, 21, 1, 0, 29419057, 21, 29419057, 21, 29419057, 21, 
  29419057, 21, 29419057, 21, 29419057, 21, 29419057, 21, 29419057, 21, 
  11737300, 10, 7665940, 19, 11737300, 10, 65767820, 5, 29419057, 21, 
  29419057, 21, 62973024, 33, 62973024, 33, 66740907, 33, 66740907, 33, 
  29419057, 21, 62972799, 49 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/csetgrp.gi", -87192773 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/csetgrp.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/csetgrp.gi");
elif COM_RESULT = 3  then
Revision.csetgrp_gi:="@(#)$Id: csetgrp.gi,v 4.54.2.1 2006/05/18 19:37:44 gap Exp $";
DeclareRepresentation("IsRightCosetDefaultRep",IsComponentObjectRep and IsAttributeStoringRep and IsRightCoset,[]);
BindGlobal("NumberElement_RightCoset",COM_FUN(1));
BindGlobal("ElementNumber_RightCoset",COM_FUN(2));
InstallMethod(Enumerator,"for a right coset",[IsRightCoset],COM_FUN(3));
DeclareRepresentation("IsDoubleCosetDefaultRep",IsComponentObjectRep and IsAttributeStoringRep and IsDoubleCoset,[]);
InstallMethod(ComputedAscendingChains,"init",true,[IsGroup],0,COM_FUN(4));
InstallGlobalFunction(AscendingChain,COM_FUN(5));
InstallGlobalFunction(IntermediateGroup,COM_FUN(6));
InstallGlobalFunction(RefinedChain,COM_FUN(7));
InstallMethod(AscendingChainOp,"generic",IsIdenticalObj,[IsGroup,IsGroup],0,COM_FUN(8));
InstallMethod(DoubleCoset,"generic",IsCollsElmsColls,[IsGroup,IsObject,IsGroup],0,COM_FUN(9));
InstallOtherMethod(DoubleCoset,"with size",true,[IsGroup,IsObject,IsGroup,IsPosInt],0,COM_FUN(10));
InstallMethod(\=,"DoubleCosets",IsIdenticalObj,[IsDoubleCoset,IsDoubleCoset],0,COM_FUN(11));
InstallMethod(PrintObj,"DoubleCoset",true,[IsDoubleCoset],0,COM_FUN(12));
InstallMethod(Random,"double coset",true,[IsDoubleCoset],0,COM_FUN(13));
InstallMethod(PseudoRandom,"double coset",true,[IsDoubleCoset],0,COM_FUN(14));
InstallMethod(RepresentativesContainedRightCosets,"generic",true,[IsDoubleCoset],0,COM_FUN(15));
InstallMethod(\in,"double coset",IsElmsColls,[IsMultiplicativeElementWithInverse,IsDoubleCoset],0,COM_FUN(16));
InstallMethod(Size,"double coset",true,[IsDoubleCoset],0,COM_FUN(17));
InstallMethod(AsList,"double coset",true,[IsDoubleCoset],0,COM_FUN(18));
BindGlobal("ElementNumber_DoubleCoset",COM_FUN(19));
BindGlobal("NumberElement_DoubleCoset",COM_FUN(20));
InstallMethod(Enumerator,"for a double coset",[IsDoubleCoset],COM_FUN(21));
RightCosetCanonicalRepresentativeDeterminator:=COM_FUN(22);
InstallMethod(RightCoset,"generic",IsCollsElms,[IsGroup,IsObject],0,COM_FUN(23));
InstallMethod(RightCoset,"use subgroup size",IsCollsElms,[IsGroup and HasSize,IsObject],0,COM_FUN(24));
InstallMethod(PrintObj,"RightCoset",true,[IsRightCoset],0,COM_FUN(25));
InstallMethod(ViewObj,"RightCoset",true,[IsRightCoset],0,COM_FUN(26));
InstallMethod(Random,"RightCoset",true,[IsRightCoset],0,COM_FUN(27));
InstallMethod(PseudoRandom,"RightCoset",true,[IsRightCoset],0,COM_FUN(28));
InstallMethod(\=,"RightCosets",IsIdenticalObj,[IsRightCoset,IsRightCoset],0,COM_FUN(29));
InstallOtherMethod(\*,"RightCosets",IsCollsElms,[IsRightCoset,IsMultiplicativeElementWithInverse],0,COM_FUN(30));
InstallGlobalFunction(DoubleCosets,COM_FUN(31));
InstallGlobalFunction(RightCosets,COM_FUN(32));
InstallMethod(CanonicalRightCosetElement,"generic",IsCollsElms,[IsGroup,IsObject],0,COM_FUN(33));
BindGlobal("CalcDoubleCosets",COM_FUN(34));
InstallMethod(DoubleCosetsNC,"generic",true,[IsGroup,IsGroup,IsGroup],0,COM_FUN(35));
InstallMethod(DoubleCosetRepsAndSizes,"generic",true,[IsGroup,IsGroup,IsGroup],0,CalcDoubleCosets);
DeclareRepresentation("IsRightTransversalViaCosetsRep",IsRightTransversalRep,["group","subgroup","cosets"]);
InstallMethod(RightTransversalOp,"generic, use RightCosets",IsIdenticalObj,[IsGroup,IsGroup],0,COM_FUN(36));
InstallMethod(\[\],"rt via coset",true,[IsList and IsRightTransversalViaCosetsRep,IsPosInt],0,COM_FUN(37));
InstallMethod(PositionCanonical,"rt via coset",IsCollsElms,[IsList and IsRightTransversalViaCosetsRep,IsMultiplicativeElementWithInverse],0,COM_FUN(38));
InstallMethod(RightCosetsNC,"generic: orbit",IsIdenticalObj,[IsGroup,IsGroup],0,COM_FUN(39));
InstallMethod(RightCosetsNC,"perm groups, use RightTransversal",IsIdenticalObj,[IsPermGroup,IsPermGroup],0,COM_FUN(40));
InstallMethod(RightCosetsNC,"pc groups, use RightTransversal",IsIdenticalObj,[IsPcGroup,IsPcGroup],0,COM_FUN(41));
InstallMethod(RightTransversalOp,"for trivial subgroup, call `EnumeratorSorted' for the big group",IsIdenticalObj,[IsGroup,IsGroup and IsTrivial],100,COM_FUN(42));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/csetgrp.gi"

#F  file="lib/csetperm.gi" crc=50382523
RANK_FILTER_LIST  := [ 62973024, 33, 62973024, 33, 62973024, 33, 513, 8, 
  20970546, 39, 20970546, 39 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/csetperm.gi", 50382523 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/csetperm.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/csetperm.gi");
elif COM_RESULT = 3  then
Revision.csetperm_gi:="@(#)$Id: csetperm.gi,v 4.12 2002/09/20 22:27:45 gap Exp $";
InstallMethod(AscendingChainOp,"PermGroup",IsIdenticalObj,[IsPermGroup,IsPermGroup],0,COM_FUN(1));
InstallMethod(CanonicalRightCosetElement,"Perm",IsCollsElms,[IsPermGroup,IsPerm],0,COM_FUN(2));
InstallMethod(\<,"RightCosets of perm group",IsIdenticalObj,[IsRightCoset and IsPermCollection,IsRightCoset and IsPermCollection],0,COM_FUN(3));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/csetperm.gi"

#F  file="lib/csetpc.gi" crc=-88305231
RANK_FILTER_LIST  := [ 66740907, 33, 1, 0, 66740907, 33, 66740907, 33, 
  66740907, 33, 66740907, 33, 29419057, 21, 227065, 26, 29419057, 21, 
  23466407, 10, 7665940, 19, 23466407, 10, 23466407, 10, 65767820, 5 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/csetpc.gi", -88305231 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/csetpc.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/csetpc.gi");
elif COM_RESULT = 3  then
Revision.csetpc_gi:="@(#)$Id: csetpc.gi,v 4.38 2003/01/30 18:38:05 gap Exp $";
InstallMethod(CanonicalRightCosetElement,"Pc",IsCollsElms,[IsPcGroup,IsObject],0,COM_FUN(1));
BindGlobal("DoubleCosetsPcGroup",COM_FUN(2));
InstallMethod(DoubleCosetRepsAndSizes,"Pc",true,[IsPcGroup,IsPcGroup,IsPcGroup],0,COM_FUN(3));
DeclareRepresentation("IsRightTransversalPcGroupRep",IsRightTransversalRep,["transversal","canonReps"]);
DoRightTransversalPc:=COM_FUN(4);
InstallMethod(RightTransversalOp,"pc groups",IsIdenticalObj,[IsPcGroup,IsGroup],0,DoRightTransversalPc);
InstallMethod(RightTransversalOp,"pc groups",IsIdenticalObj,[CanEasilyComputePcgs and HasPcgs,IsGroup],0,DoRightTransversalPc);
InstallMethod(\[\],"for Pc transversals",true,[IsList and IsRightTransversalPcGroupRep,IsPosInt],0,COM_FUN(5));
InstallMethod(AsList,"for Pc transversals",true,[IsList and IsRightTransversalPcGroupRep],0,COM_FUN(6));
InstallMethod(PositionCanonical,"RT",IsCollsElms,[IsList and IsRightTransversalPcGroupRep,IsMultiplicativeElementWithInverse],0,COM_FUN(7));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/csetpc.gi"

#F  file="lib/factgrp.gi" crc=10548730
RANK_FILTER_LIST  := [ 29419057, 21, 29419057, 21, 29419057, 21, 29419057, 
  21, 29419057, 21, 29419057, 21, 29418502, 222, 29419057, 21, 29418502, 222, 
  29419057, 21, 29419057, 21, 29419057, 21, 62973024, 33, 29407897, 26, 
  29419057, 21, 29419057, 21, 29419057, 21, 62973024, 33, 62973024, 33, 
  29418502, 222, 29419057, 21, 29419057, 21, 29419057, 21, 62973024, 33, 
  62973024, 33 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/factgrp.gi", 10548730 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/factgrp.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/factgrp.gi");
elif COM_RESULT = 3  then
Revision.factgrp_gi:="@(#)$Id: factgrp.gi,v 4.52 2003/09/17 21:37:28 gap Exp $";
InstallMethod(NaturalHomomorphismsPool,true,[IsGroup],0,COM_FUN(1));
InstallGlobalFunction(AddNaturalHomomorphismsPool,COM_FUN(2));
InstallGlobalFunction(LockNaturalHomomorphismsPool,COM_FUN(3));
InstallGlobalFunction(UnlockNaturalHomomorphismsPool,COM_FUN(4));
InstallGlobalFunction(KnownNaturalHomomorphismsPool,COM_FUN(5));
InstallGlobalFunction(GetNaturalHomomorphismsPool,COM_FUN(6));
InstallGlobalFunction(DegreeNaturalHomomorphismsPool,COM_FUN(7));
InstallGlobalFunction(CloseNaturalHomomorphismsPool,COM_FUN(8));
DoFactorCosetAction:=COM_FUN(9);
InstallMethod(FactorCosetAction,"by right transversal operation",IsIdenticalObj,[IsGroup,IsGroup],0,COM_FUN(10));
InstallOtherMethod(FactorCosetAction,"by right transversal operation, given kernel",IsFamFamFam,[IsGroup,IsGroup,IsGroup],0,COM_FUN(11));
InstallMethod(FactorCosetAction,"by right transversal operation, Niceo",IsIdenticalObj,[IsGroup and IsHandledByNiceMonomorphism,IsGroup],0,COM_FUN(12));
InstallOtherMethod(FactorCosetAction,"by right transversal operation, given kernel, Niceo",IsFamFamFam,[IsGroup and IsHandledByNiceMonomorphism,IsGroup,IsGroup],0,COM_FUN(13));
InstallMethod(DoCheapActionImages,true,[IsGroup],0,Ignore);
InstallMethod(DoCheapActionImages,true,[IsPermGroup],0,COM_FUN(14));
InstallGlobalFunction(ImproveActionDegreeByBlocks,COM_FUN(15));
InstallGlobalFunction(SmallerDegreePermutationRepresentation,COM_FUN(16));
BADINDEX:=1000;
GenericFindActionKernel:=COM_FUN(17);
InstallMethod(FindActionKernel,"generic for finite groups",IsIdenticalObj,[IsGroup and IsFinite,IsGroup],0,COM_FUN(18));
InstallMethod(FindActionKernel,"general case: can't do",IsIdenticalObj,[IsGroup,IsGroup],0,COM_FUN(19));
InstallMethod(FindActionKernel,"perm",IsIdenticalObj,[IsPermGroup,IsPermGroup],0,COM_FUN(20));
InstallMethod(FindActionKernel,"Niceo",IsIdenticalObj,[IsGroup and IsHandledByNiceMonomorphism,IsGroup],0,COM_FUN(21));
InstallMethod(NaturalHomomorphismByNormalSubgroupOp,"search for operation",IsIdenticalObj,[IsGroup,IsGroup],0,COM_FUN(22));
NH_TRYPCGS_LIMIT:=30000;
InstallMethod(NaturalHomomorphismByNormalSubgroupOp,"test if known/try solvable factor for permutation groups",IsIdenticalObj,[IsPermGroup,IsPermGroup],0,COM_FUN(23));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/factgrp.gi"

#F  file="lib/grpreps.gi" crc=122460261
RANK_FILTER_LIST  := [ 29419057, 21, 24813784, 48, 29419057, 21, 24802624, 
  53, 17, 18 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grpreps.gi", 122460261 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grpreps.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grpreps.gi");
elif COM_RESULT = 3  then
Revision.grpreps_gi:="@(#)$Id: grpreps.gi,v 4.9 2002/04/15 10:04:53 sal Exp $";
InstallGlobalFunction(RegularModuleByGens,COM_FUN(1));
InstallMethod(RegularModule,"generic method for groups",true,[IsGroup,IsField],0,COM_FUN(2));
InstallMethod(IrreducibleModules,"generic method for groups and finite field",true,[IsGroup,IsField and IsFinite,IsInt],0,COM_FUN(3));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grpreps.gi"

#F  file="lib/grppcrep.gi" crc=-72981716
RANK_FILTER_LIST  := [ 60356449, 25, 24802624, 53, 17, 18, 60356449, 25, 
  24802624, 53, 17, 18 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grppcrep.gi", -72981716 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grppcrep.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grppcrep.gi");
elif COM_RESULT = 3  then
Revision.grppcrep_gi:="@(#)$Id: grppcrep.gi,v 4.20.4.1 2007/03/21 11:50:44 gap Exp $";
MappedVector:=COM_FUN(1);
BlownUpMatrix:=COM_FUN(2);
InstallGlobalFunction(BlownUpModule,COM_FUN(3));
InstallGlobalFunction(ConjugatedModule,COM_FUN(4));
InstallGlobalFunction(FpOfModules,COM_FUN(5));
InstallGlobalFunction(EquivalenceType,COM_FUN(6));
InstallGlobalFunction(IsEquivalentByFp,COM_FUN(7));
InstallGlobalFunction(GaloisConjugates,COM_FUN(8));
InstallGlobalFunction(TrivialModule,COM_FUN(9));
InstallGlobalFunction(InducedModule,COM_FUN(10));
InstallGlobalFunction(InducedModuleByFieldReduction,COM_FUN(11));
InstallGlobalFunction(ExtensionsOfModule,COM_FUN(12));
InstallGlobalFunction(InitAbsAndIrredModules,COM_FUN(13));
InstallGlobalFunction(LiftAbsAndIrredModules,COM_FUN(14));
InstallGlobalFunction(AbsAndIrredModules,COM_FUN(15));
InstallMethod(AbsolutIrreducibleModules,"generic method for groups with pcgs",true,[IsGroup and CanEasilyComputePcgs,IsField and IsFinite,IsInt],0,COM_FUN(16));
InstallMethod(IrreducibleModules,"generic method for groups with pcgs",true,[IsGroup and CanEasilyComputePcgs,IsField and IsFinite,IsInt],0,COM_FUN(17));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grppcrep.gi"

#F  file="lib/grpprmcs.gi" crc=-96852860
RANK_FILTER_LIST  := [ 62973024, 33, 62973024, 33, 7665940, 19, 62973024, 33, 
  62973024, 33, 29419057, 21, 29419057, 21, 29419057, 21, 29419057, 21, 8193, 
  2, 29419057, 21, 29419057, 21, 8193, 2 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grpprmcs.gi", -96852860 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grpprmcs.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grpprmcs.gi");
elif COM_RESULT = 3  then
Revision.grpprmcs_gi:="@(#)$Id: grpprmcs.gi,v 4.48.2.2 2005/08/25 12:43:49 gap Exp $";
GInverses:=COM_FUN(1);
InstallGlobalFunction(DisplayCompositionSeries,COM_FUN(2));
InstallMethod(CompositionSeries,"for a permutation group",true,[IsPermGroup],0,COM_FUN(3));
InstallGlobalFunction(NonPerfectCSPG,COM_FUN(4));
InstallGlobalFunction(PerfectCSPG,COM_FUN(5));
InstallGlobalFunction(CasesCSPG,COM_FUN(6));
InstallGlobalFunction(FindNormalCSPG,COM_FUN(7));
InstallGlobalFunction(FindRegularNormalCSPG,COM_FUN(8));
InstallGlobalFunction(NinKernelCSPG,COM_FUN(9));
InstallGlobalFunction(RegularNinKernelCSPG,COM_FUN(10));
InstallGlobalFunction(NormalizerStabCSPG,COM_FUN(11));
InstallGlobalFunction(TransStabCSPG,COM_FUN(12));
InstallGlobalFunction(PullbackKernelCSPG,COM_FUN(13));
InstallGlobalFunction(PullbackCSPG,COM_FUN(14));
InstallGlobalFunction(CosetRepAsWord,COM_FUN(15));
InstallGlobalFunction(ImageInWord,COM_FUN(16));
InstallGlobalFunction(SiftAsWord,COM_FUN(17));
InstallGlobalFunction(InverseAsWord,COM_FUN(18));
InstallGlobalFunction(RandomElmAsWord,COM_FUN(19));
InstallMethod(PCoreOp,"for a permutation group, and a positive integer",true,[IsPermGroup,IsPosInt],0,COM_FUN(20));
InstallMethod(RadicalGroup," for a permutation group",true,[IsPermGroup],0,COM_FUN(21));
InstallMethod(Centre,"for a permutation group",[IsPermGroup],COM_FUN(22));
InstallGlobalFunction(CentralizerNormalCSPG,COM_FUN(23));
InstallGlobalFunction(CentralizerNormalTransCSPG,COM_FUN(24));
InstallGlobalFunction(CentralizerTransSymmCSPG,COM_FUN(25));
InstallGlobalFunction(IntersectionNormalClosurePermGroup,COM_FUN(26));
InstallGlobalFunction(ActionAbelianCSPG,COM_FUN(27));
InstallGlobalFunction(ImageOnAbelianCSPG,COM_FUN(28));
InstallGlobalFunction(ChiefSeriesOfGroup,COM_FUN(29));
InstallMethod(ChiefSeries,"generic method for a group",true,[IsGroup],0,ChiefSeriesOfGroup);
InstallMethod(ChiefSeriesUnderAction,"generic method for two groups",true,[IsGroup,IsGroup],0,ChiefSeriesOfGroup);
InstallMethod(ChiefSeriesThrough,"generic method for a group and a list",true,[IsGroup,IsList],0,ChiefSeriesOfGroup);
InstallOtherMethod(ChiefSeriesThrough,"generic method for two groups and a list",true,[IsGroup,IsGroup,IsList],0,ChiefSeriesOfGroup);
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grpprmcs.gi"

#F  file="lib/grpnames.gi" crc=-100562243
RANK_FILTER_LIST  := [ 29419057, 21, 29419057, 21, 29419057, 21, 29419057, 
  21, 29419057, 21, 29419057, 21, 29419057, 21, 29419057, 21, 29419057, 21, 
  29419057, 21, 29419057, 21, 29419057, 21, 29419057, 21, 29419057, 21, 
  29419057, 21, 29419057, 21, 29419057, 21, 29419057, 21, 29419057, 21, 
  29419057, 21, 29419057, 21, 29419057, 21, 57543881, 22 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grpnames.gi", -100562243 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grpnames.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grpnames.gi");
elif COM_RESULT = 3  then
Revision.grpnames_gi:="@(#)$Id: grpnames.gi,v 4.9.2.5 2006/02/15 10:11:34 stefan Exp $";
InstallMethod(DirectFactorsOfGroup,"generic method",true,[IsGroup],0,COM_FUN(1));
InstallMethod(SemidirectFactorsOfGroup,"generic method",true,[IsGroup],0,COM_FUN(2));
InstallMethod(DecompositionTypesOfGroup,"generic method",true,[IsGroup],0,COM_FUN(3));
InstallMethod(IsDihedralGroup,"generic method",true,[IsGroup],0,COM_FUN(4));
InstallMethod(IsQuaternionGroup,"generic method",true,[IsGroup],0,COM_FUN(5));
InstallMethod(IsQuasiDihedralGroup,"generic method",true,[IsGroup],0,COM_FUN(6));
InstallMethod(IsAlternatingGroup,"generic method",true,[IsGroup],0,COM_FUN(7));
InstallMethod(AlternatingDegree,"generic method, dispatch to `IsAlternatingGroup'",true,[IsGroup],0,COM_FUN(8));
InstallOtherMethod(IsNaturalAlternatingGroup,"for non-permutation group",true,[IsGroup],0,COM_FUN(9));
InstallMethod(IsSymmetricGroup,"generic method",true,[IsGroup],0,COM_FUN(10));
InstallOtherMethod(IsNaturalSymmetricGroup,"for non-permutation group",true,[IsGroup],0,COM_FUN(11));
InstallMethod(SymmetricDegree,"generic method, dispatch to `IsSymmetricGroup'",true,[IsGroup],0,COM_FUN(12));
InstallGlobalFunction(SizeGL,COM_FUN(13));
InstallGlobalFunction(SizeSL,COM_FUN(14));
InstallGlobalFunction(SizePSL,COM_FUN(15));
InstallGlobalFunction(LinearGroupParameters,COM_FUN(16));
InstallMethod(IsPSL,"generic method for finite groups",true,[IsGroup],0,COM_FUN(17));
InstallMethod(PSLDegree,"generic method for finite groups",true,[IsGroup],0,COM_FUN(18));
InstallMethod(PSLUnderlyingField,"generic method for finite groups",true,[IsGroup],0,COM_FUN(19));
InstallMethod(IsSL,"generic method for finite groups",true,[IsGroup],0,COM_FUN(20));
InstallMethod(SLDegree,"generic method for finite groups",true,[IsGroup],0,COM_FUN(21));
InstallMethod(SLUnderlyingField,"generic method for finite groups",true,[IsGroup],0,COM_FUN(22));
InstallMethod(IsGL,"generic method for finite groups",true,[IsGroup],0,COM_FUN(23));
InstallMethod(GLDegree,"generic method for finite groups",true,[IsGroup],0,COM_FUN(24));
InstallMethod(GLUnderlyingField,"generic method for finite groups",true,[IsGroup],0,COM_FUN(25));
InstallMethod(StructureDescription,"for finite groups",true,[IsGroup],0,COM_FUN(26));
InstallMethod(ViewObj,"for groups with known structure description",true,[IsGroup and HasStructureDescription],SUM_FLAGS,COM_FUN(27));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grpnames.gi"

#F  file="lib/onecohom.gi" crc=41251423
RANK_FILTER_LIST  := [ 4097, 1, 62914396, 20, 4097, 1, 8193, 2, 4097, 1, 
  62914396, 20, 4097, 1, 8193, 2, 4097, 1, 66740907, 33, 4063233, 1, 4097, 1, 
  58719912, 21, 4097, 1, 8193, 2, 4097, 1, 8193, 2, 4097, 1, 66740907, 33, 
  4063233, 1, 4097, 1, 29419057, 21, 4063233, 1 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/onecohom.gi", 41251423 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/onecohom.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/onecohom.gi");
elif COM_RESULT = 3  then
Revision.onecohom_gi:="@(#)$Id: onecohom.gi,v 4.43.2.1 2004/02/10 18:34:23 gap Exp $";
InstallGlobalFunction(TriangulizedGeneratorsByMatrix,COM_FUN(1));
OCAddGeneratorsPcgs:=COM_FUN(2);
OCAddGeneratorsGeneral:=COM_FUN(3);
InstallGlobalFunction(OCAddGenerators,COM_FUN(4));
InstallGlobalFunction(OCAddMatrices,COM_FUN(5));
InstallGlobalFunction(OCAddToFunctions,COM_FUN(6));
InstallMethod(OCAddToFunctions2,"pc group",true,[IsRecord,IsModuloPcgs],2,COM_FUN(7));
InstallMethod(OCAddToFunctions2,"generic",true,[IsRecord,IsList],0,COM_FUN(8));
OCAddCentralizer:=COM_FUN(9);
InstallGlobalFunction(OCOneCoboundaries,COM_FUN(10));
InstallGlobalFunction(OCConjugatingWord,COM_FUN(11));
InstallMethod(OCAddRelations,"pc group",true,[IsRecord,IsModuloPcgs],0,COM_FUN(12));
InstallMethod(OCAddRelations,"perm group",true,[IsRecord,IsList],0,COM_FUN(13));
BindGlobal("OCTestRelations",COM_FUN(14));
InstallMethod(OCNormalRelations,"pc group",true,[IsRecord,IsPcGroup,IsListOrCollection],0,COM_FUN(15));
InstallMethod(OCAddSumMatrices,"pc group",true,[IsRecord,IsPcgs],0,COM_FUN(16));
InstallMethod(OCAddSumMatrices,"perm group",true,[IsRecord,IsList],0,COM_FUN(17));
InstallGlobalFunction(OCEquationMatrix,COM_FUN(18));
InstallMethod(OCAddBigMatrices,"general",true,[IsRecord,IsList],0,COM_FUN(19));
InstallGlobalFunction(OCSmallEquationMatrix,COM_FUN(20));
InstallGlobalFunction(OCEquationVector,COM_FUN(21));
InstallGlobalFunction(OCSmallEquationVector,COM_FUN(22));
InstallMethod(OCAddComplement,"pc group",true,[IsRecord,IsPcGroup,IsListOrCollection],0,COM_FUN(23));
InstallMethod(OCAddComplement,"generic",true,[IsRecord,IsGroup,IsListOrCollection],0,COM_FUN(24));
InstallGlobalFunction(OCOneCocycles,COM_FUN(25));
InstallGlobalFunction(OneCoboundaries,COM_FUN(26));
InstallGlobalFunction(OneCocycles,COM_FUN(27));
InstallGlobalFunction(ComplementclassesEA,COM_FUN(28));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/onecohom.gi"

#F  file="lib/grppccom.gi" crc=-76127841
RANK_FILTER_LIST  := [ 30937393, 25, 30937393, 25, 29419057, 21, 29419057, 
  21, 29419057, 21, 29419057, 21, 29419057, 21 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grppccom.gi", -76127841 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grppccom.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grppccom.gi");
elif COM_RESULT = 3  then
Revision.grppccom_gi:="@(#)$Id: grppccom.gi,v 4.35 2002/04/15 10:04:51 sal Exp $";
BindGlobal("HomomorphismsSeries",COM_FUN(1));
OCTestRelators:=COM_FUN(2);
InstallGlobalFunction(COAffineBlocks,COM_FUN(3));
InstallGlobalFunction(CONextCentralizer,COM_FUN(4));
InstallGlobalFunction(CONextCocycles,COM_FUN(5));
InstallGlobalFunction(CONextCentral,COM_FUN(6));
InstallGlobalFunction(CONextComplements,COM_FUN(7));
InstallGlobalFunction(COComplements,COM_FUN(8));
InstallGlobalFunction(COComplementsMain,COM_FUN(9));
InstallMethod(ComplementclassesSolvableNC,"pc groups",IsIdenticalObj,[CanEasilyComputePcgs,CanEasilyComputePcgs],0,COM_FUN(10));
InstallMethod(Complementclasses,"solvable normal subgroup",IsIdenticalObj,[IsGroup,IsGroup],0,COM_FUN(11));
InstallMethod(Complementclasses,"tell that the normal subgroup must be solvable",IsIdenticalObj,[IsGroup,IsGroup],-2*RankFilter(IsGroup),COM_FUN(12));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grppccom.gi"

#F  file="lib/grpcompl.gi" crc=85305231
RANK_FILTER_LIST  := [ 29419057, 21, 29419057, 21 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grpcompl.gi", 85305231 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grpcompl.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grpcompl.gi");
elif COM_RESULT = 3  then
Revision.grpcompl_gi:="@(#)$Id: grpcompl.gi,v 4.13.4.3 2006/08/16 09:13:10 gap Exp $";
ComplementclassesSolvableWBG:=COM_FUN(1);
InstallMethod(ComplementclassesSolvableNC,"using cohomology",IsIdenticalObj,[IsGroup,IsGroup],1,ComplementclassesSolvableWBG);
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grpcompl.gi"

#F  file="lib/twocohom.gi" crc=114187689
RANK_FILTER_LIST  := [ 66740907, 33, 1, 0, 66740907, 33, 1, 0, 66740907, 33, 
  1, 0 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/twocohom.gi", 114187689 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/twocohom.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/twocohom.gi");
elif COM_RESULT = 3  then
Revision.twocohom_gi:="@(#)$Id: twocohom.gi,v 4.18.4.1 2007/07/27 19:15:53 gap Exp $";
InstallGlobalFunction(CollectedWordSQ,COM_FUN(1));
InstallGlobalFunction(CollectorSQ,COM_FUN(2));
InstallGlobalFunction(AddEquationsSQ,COM_FUN(3));
InstallGlobalFunction(SolutionSQ,COM_FUN(4));
InstallGlobalFunction(TwoCocyclesSQ,COM_FUN(5));
InstallGlobalFunction(TwoCoboundariesSQ,COM_FUN(6));
InstallGlobalFunction(TwoCohomologySQ,COM_FUN(7));
InstallMethod(TwoCocycles,"generic method for pc groups",true,[IsPcGroup,IsObject],0,COM_FUN(8));
InstallMethod(TwoCoboundaries,"generic method for pc groups",true,[IsPcGroup,IsObject],0,COM_FUN(9));
InstallMethod(TwoCohomology,"generic method for pc groups",true,[IsPcGroup,IsObject],0,COM_FUN(10));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/twocohom.gi"

#F  file="lib/grppcext.gi" crc=96437112
RANK_FILTER_LIST  := [ 30937393, 25, 1, 0, 63198130, 7, 30937393, 25, 1, 0, 
  63198130, 7, 30937393, 25, 1, 0, 30937393, 25, 4097, 1, 29419057, 21, 
  30937393, 25, 1, 0, 30937393, 25, 1, 0, 30937393, 25, 30937393, 25, 1, 0, 
  17, 18, 30937393, 25, 17, 18 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grppcext.gi", 96437112 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grppcext.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grppcext.gi");
elif COM_RESULT = 3  then
Revision.grppcext_gi:="@(#)$Id: grppcext.gi,v 4.55 2003/04/09 16:25:45 gap Exp $";
InstallGlobalFunction(FpGroupPcGroupSQ,COM_FUN(1));
InstallGlobalFunction(MappedPcElement,COM_FUN(2));
InstallGlobalFunction(ExtensionSQ,COM_FUN(3));
BindGlobal("FastExtSQ",COM_FUN(4));
InstallMethod(Extension,"generic method for pc groups",true,[CanEasilyComputePcgs,IsObject,IsVector],0,COM_FUN(5));
InstallMethod(ExtensionNC,"generic method for pc groups",true,[CanEasilyComputePcgs,IsObject,IsVector],0,COM_FUN(6));
InstallMethod(Extensions,"generic method for pc groups",true,[CanEasilyComputePcgs,IsObject],0,COM_FUN(7));
RelVectorToCocycle:=COM_FUN(8);
OnRelVector:=COM_FUN(9);
CocycleToRelVector:=COM_FUN(10);
OnCocycle:=COM_FUN(11);
IsCocycle:=COM_FUN(12);
InstallGlobalFunction(CompatiblePairs,COM_FUN(13));
IsCompatiblePair:=COM_FUN(14);
MatrixOperationOfCP:=COM_FUN(15);
MatrixOperationOfCPGroup:=COM_FUN(16);
InstallMethod(ExtensionRepresentatives,"generic method for pc groups",true,[CanEasilyComputePcgs,IsRecord,IsGroup],0,COM_FUN(17));
MyIntCoefficients:=COM_FUN(18);
MatOrbsApprox:=COM_FUN(19);
MatOrbs:=COM_FUN(20);
NonSplitExtensions:=COM_FUN(21);
InstallMethod(SplitExtension,"generic method for pc groups",true,[CanEasilyComputePcgs,IsObject],0,COM_FUN(22));
InstallOtherMethod(SplitExtension,"generic method for pc groups",true,[CanEasilyComputePcgs,IsObject,CanEasilyComputePcgs],0,COM_FUN(23));
ConjugatingElement:=COM_FUN(24);
InstallMethod(TopExtensionsByAutomorphism,"generic method for groups",true,[CanEasilyComputePcgs,IsObject,IsInt],0,COM_FUN(25));
InstallMethod(CyclicTopExtensions,"generic method for pc groups",true,[CanEasilyComputePcgs,IsInt],0,COM_FUN(26));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grppcext.gi"

#F  file="lib/randiso.gi" crc=-86586200
RANK_FILTER_LIST  := [ 66740907, 33, 29419057, 21 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/randiso.gi", -86586200 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/randiso.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/randiso.gi");
elif COM_RESULT = 3  then
Revision.randiso_gi:="@(#)$Id: randiso.gi,v 1.24 2002/04/15 10:05:13 sal Exp $";
FingerprintFF:=COM_FUN(1);
InstallMethod(OmegaAndLowerPCentralSeries,"omega and lower central",true,[IsPcGroup],0,COM_FUN(2));
InstallMethod(OmegaAndLowerPCentralSeries,"general case: warn that no method available",true,[IsGroup],0,COM_FUN(3));
RelatorsCode:=COM_FUN(4);
InstallGlobalFunction(PcGroupCode,COM_FUN(5));
InstallGlobalFunction(CodePcgs,COM_FUN(6));
InstallGlobalFunction(CodePcGroup,COM_FUN(7));
InstallGlobalFunction(PcGroupCodeRec,COM_FUN(8));
RandomByPcs:=COM_FUN(9);
IsLinearlyIndependent:=COM_FUN(10);
FindLayer:=COM_FUN(11);
RandomPcgsSylowSubgroup:=COM_FUN(12);
InstallGlobalFunction(RandomSpecialPcgsCoded,COM_FUN(13));
InstallGlobalFunction(RandomIsomorphismTest,COM_FUN(14));
InstallGlobalFunction(ReducedByIsomorphisms,COM_FUN(15));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/randiso.gi"

#F  file="lib/randiso2.gi" crc=-122091834
RANK_FILTER_LIST  := [  ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/randiso2.gi", -122091834 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/randiso2.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/randiso2.gi");
elif COM_RESULT = 3  then
Revision.randiso2_gi:="@(#)$Id: randiso2.gi,v 1.23 2002/04/15 10:05:13 sal Exp $";
EvalFpCoc:=COM_FUN(1);
CocGroup:=COM_FUN(2);
DiffCoc:=COM_FUN(3);
SplitUpSublistsByFpFunc:=COM_FUN(4);
CodeGenerators:=COM_FUN(5);
IsomorphismSolvableSmallGroups:=COM_FUN(6);
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/randiso2.gi"

#F  file="lib/grppcfp.gi" crc=100879095
RANK_FILTER_LIST  := [ 60356449, 25, 67108760, 5, 60356449, 25, 67108760, 5, 
  29419057, 21, 58719912, 21, 67108760, 5 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grppcfp.gi", 100879095 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grppcfp.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grppcfp.gi");
elif COM_RESULT = 3  then
Revision.grppcfp_gi:="@(#)$Id: grppcfp.gi,v 4.44.2.3 2005/11/30 03:05:31 gap Exp $";
InstallGlobalFunction(PcGroupFpGroup,COM_FUN(1));
InstallGlobalFunction(PcGroupFpGroupNC,COM_FUN(2));
InstallGlobalFunction(IsomorphismFpGroupByPcgs,COM_FUN(3));
InstallOtherMethod(IsomorphismFpGroupByCompositionSeries,"pc groups",true,[IsGroup and CanEasilyComputePcgs,IsString],0,COM_FUN(4));
InstallOtherMethod(IsomorphismFpGroup,"pc groups",true,[IsGroup and CanEasilyComputePcgs,IsString],0,COM_FUN(5));
InstallMethod(IsomorphismFpGroupByGeneratorsNC,"pcgs",IsFamFamX,[IsGroup,IsPcgs,IsString],0,COM_FUN(6));
InstallGlobalFunction(InitEpimorphismSQ,COM_FUN(7));
InstallGlobalFunction(LiftEpimorphismSQ,COM_FUN(8));
InstallGlobalFunction(BlowUpCocycleSQ,COM_FUN(9));
InstallGlobalFunction(TryModuleSQ,COM_FUN(10));
InstallGlobalFunction(AllModulesSQ,COM_FUN(11));
InstallGlobalFunction(TryLayerSQ,COM_FUN(12));
InstallGlobalFunction(EAPrimeLayerSQ,COM_FUN(13));
InstallGlobalFunction(SolvableQuotient,COM_FUN(14));
InstallGlobalFunction(EpimorphismSolvableQuotient,COM_FUN(15));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grppcfp.gi"

#F  file="lib/schur.gi" crc=-120283220
RANK_FILTER_LIST  := [ 55999958, 23, 29419057, 21, 29419057, 21, 29419057, 
  21, 29419057, 21, 29419057, 21, 8193, 2, 29419057, 21, 29419057, 21, 
  29419057, 21, 29419057, 21, 29419057, 21, 29419057, 21, 29419057, 21 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/schur.gi", -120283220 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/schur.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/schur.gi");
elif COM_RESULT = 3  then
Revision.schur_gi:="@(#)$Id: schur.gi,v 4.18.4.6 2006/08/17 14:41:21 gap Exp $";
BindGlobal("SchurCoverFP",COM_FUN(1));
InstallMethod(SchurCover,"of fp group",true,[IsSubgroupFpGroup],0,SchurCoverFP);
InstallMethod(EpimorphismSchurCover,"generic, via fp group",true,[IsGroup],1,COM_FUN(2));
BindGlobal("CommutGenImgs",COM_FUN(3));
InstallGlobalFunction(SchuMu,COM_FUN(4));
InstallMethod(AbelianInvariantsMultiplier,"naive",true,[IsGroup],1,COM_FUN(5));
InstallMethod(AbelianInvariantsMultiplier,"via Sylow Subgroups",true,[IsGroup],0,COM_FUN(6));
BindGlobal("PositiveExponentsPresentationFpHom",COM_FUN(7));
InstallGlobalFunction(CorestEval,COM_FUN(8));
InstallGlobalFunction(RelatorFixedMultiplier,COM_FUN(9));
BindGlobal("MulExt",COM_FUN(10));
DoMulExt:=COM_FUN(11);
InstallMethod(EpimorphismSchurCover,"Holt's algorithm",true,[IsGroup],0,DoMulExt);
InstallOtherMethod(EpimorphismSchurCover,"Holt's algorithm, primes",true,[IsGroup,IsList],0,DoMulExt);
InstallMethod(SchurCover,"general: Holt's algorithm",true,[IsGroup],0,COM_FUN(12));
InstallMethod(Epicentre,"Naive Method",true,[IsGroup],0,COM_FUN(13));
InstallOtherMethod(Epicentre,"Naive method",true,[IsGroup,IsGroup],0,COM_FUN(14));
InstallMethod(NonabelianExteriorSquare,"Naive method",true,[IsGroup],0,COM_FUN(15));
InstallMethod(EpimorphismNonabelianExteriorSquare,"Naive method",true,[IsGroup],0,COM_FUN(16));
InstallMethod(IsCentralFactor,"Naive method",true,[IsGroup],0,COM_FUN(17));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/schur.gi"

#F  file="lib/grpnice.gi" crc=-25614505
RANK_FILTER_LIST  := [ 29419057, 21, 11226115, 13, 29418502, 222, 29418502, 
  222, 2214405, 17, 29419057, 21, 29418502, 222, 11884457, 238, 22662639, 
  223, 29418502, 222, 29418502, 222, 29418502, 222, 65767820, 5, 29418502, 
  222, 29418502, 223, 29418502, 223, 29418502, 223, 29418502, 223, 1, 0, 
  29418502, 223, 29418502, 223, 29418502, 223, 29418502, 223, 65767820, 5, 
  29418502, 223, 29418502, 223, 29418502, 223, 29418502, 223, 29418502, 223, 
  22662639, 224, 65767820, 5, 29418502, 223, 29418502, 223, 29418502, 223, 
  29418502, 223, 29418502, 223, 29418502, 223, 29418502, 223, 29418502, 223, 
  29418502, 223, 29418502, 223, 29418502, 223, 8193, 2, 29418502, 223, 
  29418502, 223, 29418502, 223, 29418502, 223, 29418502, 223, 29418502, 223, 
  29418502, 223, 29418502, 223, 29418502, 223, 29418502, 223, 29418502, 223, 
  29418502, 223, 29418502, 223, 29418502, 223, 29418502, 223, 29418502, 223, 
  29418502, 223, 29418502, 223, 29418502, 223, 29418502, 223, 67108760, 5, 
  29418502, 223, 8193, 2, 67108760, 5, 29418502, 223, 29418502, 223, 
  29418502, 223, 29418502, 223, 29418502, 223, 29418502, 223, 29418502, 223, 
  29418502, 223, 29418502, 223, 29418502, 223, 29418502, 223, 29418502, 223, 
  29418502, 223, 29418502, 223, 7665940, 19, 29418502, 223, 7665940, 19, 
  29418502, 223, 17, 18, 32769, 4, 29418502, 223, 29418502, 223, 29418502, 
  223, 29418502, 223, 29419057, 21, 29418502, 223, 29418502, 223, 29418502, 
  223, 29418502, 223, 7665940, 19, 29418502, 223, 29418502, 223, 65767820, 5, 
  65767820, 5, 5, 1, 29418502, 223, 29419057, 21, 29418502, 223, 29419057, 
  21, 8193, 2, 8193, 2, 59460056, 14, 57244422, 18, 65767820, 5, 12641151, 
  22, 19981588, 22 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grpnice.gi", -25614505 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grpnice.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grpnice.gi");
elif COM_RESULT = 3  then
Revision.grpnice_gi:="@(#)$Id: grpnice.gi,v 4.71.2.2 2005/11/17 16:47:05 gap Exp $";
InstallMethod(SetNiceMonomorphism,"set `IsNiceomorphism' property",true,[IsGroup,IsGroupGeneralMapping],SUM_FLAGS+10,COM_FUN(1));
InstallGlobalFunction(RestrictedNiceMonomorphism,COM_FUN(2));
InstallMethod(GeneratorsOfMagmaWithInverses,true,[IsGroup and IsHandledByNiceMonomorphism],0,COM_FUN(3));
InstallMethod(SmallGeneratingSet,true,[IsGroup and IsHandledByNiceMonomorphism],0,COM_FUN(4));
InstallMethod(GroupByNiceMonomorphism,true,[IsGroupHomomorphism,IsGroup],0,COM_FUN(5));
InstallMethod(NiceObject,true,[IsGroup and IsHandledByNiceMonomorphism],0,COM_FUN(6));
InstallMethod(NiceMonomorphism,"for subgroups that get the nice monomorphism by their parent",true,[IsGroup and IsHandledByNiceMonomorphism and HasParent],RankFilter(IsFinite and IsMatrixGroup),COM_FUN(7));
InstallMethod(NiceMonomorphism,"regular action",true,[IsGroup and IsHandledByNiceMonomorphism],0,COM_FUN(8));
PropertyMethodByNiceMonomorphismCollColl(\=,[IsGroup,IsGroup]);
InstallMethod(\in,"by nice monomorphism",IsElmsColls,[IsMultiplicativeElementWithInverse,IsGroup and IsHandledByNiceMonomorphism],0,COM_FUN(9));
InstallTrueMethod(CanEasilyTestMembership,IsHandledByNiceMonomorphism);
AttributeMethodByNiceMonomorphism(AbelianInvariants,[IsGroup]);
SubgroupMethodByNiceMonomorphismCollColl(CentralizerOp,[IsGroup,IsGroup]);
SubgroupMethodByNiceMonomorphismCollElm(CentralizerOp,[IsGroup,IsObject]);
GroupSeriesMethodByNiceMonomorphism(ChiefSeries,[IsGroup]);
GroupMethodByNiceMonomorphismCollColl(ClosureGroup,[IsGroup,IsGroup]);
GroupMethodByNiceMonomorphismCollElm(ClosureGroup,[IsGroup,IsMultiplicativeElementWithInverse]);
AttributeMethodByNiceMonomorphism(CommutatorFactorGroup,[IsGroup]);
GroupMethodByNiceMonomorphismCollColl(CommutatorSubgroup,[IsGroup,IsGroup]);
GroupSeriesMethodByNiceMonomorphism(CompositionSeries,[IsGroup]);
InstallMethod(ConjugacyClasses,"via niceomorphism",true,[IsGroup and IsHandledByNiceMonomorphism],0,COM_FUN(10));
GroupMethodByNiceMonomorphismCollElm(ConjugateGroup,[IsGroup and HasParent,IsMultiplicativeElementWithInverse]);
GroupMethodByNiceMonomorphismCollColl(CoreOp,[IsGroup,IsGroup]);
AttributeMethodByNiceMonomorphism(DerivedLength,[IsGroup]);
GroupSeriesMethodByNiceMonomorphism(DerivedSeriesOfGroup,[IsGroup]);
SubgroupMethodByNiceMonomorphism(DerivedSubgroup,[IsGroup]);
GroupSeriesMethodByNiceMonomorphism(ElementaryAbelianSeries,[IsGroup]);
GroupSeriesMethodByNiceMonomorphism(ElementaryAbelianSeriesLargeSteps,[IsGroup]);
AttributeMethodByNiceMonomorphism(Exponent,[IsGroup]);
SubgroupMethodByNiceMonomorphism(FittingSubgroup,[IsGroup]);
SubgroupMethodByNiceMonomorphism(FrattiniSubgroup,[IsGroup]);
InstallMethod(HallSubgroupOp,"via niceomorphism",true,[IsGroup and IsHandledByNiceMonomorphism,IsList],0,COM_FUN(11));
AttributeMethodByNiceMonomorphismCollColl(IndexOp,[IsGroup,IsGroup]);
AttributeMethodByNiceMonomorphismCollColl(IndexNC,[IsGroup,IsGroup]);
GroupMethodByNiceMonomorphismCollColl(Intersection2,[IsGroup,IsGroup]);
PropertyMethodByNiceMonomorphism(IsCyclic,[IsGroup]);
PropertyMethodByNiceMonomorphism(IsMonomialGroup,[IsGroup]);
PropertyMethodByNiceMonomorphism(IsNilpotentGroup,[IsGroup]);
PropertyMethodByNiceMonomorphismCollColl(IsNormalOp,[IsGroup,IsGroup]);
PropertyMethodByNiceMonomorphism(IsPerfectGroup,[IsGroup]);
PropertyMethodByNiceMonomorphism(IsSimpleGroup,[IsGroup]);
PropertyMethodByNiceMonomorphism(IsSolvableGroup,[IsGroup]);
PropertyMethodByNiceMonomorphismCollColl(IsSubset,[IsGroup,IsGroup]);
PropertyMethodByNiceMonomorphism(IsSupersolvableGroup,[IsGroup]);
InstallMethod(IsomorphismPermGroup,"via niceomorphisms",true,[IsGroup and IsHandledByNiceMonomorphism],-NICE_FLAGS+5,COM_FUN(12));
InstallMethod(IsomorphismPcGroup,"via niceomorphisms",true,[IsGroup and IsHandledByNiceMonomorphism],0,COM_FUN(13));
InstallOtherMethod(IsomorphismFpGroup,"via niceomorphism",true,[IsGroup and IsHandledByNiceMonomorphism,IsString],0,COM_FUN(14));
InstallMethod(IsomorphismFpGroupByGeneratorsNC,"via niceomorphism/w. gens",IsFamFamX,[IsGroup and IsHandledByNiceMonomorphism,IsList,IsString],0,COM_FUN(15));
GroupSeriesMethodByNiceMonomorphism(JenningsSeries,[IsGroup]);
GroupSeriesMethodByNiceMonomorphism(LowerCentralSeriesOfGroup,[IsGroup]);
SubgroupsMethodByNiceMonomorphism(MaximalSubgroupClassReps,[IsGroup]);
SubgroupsMethodByNiceMonomorphism(NormalSubgroups,[IsGroup]);
GroupMethodByNiceMonomorphismCollColl(NormalClosureOp,[IsGroup,IsGroup]);
GroupMethodByNiceMonomorphismCollColl(NormalIntersection,[IsGroup,IsGroup]);
SubgroupMethodByNiceMonomorphismCollColl(NormalizerOp,[IsGroup,IsGroup]);
AttributeMethodByNiceMonomorphism(NrConjugacyClasses,[IsGroup]);
AttributeMethodByNiceMonomorphismCollColl(NrConjugacyClassesInSupergroup,[IsGroup,IsGroup]);
GroupSeriesMethodByNiceMonomorphismCollOther(PCentralSeriesOp,[IsGroup,IsPosInt]);
SubgroupMethodByNiceMonomorphismCollOther(PCoreOp,[IsGroup,IsPosInt]);
InstallMethod(PowerMapOfGroup,"via niceomorphism",true,[IsGroup and IsHandledByNiceMonomorphism,IsInt,IsHomogeneousList],0,COM_FUN(16));
SubgroupMethodByNiceMonomorphism(RadicalGroup,[IsGroup]);
InstallMethod(Random,"handled by nice monomorphism",true,[IsGroup and IsHandledByNiceMonomorphism],0,COM_FUN(17));
InstallMethod(RationalClasses,"via niceomorphism",true,[IsGroup and IsHandledByNiceMonomorphism],0,COM_FUN(18));
InstallMethod(RightCosetsNC,"via niceomorphism",true,[IsGroup and IsHandledByNiceMonomorphism,IsGroup],0,COM_FUN(19));
AttributeMethodByNiceMonomorphism(Size,[IsGroup]);
GroupSeriesMethodByNiceMonomorphismCollColl(SubnormalSeriesOp,[IsGroup,IsGroup]);
SubgroupMethodByNiceMonomorphismCollOther(SylowSubgroupOp,[IsGroup,IsPosInt]);
GroupSeriesMethodByNiceMonomorphism(UpperCentralSeriesOfGroup,[IsGroup]);
InstallOtherMethod(RepresentativeActionOp,"nice group on elements",IsCollsElmsElmsX,[IsHandledByNiceMonomorphism and IsGroup,IsMultiplicativeElementWithInverse,IsMultiplicativeElementWithInverse,IsFunction],10,COM_FUN(20));
InstallMethod(NaturalHomomorphismByNormalSubgroupOp,IsIdenticalObj,[IsHandledByNiceMonomorphism and IsGroup,IsGroup],0,COM_FUN(21));
InstallMethod(GroupGeneralMappingByImages,"from a group handled by a niceomorphism",true,[IsGroup and IsHandledByNiceMonomorphism,IsGroup,IsList,IsList],0,COM_FUN(22));
InstallMethod(AsGroupGeneralMappingByImages,"for Niceomorphisms: avoid recursion",true,[IsGroupGeneralMapping and IsNiceMonomorphism],NICE_FLAGS,COM_FUN(23));
InstallMethod(PreImagesRepresentative,"for PBG-Niceo",FamRangeEqFamElm,[IsPreimagesByAsGroupGeneralMappingByImages and IsNiceMonomorphism,IsMultiplicativeElementWithInverse],0,COM_FUN(24));
InstallMethod(NiceMonomorphism,"if a canonical nice monomorphism is already known",true,[IsGroup and HasCanonicalNiceMonomorphism],100,CanonicalNiceMonomorphism);
InstallMethod(CanonicalNiceMonomorphism,"test canonicity of existing niceo",true,[IsGroup and HasNiceMonomorphism],0,COM_FUN(25));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grpnice.gi"

#F  file="lib/morpheus.gi" crc=96099555
RANK_FILTER_LIST  := [ 13669054, 23, 29419057, 21, 29419057, 21, 46916429, 
  24, 513, 8, 29407897, 26, 29419057, 21, 14188609, 38, 41627213, 232, 
  23256941, 30, 29419057, 21, 29407897, 26, 29407897, 26, 29407897, 26 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/morpheus.gi", 96099555 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/morpheus.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/morpheus.gi");
elif COM_RESULT = 3  then
Revision.morpheus_gi:="@(#)$Id: morpheus.gi,v 4.105.2.4 2005/12/15 21:20:59 gap Exp $";
MORPHEUSELMS:=50000;
InstallMethod(AutomorphismDomain,"use source of one",true,[IsGroupOfAutomorphisms],0,COM_FUN(1));
DeclareRepresentation("IsActionHomomorphismAutomGroup",IsActionHomomorphismByBase,["basepos"]);
InstallMethod(IsGroupOfAutomorphisms,"test generators and one",true,[IsGroup],0,COM_FUN(2));
InstallMethod(IsGroupOfAutomorphismsFiniteGroup,"default",true,[IsGroup],0,COM_FUN(3));
InstallGlobalFunction(AssignNiceMonomorphismAutomorphismGroup,COM_FUN(4));
InstallGlobalFunction(NiceMonomorphismAutomGroup,COM_FUN(5));
InstallMethod(PreImagesRepresentative,"AutomGroup Niceomorphism",FamRangeEqFamElm,[IsActionHomomorphismAutomGroup,IsPerm],0,COM_FUN(6));
InstallGlobalFunction(MorFroWords,COM_FUN(7));
InstallGlobalFunction(MorRatClasses,COM_FUN(8));
InstallGlobalFunction(MorMaxFusClasses,COM_FUN(9));
BindGlobal("SomeVerbalSubgroups",COM_FUN(10));
MorClassOrbs:=COM_FUN(11);
InstallGlobalFunction(MorClassLoop,COM_FUN(12));
InstallGlobalFunction(MorFindGeneratingSystem,COM_FUN(13));
InstallGlobalFunction(Morphium,COM_FUN(14));
InstallGlobalFunction(AutomorphismGroupAbelianGroup,COM_FUN(15));
InstallGlobalFunction(IsomorphismAbelianGroups,COM_FUN(16));
InstallMethod(AutomorphismGroup,"for groups",true,[IsGroup and IsFinite],0,COM_FUN(17));
RedispatchOnCondition(AutomorphismGroup,true,[IsGroup],[IsGroup and IsFinite],0);
InstallMethod(AutomorphismGroup,"finite abelian groups",true,[IsGroup and IsFinite and IsAbelian],0,AutomorphismGroupAbelianGroup);
InstallMethod(NiceMonomorphism,"for automorphism groups",true,[IsGroupOfAutomorphismsFiniteGroup],0,COM_FUN(18));
InstallMethod(InnerAutomorphismsAutomorphismGroup,"for automorphism groups",true,[IsAutomorphismGroup and IsFinite],0,COM_FUN(19));
InstallGlobalFunction(IsomorphismGroups,COM_FUN(20));
InstallMethod(GQuotients,"for groups which can compute element orders",true,[IsGroup,IsGroup and IsFinite],1,COM_FUN(21));
InstallMethod(IsomorphicSubgroups,"for finite groups",true,[IsGroup and IsFinite,IsGroup and IsFinite],1,COM_FUN(22));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/morpheus.gi"

#F  file="lib/grplatt.gi" crc=-85717841
RANK_FILTER_LIST  := [ 29419057, 21, 29419057, 21, 29419057, 21, 25640940, 
  11, 25640940, 11, 29419057, 21, 25640940, 11, 25640940, 11, 25640940, 11, 
  7665940, 19, 25640940, 11, 7665940, 19, 25640940, 11, 25640940, 11, 
  25640940, 11, 29419057, 21, 27273315, 3, 29419057, 21, 27273315, 3, 
  27273315, 3, 29419057, 21, 29419057, 21, 64094577, 23, 29419057, 21, 
  29419057, 21, 16856508, 22, 27273315, 3, 27273315, 3, 29419057, 21, 
  29419057, 21, 29419057, 21, 66740907, 33, 62973024, 33, 29419057, 21, 
  29419057, 21, 29419057, 21, 29419057, 21, 29419057, 21 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grplatt.gi", -85717841 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grplatt.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grplatt.gi");
elif COM_RESULT = 3  then
Revision.grplatt_gi:="@(#)$Id: grplatt.gi,v 4.70.2.1 2006/11/13 16:52:31 gap Exp $";
InstallMethod(Zuppos,"group",true,[IsGroup],0,COM_FUN(1));
InstallMethod(ConjugacyClassSubgroups,IsIdenticalObj,[IsGroup,IsGroup],0,COM_FUN(2));
InstallMethod(\=,IsIdenticalObj,[IsConjugacyClassSubgroupsRep,IsConjugacyClassSubgroupsRep],0,COM_FUN(3));
InstallMethod(\in,IsElmsColls,[IsGroup,IsConjugacyClassSubgroupsRep],0,COM_FUN(4));
InstallOtherMethod(AsList,"for classes of subgroups",true,[IsConjugacyClassSubgroupsRep],0,COM_FUN(5));
InstallMethod(ClassElementLattice,"for classes of subgroups",true,[IsConjugacyClassSubgroupsRep,IsPosInt],0,COM_FUN(6));
InstallOtherMethod(\[\],"for classes of subgroups",true,[IsConjugacyClassSubgroupsRep,IsPosInt],0,ClassElementLattice);
InstallMethod(StabilizerOfExternalSet,true,[IsConjugacyClassSubgroupsRep],10,COM_FUN(7));
InstallOtherMethod(NormalizerOp,true,[IsConjugacyClassSubgroupsRep],0,StabilizerOfExternalSet);
InstallMethod(PrintObj,true,[IsConjugacyClassSubgroupsRep],0,COM_FUN(8));
InstallMethod(ConjugacyClassesSubgroups,"group",true,[IsGroup],0,COM_FUN(9));
InstallOtherMethod(ConjugacyClassesSubgroups,"lattice",true,[IsLatticeSubgroupsRep],0,COM_FUN(10));
SOLVABILITY_IMPLYING_FUNCTIONS:=[IsSolvableGroup,IsNilpotentGroup,IsPGroup,IsCyclic];
InstallGlobalFunction(LatticeByCyclicExtension,COM_FUN(11));
InstallMethod(LatticeSubgroups,"cyclic extension",true,[IsGroup],0,LatticeByCyclicExtension);
InstallMethod(ViewObj,"lattice",true,[IsLatticeSubgroupsRep],0,COM_FUN(12));
InstallMethod(PrintObj,"lattice",true,[IsLatticeSubgroupsRep],0,COM_FUN(13));
InstallMethod(ConjugacyClassesPerfectSubgroups,"generic",true,[IsGroup],0,COM_FUN(14));
InstallMethod(PerfectResiduum,"for groups",true,[IsGroup],0,COM_FUN(15));
InstallMethod(RepresentativesPerfectSubgroups,"solvable",true,[IsSolvableGroup],0,COM_FUN(16));
BindGlobal("RepsPerfSimpSub",COM_FUN(17));
InstallMethod(RepresentativesPerfectSubgroups,"using Holt/Plesken library",true,[IsGroup],0,COM_FUN(18));
InstallMethod(RepresentativesSimpleSubgroups,"using Holt/Plesken library",true,[IsGroup],0,COM_FUN(19));
InstallMethod(RepresentativesSimpleSubgroups,"if perfect subs are known",true,[IsGroup and HasRepresentativesPerfectSubgroups],0,COM_FUN(20));
InstallMethod(MaximalSubgroupsLattice,"cyclic extension",true,[IsLatticeSubgroupsRep],0,COM_FUN(21));
InstallMethod(MinimalSupergroupsLattice,"cyclic extension",true,[IsLatticeSubgroupsRep],0,COM_FUN(22));
InstallMethod(MaximalSubgroupClassReps,"using lattice",true,[IsGroup],0,COM_FUN(23));
InstallMethod(ConjugacyClassesMaximalSubgroups,"use MaximalSubgroupClassReps",true,[IsGroup],0,COM_FUN(24));
InstallMethod(MaximalSubgroups,"expand list",true,[IsGroup],0,COM_FUN(25));
NormalSubgroupsCalc:=COM_FUN(26);
InstallMethod(NormalSubgroups,"homomorphism principle pc groups",true,[IsPcGroup],0,NormalSubgroupsCalc);
InstallMethod(NormalSubgroups,"homomorphism principle perm groups",true,[IsPermGroup],0,NormalSubgroupsCalc);
InstallMethod(Socle,"from normal subgroups",true,[IsGroup],0,COM_FUN(27));
InstallMethod(IntermediateSubgroups,"blocks for coset operation",IsIdenticalObj,[IsGroup,IsGroup],0,COM_FUN(28));
InstallMethod(IntermediateSubgroups,"normal case",IsIdenticalObj,[IsGroup,IsGroup],1,COM_FUN(29));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grplatt.gi"

#F  file="lib/oprtglat.gi" crc=-130584427
RANK_FILTER_LIST  := [ 29419057, 21, 8193, 2, 1025, 1, 62973024, 33, 8193, 2, 
  1025, 1, 66740907, 33, 8193, 2, 1025, 1, 29419057, 21, 4097, 1, 1025, 1, 
  29419057, 21, 8193, 2, 29419057, 21, 8193, 2, 8193, 2, 5, 1, 29419057, 21, 
  29419057, 21, 8193, 2, 8193, 2, 5, 1 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/oprtglat.gi", -130584427 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/oprtglat.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/oprtglat.gi");
elif COM_RESULT = 3  then
Revision.oprtglat_gi:="@(#)$Id: oprtglat.gi,v 4.12 2002/04/15 10:05:06 sal Exp $";
InstallGlobalFunction(GroupOnSubgroupsOrbit,COM_FUN(1));
InstallGlobalFunction(MinimumGroupOnSubgroupsOrbit,COM_FUN(2));
InstallMethod(SubgroupsOrbitsAndNormalizers,"generic on list",true,[IsGroup,IsList,IsBool],0,COM_FUN(3));
InstallMethod(SubgroupsOrbitsAndNormalizers,"perm group on list",true,[IsPermGroup,IsList,IsBool],0,COM_FUN(4));
InstallMethod(SubgroupsOrbitsAndNormalizers,"pc group on list",true,[IsPcGroup,IsList,IsBool],0,COM_FUN(5));
InstallMethod(SubgroupsOrbitsAndNormalizers,"generic on record with list",true,[IsGroup,IsRecord,IsBool],0,COM_FUN(6));
InstallMethod(StabilizerOp,"with domain, use normalizer",true,[IsGroup,IsList,IsGroup,IsList,IsList,IsFunction],200,COM_FUN(7));
InstallOtherMethod(StabilizerOp,"use normalizer",true,[IsGroup,IsGroup,IsList,IsList,IsFunction],200,COM_FUN(8));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/oprtglat.gi"

#F  file="lib/grppclat.gi" crc=88192865
RANK_FILTER_LIST  := [ 29419057, 21 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grppclat.gi", 88192865 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grppclat.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grppclat.gi");
elif COM_RESULT = 3  then
Revision.grppclat_gi:="@(#)$Id: grppclat.gi,v 4.59.2.1 2007/07/11 15:41:51 gap Exp $";
InstallGlobalFunction(InvariantElementaryAbelianSeries,COM_FUN(1));
InstallGlobalFunction(InducedAutomorphism,COM_FUN(2));
InstallGlobalFunction(InvariantSubgroupsElementaryAbelianGroup,COM_FUN(3));
InstallGlobalFunction(ActionSubspacesElementaryAbelianGroup,COM_FUN(4));
HasInvariantConjugateSubgroup:=COM_FUN(5);
InstallGlobalFunction(SubgroupsSolvableGroup,COM_FUN(6));
InstallMethod(LatticeSubgroups,"elementary abelian extension",true,[IsGroup],1,COM_FUN(7));
InstallGlobalFunction(SizeConsiderFunction,COM_FUN(8));
InstallGlobalFunction(ExactSizeConsiderFunction,COM_FUN(9));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grppclat.gi"

#F  file="lib/grppcaut.gi" crc=-78853831
RANK_FILTER_LIST  := [ 60345289, 30, 26024402, 28 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grppcaut.gi", -78853831 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grppcaut.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grppcaut.gi");
elif COM_RESULT = 3  then
Revision.grppcaut_gi:="@(#)$Id: grppcaut.gi,v 4.50 2003/06/06 21:13:16 gap Exp $";
CheckAuto:=COM_FUN(1);
InducedActionFactor:=COM_FUN(2);
CoefficientsOfVector:=COM_FUN(3);
StabilizerByMatrixOperation:=COM_FUN(4);
TransferPcgsInfo:=COM_FUN(5);
BlockStabilizer:=COM_FUN(6);
InducedActionAutGroup:=COM_FUN(7);
if not IsBound(MyFingerprint) then
MyFingerprint:=false;
fi;
FingerprintSmall:=COM_FUN(8);
FingerprintMedium:=COM_FUN(9);
FingerprintLarge:=COM_FUN(10);
Fingerprint:=COM_FUN(11);
NormalizingReducedGL:=COM_FUN(12);
CocycleSQ:=COM_FUN(13);
InduciblePairs:=COM_FUN(14);
MatricesOfRelator:=COM_FUN(15);
VectorOfRelator:=COM_FUN(16);
LiftInduciblePair:=COM_FUN(17);
AutomorphismGroupElAbGroup:=COM_FUN(18);
AutomorphismGroupSolvableGroup:=COM_FUN(19);
AutomorphismGroupFrattFreeGroup:=COM_FUN(20);
InstallMethod(AutomorphismGroup,"finite solvable groups",true,[IsGroup and IsFinite and CanEasilyComputePcgs],0,COM_FUN(21));
InstallMethod(AutomorphismGroup,"finite frattini free solvable groups",true,[IsGroup and IsFinite and IsFrattiniFree],0,COM_FUN(22));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grppcaut.gi"

#F  file="lib/grpmat.gi" crc=78510531
RANK_FILTER_LIST  := [ 11895617, 31, 8193, 2, 11895617, 31, 49282538, 34, 
  66093634, 34, 11895617, 31, 3427700, 32, 26091422, 34, 11895617, 31, 
  11895617, 31, 11895617, 31, 11884457, 239, 11884457, 239, 11884457, 239, 
  11884457, 239, 11884457, 239, 11884457, 239, 58412696, 30, 3427700, 32, 
  11895617, 31, 11895617, 31, 11895617, 31, 3427700, 32, 58412696, 30, 
  36830888, 33, 58412696, 30, 26213501, 33, 49585440, 16, 53865321, 19, 
  53865321, 19, 38983364, 26, 11226115, 13, 26723978, 17, 58412696, 30, 
  26723978, 17, 58412696, 30, 24477644, 32 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grpmat.gi", 78510531 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grpmat.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grpmat.gi");
elif COM_RESULT = 3  then
Revision.grpmat_gi:="@(#)$Id: grpmat.gi,v 4.60.2.4 2006/02/15 10:11:34 stefan Exp $";
InstallMethod(KnowsHowToDecompose,"matrix groups",[IsMatrixGroup,IsList],ReturnFalse);
InstallMethod(DefaultFieldOfMatrixGroup,"using 'FieldOfMatrixGroup'",[IsMatrixGroup],FieldOfMatrixGroup);
InstallMethod(DefaultFieldOfMatrixGroup,"for matrix group over the cyclotomics",[IsMatrixGroup and IsCyclotomicCollCollColl],COM_FUN(1));
InstallMethod(DefaultFieldOfMatrixGroup,"for a matrix group over an s.c. algebra",[IsMatrixGroup and IsSCAlgebraObjCollCollColl],COM_FUN(2));
InstallMethod(FieldOfMatrixGroup,"for a matrix group",[IsMatrixGroup],COM_FUN(3));
InstallMethod(DimensionOfMatrixGroup,"from generators",[IsMatrixGroup and HasGeneratorsOfGroup],COM_FUN(4));
InstallMethod(DimensionOfMatrixGroup,"from one",[IsMatrixGroup and HasOne],1,COM_FUN(5));
InstallOtherMethod(One,"for matrix group, call `IdentityMat'",[IsMatrixGroup],COM_FUN(6));
InstallMethod(TransposedMatrixGroup,[IsMatrixGroup],COM_FUN(7));
InstallGlobalFunction(NaturalActedSpace,COM_FUN(8));
BindGlobal("BasisVectorsForMatrixAction",COM_FUN(9));
BindGlobal("DoSparseLinearActionOnFaithfulSubset",COM_FUN(10));
BindGlobal("NicomorphismOfGeneralMatrixGroup",COM_FUN(11));
InstallMethod(IsomorphismPermGroup,"matrix group",true,[IsMatrixGroup],10,COM_FUN(12));
InstallMethod(NiceMonomorphism,"use NicomorphismOfGeneralMatrixGroup",[IsMatrixGroup and IsFinite],COM_FUN(13));
InstallMethod(CanonicalNiceMonomorphism,[IsMatrixGroup and IsFinite],COM_FUN(14));
InstallGlobalFunction(ProjectiveActionHomomorphismMatrixGroup,COM_FUN(15));
InstallMethod(GeneratorsSmallest,"matrix group via niceo",[IsMatrixGroup and IsFinite],COM_FUN(16));
InstallOtherMethod(MinimalStabChain,"matrix group via niceo",[IsMatrixGroup and IsFinite],COM_FUN(17));
InstallOtherMethod(LargestElementGroup,"matrix group via niceo",[IsMatrixGroup and IsFinite],COM_FUN(18));
InstallMethod(CanonicalRightCosetElement,"finite matric group",IsCollsElms,[IsMatrixGroup and IsFinite,IsMatrix],COM_FUN(19));
InstallMethod(ViewObj,"for a matrix group with stored generators",[IsMatrixGroup and HasGeneratorsOfGroup],COM_FUN(20));
InstallMethod(ViewObj,"for a matrix group",[IsMatrixGroup],COM_FUN(21));
InstallMethod(PrintObj,"for a matrix group",[IsMatrixGroup],COM_FUN(22));
InstallMethod(IsGeneralLinearGroup,"try natural",[IsMatrixGroup],COM_FUN(23));
InstallMethod(IsSubgroupSL,"determinant test for generators",[IsMatrixGroup and HasGeneratorsOfGroup],COM_FUN(24));
InstallMethod(\in,"respecting bilinear form",IsElmsColls,[IsMatrix,IsFullSubgroupGLorSLRespectingBilinearForm],NICE_FLAGS,COM_FUN(25));
InstallMethod(\in,"respecting sesquilinear form",IsElmsColls,[IsMatrix,IsFullSubgroupGLorSLRespectingSesquilinearForm],NICE_FLAGS,COM_FUN(26));
InstallMethod(IsGeneratorsOfMagmaWithInverses,"for a list of matrices",[IsRingElementCollCollColl],COM_FUN(27));
InstallMethod(GroupWithGenerators,"list of matrices",[IsFFECollCollColl],COM_FUN(28));
InstallMethod(GroupWithGenerators,"list of matrices with identity",IsCollsElms,[IsFFECollCollColl,IsMultiplicativeElementWithInverse and IsFFECollColl],COM_FUN(29));
InstallMethod(IsConjugatorIsomorphism,"for a matrix group general mapping",[IsGroupGeneralMapping],1,COM_FUN(30));
InstallGlobalFunction(AffineActionByMatrixGroup,COM_FUN(31));
DeclareFilter("IsBlowUpIsomorphism",IsSPGeneralMapping and IsBijective);
InstallMethod(ImagesRepresentative,"for a blow up isomorphism, and a matrix in the source",FamSourceEqFamElm,[IsBlowUpIsomorphism,IsMatrix],COM_FUN(32));
InstallMethod(PreImagesRepresentative,"for a blow up isomorphism, and a matrix in the range",FamRangeEqFamElm,[IsBlowUpIsomorphism,IsMatrix],COM_FUN(33));
InstallGlobalFunction("BlowUpIsomorphism",COM_FUN(34));
InstallMethod(InvariantBilinearForm,"for a matrix group with known `InvariantQuadraticForm'",[IsMatrixGroup and HasInvariantQuadraticForm],COM_FUN(35));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grpmat.gi"

#F  file="lib/grpffmat.gi" crc=-70944848
RANK_FILTER_LIST  := [ 65760937, 34, 57928553, 19, 65749777, 242, 65749777, 
  242, 65749777, 242, 35281667, 246, 48026010, 248, 58412696, 30, 35281667, 
  246, 58412696, 30, 48026010, 248, 35281667, 246, 48026010, 248, 35281667, 
  246, 48026010, 248, 66048666, 243, 11684130, 245, 55621397, 241, 51837128, 
  243 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grpffmat.gi", -70944848 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grpffmat.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grpffmat.gi");
elif COM_RESULT = 3  then
Revision.grpffmat_gi:="@(#)$Id: grpffmat.gi,v 4.45.2.1 2005/11/28 14:46:46 gap Exp $";
InstallMethod(FieldOfMatrixGroup,true,[IsFFEMatrixGroup],0,COM_FUN(1));
InstallMethod(FieldOfMatrixList,"finite field matrices",true,[IsListOrCollection and IsFFECollCollColl],0,COM_FUN(2));
InstallMethod(IsNaturalGL,"size comparison",true,[IsFFEMatrixGroup and IsFinite],0,COM_FUN(3));
InstallMethod(IsNaturalSL,"size comparison",true,[IsFFEMatrixGroup and IsFinite],0,COM_FUN(4));
InstallGlobalFunction(NicomorphismOfFFEMatrixGroup,COM_FUN(5));
InstallMethod(NiceMonomorphism,"falling back on GL",true,[IsFFEMatrixGroup and IsFinite],0,COM_FUN(6));
InstallGlobalFunction(ProjectiveActionOnFullSpace,COM_FUN(7));
InstallMethod(Size,"general linear group",true,[IsFFEMatrixGroup and IsFinite and IsNaturalGL],0,COM_FUN(8));
InstallMethod(Size,"natural SL",true,[IsFFEMatrixGroup and IsNaturalSL and IsFinite],0,COM_FUN(9));
InstallMethod(\in,"general linear group",IsElmsColls,[IsMatrix,IsFFEMatrixGroup and IsFinite and IsNaturalGL],0,COM_FUN(10));
InstallMethod(\in,"special linear group",IsElmsColls,[IsMatrix,IsFFEMatrixGroup and IsFinite and IsNaturalSL],0,COM_FUN(11));
SizePolynomialUnipotentClassGL:=COM_FUN(12);
InstallGlobalFunction(ConjugacyClassesOfNaturalGroup,COM_FUN(13));
InstallMethod(ConjugacyClasses,"for natural gl",true,[IsFFEMatrixGroup and IsFinite and IsNaturalGL],0,COM_FUN(14));
InstallMethod(ConjugacyClasses,"for natural sl",true,[IsFFEMatrixGroup and IsFinite and IsNaturalSL],0,COM_FUN(15));
InstallMethod(Random,"for natural GL",true,[IsFFEMatrixGroup and IsFinite and IsNaturalGL],0,COM_FUN(16));
InstallMethod(Random,"for natural SL",true,[IsFFEMatrixGroup and IsFinite and IsNaturalSL],0,COM_FUN(17));
InstallGlobalFunction(Phi2,COM_FUN(18));
InstallGlobalFunction(NrConjugacyClassesGL,COM_FUN(19));
InstallGlobalFunction(NrConjugacyClassesSLIsogeneous,COM_FUN(20));
InstallGlobalFunction(NrConjugacyClassesSL,COM_FUN(21));
InstallGlobalFunction(NrConjugacyClassesPGL,COM_FUN(22));
InstallGlobalFunction(NrConjugacyClassesPSL,COM_FUN(23));
InstallGlobalFunction(NrConjugacyClassesGU,COM_FUN(24));
InstallGlobalFunction(NrConjugacyClassesSUIsogeneous,COM_FUN(25));
InstallGlobalFunction(NrConjugacyClassesSU,COM_FUN(26));
InstallGlobalFunction(NrConjugacyClassesPGU,COM_FUN(27));
InstallGlobalFunction(NrConjugacyClassesPSU,COM_FUN(28));
InstallMethod(NrConjugacyClasses,"for natural GL",true,[IsGroup and IsFinite and IsNaturalGL],0,COM_FUN(29));
InstallMethod(NrConjugacyClasses,"for natural SL",true,[IsGroup and IsFinite and IsNaturalSL],0,COM_FUN(30));
InstallMethod(NrConjugacyClasses,"for GU(n,q)",true,[IsGroup and IsFinite and IsFullSubgroupGLorSLRespectingSesquilinearForm],0,COM_FUN(31));
InstallMethod(NrConjugacyClasses,"for natural SU",true,[IsGroup and IsFinite and IsFullSubgroupGLorSLRespectingSesquilinearForm and IsSubgroupSL],0,COM_FUN(32));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grpffmat.gi"

#F  file="lib/grpramat.gi" crc=40188293
RANK_FILTER_LIST  := [ 49282538, 34, 49282538, 34, 11895617, 31, 11895617, 
  31, 32871158, 42, 49282538, 34, 32871158, 42, 49282538, 34, 49282538, 34, 
  49282538, 34, 49282538, 34, 19227359, 38, 49282538, 34, 49282538, 34, 
  49282538, 34, 49282538, 34, 58412696, 30, 49282538, 34, 49282538, 34, 
  49282538, 34, 49282538, 34, 49282538, 34, 49282538, 34, 49282538, 34, 
  49282538, 34, 49282538, 34, 49282538, 34, 49282538, 34, 49282538, 34, 1, 0, 
  49282538, 34, 1, 0, 49282538, 34, 7665940, 19, 49282538, 34, 49282538, 34, 
  49282538, 34 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grpramat.gi", 40188293 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grpramat.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grpramat.gi");
elif COM_RESULT = 3  then
Revision.grpramat_gi:="@(#)$Id: grpramat.gi,v 4.25 2003/07/31 17:17:17 gap Exp $";
InstallMethod(IsRationalMatrixGroup,[IsCyclotomicMatrixGroup],COM_FUN(1));
InstallTrueMethod(IsRationalMatrixGroup,IsIntegerMatrixGroup);
InstallMethod(IsIntegerMatrixGroup,[IsCyclotomicMatrixGroup],COM_FUN(2));
InstallMethod(GeneralLinearGroupCons,"some generators for GL_n(Z)",[IsMatrixGroup,IsPosInt,IsIntegers],COM_FUN(3));
InstallMethod(SpecialLinearGroupCons,"some generators for SL_n(Z)",[IsMatrixGroup,IsPosInt,IsIntegers],COM_FUN(4));
InstallMethod(NormalizerOp,IsIdenticalObj,[IsNaturalGLnZ,IsCyclotomicMatrixGroup],COM_FUN(5));
InstallMethod(CentralizerOp,IsIdenticalObj,[IsNaturalGLnZ,IsCyclotomicMatrixGroup],COM_FUN(6));
InstallValue(CrystGroupDefaultAction,RightAction);
InstallGlobalFunction(SetCrystGroupDefaultAction,COM_FUN(7));
InstallMethod(IsBravaisGroup,[IsCyclotomicMatrixGroup],COM_FUN(8));
InstallMethod(InvariantLattice,"for rational matrix groups",[IsCyclotomicMatrixGroup],COM_FUN(9));
InstallMethod(IsFinite,"cyclotomic matrix group",[IsCyclotomicMatrixGroup],COM_FUN(10));
InstallMethod(IsFinite,"via Minkowski kernel (short but not too efficient)",[IsIntegerMatrixGroup],COM_FUN(11));
InstallMethod(Size,"cyclotomic matrix group not known to be finite",[IsCyclotomicMatrixGroup],COM_FUN(12));
InstallMethod(NiceMonomorphism,"for a (nonrational) cyclotomic matrix group",[IsCyclotomicMatrixGroup],COM_FUN(13));
InstallMethod(IsHandledByNiceMonomorphism,"for a cyclotomic matrix group",[IsCyclotomicMatrixGroup],IsFinite);
InstallMethod(IsomorphismPermGroup,"cyclotomic matrix group",[IsCyclotomicMatrixGroup],10,COM_FUN(14));
RedispatchOnCondition(\in,true,[IsMatrix,IsCyclotomicMatrixGroup],[IsObject,IsFinite],0);
RedispatchOnCondition(\=,IsIdenticalObj,[IsCyclotomicMatrixGroup,IsCyclotomicMatrixGroup],[IsFinite,IsFinite],0);
RedispatchOnCondition(IndexOp,IsIdenticalObj,[IsCyclotomicMatrixGroup,IsCyclotomicMatrixGroup],[IsFinite,IsFinite],0);
RedispatchOnCondition(IndexNC,IsIdenticalObj,[IsCyclotomicMatrixGroup,IsCyclotomicMatrixGroup],[IsFinite,IsFinite],0);
RedispatchOnCondition(NormalizerOp,IsIdenticalObj,[IsCyclotomicMatrixGroup,IsCyclotomicMatrixGroup],[IsFinite,IsFinite],0);
RedispatchOnCondition(NormalClosureOp,IsIdenticalObj,[IsCyclotomicMatrixGroup,IsCyclotomicMatrixGroup],[IsFinite,IsFinite],0);
RedispatchOnCondition(CentralizerOp,true,[IsCyclotomicMatrixGroup,IsObject],[IsFinite],0);
RedispatchOnCondition(ClosureGroup,true,[IsCyclotomicMatrixGroup,IsObject],[IsFinite],0);
RedispatchOnCondition(SylowSubgroupOp,true,[IsCyclotomicMatrixGroup,IsPosInt],[IsFinite],0);
RedispatchOnCondition(ConjugacyClasses,true,[IsCyclotomicMatrixGroup],[IsFinite],0);
RedispatchOnCondition(IsomorphismPcGroup,true,[IsCyclotomicMatrixGroup],[IsFinite],0);
RedispatchOnCondition(CompositionSeries,true,[IsCyclotomicMatrixGroup],[IsFinite],0);
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grpramat.gi"

#F  file="lib/grpfp.gi" crc=-18201413
RANK_FILTER_LIST  := [ 45350223, 2, 46335269, 7, 45907804, 9, 45907804, 9, 
  45907804, 9, 45907804, 9, 45907804, 9, 45907804, 9, 45907804, 9, 44891996, 
  7, 45350223, 2, 44891996, 7, 44891996, 7, 44891996, 7, 44891996, 7, 
  44891996, 7, 44891996, 7, 44891996, 7, 44891996, 7, 45350223, 2, 45350223, 
  2, 45350223, 2, 45350223, 2, 45350223, 2, 44891996, 7, 1015809, 2, 
  22683304, 16, 8193, 2, 44891996, 7, 55999958, 23, 65767820, 5, 55999958, 
  23, 65767820, 5, 5668610, 24, 55999958, 23, 55999958, 23, 55999958, 23, 
  47532041, 24, 5668610, 24, 5668610, 24, 55999958, 23, 55999958, 23, 
  55986039, 26, 55999958, 23, 55986039, 26, 5668610, 24, 55999958, 23, 
  37419647, 24, 37419647, 24, 55999958, 23, 55999958, 23, 37419647, 24, 
  55999958, 23, 37419647, 24, 55999958, 23, 37419647, 24, 55999958, 23, 
  55999958, 23, 55999958, 23, 48833407, 24, 56556179, 24, 16776572, 24, 
  55999958, 23, 37419647, 24, 62465420, 30, 8126465, 2, 62465420, 30, 
  41942876, 3, 37419647, 24, 55999958, 23, 37419647, 24, 55999958, 23, 
  55999958, 23, 55986039, 26, 55999958, 23, 60351779, 22, 60351779, 22, 
  29405138, 23, 60351779, 22, 29405138, 23, 16835500, 22, 55999958, 23, 
  5668610, 24, 55986039, 26, 43417361, 25, 65767820, 5, 5668610, 24, 
  65767820, 5, 55999958, 23, 16776572, 24, 55999958, 23, 55999958, 23, 
  55999958, 23, 5668610, 24, 55999958, 23, 55999958, 23, 5668610, 24, 
  5668610, 24, 66021626, 25, 65767820, 5, 36661498, 26, 65767820, 5, 
  49244095, 24, 55999958, 23, 55999958, 23, 8193, 2, 37419647, 24, 55990720, 
  30, 37419647, 24, 29419057, 21, 29419057, 21, 62973024, 33, 67108760, 5, 
  22800173, 38, 67108760, 5, 60875122, 35, 67108760, 5, 62973024, 33, 
  67108760, 5, 62973024, 33, 8193, 2, 67108760, 5, 29419057, 21, 8193, 2, 
  67108760, 5, 62973024, 33, 8193, 2, 67108760, 5, 62973024, 33, 8193, 2, 
  55999958, 23, 7665940, 19, 55986039, 26, 55999958, 23, 7665940, 19, 
  55999958, 23, 55999958, 23, 7665940, 19, 55986039, 26, 7665940, 19, 8193, 
  2, 55986039, 26, 55999958, 23, 7665940, 19, 8193, 2, 55986039, 26, 
  55999958, 23, 7665940, 19, 55986039, 26, 55999958, 23, 7665940, 19, 8193, 
  2, 55999958, 23, 7665940, 19, 55986039, 26, 7665940, 19, 8193, 2, 55999958, 
  23, 55999958, 23, 7665940, 19, 55999958, 23, 55999958, 23, 5668610, 24, 
  5668610, 24, 55986039, 26, 5668610, 24, 37419647, 24, 37419647, 24, 
  37419647, 24, 55999958, 23, 66950260, 24, 29407897, 26, 66838703, 24, 
  45350223, 2, 18300897, 30, 37419647, 24, 55999958, 23, 55999958, 23, 
  55999958, 23, 55999958, 23, 5668610, 24, 55999958, 23, 55999958, 23, 
  55999958, 23, 55986039, 26, 29407897, 26, 55999958, 23, 29407897, 26, 
  37419647, 24, 37419647, 24, 55999958, 23, 37419647, 24, 37419647, 24, 
  55986039, 26, 55999958, 23, 55999958, 23, 55986039, 26, 55999958, 23, 
  55999958, 23, 55986039, 26, 55999958, 23, 55999958, 23, 55999958, 23, 
  55999958, 23, 53456147, 10, 7665940, 19, 53456147, 10, 65767820, 5, 8193, 
  2, 37419647, 24 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/grpfp.gi", -18201413 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/grpfp.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/grpfp.gi");
elif COM_RESULT = 3  then
Revision.grpfp_gi:="@(#)$Id: grpfp.gi,v 4.203.2.13 2006/10/04 16:03:08 gap Exp $";
InstallMethod(ElementOfFpGroup,"for a family of f.p. group elements, and an assoc. word",true,[IsElementOfFpGroupFamily,IsAssocWordWithInverse],0,COM_FUN(1));
InstallMethod(PrintObj,"for an element of an f.p. group (default repres.)",true,[IsElementOfFpGroup and IsPackedElementDefaultRep],0,COM_FUN(2));
InstallMethod(ViewObj,"for an element of an f.p. group (default repres.)",true,[IsElementOfFpGroup and IsPackedElementDefaultRep],0,COM_FUN(3));
InstallMethod(String,"for an element of an f.p. group (default repres.)",true,[IsElementOfFpGroup and IsPackedElementDefaultRep],0,COM_FUN(4));
InstallMethod(LaTeXObj,"for an element of an f.p. group (default repres.)",true,[IsElementOfFpGroup and IsPackedElementDefaultRep],0,COM_FUN(5));
InstallMethod(UnderlyingElement,"for an element of an f.p. group (default repres.)",true,[IsElementOfFpGroup and IsPackedElementDefaultRep],0,COM_FUN(6));
InstallMethod(ExtRepOfObj,"for an element of an f.p. group (default repres.)",true,[IsElementOfFpGroup and IsPackedElementDefaultRep],0,COM_FUN(7));
InstallOtherMethod(Length,"for an element of an f.p. group (default repres.)",true,[IsElementOfFpGroup and IsPackedElementDefaultRep],0,COM_FUN(8));
InstallMethod(InverseOp,"for an element of an f.p. group",true,[IsElementOfFpGroup],0,COM_FUN(9));
InstallOtherMethod(One,"for a family of f.p. group elements",true,[IsElementOfFpGroupFamily],0,COM_FUN(10));
InstallMethod(One,"for an f.p. group element",true,[IsElementOfFpGroup],0,COM_FUN(11));
InstallMethod(OneOp,"for an f.p. group element",true,[IsElementOfFpGroup],0,COM_FUN(12));
InstallGlobalFunction(SetReducedMultiplication,COM_FUN(13));
BindGlobal("Gpword2MSword",COM_FUN(14));
BindGlobal("MSword2gpword",COM_FUN(15));
InstallMethod(\*,"for two f.p. group elements",IsIdenticalObj,[IsElementOfFpGroup,IsElementOfFpGroup],0,COM_FUN(16));
InstallMethod(\=,"for two f.p. group elements",IsIdenticalObj,[IsElementOfFpGroup,IsElementOfFpGroup],0,COM_FUN(17));
InstallMethod(\<,"for two f.p. group elements",IsIdenticalObj,[IsElementOfFpGroup,IsElementOfFpGroup],0,COM_FUN(18));
BindGlobal("FPFaithHom",COM_FUN(19));
InstallMethod(FpElmEqualityMethod,"via faithful rep.",true,[IsElementOfFpGroupFamily],1,COM_FUN(20));
InstallMethod(FpElmComparisonMethod,"via perm rep.",true,[IsElementOfFpGroupFamily],1,COM_FUN(21));
InstallMethod(FpElmKBRWS,"via Knuth-Bendix",true,[IsElementOfFpGroupFamily],0,COM_FUN(22));
InstallMethod(FpElmEqualityMethod,"via Knuth-Bendix",true,[IsElementOfFpGroupFamily],0,COM_FUN(23));
InstallMethod(FpElmComparisonMethod,"via Knuth-Bendix",true,[IsElementOfFpGroupFamily],0,COM_FUN(24));
InstallMethod(Order,"fp group element",[IsElementOfFpGroup],0,COM_FUN(25));
InstallOtherMethod(MappedWord,"for fp group element",IsElmsCollsX,[IsPackedElementDefaultRep,IsElementOfFpGroupCollection and IsList,IsList],0,COM_FUN(26));
InstallMethod(FpGrpMonSmgOfFpGrpMonSmgElement,"for an element of an fp group",true,[IsElementOfFpGroup],0,COM_FUN(27));
InstallGlobalFunction(IndexCosetTab,COM_FUN(28));
InstallMethod(PseudoRandom,"subgroups fp group: force generators",true,[IsSubgroupFpGroup],0,COM_FUN(29));
InstallGlobalFunction(SubgroupOfWholeGroupByCosetTable,COM_FUN(30));
InstallGlobalFunction(SubgroupOfWholeGroupByQuotientSubgroup,COM_FUN(31));
MakeNiceDirectQuots:=COM_FUN(32);
InstallGlobalFunction(TracedCosetFpGroup,COM_FUN(33));
InstallMethod(\in,"subgroup of fp group",IsElmsColls,[IsMultiplicativeElementWithInverse,IsSubgroupFpGroup],0,COM_FUN(34));
InstallMethod(\in,"subgroup of fp group by quotient rep",IsElmsColls,[IsMultiplicativeElementWithInverse,IsSubgroupFpGroup and IsSubgroupOfWholeGroupByQuotientRep],0,COM_FUN(35));
InstallMethod(\=,"subgroups of fp group",IsIdenticalObj,[IsSubgroupFpGroup,IsSubgroupFpGroup],0,COM_FUN(36));
InstallMethod(IsSubset,"subgroups of fp group: test generators",IsIdenticalObj,[IsSubgroupFpGroup,IsSubgroupFpGroup and HasGeneratorsOfGroup],0,COM_FUN(37));
InstallMethod(IsSubset,"subgroups of fp group by quot. rep",IsIdenticalObj,[IsSubgroupFpGroup and IsSubgroupOfWholeGroupByQuotientRep,IsSubgroupFpGroup and IsSubgroupOfWholeGroupByQuotientRep],0,COM_FUN(38));
InstallMethod(IsSubset,"subgp fp group: via quotient rep",IsIdenticalObj,[IsSubgroupFpGroup,IsSubgroupFpGroup],0,COM_FUN(39));
InstallMethod(CanComputeIsSubset,"whole fp family group",IsIdenticalObj,[IsSubgroupFpGroup and IsWholeFamily,IsSubgroupFpGroup],0,COM_FUN(40));
InstallMethod(IsNormalOp,"subgroups of fp group by quot. rep in full fp grp.",IsIdenticalObj,[IsSubgroupFpGroup and IsWholeFamily,IsSubgroupFpGroup and IsSubgroupOfWholeGroupByQuotientRep],0,COM_FUN(41));
InstallMethod(IsFinitelyGeneratedGroup,"subgroups of fp group",true,[IsSubgroupFpGroup],0,COM_FUN(42));
InstallMethod(GeneratorsOfGroup,"for whole family f.p. group",true,[IsSubgroupFpGroup and IsGroupOfFamily],0,COM_FUN(43));
InstallMethod(AbelianInvariants,"for a finitely presented group",true,[IsSubgroupFpGroup and IsGroupOfFamily],0,COM_FUN(44));
InstallMethod(AbelianInvariants,"for a subgroup of a finitely presented group",true,[IsSubgroupFpGroup],0,COM_FUN(45));
InstallMethod(IsPerfectGroup,"for a (subgroup of a) finitely presented group",true,[IsSubgroupFpGroup],0,COM_FUN(46));
InstallMethod(DerivedSubgroup,"for a finitely presented group",true,[IsSubgroupFpGroup and IsGroupOfFamily],0,COM_FUN(47));
InstallMethod(DerivedSubgroup,"subgroup of a finitely presented group",true,[IsSubgroupFpGroup],0,COM_FUN(48));
InstallMethod(CosetTable,"for finitely presented groups",true,[IsSubgroupFpGroup and IsGroupOfFamily,IsSubgroupFpGroup],0,COM_FUN(49));
InstallMethod(CosetTableNormalClosure,"for finitely presented groups",true,[IsSubgroupFpGroup and IsGroupOfFamily,IsSubgroupFpGroup],0,COM_FUN(50));
InstallGlobalFunction(CosetTableFromGensAndRels,COM_FUN(51));
BindGlobal("GTC_CosetTableFromGensAndRels",COM_FUN(52));
GAPTCENUM.CosetTableFromGensAndRels:=GTC_CosetTableFromGensAndRels;
InstallMethod(TryCosetTableInWholeGroup,"for finitely presented groups",true,[IsSubgroupFpGroup],0,COM_FUN(53));
InstallMethod(CosetTableInWholeGroup,"for finitely presented groups",true,[IsSubgroupFpGroup],0,COM_FUN(54));
InstallMethod(CosetTableInWholeGroup,"from augmented table Rrs",true,[IsSubgroupFpGroup and HasAugmentedCosetTableRrsInWholeGroup],0,COM_FUN(55));
InstallMethod(CosetTableInWholeGroup,"from augmented table Mtc",true,[IsSubgroupFpGroup and HasAugmentedCosetTableMtcInWholeGroup],0,COM_FUN(56));
InstallMethod(CosetTableInWholeGroup,"ByQuoSubRep",true,[IsSubgroupOfWholeGroupByQuotientRep],0,COM_FUN(57));
InstallMethod(CosetTableNormalClosureInWholeGroup,"for finitely presented groups",true,[IsSubgroupFpGroup],0,COM_FUN(58));
InstallGlobalFunction(StandardizeTable,COM_FUN(59));
InstallGlobalFunction(StandardizeTable2,COM_FUN(60));
InstallMethod(Display,"for finitely presented groups",true,[IsSubgroupFpGroup and IsGroupOfFamily],0,COM_FUN(61));
InstallGlobalFunction(FactorGroupFpGroupByRels,COM_FUN(62));
BindGlobal("FactorFreeGroupByRelators",COM_FUN(63));
InstallOtherMethod(\/,"for free groups and relators",IsIdenticalObj,[IsFreeGroup,IsCollection],0,FactorFreeGroupByRelators);
InstallOtherMethod(\/,"for a free group and an empty list of relators",true,[IsFreeGroup,IsEmpty],0,FactorFreeGroupByRelators);
InstallMethod(FreeGeneratorsOfFpGroup,"for a finitely presented group",true,[IsSubgroupFpGroup and IsGroupOfFamily],0,COM_FUN(64));
InstallMethod(FreeGeneratorsOfWholeGroup,"for a finitely presented group",true,[IsSubgroupFpGroup],0,COM_FUN(65));
InstallMethod(FreeGroupOfFpGroup,"for a finitely presented group",true,[IsSubgroupFpGroup and IsGroupOfFamily],0,COM_FUN(66));
InstallMethod(IndexNC,"for finitely presented groups",[IsSubgroupFpGroup,IsSubgroupFpGroup],COM_FUN(67));
InstallMethod(IndexOp,"for finitely presented group in whole group",IsIdenticalObj,[IsSubgroupFpGroup and IsWholeFamily,IsSubgroupFpGroup],COM_FUN(68));
InstallMethod(CanComputeIndex,"subgroups fp groups",IsIdenticalObj,[IsGroup and HasIndexInWholeGroup,IsGroup and HasIndexInWholeGroup],ReturnTrue);
InstallMethod(CanComputeIndex,"subgroup of full fp groups",IsIdenticalObj,[IsGroup and IsWholeFamily,IsGroup and HasIndexInWholeGroup],ReturnTrue);
InstallMethod(CanComputeIndex,"subgroup of full fp groups",IsIdenticalObj,[IsGroup and IsWholeFamily,IsGroup and HasCosetTableInWholeGroup],ReturnTrue);
InstallMethod(IndexInWholeGroup,"for subgroups of fp groups",[IsSubgroupFpGroup],COM_FUN(69));
InstallMethod(IndexInWholeGroup,"subgroup fp by quotient",true,[IsSubgroupFpGroup and IsSubgroupOfWholeGroupByQuotientRep],0,COM_FUN(70));
InstallMethod(IndexInWholeGroup,"for full fp group",[IsSubgroupFpGroup and IsWholeFamily],COM_FUN(71));
InstallMethod(ConjugateGroup,"subgroups of fp group with coset table",IsCollsElms,[IsSubgroupFpGroup and HasCosetTableInWholeGroup,IsMultiplicativeElementWithInverse],0,COM_FUN(72));
InstallMethod(ConjugateGroup,"subgroups of fp group by quotient",IsCollsElms,[IsSubgroupFpGroup and IsSubgroupOfWholeGroupByQuotientRep,IsMultiplicativeElementWithInverse],0,COM_FUN(73));
InstallMethod(AsSubgroupOfWholeGroupByQuotient,"create",true,[IsSubgroupFpGroup],0,COM_FUN(74));
InstallMethod(AsSubgroupOfWholeGroupByQuotient,"is already",true,[IsSubgroupOfWholeGroupByQuotientRep],0,COM_FUN(75));
InstallGlobalFunction(DefiningQuotientHomomorphism,COM_FUN(76));
InstallMethod(CoreOp,"subgroups of fp group: use quotient rep",IsIdenticalObj,[IsSubgroupFpGroup,IsSubgroupFpGroup],0,COM_FUN(77));
InstallMethod(CoreOp,"subgroups of fp group by quotient",IsIdenticalObj,[IsSubgroupFpGroup,IsSubgroupFpGroup and IsSubgroupOfWholeGroupByQuotientRep],0,COM_FUN(78));
InstallMethod(Intersection2,"subgroups of fp group",IsIdenticalObj,[IsSubgroupFpGroup,IsSubgroupFpGroup],0,COM_FUN(79));
InstallMethod(Intersection2,"subgroups of fp group by quotient",IsIdenticalObj,[IsSubgroupFpGroup and IsSubgroupOfWholeGroupByQuotientRep,IsSubgroupFpGroup and IsSubgroupOfWholeGroupByQuotientRep],0,COM_FUN(80));
InstallMethod(ClosureGroup,"subgrp fp: by quotient subgroup",IsCollsElms,[IsSubgroupFpGroup and HasParent and IsSubgroupOfWholeGroupByQuotientRep,IsMultiplicativeElementWithInverse],0,COM_FUN(81));
InstallMethod(ClosureGroup,"subgrp fp: Has coset table",IsCollsElms,[IsSubgroupFpGroup and HasParent and HasCosetTableInWholeGroup,IsMultiplicativeElementWithInverse],0,COM_FUN(82));
InstallMethod(ClosureGroup,"for subgroup of fp group, and subgroup",IsIdenticalObj,[IsSubgroupFpGroup and HasParent,IsSubgroupFpGroup],0,COM_FUN(83));
InstallMethod(KnowsHowToDecompose,"fp groups: Say yes if finite index",IsIdenticalObj,[IsSubgroupFpGroup,IsList],0,COM_FUN(84));
InstallMethod(IsAbelian,"for finitely presented groups",true,[IsSubgroupFpGroup and IsGroupOfFamily],0,COM_FUN(85));
InstallMethod(IsAbelian,"finite fp grp",true,[IsSubgroupFpGroup and HasSize and IsFinite],0,COM_FUN(86));
InstallMethod(IsTrivial,"for finitely presented groups",true,[IsSubgroupFpGroup and IsGroupOfFamily],0,COM_FUN(87));
InstallOtherMethod(IsomorphismFpGroup,"supply name",true,[IsGroup],0,COM_FUN(88));
InstallGlobalFunction(IsomorphismFpGroupByGenerators,COM_FUN(89));
InstallOtherMethod(IsomorphismFpGroupByCompositionSeries,"supply name",true,[IsGroup],0,COM_FUN(90));
InstallOtherMethod(IsomorphismFpGroup,"for perm groups",true,[IsPermGroup,IsString],0,COM_FUN(91));
InstallOtherMethod(IsomorphismFpGroup,"for simple solvable permutation groups",true,[IsPermGroup and IsSimpleGroup and IsSolvableGroup,IsString],0,COM_FUN(92));
InstallOtherMethod(IsomorphismFpGroup,"for simple permutation groups",true,[IsPermGroup and IsSimpleGroup,IsString],0,COM_FUN(93));
InstallOtherMethod(IsomorphismFpGroupByCompositionSeries,"for permutation groups",true,[IsPermGroup,IsString],0,COM_FUN(94));
InstallOtherMethod(IsomorphismFpGroupByGeneratorsNC,"for perm groups",IsFamFamX,[IsPermGroup,IsList,IsString],0,COM_FUN(95));
InstallMethod(IsomorphismFpGroupByGeneratorsNC,"via cokernel",IsFamFamX,[IsGroup,IsList,IsString],0,COM_FUN(96));
InstallMethod(IsomorphismFpGroupBySubnormalSeries,"for groups",true,[IsPermGroup,IsList,IsString],0,COM_FUN(97));
InstallOtherMethod(IsomorphismFpGroupBySubnormalSeries,"for groups",true,[IsPermGroup,IsList],0,COM_FUN(98));
BindGlobal("NextIterator_LowIndexSubgroupsFpGroup",COM_FUN(99));
BindGlobal("IsDoneIterator_LowIndexSubgroupsFpGroup",COM_FUN(100));
BindGlobal("ShallowCopy_LowIndexSubgroupsFpGroup",COM_FUN(101));
BindGlobal("DoLowIndexSubgroupsFpGroupIterator",COM_FUN(102));
InstallMethod(LowIndexSubgroupsFpGroupIterator,"supply trivial subgroup",[IsSubgroupFpGroup,IsPosInt],COM_FUN(103));
InstallMethod(LowIndexSubgroupsFpGroupIterator,"full f.p. group, subgroup of it",IsFamFamX,[IsSubgroupFpGroup and IsWholeFamily,IsSubgroupFpGroup,IsPosInt],DoLowIndexSubgroupsFpGroupIterator);
InstallMethod(LowIndexSubgroupsFpGroupIterator,"subgroups of f.p. group",IsFamFamX,[IsSubgroupFpGroup,IsSubgroupFpGroup,IsPosInt],COM_FUN(104));
InstallMethod(LowIndexSubgroupsFpGroupIterator,"supply trivial subgroup, with exclusion list",[IsSubgroupFpGroup and IsWholeFamily,IsPosInt,IsList],COM_FUN(105));
InstallMethod(LowIndexSubgroupsFpGroupIterator,"full f.p. group, subgroup of it, with exclusion list",IsFamFamXY,[IsSubgroupFpGroup and IsWholeFamily,IsSubgroupFpGroup,IsPosInt,IsList],DoLowIndexSubgroupsFpGroupIterator);
BindGlobal("DoLowIndexSubgroupsFpGroupViaIterator",COM_FUN(106));
InstallMethod(LowIndexSubgroupsFpGroup,"subgroups of full fp group",IsFamFamX,[IsSubgroupFpGroup and IsWholeFamily,IsSubgroupFpGroup,IsPosInt],0,DoLowIndexSubgroupsFpGroupViaIterator);
InstallOtherMethod(LowIndexSubgroupsFpGroup,"subgroups of full fp group, with exclusion list",IsFamFamXY,[IsSubgroupFpGroup and IsWholeFamily,IsSubgroupFpGroup,IsPosInt,IsList],0,DoLowIndexSubgroupsFpGroupViaIterator);
InstallOtherMethod(LowIndexSubgroupsFpGroup,"supply trivial subgroup",true,[IsSubgroupFpGroup,IsPosInt],0,COM_FUN(107));
InstallOtherMethod(LowIndexSubgroupsFpGroup,"with exclusion list, supply trivial subgroup",[IsSubgroupFpGroup and IsWholeFamily,IsPosInt,IsList],COM_FUN(108));
InstallMethod(LowIndexSubgroupsFpGroup,"subgroups of fp group",IsFamFamX,[IsSubgroupFpGroup,IsSubgroupFpGroup,IsPosInt],0,COM_FUN(109));
BindGlobal("DoLowIndexSubgroupsFpGroup_Old",COM_FUN(110));
InstallMethod(NormalizerOp,"subgroups of fp group: find stabilizing cosets",IsIdenticalObj,[IsSubgroupFpGroup,IsSubgroupFpGroup],0,COM_FUN(111));
InstallMethod(NormalizerOp,"subgroups of fp group by quot. rep",IsIdenticalObj,[IsSubgroupFpGroup and IsSubgroupOfWholeGroupByQuotientRep,IsSubgroupFpGroup and IsSubgroupOfWholeGroupByQuotientRep],0,COM_FUN(112));
InstallMethod(NormalizerOp,"in whole group by quot. rep",IsIdenticalObj,[IsSubgroupFpGroup and IsWholeFamily,IsSubgroupFpGroup and IsSubgroupOfWholeGroupByQuotientRep],0,COM_FUN(113));
InstallGlobalFunction(MostFrequentGeneratorFpGroup,COM_FUN(114));
InstallGlobalFunction(RelatorRepresentatives,COM_FUN(115));
InstallMethod(RelatorsOfFpGroup,"for finitely presented group",true,[IsSubgroupFpGroup and IsGroupOfFamily],0,COM_FUN(116));
InstallMethod(IndicesInvolutaryGenerators,"for finitely presented group",true,[IsSubgroupFpGroup and IsGroupOfFamily],0,COM_FUN(117));
InstallGlobalFunction(RelsSortedByStartGen,COM_FUN(118));
BindGlobal("FinIndexCyclicSubgroupGenerator",COM_FUN(119));
InstallMethod(Size,"for finitely presented groups",true,[IsSubgroupFpGroup and IsGroupOfFamily],0,COM_FUN(120));
InstallMethod(Size,"subgroups of finitely presented groups",true,[IsSubgroupFpGroup],0,COM_FUN(121));
InstallMethod(Size,"infinite abelianization",true,[IsSubgroupFpGroup and HasAbelianInvariants],0,COM_FUN(122));
InstallGlobalFunction(IsomorphismPermGroupOrFailFpGroup,COM_FUN(123));
InstallMethod(IsomorphismPermGroup,"for full finitely presented groups",true,[IsGroup and IsSubgroupFpGroup and IsGroupOfFamily],RankFilter(IsFinite and IsGroup),COM_FUN(124));
InstallOtherMethod(IsomorphismPermGroup,"for family of fp words",true,[IsElementOfFpGroupFamily],0,COM_FUN(125));
InstallMethod(IsomorphismPcGroup,"for finitely presented groups that know their size",true,[IsGroup and IsSubgroupFpGroup and IsFinite and HasSize],0,COM_FUN(126));
InstallMethod(FactorCosetAction,"for full fp group on subgroup",IsIdenticalObj,[IsSubgroupFpGroup and IsGroupOfFamily,IsSubgroupFpGroup],5,COM_FUN(127));
InstallMethod(FactorCosetAction,"for subgroups of an fp group",IsIdenticalObj,[IsSubgroupFpGroup,IsSubgroupFpGroup],0,COM_FUN(128));
InstallMethod(FactorCosetAction,"subgrp in quotient Rep",IsIdenticalObj,[IsSubgroupFpGroup,IsSubgroupFpGroup and IsSubgroupOfWholeGroupByQuotientRep],0,COM_FUN(129));
InstallGlobalFunction(SubgroupGeneratorsCosetTable,COM_FUN(130));
InstallMethod(GeneratorsOfGroup,"subgroup fp, via augmented coset table",true,[IsSubgroupFpGroup],0,COM_FUN(131));
InstallMethod(IntermediateSubgroups,"fp group via quotient subgroups",IsIdenticalObj,[IsSubgroupFpGroup,IsSubgroupFpGroup],0,COM_FUN(132));
InstallMethod(GQuotients,"whole fp group to finite group",true,[IsSubgroupFpGroup and IsWholeFamily,IsGroup and IsFinite],1,COM_FUN(133));
InstallMethod(GQuotients,"subgroup of an fp group",true,[IsSubgroupFpGroup,IsGroup and IsFinite],1,COM_FUN(134));
InstallMethod(IsomorphismFpSemigroup,"for fp groups",true,[IsFpGroup],0,COM_FUN(135));
InstallMethod(IsomorphismFpMonoid,"for an fp group",true,[IsFpGroup],0,COM_FUN(136));
InstallMethod(ViewObj,"fp group",true,[IsSubgroupFpGroup],10,COM_FUN(137));
InstallMethod(StoredExcludedOrders,"fp group",true,[IsSubgroupFpGroup and IsGroupOfFamily],0,COM_FUN(138));
InstallGlobalFunction(ExcludedOrders,COM_FUN(139));
RedispatchOnCondition(CompositionSeries,true,[IsFpGroup],[IsFinite],0);
InstallMethod(NormalClosureOp,"whole fp group with normal subgroup",IsIdenticalObj,[IsSubgroupFpGroup and IsWholeFamily,IsSubgroupFpGroup],0,COM_FUN(140));
InstallMethod(LowerCentralSeriesOfGroup,"fp group",true,[IsSubgroupFpGroup],0,COM_FUN(141));
CoSuFp:=COM_FUN(142);
InstallMethod(CommutatorSubgroup,"whole fp group with normal subgroup",IsIdenticalObj,[IsSubgroupFpGroup and IsWholeFamily,IsSubgroupFpGroup],0,CoSuFp);
InstallMethod(CommutatorSubgroup,"normal subgroup with whole fp group",IsIdenticalObj,[IsSubgroupFpGroup,IsSubgroupFpGroup and IsWholeFamily],0,COM_FUN(143));
InstallMethod(CommutatorSubgroup,"normal subgroup with whole fp group",IsIdenticalObj,[IsSubgroupFpGroup,IsSubgroupFpGroup],0,COM_FUN(144));
DeclareRepresentation("IsRightTransversalFpGroupRep",IsRightTransversalRep,["group","subgroup","table","iso","reps"]);
InstallMethod(RightTransversalOp,"via coset table",IsIdenticalObj,[IsSubgroupFpGroup,IsSubgroupFpGroup],0,COM_FUN(145));
InstallMethod(\[\],"right transversal fp group",true,[IsList and IsRightTransversalFpGroupRep,IsPosInt],0,COM_FUN(146));
InstallMethod(PositionCanonical,"right transversal fp gp.",IsCollsElms,[IsList and IsRightTransversalFpGroupRep,IsMultiplicativeElementWithInverse],0,COM_FUN(147));
InstallGlobalFunction(NewmanInfinityCriterion,COM_FUN(148));
InstallGlobalFunction(FibonacciGroup,COM_FUN(149));
InstallMethod(DirectProductOp,"for a list of fp groups, and a fp group",true,[IsList,IsFpGroup],0,COM_FUN(150));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/grpfp.gi"

#F  file="lib/sgpres.gi" crc=-66775850
RANK_FILTER_LIST  := [ 55999958, 23, 55999958, 23, 56556179, 24, 55999958, 
  23, 37419647, 24, 55999958, 23, 29419057, 21, 29419057, 21, 55999958, 23, 
  55999958, 23, 11121786, 5, 7665940, 19, 11121786, 5, 7665940, 19, 11121787, 
  6, 7665940, 19, 1, 0, 11121787, 6, 7665940, 19 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/sgpres.gi", -66775850 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/sgpres.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/sgpres.gi");
elif COM_RESULT = 3  then
Revision.sgpres_gi:="@(#)$Id: sgpres.gi,v 4.61.2.3 2006/07/27 20:32:27 gap Exp $";
InstallGlobalFunction(AbelianInvariantsNormalClosureFpGroupRrs,COM_FUN(1));
InstallGlobalFunction(AbelianInvariantsSubgroupFpGroupMtc,COM_FUN(2));
InstallGlobalFunction(AbelianInvariantsSubgroupFpGroupRrs,COM_FUN(3));
InstallGlobalFunction(AugmentedCosetTableInWholeGroup,COM_FUN(4));
InstallMethod(AugmentedCosetTableMtcInWholeGroup,"subgroup of fp group",true,[IsSubgroupFpGroup],0,COM_FUN(5));
InstallMethod(AugmentedCosetTableRrsInWholeGroup,"subgroup of fp group",true,[IsSubgroupFpGroup],0,COM_FUN(6));
InstallMethod(AugmentedCosetTableRrsInWholeGroup,"use Mtc table",true,[IsSubgroupFpGroup and HasAugmentedCosetTableMtcInWholeGroup],0,AugmentedCosetTableMtcInWholeGroup);
InstallMethod(AugmentedCosetTableNormalClosureInWholeGroup,"subgroup of fp group",true,[IsSubgroupFpGroup],0,COM_FUN(7));
InstallGlobalFunction(AugmentedCosetTableMtc,COM_FUN(8));
InstallGlobalFunction(AugmentedCosetTableRrs,COM_FUN(9));
InstallMethod(AugmentedCosetTableNormalClosure,"for finitely presented groups",true,[IsSubgroupFpGroup and IsGroupOfFamily,IsSubgroupFpGroup],0,COM_FUN(10));
InstallMethod(CosetTableBySubgroup,"coset action",IsIdenticalObj,[IsGroup,IsGroup],0,COM_FUN(11));
InstallMethod(CosetTableBySubgroup,"use `CosetTableInWholeGroup",IsIdenticalObj,[IsSubgroupFpGroup,IsSubgroupFpGroup],0,COM_FUN(12));
InstallGlobalFunction(CanonicalRelator,COM_FUN(13));
InstallGlobalFunction(CheckCosetTableFpGroup,COM_FUN(14));
InstallGlobalFunction(IsStandardized,COM_FUN(15));
DeclareRepresentation("IsPresentationDefaultRep",IsComponentObjectRep and IsAttributeStoringRep,[]);
InstallMethod(\.,"for a presentation in default representation",true,[IsPresentation and IsPresentationDefaultRep,IsPosInt],0,COM_FUN(16));
InstallMethod(IsBound\.,"for a presentation in default representation",true,[IsPresentation and IsPresentationDefaultRep,IsPosInt],0,COM_FUN(17));
InstallMethod(\.\:\=,"for a mutable presentation in default representation",true,[IsPresentation and IsPresentationDefaultRep and IsMutable,IsPosInt,IsObject],0,COM_FUN(18));
InstallMethod(Unbind\.,"for a mutable presentation in default representation",true,[IsPresentation and IsPresentationDefaultRep and IsMutable,IsPosInt],0,COM_FUN(19));
InstallGlobalFunction(PresentationAugmentedCosetTable,COM_FUN(20));
InstallGlobalFunction(PresentationNormalClosureRrs,COM_FUN(21));
InstallGlobalFunction(PresentationSubgroupMtc,COM_FUN(22));
InstallGlobalFunction(PresentationSubgroupRrs,COM_FUN(23));
InstallGlobalFunction(ReducedRrsWord,COM_FUN(24));
InstallGlobalFunction(RelatorMatrixAbelianizedNormalClosureRrs,COM_FUN(25));
RelatorMatrixAbelianizedNormalClosure:=RelatorMatrixAbelianizedNormalClosureRrs;
InstallGlobalFunction(RelatorMatrixAbelianizedSubgroupMtc,COM_FUN(26));
InstallGlobalFunction(RelatorMatrixAbelianizedSubgroupRrs,COM_FUN(27));
InstallGlobalFunction(RenumberTree,COM_FUN(28));
InstallGlobalFunction(RewriteAbelianizedSubgroupRelators,COM_FUN(29));
InstallGlobalFunction(RewriteSubgroupRelators,COM_FUN(30));
InstallGlobalFunction(SortRelsSortedByStartGen,COM_FUN(31));
InstallGlobalFunction(SpanningTree,COM_FUN(32));
InstallGlobalFunction(RewriteWord,COM_FUN(33));
InstallGlobalFunction(DecodedTreeEntry,COM_FUN(34));
InstallGlobalFunction(GeneratorTranslationAugmentedCosetTable,COM_FUN(35));
InstallGlobalFunction(SecondaryGeneratorWordsAugmentedCosetTable,COM_FUN(36));
InstallGlobalFunction(CopiedAugmentedCosetTable,COM_FUN(37));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/sgpres.gi"

#F  file="lib/tietze.gi" crc=65017620
RANK_FILTER_LIST  := [ 11121786, 5, 11121786, 5, 38442676, 2 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/tietze.gi", 65017620 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/tietze.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/tietze.gi");
elif COM_RESULT = 3  then
Revision.tietze_gi:="@(#)$Id: tietze.gi,v 4.58 2002/04/15 10:05:24 sal Exp $";
TzTestInitialSetup:=COM_FUN(1);
InstallGlobalFunction(AddGenerator,COM_FUN(2));
InstallGlobalFunction(AddRelator,COM_FUN(3));
InstallGlobalFunction(DecodeTree,COM_FUN(4));
InstallGlobalFunction(FpGroupPresentation,COM_FUN(5));
InstallGlobalFunction(PresentationFpGroup,COM_FUN(6));
InstallMethod(PrintObj,"for a presentation in default representation",true,[IsPresentation and IsPresentationDefaultRep],0,COM_FUN(7));
InstallMethod(ShallowCopy,"for a presentation in default representation",true,[IsPresentation and IsPresentationDefaultRep],0,StructuralCopy);
InstallGlobalFunction(PresentationRegularPermutationGroup,COM_FUN(8));
InstallGlobalFunction(PresentationRegularPermutationGroupNC,COM_FUN(9));
InstallGlobalFunction(PresentationViaCosetTable,COM_FUN(10));
InstallGlobalFunction(RelsViaCosetTable,COM_FUN(11));
InstallGlobalFunction(RemoveRelator,COM_FUN(12));
InstallGlobalFunction(SimplifiedFpGroup,COM_FUN(13));
InstallGlobalFunction(AbstractWordTietzeWord,COM_FUN(14));
InstallGlobalFunction(TzCheckRecord,COM_FUN(15));
InstallGlobalFunction(TzEliminate,COM_FUN(16));
InstallGlobalFunction(TzEliminateFromTree,COM_FUN(17));
InstallGlobalFunction(TzEliminateGen,COM_FUN(18));
InstallGlobalFunction(TzEliminateGen1,COM_FUN(19));
InstallGlobalFunction(TzEliminateGens,COM_FUN(20));
InstallGlobalFunction(TzFindCyclicJoins,COM_FUN(21));
InstallGlobalFunction(TzGeneratorExponents,COM_FUN(22));
InstallGlobalFunction(TzGo,COM_FUN(23));
InstallGlobalFunction(TzGoGo,COM_FUN(24));
InstallGlobalFunction(TzHandleLength1Or2Relators,COM_FUN(25));
InstallGlobalFunction(GeneratorsOfPresentation,COM_FUN(26));
InstallGlobalFunction(TzInitGeneratorImages,COM_FUN(27));
InstallGlobalFunction(OldGeneratorsOfPresentation,COM_FUN(28));
InstallGlobalFunction(TzImagesOldGens,COM_FUN(29));
InstallGlobalFunction(TzPreImagesNewGens,COM_FUN(30));
InstallGlobalFunction(TzMostFrequentPairs,COM_FUN(31));
InstallGlobalFunction(TzNewGenerator,COM_FUN(32));
InstallGlobalFunction(TzPrint,COM_FUN(33));
InstallGlobalFunction(TzPrintGeneratorImages,COM_FUN(34));
InstallGlobalFunction(TzPrintGenerators,COM_FUN(35));
InstallGlobalFunction(TzPrintLengths,COM_FUN(36));
InstallMethod(TzOptions,"set default values",true,[IsPresentation],0,COM_FUN(37));
InstallGlobalFunction(TzPrintOptions,COM_FUN(38));
InstallGlobalFunction(TzPrintPairs,COM_FUN(39));
InstallGlobalFunction(TzPrintPresentation,COM_FUN(40));
InstallGlobalFunction(TzPrintRelators,COM_FUN(41));
InstallGlobalFunction(TzPrintStatus,COM_FUN(42));
InstallGlobalFunction(TzRelator,COM_FUN(43));
InstallGlobalFunction(TzRemoveGenerators,COM_FUN(44));
InstallGlobalFunction(TzSearch,COM_FUN(45));
InstallGlobalFunction(TzSearchEqual,COM_FUN(46));
InstallGlobalFunction(TzSort,COM_FUN(47));
InstallGlobalFunction(TzSubstitute,COM_FUN(48));
InstallGlobalFunction(TzSubstituteCyclicJoins,COM_FUN(49));
InstallGlobalFunction(TzSubstituteWord,COM_FUN(50));
InstallGlobalFunction(TzUpdateGeneratorImages,COM_FUN(51));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/tietze.gi"

#F  file="lib/ghomfp.gi" crc=50539279
RANK_FILTER_LIST  := [ 21720954, 30, 65767820, 5, 21720954, 30, 42856115, 31, 
  43341900, 29, 48919677, 29, 48919677, 29, 65767820, 5, 48919677, 29, 
  65767820, 5, 33432853, 24, 48919677, 29, 9666801, 28, 29419057, 21, 
  11226115, 13, 2214405, 17, 66404734, 34, 30901969, 22, 65767820, 5, 
  55999958, 23, 67108760, 5, 55999958, 23, 63988552, 12, 67108760, 5, 
  55999958, 23, 55999958, 23, 55999958, 23, 55999958, 23, 5668610, 24, 
  55999958, 23, 55986039, 26, 55986039, 26, 55999958, 23, 55999958, 23, 
  55999958, 23, 12468060, 24, 12468060, 24, 12468060, 24, 12468060, 24, 
  65767820, 5, 12468060, 24, 65767820, 5, 20951140, 22 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/ghomfp.gi", 50539279 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/ghomfp.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/ghomfp.gi");
elif COM_RESULT = 3  then
Revision.ghomfp_gi:="@(#)$Id: ghomfp.gi,v 4.41.2.3 2006/01/11 04:51:33 gap Exp $";
InstallMethod(ImagesRepresentative,"map from fp group or free group, use 'MappedWord'",FamSourceEqFamElm,[IsFromFpGroupStdGensGeneralMappingByImages,IsMultiplicativeElementWithInverse],0,COM_FUN(1));
InstallMethod(IsSingleValued,"map from fp group or free group, given on std. gens: test relators",true,[IsFromFpGroupStdGensGeneralMappingByImages],0,COM_FUN(2));
InstallMethod(IsSingleValued,"map from fp group or free group to perm, given on std. gens: test relators",true,[IsFromFpGroupStdGensGeneralMappingByImages and IsToPermGroupGeneralMappingByImages],0,COM_FUN(3));
InstallMethod(KernelOfMultiplicativeGeneralMapping,"from fp/free group, std. gens., to perm group",true,[IsFromFpGroupGeneralMapping and IsToPermGroupGeneralMappingByImages],0,COM_FUN(4));
InstallGlobalFunction(SecondaryImagesAugmentedCosetTable,COM_FUN(5));
InstallGlobalFunction(TrySecondaryImages,COM_FUN(6));
InstallMethod(CosetTableFpHom,"for fp homomorphisms",true,[IsFromFpGroupGeneralMappingByImages and IsGroupGeneralMappingByImages],0,COM_FUN(7));
InstallMethod(ImagesRepresentative,"map from (sub)fp group, rewrite",FamSourceEqFamElm,[IsFromFpGroupGeneralMappingByImages and IsGroupGeneralMappingByImages,IsMultiplicativeElementWithInverse],0,COM_FUN(8));
InstallMethod(ImagesRepresentative,"simple tests on equal words to check whether the `generators' are mapped",FamSourceEqFamElm,[IsFromFpGroupGeneralMappingByImages and IsGroupGeneralMappingByImages,IsMultiplicativeElementWithInverse],1,COM_FUN(9));
InstallMethod(KernelOfMultiplicativeGeneralMapping,"hom from fp grp",true,[IsFromFpGroupGeneralMapping and IsGroupGeneralMapping],0,COM_FUN(10));
InstallMethod(CoKernelOfMultiplicativeGeneralMapping,"GHBI from fp grp",true,[IsFromFpGroupGeneralMappingByImages and IsGroupGeneralMappingByImages],0,COM_FUN(11));
BindGlobal("WreathElm",COM_FUN(12));
InstallGlobalFunction(KuKGenerators,COM_FUN(13));
BindGlobal("InducedRepFpGroup",COM_FUN(14));
BindGlobal("IsTransPermStab1",COM_FUN(15));
InstallMethod(PreImagesSet,"map from (sub)group of fp group",CollFamRangeEqFamElms,[IsFromFpGroupHomomorphism,IsGroup],0,COM_FUN(16));
InstallMethod(IsConjugatorIsomorphism,"for a f.p. group general mapping",true,[IsGroupGeneralMapping],1,COM_FUN(17));
InstallMethod(CompositionMapping2,"for gp. hom. and fp. hom, transferring the coset table",FamSource1EqFamRange2,[IsGroupHomomorphism,IsGroupHomomorphism and IsFromFpGroupGeneralMappingByImages and HasCosetTableFpHom],0,COM_FUN(18));
InstallMethod(PreImagesRepresentative,"hom. to standard generators of fp group, using 'MappedWord'",FamRangeEqFamElm,[IsToFpGroupHomomorphismByImages,IsMultiplicativeElementWithInverse],1,COM_FUN(19));
InstallOtherMethod(IsomorphismFpGroup,"subgroups of fp group",true,[IsSubgroupFpGroup,IsString],0,COM_FUN(20));
InstallMethod(IsomorphismFpGroupByGeneratorsNC,"subgroups of fp group",IsFamFamX,[IsSubgroupFpGroup,IsList and IsMultiplicativeElementWithInverseCollection,IsString],0,COM_FUN(21));
InstallMethod(IsomorphismSimplifiedFpGroup,"using tietze transformations",true,[IsSubgroupFpGroup],0,COM_FUN(22));
InstallMethod(NaturalHomomorphismByNormalSubgroupOp,"for subgroups of fp groups",IsIdenticalObj,[IsSubgroupFpGroup,IsSubgroupFpGroup],0,COM_FUN(23));
InstallMethod(NaturalHomomorphismByNormalSubgroupOp,"for subgroups of fp groups by quotient rep.",IsIdenticalObj,[IsSubgroupFpGroup,IsSubgroupFpGroup and IsSubgroupOfWholeGroupByQuotientRep],0,COM_FUN(24));
InstallMethod(NaturalHomomorphismByNormalSubgroupOp,"trivial image fp case",IsIdenticalObj,[IsSubgroupFpGroup,IsSubgroupFpGroup and IsWholeFamily],0,COM_FUN(25));
InstallMethod(MaximalAbelianQuotient,"whole fp group",true,[IsSubgroupFpGroup and IsWholeFamily],0,COM_FUN(26));
InstallMethod(MaximalAbelianQuotient,"for subgroups of finitely presented groups",true,[IsSubgroupFpGroup],0,COM_FUN(27));
DeclareRepresentation("IsModuloPcgsFpGroupRep",IsModuloPcgs and IsPcgsDefaultRep,["hom","impcgs","groups"]);
InstallMethod(ModuloPcgs,"subgroups fp",true,[IsSubgroupFpGroup,IsSubgroupFpGroup],0,COM_FUN(28));
InstallMethod(NumeratorOfModuloPcgs,"fp",true,[IsModuloPcgsFpGroupRep],0,COM_FUN(29));
InstallMethod(DenominatorOfModuloPcgs,"fp",true,[IsModuloPcgsFpGroupRep],0,COM_FUN(30));
InstallMethod(RelativeOrders,"fp",true,[IsModuloPcgsFpGroupRep],0,COM_FUN(31));
InstallMethod(RelativeOrderOfPcElement,"fp",IsCollsElms,[IsModuloPcgsFpGroupRep,IsMultiplicativeElementWithInverse],0,COM_FUN(32));
InstallMethod(ExponentsOfPcElement,"fp",IsCollsElms,[IsModuloPcgsFpGroupRep,IsMultiplicativeElementWithInverse],0,COM_FUN(33));
InstallMethod(EpimorphismFromFreeGroup,"general",true,[IsGroup and HasGeneratorsOfGroup],0,COM_FUN(34));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/ghomfp.gi"

#F  file="lib/addgphom.gi" crc=121327775
RANK_FILTER_LIST  := [  ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/addgphom.gi", 121327775 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/addgphom.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/addgphom.gi");
elif COM_RESULT = 3  then
Revision.addgphom_gi:="@(#)$Id: addgphom.gi,v 1.2 2002/04/15 10:04:22 sal Exp $";
InstallGlobalFunction(GroupToAdditiveGroupHomomorphismByFunction,COM_FUN(1));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/addgphom.gi"

#F  file="lib/hash.gi" crc=24556858
RANK_FILTER_LIST  := [ 8126465, 2, 8126465, 2, 5, 1, 8126465, 2, 8126465, 2, 
  5, 1, 21407891, 9, 21407891, 9, 5799293, 18, 48921666, 17, 21407891, 9, 
  24936119, 2, 8126465, 2, 8126465, 2, 5, 1, 30735410, 18, 1, 0, 6748905, 18, 
  1, 0, 1, 0, 23993740, 18, 1, 0, 1, 0, 30735411, 19, 1, 0, 1, 0, 46344009, 
  10, 46344009, 10, 46344009, 10, 49872237, 3, 8126465, 2, 8126465, 2, 5, 1, 
  21898766, 12, 1, 0, 49412541, 20, 1, 0, 1, 0, 49412541, 20, 1, 0, 1, 0, 
  49412541, 20, 1, 0, 1, 0, 25426994, 12, 25426994, 12, 25426994, 12 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/hash.gi", 24556858 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/hash.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/hash.gi");
elif COM_RESULT = 3  then
Revision.hash_gi:="@(#)$Id: hash.gi,v 4.17 2002/04/15 10:04:53 sal Exp $";
DeclareInfoClass("InfoHashTables");
InstallMethod(HashTable,true,[IsCollection,IsCollection,IsFunction],-1,COM_FUN(1));
InstallMethod(SingleValuedHashTable,true,[IsCollection,IsCollection,IsFunction],-1,COM_FUN(2));
DeclareRepresentation("IsHashTable",IsComponentObjectRep,["source","range","hashFunc","entries","table"]);
InstallMethod(Source,true,[IsHashTable and IsGeneralMapping],0,COM_FUN(3));
InstallMethod(Range,true,[IsHashTable and IsGeneralMapping],0,COM_FUN(4));
InstallMethod(ViewObj,"for mutable flexible hash table",true,[IsHashTable and IsFlexibleGeneralMapping and IsMutable],0,COM_FUN(5));
InstallMethod(ViewObj,"for mutable extensible hash table",true,[IsHashTable and IsExtensibleGeneralMapping and IsMutable],0,COM_FUN(6));
InstallMethod(ViewObj,"for immutable hash table",true,[IsHashTable and IsGeneralMapping],0,COM_FUN(7));
InstallMethod(PrintObj,"for a hash table",true,[IsHashTable],0,COM_FUN(8));
ListHashParams:=rec(BASIC_HASH_RANGE:=16,HASH_GROW_MARGIN:=5/4,HASH_GROW_FACTOR:=3/2,HASH_SHRINK_MARGIN:=3,HASH_SHRINK_FACTOR:=2);
DeclareRepresentation("IsListHashTable",IsHashTable,[]);
InstallMethod(ShrinkableHashTable,true,[IsCollection,IsCollection,IsFunction],0,COM_FUN(9));
ResizeListHashTable:=COM_FUN(10);
InstallMethod(ImagesElm,FamSourceEqFamElm,[IsListHashTable and IsFlexibleGeneralMapping,IsObject],0,COM_FUN(11));
InstallMethod(AddImage,FamMapFamSourceFamRange,[IsListHashTable and IsExtensibleGeneralMapping and IsMutable,IsObject,IsObject],0,COM_FUN(12));
InstallMethod(AddImageNC,FamMapFamSourceFamRange,[IsList and IsExtensibleGeneralMapping and IsMutable,IsObject,IsObject],0,COM_FUN(13));
InstallMethod(DeleteImage,FamMapFamSourceFamRange,[IsListHashTable and IsFlexibleGeneralMapping and IsMutable,IsObject,IsObject],0,COM_FUN(14));
InstallMethod(IsSingleValued,true,[IsListHashTable and IsGeneralMapping],0,COM_FUN(15));
InstallMethod(ImagesSource,true,[IsListHashTable and IsGeneralMapping],0,COM_FUN(16));
InstallMethod(PreImagesRange,true,[IsListHashTable and IsGeneralMapping],0,COM_FUN(17));
InstallMethod(ShallowCopy,true,[IsListHashTable],0,COM_FUN(18));
FlatHashParams:=rec(BASIC_HASH_RANGE:=50,HASH_GROW_MARGIN:=3/2,HASH_GROW_FACTOR:=2);
DeclareRepresentation("IsFlatHashTable",IsHashTable,["tabSize"]);
InstallMethod(SingleValuedHashTable,true,[IsCollection,IsCollection,IsFunction\
],0,COM_FUN(19));
ResizeFlatHashTable:=COM_FUN(20);
InstallMethod(ImagesElm,FamSourceEqFamElm,[IsFlatHashTable and IsGeneralMapping and IsSingleValued,IsObject],0,COM_FUN(21));
InstallMethod(AddImage,FamMapFamSourceFamRange,[IsFlatHashTable and IsExtensiblePartialMapping and IsMutable,IsObject,IsObject],0,COM_FUN(22));
InstallMethod(AddImageNC,FamMapFamSourceFamRange,[IsFlatHashTable and IsExtensiblePartialMapping and IsMutable,IsObject,IsObject],0,COM_FUN(23));
InstallMethod(SetImage,FamMapFamSourceFamRange,[IsFlatHashTable and IsExtensiblePartialMapping and IsMutable,IsObject,IsObject],0,COM_FUN(24));
InstallMethod(ImagesSource,true,[IsFlatHashTable and IsSingleValued],0,COM_FUN(25));
InstallMethod(PreImagesRange,true,[IsFlatHashTable and IsSingleValued],0,COM_FUN(26));
InstallMethod(ShallowCopy,true,[IsFlatHashTable and IsSingleValued],0,COM_FUN(27));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/hash.gi"

#F  file="lib/dict.gi" crc=24976493
RANK_FILTER_LIST  := [ 16385, 3, 1, 0, 786433, 8, 1, 0, 16449016, 8, 1, 0, 1, 
  0, 67108475, 6, 1, 0, 48034737, 10, 1, 0, 1, 0, 49346896, 7, 1, 0, 
  16449016, 8, 1, 0, 67108475, 6, 1, 0, 16449016, 8, 1, 0, 40162743, 8, 1, 0, 
  1, 0, 45410419, 6, 1, 0, 45410419, 6, 1, 0, 40162743, 8, 1, 0, 66226823, 7, 
  66226823, 7, 67108760, 5, 67108760, 5, 66226823, 7, 66226823, 7, 66226823, 
  7, 66226823, 7, 49449262, 7, 17, 18, 49449262, 7, 17, 18, 1, 0, 49449262, 
  7, 49449262, 7, 65344766, 7, 65344766, 7, 67108760, 5, 67108760, 5, 
  65344766, 7, 48567205, 7, 48567205, 7, 48567205, 7, 48567205, 7, 1, 0, 
  48567205, 7, 1, 0, 1, 0, 48567205, 7, 48567205, 7, 50331319, 5, 50331319, 
  5, 1, 0, 50331319, 5, 1, 0, 1, 0, 14571737, 8, 1, 0, 1, 0, 50331319, 5, 1, 
  0, 50331319, 5, 1, 0, 14571737, 8, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 4819275, 
  49, 1, 0, 40324424, 23, 1, 0, 1, 0, 31628240, 40, 1, 0, 31628240, 40, 1, 0, 
  16173166, 29, 1, 0, 7665940, 19, 1, 0, 575, 9, 1, 0, 63332713, 9, 1, 0, 
  42892855, 28, 1, 0, 53610488, 2 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/dict.gi", 24976493 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/dict.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/dict.gi");
elif COM_RESULT = 3  then
Revision.dict_gi:="@(#)$Id: dict.gi,v 4.25.2.2 2006/11/16 17:52:21 gap Exp $";
InstallMethod(PositionFirstComponentDict,"for dense list",true,[IsDenseList,IsObject],0,COM_FUN(1));
InstallMethod(PositionFirstComponentDict,"for sorted list",true,[IsSSortedList,IsObject],0,COM_FUN(2));
BindGlobal("DictionaryByList",COM_FUN(3));
BindGlobal("DictionaryBySort",COM_FUN(4));
InstallOtherMethod(AddDictionary,"for lookup list dictionaries",true,[IsListLookupDictionary,IsObject,IsObject],0,COM_FUN(5));
InstallMethod(AddDictionary,"for list dictionaries",true,[IsListDictionary,IsObject],0,COM_FUN(6));
InstallOtherMethod(AddDictionary,"for lookup sort dictionaries",true,[IsSortLookupDictionary,IsObject,IsObject],0,COM_FUN(7));
InstallMethod(AddDictionary,"for sort dictionaries",true,[IsSortDictionary,IsObject],0,COM_FUN(8));
InstallMethod(KnowsDictionary,"for list lookup dictionaries",true,[IsListLookupDictionary,IsObject],0,COM_FUN(9));
InstallMethod(KnowsDictionary,"for list dictionaries",true,[IsListDictionary,IsObject],0,COM_FUN(10));
InstallMethod(LookupDictionary,"for list dictionaries",true,[IsListLookupDictionary,IsObject],0,COM_FUN(11));
InstallGlobalFunction(DictionaryByPosition,COM_FUN(12));
InstallOtherMethod(AddDictionary,"for lookup position dictionaries",true,[IsPositionLookupDictionary,IsObject,IsObject],0,COM_FUN(13));
InstallMethod(AddDictionary,"for position dictionaries",true,[IsPositionDictionary,IsObject],0,COM_FUN(14));
InstallMethod(KnowsDictionary,"for position dictionaries",true,[IsPositionDictionary,IsObject],0,COM_FUN(15));
InstallMethod(LookupDictionary,"for position dictionaries",true,[IsPositionLookupDictionary,IsObject],0,COM_FUN(16));
InstallGlobalFunction(NewDictionary,COM_FUN(17));
MaxHashViewSize:=10;
LastHashIndex:=-1;
InstallGlobalFunction(DenseHashTable,COM_FUN(18));
InstallMethod(ViewObj,"for dense hash tables",true,[IsDenseHashRep],0,COM_FUN(19));
InstallMethod(PrintHashWithNames,"for dense hash tables",true,[IsDenseHashRep,IsString,IsString],0,COM_FUN(20));
InstallMethod(PrintObj,"for dense hash tables",true,[IsDenseHashRep],0,COM_FUN(21));
InstallMethod(Size,"for dense hash tables",true,[IsDenseHashRep],0,COM_FUN(22));
InstallMethod(Enumerator,"for dense hash tables",true,[IsDenseHashRep],0,COM_FUN(23));
InstallMethod(HashKeyEnumerator,"for dense hash tables",true,[IsDenseHashRep],0,COM_FUN(24));
InstallMethod(GetHashEntry,"for dense hash tables",true,[IsHash and IsDenseHashRep,IsObject and IsInt],0,COM_FUN(25));
InstallMethod(AddHashEntry,"for dense hash tables",true,[IsHash and IsDenseHashRep,IsObject and IsInt,IsObject],0,COM_FUN(26));
InstallMethod(Random,"for dense hash tables",true,[IsHash and IsDenseHashRep],100,COM_FUN(27));
InstallMethod(RandomHashKey,"for dense hash tables",true,[IsHash and IsDenseHashRep],100,COM_FUN(28));
DefaultHashLength:=2^7;
InstallGlobalFunction(SparseHashTable,COM_FUN(29));
InstallMethod(ViewObj,"for sparse hash tables",true,[IsSparseHashRep],0,COM_FUN(30));
InstallMethod(PrintHashWithNames,"for sparse hash tables",true,[IsSparseHashRep,IsString,IsString],0,COM_FUN(31));
InstallMethod(PrintObj,"for sparse hash tables",true,[IsSparseHashRep],0,COM_FUN(32));
InstallMethod(Size,"for sparse hash tables",true,[IsHash and IsSparseHashRep],0,COM_FUN(33));
InstallMethod(Enumerator,"for sparse hash tables",true,[IsHash and IsSparseHashRep],0,COM_FUN(34));
InstallMethod(HashKeyEnumerator,"for sparse hash tables",true,[IsHash and IsSparseHashRep],0,COM_FUN(35));
BindGlobal("HASH_RANGE",[0..10000]);
InstallGlobalFunction(GetHashEntryIndex,COM_FUN(36));
InstallMethod(GetHashEntry,"for sparse hash tables",true,[IsHash and IsSparseHashRep,IsObject],0,COM_FUN(37));
InstallGlobalFunction(DoubleHashArraySize,COM_FUN(38));
InstallMethod(AddHashEntry,"for sparse hash tables",true,[IsHash and IsSparseHashRep,IsObject,IsObject],0,COM_FUN(39));
InstallMethod(Random,"for sparse hash tables",true,[IsHash and IsSparseHashRep],100,COM_FUN(40));
InstallMethod(RandomHashKey,"for sparse hash tables",true,[IsHash and IsSparseHashRep],100,COM_FUN(41));
InstallGlobalFunction(HashFunct,COM_FUN(42));
InstallMethod(GetHashEntryAtLastIndex,"for hash table",true,[IsHash],0,COM_FUN(43));
InstallMethod(SetHashEntryAtLastIndex,"for hash table",true,[IsHash,IsObject],0,COM_FUN(44));
InstallMethod(SetHashEntry,"for hash table",true,[IsHash,IsObject,IsObject],0,COM_FUN(45));
BindGlobal("HashDictAddDictionary",COM_FUN(46));
InstallOtherMethod(AddDictionary,"for hash tables",true,[IsHash and IsSparseHashRep and TableHasIntKeyFun,IsObject,IsObject],0,HashDictAddDictionary);
InstallGlobalFunction(DoubleHashDictSize,COM_FUN(47));
InstallOtherMethod(AddDictionary,"for hash tables, no value given",true,[IsHash,IsObject],0,COM_FUN(48));
InstallMethod(KnowsDictionary,"for hash tables",true,[IsHash,IsObject],0,COM_FUN(49));
InstallMethod(LookupDictionary,"for hash tables",true,[IsHash and IsSparseHashRep and TableHasIntKeyFun,IsObject],0,COM_FUN(50));
InstallMethod(DenseIntKey,"default fail",true,[IsObject,IsObject],0,ReturnFail);
InstallMethod(SparseIntKey,"defaults to DenseIntKey",true,[IsObject,IsObject],0,DenseIntKey);
InstallMethod(DenseIntKey,"for finite Gaussian row spaces",true,[IsFFECollColl and IsGaussianRowSpace,IsObject],0,COM_FUN(51));
InstallMethod(DenseIntKey,"for lists of vectors",true,[IsFFECollColl,IsObject],0,COM_FUN(52));
InstallMethod(DenseIntKey,"for matrices over finite field vector spaces",true,[IsObject,IsFFECollColl and IsMatrix],0,COM_FUN(53));
InstallMethod(SparseIntKey,"for matrices over finite field vector spaces",true,[IsObject,IsFFECollColl and IsMatrix],0,COM_FUN(54));
InstallMethod(SparseIntKey,"for row spaces over finite fields",true,[IsObject,IsVectorSpace and IsRowSpace],0,COM_FUN(55));
InstallMethod(DenseIntKey,"integers",true,[IsObject,IsPosInt],0,COM_FUN(56));
InstallMethod(SparseIntKey,"permutations, arbitrary domain",true,[IsObject,IsInternalRep and IsPerm],0,COM_FUN(57));
InstallMethod(SparseIntKey,"kernel pc group elements",true,[IsObject,IsElementFinitePolycyclicGroup and IsDataObjectRep and IsNBitsPcWordRep],0,COM_FUN(58));
InstallMethod(SparseIntKey,"pcgs element lists: i.e. pcgs",true,[IsObject,IsElementFinitePolycyclicGroupCollection and IsList],0,COM_FUN(59));
InstallMethod(DenseIntKey,"transformations, arbitrary domain",true,[IsObject,IsTransformationRep],0,COM_FUN(60));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/dict.gi"

#F  file="lib/trans.gi" crc=91595896
RANK_FILTER_LIST  := [ 7665940, 19, 63734282, 6, 50235890, 8, 63734282, 6, 
  63734282, 6, 17, 18, 63734282, 6, 4063233, 1, 50235890, 8, 63734282, 6, 
  63734282, 6, 63734282, 6, 50235890, 8, 513, 8, 513, 8, 7665940, 19, 513, 8, 
  7665940, 19, 51026709, 12, 63580652, 7, 63734282, 6, 50235890, 8, 50235890, 
  8, 50235890, 8, 513, 8, 513, 8, 50235890, 8, 63580652, 7, 63734282, 6, 
  63734282, 6, 63580652, 7, 50235890, 8, 50235890, 8, 50235890, 8, 50235890, 
  8, 50235890, 8, 17, 18, 50235890, 8, 63734282, 6, 63734282, 6, 15332823, 
  19, 63734282, 6, 30666573, 21 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/trans.gi", 91595896 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/trans.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/trans.gi");
elif COM_RESULT = 3  then
Revision.trans_gi:="@(#)$Id: trans.gi,v 4.16.2.2 2006/03/05 14:39:56 jamesm Exp $";
InstallGlobalFunction(Transformation,COM_FUN(1));
InstallGlobalFunction(TransformationNC,COM_FUN(2));
InstallGlobalFunction(IdentityTransformation,COM_FUN(3));
InstallMethod(RandomTransformation,"<trans>",true,[IsPosInt],0,COM_FUN(4));
InstallMethod(ImageSetOfTransformation,"<trans>",true,[IsTransformation],0,COM_FUN(5));
InstallMethod(ImageListOfTransformation,"<trans>",true,[IsTransformation and IsTransformationRep],0,COM_FUN(6));
InstallMethod(RankOfTransformation,"<trans>",true,[IsTransformation],0,COM_FUN(7));
InstallMethod(PreimagesOfTransformation,"<trans>",true,[IsTransformation,IsInt],0,COM_FUN(8));
InstallMethod(RestrictedTransformation,"for transformation",true,[IsTransformation,IsListOrCollection],0,COM_FUN(9));
InstallMethod(KernelOfTransformation,"to give a kernel of a transformation as \
a partition of its domain including singletons!!",true,[IsTransformation and I\
sTransformationRep],0,COM_FUN(10));
InstallMethod(PermLeftQuoTransformation,"for two transformations",true,[IsTransformation,IsTransformation],0,COM_FUN(11));
InstallGlobalFunction(TransformationData,COM_FUN(12));
InstallGlobalFunction(TransformationType,COM_FUN(13));
InstallGlobalFunction(TransformationFamily,COM_FUN(14));
InstallMethod(PrintObj,"for transformations",true,[IsTransformation],0,COM_FUN(15));
InstallMethod(DegreeOfTransformation,"for a transformation",true,[IsTransformation and IsTransformationRep],0,COM_FUN(16));
InstallMethod(AsTransformation,"for a permutation",true,[IsPerm],0,COM_FUN(17));
InstallOtherMethod(AsTransformation,"for a permutation and degree",true,[IsPerm,IsPosInt],0,COM_FUN(18));
InstallOtherMethod(AsTransformationNC,"for a permutation and degree",true,[IsPerm,IsPosInt],0,COM_FUN(19));
InstallOtherMethod(AsTransformation,"for binary relations on points",true,[IsBinaryRelation and IsBinaryRelationOnPointsRep],0,COM_FUN(20));
InstallMethod(TransformationRelation,"for relation over [1..n]",true,[IsGeneralMapping],0,COM_FUN(21));
InstallMethod(BinaryRelationTransformation,"for a transformation",true,[IsTransformation],0,COM_FUN(22));
InstallMethod(\*,"trans * trans",IsIdenticalObj,[IsTransformation and IsTransformationRep,IsTransformation and IsTransformationRep],0,COM_FUN(23));
InstallMethod(\*,"trans * perm",true,[IsTransformation and IsTransformationRep,IsPerm],0,COM_FUN(24));
InstallMethod(\*,"trans * perm",true,[IsPerm,IsTransformation and IsTransformationRep],0,COM_FUN(25));
InstallMethod(\*,"binary relation * trans",true,[IsGeneralMapping,IsTransformation],0,COM_FUN(26));
InstallMethod(\*,"trans * binary relation",true,[IsTransformation,IsGeneralMapping],0,COM_FUN(27));
InstallMethod(\<,"<trans> < <trans>",IsIdenticalObj,[IsTransformation and IsTransformationRep,IsTransformation and IsTransformationRep],0,COM_FUN(28));
InstallMethod(One,"One(<trans>)",true,[IsTransformation and IsTransformationRep],0,COM_FUN(29));
InstallMethod(\=,"for two transformations of the same set",IsIdenticalObj,[IsTransformation and IsTransformationRep,IsTransformation and IsTransformationRep],0,COM_FUN(30));
InstallOtherMethod(\^,"i ^ trans",true,[IsInt,IsTransformation and IsTransformationRep],0,COM_FUN(31));
InstallMethod(InverseOp,"Inverse operation of transformations",true,[IsTransformation],0,COM_FUN(32));
InstallMethod(\^,"for transformations and negative integers",true,[IsTransformation,IsInt and IsNegRat],0,COM_FUN(33));
InstallMethod(\^,"for transformations and zero",true,[IsTransformation,IsZeroCyc],0,COM_FUN(34));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/trans.gi"

#F  file="lib/fastendo.gi" crc=-39171898
RANK_FILTER_LIST  := [ 20564445, 13, 18728672, 16, 18728672, 16, 18728672, 
  16, 20564445, 13, 18728672, 16, 18728672, 16, 20564445, 13, 18728672, 16, 
  18728672, 16, 18728672, 16, 20564445, 13, 20564445, 13, 18728672, 16, 
  18728672, 16, 18728672, 16, 20564445, 13, 18728672, 16, 18728672, 16, 
  20564445, 13, 18728672, 16, 1, 0 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/fastendo.gi", -39171898 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/fastendo.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/fastendo.gi");
elif COM_RESULT = 3  then
Revision.fastendo_gi:="@(#)$Id: fastendo.gi,v 4.3.4.1 2006/04/07 09:04:29 gap Exp $";
DeclareRepresentation("IsTransformationRepOfEndo",IsComponentObjectRep and IsAttributeStoringRep,["transformation"]);
BindGlobal("EndoMappingByTransformation",COM_FUN(1));
InstallMethod(TransformationRepresentation,"for an endo general mapping",true,[IsEndoMapping],0,COM_FUN(2));
InstallMethod(TransformationRepresentation,"for an endo general mapping",true,[IsEndoMapping and IsTransformationRepOfEndo],0,COM_FUN(3));
InstallMethod(CompositionMapping2,"IsTransformationRepOfEndo, IsTransformationRepOfEndo",IsIdenticalObj,[IsTransformationRepOfEndo and IsEndoMapping,IsTransformationRepOfEndo and IsEndoMapping],0,COM_FUN(4));
InstallMethod(CompositionMapping2,"IsEndoMapping, IsTransformationRepOfEndo",IsIdenticalObj,[IsEndoMapping,IsTransformationRepOfEndo and IsEndoMapping],COM_FUN(5));
InstallMethod(CompositionMapping2,"IsTransformationRepOfEndo, IsEndoMapping",IsIdenticalObj,[IsTransformationRepOfEndo and IsEndoMapping,IsEndoMapping],COM_FUN(6));
InstallMethod(\=,"IsTransformationRepOfEndo, IsTransformationRepOfEndo",IsIdenticalObj,[IsTransformationRepOfEndo and IsEndoMapping,IsTransformationRepOfEndo and IsEndoMapping],0,COM_FUN(7));
InstallMethod(\=,"IsTransformationRepOfEndo, IsEndoMapping",IsIdenticalObj,[IsTransformationRepOfEndo and IsEndoMapping,IsEndoMapping],0,COM_FUN(8));
InstallMethod(\=,"IsEndoMapping, IsTransformationRepOfEndo",IsIdenticalObj,[IsEndoMapping,IsTransformationRepOfEndo and IsEndoMapping],0,COM_FUN(9));
InstallMethod(\<,"IsTransformationRepOfEndo, IsTransformationRepOfEndo",IsIdenticalObj,[IsEndoMapping and IsTransformationRepOfEndo,IsEndoMapping and IsTransformationRepOfEndo],0,COM_FUN(10));
InstallMethod(\<,"IsEndoMapping, IsTransformationRepOfEndo",IsIdenticalObj,[IsEndoMapping,IsEndoMapping and IsTransformationRepOfEndo],0,COM_FUN(11));
InstallMethod(\<,"IsTransformationRepOfEndo, IsEndoMapping",IsIdenticalObj,[IsEndoMapping and IsTransformationRepOfEndo,IsEndoMapping],0,COM_FUN(12));
InstallMethod(ImagesElm,"IsTransformationRepOfEndo",FamSourceEqFamElm,[IsTransformationRepOfEndo and IsEndoMapping,IsObject],0,COM_FUN(13));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/fastendo.gi"

#F  file="lib/fpsemi.gi" crc=-38909162
RANK_FILTER_LIST  := [ 1343114, 2, 47676329, 5, 18128327, 7, 17112519, 5, 
  17112519, 5, 17112519, 5, 17112519, 5, 17112519, 5, 17112519, 5, 17112519, 
  5, 17112519, 5, 17112519, 5, 17112519, 5, 35676996, 18, 54779227, 32, 
  46043103, 17, 54779227, 32, 46043103, 17, 35676996, 18, 46043103, 17, 
  28613822, 19, 27148904, 18, 35676996, 18, 46043103, 17, 35676996, 18, 
  60045706, 14, 46043103, 17, 60045706, 14 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/fpsemi.gi", -38909162 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/fpsemi.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/fpsemi.gi");
elif COM_RESULT = 3  then
Revision.fpsemi_gi:="@(#)$Id: fpsemi.gi,v 4.14 2002/04/15 10:04:40 sal Exp $";
InstallMethod(ElementOfFpSemigroup,"for a family of f.p. semigroup elements, and an assoc. word",true,[IsElementOfFpSemigroupFamily,IsAssocWord],0,COM_FUN(1));
InstallMethod(UnderlyingElement,"for an element of an f.p. semigroup (default repres.)",true,[IsElementOfFpSemigroup and IsPackedElementDefaultRep],0,COM_FUN(2));
InstallMethod(FpSemigroupOfElementOfFpSemigroup,"for an element of an fp semigroup",true,[IsElementOfFpSemigroup],0,COM_FUN(3));
InstallMethod(\*,"for two elements of a f.p. semigroup",IsIdenticalObj,[IsElementOfFpSemigroup,IsElementOfFpSemigroup],0,COM_FUN(4));
InstallMethod(\<,"for two elements of a f.p. semigroup",IsIdenticalObj,[IsElementOfFpSemigroup,IsElementOfFpSemigroup],0,COM_FUN(5));
InstallMethod(\=,"for two elements of a f.p. semigroup",IsIdenticalObj,[IsElementOfFpSemigroup,IsElementOfFpSemigroup],0,COM_FUN(6));
InstallMethod(PrintObj,"for an f.p. semigroup element",true,[IsElementOfFpSemigroup],0,COM_FUN(7));
InstallMethod(String,"for an f.p. semigroup element",true,[IsElementOfFpSemigroup],0,COM_FUN(8));
InstallMethod(FpGrpMonSmgOfFpGrpMonSmgElement,"for an element of an fp semigroup",true,[IsElementOfFpSemigroup],0,COM_FUN(9));
InstallGlobalFunction(FactorFreeSemigroupByRelations,COM_FUN(10));
InstallMethod(HomomorphismFactorSemigroup,"for a free semigroup and a congruence",true,[IsFreeSemigroup,IsSemigroupCongruence],0,COM_FUN(11));
InstallMethod(HomomorphismFactorSemigroup,"for an fp semigroup and a congruence",true,[IsFpSemigroup,IsSemigroupCongruence],0,COM_FUN(12));
InstallMethod(FreeSemigroupOfFpSemigroup,"for a finitely presented semigroup",true,[IsSubsemigroupFpSemigroup and IsWholeFamily],0,COM_FUN(13));
InstallMethod(Size,"for a free semigroup",true,[IsFreeSemigroup],0,COM_FUN(14));
InstallMethod(FreeGeneratorsOfFpSemigroup,"for a finitely presented semigroup",true,[IsSubsemigroupFpSemigroup and IsWholeFamily],0,COM_FUN(15));
InstallMethod(ViewObj,"for a free semigroup with generators",true,[IsSemigroup and IsFreeSemigroup and HasGeneratorsOfMagma],0,COM_FUN(16));
InstallMethod(ViewObj,"for a fp semigroup with generators",true,[IsSubsemigroupFpSemigroup and IsWholeFamily and IsSemigroup and HasGeneratorsOfMagma],0,COM_FUN(17));
InstallOtherMethod(RelationsOfFpSemigroup,"method for a free semigroup",true,[IsFreeSemigroup],0,COM_FUN(18));
InstallMethod(RelationsOfFpSemigroup,"for finitely presented semigroup",true,[IsSubsemigroupFpSemigroup and IsWholeFamily],0,COM_FUN(19));
BindGlobal("FreeSemigroupNatHomByGeneratorsNC",COM_FUN(20));
InstallMethod(NaturalHomomorphismByGenerators,"for a free semigroup and semigroup",true,[IsFreeSemigroup,IsSemigroup and HasGeneratorsOfMagma],0,COM_FUN(21));
InstallMethod(NaturalHomomorphismByGenerators,"for an fp semigroup and semigroup",true,[IsFpSemigroup,IsSemigroup and HasGeneratorsOfSemigroup],0,COM_FUN(22));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/fpsemi.gi"

#F  file="lib/fpmon.gi" crc=-15885006
RANK_FILTER_LIST  := [ 37748707, 2, 30898753, 6, 44006945, 8, 42991137, 6, 
  42991137, 6, 42991137, 6, 42991137, 6, 42991137, 6, 42991137, 6, 37748707, 
  2, 42991137, 6, 42991137, 6, 42991137, 6, 42991137, 6, 42991137, 6, 
  42991137, 6, 43070785, 21, 61964984, 20, 61964984, 20, 28346098, 22, 
  61964984, 20, 28346098, 22, 67108700, 26, 61964984, 20, 54779227, 32, 
  28346098, 22, 5316152, 17, 61964984, 20, 5316152, 17, 61964984, 20 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/fpmon.gi", -15885006 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/fpmon.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/fpmon.gi");
elif COM_RESULT = 3  then
Revision.fpmon_gi:="@(#)$Id: fpmon.gi,v 4.7 2002/04/15 10:04:40 sal Exp $";
InstallMethod(ElementOfFpMonoid,"for a family of f.p. monoid elements, and an assoc. word",true,[IsElementOfFpMonoidFamily,IsAssocWordWithOne],0,COM_FUN(1));
InstallMethod(UnderlyingElement,"for an element of an fp monoid (default repres.)",true,[IsElementOfFpMonoid and IsPackedElementDefaultRep],0,COM_FUN(2));
InstallMethod(\*,"for two elements of a fp monoid",IsIdenticalObj,[IsElementOfFpMonoid,IsElementOfFpMonoid],0,COM_FUN(3));
InstallMethod(\<,"for two elements of a f.p. monoid",IsIdenticalObj,[IsElementOfFpMonoid,IsElementOfFpMonoid],0,COM_FUN(4));
InstallMethod(\=,"for two elements of a f.p. monoid",IsIdenticalObj,[IsElementOfFpMonoid,IsElementOfFpMonoid],0,COM_FUN(5));
InstallOtherMethod(One,"for a family of fp monoid elements",true,[IsElementOfFpMonoidFamily],0,COM_FUN(6));
InstallMethod(One,"for an fp monoid element",true,[IsElementOfFpMonoid],0,COM_FUN(7));
InstallMethod(OneOp,"for an fp monoid element",true,[IsElementOfFpMonoid],0,COM_FUN(8));
InstallMethod(PrintObj,"for an fp monoid element",true,[IsElementOfFpMonoid],0,COM_FUN(9));
InstallMethod(String,"for an fp monoid element",true,[IsElementOfFpMonoid],0,COM_FUN(10));
InstallMethod(FpMonoidOfElementOfFpMonoid,"for an fp monoid element",true,[IsElementOfFpMonoid],0,COM_FUN(11));
InstallMethod(FpGrpMonSmgOfFpGrpMonSmgElement,"for an element of an fp monoid",true,[IsElementOfFpMonoid],0,COM_FUN(12));
InstallGlobalFunction(FactorFreeMonoidByRelations,COM_FUN(13));
InstallMethod(ViewObj,"for a fp monoid with generators",true,[IsSubmonoidFpMonoid and IsWholeFamily and IsMonoid and HasGeneratorsOfMagma],0,COM_FUN(14));
InstallMethod(FreeGeneratorsOfFpMonoid,"for a finitely presented monoid",true,[IsSubmonoidFpMonoid and IsWholeFamily],0,COM_FUN(15));
InstallMethod(FreeMonoidOfFpMonoid,"for a finitely presented monoid",true,[IsSubmonoidFpMonoid and IsWholeFamily],0,COM_FUN(16));
InstallOtherMethod(RelationsOfFpMonoid,"method for a free monoid",true,[IsFreeMonoid],0,COM_FUN(17));
InstallMethod(RelationsOfFpMonoid,"for finitely presented monoid",true,[IsSubmonoidFpMonoid and IsWholeFamily],0,COM_FUN(18));
InstallOtherMethod(HomomorphismFactorSemigroup,"for a free monoid and a congruence",true,[IsFreeMonoid,IsMagmaCongruence],0,COM_FUN(19));
InstallMethod(HomomorphismFactorSemigroup,"for an fp monoid and a congruence",true,[IsFpMonoid,IsSemigroupCongruence],0,COM_FUN(20));
BindGlobal("FreeMonoidNatHomByGeneratorsNC",COM_FUN(21));
InstallMethod(NaturalHomomorphismByGenerators,"for a free monoid and monoid",true,[IsFreeMonoid,IsMonoid and HasGeneratorsOfMagmaWithOne],0,COM_FUN(22));
InstallMethod(NaturalHomomorphismByGenerators,"for an fp monoid and monoid",true,[IsFpMonoid,IsMonoid and HasGeneratorsOfMonoid],0,COM_FUN(23));
InstallMethod(IsomorphismFpSemigroup,"for an fp monoid",true,[IsFpMonoid],0,COM_FUN(24));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/fpmon.gi"

#F  file="lib/rwssmg.gi" crc=-84235945
RANK_FILTER_LIST  := [ 46043103, 17, 61964984, 20, 46043103, 17, 53185616, 1, 
  61964984, 20, 53185616, 1, 46043103, 17, 5, 1, 49422181, 2, 13950431, 4, 
  41753899, 4, 13950431, 4, 47676329, 5, 41753899, 4, 47676329, 5, 13950431, 
  4, 41753899, 4, 13950431, 4, 41753899, 4 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/rwssmg.gi", -84235945 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/rwssmg.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/rwssmg.gi");
elif COM_RESULT = 3  then
Revision.rwssmg_gi:="@(#)$Id: rwssmg.gi,v 4.19.2.2 2006/02/27 12:08:28 sal Exp $";
BindGlobal("ReducedConfluentRwsFromKbrwsNC",COM_FUN(1));
InstallMethod(ReducedConfluentRewritingSystem,"for an fp semigroup",true,[IsFpSemigroup],0,COM_FUN(2));
InstallMethod(ReducedConfluentRewritingSystem,"for an fp monoid",true,[IsFpMonoid],0,COM_FUN(3));
InstallOtherMethod(ReducedConfluentRewritingSystem,"for an fp semigroup and an ordering on the underlying free semigroup",true,[IsFpSemigroup,IsOrdering],0,COM_FUN(4));
InstallOtherMethod(ReducedConfluentRewritingSystem,"for an fp monoid and an ordering on the underlying free monoid",true,[IsFpMonoid,IsOrdering],0,COM_FUN(5));
InstallOtherMethod(ReducedConfluentRewritingSystem,"for an fp semigroup and an order on the underlying free semigroup",true,[IsFpSemigroup,IsFunction],0,COM_FUN(6));
InstallMethod(IsConfluent,"for a monoid or a semigroup rewriting system",true,[IsRewritingSystem],0,COM_FUN(7));
InstallMethod(ViewObj,"for a semigroup rewriting system",true,[IsRewritingSystem and IsBuiltFromSemigroup],0,COM_FUN(8));
InstallMethod(ViewObj,"for a monoid rewriting system",true,[IsRewritingSystem and IsBuiltFromMonoid],0,COM_FUN(9));
InstallGlobalFunction(ReduceLetterRepWordsRewSys,REDUCE_LETREP_WORDS_REW_SYS);
InstallGlobalFunction(ReduceWordUsingRewritingSystem,COM_FUN(10));
InstallMethod(ReducedForm,"for a semigroup rewriting system and a word on the underlying free semigroup\
",true,[IsRewritingSystem and IsBuiltFromSemigroup,IsAssocWord],0,COM_FUN(11));
InstallMethod(ReducedForm,"for a monoid rewriting system and a word on the underlying free monoid",true,[IsRewritingSystem and IsBuiltFromMonoid,IsAssocWord],0,COM_FUN(12));
InstallMethod(FreeSemigroupOfRewritingSystem,"for a semigroup rewriting system",true,[IsRewritingSystem and IsBuiltFromSemigroup],0,COM_FUN(13));
InstallMethod(FreeMonoidOfRewritingSystem,"for a monoid rewriting system",true,[IsRewritingSystem and IsBuiltFromMonoid],0,COM_FUN(14));
InstallOtherMethod(GeneratorsOfRws,"for a monoid rewriting system",true,[IsRewritingSystem and IsBuiltFromSemigroup],0,COM_FUN(15));
InstallOtherMethod(GeneratorsOfRws,"for a monoid rewriting system",true,[IsRewritingSystem and IsBuiltFromMonoid],0,COM_FUN(16));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/rwssmg.gi"

#F  file="lib/kbsemi.gi" crc=61624524
RANK_FILTER_LIST  := [ 52456166, 6, 52456166, 6, 8193, 2, 16984416, 8, 
  44787884, 8, 52456166, 6, 1343114, 2, 53185616, 1, 37748707, 2, 53185616, 
  1, 46043103, 17, 53185616, 1, 61964984, 20, 53185616, 1, 46043103, 17, 5, 
  1, 61964984, 20, 5, 1, 61964984, 20, 46043103, 17, 41753899, 4, 13950431, 
  4, 52456165, 5, 52456165, 5, 52456165, 5, 52456165, 5, 48458469, 5, 
  20655001, 5, 52456165, 5, 52456165, 5, 52456165, 5 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/kbsemi.gi", 61624524 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/kbsemi.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/kbsemi.gi");
elif COM_RESULT = 3  then
Revision.kbsemi_gi:="@(#)$Id: kbsemi.gi,v 4.36.2.1 2005/11/26 06:58:59 gap Exp $";
DeclareRepresentation("IsKnuthBendixRewritingSystemRep",IsComponentObjectRep,["family","tzrules","pairs2check","reduced","ordering"]);
InstallGlobalFunction(CreateKnuthBendixRewritingSystem,COM_FUN(1));
InstallMethod(ReduceRules,"for a Knuth Bendix rewriting system",true,[IsKnuthBendixRewritingSystem and IsKnuthBendixRewritingSystemRep and IsMutab\
le],0,COM_FUN(2));
InstallOtherMethod(AddRuleReduced,"for a Knuth Bendix rewriting system and a rule",true,[IsKnuthBendixRewritingSystem and IsMutable and IsKnuthBendixRewritingSystemR\
ep,IsList],0,COM_FUN(3));
InstallGlobalFunction(MakeKnuthBendixRewritingSystemConfluent,COM_FUN(4));
BindGlobal("KBOverlaps",COM_FUN(5));
BindGlobal("GKB_MakeKnuthBendixRewritingSystemConfluent",COM_FUN(6));
GAPKB_REW.MakeKnuthBendixRewritingSystemConfluent:=GKB_MakeKnuthBendixRewritingSystemConfluent;
InstallMethod(MakeConfluent,"for Knuth Bendix Rewriting System",true,[IsKnuthBendixRewritingSystem and IsKnuthBendixRewritingSystemRep and IsMutable and IsBuiltFromSemigroup],0,COM_FUN(7));
InstallMethod(MakeConfluent,"for Knuth Bendix Rewriting System",true,[IsKnuthBendixRewritingSystem and IsKnuthBendixRewritingSystemRep and IsMutable and IsBuiltFromMonoid],0,COM_FUN(8));
InstallMethod(IsReduced,"for a Knuth Bendix rewriting system",true,[IsKnuthBendixRewritingSystem and IsKnuthBendixRewritingSystemRep and IsMutab\
le],0,COM_FUN(9));
InstallMethod(KnuthBendixRewritingSystem,"for a family of words of an fp semigroup and on ordering on that family",tru\
e,[IsElementOfFpSemigroupFamily,IsOrdering],0,COM_FUN(10));
InstallMethod(KnuthBendixRewritingSystem,"for a family of words of an fp monoid and on ordering on that family",true,[IsElementOfFpMonoidFamily,IsOrdering],0,COM_FUN(11));
InstallOtherMethod(KnuthBendixRewritingSystem,"for an fp semigroup and an order on the family of words of the underlying fr\
ee semigroup",true,[IsFpSemigroup,IsOrdering],0,COM_FUN(12));
InstallOtherMethod(KnuthBendixRewritingSystem,"for an fp monoid and an order on the family of words of the underlying free \
monoid",true,[IsFpMonoid,IsOrdering],0,COM_FUN(13));
InstallOtherMethod(KnuthBendixRewritingSystem,"for an fp semigroup and a function",true,[IsFpSemigroup,IsFunction],0,COM_FUN(14));
InstallOtherMethod(KnuthBendixRewritingSystem,"for an fp monoid and a function",true,[IsFpMonoid,IsFunction],0,COM_FUN(15));
InstallOtherMethod(KnuthBendixRewritingSystem,"for an fp monoid",true,[IsFpMonoid],0,COM_FUN(16));
InstallOtherMethod(KnuthBendixRewritingSystem,"for an fp semigroup",true,[IsFpSemigroup],0,COM_FUN(17));
InstallMethod(MonoidOfRewritingSystem,"for a Knuth Bendix rewriting system",true,[IsRewritingSystem and IsBuiltFromMonoid],0,COM_FUN(18));
InstallMethod(SemigroupOfRewritingSystem,"for a Knuth Bendix rewriting system",true,[IsRewritingSystem and IsBuiltFromSemigroup],0,COM_FUN(19));
InstallMethod(Rules,"for a Knuth Bendix rewriting system",true,[IsKnuthBendixRewritingSystem and IsKnuthBendixRewritingSystemRep],0,COM_FUN(20));
InstallMethod(TzRules,"for a Knuth Bendix rewriting system",true,[IsKnuthBendixRewritingSystem and IsKnuthBendixRewritingSystemRep],0,COM_FUN(21));
InstallMethod(OrderingOfRewritingSystem,"for a Knuth Bendix rewriting system",true,[IsKnuthBendixRewritingSystem and IsKnuthBendixRewritingSystemRep],0,COM_FUN(22));
InstallMethod(FamilyForRewritingSystem,"for a Knuth Bendix rewriting system",true,[IsKnuthBendixRewritingSystem and IsKnuthBendixRewritingSystemRep],0,COM_FUN(23));
InstallMethod(ViewObj,"for a Knuth Bendix rewriting system",true,[IsKnuthBendixRewritingSystem and IsBuiltFromMonoid],0,COM_FUN(24));
InstallMethod(ViewObj,"for a Knuth Bendix rewriting system",true,[IsKnuthBendixRewritingSystem and IsBuiltFromSemigroup],0,COM_FUN(25));
InstallMethod(ShallowCopy,"for a Knuth Bendix rewriting system",true,[IsKnuthBendixRewritingSystem and IsKnuthBendixRewritingSystemRep],0,COM_FUN(26));
InstallMethod(\=,"for two Knuth-Bendix rewriting systems",IsIdenticalObj,[IsKnuthBendixRewritingSystem and IsKnuthBendixRewritingSystemRep,IsKnuthBendixRewritingSystem and IsKnuthBendixRewritingSystemRep],0,COM_FUN(27));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/kbsemi.gi"

#F  file="lib/tcsemi.gi" crc=64284814
RANK_FILTER_LIST  := [ 67108595, 22, 46043103, 17, 46043103, 17, 67108595, 22 
 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/tcsemi.gi", 64284814 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/tcsemi.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/tcsemi.gi");
elif COM_RESULT = 3  then
Revision.tcsemi_gi:="@(#)$Id: tcsemi.gi,v 4.8 2002/04/15 10:05:24 sal Exp $";
DeclareInfoClass("SemigroupToddCoxeterInfo");
InstallMethod(CosetTableOfFpSemigroup,"for a right congruence on an fp semigroup",true,[IsRightMagmaCongruence],0,COM_FUN(1));
InstallMethod(IsomorphismTransformationSemigroup,"<fp-semigroup>",true,[IsFpSemigroup],0,COM_FUN(2));
InstallMethod(HomomorphismTransformationSemigroup,"for an f.p. semigroup, and a right congruence",true,[IsFpSemigroup,IsRightMagmaCongruence],0,COM_FUN(3));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/tcsemi.gi"

#F  file="lib/adjoin.gi" crc=70203546
RANK_FILTER_LIST  := [ 1985, 1, 1985, 1, 28344021, 4, 7401306, 6, 7401306, 6, 
  7401306, 6, 7401306, 6, 7401306, 6, 7401306, 6, 7401306, 6, 60045706, 14, 
  7401306, 6, 7401306, 6, 7401306, 6 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/adjoin.gi", 70203546 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/adjoin.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/adjoin.gi");
elif COM_RESULT = 3  then
Revision.adjoin_gi:="@(#)$Id: adjoin.gi,v 1.1.2.2 2006/03/03 17:41:10 jamesm Exp $";
InstallMethod(AdjoinedIdentityFamily,[IsFamily],COM_FUN(1));
InstallMethod(AdjoinedIdentityDefaultType,[IsFamily],COM_FUN(2));
InstallMethod(MonoidByAdjoiningIdentityElt,[IsMultiplicativeElement and IsAsso\
ciativeElement],COM_FUN(3));
InstallMethod(\*,IsIdenticalObj,[IsMonoidByAdjoiningIdentityElt,IsMonoidByAdjoiningIdentityElt],COM_FUN(4));
InstallMethod(\<,IsIdenticalObj,[IsMonoidByAdjoiningIdentityElt,IsMonoidByAdjoiningIdentityElt],COM_FUN(5));
InstallMethod(\=,IsIdenticalObj,[IsMonoidByAdjoiningIdentityElt,IsMonoidByAdjoiningIdentityElt],COM_FUN(6));
InstallMethod(One,[IsMonoidByAdjoiningIdentityElt],COM_FUN(7));
InstallMethod(MonoidByAdjoiningIdentity,[IsSemigroup and HasGeneratorsOfSemigr\
oup],COM_FUN(8));
InstallMethod(UnderlyingSemigroupElementOfMonoidByAdjoiningIdentityElt,[IsMonoidByAdjoiningIdentityElt],COM_FUN(9));
InstallMethod(PrintObj,[IsMonoidByAdjoiningIdentityElt],COM_FUN(10));
InstallMethod(ViewObj,[IsMonoidByAdjoiningIdentityElt],COM_FUN(11));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/adjoin.gi"

#F  file="lib/semirel.gi" crc=82907093
RANK_FILTER_LIST  := [ 11831026, 13, 11831026, 13, 11831026, 13, 11831026, 
  13, 11831026, 13, 32309144, 11, 62127694, 11, 64618287, 11, 62758193, 10, 
  62758193, 10, 11819866, 15, 1, 0, 11819866, 15, 1, 0, 11819866, 15, 1, 0, 
  11819866, 15, 1, 0, 11819866, 15, 1, 0, 12220120, 8, 62758193, 10, 1, 0, 
  62758193, 10, 12220120, 8, 12220120, 8, 12220120, 8, 12220120, 8, 1, 0, 
  12220120, 8, 2857929, 22, 2857929, 22, 1, 0, 65617081, 23, 56917627, 23, 
  4718023, 23, 2227430, 23, 39517759, 23, 34465151, 10, 34465151, 10, 
  34465151, 10, 35817086, 10, 15946705, 10, 11831026, 13, 3642843, 10, 
  11831026, 13, 3642843, 10, 11819866, 15, 11831026, 13, 11831026, 13, 
  3642843, 10, 15946705, 10, 35817086, 10, 3642843, 10, 12220120, 8, 
  12220120, 8, 34465151, 10, 3642843, 10, 3642843, 10, 5081830, 16, 43093390, 
  18, 11819866, 15, 47508021, 18, 47508021, 18, 47508021, 18, 47508021, 18, 
  47508021, 18, 11831026, 13, 11831026, 13, 8193, 2, 32589374, 17, 32505602, 
  3, 32589374, 17, 32505602, 3, 32589374, 17, 32589374, 17, 32589374, 17, 
  32505602, 3, 32589374, 17, 32589374, 17, 22628412, 21, 32589374, 17, 
  32589374, 17 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/semirel.gi", 82907093 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/semirel.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/semirel.gi");
elif COM_RESULT = 3  then
Revision.semirel_gi:="@(#)$Id: semirel.gi,v 4.30.2.7 2006/08/22 13:30:29 jamesm Exp $";
InstallMethod(GreensRRelation,"for a semigroup",true,[IsSemigroup],0,COM_FUN(1));
InstallMethod(GreensLRelation,"for a semigroup",true,[IsSemigroup],0,COM_FUN(2));
InstallMethod(GreensJRelation,"for a semigroup",true,[IsSemigroup],0,COM_FUN(3));
InstallMethod(GreensDRelation,"for a semigroup",true,[IsSemigroup],0,COM_FUN(4));
InstallMethod(GreensHRelation,"for a semigroup",true,[IsSemigroup],0,COM_FUN(5));
InstallMethod(ViewObj,"for GreensJRelation",[IsGreensJRelation],COM_FUN(6));
InstallMethod(ViewObj,"for GreensDRelation",[IsGreensDRelation],COM_FUN(7));
InstallMethod(ViewObj,"for GreensHRelation",[IsGreensHRelation],COM_FUN(8));
InstallMethod(\=,"for GreensRelation",[IsGreensRelation,IsGreensRelation],COM_FUN(9));
InstallMethod(GreensRClassOfElement,"for a semigroup",true,[IsSemigroup and Ha\
sIsFinite and IsFinite,IsObject],0,COM_FUN(10));
InstallMethod(GreensLClassOfElement,"for a semigroup",true,[IsSemigroup and Ha\
sIsFinite and IsFinite,IsObject],0,COM_FUN(11));
InstallMethod(GreensHClassOfElement,"for a semigroup",true,[IsSemigroup and Ha\
sIsFinite and IsFinite,IsObject],0,COM_FUN(12));
InstallMethod(GreensDClassOfElement,"for a semigroup",true,[IsSemigroup and Ha\
sIsFinite and IsFinite,IsObject],0,COM_FUN(13));
InstallMethod(GreensJClassOfElement,"for a semigroup",true,[IsSemigroup and Ha\
sIsFinite and IsFinite,IsObject],0,COM_FUN(14));
InstallMethod(CanonicalGreensClass,"for a Green's class",true,[IsGreensClass],\
0,COM_FUN(15));
InstallMethod(ImagesElm,"for a Green's equivalence",true,[IsGreensRelation,IsO\
bject],0,COM_FUN(16));
InstallMethod(Successors,"for a Green's equivalence",true,[IsGreensRelation],0,COM_FUN(17));
InstallMethod(AsSSortedList,"for a Green's class",true,[IsGreensClass],0,COM_FUN(18));
InstallMethod(\=,"for Green's classes",true,[IsGreensClass,IsGreensClass],0,COM_FUN(19));
InstallMethod(Size,"for Green's classes",true,[IsGreensClass],0,COM_FUN(20));
InstallMethod(\in,"membership test of Green's class",true,[IsObject,IsGreensCl\
ass],0,COM_FUN(21));
InstallMethod(EquivalenceRelationPartition,"for a Green's equivalence",true,[I\
sEquivalenceRelation and IsGreensRelation],0,COM_FUN(22));
InstallOtherMethod(EquivalenceClassOfElementNC,"no check",true,[IsEquivalenceRelation and IsGreensRelation,IsObject],0,COM_FUN(23));
InstallMethod(EquivalenceClasses,"for a Green's R-relation",true,[IsEquivalenc\
eRelation and IsGreensRRelation],0,COM_FUN(24));
InstallMethod(EquivalenceClasses,"for a Green's L-relation",true,[IsEquivalenc\
eRelation and IsGreensLRelation],0,COM_FUN(25));
InstallMethod(EquivalenceClasses,"for a Green's H-relation",true,[IsEquivalenc\
eRelation and IsGreensHRelation],0,COM_FUN(26));
InstallMethod(EquivalenceClasses,"for a Green's D-relation",true,[IsEquivalenc\
eRelation and IsGreensDRelation],0,COM_FUN(27));
InstallMethod(EquivalenceClasses,"for a Green's J-relation",true,[IsEquivalenc\
eRelation and IsGreensJRelation],0,COM_FUN(28));
InstallMethod(RClassOfHClass,"for a Green's H-class",true,[IsGreensHClass],0,COM_FUN(29));
InstallMethod(LClassOfHClass,"for a Green's H-class",true,[IsGreensHClass],0,COM_FUN(30));
InstallMethod(DClassOfHClass,"for a Green's H-class",true,[IsGreensHClass],0,COM_FUN(31));
InstallMethod(DClassOfLClass,"for a Green's L-class",true,[IsGreensLClass],0,COM_FUN(32));
InstallMethod(DClassOfRClass,"for a Green's R-class",true,[IsGreensRClass],0,COM_FUN(33));
InstallMethod(GreensRClasses,"for a semigroup",true,[IsSemigroup],0,COM_FUN(34));
InstallOtherMethod(GreensRClasses,"for a Green's D-class",true,[IsGreensDClass\
],0,COM_FUN(35));
InstallOtherMethod(GreensLClasses,"for a semigroup",true,[IsSemigroup],0,COM_FUN(36));
InstallOtherMethod(GreensLClasses,"for a Green's D-class",true,[IsGreensDClass\
],0,COM_FUN(37));
InstallOtherMethod(GreensJClasses,"for a semigroup",true,[IsSemigroup and IsFi\
nite],0,COM_FUN(38));
InstallMethod(GreensDClasses,"for a semigroup",true,[IsSemigroup],0,COM_FUN(39));
InstallMethod(GreensHClasses,"for a semigroup",true,[IsSemigroup],0,COM_FUN(40));
InstallOtherMethod(GreensHClasses,"for a Green's Class",true,[IsGreensDClass],\
0,COM_FUN(41));
InstallOtherMethod(GreensHClasses,"for a Green's Class",true,[IsGreensRClass],\
0,COM_FUN(42));
InstallOtherMethod(GreensHClasses,"for a Green's Class",true,[IsGreensLClass],\
0,COM_FUN(43));
InstallMethod(IsRegularDClass,"for a Green's D class",true,[IsGreensDClass],0,COM_FUN(44));
InstallMethod(IsGreensLessThanOrEqual,"for two Green's  classes",true,[IsGreensClass,IsGreensClass],0,COM_FUN(45));
InstallMethod(IsGroupHClass,"for Green's H-class",true,[IsGreensHClass],0,COM_FUN(46));
InstallMethod(GroupHClassOfGreensDClass,"for a Green's H-class",true,[IsGreensDClass],0,COM_FUN(47));
InstallMethod(EggBoxOfDClass,"for a Green's D class",true,[IsGreensDClass],0,COM_FUN(48));
InstallGlobalFunction(DisplayEggBoxOfDClass,COM_FUN(49));
InstallMethod(DisplayEggBoxesOfSemigroup,"for finite semigroups",[IsTransformationSemigroup],COM_FUN(50));
InstallMethod(FroidurePinSimpleAlg,true,[IsMonoid and HasIsFinite and IsFinite\
],0,COM_FUN(51));
InstallMethod(FroidurePinExtendedAlg,"for a semigroup",true,[IsSemigroup and H\
asIsFinite and IsFinite],0,COM_FUN(52));
InstallMethod(GreensRRelation,"for free semigroups",true,[IsSemigroup and IsFreeSemigroup],0,COM_FUN(53));
InstallMethod(GreensLRelation,"for free semigroups",true,[IsSemigroup and IsFreeSemigroup],0,COM_FUN(54));
InstallMethod(GreensJRelation,"for free semigroups",true,[IsSemigroup and IsFreeSemigroup],0,COM_FUN(55));
InstallMethod(GreensDRelation,"for free semigroups",true,[IsSemigroup and IsFreeSemigroup],0,COM_FUN(56));
InstallMethod(GreensHRelation,"for free semigroups",true,[IsSemigroup and IsFreeSemigroup],0,COM_FUN(57));
InstallMethod(SemigroupHomomorphismByImagesNC,"for a semigroup, semigroup, lis\
t",true,[IsSemigroup,IsSemigroup,IsList],0,COM_FUN(58));
InstallMethod(ImagesRepresentative,"for semigroup homomorphism by images",FamS\
ourceEqFamElm,[IsSemigroupHomomorphism and IsSemigroupHomomorphismByImagesRep,\
IsMultiplicativeElement],COM_FUN(59));
InstallMethod(PreImagesRepresentative,"for semigroup homomorphism by images",F\
amRangeEqFamElm,[IsSemigroupHomomorphism and IsSemigroupHomomorphismByImagesRe\
p,IsMultiplicativeElement],COM_FUN(60));
InstallMethod(ViewObj,"for semigroup homomorphism by images",[IsSemigroupHomomorphism and IsSemigroupHomomorphismByImagesRep],COM_FUN(61));
InstallMethod(PrintObj,"for semigroup homomorphism by images",[IsSemigroupHomomorphism and IsSemigroupHomomorphismByImagesRep],COM_FUN(62));
InstallMethod(ImagesElm,"for semigroup homomorphism by images",FamSourceEqFamElm,[IsSemigroupHomomorphism and IsSemigroupHomomorphismByImage\
sRep,IsMultiplicativeElement],COM_FUN(63));
InstallMethod(CompositionMapping2,"for semigroup homomorphism by images",[IsSemigroupHomomorphism and IsSemigroupHomomorphismByImagesRep,IsSemigroupHo\
momorphism and IsSemigroupHomomorphismByImagesRep],0,COM_FUN(64));
InstallMethod(InverseGeneralMapping,"for semigroup homomorphism by images",[Is\
SemigroupHomomorphism and IsSemigroupHomomorphismByImagesRep and IsInjective a\
nd IsSurjective],0,COM_FUN(65));
InstallMethod(\=,"for semigroup homomorphism by images",IsIdenticalObj,[IsSemi\
groupHomomorphism and IsSemigroupHomomorphismByImagesRep,IsSemigroupHomomorphi\
sm and IsSemigroupHomomorphismByImagesRep],0,COM_FUN(66));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/semirel.gi"

#F  file="lib/semitran.gi" crc=98116075
RANK_FILTER_LIST  := [ 53296510, 17, 53296510, 17, 5081830, 18, 51241662, 10, 
  58647841, 14, 11831026, 13, 31819882, 18, 11831026, 13, 1, 0, 24653712, 15 
 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/semitran.gi", 98116075 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/semitran.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/semitran.gi");
elif COM_RESULT = 3  then
Revision.semitran_gi:="@(#)$Id: semitran.gi,v 4.11.4.1 2006/08/22 13:42:54 jamesm Exp $";
InstallTrueMethod(IsTransformationMonoid,IsMonoid and IsTransformationCollection);
InstallMethod(IsTransformationMonoid,"for a transformation semigroup",true,[IsTransformationSemigroup and HasGeneratorsOfSemigroup],0,COM_FUN(1));
InstallMethod(AsMonoid,"for transformation semigroup",true,[IsTransformationSemigroup and HasGeneratorsOfSemigroup],0,COM_FUN(2));
InstallTrueMethod(IsFinite,IsTransformationSemigroup);
InstallMethod(DegreeOfTransformationSemigroup,"degree of a trans semigroup",true,[IsTransformationSemigroup],0,COM_FUN(3));
InstallOtherMethod(IsomorphismPermGroup,"for a Green's group H class of a semigroup",true,[IsGreensHClass and IsEquivalenceClass],0,COM_FUN(4));
InstallMethod(IsomorphismTransformationSemigroup,"for a generic semigroup with multiplicative neutral element",true,[IsSemigroup and HasMultiplicativeNeutralElement],0,COM_FUN(5));
InstallMethod(IsomorphismTransformationSemigroup,"for a generic semigroup",true,[IsSemigroup],0,COM_FUN(6));
InstallMethod(IsomorphismTransformationSemigroup,"for a semigroup of general mappings",true,[IsSemigroup and IsGeneralMappingCollection and HasGeneratorsOfSemigroup],0,COM_FUN(7));
InstallGlobalFunction(FullTransformationSemigroup,COM_FUN(8));
InstallMethod(IsFullTransformationSemigroup,"for semigroups",true,[IsSemigroup],0,COM_FUN(9));
InstallMethod(\in,"for full transformation semigroups",true,[IsObject,IsFullTransformationSemigroup],0,COM_FUN(10));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/semitran.gi"

#F  file="lib/reesmat.gi" crc=41397053
RANK_FILTER_LIST  := [ 4734474, 14, 4734474, 14, 4734474, 14, 4734474, 14, 
  8282750, 15, 8282750, 15, 8282750, 15, 8282750, 15, 66221811, 5, 65334742, 
  4, 8282750, 15, 4734474, 14, 8282750, 15, 4734474, 14, 66221811, 5, 
  66221811, 5, 65334742, 4, 65334742, 4, 8268831, 17, 4720555, 16, 66221811, 
  5, 66221811, 5, 65334742, 4, 65334742, 4, 66221811, 5, 66221811, 5, 
  65334742, 4, 65334742, 4, 8268831, 17, 4720555, 16, 62566930, 15, 48943000, 
  15, 3642843, 10 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/reesmat.gi", 41397053 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/reesmat.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/reesmat.gi");
elif COM_RESULT = 3  then
Revision.reesmat_gi:="@(#)$Id: reesmat.gi,v 4.21.2.3 2006/08/22 13:28:18 jamesm Exp $";
DeclareRepresentation("IsReesMatrixSemigroupElementRep",IsComponentObjectRep and IsAttributeStoringRep,rec());
InstallGlobalFunction(ReesMatrixSemigroupElement,COM_FUN(1));
InstallGlobalFunction(ReesZeroMatrixSemigroupElement,COM_FUN(2));
InstallMethod(SandwichMatrixOfReesZeroMatrixSemigroup,"for a subsemigroup of a Rees zero matrix semigroup",[IsSubsemigroupReesZeroMatrixSemigroup],COM_FUN(3));
InstallMethod(RowsOfReesZeroMatrixSemigroup,"for a subsemigroup of a Rees zero matrix semigroup",[IsSubsemigroupReesZeroMatrixSemigroup],COM_FUN(4));
InstallMethod(ColumnsOfReesZeroMatrixSemigroup,"for a subsemigroup of a Rees zero matrix semigroup",[IsSubsemigroupReesZeroMatrixSemigroup],COM_FUN(5));
InstallMethod(UnderlyingSemigroupOfReesZeroMatrixSemigroup,"for a subsemigroup of a Rees zero matrix semigroup",[IsSubsemigroupReesZeroMatrixSemigroup],COM_FUN(6));
InstallMethod(SandwichMatrixOfReesMatrixSemigroup,"for a subsemigroup of a Rees matrix semigroup",[IsSubsemigroupReesMatrixSemigroup],COM_FUN(7));
InstallMethod(RowsOfReesMatrixSemigroup,"for a subsemigroup of a Rees matrix semigroup",[IsSubsemigroupReesMatrixSemigroup],COM_FUN(8));
InstallMethod(ColumnsOfReesMatrixSemigroup,"for a subsemigroup of a Rees matrix semigroup",[IsSubsemigroupReesMatrixSemigroup],COM_FUN(9));
InstallMethod(UnderlyingSemigroupOfReesMatrixSemigroup,"for a subsemigroup of a Rees matrix semigroup",[IsSubsemigroupReesMatrixSemigroup],COM_FUN(10));
InstallGlobalFunction(ReesMatrixSemigroup,COM_FUN(11));
InstallGlobalFunction(ReesZeroMatrixSemigroup,COM_FUN(12));
InstallMethod(PrintObj,"for elements of Rees matrix semigroups",[IsReesMatrixSemigroupElement],COM_FUN(13));
InstallMethod(PrintObj,"for elements of Rees zero matrix semigroups",[IsReesZeroMatrixSemigroupElement],COM_FUN(14));
InstallMethod(ViewObj,"for Rees matrix semigroups",[IsSubsemigroupReesMatrixSemigroup],COM_FUN(15));
InstallMethod(ViewObj,"for Rees zero matrix semigroups",[IsSubsemigroupReesZeroMatrixSemigroup],COM_FUN(16));
InstallMethod(PrintObj,"for Rees matrix semigroups",[IsSubsemigroupReesMatrixSemigroup],COM_FUN(17));
InstallMethod(PrintObj,"for Rees zero matrix semigroups",[IsSubsemigroupReesZeroMatrixSemigroup],COM_FUN(18));
InstallMethod(\*,"for two elements of a Rees matrix semigroup",IsIdenticalObj,[IsReesMatrixSemigroupElement,IsReesMatrixSemigroupElement],0,COM_FUN(19));
InstallMethod(\*,"for two elements of a Rees zero matrix semigroup",IsIdenticalObj,[IsReesZeroMatrixSemigroupElement,IsReesZeroMatrixSemigroupElement],0,COM_FUN(20));
InstallMethod(Size,"for a Rees matrix semigroup",[IsReesMatrixSemigroup],COM_FUN(21));
InstallMethod(Size,"for a Rees zero matrix semigroup",[IsReesZeroMatrixSemigroup],COM_FUN(22));
InstallMethod(\<,"for two elements of a Rees matrix semigroup",IsIdenticalObj,[IsReesMatrixSemigroupElement,IsReesMatrixSemigroupElement],0,COM_FUN(23));
InstallMethod(\<,"for two elements of a Rees zero matrix semigroup",IsIdenticalObj,[IsReesZeroMatrixSemigroupElement,IsReesZeroMatrixSemigroupElement],0,COM_FUN(24));
InstallMethod(\=,"for two elements of a Rees matrix semigroup",IsIdenticalObj,[IsReesMatrixSemigroupElement,IsReesMatrixSemigroupElement],COM_FUN(25));
InstallMethod(\=,"for two elements of a Rees zero matrix semigroup",IsIdenticalObj,[IsReesZeroMatrixSemigroupElement,IsReesZeroMatrixSemigroupElement],COM_FUN(26));
BindGlobal("ReesMatrixSemigroupEnumeratorGetElement",COM_FUN(27));
BindGlobal("ReesZeroMatrixSemigroupEnumeratorGetElement",COM_FUN(28));
BindGlobal("ElementNumber_ReesMatrixSemigroupEnumerator",COM_FUN(29));
BindGlobal("IsBound_ReesMatrixSemigroupEnumerator",COM_FUN(30));
InstallMethod(Enumerator,"for a Rees matrix semigroup",[IsReesMatrixSemigroup],COM_FUN(31));
InstallMethod(Enumerator,"for a Rees zero matrix semigroup",[IsReesZeroMatrixSemigroup],COM_FUN(32));
BindGlobal("BuildIsomorphismReesMatrixSemigroupWithMap",COM_FUN(33));
InstallMethod(IsomorphismReesMatrixSemigroup,"for a finite simple semigroup",[IsSimpleSemigroup],COM_FUN(34));
InstallMethod(IsomorphismReesMatrixSemigroup,"for a finite 0-simple semigroup",[IsZeroSimpleSemigroup],COM_FUN(35));
InstallMethod(AssociatedReesMatrixSemigroupOfDClass,"for d class",[IsGreensDClass],COM_FUN(36));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/reesmat.gi"

#F  file="lib/semiquo.gi" crc=-58365229
RANK_FILTER_LIST  := [ 11831026, 13, 54779227, 32, 33553593, 14 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/semiquo.gi", -58365229 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/semiquo.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/semiquo.gi");
elif COM_RESULT = 3  then
Revision.semiquo_gi:="@(#)$Id: semiquo.gi,v 4.13 2002/04/15 10:05:22 sal Exp $";
InstallGlobalFunction(HomomorphismQuotientSemigroup,COM_FUN(1));
InstallMethod(HomomorphismFactorSemigroup,"for a semigroup and a congruence",true,[IsSemigroup,IsSemigroupCongruence],0,COM_FUN(2));
InstallMethod(ViewObj,"for a quotient semigroup with generators",true,[IsQuotientSemigroup],0,COM_FUN(3));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/semiquo.gi"

#F  file="lib/proto.gi" crc=-108208693
RANK_FILTER_LIST  := [  ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/proto.gi", -108208693 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/proto.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/proto.gi");
elif COM_RESULT = 3  then
Revision.proto_gi:="@(#)$Id: proto.gi,v 4.4 2002/04/15 10:05:13 sal Exp $";
InstallGlobalFunction(ArithmeticElementCreator,COM_FUN(1));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/proto.gi"

#F  file="lib/orders.gi" crc=-80929785
RANK_FILTER_LIST  := [ 1985, 1, 53185616, 1, 1985, 1, 5, 1, 1985, 1, 5, 1, 
  8193, 2, 1985, 1, 5, 1, 1985, 1, 5, 1, 8193, 2, 15961558, 2, 45846379, 2, 
  53185616, 1, 1, 0, 1, 0, 53185616, 1, 1, 0, 1, 0, 53185616, 1, 1, 0, 1, 0, 
  66094711, 2, 66094711, 2, 58600963, 13, 66094711, 2, 8193, 2, 35676996, 18, 
  28346098, 22, 35676996, 18, 58600963, 13, 28346098, 22, 58600963, 13, 
  35676996, 18, 8193, 2, 28346098, 22, 8193, 2, 66094711, 2, 66094711, 2, 
  58600963, 13, 66094711, 2, 8193, 2, 35676996, 18, 28346098, 22, 35676996, 
  18, 58600963, 13, 28346098, 22, 58600963, 13, 35676996, 18, 8193, 2, 
  28346098, 22, 8193, 2, 66094711, 2, 58600963, 13, 8193, 2, 66094711, 2, 
  8193, 2, 8193, 2, 35676996, 18, 58600963, 13, 8193, 2, 28346098, 22, 
  58600963, 13, 8193, 2, 35676996, 18, 8193, 2, 8193, 2, 28346098, 22, 8193, 
  2, 8193, 2, 66094711, 2, 66094711, 2, 58600963, 13, 66094711, 2, 8193, 2, 
  35676996, 18, 28346098, 22, 35676996, 18, 58600963, 13, 28346098, 22, 
  58600963, 13, 35676996, 18, 8193, 2, 28346098, 22, 8193, 2, 66094711, 2, 
  8193, 2, 66094711, 2, 8193, 2, 8193, 2, 66092727, 2, 58600963, 13, 8193, 2, 
  28346098, 22, 8193, 2, 8193, 2, 35676996, 18, 8193, 2, 28346098, 22, 8193, 
  2, 35676996, 18, 8193, 2, 8193, 2, 28346098, 22, 8193, 2, 8193, 2 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/orders.gi", -80929785 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/orders.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/orders.gi");
elif COM_RESULT = 3  then
Revision.orders_gi:="@(#)$Id: orders.gi,v 4.13 2002/04/15 10:05:11 sal Exp $";
InstallMethod(OrderingsFamily,"for a family",true,[IsFamily],0,COM_FUN(1));
InstallMethod(ViewObj,"for an ordering",true,[IsOrdering],0,COM_FUN(2));
BindGlobal("CreateOrderingByLtFunction",COM_FUN(3));
BindGlobal("CreateOrderingByLteqFunction",COM_FUN(4));
InstallMethod(OrderingByLessThanFunctionNC,"for a family and a function",true,[IsFamily,IsFunction],0,COM_FUN(5));
InstallOtherMethod(OrderingByLessThanFunctionNC,"for a family, a function, and a list of properties",true,[IsFamily,IsFunction,IsList],0,COM_FUN(6));
InstallMethod(OrderingByLessThanOrEqualFunctionNC,"for a family and a function",true,[IsFamily,IsFunction],0,COM_FUN(7));
InstallOtherMethod(OrderingByLessThanOrEqualFunctionNC,"for a family, a function, and a list of properties",true,[IsFamily,IsFunction,IsList],0,COM_FUN(8));
InstallMethod(LessThanOrEqualFunction,"for an ordering which has a a LessThanFunction",true,[IsOrdering and HasLessThanFunction],0,COM_FUN(9));
InstallMethod(LessThanFunction,"for an ordering which has a a LessThanOrEqualFunction",true,[IsOrdering and HasLessThanOrEqualFunction],0,COM_FUN(10));
InstallMethod(IsLessThanUnder,"for an ordering ",true,[IsOrdering,IsObject,IsObject],0,COM_FUN(11));
InstallMethod(IsLessThanOrEqualUnder,"for an ordering and two objects ",true,[IsOrdering,IsObject,IsObject],0,COM_FUN(12));
InstallMethod(IsIncomparableUnder,"for an ordering",true,[IsOrdering,IsObject,IsObject],0,COM_FUN(13));
BindGlobal("LexicographicOrderingNC",COM_FUN(14));
InstallOtherMethod(LexicographicOrdering,"for a family of words of a free semigroup or free monoid",true,[IsFamily and IsAssocWordFamily],0,COM_FUN(15));
InstallMethod(LexicographicOrdering,"for a family of words of a free semigroup or free monoid and a list of gener\
ators",true,[IsFamily and IsAssocWordFamily,IsList and IsAssocWordCollection],0,COM_FUN(16));
InstallOtherMethod(LexicographicOrdering,"for a family of words of a free semigroup or free monoid and a list",true,[IsFamily and IsAssocWordFamily,IsList],0,COM_FUN(17));
InstallOtherMethod(LexicographicOrdering,"for a free semigroup",true,[IsFreeSemigroup],0,COM_FUN(18));
InstallOtherMethod(LexicographicOrdering,"for a free monoid",true,[IsFreeMonoid],0,COM_FUN(19));
InstallOtherMethod(LexicographicOrdering,"for a free semigroup and a list of generators",IsElmsColls,[IsFreeSemigroup,IsList and IsAssocWordCollection],0,COM_FUN(20));
InstallOtherMethod(LexicographicOrdering,"for a free monoid and a list of generators",IsElmsColls,[IsFreeMonoid,IsList and IsAssocWordCollection],0,COM_FUN(21));
InstallOtherMethod(LexicographicOrdering,"for a free semigroup and a list",true,[IsFreeSemigroup,IsList],0,COM_FUN(22));
InstallOtherMethod(LexicographicOrdering,"for a free monoid and a list",true,[IsFreeMonoid,IsList],0,COM_FUN(23));
BindGlobal("ShortLexOrderingNC",COM_FUN(24));
InstallOtherMethod(ShortLexOrdering,"for a family of words of a free semigroup or free  monoid",true,[IsFamily and IsAssocWordFamily],0,COM_FUN(25));
InstallMethod(ShortLexOrdering,"for a family of words of a free semigroup or free monoid and a list of gener\
ators",true,[IsFamily and IsAssocWordFamily,IsList and IsAssocWordCollection],0,COM_FUN(26));
InstallOtherMethod(ShortLexOrdering,"for a family of free words of a free semigroup or free  monoid and a list",true,[IsFamily and IsAssocWordFamily,IsList],0,COM_FUN(27));
InstallOtherMethod(ShortLexOrdering,"for a free semigroup",true,[IsFreeSemigroup],0,COM_FUN(28));
InstallOtherMethod(ShortLexOrdering,"for a free monoid",true,[IsFreeMonoid],0,COM_FUN(29));
InstallOtherMethod(ShortLexOrdering,"for a free semigroup and a list of generators in the required order",IsElmsColls,[IsFreeSemigroup,IsList and IsAssocWordCollection],0,COM_FUN(30));
InstallOtherMethod(ShortLexOrdering,"for a free monoid and a list of generators in the required order ",IsElmsColls,[IsFreeMonoid,IsList and IsAssocWordCollection],0,COM_FUN(31));
InstallOtherMethod(ShortLexOrdering,"for a free semigroup and a list",true,[IsFreeSemigroup,IsList],0,COM_FUN(32));
InstallOtherMethod(ShortLexOrdering,"for a free monoid and a list",true,[IsFreeMonoid,IsList],0,COM_FUN(33));
InstallGlobalFunction(IsShortLexLessThanOrEqual,COM_FUN(34));
BindGlobal("WeightLexOrderingNC",COM_FUN(35));
InstallMethod(WeightLexOrdering,"for a family of words of a free semigroup or free monoid, a list of generato\
rs and a list of weights",true,[IsFamily and IsAssocWordFamily,IsList and IsAssocWordCollection,IsList],0,COM_FUN(36));
InstallOtherMethod(WeightLexOrdering,"for a family of words of a free semigroup or free monoid, and two lists",true,[IsFamily and IsAssocWordFamily,IsList,IsList],0,COM_FUN(37));
InstallOtherMethod(WeightLexOrdering,"for a free semigroup, a list of generators and a list of weights",true,[IsFreeSemigroup,IsList and IsAssocWordCollection,IsList],0,COM_FUN(38));
InstallOtherMethod(WeightLexOrdering,"for a free monoid, a list of generators and a list of weights",true,[IsFreeMonoid,IsList and IsAssocWordCollection,IsList],0,COM_FUN(39));
InstallOtherMethod(WeightLexOrdering,"for a free semigroup, a list giving ordering on generators and a list of wei\
ghts",true,[IsFreeSemigroup,IsList,IsList],0,COM_FUN(40));
InstallOtherMethod(WeightLexOrdering,"for a free monoid, a list giving ordering on generators and a list of weight\
s",true,[IsFreeMonoid,IsList,IsList],0,COM_FUN(41));
BindGlobal("BasicWreathProductOrderingNC",COM_FUN(42));
InstallOtherMethod(BasicWreathProductOrdering,"for a family of words of a free semigroup or free monoid and a list",true,[IsAssocWordFamily and IsFamily],0,COM_FUN(43));
InstallMethod(BasicWreathProductOrdering,"for a family of words of a free semigroup or free monoid and a list of gener\
ators",true,[IsAssocWordFamily and IsFamily,IsList and IsAssocWordCollection],0,COM_FUN(44));
InstallMethod(BasicWreathProductOrdering,"for a family of words of a free semigroup or free monoid and a list",true,[IsAssocWordFamily and IsFamily,IsList],0,COM_FUN(45));
InstallOtherMethod(BasicWreathProductOrdering,"for a free semigroup",true,[IsFreeSemigroup],0,COM_FUN(46));
InstallOtherMethod(BasicWreathProductOrdering,"for a free monoid",true,[IsFreeMonoid],0,COM_FUN(47));
InstallOtherMethod(BasicWreathProductOrdering,"for a free semigroup and a list of generators",true,[IsFreeSemigroup,IsList and IsAssocWordCollection],0,COM_FUN(48));
InstallOtherMethod(BasicWreathProductOrdering,"for a free monoid and a list of generators",true,[IsFreeMonoid,IsList and IsAssocWordCollection],0,COM_FUN(49));
InstallOtherMethod(BasicWreathProductOrdering,"for a free semigroup and a list",true,[IsFreeSemigroup,IsList],0,COM_FUN(50));
InstallOtherMethod(BasicWreathProductOrdering,"for a free monoid and a list",true,[IsFreeMonoid,IsList],0,COM_FUN(51));
InstallGlobalFunction(IsBasicWreathLessThanOrEqual,COM_FUN(52));
InstallOtherMethod(WreathProductOrdering,"for a family of words of a free semigroup or free monoid and a list",true,[IsAssocWordFamily and IsFamily,IsList],0,COM_FUN(53));
InstallMethod(WreathProductOrdering,"for a family of words of a free semigroup or free monoid and a list",true,[IsAssocWordFamily and IsFamily,IsList,IsList],0,COM_FUN(54));
InstallOtherMethod(WreathProductOrdering,"for a family of associative words, a list of generators and a list with the \
levels of the generators",true,[IsAssocWordFamily,IsList and IsAssocWordCollection,IsList],0,COM_FUN(55));
InstallOtherMethod(WreathProductOrdering,"for a free monoid and a list",true,[IsFreeMonoid,IsList,IsList],0,COM_FUN(56));
InstallOtherMethod(WreathProductOrdering,"for a free semigroup",true,[IsFreeSemigroup,IsList],0,COM_FUN(57));
InstallOtherMethod(WreathProductOrdering,"for a free monoid",true,[IsFreeMonoid,IsList],0,COM_FUN(58));
InstallOtherMethod(WreathProductOrdering,"for a free semigroup and a list",true,[IsFreeSemigroup,IsList,IsList],0,COM_FUN(59));
InstallOtherMethod(WreathProductOrdering,"for a free monoid and a list",true,[IsFreeMonoid,IsList,IsList],0,COM_FUN(60));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/orders.gi"

#F  file="lib/other.gi" crc=-23912072
RANK_FILTER_LIST  := [ 62973024, 33, 67108760, 5 ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/other.gi", -23912072 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/other.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/other.gi");
elif COM_RESULT = 3  then
Revision.other_gi:="@(#)$Id: other.gi,v 4.1 2000/08/17 10:58:08 ahulpke Exp $";
InstallMethod(MagmaInputString,"perm group",true,[IsPermGroup,IsString],0,COM_FUN(1));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/other.gi"

#F  file="lib/gasman.gi" crc=57630443
RANK_FILTER_LIST  := [  ];
RANK_FILTER_COUNT := 1;

#C  load module, file, or complete
COM_RESULT := COM_FILE( "lib/gasman.gi", 57630443 );
if COM_RESULT = fail  then
Error("cannot locate file \"lib/gasman.gi\"");
elif COM_RESULT = 1  then
;
elif COM_RESULT = 2  then
;
elif COM_RESULT = 4  then
READ_CHANGED_GAP_ROOT("lib/gasman.gi");
elif COM_RESULT = 3  then
Revision.gasman_gi:="@(#)$Id: gasman.gi,v 4.1.2.1 2004/04/22 15:30:25 gap Exp $";
InstallGlobalFunction(GasmanStatistics,COM_FUN(1));
InstallGlobalFunction(GasmanMessageStatus,COM_FUN(2));
InstallGlobalFunction(SetGasmanMessageStatus,COM_FUN(3));
InstallGlobalFunction(GasmanLimits,COM_FUN(4));
else
Error("unknown result code ", COM_RESULT );
fi;

#U  unbind temporary variables
Unbind(RANK_FILTER_LIST);
Unbind(RANK_FILTER_COUNT);
Unbind(COM_RESULT);
#E  file="lib/gasman.gi"

